;
/* module-key = 'com.atlassian.pocketknife.featureflags-plugin:pocketknife-feature-flags', location = '/featureflags/feature-manager.js' */
define("featureflags/feature-manager", [
    "exports"
], function(
    exports
    ){

    var json = WRM.data.claim("com.atlassian.pocketknife.featureflags-plugin:pocketknife-feature-flags.feature-flag-data");
    var systemEnabledFeatures = (json && json["enabled-feature-keys"]) || [];
    var featureFlagStates = (json && json["feature-flag-states"]) || {};

    var contains = function (arr, target) {
        return arr.indexOf(target) !== -1;
    };

    /**
     * Checks if the given feature is enabled. If no feature flag is defined with
     * the given feature key, this will fall-back to the default feature manager behaviour (like AJS.DarkFeatures.isEnabled(..))
     * @param featureKey a String, usually of the form "my.feature.key" (NOT "my.feature.key.enabled" or "my.feature.key.disabled")
     * @returns {boolean}
     */
    exports.isFeatureEnabled = function(featureKey){
        var flagState = featureFlagStates[featureKey];

        if(flagState === true){
            // Feature flag is in enabled state, check for (featureKey + ".disabled") to tell us otherwise
            var isSystemNegated = contains(systemEnabledFeatures, featureKey + ".disabled");
            return !isSystemNegated;
        }
        else if(flagState === false){
            // Disabled state, remain disabled unless (featureKey + ".enabled") is present
            var isSystemEnabled = contains(systemEnabledFeatures, featureKey + ".enabled");
            return isSystemEnabled;
        }
        else {
            // There is no flag defined with the given key, fall-back to what the system features say
            return contains(systemEnabledFeatures, featureKey);
        }
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-amd', location = 'js/jira-amd.js' */
/**
 * AMD wrapper for JIRA object
 */

define('dndattachment/JIRA',  function() {
    return JIRA;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-amd', location = 'js/aui-amd.js' */
// amd shim required for JIRA 6.1

define('dndattachment/aui', function() { return AJS; });;
;
/* module-key = 'com.atlassian.plugin.jslibs:moment-2.6.0', location = 'libs/moment/2.6.0/moment-2.6.0.js' */
/////////// Modified by Atlassian ///////////
(function(factory) {
    define('atlassian/libs/moment-2.6.0', function () {
        var env = {};
        factory.call(env);
        return env.moment;
    });
})(function(){
/////// End of Atlassian modification ///////


//! moment.js
//! version : 2.6.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
     Constants
     ************************************/

    var moment,
        VERSION = "2.6.0",
    // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

    // internal storage for language config files
        languages = {},

    // moment internal properties
        momentProperties = {
            _isAMomentObject: null,
            _i : null,
            _f : null,
            _l : null,
            _strict : null,
            _isUTC : null,
            _offset : null,  // optional. Combine with _isUTC
            _pf : null,
            _lang : null  // optional
        },

    // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

    // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

    // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

    // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

    //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

    // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

    // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

    // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

    // format function strings
        formatFunctions = {},

    // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        function printMsg() {
            if (moment.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' && console.warn) {
                console.warn("Deprecation warning: " + msg);
            }
        }
        return extend(function () {
            if (firstTime) {
                printMsg();
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
     Constructors
     ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
     Helpers
     ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function cloneMoment(m) {
        var result = {}, i;
        for (i in m) {
            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                result[i] = m[i];
            }
        }

        return result;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                    m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                        m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                            m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                                    m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                                        -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
     Languages
     ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
     Formatting
     ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
     Parsing
     ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
            case 'Q':
                return parseTokenOneDigit;
            case 'DDDD':
                return parseTokenThreeDigits;
            case 'YYYY':
            case 'GGGG':
            case 'gggg':
                return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
            case 'Y':
            case 'G':
            case 'g':
                return parseTokenSignedNumber;
            case 'YYYYYY':
            case 'YYYYY':
            case 'GGGGG':
            case 'ggggg':
                return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
            case 'S':
                if (strict) { return parseTokenOneDigit; }
            /* falls through */
            case 'SS':
                if (strict) { return parseTokenTwoDigits; }
            /* falls through */
            case 'SSS':
                if (strict) { return parseTokenThreeDigits; }
            /* falls through */
            case 'DDD':
                return parseTokenOneToThreeDigits;
            case 'MMM':
            case 'MMMM':
            case 'dd':
            case 'ddd':
            case 'dddd':
                return parseTokenWord;
            case 'a':
            case 'A':
                return getLangDefinition(config._l)._meridiemParse;
            case 'X':
                return parseTokenTimestampMs;
            case 'Z':
            case 'ZZ':
                return parseTokenTimezone;
            case 'T':
                return parseTokenT;
            case 'SSSS':
                return parseTokenDigits;
            case 'MM':
            case 'DD':
            case 'YY':
            case 'GG':
            case 'gg':
            case 'HH':
            case 'hh':
            case 'mm':
            case 'ss':
            case 'ww':
            case 'WW':
                return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
            case 'M':
            case 'D':
            case 'd':
            case 'H':
            case 'h':
            case 'm':
            case 's':
            case 'w':
            case 'W':
            case 'e':
            case 'E':
                return parseTokenOneOrTwoDigits;
            case 'Do':
                return parseTokenOrdinal;
            default :
                a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
                return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
            // QUARTER
            case 'Q':
                if (input != null) {
                    datePartArray[MONTH] = (toInt(input) - 1) * 3;
                }
                break;
            // MONTH
            case 'M' : // fall through to MM
            case 'MM' :
                if (input != null) {
                    datePartArray[MONTH] = toInt(input) - 1;
                }
                break;
            case 'MMM' : // fall through to MMMM
            case 'MMMM' :
                a = getLangDefinition(config._l).monthsParse(input);
                // if we didn't find a month name, mark the date as invalid.
                if (a != null) {
                    datePartArray[MONTH] = a;
                } else {
                    config._pf.invalidMonth = input;
                }
                break;
            // DAY OF MONTH
            case 'D' : // fall through to DD
            case 'DD' :
                if (input != null) {
                    datePartArray[DATE] = toInt(input);
                }
                break;
            case 'Do' :
                if (input != null) {
                    datePartArray[DATE] = toInt(parseInt(input, 10));
                }
                break;
            // DAY OF YEAR
            case 'DDD' : // fall through to DDDD
            case 'DDDD' :
                if (input != null) {
                    config._dayOfYear = toInt(input);
                }

                break;
            // YEAR
            case 'YY' :
                datePartArray[YEAR] = moment.parseTwoDigitYear(input);
                break;
            case 'YYYY' :
            case 'YYYYY' :
            case 'YYYYYY' :
                datePartArray[YEAR] = toInt(input);
                break;
            // AM / PM
            case 'a' : // fall through to A
            case 'A' :
                config._isPm = getLangDefinition(config._l).isPM(input);
                break;
            // 24 HOUR
            case 'H' : // fall through to hh
            case 'HH' : // fall through to hh
            case 'h' : // fall through to hh
            case 'hh' :
                datePartArray[HOUR] = toInt(input);
                break;
            // MINUTE
            case 'm' : // fall through to mm
            case 'mm' :
                datePartArray[MINUTE] = toInt(input);
                break;
            // SECOND
            case 's' : // fall through to ss
            case 'ss' :
                datePartArray[SECOND] = toInt(input);
                break;
            // MILLISECOND
            case 'S' :
            case 'SS' :
            case 'SSS' :
            case 'SSSS' :
                datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
                break;
            // UNIX TIMESTAMP WITH MS
            case 'X':
                config._d = new Date(parseFloat(input) * 1000);
                break;
            // TIMEZONE
            case 'Z' : // fall through to ZZ
            case 'ZZ' :
                config._useUTC = true;
                config._tzm = timezoneMinutesFromString(input);
                break;
            case 'w':
            case 'ww':
            case 'W':
            case 'WW':
            case 'd':
            case 'dd':
            case 'ddd':
            case 'dddd':
            case 'e':
            case 'E':
                token = token.substr(0, 1);
            /* falls through */
            case 'gg':
            case 'gggg':
            case 'GG':
            case 'GGGG':
            case 'GGGGG':
                token = token.substr(0, 2);
                if (input) {
                    config._w = config._w || {};
                    config._w[token] = input;
                }
                break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                var intVal = parseInt(val, 10);
                return val ?
                    (val.length < 3 ? (intVal > 68 ? 1900 + intVal : 2000 + intVal) : intVal) :
                    (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            }
            else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ?  parseWeekday(w.d, lang) :
                    (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
     Relative Time
     ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
     Week of Year
     ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
     Top Level Functions
     ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = cloneMoment(input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = lang;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
        "moment construction falls back to js Date. This is " +
        "discouraged and will be removed in upcoming major " +
        "release. Please refer to " +
        "https://github.com/moment/moment/issues/1407 for more info.",
        function (config) {
            config._d = new Date(config._i);
        });

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = lang;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
        // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
     Moment Prototype
     ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                    (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                    (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                        units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                            units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                                units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var sod = makeAs(moment(), this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                        diff < 0 ? 'lastDay' :
                            diff < 1 ? 'sameDay' :
                                diff < 2 ? 'nextDay' :
                                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
            this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
                case 'year':
                    this.month(0);
                /* falls through */
                case 'quarter':
                case 'month':
                    this.date(1);
                /* falls through */
                case 'week':
                case 'isoWeek':
                case 'day':
                    this.hours(0);
                /* falls through */
                case 'hour':
                    this.minutes(0);
                /* falls through */
                case 'minute':
                    this.seconds(0);
                /* falls through */
                case 'second':
                    this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        // keepTime = true means only change the timezone, without affecting
        // the local hour. So 5:31:26 +0300 --[zone(2, true)]--> 5:31:26 +0200
        // It is possible that 5:31:26 doesn't exist int zone +0200, so we
        // adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepTime) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    if (!keepTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                            moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this._lang._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.lang().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
            daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
     Duration Prototype
     ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
     Default Lang
     ************************************/


        // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                    (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                            (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
     Exposing Moment
     ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                "Accessing Moment through the global scope is " +
                "deprecated, and will be removed in an upcoming " +
                "release.",
                moment);
        } else {
            globalScope.moment = moment;
        }
    }

    /////////// Modified by Atlassian ///////////
    // CommonJS module is defined
    //if (hasModule) {
    //    module.exports = moment;
    //} else if (typeof define === "function" && define.amd) {
    //    define("moment", function (require, exports, module) {
    //        if (module.config && module.config() && module.config().noGlobal === true) {
    //            // release the global variable
    //            globalScope.moment = oldGlobalMoment;
    //        }
    //
    //        return moment;
    //    });
    //    makeGlobal(true);
    //} else {
    //    makeGlobal();
    //}
    // Bypassing in-library AMD
    makeGlobal();
    /////// End of Atlassian modification ///////

}).call(this);

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.lib.js' */
define('jira/moment/moment.lib', ['atlassian/libs/moment-2.6.0'], function(moment) {
    return moment;
});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.jira.formatter.js' */
define("jira/moment/moment.jira.formatter", ["underscore", "exports"], function(_, exports) {
    "use strict";
    var map = {
        d: "D",       // day
        y: "Y",       // year
        a: "A",       // meridiem
        E: "d",       // day name of week
        u: "d",       // day number of week
        Z: "ZZ",      // RFC 822 time zone
        z: "[GMT]ZZ", // replacing time zone name with offset
        XX: "ZZ",     // ISO 8601 time zone
        XXX: "Z"      // ISO 8601 time zone
    };

    function actuallyTranslate(tmpBuffer) {
        return map[tmpBuffer] || _.reduce(tmpBuffer, function (memo, value) {
            return memo + (map[value] || value);
        }, "");
    }

    function translateSimpleDateFormat(pattern) {
        var inQuote = false;
        var skip = false;
        var tmpBuffer = "";
        var reduction = _.reduce(pattern, function (memo, value, index, list) {
                if (skip) {
                    skip = false;
                }
                else if (value === '\'') {
                    if (tmpBuffer) {
                        memo += actuallyTranslate(tmpBuffer);
                        tmpBuffer = "";
                    }
                    if (list[index + 1] === '\'') {
                        memo += value;
                        skip = true;
                    }
                    else {
                        memo += !inQuote ? "[" : "]";
                        inQuote = !inQuote;
                    }
                }
                else if (inQuote) {
                    memo += value;
                }
                else if (!/[a-zA-Z]/.test(value)) {
                    if (tmpBuffer) {
                        memo += actuallyTranslate(tmpBuffer);
                        tmpBuffer = "";
                    }
                    memo += value;
                }
                else if (!tmpBuffer || tmpBuffer[tmpBuffer.length - 1] === value) {
                    tmpBuffer += value;
                }
                else {
                    memo += actuallyTranslate(tmpBuffer);
                    tmpBuffer = value;
                }
                return memo;
            }, "");
        if (tmpBuffer) {
            reduction += actuallyTranslate(tmpBuffer);
        }
        return reduction;
    }

    exports.translateSimpleDateFormat = translateSimpleDateFormat;
});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.jira.i18n.js' */
/* global WRM */
define("jira/moment/moment.jira.i18n", [
    "jira/moment/moment.lib",
    "jira/moment/moment.jira.formatter",
    "jira/util/data/meta"
], function (moment, formatter, Meta) {

    "use strict";

    var timeUnits = WRM.data.claim("jira.webresources:dateFormatProvider.dateFormat");

    moment.lang("jira", {
        months: timeUnits.months,
        monthsShort: timeUnits.monthsShort,
        weekdays: timeUnits.weekdays,
        weekdaysShort: timeUnits.weekdaysShort,
        weekdaysMin: timeUnits.weekdaysShort,
        longDateFormat: {
            LT: formatter.translateSimpleDateFormat(Meta.get("date-time")),
            L: formatter.translateSimpleDateFormat(Meta.get("date-day")),
            LL: formatter.translateSimpleDateFormat(Meta.get("date-dmy")),
            LLL: formatter.translateSimpleDateFormat(Meta.get("date-complete"))
        },
        meridiem: function (hours) {
            return timeUnits.meridiem[+(hours > 11)];
        },

        calendar: {
            sameDay:  "LLL",
            nextDay:  "LLL",
            nextWeek: "LLL",
            lastDay:  "LLL",
            lastWeek: "LLL",
            sameElse: "LLL"
        },

        // TODO Deprecate?
        relativeTime: {
            future: AJS.format("in {0}", "%s"),
            past: AJS.format("{0} ago", "%s"),
            s: "a few seconds",
            m: "a minute",
            mm: AJS.format("{0} minutes", "%d"),
            h: "an hour",
            hh: AJS.format("{0} hours", "%d"),
            d: "a day",
            dd: AJS.format("{0} days", "%d"),
            M: "a month",
            MM: AJS.format("{0} months", "%d"),
            y: "a year",
            yy: AJS.format("{0} years", "%d")
        }
    });

});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.js' */
/**
 * @fileOverview
 * Pulls in the core Moment.js library, defines JIRA's i18n mappings,
 * then returns a moment instance that always uses the correct i18n setting.
 * See {@link http://momentjs.com/docs/#/i18n/instance-locale/} for details
 * on Moment.js' (changes in its) support for i18n.
 */

/**
 * @module jira/moment
 */
define('jira/moment', ['jira/moment/moment.lib', 'jira/moment/moment.jira.i18n'], function(moment, i18n) {
    return moment;
});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.legacy.js' */
(function() {
    AJS.namespace('JIRA.translateSimpleDateFormat', null, require('jira/moment/moment.jira.formatter').translateSimpleDateFormat);
    AJS.namespace('window.moment', null, require('jira/moment'));
}());
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:shared-utility', location = 'js/ctrlv/time.js' */
define("dndattachment/ctrlv/time", [], function () {
  "use strict";
  return moment;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:shared-utility', location = 'js/ctrlv/base64decode.js' */
// Modified by Atlassian
// Copyright (c) 2013 ethertank, fusionchess
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
define("dndattachment/ctrlv/base64decode", [
    "exports"
], function (
  exports
) {
    "use strict";

    /**
     * Array of bytes to base64 string decoding
     * @param nChr
     * @returns {number}
     */
    function b64ToUint6(nChr) {
        return nChr > 64 && nChr < 91 ?
            nChr - 65
            : nChr > 96 && nChr < 123 ?
            nChr - 71
            : nChr > 47 && nChr < 58 ?
            nChr + 4
            : nChr === 43 ?
            62
            : nChr === 47 ?
            63
            :
            0;
    }

    var base64decode = function (encoded) {
        var sB64Enc = encoded.replace(/[^A-Za-z0-9\+\/]/g, ""),
            nInLen = sB64Enc.length,
            nOutLen = nInLen * 3 + 1 >> 2,
            taBytes = new Uint8Array(nOutLen);

        for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
            nMod4 = nInIdx & 3;
            nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
            if (nMod4 === 3 || nInLen - nInIdx === 1) {
                for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
                    taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
                }
                nUint24 = 0;
            }
        }

        return taBytes;
    };
    /**
     * Decoder of base64 encoded string to a byte array
     * @param encoded
     * @returns {Uint8Array}
     */
    exports.base64decode = base64decode;


    exports.decodeBase64DataUri = function (uri) {
        var separator = ";base64,",
            prefix = uri.slice(0, uri.indexOf(separator)) + separator,
            base64encoded = uri.substring(prefix.length);
        return base64decode(base64encoded);
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:shared-utility', location = 'js/ctrlv/utility.js' */
define("dndattachment/ctrlv/utility", [
    "jquery",
    "underscore",
    "dndattachment/ctrlv/base64decode",
    "dndattachment/ctrlv/time",
    "jira/flag",
    "jira/util/navigator",
    "featureflags/feature-manager",
    "exports"
], function (
  $,
  _,
  base64decode,
  time,
  JIRAFlag,
  Navigator,
  FeatureManager,
  exports
) {
    "use strict";

    /**
     * Determine if a keypress event is a "paste" (the keys differ between platform).
     * @param {Event} event
     * @param {string} [platform] If provided, overrides the value of navigator.platform.
     * @returns {boolean}
     */
    exports.isKeyPasteEvent = function (event, platform) {
        var V_KEY = 86;
        var IS_MAC = ((platform || "").indexOf("Mac") !== -1) || Navigator.isMac();

        return event.which === V_KEY && (IS_MAC ? event.metaKey : event.ctrlKey);
    };

    /**
     * Feature detection, check whether given parameter is a valid clipboard event
     *
     * @param event JQuery Event object
     * @returns {boolean}
     */
    exports.isImagePasteEvent = function (event) {
        if (event && event.clipboardData) {
            // Get the items from the clipboard, scan items and files properties
            var items = _.union(_.toArray(event.clipboardData.items), _.toArray(event.clipboardData.files));
            var hasImage = items.some(function (item) {
                return item.type.indexOf("image") !== -1;
            });
            var hasRtf = items.some(function (item) {
                return item.type.indexOf("rtf") !== -1;
            });
            return hasImage && !hasRtf;
        }
    };

    var getHtmlImagePaste = function (event) {
        if (!event.clipboardData || !event.clipboardData.types || !_.contains(event.clipboardData.types, "text/html")) {
            return;
        }

        var $data = $(event.clipboardData.getData("text/html"));
        if($data.length === 1 && $data.children().length === 0 && $data[0].nodeName.toLowerCase() === "img"){
            return $data[0].src;
        }
        return null;
    };

    exports.getHtmlImagePaste = getHtmlImagePaste;

    /**
     * Detect whether given event comes with html content in its ClipboardData, that contains single image tag
     * @param {Event} event
     * @returns {Boolean}
     */
    exports.isHtmlImagePasteEvent = function(event) {
        return getHtmlImagePaste(event) != null;
    };

    /**
     * Detect whether given event comes with text content in its ClipboardData
     * @param {Event} event
     * @returns {Boolean}
     */
    exports.isTextPasteEvent = function(event) {
        return event.clipboardData.types && (_.contains(event.clipboardData.types, "text/plain") || _.contains(event.clipboardData.types, "text/html"));
    };

    /**
     * Detect whether this element is an/withing contentEditable
     * @param {HTMLElement} element
     * @returns {Boolean}
     */
    exports.isContentEditable = function(element) {
        return  element.contentEditable == "true" || element.contentEditable == "" ||
                (element.contentEditable == "inherit" && $(element).parents().is('[contenteditable=true]'));
    };

    /**
     * Check if provided file name does not contain any of forbidden characters
     * @param {String} fileName
     * @returns {boolean}
     */
    exports.isValidFileName = function(fileName) {
        return !_([
            // characters forbidden by various file systems
            '\\', '/', '\"', ':', '?', '*', '<', '|', '>',
            // wiki markup
            '!'
        ]).any(function(character) {
            return fileName.indexOf(character) > -1;
        });
    };

    /**
     * Get text content from paste event
     * @param {Event} event
     * @returns {String}
     */
    exports.getTextPasteContent = function(event) {
        return event.clipboardData.types && _.contains(event.clipboardData.types, "text/plain") && event.clipboardData.getData("text/plain") || '';
    };

    /**
     * Get text contet from node, pick property which preserves new lines.
     * @param node
     * @returns {String}
     */
    exports.getTextContent = function(node) {
        if (!node) {
            return '';
        } else if (Navigator.isIE() && typeof node.innerText !== "undefined") {
            return node.innerText;
        } else  {
            return $(node).text();
        }
    };

    /**
     * Copy clipboardData from pasteEvent.originalEvent into pasteEvent or create and adapter
     * @param {Event} pasteEvent
     * @returns {Event}
     */
    exports.normalizePasteEvent = function(pasteEvent) {
        if(pasteEvent && pasteEvent.originalEvent && pasteEvent.originalEvent.clipboardData) {
            pasteEvent.clipboardData = pasteEvent.originalEvent.clipboardData;
        }

        // IE case, create small adapter for IE window.clipboardData
        if(pasteEvent && !pasteEvent.clipboardData && window.clipboardData) {
            pasteEvent.clipboardData = {
                files: window.clipboardData.files,
                types: {
                    contains: function(mimeType) {
                        if(mimeType == "text/plain") {
                            return !!window.clipboardData.getData("Text");
                        }
                    }
                },
                getData: function(mimeType) {
                    if(mimeType == "text/plain") {
                        return window.clipboardData.getData("Text");
                    }
                }
            };
        }

        return pasteEvent;
    };

    /**
     * Determine if the current browser is supported.
     * @param {string} [platform] If provided, overrides the value of navigator.platform.
     * @returns {boolean}
     */
    exports.browserIsSupported = function (platform) {
        var isMac = ((platform || "").indexOf("Mac") !== -1) || Navigator.isMac();
        var isSafari = Navigator.isSafari();

        // Safari isn't supported because it supports neither the HTML5 approach nor the Java applet approach.
        return !(isMac && isSafari);
    };

    /**
     * Determine wheter the current browser supports paste natively.
     * @returns {boolean}
     */
    exports.browserIsNativePaste = function () {
        return Navigator.isChrome() || Navigator.isSafari();
    };

    /**
     * Determine whether the unified attachments dark feature is enabled.
     * @returns {boolean}
     */
    exports.isUnifiedAttachmentsEnabled = function() {
        return FeatureManager.isFeatureEnabled("jira.unified.attachments");
    };

    /**
     * Determine whether the issuePasteDisabled dark feature is enabled.
     * @returns {boolean}
     */
    exports.isIssuePasteDisabledEnabled = function() {
        return FeatureManager.isFeatureEnabled("com.atlassian.plugins.jira.screenshot.issuePasteDisabled");
    };

    /**
     * Determine whether $pasteTarget is an input element and that it is a wiki textfield
     * @returns {boolean}
     */
    exports.isWikiTextfield = function ($pasteTarget) {
        return $pasteTarget.is(':input') && $pasteTarget.hasClass("wiki-textfield")
    };

    /**
     * Determine whether the element is the summary input field
     * @returns {boolean}
     */
    var _isSummaryField = function ($pasteTarget) {
        return $pasteTarget.is('input#summary');
    };

    /**
     * Append the given text content (if not null) to either the summary field or to a wiki textfield
     * @param content to be appended
     * @param pasteTarget element that will have the value updated
     * @param selectionStart
     * @param selectionEnd
     */
    var insertToInput = function (content, pasteTarget, selectionStart, selectionEnd) {
        var $pasteTarget = $(pasteTarget);

        // bail if pasteTarget is not a valid field or if no content was passed in
        if( !(exports.isWikiTextfield($pasteTarget) || _isSummaryField($pasteTarget)) || !content) {
            return;
        }

        if(!$pasteTarget.is(':focus')) {
            // This is a workaround for the case where the textfield is not focused (only needed for some browsers).
            // This ensures the cursor moves to the end of the text.
            $pasteTarget.one('focus', function() {
                var pasteTarget = $pasteTarget[0];
                pasteTarget.selectionStart = pasteTarget.selectionEnd = selectionStart + content.length;
            });
        }

        var value = $pasteTarget.val();
        var prefix = value.substring(0, selectionStart);
        var suffix = value.substring(selectionEnd, value.length);

        // wiki editor maintains its own history buffer, it helps us in some browser(Safari, IE)
        var wikiEditor = $pasteTarget.data("wikiEditor");
        if(wikiEditor && wikiEditor.undoRedoEl && _.isFunction(wikiEditor.undoRedoEl.recordHistoryItem)) {
            wikiEditor.undoRedoEl.recordHistoryItem();
        }

        $pasteTarget.val(prefix + content + suffix);

        // trigger input for dirty form handlers if there are any
        $pasteTarget.trigger("input");

        pasteTarget.selectionStart = pasteTarget.selectionEnd = selectionStart + content.length;

        if(wikiEditor && wikiEditor.undoRedoEl && _.isFunction(wikiEditor.undoRedoEl.updateCurrent)) {
            wikiEditor.undoRedoEl.updateCurrent();
        }
    };

    /**
     * Insert content into textfield at its current selection
     * @param {String} content
     * @param {HTMLElement} textfield
     * @param {Number} selectionStart current selection start
     * @param {Number} selectionEnd current selection end
     */
    exports.insertToInput = insertToInput;

    exports.getMarkup = function(fileName) {
        var animatedImageFileTypes = [
            'gif'
        ];
        var regularImageFileTypes = [
            'bmp',
            'jpeg',
            'jpg',
            'png'
        ];
        var nameParts = fileName.split('.');
        var fileType = nameParts[nameParts.length - 1].toLowerCase();
        if (_.contains(animatedImageFileTypes, fileType)) {
            return '!' + fileName + '!';
        } else if (_.contains(regularImageFileTypes, fileType)) {
            return '!' + fileName + '|thumbnail!';
        } else {
            return '[^' + fileName + ']';
        }
    };

    /**
     * Wrap fileName into wiki markup and insert it into textfield at its current selection
     * @param {String} fileName
     * @param {HTMLElement} pasteTarget
     * @param {Number} selectionStart current selection start
     * @param {Number} selectionEnd current selection end
     */
    exports.insertWikiMarkup = function (fileName, pasteTarget, selectionStart, selectionEnd) {
        var markup = exports.getMarkup(fileName);
        if (markup) {
            // Add a space before and after so that it will display properly if the user forgets to add spaces
            markup = " " + markup + " ";
            insertToInput(markup, pasteTarget, selectionStart, selectionEnd);
        }
    };

    /**
     * Load image from given source
     * @param imageSrc
     * @returns {$.Deferred}
     */
    exports.loadImage = function (imageSrc) {
        var deferred = new $.Deferred();

        var image = new Image();
        image.setAttribute("crossOrigin", "anonymous");
        image.onload = function() {
            deferred.resolve(image);
        };
        image.onerror = deferred.reject.bind(deferred);
        image.src = imageSrc;

        // maybe it was already loaded (from cache)
        if(image.width > 0 && image.height > 0) {
            deferred.resolve(image);
        }

        return deferred;
    };

    /**
     * Convert image to blob or return null when it is not possible
     * @param image
     * @returns {Blob}
     */
    exports.convertImageToBlob = function(image) {
        // off screen canvas and try feature detection
        var canvas = $('<canvas>').attr("width", image.width).attr("height", image.height)[0];
        canvas.getContext('2d').drawImage(image, 0, 0);
        try {
            if(canvas.mozGetAsFile) {
                return canvas.mozGetAsFile("image/png");
            }

            if(canvas.toDataURL) {
                return new Blob([base64decode.decodeBase64DataUri(canvas.toDataURL("image/png"))], { type: "image/png" });
            }
        } catch(e) {
            // in case of any exceptions (security, malformed uri etc)
            return null;
        }
    };

    /**
     * Convert a blob into an image
     * @param blob
     * @param imageName
     * @return {File}
     */
    exports.convertBlobToImage = function(blob, imageName) {
        var file = new Blob([blob.slice()], { type: blob.type });
        file.lastModifiedDate = new Date();
        file.name = imageName;
        return file;
    };

    /**
     * Try to drop image file to element and return true if the event was actually consumed
     * @param {Blob} file
     * @param {jQuery} element
     * @returns {Boolean} Returns true if drop was actually consumed
     */
    exports.dropFileToElement = function(file, $element) {
        var fileName = file.name;
        if(!fileName) {
            fileName = this.generateFileName();
            file.name = fileName + ".png";
        }
        var event = $.Event("drop", {dataTransfer: {files: [file]}});

        var result = false;
        $(document).on('dropHandled.dropFileToElement', function() {
            result = true;
        });
        $element.trigger(event);
        $(document).off('.dropFileToElement');
        return result;
    };

    exports.generateFileName = function() {
        return "image-" + time().format("YYYY-MM-DD-HH-mm-ss-SSS");
    };

    exports.getCurrentIssueId = function() {
        return JIRA.Issues.Api.getSelectedIssueId();
    };

    exports.showErrorMsg = function(title, message){
        JIRAFlag.showErrorMsg(title, message);
    };

    /**
     * Create Blob from file with same mime type and copied file.name.
     * This is required, because we want to pass file with modified name in drop event and name property of File is read only
     * @param {File} file
     * @returns {Blob}
     */
    exports.createBlobFromFile = function(file) {
        var fileBlob = new Blob([file.slice()], { type: file.type });
        fileBlob.name = file.name;
        return fileBlob;
    };

    /**
     * Check whether a drag event contains files. To be used during dragover/dragenter events to determine whether
     * we should show the dropzone or not. If dataTransfer.types is not supported (only IE) just returns true.
     * This doesn't work completely on Firefox, since they count dragging an image element from within the browser
     * as a 'file'.
     * @param event
     * @returns {boolean}
     */
    exports.dragEventContainsFiles = function (event) {
        // If we can't check the types, assume it does contain files.
        if (!event.dataTransfer || !event.dataTransfer.types) {
            return true;
        }

        // Behaviour
        // Mozilla: types = DOMStringList and contains "Files" even when a file is not dragging. It contains "application/x-moz-file" when a file is actually dragging
        // IE: types = DOMStringList and contains "Files" when dragging  a file
        // Chrome + Safari: types = Array and contains "Files" when dragging a file

        var types = event.dataTransfer.types;

        if (Navigator.isMozilla()) {
            return types.contains("application/x-moz-file");
        }

        // using a standard iterator as it works for both Array and DOMStringList
        for (var i = 0; i < types.length; i++) {
            if (types[i] === "Files") {
                return true;
            }
        }

        return false;
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/Configuration.js' */
define("dndattachment/util/Configuration", function() {
    var dataKey = "com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone.";

    function getWRMData(key) {
        return _.isFunction(WRM.data) ? WRM.data(key) : WRM.data.claim(key);
    }

    return {
        getWRM: function(key) {
            return getWRMData(dataKey + key);
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/DataTransfer.js' */
define("dndattachment/util/DataTransfer", ['jquery'], function ($) {
    return Class.extend({
        init: function(_dataTransfer) {
            this._dataTransfer = _dataTransfer;
        },

        getFiles: function() {
            var files = this._dataTransfer.files;
            var items = this._dataTransfer.items;

            if(items && items.length > 0) {
                if(_.any(items, function(item) { return !!item.webkitGetAsEntry; })) {
                    return this.readEntries(items);
                }
            }

            if(files && files.length > 0) {
                return this.readFiles(this._dataTransfer.files)
            } else {
                return new $.Deferred().reject();
            }
        },

        readFiles: function(files) {
            var result = new $.Deferred();

            $.when.apply(window, _.map(files, function(file) {
                var deferred = new $.Deferred();

                var noExtension = !file.name.match(/\.([a-z0-9]+)$/i);

                // if there is no extension, we rely on a fact that underlying implementation
                // will throw permission denied on fopen call for directory path
                // typical candidates for directory are paths without extension at the end
                // and also file.size 8192, 4096 and below 1024(Mac OS X)
                if(noExtension && (file.size <= 8192) || file.size == 8192 || file.size == 4096 || file.size <= 1024) {
                    this.readFileAsText(file).fail(function() {
                        files = _(files).without(file);
                    }).always(deferred.resolve.bind(deferred));
                } else {
                    deferred.resolve();
                }

                return deferred;
            }.bind(this))).always(function() {
                result.resolve(files);
            });

            return result;
        },

        readFileAsText: function(file) {
            var result = new $.Deferred();

            var reader = new FileReader();
            reader.onload = function() {
                result.resolve(this.result);
            };
            reader.onerror = function() {
                result.reject(this.error);
            };

            reader.readAsText(file);

            return result;
        },

        readEntries: function(items) {
            var result = new $.Deferred();

            // if dropped item is a file or a directory, item.kind === "file"
            items = _.filter(items, function(item){
                return item.kind === "file";
            });

            $.when.apply(window, _.map(items, function (item) {
                return this.readEntry(item.webkitGetAsEntry(), item);
            }.bind(this))).then(function() {
                result.resolve(_.union.apply(_, arguments));
            }, result.reject.bind(result));

            return result;
        },

        readEntry: function(entry, item) {
            var result = new $.Deferred();

            if(entry.isFile) {
                if(item && item.getAsFile) {
                    result.resolve([item.getAsFile()]);
                } else {
                    entry.file(function(file) {
                        result.resolve([file]);
                    });
                }
            } else if(entry.isDirectory) {
                entry.createReader().readEntries(function(entries) {
                    var files = [];

                    $.when.apply(window, _.map(entries, function(entry) {
                        return this.readEntry(entry).then(function(entryFiles) {
                            return files.push.apply(files, entryFiles);
                        });
                    }.bind(this))).always(function() {
                        result.resolve(files);
                    });
                }.bind(this));
            }

            return result;
        }
    })
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/FileSizeUtil.js' */
/**
 * Ported from com.atlassian.core.util.FileSize
 */

define('dndattachment/util/FileSizeUtil',
function() {
    var KB_SIZE = 1024;
    var MB_SIZE = KB_SIZE * KB_SIZE;

    var KB = " kB";
    var MB = " MB";

    /**
     * Format the size of a file in human readable form.  Anything less than a kilobyte
     * is presented in kilobytes to one decimal place.  Anything between a kilobyte and a megabyte is
     * presented in kilobytes to zero decimal places.  Anything greater than one megabyte is
     * presented in megabytes to two decimal places.
     * <p>
     * eg.
     * <ul>
     *  <li>format(512) -> 0.5 kb
     *  <li>format(1024) -> 1.0 kb
     *  <li>format(2048) -> 2 kb
     *  <li>format(1024 * 400) -> 400 kb
     *  <li>format(1024 * 1024) -> 1024 kb
     *  <li>format(1024 * 1024 * 1.2) -> 1.20 Mb
     *  <li>format(1024 * 1024 * 20) -> 20.00 Mb
     * </ul>
     *
     * @param   filesize  The size of the file in bytes.
     * @return  The size in human readable form.
     */
    function format(filesize) {
        // TODO: filesize = 1024 gives "1.0 kB", but filesize = 1025 gives "1 kB", this is kinda inconsistent.

        if (filesize > MB_SIZE)
        {
            return formatMB(filesize);
        }
        else if (filesize > KB_SIZE)
        {
            return formatKB(filesize);
        }
        else
        {
            return formatBytes(filesize);
        }

    }

    function formatMB(filesize) {
        var mbsize = filesize / MB_SIZE;
        return mbsize.toFixed(2) + MB;
    }

    function formatKB(filesize) {
        var kbsize = Math.round(filesize / KB_SIZE); //format 0 decimal places
        return kbsize + KB;
    }

    function formatBytes(filesize) {
        var mbsize = filesize / KB_SIZE;
        return mbsize.toFixed(1) + KB;
    }

    return {
        format: format
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/AttachmentEvents.js' */
/**
 * A dictionary of attachment related event types that JIRA will fire from time to time.
 * @module jira/util/events/types
 */
define('dndattachment/util/events/types', {
    // Export the event name so listeners don't have to
    ATTACHMENT_FOR_PAGE_RECEIVED: "attachmentForPageReceived"
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-upload', location = 'js/upload/UploadHandler.js' */
/**
 * An executor is what the handler calls to actually execute the upload
 * @typedef {Object} Executor
 *  @function {boolean} isValid(event, args) - returns true if the executor wants to be invoked.
 *  @function {deferred} processFiles(files, attachmentDropZone) - handles the actual processing of the file.
 *  Should return a deferred that properly communicates the outcome
 *  @property {number} weight - the weight of the executor when we loop through them. Higher the number, the earier we check it
 *  @property {string} name - name of the executor. This is used as the 'key' when we register and remove executors.
 */

/**
 * This listens for EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED and handles the uploading of the files.
 * This does not do the actual uploading, just collects the events and pass them along.
 */
define('dndattachment/upload/handler', [
    'jira/util/events',
    'dndattachment/util/events/types',
    'underscore',
    'jquery',
    'dndattachment/ctrlv/utility',
    'exports'
], function(
    Events,
    EventTypes,
    _,
    $,
    Utility,
    exports
) {
    // The list of registered upload executors
    var executorList = [];

    // The current attachmentDropZone that is relevant to us
    var attachmentDropZone;

    /**
     * This method is called to handle the ATTACHMENT_FOR_PAGE_RECEIVED event once it has been triggered by something.
     *
     * @param event - This will be ATTACHMENT_FOR_PAGE_RECEIVED
     * @param args - These are all the arguments that are passed in when the event is thrown. Typically they will
     * contain files, successCallback, failureCallback and alwaysCallback but may contain more things depending on the code
     * that receives the file.
     */
    var handleAttachmentReceived = function(event, args) {
        var uploadResult = $.Deferred();

        //if there's a dialog open, we simulate a drop and let the dialog handle it.
        var JIRADialog = JIRA.Dialog.current;
        if (JIRADialog) {
            AJS.trigger('analytics', { name : 'attach.screenshot.html5.dialogPaste', data : {}});

            var fileBlob = Utility.createBlobFromFile(args.files[0]);
            if(Utility.dropFileToElement(fileBlob, JIRADialog.$form)) {
                uploadResult.resolve([args.files[0].name]);
            }
        }
        else {
            var validExecutor = _.find(executorList, function(executor) {
                return executor.isValid(event, args);
            });
            if(validExecutor) {
                uploadResult = validExecutor.processFiles(args.files, attachmentDropZone);
                if(args.successCallback) {
                    uploadResult.done(args.successCallback);
                }
                if(args.failureCallback) {
                    uploadResult.fail(args.failureCallback);
                }
                if(args.alwaysCallback) {
                    uploadResult.always(args.alwaysCallback);
                }
            }
        }

        uploadResult.done(function(fileNames, noInsertMarkup) {
            if (!noInsertMarkup && args.isWikiTextfieldFocused) {
                var wikiTextfield = args.wikiTextfield;
                _.each(fileNames, function(fileName) {
                    Utility.insertWikiMarkup(fileName, wikiTextfield, wikiTextfield.selectionStart, wikiTextfield.selectionStart);
                });
                if (JIRADialog && args.isPaste) {
                    AJS.trigger('analytics', { name : 'attach.screenshot.html5.dialogPaste.insertWikiMarkup', data : {}});
                }
                // Focus back on the textfield if the executor caused it to lose focus.
                if (!$(args.wikiTextfield).is(":focus")) {
                    setTimeout(function () {
                        args.wikiTextfield.focus();
                    }, 0);
                }
            }
        });
    };

    var isExecutorValid = function(executor) {
        // Check that the executor exists
        if(executor) {
            // Check that the valid methods are defined
            var hasIsValidMethod = typeof executor.isValid !== 'undefined';
            var hasProcessFiles = typeof executor.processFiles !== 'undefined';
            var hasWeight = typeof executor.weight !== 'undefined';
            var hasName = typeof executor.name !== 'undefined';

            return hasIsValidMethod && hasProcessFiles && hasWeight && hasName;
        }
        return false;
    };

    /**
     * This registers an executor for handling the uploads.
     *
     * @param {Executor} executor - The executor to register
     * @returns {Boolean} - true if the registration was successful
     */
    exports.registerExecutor = function(executor) {
        var isValid = isExecutorValid(executor);
        if(isValid) {
            // Prevent duplicate executors
            var list = _.reject(executorList, function (ex) {
                return ex.name === executor.name;
            });

            // Add in the executor
            list.push(executor);

            // Sort by weight
            executorList = _.sortBy(list, function (ex) {
                // Negative weight so that highest numbers are sorted first
                return -ex.weight;
            });
        }
        return isValid;
    };

    /**
     * This unregisters an executor
     *
     * @param {Executor} executor - The executor to register
     */
    exports.unregisterExecutor = function(executor) {
        executorList = _.reject(executorList, function(ex) {
            return ex.name === executor.name;
        });
    };

    /**
     * Initialised the upload handler
     */
    exports.initialize = function() {
        // Handle any attachments that need to be uploaded directly onto the page through the main attachment zone
        Events.bind(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, handleAttachmentReceived);
    };

    /**
     * Remove the upload handler
     */
    exports.disable = function() {
        // Cleanup everything that was done in the initialize method
        Events.unbind(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, handleAttachmentReceived);
    };

    /**
     * Set the attachmentDropZone that should handle incoming attachments
     */
    exports.setAttachmentDropZone = function(dropZone) {
        attachmentDropZone = dropZone;
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-upload', location = 'js/upload/DefaultUploadExecutor.js' */
/**
 * This is the default executor that uploads the files when none of the other registered executors hit
 */
define('dndattachment/upload/default/executor', [
    'jquery',
    'underscore',
    'dndattachment/ctrlv/utility',
    'exports'
], function(
    $,
    _,
    Utility,
    exports
) {
    exports.name = 'Default attachment executor';

    /**
     * The default executor's weight is always 0. As in it is always the lowest thing
     */
    exports.weight = 0;

    /**
     * This executor is always valid
     */
    exports.isValid = function(event, args) {
        return true;
    };

    exports.processFiles = function(files, attachmentDropZone) {
        return attachmentDropZone.uploadFiles(files);
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-base', location = 'js/i18n.js' */
// because almond.js breaks jsI18n transformers

define('dndattachment/i18n', function() {
    var dict = {
        "dnd.attachment.unsupported.browser": "\u041f\u0435\u0440\u0435\u0442\u0430\u0441\u043a\u0438\u0432\u0430\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432 \u0432\u043b\u043e\u0436\u0435\u043d\u0438\u0439 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e \u0442\u043e\u043b\u044c\u043a\u043e \u0432 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u0430\u0445:",
        "dnd.attachment.file.is.too.large": "\u0420\u0430\u0437\u043c\u0435\u0440 \u0444\u0430\u0439\u043b\u0430 \u043f\u0440\u0435\u0432\u044b\u0441\u0438\u043b \u043b\u0438\u043c\u0438\u0442, \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u044b\u0439 \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u043c ({0}).",
        "dnd.attachment.upload.in.progress": "\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u043e\u0436\u0438\u0434\u0430\u0439\u0442\u0435. \u0412\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0430.",
        "dnd.attachment.not.uploaded": function(param) {
            return AJS.format("File \"{0}\" was not uploaded", param)
        },
        "dnd.attachment.unauthorized": "You are not authorized, session has expired or connection is lost.",
        "dnd.attachment.internal.server.error": "An internal error has occurred. Please contact your administrator.",
        "dnd.attachment.upload.aborted": "Upload was aborted.",
        "dnd.attachment.upload.remove": "Remove attachment"

    };
    return function(key) {
        if(dict[key])
            return dict[key];
        else
            throw "Unknown key: "+key;
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-base', location = 'js/TemporaryAttachments.js' */
define('dndattachment/TemporaryAttachments', [], function() {
    var attachments = { };

    return {
        createAttachment: function(id, name, type, file) {
            return {
                id: id,
                name: name,
                type: type,
                file: file
            };
        },

        getAttachment: function(id, name) {
            return attachments[id] || this.createAttachment(id, name);
        },

        putAttachment: function(id, file) {
            return attachments[id] = this.createAttachment(id, file.name, file.type, file);
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-base', location = 'js/Parser.js' */
define('dndattachment/Parser',
    ['dndattachment/aui',
     'jquery'],
function(AJS, $) {
    var PARSED_MARKCLASS = '-dui-type-parsed';
    var contextSelector = '*[duiType]:not(.'+PARSED_MARKCLASS+')';

    function parse(context) {
        var queue = $(context).find(contextSelector).add(context.filter(contextSelector));

        var deferreds = queue.addClass(PARSED_MARKCLASS).map(function(idx, el) {
            var result = new $.Deferred();

            require([$(el).attr('duiType')], function(duiType) {
                if(typeof duiType == "function")
                    result.resolve(new duiType(el));
                else
                    result.reject();
            });

            return result;
        });

        return $.when.apply(window, $.makeArray(deferreds));
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function(e, context, reason) {
        parse(context);
    });

    if($.isReady) {
        parse($('body'));
    } else {
        $(function() {
            parse($('body'));
        });
    }

    return {
        parse: parse
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-base', location = 'js/dropzones/IssueDropZone.js' */
define('dndattachment/dropzones/IssueDropZone', [
        'jquery',
        'jira/flag',
        'dndattachment/Parser',
        'dndattachment/aui',
        'dndattachment/JIRA',
        'dndattachment/i18n',
        'dndattachment/TemporaryAttachments',
        'dndattachment/util/DataTransfer',
        'featureflags/feature-manager',
        'dndattachment/ctrlv/utility'
    ],
    function($,
             Flag,
             Parser,
             AJS,
             JIRA,
             I18n,
             Attachments,
             DataTransfer,
             FeatureManager,
             Utility) {

    var AUTO_DESTROY_DELAY = 5000;
    var INTERNAL_ERROR = ["An internal error has occurred. Please contact your administrator."];

    var IssueDropZone = Class.extend({

        eventGroup: 'issuedropzone',

        progressBarType: 'dndattachment/progressbars/UploadProgressBar',

        init: function(element) {
            this.$node = $(element);

            if(!this.isSupportedBrowser()) {
                return this.renderUnsupported();
            }

            if(this.$node.parents('.mod-content')) {
                this.$node.parents('.mod-content').addClass('issue-drop-zone');
            }

            this.uploadLimit = this.$node.data('upload-limit');
            this.uploadSize = this.$node.data('upload-size');
            this.formToken = this.$node.data('form-token');
            this.attachFileUrl = contextPath + '/secure/AttachFile.jspa';

            this.pendingQueue = [];

            this.render();

            this.queueEvent('init');
        },

        queueTask: function(task) {
            this.pendingQueue.push(task);
            task.always(function() {
                this.pendingQueue.splice(this.pendingQueue.indexOf(task), 1);
            }.bind(this));

            this.markDirty(true);

            // debounce required to make transition -> commit possible
            $.when.apply(window, this.pendingQueue).always(_.debounce(this.checkMarkDirty, false, true).bind(this));
        },

        render: function() {
            this.$node.html(JIRA.Templates.DnDAttachmentPlugin.IssueDropZone({}));

            this.fileInput = this.$node.find('.issue-drop-zone__file');
            this.fileButton = this.$node.find('button.issue-drop-zone__button');

            this.connectListeners();

            JIRA.trace("jira.issue.dnd.issuedropzone.render");
        },

        connectListeners: function() {
            this.fileInput.change(function(event) {
                this.handleFilesReceived(this.fileInput[0].files);
                this.queueEvent('fileInput', { count: this.fileInput[0].files.length });
                this.fileInput.attr('value', null);
            }.bind(this));

            this.fileButton.click(function(e){
                e.preventDefault();
                this.fileInput.click();
            }.bind(this));

            var $dropNode = this.$node.parents('.issue-drop-zone').length > 0 ? this.$node.parents('.issue-drop-zone') : this.$node;
            this.$dropTarget = $dropNode.find('>*').andSelf();

            this.$dropTarget.on('dragover dragenter drop', function(event) {
                event.preventDefault();
                event.stopPropagation();

                $dropNode.addClass('dragover');

                if(event.type == 'drop') {
                    $dropNode.removeClass('dragover');
                    $(document).trigger("dropHandled");

                    var dataTransfer = new DataTransfer(event.dataTransfer);
                    dataTransfer.getFiles().then(function(files) {
                        this.handleFilesReceived(files);
                        this.queueEvent('fileDrop', { count: files.length });
                    }.bind(this));
                }
            }.bind(this));

            this.$dropTarget.on('dragleave', function() {
                $dropNode.removeClass('dragover');
            }.bind(this))
        },

        configureUploadProgressBar: function($progressBar, file) {
            $progressBar.data("upload-size", this.uploadSize).
                data("file", file).
                data("form-token", this.formToken);
        },

        /**
         * It will create progress bar for given file and place it in drop zone
         * @param {File} file An object that comes from input field or drop object
         * @returns {UploadProgressBar}
         */
        createUploadProgressBar: function(file) {
            var $progressBar = $('<div duiType="'+this.progressBarType+'" class="upload-progress-bar"></div>');
            this.configureUploadProgressBar($progressBar, file);

            return Parser.parse($progressBar).then(function(progressBar) {
                this.placeUploadProgressBar($progressBar, progressBar);
                this.handleNewProgressBar(progressBar);
            }.bind(this));
        },

        placeUploadProgressBar: function($progressBar) {
            return $progressBar.insertAfter(this.$node);
        },

        handleNewProgressBar: function(progressBar) {
            // This is to be overridden by parent classes if needed
        },

        // The default behaviour for handling files is to upload them
        handleFilesReceived: function (files) {
            this.uploadFiles(files);
        },

        uploadFiles: function(files) {

            var uploadFilesResult = new $.Deferred();
            var progressBars = [];
            var issueKey = AJS.Meta.get("issue-key");
            var issueLink = AJS.Meta.get("viewissue-permlink");
            // user could be editing the summary field || not editing
            var issueSummary = $("#summary-val input").attr("value") || $("#summary-val").text();
            var issueLinkHTML = JIRA.Templates.DnDAttachmentPlugin.SuccessMessageLink({ issueLink: issueLink, issueKey: issueKey, issueSummary: issueSummary });

            var queue = _.map(files, function(file) {
                var result = new $.Deferred();

                this.createUploadProgressBar(file).then(function(uploadProgressBar) {
                    this.trigger('progressBarInserted', uploadProgressBar);
                    progressBars.push(uploadProgressBar);
                    uploadProgressBar.uploadFile(file, this.uploadLimit)
                        .then(result.resolve.bind(result), result.resolve.bind(result))
                        .done(function() {
                            this.trigger('uploadFinished', uploadProgressBar);
                        }.bind(this))
                        .fail(function(){
                            uploadFilesResult.reject(arguments);
                        });
                }.bind(this));

                return result;
            }.bind(this));

            var uploadQueue = $.when.apply(window, queue);

            uploadQueue.done(function() {
                var fileIDs = _.filter(queue.length == 1 ? [arguments] : arguments, function(result) {
                    return result && result[0] && result[0].id }).map(function(result) {
                    return result[0].id
                });

                if(fileIDs.length == 0) {
                    return;
                }

                this.commitUpload(fileIDs).done(function() {
                    // auto destroy progress bars
                    _.delay(function() {
                        progressBars.some(function(progressBar) {
                            if(progressBar.getAutoDestroy()) {
                                progressBar.destroy();
                                this.queueEvent('autoDestroy')
                            }
                        }.bind(this));
                    }.bind(this), AUTO_DESTROY_DELAY);

                    var successfulUploads = _.filter(progressBars, function(progressBar){
                        return progressBar.result.isResolved();
                    });

                    if(successfulUploads.length == 1){
                        var fileName = successfulUploads[0].getFileName();
                        Flag.showSuccessMsg("", AJS.format("{0} was attached successfully to {1}.", fileName, issueLinkHTML));
                    }
                    else if(successfulUploads.length > 1){
                        Flag.showSuccessMsg("", AJS.format("{0} files were attached successfully to {1}.", successfulUploads.length, issueLinkHTML));
                    }
                    uploadFilesResult.resolve(
                        _.map(successfulUploads, function(successfulUpload) {
                            return successfulUpload.file.name;
                        })
                    );
                }.bind(this)).fail(function(errorMessages, errors) {
                    uploadFilesResult.reject(errorMessages, errors);
                    if(errorMessages) {
                        errorMessages.forEach(function(errorMessage) {
                            progressBars.forEach(function(progressBar) {
                                progressBar.reportError(errorMessage);
                            });
                        });
                    }

                    if(errors) {
                        progressBars.forEach(function(progressBar) {
                            var errorMessage = errors['#' + progressBar.getFileID()] || errors[progressBar.getFileName()];
                            if(errorMessage) {
                                progressBar.reportError(errorMessage);
                            }
                        });
                    }

                    JIRA.trace('jira.issue.dnd.commit.fail');
                });
            }.bind(this));

            this.queueTask(uploadQueue);

            return uploadFilesResult;
        },

        /**
         *
         * @param attachments
         */
        loadAttachments: function(attachments) {
            attachments.forEach(function(attachment) {
                this.createUploadProgressBar(attachment.file).then(function(progressBar) {
                    progressBar.setFileID(attachment.id);
                    progressBar.setFileName(attachment.name);
                    progressBar.setFileSize(attachment.size);
                    progressBar.setProgress(1);
                    progressBar.setFinished();

                    this.trigger('uploadFinished', progressBar);
                }.bind(this));
            }, this);
        },

        commitUpload: function(fileIDs) {
            // By default, do nothing. This method is typically overridden
            return new $.Deferred();
        },

        attachFile: function(fileIDs) {
            var result = new $.Deferred();

            JIRA.SmartAjax.makeRequest({
                type: "POST",
                url: this.attachFileUrl,
                data: {
                    inline: true,
                    id: JIRA.Issue.getIssueId(),
                    filetoconvert: fileIDs,
                    atl_token: atl_token(),
                    formToken: this.formToken
                },
                dataType: "json"
            })
            .done(result.resolve.bind(result))
            .fail(function(jqXHR) {
                try {
                    var response = JSON.parse(jqXHR.responseText);
                    result.reject(response.errorMessages || INTERNAL_ERROR, response.errors);
                } catch(ex) {
                    result.reject(INTERNAL_ERROR);
                }
            });

            return result;
        },

        isSupportedBrowser: function() {
            if ($('html.webkit')[0] || $('html.safari')[0]) {
                if (!(parseFloat($.browser.version) >= 537)) {
                    return false;
                }
            } else {
                if ($('html.mozilla')[0]) {
                    if (!(parseFloat($.browser.version) >= 1.9)) {
                        return false;
                    }
                } else if ($('html.msie')[0]) {
                    if (!(parseFloat($.browser.version) >= 10)) {
                        return false;
                    }
                } else {
                    return false; // we don't support anything else than IE10, Mozilla or WebKit
                }
            }
            return true;
        },

        renderUnsupported: function() {
            this.$node.addClass('issue-drop-zone__not-supported').text(I18n("dnd.attachment.unsupported.browser")).append('<ul><li>FireFox 3.6+</li><li>Chrome 5+</li><li>Safari 5</li></ul>');
        },

        markDirty: function(isDirty) {
            // DirtyForm
            this.$node.addClass(JIRA.DirtyForm.ClassNames.SANCTIONED);
            this.$node.toggleClass(JIRA.DirtyForm.ClassNames.EXEMPT, !isDirty);
            this.$node.attr('value', false);
            this.$node.attr('defaultValue', true);
        },

        checkMarkDirty: function() {
            // all tasks are done, succesful or not
            if(this.pendingQueue.length == 0)
                this.markDirty(false);
        },

        /**
         * Analytics
         */

        queueEvent: function(name, props) {
            AJS.trigger("analytics", { name: 'issue.dnd.attachment.'+this.eventGroup+'.'+name, data: props || {} });
        }

    });

    return IssueDropZone;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:drag-and-drop-attachment-javascript-init', location = 'js/initIssueDropZone.js' */
require(['dndattachment/Parser',
        'jquery',
        'dndattachment/dropzones/IssueDropZone',
        'dndattachment/upload/handler',
        'dndattachment/upload/default/executor',
        'dndattachment/aui',
        'dndattachment/TemporaryAttachments',
        'dndattachment/util/Configuration',
        'dndattachment/util/FileSizeUtil'],
    function (Parser,
              $,
              IssueDropZone,
              uploadHandler,
              defaultUploadExecutor,
              AJS,
              Attachments,
              Config,
              FileSizeUtil) {
        if (!IssueDropZone.prototype.isSupportedBrowser()) {
            return;
        }

        var uploadLimit = Config.getWRM("upload-limit");
        var attachmentDropzone;

        function createDropZoneInContext($context, duiType) {
            var $fileInputList = $context.find('.field-group.file-input-list');

            if ($fileInputList.size() == 0) {
                return;
            }

            // skip if we already have dropzone there
            if ($fileInputList.find('*[duiType*="' + duiType + '"]').length > 0) {
                return;
            }

            var attachments = $fileInputList.find('input[name=filetoconvert]:checked').map(function (idx, el) {
                return Attachments.getAttachment(el.value, $(el).siblings('label').text());
            }).toArray();

            var description = $fileInputList.find('.description:last-child').html();

            // clear contents
            $fileInputList.empty();

            var $dropZone = $(JIRA.Templates.DnDAttachmentPlugin[duiType]({
                uploadLimit: FileSizeUtil.format(uploadLimit),
                jiraAttachmentSize: uploadLimit,
                description: description
            }));

            Parser.parse($dropZone.appendTo($fileInputList)).then(function (dropZone) {
                if (dropZone != null)
                    dropZone.loadAttachments(attachments);
            });
        }

        function createDropZoneInDialog(dialog, duiType) {
            var createDropZone = function () {
                createDropZoneInContext(dialog.$popupContent, duiType);
            };
            if (dialog.$popup && dialog.$popup.is(':visible')) {
                createDropZone();
            } else {
                dialog.onContentReady(createDropZone);
            }
        }

        function createAttachmentsDropZone($context) {
            var $attachmentModule = $context && ($context.attr("id") == "attachmentmodule") && $('.mod-content:not(.issue-drop-zone)', $context);

            if ($attachmentModule && $attachmentModule.size() > 0) {
                if ($context.find('#add-attachments-link').length == 0) {
                    // add attachment link is not there, means user don't have permissions
                    // This attachment link is hidden by this plugin and defined in JIRA
                    return;
                }

                $attachmentModule.addClass('issue-drop-zone');

                var $dropZone = $(JIRA.Templates.DnDAttachmentPlugin.AttachmentsDropZone({
                    uploadLimit: FileSizeUtil.format(uploadLimit),
                    jiraAttachmentSize: uploadLimit
                }));

                Parser.parse($dropZone.prependTo($attachmentModule)).then(function (dropZone) {
                    if (attachmentDropzone) {
                        attachmentDropzone.disconnectContainer();
                    }
                    attachmentDropzone = dropZone;
                    uploadHandler.setAttachmentDropZone(dropZone);
                });
            }
        }

        // Requiring Parser is enough to process all duiType declarations
        // besides that we need to install issue-drop-zone in attachFile and createIssue dialogs
        // each time when they become visible.
        // This is NOT supposed to inject drop zone everywhere.
        var onReady = function () {
            if (JIRA.Dialogs.attachFile) {
                createDropZoneInDialog(JIRA.Dialogs.attachFile, 'AttachFilesDropZone');
            }

            var triggerDialogs = ['create-issue-dialog', 'create-subtask-dialog', 'edit-issue-dialog'];

            var onDialogShow = function (event, $popupContent, dialog) {
                if (_.contains(triggerDialogs, $popupContent.attr('id'))) {
                    createDropZoneInDialog(dialog, 'CreateIssueDropZone');
                }
            };
            $(AJS).on('Dialog.show', onDialogShow);

            // just in case init file was loaded after Dialog.show event
            if (JIRA.Dialog.current) {
                onDialogShow(null, JIRA.Dialog.current.$popup, JIRA.Dialog.current);
            }

            JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
                createDropZoneInContext(context, 'CreateIssueDropZone');

                createAttachmentsDropZone(context);
            });

            var $createIssueForm = $('form#issue-create, form#issue-edit');
            if ($createIssueForm.size() > 0) {
                createDropZoneInContext($createIssueForm, 'CreateIssueDropZone');
            }

            uploadHandler.initialize();
            uploadHandler.registerExecutor(defaultUploadExecutor);
            createAttachmentsDropZone($('#attachmentmodule'));

            var DRAGOVER_CLASS = 'issue-drop-zone-document__dragover';

            $(document).on("dragover dragenter", function () {
                $('body').addClass(DRAGOVER_CLASS);
            });

            $(document).on("dragleave drop dropHandled", function () {
                $('body').removeClass(DRAGOVER_CLASS);
            });
        };

        if ($.isReady) {
            onReady();
        } else {
            AJS.$(onReady);
        }

        // we want dataTransfer property from originalEvent
        $.event.props.push("dataTransfer");
    });;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:soy-templates', location = 'viewissue/attachmentsblock.soy' */
// This file was automatically generated from attachmentsblock.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ViewIssue.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ViewIssue == 'undefined') { JIRA.Templates.ViewIssue = {}; }


JIRA.Templates.ViewIssue.renderAttachments = function(opt_data, opt_ignored) {
  return '' + ((opt_data.viewMode == 'list') ? JIRA.Templates.ViewIssue.fileAttachments(opt_data) : JIRA.Templates.ViewIssue.galleryAttachments(opt_data));
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.renderAttachments.soyTemplateName = 'JIRA.Templates.ViewIssue.renderAttachments';
}


JIRA.Templates.ViewIssue.fileAttachments = function(opt_data, opt_ignored) {
  var output = '<ol id="file_attachments" class="item-attachments" data-sort-key="' + soy.$$escapeHtml(opt_data.sortKey) + '" data-sort-order="' + soy.$$escapeHtml(opt_data.sortOrder) + '">';
  var fileAttachmentList14 = opt_data.attachments;
  var fileAttachmentListLen14 = fileAttachmentList14.length;
  for (var fileAttachmentIndex14 = 0; fileAttachmentIndex14 < fileAttachmentListLen14; fileAttachmentIndex14++) {
    var fileAttachmentData14 = fileAttachmentList14[fileAttachmentIndex14];
    output += JIRA.Templates.ViewIssue.fileAttachment(soy.$$augmentMap(opt_data, {fileAttachment: fileAttachmentData14}));
  }
  output += '</ol>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.fileAttachments.soyTemplateName = 'JIRA.Templates.ViewIssue.fileAttachments';
}


JIRA.Templates.ViewIssue.galleryAttachments = function(opt_data, opt_ignored) {
  var output = '<ol id="attachment_thumbnails" class="item-attachments" data-sort-key="' + soy.$$escapeHtml(opt_data.sortKey) + '" data-sort-order="' + soy.$$escapeHtml(opt_data.sortOrder) + '">';
  var imageAttachmentList25 = opt_data.attachments;
  var imageAttachmentListLen25 = imageAttachmentList25.length;
  for (var imageAttachmentIndex25 = 0; imageAttachmentIndex25 < imageAttachmentListLen25; imageAttachmentIndex25++) {
    var imageAttachmentData25 = imageAttachmentList25[imageAttachmentIndex25];
    output += JIRA.Templates.ViewIssue.imageAttachment(soy.$$augmentMap(opt_data, {imageAttachment: imageAttachmentData25}));
  }
  output += '</ol>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.galleryAttachments.soyTemplateName = 'JIRA.Templates.ViewIssue.galleryAttachments';
}


JIRA.Templates.ViewIssue.fileAttachment = function(opt_data, opt_ignored) {
  return '<li class="attachment-content js-file-attachment' + ((! opt_data.fileAttachment.latest) ? ' earlier-version' : '') + '" data-attachment-id="' + soy.$$escapeHtml(opt_data.fileAttachment.id) + '"' + JIRA.Templates.ViewIssue.renderAttachmentData({issue: opt_data.issue, attachment: opt_data.fileAttachment}) + '>' + ((opt_data.fileAttachment.expandable) ? JIRA.Templates.ViewIssue.zipFileAttachment(opt_data) : '<div class="attachment-thumb"><a href="' + soy.$$escapeHtml(opt_data.baseurl) + '/' + soy.$$escapeHtml('' + opt_data.fileAttachment.attachmentUrl) + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(opt_data.fileAttachment.mimeType) + ':' + soy.$$escapeHtml(opt_data.fileAttachment.fileName) + ':' + soy.$$escapeHtml(opt_data.fullBaseUrl) + '/' + soy.$$escapeHtml('' + opt_data.fileAttachment.attachmentUrl) + '"' + JIRA.Templates.ViewIssue.tagAttachment({attachment: opt_data.fileAttachment}) + '>' + JIRA.Templates.ViewIssue.renderAttachmentIcon(soy.$$augmentMap(opt_data, {mimetype: opt_data.fileAttachment.mimeType})) + '</a></div><dl>' + JIRA.Templates.ViewIssue.renderAttachmentInfo(soy.$$augmentMap(opt_data, {attachment: opt_data.fileAttachment})) + '</dl>') + '</li>';
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.fileAttachment.soyTemplateName = 'JIRA.Templates.ViewIssue.fileAttachment';
}


JIRA.Templates.ViewIssue.zipFileAttachment = function(opt_data, opt_ignored) {
  return '<div class="twixi-block collapsed expander"><div class="twixi-wrap verbose"><a href="#" class="twixi"><span class="icon-default aui-icon aui-icon-small aui-iconfont-expanded"><span>' + soy.$$escapeHtml("Hide") + '</span></span></a><div class="attachment-thumb"><a href="' + soy.$$escapeHtml(opt_data.baseurl) + '/' + soy.$$escapeHtml('' + opt_data.fileAttachment.attachmentUrl) + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(opt_data.fileAttachment.mimeType) + ':' + soy.$$escapeHtml(opt_data.fileAttachment.fileName) + ':' + soy.$$escapeHtml(opt_data.fullBaseUrl) + '/' + soy.$$escapeHtml('' + opt_data.fileAttachment.attachmentUrl) + '"' + JIRA.Templates.ViewIssue.tagAttachment({attachment: opt_data.fileAttachment}) + '>' + JIRA.Templates.ViewIssue.renderAttachmentIcon(soy.$$augmentMap(opt_data, {mimetype: opt_data.fileAttachment.mimeType})) + '</a></div><dl>' + JIRA.Templates.ViewIssue.renderAttachmentInfo(soy.$$augmentMap(opt_data, {attachment: opt_data.fileAttachment})) + '<dd class="zip-contents"><ol><li><div class="attachment-thumb"><img src="' + soy.$$escapeHtml(opt_data.baseurl) + '/images/icons/wait.gif" /></div>' + soy.$$escapeHtml("Extracting archive...") + '</li></ol></dd></dl></div><div class="twixi-wrap concise"><a href="#" class="twixi"><span class="icon-default aui-icon aui-icon-small aui-iconfont-collapsed"><span>' + soy.$$escapeHtml("Show") + '</span></span></a><div class="attachment-thumb"><a href="' + soy.$$escapeHtml(opt_data.baseurl) + '/' + soy.$$escapeHtml('' + opt_data.fileAttachment.attachmentUrl) + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(opt_data.fileAttachment.mimeType) + ':' + soy.$$escapeHtml(opt_data.fileAttachment.fileName) + ':' + soy.$$escapeHtml(opt_data.fullBaseUrl) + '/' + soy.$$escapeHtml('' + opt_data.fileAttachment.attachmentUrl) + '"' + JIRA.Templates.ViewIssue.tagAttachment({attachment: opt_data.fileAttachment}) + '>' + JIRA.Templates.ViewIssue.renderAttachmentIcon(soy.$$augmentMap(opt_data, {mimetype: opt_data.fileAttachment.mimeType})) + '</a></div><dl>' + JIRA.Templates.ViewIssue.renderAttachmentInfo(soy.$$augmentMap(opt_data, {attachment: opt_data.fileAttachment})) + '</dl></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.zipFileAttachment.soyTemplateName = 'JIRA.Templates.ViewIssue.zipFileAttachment';
}


JIRA.Templates.ViewIssue.imageAttachment = function(opt_data, opt_ignored) {
  return '<li class="attachment-content js-file-attachment" draggable="true" data-downloadurl="' + soy.$$escapeHtml(opt_data.imageAttachment.mimeType) + ':' + soy.$$escapeHtml(opt_data.imageAttachment.fileName) + ':' + soy.$$escapeHtml(opt_data.fullBaseUrl) + '/' + soy.$$escapeHtml('' + opt_data.imageAttachment.attachmentUrl) + '"' + JIRA.Templates.ViewIssue.renderAttachmentData({issue: opt_data.issue, attachment: opt_data.imageAttachment}) + '><div class="attachment-thumb"><a href="' + soy.$$escapeHtml(opt_data.baseurl) + '/' + soy.$$escapeHtml('' + opt_data.imageAttachment.attachmentUrl) + '" title="' + soy.$$escapeHtml(opt_data.imageAttachment.fileName) + ' -' + ((opt_data.imageAttachment.latest) ? ' ' + soy.$$escapeHtml("Latest") : '') + ' ' + soy.$$escapeHtml(opt_data.imageAttachment.createdDateTime) + ((opt_data.imageAttachment.authorDisplayName) ? ' - ' + soy.$$escapeHtml(opt_data.imageAttachment.authorDisplayName) : '') + '"' + JIRA.Templates.ViewIssue.tagAttachment({attachment: opt_data.imageAttachment}) + '>' + ((opt_data.imageAttachment.thumbnailUrl != null) ? '<img src="' + soy.$$escapeHtml('' + opt_data.imageAttachment.thumbnailUrl) + '" alt="' + soy.$$escapeHtml(opt_data.imageAttachment.fileName) + '" />' : JIRA.Templates.ViewIssue.renderThumbnailIcon({mimetype: opt_data.imageAttachment.mimeType})) + '</a></div><dl ' + ((! opt_data.imageAttachment.latest) ? 'class="earlier-version"' : '') + '><dt>' + ((opt_data.imageAttachment.deletable) ? '<span class="blender blender-delete"></span><div class="attachment-delete"><a title="' + soy.$$escapeHtml("Delete this attachment") + '" id="del_' + soy.$$escapeHtml(opt_data.imageAttachment.id) + '" href="' + soy.$$escapeHtml(opt_data.baseurl) + '/secure/DeleteAttachment!default.jspa?id=' + soy.$$escapeHtml(opt_data.issue.id) + '&deleteAttachmentId=' + soy.$$escapeHtml(opt_data.imageAttachment.id) + '&from=issue"><span class="icon-default aui-icon aui-icon-small aui-iconfont-delete">' + soy.$$escapeHtml("Delete this attachment") + '</span></a></div>' : '<span class="blender"></span>') + '<a  href="' + soy.$$escapeHtml(opt_data.baseurl) + '/' + soy.$$escapeHtml('' + opt_data.imageAttachment.attachmentUrl) + '" class="attachment-title" title="' + soy.$$escapeHtml(opt_data.imageAttachment.fileName) + ' -' + ((opt_data.imageAttachment.latest) ? ' ' + soy.$$escapeHtml("Latest") : '') + ' ' + soy.$$escapeHtml(opt_data.imageAttachment.createdDateTime) + ((opt_data.imageAttachment.authorDisplayName) ? ' - ' + soy.$$escapeHtml(opt_data.imageAttachment.authorDisplayName) : '') + '"' + JIRA.Templates.ViewIssue.tagAttachment({attachment: opt_data.imageAttachment}) + '>' + soy.$$escapeHtml(opt_data.imageAttachment.fileName) + '</a></dt><dd class="attachment-size">' + soy.$$escapeHtml(opt_data.imageAttachment.fileSize) + '</dd><dd class="attachment-date"><time class="livestamp" datetime="' + soy.$$escapeHtml('' + opt_data.imageAttachment.createdIso8601) + '">' + soy.$$escapeHtml(opt_data.imageAttachment.createdDateTime) + '</time></dd></dl></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.imageAttachment.soyTemplateName = 'JIRA.Templates.ViewIssue.imageAttachment';
}


JIRA.Templates.ViewIssue.renderAttachmentInfo = function(opt_data, opt_ignored) {
  return '<dt class="attachment-title"><a href="' + soy.$$escapeHtml(opt_data.baseurl) + '/' + soy.$$escapeHtml('' + opt_data.attachment.attachmentUrl) + '" title="' + ((opt_data.attachment.latest) ? soy.$$escapeHtml("Latest") + ' ' : '') + ' ' + soy.$$escapeHtml(opt_data.attachment.createdDateTime) + ((opt_data.attachment.authorDisplayName) ? ' - ' + soy.$$escapeHtml(opt_data.attachment.authorDisplayName) : '') + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(opt_data.attachment.mimeType) + ':' + soy.$$escapeHtml(opt_data.attachment.fileName) + ':' + soy.$$escapeHtml(opt_data.fullBaseUrl) + '/' + soy.$$escapeHtml('' + opt_data.attachment.attachmentUrl) + '"' + JIRA.Templates.ViewIssue.tagAttachment(opt_data) + '>' + soy.$$escapeHtml(opt_data.attachment.fileName) + '</a></dt><dd class="attachment-delete">' + ((opt_data.attachment.deletable) ? '<a title="' + soy.$$escapeHtml("Delete this attachment") + '" id="del_' + soy.$$escapeHtml(opt_data.attachment.id) + '" href="' + soy.$$escapeHtml(opt_data.baseurl) + '/secure/DeleteAttachment!default.jspa?id=' + soy.$$escapeHtml(opt_data.issue.id) + '&deleteAttachmentId=' + soy.$$escapeHtml(opt_data.attachment.id) + '&from=issue"><span class="icon-default aui-icon aui-icon-small aui-iconfont-delete">' + soy.$$escapeHtml("Delete this attachment") + '</span></a>' : '<span class="icon"></span>') + '</dd><dd class="attachment-date"><time class="livestamp" datetime="' + soy.$$escapeHtml('' + opt_data.attachment.createdIso8601) + '">' + soy.$$escapeHtml(opt_data.attachment.createdDateTime) + '</time></dd><dd class="attachment-size">' + soy.$$escapeHtml(opt_data.attachment.fileSize) + '</dd><dd class="attachment-author">' + soy.$$escapeHtml(opt_data.attachment.authorDisplayName ? opt_data.attachment.authorDisplayName : '') + '</dd>';
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.renderAttachmentInfo.soyTemplateName = 'JIRA.Templates.ViewIssue.renderAttachmentInfo';
}


JIRA.Templates.ViewIssue.renderAttachmentData = function(opt_data, opt_ignored) {
  return 'data-issue-id="' + soy.$$escapeHtml(opt_data.issue.id) + '"' + ((opt_data.attachment.expandable) ? 'data-attachment-type="expandable"' : (opt_data.attachment.thumbnailUrl != null) ? 'data-attachment-type="image"' : 'data-attachment-type="file"');
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.renderAttachmentData.soyTemplateName = 'JIRA.Templates.ViewIssue.renderAttachmentData';
}


JIRA.Templates.ViewIssue.renderAttachmentLegacyIcon = function(opt_data, opt_ignored) {
  var output = '';
  var fileIconUrl__soy284 = '' + JIRA.Templates.ViewIssue.matchFileIconUrl(opt_data);
  var fileIconAlt__soy286 = '' + JIRA.Templates.ViewIssue.matchFileIconAlt(opt_data);
  output += '<img src="' + soy.$$escapeHtml(fileIconUrl__soy284) + '" height="16" width="16" border="0" alt="' + soy.$$escapeHtml(fileIconAlt__soy286) + '">';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.renderAttachmentLegacyIcon.soyTemplateName = 'JIRA.Templates.ViewIssue.renderAttachmentLegacyIcon';
}


JIRA.Templates.ViewIssue.matchFileIconUrl = function(opt_data, opt_ignored) {
  return soy.$$escapeHtml(opt_data.baseurl) + '/images/icons/attach/' + JIRA.Templates.ViewIssue.matchFileIcon(opt_data);
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.matchFileIconUrl.soyTemplateName = 'JIRA.Templates.ViewIssue.matchFileIconUrl';
}


JIRA.Templates.ViewIssue.matchFileIcon = function(opt_data, opt_ignored) {
  var output = '';
  switch (opt_data.mimetype) {
    case 'application/pdf':
      output += 'pdf.gif';
      break;
    case 'image/gif':
      output += 'image.gif';
      break;
    case 'image/png':
      output += 'image.gif';
      break;
    case 'image/jpeg':
      output += 'image.gif';
      break;
    case 'text/xml':
      output += 'xml.gif';
      break;
    case 'text/html':
      output += 'html.gif';
      break;
    case 'text/plain':
      output += 'text.gif';
      break;
    case 'application/zip':
      output += 'zip.gif';
      break;
    case 'application/x-gzip-compressed':
      output += 'zip.gif';
      break;
    case 'application/msword':
      output += 'word.gif';
      break;
    case 'application/msword-template':
      output += 'word.gif';
      break;
    case 'application/vnd.ms-word.document.macroEnabled.12':
      output += 'word.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
      output += 'word.gif';
      break;
    case 'application/vnd.ms-word.template.macroEnabled.12':
      output += 'word.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.template':
      output += 'word.gif';
      break;
    case 'application/vnd.ms-excel':
      output += 'excel.gif';
      break;
    case 'application/vnd.ms-excel.addin.macroEnabled.12':
      output += 'excel.gif';
      break;
    case 'application/vnd.ms-excel.sheet.binary.macroEnabled.12':
      output += 'excel.gif';
      break;
    case 'application/vnd.ms-excel.sheet.macroEnabled.12':
      output += 'excel.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
      output += 'excel.gif';
      break;
    case 'application/vnd.ms-excel.template.macroEnabled.12':
      output += 'excel.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.template':
      output += 'excel.gif';
      break;
    case 'application/vnd.ms-powerpoint':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.ms-powerpoint.template.macroEnabled.12':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.template':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.ms-powerpoint.addin.macroEnabled.12':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.slideshow':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.ms-powerpoint.presentation.macroEnabled.12':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
      output += 'powerpoint.gif';
      break;
    case 'text/x-java':
      output += 'java.gif';
      break;
    case 'text/x-java-source':
      output += 'java.gif';
      break;
    case 'application/x-java-archive':
      output += 'java.gif';
      break;
    default:
      output += 'file.gif';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.matchFileIcon.soyTemplateName = 'JIRA.Templates.ViewIssue.matchFileIcon';
}


JIRA.Templates.ViewIssue.matchFileIconAlt = function(opt_data, opt_ignored) {
  var output = '';
  switch (opt_data.mimetype) {
    case 'application/pdf':
      output += soy.$$escapeHtml("PDF File");
      break;
    case 'image/gif':
      output += soy.$$escapeHtml("GIF File");
      break;
    case 'image/png':
      output += soy.$$escapeHtml("PNG File");
      break;
    case 'image/jpeg':
      output += soy.$$escapeHtml("JPEG File");
      break;
    case 'text/xml':
      output += soy.$$escapeHtml("XML File");
      break;
    case 'text/html':
      output += soy.$$escapeHtml("HTML File");
      break;
    case 'text/plain':
      output += soy.$$escapeHtml("Text File");
      break;
    case 'application/zip':
      output += soy.$$escapeHtml("Zip Archive");
      break;
    case 'application/x-gzip-compressed':
      output += soy.$$escapeHtml("GZip Archive");
      break;
    case 'application/msword':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/msword-template':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.openxmlformats':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-word.document.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-word.template.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.template':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-excel':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-excel':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-excel.addin.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-excel.sheet.binary.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-excel.sheet.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-excel.template.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.template':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-powerpoint':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.ms-powerpoint.template.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.template':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.ms-powerpoint.addin.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.slideshow':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.ms-powerpoint.presentation.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'text/x-java':
      output += soy.$$escapeHtml("Java Source File");
      break;
    case 'text/x-java-source':
      output += soy.$$escapeHtml("Java Source File");
      break;
    case 'application/x-java-archive':
      output += soy.$$escapeHtml("Java Archive File");
      break;
    default:
      output += soy.$$escapeHtml("File");
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.matchFileIconAlt.soyTemplateName = 'JIRA.Templates.ViewIssue.matchFileIconAlt';
}


JIRA.Templates.ViewIssue.renderAttachmentIcon = function(opt_data, opt_ignored) {
  var output = '';
  var fileClass__soy442 = '' + JIRA.Templates.ViewIssue.matchFileClass(opt_data);
  var fileIconAlt__soy444 = '' + JIRA.Templates.ViewIssue.matchFileIconAlt(opt_data);
  output += '<span class="aui-icon aui-icon-small attachment-icon ' + soy.$$escapeHtml(fileClass__soy442) + '" title="' + soy.$$escapeHtml(fileIconAlt__soy444) + '"></span>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.renderAttachmentIcon.soyTemplateName = 'JIRA.Templates.ViewIssue.renderAttachmentIcon';
}


JIRA.Templates.ViewIssue.renderThumbnailIcon = function(opt_data, opt_ignored) {
  var output = '';
  var fileClass__soy452 = '' + JIRA.Templates.ViewIssue.matchFileClass(opt_data);
  output += '<span class="aui-icon aui-icon-large attachment-thumbnail-icon ' + soy.$$escapeHtml(fileClass__soy452) + '"></span>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.renderThumbnailIcon.soyTemplateName = 'JIRA.Templates.ViewIssue.renderThumbnailIcon';
}


JIRA.Templates.ViewIssue.matchFileClass = function(opt_data, opt_ignored) {
  var output = '';
  switch (opt_data.mimetype) {
    case 'application/pdf':
      output += 'aui-iconfont-file-pdf';
      break;
    case 'image/gif':
      output += 'aui-iconfont-image';
      break;
    case 'image/png':
      output += 'aui-iconfont-image';
      break;
    case 'image/jpeg':
      output += 'aui-iconfont-image';
      break;
    case 'text/xml':
      output += 'aui-iconfont-file-code';
      break;
    case 'text/html':
      output += 'aui-iconfont-file-code';
      break;
    case 'text/plain':
      output += 'aui-iconfont-file-txt';
      break;
    case 'application/zip':
      output += 'aui-iconfont-file-zip';
      break;
    case 'application/x-gzip-compressed':
      output += 'aui-iconfont-file-zip';
      break;
    case 'application/msword':
      output += 'aui-iconfont-file-doc';
      break;
    case 'application/msword-template':
      output += 'aui-iconfont-file-doc';
      break;
    case 'application/vnd.ms-word.document.macroEnabled.12':
      output += 'aui-iconfont-file-doc';
      break;
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
      output += 'aui-iconfont-file-doc';
      break;
    case 'application/vnd.ms-word.template.macroEnabled.12':
      output += 'aui-iconfont-file-doc';
      break;
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.template':
      output += 'aui-iconfont-file-doc';
      break;
    case 'application/vnd.ms-excel':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.ms-excel.addin.macroEnabled.12':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.ms-excel.sheet.binary.macroEnabled.12':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.ms-excel.sheet.macroEnabled.12':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.ms-excel.template.macroEnabled.12':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.template':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.ms-powerpoint':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.ms-powerpoint.template.macroEnabled.12':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.template':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.ms-powerpoint.addin.macroEnabled.12':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.slideshow':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.ms-powerpoint.presentation.macroEnabled.12':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'text/x-java':
      output += 'aui-iconfont-file-code';
      break;
    case 'text/x-java-source':
      output += 'aui-iconfont-file-code';
      break;
    case 'application/x-java-archive':
      output += 'aui-iconfont-file-zip';
      break;
    default:
      output += 'aui-iconfont-devtools-file';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.matchFileClass.soyTemplateName = 'JIRA.Templates.ViewIssue.matchFileClass';
}


JIRA.Templates.ViewIssue.tagAttachment = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ViewIssue.tagFilePreview({id: opt_data.attachment.id, title: opt_data.attachment.fileName, mimeType: opt_data.attachment.mimeType, isImage: opt_data.attachment.thumbnailUrl != null, thumbnailUrl: opt_data.attachment.thumbnailUrl});
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.tagAttachment.soyTemplateName = 'JIRA.Templates.ViewIssue.tagAttachment';
}


JIRA.Templates.ViewIssue.tagFilePreview = function(opt_data, opt_ignored) {
  var output = '';
  var previewType__soy535 = '' + ((opt_data.isImage || opt_data.mimeType != null && ('' + opt_data.mimeType).indexOf('image/') != -1) ? 'image' : (opt_data.mimeType == 'application/pdf') ? 'document' : 'unknown');
  output += (previewType__soy535 != 'unknown') ? ' file-preview-id="' + soy.$$escapeHtml(opt_data.id) + '" file-preview-title="' + soy.$$escapeHtml(opt_data.title) + '" file-preview-type="' + soy.$$escapeHtml(previewType__soy535) + '"' + ((opt_data.thumbnailUrl != null) ? 'file-preview-url="' + soy.$$escapeHtml('' + opt_data.thumbnailUrl) + '"' : '') : '';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.tagFilePreview.soyTemplateName = 'JIRA.Templates.ViewIssue.tagFilePreview';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone', location = 'js/dropzones/AttachmentsDropZone.js' */
define('dndattachment/dropzones/AttachmentsDropZone', [
        'dndattachment/dropzones/IssueDropZone',
        'jira/util/events',
        'dndattachment/util/events/types',
        'jquery',
        'dndattachment/util/DataTransfer',
        'featureflags/feature-manager',
        "dndattachment/ctrlv/utility",
        "jira/dialog/dialog"
    ],
    function (IssueDropZone,
              Events,
              EventTypes,
              $,
              DataTransfer,
              FeatureManager,
              Utility,
              JIRADialog) {

        var canonicalBaseUrl = (function () {
            var uri = parseUri(window.location);
            return uri.protocol + "://" + uri.authority;
        })();

        var AttachmentsDropZone = IssueDropZone.extend({
            eventGroup: 'attachmentsdropzone',
            progressBarType: 'dndattachment/progressbars/AttachmentsUploadProgressBar',

            init: function () {
                this._super.apply(this, arguments);

                this.attachFileUrl = contextPath + '/rest/jddap/1.0/attachment';
                Events.bind(JIRA.Events.PANEL_REFRESHED, this.panelRefreshed.bind(this));

                if (FeatureManager.isFeatureEnabled('jira.unified.attachments')) {
                    this.connectContainer();
                }

            },

            connectContainer: function() {
                this.$containerNode = this.getContainerNode();
                this.$dragoverDropzone = $(JIRA.Templates.DnDAttachmentPlugin.dropzone());
                this.$dragoverBorder = this.$dragoverDropzone.find(".attachments-drop-zone__dragover-border");
                this.$dragoverInfo = this.$dragoverDropzone.find(".attachments-drop-zone__dragover-info");
                this.$dragoverDropzone.appendTo(this.$containerNode);
                this.onDragOverDropHandler = this.onDragOverDrop.bind(this);
                this.onDragLeaveHandler = this.onDragLeave.bind(this);
                this.$containerNode.on('dragover dragenter drop', this.onDragOverDropHandler);
                this.$containerNode.on('dragleave', this.onDragLeaveHandler);

                this.$windowMask = $(JIRA.Templates.DnDAttachmentPlugin.windowDropzoneMask());
                this.$body = $(document.body);
                this.$body.append(this.$windowMask);
                this.$body.on('dragenter', _.throttle(this.onBodyDragEnter.bind(this), 200));
                this.$body.on('dragleave', this.onBodyDragLeave.bind(this));
                this.$windowMask.on('dragover dragenter', this.onWindowMaskDragEnter.bind(this));
                this.$windowMask.on('dragleave', this.onWindowMaskDragLeave.bind(this));
                this.$windowMask.on('drop', this.onWindowMaskDrop.bind(this));

                // Save the aui sidebar for easy access
                this.$auiSidebar = $(".aui-sidebar-body");

                // Disconnect the listeners
                this._disconnectListenersFromParentDropzone();

                this.onContentAddedHandler = this.onContentAdded.bind(this);
                Events.bind(JIRA.Events.NEW_CONTENT_ADDED, this.onContentAddedHandler);
            },

            _disconnectListenersFromParentDropzone: function() {
                // Remove the default event handlers from IssueDropZone since we are overriding it.
                this.$dropTarget.off('dragover drop dragleave dragenter');
                $(document).off('dragover dragenter');
            },

            disconnectContainer: function() {
                this.$dragoverDropzone.remove();
                this.$windowMask.remove();
                this.$body.removeClass('attachments-drop-zone__dragover');

                this.$body.off('dragenter', this.onBodyDragEnter.bind(this));
                this.$containerNode.off('dragenter dragover drop', this.onDragOverDropHandler);
                this.$containerNode.off('dragleave', this.onDragLeaveHandler);

                Events.unbind(JIRA.Events.NEW_CONTENT_ADDED, this.onContentAddedHandler);
            },

            isAttached: function() {
                return $.contains(document, this.$node[0]);
            },

            onContentAdded: function() {
                if(!this.isAttached()) {
                    this.disconnectContainer();
                }
            },

            getContainerNode: function() {
                var $node = $($(".issue-container")[0]);
                // In the case of the issue nav view, we need to modify the parent to have a relative position so that
                // our dragover border is positioned correctly as it's child.
                if ($node.css('position') === 'static') {
                    $node.css('position', 'relative');
                }
                return $node;
            },

            /**
             * We don't want to do a full page drag+drop if they are editing a field or have a dialog open.
             * This will change in the future (they will soon be allowed to drag+drop into wiki-renderable fields).
             * @returns {boolean}
             */
            canDoFullPageDrop: function() {
                if (!JIRADialog.current) {
                    JIRA.trace("jira.issue.dnd.dropallowed");
                    return true;
                } else {
                    JIRA.trace("jira.issue.dnd.dropnotallowed");
                    return false;
                }
            },

            onDragOverDrop: function(event) {
                if (!this.isAttached()) {
                    this.disconnectContainer();
                    return;
                }
                if (!Utility.dragEventContainsFiles(event)) {
                    return;
                }
                if (!this.canDoFullPageDrop()) {
                    return;
                }
                event.preventDefault();
                if (event.originalEvent) {
                    event.originalEvent.dataTransfer.dropEffect = "copy";
                }
                JIRA.trace('jira.issue.dnd.dragover');
                this.$body.addClass('attachments-drop-zone__dragover');
                this.$body.addClass("attachments-drop-zone__window-dragover");
                this.$containerNode.addClass("attachments-drop-zone__dragover-fade");

                this._readjustDropzone();
                this._repositionStickyInfoBox();
                if(event.type == 'drop') {
                    this.removeAllDragoverClasses(this.$containerNode);
                    $(document).trigger("dropHandled");

                    var dataTransfer = new DataTransfer(event.dataTransfer);
                    dataTransfer.getFiles().then(function(files) {
                        this.handleFilesReceived(files);
                        this.queueEvent('fileDrop', { count: files.length });
                    }.bind(this));
                }
            },

            onDragLeave: function() {
                this.removeAllDragoverClasses(this.$containerNode);
            },

            /**
             * If the side-bar is in fly-out mode it overlays over the issue, so we need to adjust the dropzone in that case
             */
            _readjustDropzone: function() {
                if (this.$auiSidebar.length !== 0) {
                    var sidebarWidth = this.$auiSidebar.offset().left + this.$auiSidebar.width();
                    // IE can encounter problems with the dragoverBorder's parent offset, so check it's defined.
                    if (this.$dragoverBorder.parent().offset()) {
                        var dropzoneParentLeft = this.$dragoverBorder.parent().offset().left;
                        if (sidebarWidth > dropzoneParentLeft) {
                            this.$dragoverBorder.css({left: sidebarWidth - dropzoneParentLeft});
                        } else {
                            this.$dragoverBorder.css({left: 0});
                        }
                    } else {
                        this.$dragoverBorder.css({left: 0});
                    }
                }
            },

            _repositionStickyInfoBox: function() {
                // dragover-info should always be visible, so we calculate its position based on
                // how much the user has scrolled down within the containerNode and whether the
                // scrollParent of the containerNode has an offset.
                var scroll = this.$containerNode.scrollParent().scrollTop() + 10;
                var nodeOffset = this.$containerNode.offset().top;
                // Calling .offset() on $(document) returns null, so make sure we handle that case properly
                var parentOffset;
                if (this.$containerNode.scrollParent().offset()) {
                    parentOffset = this.$containerNode.scrollParent().offset().top;
                } else {
                    parentOffset = 0;
                }

                var dragoverInfoTop;

                if(parentOffset === 0){
                    if(scroll >= nodeOffset){
                        dragoverInfoTop = scroll - nodeOffset;
                    }
                    else{
                        dragoverInfoTop = 10;
                    }
                }
                else{
                    dragoverInfoTop = scroll;
                }

                this.$dragoverInfo.css({top: dragoverInfoTop});
            },

            onBodyDragEnter: function(e) {
                if (!Utility.dragEventContainsFiles(e)) {
                    return;
                }
                this._readjustDropzone();
                this.$body.addClass("attachments-drop-zone__window-dragover");
            },

            onBodyDragLeave: function() {
                this.removeAllDragoverClasses();
            },

            onWindowMaskDragEnter: function(event) {
                if (!Utility.dragEventContainsFiles(event)) {
                    return;
                }
                event.preventDefault();
                if (event.originalEvent) {
                    event.originalEvent.dataTransfer.dropEffect = "none";
                }
                this._readjustDropzone();
                this.$body.addClass("attachments-drop-zone__window-dragover");
                if (this.canDoFullPageDrop()) {
                    this.$body.addClass("attachments-drop-zone__dragover");
                    this._repositionStickyInfoBox();
                }
            },

            onWindowMaskDragLeave: function() {
                this.removeAllDragoverClasses();
            },

            onWindowMaskDrop: function(event) {
                event.preventDefault();
                this.removeAllDragoverClasses();
            },

            removeAllDragoverClasses: function(fadeMask) {
                if (fadeMask) {
                    fadeMask.removeClass("attachments-drop-zone__dragover-fade")
                }
                this.$body.removeClass("attachments-drop-zone__window-dragover");
                this.$body.removeClass("attachments-drop-zone__dragover");
            },

            handleFilesReceived: function (files) {
                var wikiTextfield = $("textarea.wiki-textfield:visible:focus");
                var isWikiTextfieldFocused = wikiTextfield.length > 0;

                // Files that are received in the drop zone should commit them to the page using the event handler so
                // they are handled in the same way as other attachments that are committed directly to the page
                Events.trigger(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, {
                    files: files,
                    // If a wiki textfield is in focus we insert the markup.
                    // We want the attachment executor to know if a wiki textfield is in focus
                    // so that the executor can then decide whether it wants to perform its action.
                    isWikiTextfieldFocused: isWikiTextfieldFocused,
                    wikiTextfield: wikiTextfield[0]
                });
            },

            render: function () {
                this.$node.parents("#attachmentmodule").addClass('attachments-drop-zone-parent');
                this.$listNode = this.$node.siblings('#file_attachments, #attachment_thumbnails');

                return this._super.apply(this, arguments);
            },

            panelRefreshed: function (event, panel, $new, $existing) {
                // our drop zone was attached to refreshed panel, so we should reattach it and recover removed progress bars
                if (!$existing.find(this.$node).is('*')) {
                    return;
                }

                var oldViewMode = this.getViewMode();

                $new = $new.find('>.mod-content');
                $new.addClass('issue-drop-zone');
                this.$node.prependTo($new);
                this.render();

                var $existingProgressBars = $existing.find('.attachments-upload-progress-bar');

                $existingProgressBars.data("viewMode", this.getViewMode()).each(function (idx, progressBar) {
                    $(progressBar).prop("_instance").render();
                });

                $existingProgressBars.each(function (idx, progressBar) {
                    this.insertProgressBar($(progressBar));
                }.bind(this));

                if (FeatureManager.isFeatureEnabled('jira.unified.attachments')) {
                    // Disconnect the listeners since they get reattached
                    this._disconnectListenersFromParentDropzone();
                }
            },

            /**
             *
             * @returns {string} "list" or "gallery"
             */
            getViewMode: function () {
                return this.$listNode.attr("id") == "file_attachments" ? "list" : "gallery";
            },

            /**
             *
             * @returns {string} "fileName" or "dateTime"
             */
            getSortBy: function () {
                return this.$listNode.data("sort-key");
            },

            /**
             *
             * @returns {string} "desc" or "asc"
             */
            getSortOrder: function () {
                return this.$listNode.data("sort-order");
            },

            /**
             * Return sort comparator function that takes two nodes
             * @returns {Function}
             */
            getSortComparator: function () {
                var sortOrder = this.getSortOrder() == "asc" ? 1 : -1;
                var getSortValue = this.getSortBy() == "fileName" ? function ($node) {
                    return $node.find('.attachment-title').text();
                } : function ($node) {
                    return new Date($node.find('*[datetime]').attr("datetime")).getTime();
                };

                var compareFn = this.getSortBy() == "fileName" && String.prototype.localeCompare ?
                    function (left, right) {
                        return left.localeCompare(right);
                    } :
                    function (left, right) {
                        return left < right ? -1 : (left > right ? 1 : 0);
                    };

                return function ($nodeLeft, $nodeRight) {
                    var left = getSortValue($nodeLeft);
                    var right = getSortValue($nodeRight);
                    return sortOrder * compareFn(left, right);
                }
            },

            commitUpload: function (fileIDs) {
                var result = new $.Deferred();

                this.attachFile(fileIDs).then(result.resolve.bind(result), result.reject.bind(result));

                result.then(function (beans) {
                    var $beans = $(JIRA.Templates.ViewIssue.renderAttachments({
                        baseurl: contextPath,
                        fullBaseUrl: canonicalBaseUrl + contextPath,
                        issue: {id: JIRA.Issues.Api.getSelectedIssueId()},
                        attachments: beans,
                        viewMode: this.getViewMode()
                    })).find('.attachment-content');

                    beans.forEach(function (bean, idx) {
                        var beanNode = $beans[idx];
                        var $progressBar = this.$listNode.find('>*[data-file-id="' + fileIDs[idx] + '"]');
                        $progressBar.replaceWith(beanNode);
                    }, this);

                    JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [this.$listNode, JIRA.CONTENT_ADDED_REASON.panelRefreshed]);

                    JIRA.trace('jira.issue.dnd.attached');
                }.bind(this));

                this.queueTask(result);

                this.queueEvent('commitUpload', {count: fileIDs.length});

                return result;
            },

            configureUploadProgressBar: function ($progressBar) {
                this._super.apply(this, arguments);

                $progressBar.data("viewMode", this.getViewMode());
            },

            placeUploadProgressBar: function ($progressBar, progressBar) {
                progressBar.$node.find('time.livestamp').attr("datetime", new Date().toISOString()).livestamp();

                this.insertProgressBar($progressBar);

                progressBar.bind("onDestroy", function () {
                    var $itemAttachments = $progressBar.parents('.item-attachments');
                    if ($itemAttachments.find(".attachments-upload-progress-bar, .attachment-content").length == 0) {
                        $itemAttachments.remove();
                    }
                });

                return $progressBar;
            },

            /**
             * Insert given progressBar element on attachment list respecting sorting options
             * @param $progressBar
             */
            insertProgressBar: function ($progressBar) {
                var comparator = this.getSortComparator();

                var $children = this.$listNode.children().toArray();

                var isGreater = function (item) {
                    if (comparator($progressBar, $(item)) < 1) {
                        $progressBar.insertBefore(item);
                        return true;
                    }
                };

                if (!$children.some(isGreater)) {
                    $progressBar.appendTo(this.$listNode);
                }
            }

        });

        return AttachmentsDropZone;
    });;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone', location = 'js/progressbars/UploadProgressBar.js' */
define('dndattachment/progressbars/UploadProgressBar',
    ['jquery',
     'dndattachment/Parser',
     'dndattachment/JIRA',
     'dndattachment/aui',
     'dndattachment/i18n',
     'dndattachment/TemporaryAttachments',
     'dndattachment/util/Configuration',
     'dndattachment/util/FileSizeUtil',
     'featureflags/feature-manager'],
function($,
         Parser,
         JIRA,
         AJS,
         I18n,
         Attachments,
         Config,
         FileSizeUtil,
         FeatureManager
) {

    var ICONS = ['aui-iconfont-error', 'aui-iconfont-success', 'aui-iconfont-close-dialog'];

    function queueEvent(name, props) {
        AJS.trigger("analytics", { name: 'issue.dnd.attachment.uploadprogress.'+name, data: props || {} });
    }

    var thumbnailMimeTypes = Config.getWRM("thumbnail-mime-types").split(",");

    var UploadProgressBar = Class.extend({

        autoDestroy: true,

        init: function(element) {
            this.result = new $.Deferred();
            this.$node = $(element);
            this.file = this.$node.data("file");
            this.uploadSize = this.$node.data('upload-size');
            this.formToken = this.$node.data('form-token');

            this.$node.prop("_instance", this);

            this.render();
        },

        render: function() {
            this.$node.html(JIRA.Templates.DnDAttachmentPlugin.UploadProgressBar({isImageType: this.isImageType()}));

            this.afterRender();
        },

        afterRender: function() {
            if (this.file) {
                this.setFileName(this.file.name);
                this.setFileSize(this.file.size);
                this.loadThumbnail(this.file);
            }

            if (this.progress)
            {
                this.updateProgress();
            }

            this.connectListeners();
        },

        connectListeners: function() {
            this.getControlNode().on('click', function() {
                this.destroy();
                queueEvent('buttonClick');
            }.bind(this));
        },

        destroy: function () {
            if (this.destroyed) {
                return;
            }

            if(this.upload) {
                this.upload.abort();
            }

            this.setAutoDestroy(false);
            this.trigger('onBeforeDestroy');
            this.destroyed = true;
            this.$node.animate({ opacity: 0 }, {
                duration: 250,
                complete: function () {
                    this.$node.slideUp(250, function () {
                        if (this.objectURL)
                            window.URL.revokeObjectURL(this.objectURL);
                        this.$node.remove();
                        JIRA.trace('jira.issue.dnd.progressbar.removed');

                        this.trigger('onDestroy');
                    }.bind(this));
                }.bind(this)
            });
        },

        isDestroyed: function() {
            return !!this.destroyed;
        },

        setAutoDestroy: function(enabled) {
            this.autoDestroy = enabled;
        },

        getAutoDestroy: function() {
            return this.autoDestroy;
        },

        getUploadParams: function(file) {
            var uploadParams = {
                filename: file.name,
                size: file.size,
                atl_token: atl_token(),
                formToken: this.formToken
            };

            _.extend(uploadParams, this.getEntityParams());

            return uploadParams
        },

        /**
         * Return object with projectKey, projectId, issueKey and/or issueId
         */
        getEntityParams: function() {
            var entityParams = {};

            var issueId = JIRA.Issue.getIssueId();
            var projectId = this.$node.parents('form').find('*[name="pid"]').attr('value');

            // projectId has priority over issueId
            if(projectId) {
                entityParams.projectId = projectId;
            } else if(issueId) {
                entityParams.issueId = issueId;
            }

            return entityParams;
        },

        setFile: function(file) {
            this.file = file;
        },

        setFileID: function(id) {
            this.fileID = id;
            this.$node.attr("data-file-id", id);
        },

        getFileID: function() {
            return this.fileID;
        },

        setFileName: function(fileName) {
            this.$node.find('.upload-progress-bar__file-name').text(fileName);
        },

        getFileName: function() {
            return this.$node.find('.upload-progress-bar__file-name').text();
        },

        setFileSize: function(fileSize) {
            if(fileSize >= 0) {
                this.$node.find('.upload-progress-bar__file-size').html(FileSizeUtil.format(fileSize));
            }
        },

        uploadFile: function(file, uploadLimit) {
            this.setFile(file);

            var result = this.result;

            this.monitorUpload(result);
            result.fail(this.reportError.bind(this));

            if(file.size > uploadLimit) {
                result.reject(I18n("dnd.attachment.file.is.too.large").replace('{0}', this.uploadSize), true);
                return result;
            }

            var invalidChars = [ '\\', '/','"', ':','?', '*', '<','|','>' ];
            for (var i = 0; i < invalidChars.length; i++) {
                var invalidChar = invalidChars[i];
                if (_.contains(file.name, invalidChar)) {
                    result.reject(AJS.format("{0} contains the invalid character \'\'{1}\'\'. Please rename the file and try again.", file.name, invalidChar), true);
                    return result;
                }
            }

            this.upload = new AJS.InlineAttach.AjaxUpload({
                file: file,
                params: this.getUploadParams(file),
                url: AJS.InlineAttach.AjaxPresenter.DEFAULT_URL,
                progress: function(val) {
                    result.notify(val / file.size);
                },
                success: function(val, status) {
                    if(val.id !== undefined && val.name !== undefined) {
                        result.notify(1);
                        result.resolve(val, status, file);
                    } else
                        result.reject(val, status, file);
                },
                error: function(text, status) {
                    result.reject(I18n("dnd.attachment.internal.server.error"), status);
                },
                abort: function() {
                    result.reject(I18n("dnd.attachment.upload.aborted"), "abort");
                }
            });

            // check if current session is able to create attachments
            this.checkSession().then(function() {
                this.upload.upload();
            }.bind(this)).fail(function() {
                result.reject(I18n("dnd.attachment.unauthorized"), 401);
            });

            this.$node.find('.upload-progress-bar__control>*').on('click', function() {
                this.upload.abort();
                result.reject();
            }.bind(this));

            result.done(function(val) {
                Attachments.putAttachment(val.id, file);

                this.setFileID(val.id);
                JIRA.trace('jira.issue.dnd.uploaded');
            }.bind(this));

            return result;
        },

        monitorUpload: function(promise) {
            promise.progress(this.setProgress.bind(this));

            promise.done(this.setFinished.bind(this));

            promise.fail(this.setFailed.bind(this));
        },

        setProgress: function(state) {
            this.progress = state;

            this.updateProgress();
        },

        updateProgress: function() {
            var progressBar = this.$node.find('.upload-progress-bar__progress-bar');
            progressBar.toggleClass('UploadProgressBar_progressUnknown', this.progress === false);
            if(this.progress >= 0) {
                progressBar.find('.upload-progress-bar__bar').css('width', 100 * this.progress + '%');
            }
        },

        setFinished: function() {
            this.$node.addClass('upload-progress-bar__upload-finished');
            this.$node.find('.upload-progress-bar__control button .aui-icon')
                .addClass('aui-iconfont-success')
                .removeClass('aui-iconfont-close-dialog');
            this.finished = true;
            this.trigger("onFinished");
        },

        setFailed: function() {
            this.$node.addClass('UploadProgressBar_uploadFailed');
            this.finished = true;
            this.failed = true;
            this.trigger("onFailed");
        },

        isFinished: function() {
            return !!this.finished;
        },

        isFailed: function() {
            return !!this.failed;
        },

        isSuccessful: function() {
            return this.isFinished() && !this.isFailed();
        },

        isImageType: function() {
            return this.file && this.file.type && _.contains(thumbnailMimeTypes, this.file.type);
        },

        getThumbnailSrc: function(file) {
            if(this.isImageType()) {
                this.objectURL = window.URL.createObjectURL(file);
            }

            return this.objectURL || JIRA.Templates.ViewIssue.matchFileIconUrl({ baseurl: AJS.contextPath(), mimetype: file.type });
        },

        getThumbnailNode: function ()
        {
            return this.$node.find('.upload-progress-bar__thumbnail');
        },

        getControlNode: function () {
            return this.$node.find('.upload-progress-bar__control button');
        },

        loadThumbnail: function(file) {
            var imgSrc = this.getThumbnailSrc(file);

            var $thumbnailNode = this.getThumbnailNode();
            $thumbnailNode.addClass(this.objectURL ? 'upload-progress-bar__thumbnail_image' : 'upload-progress-bar__thumbnail_icon');

            var $thumbnail = $('<img/>').attr('src', imgSrc);

            return $thumbnail.appendTo($thumbnailNode);
        },

        unifiedAttachmentsM2FeatureEnabled: function() {
            return FeatureManager.isFeatureEnabled("jira.unified.attachments.m2");
        },

        reportError: function(message, status) {
            if(typeof message == "object" && message.errorMessage)
                message = message.errorMessage;

            this.$node.addClass('upload-progress-bar__upload-error');
            this.$node.removeClass('upload-progress-bar__upload-finished');
            this.$node.find('.upload-progress-bar__bar').css('width', '100%');
            this.showErrorMessage(message, status);
            this.setAutoDestroy(false);

            queueEvent('error', { message: message });
        },

        showErrorMessage: function(message) {
            this.$node.find('.upload-progress-bar__error-message').text(message);
        },

        setIcon: function(iconName) {
            var $icon = this.$node.find('.upload-progress-bar__control button .aui-icon');
            if(!ICONS.some(function(icon) {
                $icon.toggleClass(icon, icon == iconName);
                return icon == iconName;
            })) {
                throw "Unknown icon";
            }
        },
        
        checkSession: function() {
            var result = new $.Deferred();

            // auth session should just return 200, when user is logged in
            AJS.$.ajax({
                type: "GET",
                url: contextPath + "/rest/auth/1/session",
                contentType: "application/json"
            }).done(function() {
                // user is authorized
                result.resolve();
            }).fail(function() {
                // in case of user being not logged in, check explictly for CREATE_ATTACHMENT permissions
                this.checkPermissions().done(function(response) {
                    result.resolve();
                }).fail(function() {
                    result.reject();
                });
            }.bind(this));

            return result;
        },

        checkPermissions: function() {
            var result = new $.Deferred();

            AJS.$.ajax({
                type: "GET",
                url: contextPath + "/rest/api/2/mypermissions",
                contentType: "application/json",
                data: this.getEntityParams()
            }).done(function(response) {
                if(response.permissions["CREATE_ATTACHMENT"].havePermission) {
                    result.resolve();
                } else {
                    result.reject();
                }
            }).fail(function() {
                result.reject();
            });

            return result;
        }
    });

    return UploadProgressBar;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone', location = 'js/progressbars/AttachmentsUploadProgressBar.js' */
define('dndattachment/progressbars/AttachmentsUploadProgressBar',
  ['dndattachment/progressbars/UploadProgressBar',
   'jira/flag',
   'jquery',
   'dndattachment/i18n'],
  function(UploadProgressBar, flag, $, I18n) {
    function queueEvent(name, props) {
        AJS.trigger("analytics", { name: 'issue.dnd.attachment.attachmentsuploadprogress.'+name, data: props || {} });
    }

    return UploadProgressBar.extend({
        render: function() {
            this.$node.html(JIRA.Templates.DnDAttachmentPlugin.AttachmentsUploadProgressBar({ isImageType: this.isImageType() }))
                    .removeClass('upload-progress-bar')
                    .addClass('attachments-upload-progress-bar');

            this.$node.toggleClass('attachment-content', !this.isImageType());

            this.afterRender();
        },

        loadThumbnail: function(file) {
            if(this.$node.data("viewMode") == "gallery") {
                if(UploadProgressBar.prototype.isImageType.call(this)) {
                    return this._super.apply(this, arguments);
                } else {
                    return $(JIRA.Templates.ViewIssue.renderThumbnailIcon({ mimetype: file.type })).appendTo(this.getThumbnailNode());
                }
            } else {
                return $(JIRA.Templates.ViewIssue.renderAttachmentIcon({ mimetype: file.type })).appendTo(this.getThumbnailNode());
            }
        },

        showErrorMessage: function(message, status) {
            if(status == "abort") {
                // upload was aborted by hand, so we don't show flag
                return;
            }

            var errorFlag = flag.showErrorMsg(I18n("dnd.attachment.not.uploaded")(this.getFileName()), AJS.escapeHTML(message));
            $(errorFlag).on('aui-flag-close', function() {
                this.destroy();
            }.bind(this));

            this.bind('onDestroy', function() {
                errorFlag.close();
            });
        },

        isImageType: function() {
            return this.$node.data("viewMode") == "gallery";
        },

        getControlNode: function () {
            return this.$node.find('.upload-progress-bar__upload-control span');
        },

        getAutoDestroy: function() {
            return false;
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone', location = 'templates/IssueDropZone.soy' */
// This file was automatically generated from IssueDropZone.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.DnDAttachmentPlugin.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.DnDAttachmentPlugin == 'undefined') { JIRA.Templates.DnDAttachmentPlugin = {}; }


JIRA.Templates.DnDAttachmentPlugin.IssueDropZone = function(opt_data, opt_ignored) {
  return '<div class="issue-drop-zone__target"></div><span class="issue-drop-zone__text"><span class="issue-drop-zone__drop-icon"> </span> ' + soy.$$escapeHtml("Drop files to attach, or") + ' <button type="button" class="issue-drop-zone__button"> ' + soy.$$escapeHtml("browse") + '.</button><input class="issue-drop-zone__file ignore-inline-attach" type="file" multiple /></span>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.IssueDropZone.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.IssueDropZone';
}


JIRA.Templates.DnDAttachmentPlugin.AttachmentsDropZone = function(opt_data, opt_ignored) {
  return '<div duiType="dndattachment/dropzones/AttachmentsDropZone" class="issue-drop-zone" data-upload-limit="' + soy.$$escapeHtml(opt_data.jiraAttachmentSize) + '" data-upload-size="' + soy.$$escapeHtml(opt_data.uploadLimit) + '" data-upload-size="' + soy.$$escapeHtml(opt_data.uploadLimit) + '"></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.AttachmentsDropZone.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.AttachmentsDropZone';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone', location = 'templates/AttachmentsDropZone.soy' */
// This file was automatically generated from AttachmentsDropZone.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.DnDAttachmentPlugin.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.DnDAttachmentPlugin == 'undefined') { JIRA.Templates.DnDAttachmentPlugin = {}; }


JIRA.Templates.DnDAttachmentPlugin.dropzoneMask = function(opt_data, opt_ignored) {
  return '<span><div class="attachments-drop-zone__dragover-mask" /></span>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.dropzoneMask.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.dropzoneMask';
}


JIRA.Templates.DnDAttachmentPlugin.dropzone = function(opt_data, opt_ignored) {
  return '<span><div class="attachments-drop-zone__dragover-border"><div class="attachments-drop-zone__dragover-info"><p>' + soy.$$escapeHtml("Drop files to attach them to the issue") + '</p></div></div></span>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.dropzone.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.dropzone';
}


JIRA.Templates.DnDAttachmentPlugin.windowDropzoneMask = function(opt_data, opt_ignored) {
  return '<span><div class="attachments-drop-zone__window-dragover-mask" /></span>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.windowDropzoneMask.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.windowDropzoneMask';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone', location = 'templates/UploadProgressBar.soy' */
// This file was automatically generated from UploadProgressBar.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.DnDAttachmentPlugin.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.DnDAttachmentPlugin == 'undefined') { JIRA.Templates.DnDAttachmentPlugin = {}; }


JIRA.Templates.DnDAttachmentPlugin.UploadProgressBar = function(opt_data, opt_ignored) {
  return '<div class="upload-progress-bar__thumbnail"> </div><span class="upload-progress-bar__file-name"> </span><span class="upload-progress-bar__file-size"> </span><div class="upload-progress-bar__progress-bar"><span class="upload-progress-bar__bar"> </span></div><div class="upload-progress-bar__control"><button type="button" class="aui-button aui-button-subtle aui-button-compact"><span class="aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Cancel upload") + '</span></button></div><div class="upload-progress-bar__error-message"></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.UploadProgressBar.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.UploadProgressBar';
}


JIRA.Templates.DnDAttachmentPlugin.AttachmentsUploadProgressBar = function(opt_data, opt_ignored) {
  return '' + ((opt_data.isImageType) ? '<div class="upload-progress-bar__thumbnail"><div class="upload-progress-bar__progress-bar"><span class="upload-progress-bar__bar"> </span></div></div><dl><dt><span class="upload-progress-bar__file-name"> </span></dt><dd class="upload-progress-bar__file-size"> </dd><dd class="upload-progress-bar__upload-control"><span>' + soy.$$escapeHtml("Cancel") + '</span></dd><dd class="upload-progress-bar__error-message"></dd><dd class="attachment-date"><time class="livestamp" /></dd></dl>' : '<div class="attachment-thumb upload-progress-bar__thumbnail"></div><dl><dt class="attachment-title upload-progress-bar__file-name"></dt><dd class="upload-progress-bar__upload-control"><span>' + soy.$$escapeHtml("Cancel") + '</span></dd><dd class="attachment-size"><span class="upload-progress-bar__file-size"> </span><div class="upload-progress-bar__progress-bar"><span class="upload-progress-bar__bar"> </span></div></dd><dd class="attachment-author"> </dd><dd class="attachment-date"><time class="livestamp" /></dd></dl>');
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.AttachmentsUploadProgressBar.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.AttachmentsUploadProgressBar';
}


JIRA.Templates.DnDAttachmentPlugin.TempUploadProgressBar = function(opt_data, opt_ignored) {
  return '<div class="temp-upload-progress-bar__parent-container temp-upload-progress-bar__uploading"><div class="temp-upload-progress-bar__container"><div class="upload-progress-bar__thumbnail"/><div class="upload-progress-bar__progress-bar"><span class="upload-progress-bar__bar"> </span></div><div class="upload-progress-bar__error"><div class="upload-progress-bar__error-indicator"><span class="aui-icon aui-icon-large aui-iconfont-error">' + soy.$$escapeHtml("Upload error") + '</span></div><div class="upload-progress-bar__error-text">' + soy.$$escapeHtml("Upload failed") + '</div></div><div class="upload-progress-bar__upload-mask"/><div class="upload-progress-bar__control"><button type="button" class="aui-button aui-button-subtle aui-button-compact"><span class="aui-icon aui-icon-small aui-iconfont-close-dialog"><div class="button-text" aria-label="' + soy.$$escapeHtml("Cancel upload") + ' "></div><div class="file-name"></div><div class="error-message"></div></span></button></div><div class="upload-progress-bar__progress-bar"><span class="upload-progress-bar__bar"> </span></div></div><div class="upload-progress-bar_file-name-container"><span class="upload-progress-bar__file-name"></span></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.TempUploadProgressBar.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.TempUploadProgressBar';
}


JIRA.Templates.DnDAttachmentPlugin.SuccessMessageLink = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.issueLink) + '">' + soy.$$escapeHtml(opt_data.issueKey) + ' - ' + soy.$$escapeHtml(opt_data.issueSummary) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.SuccessMessageLink.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.SuccessMessageLink';
}
;
;
/* module-key = 'com.atlassian.jira.plugin.system.comment-panel:expandablecomments', location = 'js/plugin/comment/comments-expanding.js' */
AJS.$(function($) {
    $(document).on('simpleClick', '.collapsed-comments', function(e) {
        e.preventDefault();

        var collapsedLink = $(this);
        var collapsedLinkBlock = collapsedLink.closest('.message-container');
        var container = collapsedLink.closest('.issuePanelContainer');
        var module = collapsedLink.closest('.module');
        var numCommentsBefore = collapsedLinkBlock.prevAll('.activity-comment').length;
        var numCollapsed = collapsedLink.find('.show-more-comments').data('collapsed-count');

        showLoading();
        makeRequest();

        function showLoading() {
            collapsedLink.find('.show-more-comments').text("Loading...");
        }

        function makeRequest() {
            var url = collapsedLink.attr('href');
            JIRA.SmartAjax.makeRequest({
                url: url,
                method: 'GET',
                headers: { "X-PJAX": true } // needed for the ViewIssue action to return only the activity panel
            }).done(showCollapsed);
        }

        function showCollapsed(html) {
            var commentsToShow = $(html).find('.activity-comment').slice(numCommentsBefore, numCommentsBefore + numCollapsed);
            collapsedLinkBlock.replaceWith(commentsToShow);
            JIRA.trace("jira.issue.comment.expanded");
            JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [module, JIRA.CONTENT_ADDED_REASON.panelRefreshed]);

            // Expand the twixi for the first comment
            container.find('.activity-comment:first').removeClass('collapsed').addClass('expanded');
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:lib', location = 'namespaces.js' */
JIRA.Components = JIRA.Components || {};
JIRA.Issues = JIRA.Issues || {};
JIRA.Events = JIRA.Events || {};
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-legacy', location = 'content/js/search/LegacyIssueNavigatorShortcuts.js' */
define('jira/issues/search/legacyissuenavigatorshortcuts', [
    'jira/issues/search/legacyissuenavigator',
    'jira/focus/set-focus',
    'jira/ajs/persistence',
    'jira/util/events',
    'jira/issue',
    'jira/message',
    'jquery'
], function (
    IssueNavigator,/** @todo TF-711 remove. */
    SetFocus,
    Persistence,
    Events,
    Issue,
    Messages,
    $
) {
    "use strict";

    /**
     * @deprecated should all be superceded by {@link JIRA.Issues.Api}.
     * @todo TF-711 remove entirely.
     * @exports jira/issuenavigator/issue-navigator/shortcuts
     * @namespace JIRA.IssueNavigator.Shortcuts
     */
    var contextPath = AJS.contextPath();
    var Shortcuts = {};

    Shortcuts._quickEditSessionCompleteHandler = function () {
        IssueNavigator.setIssueUpdatedMsg();
        IssueNavigator.reload();
    };

    Shortcuts._quickCreateSubtaskSessionCompleteHandler = function (e, issues) {
        var lastIssue = issues[issues.length - 1],
            msg = Issue.issueCreatedMessage(lastIssue, true);

        IssueNavigator.setIssueUpdatedMsg({
            issueMsg: msg
        });

        IssueNavigator.reload();
    };

    var $rows,
        index,
        $nextPage,
        $previousPage,
        helpText,
        isLoadingNewPage = false;

    var issueIdToRowIndex = {};

    $(document).ready(function () {

        // TODO NEXT-156 - isNavigator() checks if is the Issue-Search / 'single' issue view (instead of the project issue navigator)
        // TODO NEXT-156 - but the focus only 'sort of' works on a full page reload on a 'single' issue that has sub-tasks.
        if (IssueNavigator.isNavigator()) {

            var $focusedRow;
            var focusedClassName = /(?:^|\s)focused(?!\S)/;
            var preventFocus = function() {
                $(this).attr("tabIndex", -1);
            };

            // TODO NEXT-156 - $rows is filled when there are subtasks
            $rows = $('#issuetable').find('tr.issuerow');

            // TODO NEXT-156 - None of this code is excuted when we're in the issue-search when I click on another issue.
            $rows.each(function(i) {
                var $row = $(this);

                $('a.hidden-link', this).blur(preventFocus);

                // TODO NEXT-156 - $row contains subtasks - it doesn't satisfy the regex test. Hence index and $focusedRow is never set.
                if (!$focusedRow && focusedClassName.test(this.className)) {
                    $focusedRow = $row;
                    index = i;
                }

                issueIdToRowIndex[$row.attr("rel")] = i;
            });

            // TODO NEXT-156 - this is always the case (if there are no sub-tasks or even sub-tasks - refer above)
            if (!$focusedRow) {
                // This shouldn't ever be the case, but let's be defensive.
                $focusedRow = $rows.first().addClass("focused");
            }

            var jqlHasFocus = $("#jqltext").hasClass('focused');

            if (!jqlHasFocus) {
                var triggerConfig = new SetFocus.FocusConfiguration();
                triggerConfig.focusNow = function() {
                    focusRow(index);
                };
                SetFocus.pushConfiguration(triggerConfig);
            }

            // TODO NEXT-156 - this will trigger when you hit enter on the single 'issue' view. (maybe search 'issue')
            // This is basically a hard coded shortcut for "Enter".  It will trigger a issue view ...
            $(document).keypress(function (e) {
                if (e.keyCode === '13' && $('div.aui-blanket').length === 0){ // ... but not if a dialog is currently open.
                    var target = e.target;
                    // On different browser the originalTarget is different, but all of these are impossible for a user to trigger.
                    if (target === undefined || target.nodeName === "HTML" || target.nodeName === "BODY" || target === document){

                        // TODO NEXT-156 - the if statement below never gets executed because index is always undefined.
                        if (hasResults() && $rows[index]) {
                            // TODO NEXT-156 - this is suppose to do a re-direct to the sub-task/issue.
                            window.location = contextPath + '/browse/' + $rows.eq(index).data('issuekey');
                        }
                    }
                }
            });


            var $pager = $('div.pagination').first(),
                shouldFocusSearch = $("#focusSearch").attr("content") === "true";

            $nextPage = $pager.find('a.icon-next');
            $previousPage = $pager.find('a.icon-previous');

            /*
             * This is used to set the focus away from an input box if they are coming back from a previous search.
             * The server is setting the #focusSearch meta property to true if its a new search and hence the focus will auto go to the input box.
             * But if its not a new search then we want to blur away from the input box so that keyboard shortcuts work
             */
            if (!shouldFocusSearch) {
                var activeElement = $(document.activeElement);
                if (activeElement.is(":input")) {
                    activeElement.blur();
                }
            }


            if (hasResults() && !$(document.activeElement).is(":input")) {
                setTimeout(function () {
                    $rows.eq(index).scrollIntoView();
                }, 0);
            }

            $(".issue-actions-trigger").click(function(){
                var $row = $(this).closest("tr");
                var issueId = $row.attr("rel");
                if (issueId){
                    Shortcuts.focusRow(issueId, 0, true);
                }
            });

            // listen for subtask creation to publish success message. See jira-quick-edit plugin.
            Events.bind("QuickCreateSubtask.sessionComplete", Shortcuts._quickCreateSubtaskSessionCompleteHandler);

            // Listen to edit event to publish success message. See jira-quick-edit plugin.
            Events.bind("QuickEdit.sessionComplete", Shortcuts._quickEditSessionCompleteHandler);
        }
    });

    Shortcuts.selectNextIssue = function () {
        if (hasResults() && !isLoadingNewPage) {
            if (index === $rows.length - 1) {
                followLink($nextPage);
            } else {
                unselectRow(index++);
                selectRow(index);
            }
        }
    };

    Shortcuts.selectPreviousIssue = function () {
        if (hasResults() && !isLoadingNewPage) {
            if (index === 0) {
                followLink($previousPage);
            } else {
                unselectRow(index--);
                selectRow(index);
            }
        }
    };

    Shortcuts.viewSelectedIssue = function () {
        if (hasResults() && $($rows[index]).length) {
            try {
                window.location = contextPath + '/browse/' + $($rows[index]).data('issuekey');
            } catch(err) {
                //IE8 seems to throw an unspecified error here if there's a dirty form warning (see JRADEV-3307).  Catching and ignoring it!
            }
        }
    };

    /**
     * Called to focus the row on the first row or the specified row if issueId is specified
     * @param issueId an optional issueIf to focus on
     * @param delay the delay before triggering ajax issue selection
     * @param supressLinkFocus Do not focus on the first link in the row if this is true.
     */
    Shortcuts.focusRow = function (issueId, delay, supressLinkFocus) {
        if (hasResults()) {
            if (issueId) {
                selectRowViaIssueId(issueId, delay, supressLinkFocus);
            } else {
                if (!supressLinkFocus){
                    $($rows[index]).find('a:first').focus();
                }
            }
        }
    };



    Shortcuts.focusSearch = function () {
        var $jqlTextArea = $("#jqltext");
        // go to the top of the page
        $("#jira").scrollIntoView();
        if ($jqlTextArea.length > 0){
            $jqlTextArea.focus();
        } else {
            var $issuenav = $("#issuenav");
            if ($issuenav.hasClass("lhc-collapsed")){
                $(".toggle-lhc").click();
            }
            var $textSection = $("#navigator-filter-subheading-textsearch-group");
            if ($textSection.hasClass("collapsed")){
                $("#searcher-pid").focus();
            } else {
                $("#searcher-query").focus();
            }
        }
    };

    function hasResults() {
        return $rows && $rows.length > 0;
    }

    function followLink($a) {
        var href = $a.attr('href');
        if (href) {
            isLoadingNewPage = true;
            Persistence.nextPage("blurSearch", true);
            window.location = href;
            //if the new page hasn't loaded, re-enable shortcuts after 5 seconds (user may have pressed stop).
            //this may leave a small window where j & k don't work but there doesn't seem to be a way to detect
            //if the user pressed stop. (JRADEV-2872)
            setTimeout(function() { isLoadingNewPage = false; }, 5000);

        }
    }

    function unselectRow(i) {

        var $td = $($rows[i]).find('td:first');
        $($rows[i]).removeClass('focused');
        helpText = $td.attr('title');
        $td.removeAttr('title');
    }

    function selectRow(i, delay, supressLinkFocus) {
        var $selected = $($rows[i]).addClass('focused').scrollIntoView();
        $selected.find('td').first().attr('title', helpText);
        if (!supressLinkFocus){
            focusRow(i);
        }
    }

    function selectRowViaIssueId(issueId, delay, supressLinkFocus)
    {
        var newIndex = issueIdToRowIndex[issueId];
        if (newIndex || newIndex === 0) {
            unselectRow(index);
            selectRow(index = newIndex, delay, supressLinkFocus);
        }
    }

    // This is here so tab and enter work correctly while traversing the navigator list.
    function focusRow(i) {
        var $selected = $($rows[i]);
        $selected.find('.hidden-link')
            .removeAttr('tabIndex')
            .focus();
    }

    return Shortcuts;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-legacy', location = 'content/js/search/LegacyIssueNavigator.js' */
define('jira/issues/search/legacyissuenavigator', [
    'jira/data/session-storage',
    'jira/util/browser',
    'jquery'
], function(
    SessionStorage,
    Browser,
    jQuery
) {
    "use strict";

    /**
     * Represents an the Issue Navigator page.  This class should be used to retrieve information from the
     * issue navigator such as the currently selected row, currently selected issue key and so on.
     *
     * @deprecated should all be superceded by {@link JIRA.Issues.Api}.
     * @todo TF-711 remove entirely.
     * @exports jira/issuenavigator/issue-navigator
     * @namespace JIRA.IssueNavigator
     */
    var IssueNavigator = {
        /**
         * Checks if we are currently viewing the issue navigator.
         *
         * @return {Boolean} true if the current page is the issue navigator, false otherwise
         */
        isNavigator: function() {
            return jQuery("#isNavigator").length === 1;
        },

        /**
         * Sets a message to be displayed when the navigator has been reloaded
         *
         * @param {Object} [options={}]
         * @param {String} options.issueMsg
         * @param {String} options.issueId
         * @param {String} options.issueKey
         */
        setIssueUpdatedMsg: function (options) {

            options = options || {};

            var issueMsg = options.issueMsg,
                issueId = options.issueId,
                issueKey = options.issueKey;

            if (!issueId) {
                issueId = this.getSelectedIssueId();
                issueKey = this.getSelectedIssueKey();
            }

            if (issueId) {
                SessionStorage.setItem('selectedIssueId', issueId);
            }

            if (issueKey) {
                SessionStorage.setItem('selectedIssueKey', issueKey);
            }

            if (issueMsg) {
                SessionStorage.setItem('selectedIssueMsg', issueMsg);
            }
        },

        /**
         * Reloads the issue navigator
         */
        reload: function () {
            Browser.reloadViaWindowLocation();
        },

        /**
         * Checks if any row is currently selected on the issue navigator. This can be the case for
         * an empty searchr, or if keyboard shortcuts are disabled.
         *
         * @return {Boolean} true if a selected issue row exists, false otherwise
         */
        isRowSelected: function() {
            return IssueNavigator.get$focusedRow().length !== 0;
        },

        /**
         * Returns a jQuery wrapped object representing the currently selected issue row.
         * TODO NEXT-156 - Remove this after confirming it is unused
         *
         * @return {jQuery} the jQuery wrapped issue row representing the currently selected row
         */
        get$focusedRow: function() {
            return jQuery("#issuetable tr.issuerow.focused");
        },

        /**
         * Gets the index of the focused issue.
         * TODO NEXT-156 - Remove this after confirming it is unused
         *
         * @return {Number} - The index of the focused issue in the current search result set.
         */
        getFocsuedIssueIndex: function() {
            var rowIndex = jQuery("#issuetable").find("tr.issuerow").index(this.get$focusedRow());
            var searchOffset = parseInt(jQuery('.results-count-start').first().text(), 10) - 1;
            return rowIndex + searchOffset;
        },

        /**
         * Returns the issue key for the currently selected row.
         *
         * @return {String} The issue key for the currently focused row or undefined if none exists.
         */
        getSelectedIssueKey: function() {
            var $focusedRow = IssueNavigator.get$focusedRow();
            if ($focusedRow.length !== 0) {
                return $focusedRow.attr("data-issuekey");
            }
            return undefined;
        },

        /**
         * Returns the issue id for the currently selected row.
         *
         * @return {String} The issue id for the currently focused row or undefined if none exists.
         */
        getSelectedIssueId: function() {
            return IssueNavigator.get$focusedRow().attr("rel");
        },

        /**
         * Returns the issue id for the next row after the currently selected row.
         *
         * Note: It is a known issue that no id will be returned when the last issue on the page is
         * focused. In future, the return value in this situation may change.
         * TODO NEXT-156 - Remove this after confirming it is unused
         *
         * @return {String} The issue id for the next issue after the currently focused row or undefined if none exists.
         */
        getNextIssueId: function() {
            return IssueNavigator.get$focusedRow().next("tr.issuerow").attr("rel");
        }
    };

    return IssueNavigator;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-legacy', location = 'content/js/search/LegacyIssue.js' */
define('jira/issues/search/legacyissue', [
    'jira/util/browser',
    'jira/util/events',
    'jquery',
    'wrm/context-path'
], function(
    Browser,
    Events,
    jQuery,
    contextPath
) {
    "use strict";

    /**
     * Represents the View Issue page.  This class should be used to get the current issue key
     * and any other issue centric information!
     *
     * @deprecated should all be superceded by {@link JIRA.Issues.Api}.
     * @todo TF-711 remove entirely.
     * @exports jira/issue
     * @namespace JIRA.Issue
     */
    var Issue = {};
    var $keyVal;

    //private function to cache the key value.
    function getKeyVal() {
        if(!$keyVal) {
            $keyVal = jQuery("#key-val");
        }
        return $keyVal;
    }

    /**
     * @return {jQuery}
     */
    Issue.getStalker = function () {
        return jQuery("#stalker");
    };

    /**
     * Gets subtask contents
     * @return {jQuery}
     */
    Issue.getSubtaskContent = function () {
        return Issue.getSubtaskModule().find(".mod-content");
    };

    /**
     * Gets subtask module
     */
    Issue.getSubtaskModule = function () {
        return jQuery("#view-subtasks");
    };

    /**
     * Reloads View Issue screen
     */
    Issue.reload = function () {
        Browser.reloadViaWindowLocation();
    };

    /**
     * Goes back to the server to get updates content, if there is any.
     *
     * @return jQuery.promise
     */
    Issue.refreshSubtasks = function () {

        var deferred = new jQuery.Deferred(),
            $subtasks = Issue.getSubtaskContent();

        if ($subtasks.length === 0) {
            Browser.reloadViaWindowLocation(window.location.href + "#view-subtasks");
            return deferred.promise();
        } else {
            return jQuery.ajax({
                url: contextPath + "/secure/ViewSubtasks.jspa?id=" + Issue.getIssueId(),
                success: function (html) {
                    $subtasks.replaceWith(html);
                    Events.trigger("Issue.subtasksRefreshed", [Issue.getSubtaskContent()]);
                }
            });
        }
    };

    /**
     * Highlights specified issues
     *
     * @param issues
     */
    Issue.highlightSubtasks = function (issues) {
        jQuery.each(issues, function (i, issue) {
            jQuery(".issuerow[data-issuekey='" + issue.issueKey + "']").fadeInBackground();
        });
    };

    /**
     * Returns the issue id of the current issue being viewed.
     *
     * @return {String} the issue id or undefined if none can be found.
     */
    Issue.getIssueId = function() {
        var $keyVal = getKeyVal();
        if($keyVal.length !== 0) {
            return $keyVal.attr("rel");
        }
        return undefined;
    };

    /**
     * Returns the issue key of the current issue being viewed.
     *
     * @return {String} the issue key or undefined if none can be found.
     */
    Issue.getIssueKey = function() {
        var $keyVal = getKeyVal();
        if($keyVal.length !== 0) {
            return $keyVal.text();
        }
        return undefined;
    };

    /**
     * Gets I18N message for a created issue.
     *
     * @param issue issue to get message for
     * @param isSubtask whether the created issue is a subtask
     * @return {String} the issue created message according to the given data
     */
    Issue.issueCreatedMessage = function(issue, isSubtask) {
        var issueText = isSubtask ? "Subtask" : "Issue";
        var link = '<a class="issue-created-key issue-link" data-issue-key="' + issue.issueKey + '" href="' + contextPath() + '/browse/' + issue.issueKey + '">'
            + issue.issueKey + ' - ' + AJS.escapeHtml(issue.summary) + '</a>';
        return AJS.format("{0} {1} has been successfully created.", issueText, link);
    };

    return Issue;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issues-api', location = 'content/js/search/IssuesApi.js' */
(function() {
    "use strict";

    /**
     * The JIRA issues API.
     *
     * @type {object}
     */
    var issuesApi = (function() {
        var searchPageModule;

        return {
            /**
             * Initialize the API.
             *
             * @param {object} options
             * @param {SearchPageModule} options.searchPageModule
             */
            initialize: function(options) {
                searchPageModule = options.searchPageModule;
            },

            /**
             * Initiate editing the value of a field on the selected issue.
             *
             * It's not always possible for the user to edit a field, for example if the issue is currently not editable, or
             * if the user doesn't have the correct permissions.
             *
             * For visible fields inline editing is used. For hidden fields, a modal dialog is used.
             *
             * @param fieldId the ID of the field to edit
             * @return {boolean} true if the field editing did/will happen, otherwise false.
             */
            editFieldOnSelectedIssue: function(fieldId) {
                var fields = JIRA.Issues.Api.getFieldsOnSelectedIssue();
                var field = fields && fields.get(fieldId);
                var permitted = field && field.isEditable();

                if (permitted && searchPageModule) {
                    JIRA.Issues.Application.execute("issueEditor:editField", field);
                }

                return permitted;
            },

            /**
             * Focus the search controls.
             * <p/>
             * In basic mode, the project criteria; in advanced mode, the JQL input.
             */
            focusSearch: function() {
                AJS.$(".criteria-selector:first, #advanced-search").focus().select();
            },

            /**
             * @return {JIRA.Issues.SimpleIssue} the currently selected issue.
             */
            getSelectedIssue: function() {
                return searchPageModule.getEffectiveIssue();
            },

            /**
             * @return {null|number} the ID of the selected issue or null.
             */
            getSelectedIssueId: function() {
                return searchPageModule.getEffectiveIssueId();
            },

            /**
             * @return {null|string} the key of the selected issue or <tt>null</tt>.
             */
            getSelectedIssueKey: function() {
                return searchPageModule.getEffectiveIssueKey();
            },

            /**
             * Returns the fields on the selected issue.
             *
             * @return {undefined|Backbone.Collection} collection of {JIRA.Components.IssueEditor.Models.Field} objects
             */
            getFieldsOnSelectedIssue: function() {
                var fields = JIRA.Issues.Application.request("issueEditor:fields");
                return fields.length ? fields : undefined;
            },

            /**
             * @return {boolean} whether there are saves in progress.
             */
            hasSavesInProgress: function() {
                return JIRA.Issues.Application.request("issueEditor:hasSavesInProgress");
            },

            /**
             * @return {boolean} whether an issue is currently being loaded.
             */
            isCurrentlyLoadingIssue: function() {
                return searchPageModule.isCurrentlyLoadingIssue();
            },

            /**
             * @return {boolean|null} whether the selected issue can be opened, or <tt>null</tt> if no issue is selected.
             */
            isSelectedIssueAccessible: function() {
                return searchPageModule.isHighlightedIssueAccessible();
            },

            /**
             * @return {boolean} whether an issue is visible.
             */
            issueIsVisible: function() {
                return searchPageModule.isIssueVisible();
            },

            /**
             * Select the next issue.
             * <p/>
             * When in issue search, the next issue is highlighted; when viewing an
             * issue, the next one is loaded. No-op if an overlay is visible.
             */
            nextIssue: function() {
                searchPageModule.nextIssue();
            },

            /**
             * Open the focus shifter.
             */
            openFocusShifter: function() {
                if (searchPageModule.isIssueVisible()) {
                    searchPageModule.openFocusShifter();
                }
            },

            /**
             * Select the previous issue.
             * <p/>
             * When in issue search, the previous issue is highlighted; when viewing
             * an issue, the previous one is loaded. No-op if an overlay is visible.
             */
            prevIssue: function() {
                searchPageModule.prevIssue();
            },

            /**
             * Refresh the content of the selected issue, by merging changes from the server.
             *
             * @param {object} [options] Extra options to include in the internal triggerRefreshIssue() call
             * @returns {jQuery.Promise}
             *
             * The returned promise is:
             * - resolved when the selected issue is refreshed, or if there is no selected issue
             * - rejected *only* when refreshing the selected issue fails
             */
            refreshSelectedIssue: function(options) {
                return JIRA.Issues.Application.request("issueEditor:refreshIssue", options);
            },

            /**
             * Return to issue search.
             * <p/>
             * If a form is dirty, we ask the user to confirm navigation.
             *
             * @param {boolean} ignoreDirtiness Whether we should ignore dirtiness
             *     (used, for example, to force return after deleting an issue).
             */
            returnToSearch: function(ignoreDirtiness) {
                searchPageModule.returnToSearch({
                    ignoreDirtiness: ignoreDirtiness
                });
            },

            /**
             * @param {Object|null} issueProps - if null/undefined, use currently selected issue
             */
            showInlineIssueLoadError: function(issueProps) {
                searchPageModule.showInlineIssueLoadError(issueProps);
            },

            /**
             * Switch to the next search layout.
             * <p/>
             * We cycle through layouts in the order they appear in the layout switcher.
             */
            switchLayouts: function(options) {
                var currentIndex = -1;
                var currentLayout = searchPageModule.getCurrentLayout();
                var layouts = searchPageModule.getSortedLayouts();
                var newLayout;

                _.find(layouts, function(layout, index) {
                    if (currentLayout instanceof layout.View) {
                        currentIndex = index;
                        return true;
                    }
                });

                newLayout = layouts[(currentIndex + 1) % layouts.length];

                if (!newLayout) {
                    return;
                } else if (newLayout.id === 'split-view') {
                    require('jira/issues/views/details/metrics').start();
                } else if (newLayout.id === 'list-view') {
                    require('jira/issues/navigator/metrics').notifyIssueNavList();
                }

                searchPageModule.changeLayout(newLayout.id, options);
            },

            /**
             * Return if the current query is valid.
             * @returns {boolean}
             */
            isQueryValid: function() {
                return searchPageModule.queryModule.isQueryValid();
            },

            /**
             * @returns {*|boolean}
             */
            isFullScreenIssueVisible: function() {
                return searchPageModule.isFullScreenIssueVisible();
            },

            /**
             * View the issue that is currently highlighted in the issue table.
             */
            viewSelectedIssue: function() {
                if (!JIRA.Issues.Api.isSelectedIssueAccessible()) return;

                var issueKey = JIRA.Issues.Api.getSelectedIssueKey();

                if (!searchPageModule.isIssueVisible()) {
                    searchPageModule.update({
                        selectedIssueKey: issueKey
                    });
                }
            },

            /**
             * Undocks/Docks filter panel
             */
            toggleFilterPanel: function() {
                searchPageModule.toggleFilterPanel();
            },

            /**
             * Returns a deferred that is resolved once all inline edits are complete.
             * Or straight away if you have no inline edits pending.
             *
             * @return jQuery.Deferred
             */
            waitForSavesToComplete: function() {
                var d = new jQuery.Deferred();
                window.setTimeout(function() {
                    if (!JIRA.Issues.Api.hasSavesInProgress()) {
                        d.resolve();
                    } else {
                        JIRA.bind(JIRA.Events.INLINE_EDIT_SAVE_COMPLETE, function() {
                            if (!JIRA.Issues.Api.hasSavesInProgress()) {
                                d.resolve();
                            }
                        });
                    }
                }, 10);
            },

            updateIssue: function(issue, message) {
                message = message || "thanks_issue_updated";

                return searchPageModule.updateIssue({
                    key: issue.key,
                    id: issue.id,
                    action: JIRA.Issues.Actions.UPDATE,
                    message: message,
                    meta: {}
                });
            },

            toggleFullscreenIssue: function() {
                if(searchPageModule.isFullScreenIssueVisible()) {
                    if(!searchPageModule.standalone) {
                        searchPageModule.returnToSearch();
                    }
                } else {
                    var options = searchPageModule.isSplitViewLayout() ? {reset: true} : {};

                    JIRA.Issues.Application.execute("navigation:navigate", {
                        selectedIssueKey: searchPageModule.getEffectiveIssueKey()
                    }, options);
                }
            }
        };
    })();

    AJS.namespace('JIRA.Issues.Api', null, issuesApi);

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issues-api', location = 'content/js/search/IssueAPI.js' */
(function() {
    "use strict";

    /**
     * The JIRA issue API.
     * TODO TF-711 Dismantle the old JIRA.Issue object.
     *
     * @type {object}
     */
    JIRA.Issues.IssueAPI = (function() {
        var patch = {
            /**
             * @return {null|string} the currently selected issue's ID or
             *     <tt>null</tt> if no issue is selected.
             */
            getIssueId: function() {
                return JIRA.Issues.Api.getSelectedIssueId();
            },

            /**
             * @return {null|string} the currently selected issue's key or
             *     <tt>null</tt> if no issue is selected.
             */
            getIssueKey: function() {
                return JIRA.Issues.Api.getSelectedIssueKey();
            }
        };

        return {
            /**
             * Patch the <tt>JIRA.Issue</tt> API with the above methods.
             *
             * @param {object} options
             */
            override: function(options) {
                // We override the target in tests.
                options = _.defaults({}, options, {
                    target: JIRA.Issue
                });

                _.extend(options.target, patch);
            }
        };
    })();
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issues-api', location = 'content/js/search/IssueNavigatorAPI.js' */
(function() {
    "use strict";

    /**
     * Overrides for the <tt>JIRA.IssueNavigator</tt> API.
     * TODO TF-711 Dismantle the old JIRA.IssueNavigator object.
     * TODO NEXT-156 Remove this file after removing JIRA's dependency.
     *
     * @type {object}
     */
    JIRA.Issues.IssueNavigatorAPI = (function() {
        var IssueNavigatorMixin = {
            /**
             * @return {Boolean} whether issue search is visible.
             */
            isNavigator: function() {
                return JIRA.Issues.Api.issueIsVisible();
            }
        };

        var IssueNavigatorShortcutsMixin = {
            focusSearch: JIRA.Issues.Api.focusSearch,
            isNavigator: IssueNavigatorMixin.isNavigator,
            selectNextIssue: JIRA.Issues.Api.nextIssue,
            selectPreviousIssue: JIRA.Issues.Api.prevIssue,
            viewSelectedIssue: JIRA.Issues.Api.viewSelectedIssue
        };

        return {
            /**
             * Override the <tt>JIRA.IssueNavigator</tt> API with the above mixins.
             */
            override: function() {

                JIRA.IssueNavigator = _.extend(JIRA.IssueNavigator, IssueNavigatorMixin);
                JIRA.IssueNavigator.Shortcuts = _.extend(JIRA.IssueNavigator.Shortcuts,
                    IssueNavigatorShortcutsMixin);
            }
        };
    })();
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issues-api', location = 'content/js/search/LayoutPreferenceManager.js' */
(function() {
    "use strict";

    /**
     * Manages getting/setting the user's preferred layout preference.
     */
    JIRA.Issues.LayoutPreferenceManager = {
        PREFERRED_LAYOUT_KEY: "jira.issues.preferred.layout.key",

        /**
         * @return {string} The key of the current user's preferred layout.
         */
        getPreferredLayoutKey: function() {
            return AJS.Meta.get(this.PREFERRED_LAYOUT_KEY);
        },

        /**
         * @param {string} layoutKey The key of the current user's preferred layout.
         * @param {object} [options]
         * @param {object} [options.ajax=true] Whether to post the user's preferred layout to the server.
         * @param {object} [options.render]
         */
        setPreferredLayoutKey: function(layoutKey, options) {
            options = _.defaults({}, options, {
                ajax: true
            });

            AJS.Meta.set(this.PREFERRED_LAYOUT_KEY, layoutKey);
            if (options.ajax) {
                AJS.$.ajax({
                    data: {
                        layoutKey: layoutKey
                    },
                    type: "POST",
                    headers: JIRA.Issues.XsrfTokenHeader,
                    url: AJS.contextPath() + "/rest/issueNav/latest/preferredSearchLayout"
                });
            }
        }
    };
}());
;
;
/* module-key = 'com.atlassian.jira.jira-project-config-plugin:custom-fields', location = 'customfields/js/util/IssuesApi.js' */
/**
 *  This is module exists only to provide AMD module for JIRA.Issues.Api.
 *  It should be removed as soon as there will be one provided by issue-nav-plugin.
 */
define("jira-project-config/issues/api", function() {
    return JIRA &&
        JIRA.Issues &&
        JIRA.Issues.Api;
});
;
;
/* module-key = 'com.atlassian.jira.jira-project-config-plugin:custom-fields', location = 'customfields/js/main.js' */
require([
    'wrm/require',
    'jquery'
], function(
    wrmRequire,
    $
) {
    var loadApi = function (callback) {
        wrmRequire(["wrc!com.atlassian.jira.jira-project-config-plugin.custom-fields-impl"], function () {
            require(['jira-project-config/custom-fields/api'], callback);
        });
    };

    // Adding a custom field from the View Issue page.
    $(document).on("click", ".issueaction-fields-add", function (event) {
        event.preventDefault();
        var issue = JIRA.Issues.Api.getSelectedIssueId();

        loadApi(function(api) {
            api.addCustomFieldToIssue(issue);
        });
    });
});
;
;
/* module-key = 'jira.webresources:calendar', location = '/includes/lib/calendar/Calendar.js' */
/*  Copyright Mihai Bazon, 2002-2005  |  www.bazon.net/mishoo
 * -----------------------------------------------------------
 *
 * The DHTML Calendar, version 1.0 "It is happening again"
 *
 * Details and latest version at:
 * www.dynarch.com/projects/calendar
 *
 * This script is developed by Dynarch.com.  Visit us at www.dynarch.com.
 *
 * This script is distributed under the GNU Lesser General Public License.
 * Read the entire license text here: http://www.gnu.org/licenses/lgpl.html
 */

// NOTE: we have modified calendar-ko.js to resolve JRA-7729, we added the month character to the
// Calendar._SMN (short month names) array values, this is what java expects
//
// NOTE: there is a further modification to resolve JRA-8703, we added the Calendar._SMN (short month names) and
// Calendar._SDN (short week names) to the calendar-nl.js.
//
// $Id: calendar.js,v 1.4 2006/10/20 04:34:05 jkoke Exp $

/** The Calendar object constructor. */
Calendar = function (firstDayOfWeek, dateStr, todayDateStr, onSelected, onClose) {
	// member variables
	this.activeDiv = null;
	this.currentDateEl = null;
	this.getDateStatus = null;
	this.getDateToolTip = null;
	this.getDateText = null;
	this.timeout = null;
	this.onSelected = onSelected || null;
	this.onClose = onClose || null;
	this.dragging = false;
	this.hidden = false;
	this.minYear = 1970;
	this.maxYear = 2050;
	this.dateFormat = Calendar._TT["DEF_DATE_FORMAT"];
	this.ttDateFormat = Calendar._TT["TT_DATE_FORMAT"];
	this.isPopup = true;
    this.weekNumbers = true;

    this.firstDayOfWeek = typeof firstDayOfWeek == "number" ? firstDayOfWeek : Calendar._FD; // 0 for Sunday, 1 for Monday, etc.
	this.showsOtherMonths = false;
	this.dateStr = dateStr;
	this.todayDateStr = todayDateStr;
	this.ar_days = null;
	this.showsTime = false;
	this.time24 = true;
	this.yearStep = 2;
	this.hiliteToday = true;
	this.multiple = null;
	// HTML elements
	this.table = null;
	this.element = null;
	this.tbody = null;
	this.firstdayname = null;
	// Combo boxes
	this.monthsCombo = null;
	this.yearsCombo = null;
	this.hilitedMonth = null;
	this.activeMonth = null;
	this.hilitedYear = null;
	this.activeYear = null;
	// Information
	this.dateClicked = false;

	// one-time initializations
	if (typeof Calendar._SDN == "undefined") {
		// table of short day names
		if (typeof Calendar._SDN_len == "undefined")
			Calendar._SDN_len = 3;
		var ar = new Array();
		for (var i = 8; i > 0;) {
			ar[--i] = Calendar._DN[i].substr(0, Calendar._SDN_len);
		}
		Calendar._SDN = ar;
		// table of short month names
		if (typeof Calendar._SMN_len == "undefined")
			Calendar._SMN_len = 3;
		ar = new Array();
		for (var i = 12; i > 0;) {
			ar[--i] = Calendar._MN[i].substr(0, Calendar._SMN_len);
		}
		Calendar._SMN = ar;
	}
};

// ** constants

/// "static", needed for event handlers.
Calendar._C = null;

/// detect a special case of "web browser"
Calendar.is_ie = ( /msie/i.test(navigator.userAgent) &&
		   !/opera/i.test(navigator.userAgent) );

Calendar.is_ie5 = ( Calendar.is_ie && /msie 5\.0/i.test(navigator.userAgent) );

Calendar.is_ie6 = ( Calendar.is_ie && /msie 6\.0/i.test(navigator.userAgent) );

/// detect Opera browser
Calendar.is_opera = /opera/i.test(navigator.userAgent);

/// detect KHTML-based browsers
Calendar.is_khtml = /Konqueror|Safari|KHTML/i.test(navigator.userAgent);

// BEGIN: UTILITY FUNCTIONS; beware that these might be moved into a separate
//        library, at some point.

Calendar.getAbsolutePos = function(el) {
    var coords = jQuery(el).offset();
    coords.x = coords.left;
    coords.y = coords.top;
    return coords;
};

Calendar.isRelated = function (el, evt) {
	var related = evt.relatedTarget;
	if (!related) {
		var type = evt.type;
		if (type == "mouseover") {
			related = evt.fromElement;
		} else if (type == "mouseout") {
			related = evt.toElement;
		}
	}
	while (related) {
		if (related == el) {
			return true;
		}
		related = related.parentNode;
	}
	return false;
};

Calendar.removeClass = function(el, className) {
	if (!(el && el.className)) {
		return;
	}
	var cls = el.className.split(" ");
	var ar = new Array();
	for (var i = cls.length; i > 0;) {
		if (cls[--i] != className) {
			ar[ar.length] = cls[i];
		}
	}
	el.className = ar.join(" ");
};

Calendar.addClass = function(el, className) {
	Calendar.removeClass(el, className);
	el.className += " " + className;
};

// FIXME: the following 2 functions totally suck, are useless and should be replaced immediately.
Calendar.getElement = function(ev) {
	var f = Calendar.is_ie ? window.event.srcElement : ev.currentTarget;
	while (f.nodeType != 1 || /^div$/i.test(f.tagName))
		f = f.parentNode;
	return f;
};

Calendar.getTargetElement = function(ev) {
	var f = Calendar.is_ie ? window.event.srcElement : ev.target;
	while (f.nodeType != 1)
		f = f.parentNode;
	return f;
};

Calendar.stopEvent = function(ev) {
    if (!ev) ev = window.event;
    if (ev.stopPropagation) {
		ev.preventDefault();
		ev.stopPropagation();
	} else {
		ev.cancelBubble = true;
		ev.returnValue = false;
    }
	return false;
};

Calendar.addEvent = function(el, evname, func) {
	if (el.attachEvent) { // IE
		el.attachEvent("on" + evname, func);
	} else if (el.addEventListener) { // Gecko / W3C
		el.addEventListener(evname, func, true);
	} else {
		el["on" + evname] = func;
	}
};

Calendar.removeEvent = function(el, evname, func) {
	if (el.detachEvent) { // IE
		el.detachEvent("on" + evname, func);
	} else if (el.removeEventListener) { // Gecko / W3C
		el.removeEventListener(evname, func, true);
	} else {
		el["on" + evname] = null;
	}
};

Calendar.createElement = function(type, parent) {
	var el = null;
	if (document.createElementNS) {
		// use the XHTML namespace; IE won't normally get here unless
		// _they_ "fix" the DOM2 implementation.
		el = document.createElementNS("http://www.w3.org/1999/xhtml", type);
	} else {
		el = document.createElement(type);
	}
	if (typeof parent != "undefined") {
		parent.appendChild(el);
	}
	return el;
};

// END: UTILITY FUNCTIONS

// BEGIN: CALENDAR STATIC FUNCTIONS

/** Internal -- adds a set of events to make some element behave like a button. */
Calendar._add_evs = function(el) {
	with (Calendar) {
		addEvent(el, "mouseover", dayMouseOver);
		addEvent(el, "mousedown", dayMouseDown);
		addEvent(el, "mouseout", dayMouseOut);
		if (is_ie) {
			addEvent(el, "dblclick", dayMouseDblClick);
			el.setAttribute("unselectable", true);
		}
	}
};

Calendar.findMonth = function(el) {
	if (typeof el.month != "undefined") {
		return el;
	} else if (typeof el.parentNode.month != "undefined") {
		return el.parentNode;
	}
	return null;
};

Calendar.findYear = function(el) {
	if (typeof el.year != "undefined") {
		return el;
	} else if (typeof el.parentNode.year != "undefined") {
		return el.parentNode;
	}
	return null;
};

Calendar.showMonthsCombo = function () {
	var cal = Calendar._C;
	if (!cal) {
		return false;
	}
	var cal = cal;
	var cd = cal.activeDiv;
	var mc = cal.monthsCombo;
	if (cal.hilitedMonth) {
		Calendar.removeClass(cal.hilitedMonth, "hilite");
	}
	if (cal.activeMonth) {
		Calendar.removeClass(cal.activeMonth, "active");
	}
	var mon = cal.monthsCombo.getElementsByTagName("div")[cal.date.getMonth()];
	Calendar.addClass(mon, "active");
	cal.activeMonth = mon;
	var s = mc.style;
	s.display = "block";
	if (cd.navtype < 0)
		s.left = cd.offsetLeft + "px";
	else {
		var mcw = mc.offsetWidth;
		if (typeof mcw == "undefined")
			// Konqueror brain-dead techniques
			mcw = 50;
		s.left = (cd.offsetLeft + cd.offsetWidth - mcw) + "px";
	}
	s.top = (cd.offsetTop + cd.offsetHeight) + "px";
};

Calendar.showYearsCombo = function (fwd) {
	var cal = Calendar._C;
	if (!cal) {
		return false;
	}
	var cal = cal;
	var cd = cal.activeDiv;
	var yc = cal.yearsCombo;
	if (cal.hilitedYear) {
		Calendar.removeClass(cal.hilitedYear, "hilite");
	}
	if (cal.activeYear) {
		Calendar.removeClass(cal.activeYear, "active");
	}
	cal.activeYear = null;
	var Y = cal.date.getFullYear() + (fwd ? 1 : -1);
	var yr = yc.firstChild;
	var show = false;
	for (var i = 12; i > 0; --i) {
		if (Y >= cal.minYear && Y <= cal.maxYear) {
			yr.innerHTML = Y;
			yr.year = Y;
			yr.style.display = "block";
			show = true;
		} else {
			yr.style.display = "none";
		}
		yr = yr.nextSibling;
		Y += fwd ? cal.yearStep : -cal.yearStep;
	}
	if (show) {
		var s = yc.style;
		s.display = "block";
		if (cd.navtype < 0)
			s.left = cd.offsetLeft + "px";
		else {
			var ycw = yc.offsetWidth;
			if (typeof ycw == "undefined")
				// Konqueror brain-dead techniques
				ycw = 50;
			s.left = (cd.offsetLeft + cd.offsetWidth - ycw) + "px";
		}
		s.top = (cd.offsetTop + cd.offsetHeight) + "px";
	}
};

// event handlers

Calendar.tableMouseUp = function(ev) {
	var cal = Calendar._C;
	if (!cal) {
		return false;
	}
	if (cal.timeout) {
		clearTimeout(cal.timeout);
	}
	var el = cal.activeDiv;
	if (!el) {
		return false;
	}
	var target = Calendar.getTargetElement(ev);
	ev || (ev = window.event);
	Calendar.removeClass(el, "active");
	if (target == el || target.parentNode == el) {
		Calendar.cellClick(el, ev);
	}
	var mon = Calendar.findMonth(target);
	var date = null;
	if (mon) {
		date = new Date(cal.date);
		if (mon.month != date.getMonth()) {
			date.setMonth(mon.month);
			cal.setDate(date);
			cal.dateClicked = false;
			cal.callHandler();
		}
	} else {
		var year = Calendar.findYear(target);
		if (year) {
			date = new Date(cal.date);
			if (year.year != date.getFullYear()) {
				date.setFullYear(year.year);
				cal.setDate(date);
				cal.dateClicked = false;
				cal.callHandler();
			}
		}
	}
	with (Calendar) {
		removeEvent(document, "mouseup", tableMouseUp);
		removeEvent(document, "mouseover", tableMouseOver);
		removeEvent(document, "mousemove", tableMouseOver);
		cal._hideCombos();
		_C = null;
		return stopEvent(ev);
	}
};

Calendar.tableMouseOver = function (ev) {
	var cal = Calendar._C;
	if (!cal) {
		return;
	}
	var el = cal.activeDiv;
	var target = Calendar.getTargetElement(ev);
	if (target == el || target.parentNode == el) {
		Calendar.addClass(el, "hilite active");
		Calendar.addClass(el.parentNode, "rowhilite");
	} else {
		if (typeof el.navtype == "undefined" || (el.navtype != 50 && (el.navtype == 0 || Math.abs(el.navtype) > 2)))
			Calendar.removeClass(el, "active");
		Calendar.removeClass(el, "hilite");
		Calendar.removeClass(el.parentNode, "rowhilite");
	}
	ev || (ev = window.event);
	if (el.navtype == 50 && target != el) {
		var pos = Calendar.getAbsolutePos(el);
		var w = el.offsetWidth;
		var x = ev.clientX;
		var dx;
		var decrease = true;
		if (x > pos.x + w) {
			dx = x - pos.x - w;
			decrease = false;
		} else
			dx = pos.x - x;

		if (dx < 0) dx = 0;
		var range = el._range;
		var current = el._current;
		var count = Math.floor(dx / 10) % range.length;
		for (var i = range.length; --i >= 0;)
			if (range[i] == current)
				break;
        while (count-- > 0)
			if (decrease) {
				if (--i < 0)
					i = range.length - 1;
			} else if ( ++i >= range.length )
				i = 0;
		var newval = range[i];
		el.innerHTML = newval;

		cal.onUpdateTime();
	}
	var mon = Calendar.findMonth(target);
	if (mon) {
		if (mon.month != cal.date.getMonth()) {
			if (cal.hilitedMonth) {
				Calendar.removeClass(cal.hilitedMonth, "hilite");
			}
			Calendar.addClass(mon, "hilite");
			cal.hilitedMonth = mon;
		} else if (cal.hilitedMonth) {
			Calendar.removeClass(cal.hilitedMonth, "hilite");
		}
	} else {
		if (cal.hilitedMonth) {
			Calendar.removeClass(cal.hilitedMonth, "hilite");
		}
		var year = Calendar.findYear(target);
		if (year) {
			if (year.year != cal.date.getFullYear()) {
				if (cal.hilitedYear) {
					Calendar.removeClass(cal.hilitedYear, "hilite");
				}
				Calendar.addClass(year, "hilite");
				cal.hilitedYear = year;
			} else if (cal.hilitedYear) {
				Calendar.removeClass(cal.hilitedYear, "hilite");
			}
		} else if (cal.hilitedYear) {
			Calendar.removeClass(cal.hilitedYear, "hilite");
		}
	}
	return Calendar.stopEvent(ev);
};

Calendar.tableMouseDown = function (ev) {
	if (Calendar.getTargetElement(ev) == Calendar.getElement(ev)) {
		return Calendar.stopEvent(ev);
	}
};

Calendar.calDragIt = function (ev) {
	var cal = Calendar._C;
	if (!(cal && cal.dragging)) {
		return false;
	}
	var posX;
	var posY;
	if (Calendar.is_ie) {
		posY = window.event.clientY + document.body.scrollTop;
		posX = window.event.clientX + document.body.scrollLeft;
	} else {
		posX = ev.pageX;
		posY = ev.pageY;
	}
	var st = cal.element.style;
	st.left = (posX - cal.xOffs) + "px";
	st.top = (posY - cal.yOffs) + "px";
	return Calendar.stopEvent(ev);
};

Calendar.calDragEnd = function (ev) {
	var cal = Calendar._C;
	if (!cal) {
		return false;
	}
	cal.dragging = false;
	with (Calendar) {
		removeEvent(document, "mousemove", calDragIt);
		removeEvent(document, "mouseup", calDragEnd);
		tableMouseUp(ev);
	}
};

Calendar.dayMouseDown = function(ev) {
	var el = Calendar.getElement(ev);
	if (el.disabled) {
		return false;
	}
	var cal = el.calendar;
	cal.activeDiv = el;
	Calendar._C = cal;
	if (el.navtype != 300) with (Calendar) {
		if (el.navtype == 50) {
			el._current = el.innerHTML;
			addEvent(document, "mousemove", tableMouseOver);
		} else
			addEvent(document, Calendar.is_ie5 ? "mousemove" : "mouseover", tableMouseOver);
		addClass(el, "hilite active");
		addEvent(document, "mouseup", tableMouseUp);
	} else if (cal.isPopup) {
		cal._dragStart(ev);
	}
	if (el.navtype == -1 || el.navtype == 1) {
		if (cal.timeout) clearTimeout(cal.timeout);
		cal.timeout = setTimeout("Calendar.showMonthsCombo()", 250);
	} else if (el.navtype == -2 || el.navtype == 2) {
		if (cal.timeout) clearTimeout(cal.timeout);
		cal.timeout = setTimeout((el.navtype > 0) ? "Calendar.showYearsCombo(true)" : "Calendar.showYearsCombo(false)", 250);
	} else {
		cal.timeout = null;
	}
	return Calendar.stopEvent(ev);
};

Calendar.dayMouseDblClick = function(ev) {
	Calendar.cellClick(Calendar.getElement(ev), ev || window.event);
	if (Calendar.is_ie) {
		document.selection.empty();
	}
};

Calendar.dayMouseOver = function(ev) {
	var el = Calendar.getElement(ev);
	if (Calendar.isRelated(el, ev) || Calendar._C || el.disabled) {
		return false;
	}
	if (el.ttip) {
		if (el.ttip.substr(0, 1) == "_") {
			el.ttip = el.caldate.print(el.calendar.ttDateFormat) + el.ttip.substr(1);
		}
		el.calendar.tooltips.innerHTML = el.ttip;
	}
	if (el.navtype != 300) {
		Calendar.addClass(el, "hilite");
		if (el.caldate) {
			Calendar.addClass(el.parentNode, "rowhilite");
		}
	}
	return Calendar.stopEvent(ev);
};

Calendar.dayMouseOut = function(ev) {
	with (Calendar) {
		var el = getElement(ev);
		if (isRelated(el, ev) || _C || el.disabled)
			return false;
		removeClass(el, "hilite");
		if (el.caldate)
			removeClass(el.parentNode, "rowhilite");
		if (el.calendar)
			el.calendar.tooltips.innerHTML = _TT["SEL_DATE"];
		return stopEvent(ev);
	}
};

/**
 *  A generic "click" handler :) handles all types of buttons defined in this
 *  calendar.
 */
Calendar.cellClick = function(el, ev) {
	var cal = el.calendar;
	var closing = false;
	var newdate = false;
	var date = null;
	if (typeof el.navtype == "undefined") {
		if (cal.currentDateEl) {
			Calendar.removeClass(cal.currentDateEl, "selected");
			Calendar.addClass(el, "selected");
			closing = (cal.currentDateEl == el);
			if (!closing) {
				cal.currentDateEl = el;
			}
		}
		cal.date.setDateOnly(el.caldate);
		date = cal.date;
		var other_month = !(cal.dateClicked = !el.otherMonth);
		if (!other_month && !cal.currentDateEl)
			cal._toggleMultipleDate(new Date(date));
		else
			newdate = !el.disabled;
		// a date was clicked
		if (other_month)
			cal._init(cal.firstDayOfWeek, date);
	} else {
		if (el.navtype == 200) {
			Calendar.removeClass(el, "hilite");
			cal.callCloseHandler();
			return;
		}
		date = new Date(cal.date);
		if (el.navtype == 0)
			if (cal.todayDateStr)
				date = new Date(cal.todayDateStr); // TODAY server TZ
			else
				// todayDate wasn't passed in, so use local TZ
				// this is same bahaviour as before JRA-45558 fix
				date.setDateOnly(new Date()); // TODAY local TZ
		// unless "today" was clicked, we assume no date was clicked so
		// the selected handler will know not to close the calenar when
		// in single-click mode.
		// cal.dateClicked = (el.navtype == 0);
		cal.dateClicked = false;
		var year = date.getFullYear();
		var mon = date.getMonth();

        function setMonth(m) {
			var day = date.getDate();
			var max = date.getMonthDays(m);
			if (day > max) {
				date.setDate(max);
			}
			date.setMonth(m);
		};
		switch (el.navtype) {
		    case 400:
			Calendar.removeClass(el, "hilite");
			var text = Calendar._TT["ABOUT"];
			if (typeof text != "undefined") {
				text += cal.showsTime ? Calendar._TT["ABOUT_TIME"] : "";
			} else {
				// FIXME: this should be removed as soon as lang files get updated!
				text = "Help and about box text is not translated into this language.\n" +
					"If you know this language and you feel generous please update\n" +
					"the corresponding file in \"lang\" subdir to match calendar-en.js\n" +
					"and send it back to <mihai_bazon@yahoo.com> to get it into the distribution  ;-)\n\n" +
					"Thank you!\n" +
					"http://dynarch.com/mishoo/calendar.epl\n";
			}
            /* [alert] */
			alert(text);
            /* [alert] end */
			return;
		    case -2:
			if (year > cal.minYear) {
				date.setFullYear(year - 1);
			}
			break;
		    case -1:
			if (mon > 0) {
				setMonth(mon - 1);
			} else if (year-- > cal.minYear) {
				date.setFullYear(year);
				setMonth(11);
			}
			break;
		    case 1:
			if (mon < 11) {
				setMonth(mon + 1);
			} else if (year < cal.maxYear) {
				date.setFullYear(year + 1);
				setMonth(0);
			}
			break;
		    case 2:
			if (year < cal.maxYear) {
				date.setFullYear(year + 1);
			}
			break;
		    case 100:
			cal.setFirstDayOfWeek(el.fdow);
			return;
		    case 50:
			var range = el._range;
			var current = el.innerHTML;
			for (var i = range.length; --i >= 0;)
				if (range[i] == current)
					break;
			if (ev && ev.shiftKey) {
				if (--i < 0)
					i = range.length - 1;
			} else if ( ++i >= range.length )
				i = 0;
			var newval = range[i];
			el.innerHTML = newval;
			cal.onUpdateTime();
			return;
		    case 0:
			// TODAY will bring us here
			if ((typeof cal.getDateStatus == "function") &&
			    cal.getDateStatus(date, date.getFullYear(), date.getMonth(), date.getDate())) {
				return false;
			}
			break;
		}
		if (!date.equalsTo(cal.date)) {
			cal.setDate(date);
			newdate = true;
		} else if (el.navtype == 0)
			newdate = closing = true;
	}
	if (newdate) {
		ev && cal.callHandler();
	}
	if (closing) {
		Calendar.removeClass(el, "hilite");
		ev && cal.callCloseHandler();
	}
};

// END: CALENDAR STATIC FUNCTIONS

// BEGIN: CALENDAR OBJECT FUNCTIONS

/**
 *  This function creates the calendar inside the given parent.  If _par is
 *  null than it creates a popup calendar inside the BODY element.  If _par is
 *  an element, be it BODY, then it creates a non-popup calendar (still
 *  hidden).  Some properties need to be set before calling this function.
 */
Calendar.prototype.create = function (_par) {
	var parent = null;
	if (! _par) {
		// default parent is the document body, in which case we create
		// a popup calendar.
		parent = document.getElementsByTagName("body")[0];
		this.isPopup = true;
	} else {
		parent = _par;
		this.isPopup = false;
	}

    // try to parse the current date/time in ISO8601 format
	if (this.dateStr) {
        this.date = new Date(this.dateStr);
    }

    // fall back to date/time in browser time zone if necessary
    if (!this.date || isNaN(this.date)) {
        this.date = new Date();
    }

	var table = Calendar.createElement("table");
	this.table = table;
	table.cellSpacing = 0;
	table.cellPadding = 0;
	table.calendar = this;
	Calendar.addEvent(table, "mousedown", Calendar.tableMouseDown);

	var div = Calendar.createElement("div");
	this.element = div;
	div.className = "calendar";
	if (this.isPopup) {
		div.style.position = "absolute";
		div.style.display = "none";
	}
	div.appendChild(table);

	var thead = Calendar.createElement("thead", table);
	var cell = null;
	var row = null;

	var cal = this;
	var hh = function (text, cs, navtype) {
		cell = Calendar.createElement("td", row);
		cell.colSpan = cs;
		cell.className = "button";
		if (navtype != 0 && Math.abs(navtype) <= 2)
			cell.className += " nav";
		Calendar._add_evs(cell);
		cell.calendar = cal;
		cell.navtype = navtype;
		cell.innerHTML = "<div unselectable='on'>" + text + "</div>";
		return cell;
	};

	row = Calendar.createElement("tr", thead);
	var title_length = 6;
	(this.isPopup) && --title_length;
	(this.weekNumbers) && ++title_length;

	hh("?", 1, 400).ttip = Calendar._TT["INFO"];
	this.title = hh("", title_length, 300);
	this.title.className = "title";
	if (this.isPopup) {
		this.title.ttip = Calendar._TT["DRAG_TO_MOVE"];
		this.title.style.cursor = "move";
		hh("&#x00d7;", 1, 200).ttip = Calendar._TT["CLOSE"];
	}

	row = Calendar.createElement("tr", thead);
	row.className = "headrow";

	this._nav_py = hh("&#x00ab;", 1, -2);
	this._nav_py.ttip = Calendar._TT["PREV_YEAR"];

	this._nav_pm = hh("&#x2039;", 1, -1);
	this._nav_pm.ttip = Calendar._TT["PREV_MONTH"];

	this._nav_now = hh(Calendar._TT["TODAY"], this.weekNumbers ? 4 : 3, 0);
	this._nav_now.ttip = Calendar._TT["GO_TODAY"];

	this._nav_nm = hh("&#x203a;", 1, 1);
	this._nav_nm.ttip = Calendar._TT["NEXT_MONTH"];

	this._nav_ny = hh("&#x00bb;", 1, 2);
	this._nav_ny.ttip = Calendar._TT["NEXT_YEAR"];

	// day names
	row = Calendar.createElement("tr", thead);
	row.className = "daynames";
	if (this.weekNumbers) {
		cell = Calendar.createElement("td", row);
		cell.className = "name wn";
		cell.innerHTML = Calendar._TT["WK"];
	}
	for (var i = 7; i > 0; --i) {
		cell = Calendar.createElement("td", row);
		if (!i) {
			cell.navtype = 100;
			cell.calendar = this;
			Calendar._add_evs(cell);
		}
	}
	this.firstdayname = (this.weekNumbers) ? row.firstChild.nextSibling : row.firstChild;
	this._displayWeekdays();

	var tbody = Calendar.createElement("tbody", table);
	this.tbody = tbody;

	for (i = 6; i > 0; --i) {
		row = Calendar.createElement("tr", tbody);
		if (this.weekNumbers) {
			cell = Calendar.createElement("td", row);
		}
		for (var j = 7; j > 0; --j) {
			cell = Calendar.createElement("td", row);
			cell.calendar = this;
			Calendar._add_evs(cell);
		}
	}

	if (this.showsTime) {
		row = Calendar.createElement("tr", tbody);
		row.className = "time";

		cell = Calendar.createElement("td", row);
		cell.className = "time";
		cell.colSpan = 2;
		cell.innerHTML = Calendar._TT["TIME"] || "&nbsp;";

		cell = Calendar.createElement("td", row);
		cell.className = "time";
		cell.colSpan = this.weekNumbers ? 4 : 3;

		(function(){
			function makeTimePart(className, init, range_start, range_end) {
				var part = Calendar.createElement("span", cell);
				part.className = className;
				part.innerHTML = init;
				part.calendar = cal;
				part.ttip = Calendar._TT["TIME_PART"];
				part.navtype = 50;
				part._range = [];
				if (typeof range_start != "number")
					part._range = range_start;
				else {
					for (var i = range_start; i <= range_end; ++i) {
						var txt;
						if (i < 10 && range_end >= 10) txt = '0' + i;
						else txt = '' + i;
						part._range[part._range.length] = txt;
					}
				}
				Calendar._add_evs(part);
				return part;
			};
			var hrs = cal.date.getHours();
			var mins = cal.date.getMinutes();
			var t12 = !cal.time24;
			var pm = (hrs > 12);
			if (t12 && pm) hrs -= 12;
			var H = makeTimePart("hour", hrs, t12 ? 1 : 0, t12 ? 12 : 23);
			var span = Calendar.createElement("span", cell);
			span.innerHTML = ":";
			span.className = "colon";
			var M = makeTimePart("minute", mins, 0, 59);
			var AP = null;
			cell = Calendar.createElement("td", row);
			cell.className = "time";
			cell.colSpan = 2;
			if (t12)
				AP = makeTimePart("ampm", pm ? Calendar._TT["PM"] : Calendar._TT["AM"], [Calendar._TT["am"], Calendar._TT["pm"]]);
			else
				cell.innerHTML = "&nbsp;";

			cal.onSetTime = function() {
				var pm, hrs = this.date.getHours(),
					mins = this.date.getMinutes();
				if (t12) {
					pm = (hrs >= 12);
					if (pm) hrs -= 12;
					if (hrs == 0) hrs = 12;
					AP.innerHTML = pm ? Calendar._TT["pm"] : Calendar._TT["am"];
				}
				H.innerHTML = (hrs < 10) ? ("0" + hrs) : hrs;
				M.innerHTML = (mins < 10) ? ("0" + mins) : mins;
			};

			cal.onUpdateTime = function() {
				var date = this.date;
				var h = parseInt(H.innerHTML, 10);
				if (t12) {
					if (new RegExp(Calendar._TT["pm"],"i").test(AP.innerHTML) && h < 12)
						h += 12;
					else if (new RegExp(Calendar._TT["am"],"i").test(AP.innerHTML) && h == 12)
						h = 0;
				}
				var d = date.getDate();
				var m = date.getMonth();
				var y = date.getFullYear();
				date.setHours(h);
				date.setMinutes(parseInt(M.innerHTML, 10));
				date.setFullYear(y);
				date.setMonth(m);
				date.setDate(d);
				this.dateClicked = false;
				this.callHandler();
			};
		})();
	} else {
		this.onSetTime = this.onUpdateTime = function() {};
	}

	var tfoot = Calendar.createElement("tfoot", table);

	row = Calendar.createElement("tr", tfoot);
	row.className = "footrow";

	cell = hh(Calendar._TT["SEL_DATE"], this.weekNumbers ? 8 : 7, 300);
	cell.className = "ttip";
	if (this.isPopup) {
		cell.ttip = Calendar._TT["DRAG_TO_MOVE"];
		cell.style.cursor = "move";
	}
	this.tooltips = cell;

	div = Calendar.createElement("div", this.element);
	this.monthsCombo = div;
	div.className = "combo";
	for (i = 0; i < Calendar._MN.length; ++i) {
		var mn = Calendar.createElement("div");
		mn.className = Calendar.is_ie ? "label-IEfix" : "label";
		mn.month = i;
		mn.innerHTML = Calendar._SMN[i];
		div.appendChild(mn);
	}

	div = Calendar.createElement("div", this.element);
	this.yearsCombo = div;
	div.className = "combo";
	for (i = 12; i > 0; --i) {
		var yr = Calendar.createElement("div");
		yr.className = Calendar.is_ie ? "label-IEfix" : "label";
		div.appendChild(yr);
	}

	this._init(this.firstDayOfWeek, this.date);
	parent.appendChild(this.element);

    // JRADEV-11430 Prevent clicks on parts of the calendar that aren't already handled by
    // this lib from stealing focus from a focused element
    Calendar.addEvent(this.element, "mousedown", function(ev) {
        ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
    });
};

Calendar._upkeyEvent = function (e) {
    // JRADEV-10921 - We need to make sure that the calendar is still visible when the
    // blur input field code runs (initKeyboardShortcuts.js) so that the LayerManager.js has the chance to preventDefault
    if (e.keyCode === 27) { // KEY esc
        window.setTimeout(function () {
            var cal = window._dynarch_popupCalendar;
            if (!cal || cal.multiple) {
                return false;
            } else {
                cal.callCloseHandler();
            }
        }, 0);
    }
};

/** keyboard navigation, only for popup calendars */
Calendar._keyEvent = function(ev) {
	var cal = window._dynarch_popupCalendar;
	if (!cal || cal.multiple)
		return false;
	var act = (Calendar.is_ie || ev.type == "keydown"),
        K = ev.keyCode;
	if (ev.ctrlKey) {
		switch (K) {
		    case 37: // KEY left
			act && Calendar.cellClick(cal._nav_pm);
			break;
		    case 38: // KEY up
			act && Calendar.cellClick(cal._nav_py);
			break;
		    case 39: // KEY right
			act && Calendar.cellClick(cal._nav_nm);
			break;
		    case 40: // KEY down
			act && Calendar.cellClick(cal._nav_ny);
			break;
		}
	} else switch (K) {
	    case 32: // KEY space (now)
		Calendar.cellClick(cal._nav_now);
		break;
	    case 37: // KEY left
	    case 38: // KEY up
	    case 39: // KEY right
	    case 40: // KEY down
		if (act) {
			var prev, x, y, ne, el, step;
			prev = K == 37 || K == 38;
			step = (K == 37 || K == 39) ? 1 : 7;
			function setVars() {
				el = cal.currentDateEl;
				var p = el.pos;
				x = p & 15;
				y = p >> 4;
				ne = cal.ar_days[y][x];
			};setVars();
			function prevMonth() {
				var date = new Date(cal.date);
				date.setDate(date.getDate() - step);
				cal.setDate(date);
			};
			function nextMonth() {
				var date = new Date(cal.date);
				date.setDate(date.getDate() + step);
				cal.setDate(date);
			};
			while (1) {
				switch (K) {
				    case 37: // KEY left
					if (--x >= 0)
						ne = cal.ar_days[y][x];
					else {
						x = 6;
						K = 38;
						continue;
					}
					break;
				    case 38: // KEY up
					if (--y >= 0)
						ne = cal.ar_days[y][x];
					else {
						prevMonth();
						setVars();
					}
					break;
				    case 39: // KEY right
					if (++x < 7)
						ne = cal.ar_days[y][x];
					else {
						x = 0;
						K = 40;
						continue;
					}
					break;
				    case 40: // KEY down
					if (++y < cal.ar_days.length)
						ne = cal.ar_days[y][x];
					else {
						nextMonth();
						setVars();
					}
					break;
				}
				break;
			}
			if (ne) {
				if (!ne.disabled)
					Calendar.cellClick(ne);
				else if (prev)
					prevMonth();
				else
					nextMonth();
			}
		}
		break;
	    case 13: // KEY enter
		if (act)
			Calendar.cellClick(cal.currentDateEl, ev);
		break;
	}
	return Calendar.stopEvent(ev);
};

/**
 *  (RE)Initializes the calendar to the given date and firstDayOfWeek
 */
Calendar.prototype._init = function (firstDayOfWeek, seedDate) {
    // JRA-19533
    //
    // Depending on when the DST is applied, some hours might not exist. For example,
    // in Brazil, the clock goes like
    //    Saturday, 17 October 2014 23:59:58
    //    Saturday, 17 October 2014 23:59:59
    //     <------ DST starts here ------->
    //    Sunday, 18 October 2014 01:00:00
    //    Sunday, 18 October 2014 01:00:01
    //
    // We want to avoid iterating over times of dubious values.
    //
    // So first, we'll clone the original seed date.
    var date = new Date(seedDate);
    // Now, to avoid DST problems, we need to tweak the hour of day.
    //
    // Set time to 13.00 to avoid the case where a DST transition causes
    // the below method of iterating through dates to print the same
    // date twice consecutively.
    //
    // After checking the IANA time zone database (http://en.wikipedia.org/wiki/IANA_time_zone_database)
    // 13.00 was never used by any country to apply the DST, so it's a better assumption than midnight or
    // noon.
    date.setHours(13);

	var today = new Date(),
		TY = today.getFullYear(),
		TM = today.getMonth(),
		TD = today.getDate();
	this.table.style.visibility = "hidden";
	var year = date.getFullYear();
	if (year < this.minYear) {
		year = this.minYear;
		date.setFullYear(year);
	} else if (year > this.maxYear) {
		year = this.maxYear;
		date.setFullYear(year);
	}
	this.firstDayOfWeek = firstDayOfWeek;
	var month = date.getMonth();
	var mday = date.getDate();
	var no_days = date.getMonthDays();

	// calendar voodoo for computing the first day that would actually be
	// displayed in the calendar, even if it's from the previous month.
	// WARNING: this is magic. ;-)
	date.setDate(1);
	var day1 = (date.getDay() - this.firstDayOfWeek) % 7;
	if (day1 < 0)
		day1 += 7;
	date.setDate(-day1);
	date.setDate(date.getDate() + 1);

	var row = this.tbody.firstChild;
	var MN = Calendar._SMN[month];
	var ar_days = this.ar_days = new Array();
	var weekend = Calendar._TT["WEEKEND"];
	var dates = this.multiple ? (this.datesCells = {}) : null;
	for (var i = 0; i < 6; ++i, row = row.nextSibling) {
		var cell = row.firstChild;
		if (this.weekNumbers) {
			cell.className = "day wn";
            //
            // The old code didn't take into account the displayed month and hence
            // it showed 52/53 for the first week in January instead of 1
            // so we now taken this into account, but only for non ISO 8601 dates.
            //
            //cell.innerHTML = date.getWeekNumber();
            var monthStartDate = date;
            if (month == 0 && i == 0 && Date.useISO8601WeekNumbers == false) { // Jan and first week in row
                monthStartDate = new Date(year,month,1);
            }
            cell.innerHTML = monthStartDate.getWeekNumber(this.firstDayOfWeek);
            cell = cell.nextSibling;
		}
		row.className = "daysrow";
		var hasdays = false, iday, dpos = ar_days[i] = [];
		for (var j = 0; j < 7; ++j, cell = cell.nextSibling, date.setDate(iday + 1)) {
			iday = date.getDate();
			var wday = date.getDay();
			cell.className = "day day-" + iday;
			cell.pos = i << 4 | j;
			dpos[j] = cell;
			var current_month = (date.getMonth() == month);
			if (!current_month) {
				if (this.showsOtherMonths) {
					cell.className += " othermonth";
					cell.otherMonth = true;
				} else {
					cell.className = "emptycell";
					cell.innerHTML = "&nbsp;";
					cell.disabled = true;
					continue;
				}
			} else {
				cell.otherMonth = false;
				hasdays = true;
			}
			cell.disabled = false;
			cell.innerHTML = this.getDateText ? this.getDateText(date, iday) : iday;
			if (dates)
				dates[date.print("%Y%m%d")] = cell;
			if (this.getDateStatus) {
				var status = this.getDateStatus(date, year, month, iday);
				if (this.getDateToolTip) {
					var toolTip = this.getDateToolTip(date, year, month, iday);
					if (toolTip)
						cell.title = toolTip;
				}
				if (status === true) {
					cell.className += " disabled";
					cell.disabled = true;
				} else {
					if (/disabled/i.test(status))
						cell.disabled = true;
					cell.className += " " + status;
				}
			}
			if (!cell.disabled) {
				cell.caldate = new Date(date);
				cell.ttip = "_";
				if (!this.multiple && current_month
				    && iday == mday && this.hiliteToday) {
					cell.className += " selected";
					this.currentDateEl = cell;
				}
				if (date.getFullYear() == TY &&
				    date.getMonth() == TM &&
				    iday == TD) {
					cell.className += " today";
					cell.ttip += Calendar._TT["PART_TODAY"];
				}
				if (weekend.indexOf(wday.toString()) != -1)
					cell.className += cell.otherMonth ? " oweekend" : " weekend";
			}
		}
		if (!(hasdays || this.showsOtherMonths))
			row.className = "emptyrow";
	}

    // JRA-19533
    // Now that we're done messing with the time of day, set the internal date to the seed date.
    this.date = new Date(seedDate);
    // The date above will include the original time, which will be used to set the time controls below.
	this.onSetTime();

    this.title.innerHTML = Calendar._MN[month] + ", " + year;
	this.table.style.visibility = "visible";
	this._initMultipleDates();
	// PROFILE
	// this.tooltips.innerHTML = "Generated in " + ((new Date()) - today) + " ms";
};

Calendar.prototype._initMultipleDates = function() {
	if (this.multiple) {
		for (var i in this.multiple) {
			var cell = this.datesCells[i];
			var d = this.multiple[i];
			if (!d)
				continue;
			if (cell)
				cell.className += " selected";
		}
	}
};

Calendar.prototype._toggleMultipleDate = function(date) {
	if (this.multiple) {
		var ds = date.print("%Y%m%d");
		var cell = this.datesCells[ds];
		if (cell) {
			var d = this.multiple[ds];
			if (!d) {
				Calendar.addClass(cell, "selected");
				this.multiple[ds] = date;
			} else {
				Calendar.removeClass(cell, "selected");
				delete this.multiple[ds];
			}
		}
	}
};

Calendar.prototype.setDateToolTipHandler = function (unaryFunction) {
	this.getDateToolTip = unaryFunction;
};

/**
 *  Calls _init function above for going to a certain date (but only if the
 *  date is different than the currently selected one).
 */
Calendar.prototype.setDate = function (date) {
	if (!date.equalsTo(this.date)) {
		this._init(this.firstDayOfWeek, date);
	}
};

/**
 *  Refreshes the calendar.  Useful if the "disabledHandler" function is
 *  dynamic, meaning that the list of disabled date can change at runtime.
 *  Just * call this function if you think that the list of disabled dates
 *  should * change.
 */
Calendar.prototype.refresh = function () {
	this._init(this.firstDayOfWeek, this.date);
};

/** Modifies the "firstDayOfWeek" parameter (pass 0 for Synday, 1 for Monday, etc.). */
Calendar.prototype.setFirstDayOfWeek = function (firstDayOfWeek) {
	this._init(firstDayOfWeek, this.date);
	this._displayWeekdays();
};

/**
 *  Allows customization of what dates are enabled.  The "unaryFunction"
 *  parameter must be a function object that receives the date (as a JS Date
 *  object) and returns a boolean value.  If the returned value is true then
 *  the passed date will be marked as disabled.
 */
Calendar.prototype.setDateStatusHandler = Calendar.prototype.setDisabledHandler = function (unaryFunction) {
	this.getDateStatus = unaryFunction;
};

/** Customization of allowed year range for the calendar. */
Calendar.prototype.setRange = function (a, z) {
	this.minYear = a;
	this.maxYear = z;
};

/** Calls the first user handler (selectedHandler). */
Calendar.prototype.callHandler = function () {
	if (this.onSelected) {
		this.onSelected(this, this.date.print(this.dateFormat));
	}
};

/** Calls the second user handler (closeHandler). */
Calendar.prototype.callCloseHandler = function () {
	if (this.onClose) {
		this.onClose(this);
	}
};

/** Removes the calendar object from the DOM tree and destroys it. */
Calendar.prototype.destroy = function () {
	var el = this.element.parentNode;
	el.removeChild(this.element);
	Calendar._C = null;
	window._dynarch_popupCalendar = null;
};

/**
 *  Moves the calendar element to a different section in the DOM tree (changes
 *  its parent).
 */
Calendar.prototype.reparent = function (new_parent) {
	var el = this.element;
	el.parentNode.removeChild(el);
	new_parent.appendChild(el);
};

// This gets called when the user presses a mouse button anywhere in the
// document, if the calendar is shown.  If the click was outside the open
// calendar this function closes it.
Calendar._checkCalendar = function(ev) {
	var calendar = window._dynarch_popupCalendar;
	if (!calendar) {
		return false;
	}
	var el = Calendar.is_ie ? Calendar.getElement(ev) : Calendar.getTargetElement(ev);
	for (; el != null && el != calendar.element; el = el.parentNode);
	if (el == null) {
		// calls closeHandler which should hide the calendar.
		window._dynarch_popupCalendar.callCloseHandler();
		return Calendar.stopEvent(ev);
	}
};

/** Shows the calendar. */
Calendar.prototype.show = function() {
	if (this.params.inputField.disabled) {
		// Don't show the calendar if its inputField isn't editable.
		return;
	}
	var rows = this.table.getElementsByTagName("tr");
	for (var i = rows.length; i > 0;) {
		var row = rows[--i];
		Calendar.removeClass(row, "rowhilite");
		var cells = row.getElementsByTagName("td");
		for (var j = cells.length; j > 0;) {
			var cell = cells[--j];
			Calendar.removeClass(cell, "hilite");
			Calendar.removeClass(cell, "active");
		}
	}
    Calendar.current = this;
    this.element.style.display = "block";
    this.element.className += " active";
    
	this.hidden = false;
	if (this.isPopup) {
		window._dynarch_popupCalendar = this;
		Calendar.addEvent(document, "keyup", Calendar._upkeyEvent);
		Calendar.addEvent(document, "keydown", Calendar._keyEvent);
		Calendar.addEvent(document, "mousedown", Calendar._checkCalendar);
	}
};

/**
 *  Hides the calendar.  Also removes any "hilite" from the class of any TD
 *  element.
 */
Calendar.prototype.hide = function () {
	if (this.isPopup) {
        Calendar.removeEvent(document, "keyup", Calendar._upkeyEvent);
		Calendar.removeEvent(document, "keydown", Calendar._keyEvent);
		Calendar.removeEvent(document, "mousedown", Calendar._checkCalendar);
	}

    Calendar.current = null;
	this.element.style.display = "none";
    this.element.className = this.element.className.replace(/active/gi, "");
	this.hidden = true;
};

/**
 *  Shows the calendar at a given absolute position (beware that, depending on
 *  the calendar element style -- position property -- this might be relative
 *  to the parent's containing rectangle).
 */
Calendar.prototype.showAt = function (x, y) {
	var s = this.element.style;
	s.left = x + "px";
	s.top = y + "px";
	this.show();
};

/** Shows the calendar near a given element. */
Calendar.prototype.showAtElement = function (el, opts) {
    var self = this;
	var p = Calendar.getAbsolutePos(el);
	if (!opts || typeof opts != "string") {
		this.showAt(p.x, p.y + el.offsetHeight);
		return true;
	}
	function fixPosition(box) {
		if (box.x < 0)
			box.x = 0;
		if (box.y < 0)
			box.y = 0;
		var cp = document.createElement("div");
		var s = cp.style;
		s.position = "absolute";
		s.right = s.bottom = s.width = s.height = "0px";
		document.body.appendChild(cp);
		var br = Calendar.getAbsolutePos(cp);
		document.body.removeChild(cp);
        br.y += jQuery(window).scrollTop();
        br.x += jQuery(window).scrollLeft();
		var tmp = box.x + box.width - br.x;
		if (tmp > 0) box.x -= tmp;
		tmp = box.y + box.height - br.y;
		if (tmp > 0) box.y -= tmp;
	};
	this.element.style.display = "block";
	Calendar.continuation_for_the_khtml_browser = function() {
		var w = jQuery(self.element).outerWidth();
		var h = jQuery(self.element).outerHeight();
		self.element.style.display = "none";
		var valign = opts.substr(0, 1);
		var halign = "l";
		if (opts.length > 1) {
			halign = opts.substr(1, 1);
		}
		// vertical alignment
		switch (valign) {
		    case "T": p.y -= h; break;
		    case "B": p.y += jQuery(el).outerHeight(); break;
		    case "C": p.y += (jQuery(el).outerHeight() - h) / 2; break;
		    case "t": p.y += jQuery(el).outerHeight() - h; break;
		    case "b": break; // already there
		}
		// horizontal alignment
		switch (halign) {
		    case "L": p.x -= w; break;
		    case "R": p.x += jQuery(el).outerWidth(); break;
		    case "C": p.x += (jQuery(el).outerWidth() - w) / 2; break;
		    case "l": p.x += jQuery(el).outerWidth() - w; break;
		    case "r": break; // already there
		}
		p.width = w;
		p.height = h + 40;
		self.monthsCombo.style.display = "none";
		fixPosition(p);
		self.showAt(p.x, p.y);
	};
    Calendar.continuation_for_the_khtml_browser();
};

/** Customizes the date format. */
Calendar.prototype.setDateFormat = function (str) {
	this.dateFormat = str;
};

/** Customizes the tooltip date format. */
Calendar.prototype.setTtDateFormat = function (str) {
	this.ttDateFormat = str;
};

/**
 *  Tries to identify the date represented in a string.  If successful it also
 *  calls this.setDate which moves the calendar to the given date.
 */
Calendar.prototype.parseDate = function(str, fmt) {
	if (!fmt)
		fmt = this.dateFormat;
	this.setDate(Date.parseDate(str, fmt));
};


/** Internal function; it displays the bar with the names of the weekday. */
Calendar.prototype._displayWeekdays = function () {
	var fdow = this.firstDayOfWeek;
	var cell = this.firstdayname;
	var weekend = Calendar._TT["WEEKEND"];
	for (var i = 0; i < 7; ++i) {
		cell.className = "day name";
		var realday = (i + fdow) % 7;
		if (i) {
			cell.ttip = Calendar._TT["DAY_FIRST"].replace("%s", Calendar._DN[realday]);
			cell.navtype = 100;
			cell.calendar = this;
			cell.fdow = realday;
			Calendar._add_evs(cell);
		}
		if (weekend.indexOf(realday.toString()) != -1) {
			Calendar.addClass(cell, "weekend");
		}
		cell.innerHTML = Calendar._SDN[(i + fdow) % 7];
		cell = cell.nextSibling;
	}
};

/** Internal function.  Hides all combo boxes that might be displayed. */
Calendar.prototype._hideCombos = function () {
	this.monthsCombo.style.display = "none";
	this.yearsCombo.style.display = "none";
};

/** Internal function.  Starts dragging the element. */
Calendar.prototype._dragStart = function (ev) {
	if (this.dragging) {
		return;
	}
	this.dragging = true;
	var posX;
	var posY;
	if (Calendar.is_ie) {
		posY = window.event.clientY + document.body.scrollTop;
		posX = window.event.clientX + document.body.scrollLeft;
	} else {
		posY = ev.clientY + window.scrollY;
		posX = ev.clientX + window.scrollX;
	}
	var st = this.element.style;
	this.xOffs = posX - parseInt(st.left);
	this.yOffs = posY - parseInt(st.top);
	with (Calendar) {
		addEvent(document, "mousemove", calDragIt);
		addEvent(document, "mouseup", calDragEnd);
	}
};

// BEGIN: DATE OBJECT PATCHES

/** Adds the number of days array to the Date object. */
Date._MD = new Array(31,28,31,30,31,30,31,31,30,31,30,31);

/** Constants used for time computations */
Date.SECOND = 1000 /* milliseconds */;
Date.MINUTE = 60 * Date.SECOND;
Date.HOUR   = 60 * Date.MINUTE;
Date.DAY    = 24 * Date.HOUR;
Date.WEEK   =  7 * Date.DAY;

/**
 * Splits based on multiple seprators as opposed to String.split, which takes only 1 separator
 */
Date._multisplit = function(s,seps) {
	if (s == null) {
		return null;
	}
	if (seps == null) {
		seps = "";
	}
	var arr = [];
	var len = s.length;
	var token = "";
	var inWord = false;
	for (i = 0; i < len; i++) {
		var c = s.charAt(i);
		if (seps.indexOf(c) == -1) {
			// it a non seperator
			inWord = true;
			token += c;
		} else {
			// its a separator
			if (inWord) {
				// finish of the last word first
				arr[arr.length] = token;
				token = "";
				inWord = false;
			}
			// ignore the sep character
		}
	}
	if (token.length > 0) {
		arr[arr.length] = token;
	}
	// in case the pass in a empty string to start with
	if (arr.length == 0) {
		arr[arr.length] = "";
	}
	return arr;
}

/**
 * This returns the characters in a string that are not part of the DHTML Calendar special
 * magic format characters, eg the ones that start with % something.
 */
Date._parseNonDateFormatChars = function(s) {
	//
	// as taken from code and documentation online
	// http://www.dynarch.com/demos/jscalendar/doc/html/reference.html#node_sec_5.3.6
	//
	var magicChars = "aAbBCdeHIJklmMnpPRSstUWVuwyY%";
	var nonMagicChars = "";
	var len = s.length;
	var inMagic = false;
	for (i = 0; i < len; i++) {
		var c = s.charAt(i);
		if (c == "%") {
			// peek ahead  and we always jump ahead too
			var peekc = "";
			if (i+1 < len) {
				peekc = s.charAt(i+1);
			}
			i = i+1;
			if (peekc.length > 0 && magicChars.indexOf(peekc) != -1) {
				// we have a magic chars so eat it
				continue;
			} else {
				// we have a non magic chars preceded by a % (weird huh?) so put it in the list if its not there already
				if (nonMagicChars.indexOf(c) == -1) {
					nonMagicChars += c;
				}
				if (peekc.length > 0 && nonMagicChars.indexOf(peekc) == -1) {
					nonMagicChars += peekc;
				}
			}
		} else {
			// we have a non magic chars so put it in the list if its not there already
			if (nonMagicChars.indexOf(c) == -1) {
					nonMagicChars += c;
			}
		}
	}
	return nonMagicChars;
}

Date.parseDate = function(str, fmt) {


    var today = new Date();
	var y = 0;
	var m = -1;
	var d = 0;
    // The old code used a regex /\W+/ that only worked for ISO Latin character sets
    // so we have replaced this with two new functions that parse out the non date format
    // characters and then splits the input value based on these non formatting characters.
    //
    //var a = str.split(/\W+/);
    var seps = Date._parseNonDateFormatChars(fmt);
    var a = Date._multisplit(str,seps);
    var b = fmt.match(/%./g);

    var i = 0, j = 0;
	var hr = 0;
	var min = 0;
	for (i = 0; i < a.length; ++i) {
		if (!a[i])
			continue;
		switch (b[i]) {
		    case "%d":
		    case "%e":
			d = parseInt(a[i], 10);
			break;

		    case "%m":
			m = parseInt(a[i], 10) - 1;
			break;

		    case "%Y":
		    case "%y":
			y = parseInt(a[i], 10);
			(y < 100) && (y += (y > 29) ? 1900 : 2000);
			break;

            //
            // the old code was too liberal in how it found month names and assumed that the short month name
            // was always contained within the long month name.  But this not always so.  So lets get more specific
            // and stop thinking %b and %B are equivalent.
            //
//          case "%b":
//		    case "%B":
//			for (j = 0; j < 12; ++j) {
//				if (Calendar._MN[j].substr(0, a[i].length).toLowerCase() == a[i].toLowerCase()) { m = j; break; }
//			}
//			break;
//
            case "%b":
            case "%B":

            var monthName = a[i].toLowerCase();
            var found = false;
            if (b[i] == "%b") {
                for (j = 0; j < 12; ++j) {
                    // check most specific first
                    if (Calendar._SMN[j].substr(0, monthName.length).toLowerCase() == monthName) {
                        m = j;
                        found = true;
                        break;
                    }
                }
            }
            if (! found) {
                // do it the old code way even for %b if need be
                for (j = 0; j < 12; ++j) {
                     if (Calendar._MN[j].substr(0, monthName.length).toLowerCase() == monthName) {
                         m = j;
                         break;
                     }
                 }
            }
            break;

            case "%H":
		    case "%I":
		    case "%k":
		    case "%l":
			hr = parseInt(a[i], 10);
			break;

		    case "%P":
		    case "%p":
			if (/pm/i.test(a[i]) && hr < 12)
				hr += 12;
			else if (/am/i.test(a[i]) && hr >= 12)
				hr -= 12;
			break;

		    case "%M":
			min = parseInt(a[i], 10);
			break;

            case "%R":
                var hrMinString = a[ i ];
                var hrMinSeparator = hrMinString.indexOf(":");
                var hrString = hrMinString.substring( 0, hrMinSeparator );
                var minString = hrMinSeparator == -1 ? 0 : hrMinString.substring( hrMinSeparator + 1 );

                hr = parseInt( hrString, 10 );
                min = parseInt( minString, 10 );
                break;
        }
	}
	if (isNaN(y)) y = today.getFullYear();
	if (isNaN(m)) m = today.getMonth();
	if (isNaN(d)) d = today.getDate();
	if (isNaN(hr)) hr = today.getHours();
	if (isNaN(min)) min = today.getMinutes();
	if (y != 0 && m != -1 && d != 0)
		return new Date(y, m, d, hr, min, 0);
	y = 0; m = -1; d = 0;
	for (i = 0; i < a.length; ++i) {
		if (a[i].search(/[a-zA-Z]+/) != -1) {
			var t = -1;
			for (j = 0; j < 12; ++j) {
				if (Calendar._MN[j].substr(0, a[i].length).toLowerCase() == a[i].toLowerCase()) { t = j; break; }
			}
			if (t != -1) {
				if (m != -1) {
					d = m+1;
				}
				m = t;
			}
		} else if (parseInt(a[i], 10) <= 12 && m == -1) {
			m = a[i]-1;
		} else if (parseInt(a[i], 10) > 31 && y == 0) {
			y = parseInt(a[i], 10);
			(y < 100) && (y += (y > 29) ? 1900 : 2000);
		} else if (d == 0) {
			d = a[i];
		}
	}
	if (y == 0)
		y = today.getFullYear();
	if (m != -1 && d != 0)
		return new Date(y, m, d, hr, min, 0);
	return today;
};

/** Returns the number of days in the current month */
Date.prototype.getMonthDays = function(month) {
	var year = this.getFullYear();
	if (typeof month == "undefined") {
		month = this.getMonth();
	}
	if (((0 == (year%4)) && ( (0 != (year%100)) || (0 == (year%400)))) && month == 1) {
		return 29;
	} else {
		return Date._MD[month];
	}
};

/** Returns the number of day in the year. */
Date.prototype.getDayOfYear = function() {
	// JRA-19533 -- We use an hour of 13 to avoid potential DST problems.
	var now = new Date(this.getFullYear(), this.getMonth(), this.getDate(), 13, 0, 0);
	var then = new Date(this.getFullYear(), 0, 0, 13, 0, 0);
	var time = now - then;
	return Math.floor(time / Date.DAY);
};

/** Returns the number of the week in year, as defined in ISO 8601. */
Date.prototype.getWeekNumber = function(startOfWeek) {
    if (Date.useISO8601WeekNumbers) {
        return this.getISO8601WeekNumber();
    } else {
        return this.getSimpleWeekNumber(startOfWeek);
    }
};

/* Algorithm taken from: http://www.staff.science.uu.nl/~gent0113/calendar/isocalendar.htm
 */
Date.prototype.getISO8601WeekNumber = function() {
    function gregdaynumber(year, month, day)
    {
        // computes the day number since 0 January 0 CE (Gregorian)

        y = year;
        m = month;
        if (month < 3)
        {
            y = y - 1;
        }
        if (month < 3)
        {
            m = m + 12;
        }
        return Math.floor(365.25 * y) - Math.floor(y / 100) + Math.floor(y / 400) + Math.floor(30.6 * (m + 1)) + day - 62;
    }

    function isocalendar1(date)
    {

        // computes the ISO calendar date from the current Gregorian date
        year = date.getFullYear();
        month = date.getMonth(); // 0=January, 1=February, etc.
        day = date.getDate();
        wday = date.getDay();

        weekday = ((wday + 6) % 7) + 1; // weekdays will be numbered 1 to 7

        isoyear = year;

        d0 = gregdaynumber(year, 1, 0);
        weekday0 = ((d0 + 4) % 7) + 1;

        d = gregdaynumber(year, month + 1, day);
        isoweeknr = Math.floor((d - d0 + weekday0 + 6) / 7) - Math.floor((weekday0 + 3) / 7);

        // check whether the last few days of December belong to the next year's ISO week

        if ((month == 11) && ((day - weekday) > 27))
        {
            isoweeknr = 1;
            isoyear = isoyear + 1;
        }

        // check whether the first few days of January belong to the previous year's ISO week
        if ((month == 0) && ((weekday - day) > 3))
        {
            d0 = gregdaynumber(year - 1, 1, 0);
            weekday0 = ((d0 + 4) % 7) + 1;
            isoweeknr = Math.floor((d - d0 + weekday0 + 6) / 7) - Math.floor((weekday0 + 3) / 7);
            isoyear = isoyear - 1;
        }

        return isoweeknr;
    }

    return isocalendar1(this);
}

/* Algorithm taken from: http://www.merlyn.demon.co.uk/weekcalc.htm#NIP
   Blame them for the shit variable and function names. Seriously, WTF?
   This is "Type 1" with a Sun-Sat row.

   Using the simple week counting you need to know
   the start of week so you can do the calculations properly.

   If you don't specify a startOfWeek then Sunday is used.
*/

Date.prototype.getSimpleWeekNumber = function(startOfWeek)
{
    function OddWkNo1(D, d1, d2)
    {
        var Yr = D.getFullYear(), Jan1 = new Date(Yr, 0, 1), Q;
        Q = Math.round((D - Jan1) / 86400000);
        if (d1 != null)
        {
            Q -= (7 + d1 - Jan1.getDay()) % 7;
        }
        if (d2 != null)
        {
            Q += d2;
        }
        return [Yr, 1 + Q / 7 | 0, 1 + (7 + Q) % 7];
    }

    return OddWkNo1(this, startOfWeek ? startOfWeek : 6, 6)[1];
//    return OddWkNo1(this, 6, 6)[1];
}

/** Checks date and time equality */
Date.prototype.equalsTo = function(date) {
	return ((this.getFullYear() == date.getFullYear()) &&
		(this.getMonth() == date.getMonth()) &&
		(this.getDate() == date.getDate()) &&
		(this.getHours() == date.getHours()) &&
		(this.getMinutes() == date.getMinutes()));
};

/** Set only the year, month, date parts (keep existing time) */
Date.prototype.setDateOnly = function(date) {
	var tmp = new Date(date);
	this.setDate(1);
	this.setFullYear(tmp.getFullYear());
	this.setMonth(tmp.getMonth());
	this.setDate(tmp.getDate());
};

/** Prints the date in a string according to the given format. */
Date.prototype.print = function (str) {

    var m = this.getMonth();
	var d = this.getDate();
	var y = this.getFullYear();
	var wn = this.getWeekNumber();
	var w = this.getDay();
	var s = {};
	var hr = this.getHours();
	var pm = (hr >= 12);
	var ir = (pm) ? (hr - 12) : hr;
	var dy = this.getDayOfYear();
	if (ir == 0)
		ir = 12;
	var min = this.getMinutes();
	var sec = this.getSeconds();
	s["%a"] = Calendar._SDN[w]; // abbreviated weekday name [FIXME: I18N]
	s["%A"] = Calendar._DN[w]; // full weekday name
	s["%b"] = Calendar._SMN[m]; // abbreviated month name [FIXME: I18N]

    s["%B"] = Calendar._MN[m]; // full month name
	// FIXME: %c : preferred date and time representation for the current locale
	s["%C"] = 1 + Math.floor(y / 100); // the century number
	s["%d"] = (d < 10) ? ("0" + d) : d; // the day of the month (range 01 to 31)
	s["%e"] = d; // the day of the month (range 1 to 31)
	// FIXME: %D : american date style: %m/%d/%y
	// FIXME: %E, %F, %G, %g, %h (man strftime)
	s["%H"] = (hr < 10) ? ("0" + hr) : hr; // hour, range 00 to 23 (24h format)
	s["%I"] = (ir < 10) ? ("0" + ir) : ir; // hour, range 01 to 12 (12h format)
	s["%j"] = (dy < 100) ? ((dy < 10) ? ("00" + dy) : ("0" + dy)) : dy; // day of the year (range 001 to 366)
	s["%k"] = hr;		// hour, range 0 to 23 (24h format)
	s["%l"] = ir;		// hour, range 1 to 12 (12h format)
	s["%m"] = (m < 9) ? ("0" + (1+m)) : (1+m); // month, range 01 to 12
	s["%M"] = (min < 10) ? ("0" + min) : min; // minute, range 00 to 59
	s["%n"] = "\n";		// a newline character
	s["%p"] = pm ? Calendar._TT["PM"] : Calendar._TT["AM"]
	s["%P"] = pm ? Calendar._TT["PM"] : Calendar._TT["AM"]
	// FIXME: %r : the time in am/pm notation %I:%M:%S %p
	// FIXME: %R : the time in 24-hour notation %H:%M
    s["%R"] = s["%k"] + ":" + s["%M"];



    s["%s"] = Math.floor(this.getTime() / 1000);
	s["%S"] = (sec < 10) ? ("0" + sec) : sec; // seconds, range 00 to 59
	s["%t"] = "\t";		// a tab character
	// FIXME: %T : the time in 24-hour notation (%H:%M:%S)
	s["%U"] = s["%W"] = s["%V"] = (wn < 10) ? ("0" + wn) : wn;
	s["%u"] = w + 1;	// the day of the week (range 1 to 7, 1 = MON)
	s["%w"] = w;		// the day of the week (range 0 to 6, 0 = SUN)
	// FIXME: %x : preferred date representation for the current locale without the time
	// FIXME: %X : preferred time representation for the current locale without the date
	s["%y"] = ('' + y).slice(-2); // year without the century (range 00 to 99)
	s["%Y"] = y;		// year with the century
	s["%%"] = "%";		// a literal '%' character

	var re = /%./g;
	if (!Calendar.is_ie5 && !Calendar.is_khtml)
		return str.replace(re, function (par) { return s[par] || par; });

	var a = str.match(re);
	for (var i = 0; i < a.length; i++) {
		var tmp = s[a[i]];
		if (tmp) {
			re = new RegExp(a[i], 'g');
			str = str.replace(re, tmp);
		}
	}

	return str;
};

Date.prototype.__msh_oldSetFullYear = Date.prototype.setFullYear;
Date.prototype.setFullYear = function(y) {
	var d = new Date(this);
	d.__msh_oldSetFullYear(y);
	if (d.getMonth() != this.getMonth())
		this.setDate(28);
	this.__msh_oldSetFullYear(y);
};

// END: DATE OBJECT PATCHES


// global object that remembers the calendar
window._dynarch_popupCalendar = null;
;
;
/* module-key = 'jira.webresources:calendar', location = '/includes/lib/calendar/Calendar.setup.js' */
/*  Copyright Mihai Bazon, 2002, 2003  |  http://dynarch.com/mishoo/
 * ---------------------------------------------------------------------------
 *
 * The DHTML Calendar
 *
 * Details and latest version at:
 * http://dynarch.com/mishoo/calendar.epl
 *
 * This script is distributed under the GNU Lesser General Public License.
 * Read the entire license text here: http://www.gnu.org/licenses/lgpl.html
 *
 * This file defines helper functions for setting up the calendar.  They are
 * intended to help non-programmers get a working calendar on their site
 * quickly.  This script should not be seen as part of the calendar.  It just
 * shows you what one can do with the calendar, while in the same time
 * providing a quick and simple method for setting it up.  If you need
 * exhaustive customization of the calendar creation process feel free to
 * modify this code to suit your needs (this is recommended and much better
 * than modifying calendar.js itself).
 */

// $Id: calendar-setup.js,v 1.1 2005/04/26 03:29:58 mchai Exp $

/**
 *  This function "patches" an input field (or other element) to use a calendar
 *  widget for date selection.
 *
 *  The "params" is a single object that can have the following properties:
 *
 *    prop. name   | description
 *  -------------------------------------------------------------------------------------------------
 *   inputField    | the ID of an input field to store the date
 *   displayArea   | the ID of a DIV or other element to show the date
 *   button        | ID of a button or other element that will trigger the calendar
 *   eventName     | event that will trigger the calendar, without the "on" prefix (default: "click")
 *   ifFormat      | date format that will be stored in the input field
 *   daFormat      | the date format that will be used to display the date in displayArea
 *   singleClick   | (true/false) whether the calendar is in single click mode or not (default: true)
 *   firstDay      | numeric: 0 to 6.  "0" means display Sunday first, "1" means display Monday first, etc.
 *   align         | alignment (default: "Br"); if you don't know what's this see the calendar documentation
 *   range         | array with 2 elements.  Default: [1900, 2999] -- the range of years available
 *   weekNumbers   | (true/false) if it's true (default) the calendar will display week numbers
 *   flat          | null or element ID; if not null the calendar will be a flat calendar having the parent with the given ID
 *   flatCallback  | function that receives a JS Date object and returns an URL to point the browser to (for flat calendar)
 *   disableFunc   | function that receives a JS Date object and should return true if that date has to be disabled in the calendar
 *   onSelect      | function that gets called when a date is selected.  You don't _have_ to supply this (the default is generally okay)
 *   onClose       | function that gets called when the calendar is closed.  [default]
 *   onUpdate      | function that gets called after the date is updated in the input field.  Receives a reference to the calendar.
 *   date          | the date that the calendar will be initially displayed to
 *   todayDate     | the date-time that the calendar will user with the Today button
 *   showsTime     | default: false; if true the calendar will include a time selector
 *   timeFormat    | the time format; can be "12" or "24", default is "12"
 *   electric      | if true (default) then given fields/date areas are updated for each move; otherwise they're updated only on close
 *   step          | configures the step of the years in drop-down boxes; default: 2
 *   position      | configures the calendar absolute position; default: null
 *   cache         | if "true" (but default: "false") it will reuse the same calendar object, where possible
 *   showOthers    | if "true" (but default: "false") it will show days from other months too
 *
 *  None of them is required, they all have default values.  However, if you
 *  pass none of "inputField", "displayArea" or "button" you'll get a warning
 *  saying "nothing to setup".
 */
Calendar.setup = function (params) {
    params = params || {};

	function param_default(pname, def) { if (typeof params[pname] == "undefined") { params[pname] = def; } };

	param_default("inputField",     null);
	param_default("context",        null);
	param_default("displayArea",    null);
	param_default("button",         null);
	param_default("eventName",      "click");
	param_default("ifFormat",       "%Y/%m/%d");
	param_default("daFormat",       "%Y/%m/%d");
	param_default("singleClick",    true);
	param_default("disableFunc",    null);
	param_default("dateStatusFunc", params["disableFunc"]);	// takes precedence if both are defined
	param_default("dateText",       null);
	param_default("firstDay",       null);
	param_default("align",          "Br");
	param_default("range",          [1900, 2999]);
	param_default("weekNumbers",    true);
     /*
     Set this to true if you want to use the ISO 8601 week numbering scheme.  This was the old default.
     But is now the week contain Jan 01 is considered the first week of the year after many customer requests
     so we now useISO8601WeekNumbers is false by default. 
    */
    param_default("useISO8601WeekNumbers",    false);

    param_default("flat",           null);
	param_default("flatCallback",   null);
	param_default("onSelect",       null);
	param_default("onClose",        null);
	param_default("onUpdate",       null);
	param_default("date",           null);
	param_default("todayDate",      null);
	param_default("showsTime",      false);
	param_default("timeFormat",     "24");
	param_default("electric",       true);
	param_default("step",           1);
	param_default("position",       null);
	param_default("cache",          false);
	param_default("showOthers",     false);
	param_default("multiple",       null);

    var i, item;

    // Unwrap jQuery and deal with the base Element.
    var unwrap = ["context", "inputField", "button", "displayArea"];
    for(i in unwrap) {
        item = unwrap[i];
        if (params[item] instanceof jQuery) {
            params[item] = params[item][0];
        }
    }

	var tmp = ["inputField", "displayArea", "button"];
	for (i in tmp) {
        item = tmp[i];
		if (typeof params[item] === "string") {
            /**
             * TODO JDEV-27991: Kill this ID string. The API of Calendar#setup should NOT accept an ID of an element, it should take the element itself.
             * Then there'd be no need to search within a context and do all this stupid stuff.
             */
            var escapedSelector = "#" + params[item].escapejQuerySelector();
            var el = jQuery(params.context || document.body).find(escapedSelector);
            params[item] = el[0];
		}
	}

	if (!(params.flat || params.multiple || params.inputField || params.displayArea || params.button)) {
        /* [logging] */
		AJS.log("Calendar.setup:\n  Nothing to setup (no fields found).  Please check your code");
        /* [logging] end */
		return false;
	}

    if (params.firstDay && params.firstDay !== null) {
        params.firstDay = +params.firstDay; // Convert firstDay from a string to a number
    }

	function onSelect(cal) {
		var p = cal.params;
		var update = (cal.dateClicked || p.electric);
		if (update && p.inputField) {
			p.inputField.value = cal.date.print(p.ifFormat);
            jQuery(p.inputField).change();            
		}
		if (update && p.displayArea)
			p.displayArea.innerHTML = cal.date.print(p.daFormat);
		if (update && typeof p.onUpdate == "function")
			p.onUpdate(cal);
		if (update && p.flat) {
			if (typeof p.flatCallback == "function")
				p.flatCallback(cal);
		}
        if (p.singleClick === "true") {
            p.singleClick = true;
        } else if (p.singleClick === "false") {
            p.singleClick = false;
        }
		if (update && p.singleClick && cal.dateClicked)
			cal.callCloseHandler();
	}

	if (params.flat != null) {
		if (typeof params.flat == "string")
			params.flat = document.getElementById(params.flat);
		if (!params.flat) {
            /* [logging] */
			AJS.log("Calendar.setup:\n  Flat specified but can't find parent.");
            /* [logging] end */
			return false;
		}
		var cal = new Calendar(params.firstDay, params.date, params.todayDate, params.onSelect || onSelect);
		cal.showsOtherMonths = params.showOthers;
		cal.showsTime = params.showsTime;
		cal.time24 = (params.timeFormat == "24");
		cal.params = params;
		cal.weekNumbers = params.weekNumbers;
		cal.setRange(params.range[0], params.range[1]);
		cal.setDateStatusHandler(params.dateStatusFunc);
		cal.getDateText = params.dateText;
		if (params.ifFormat) {
			cal.setDateFormat(params.ifFormat);
		}
		if (params.inputField && typeof params.inputField.value == "string") {
			cal.parseDate(params.inputField.value);
		}
		cal.create(params.flat);
		cal.show();
		return false;
	}

	var triggerEl = params.button || params.displayArea || params.inputField;

    jQuery(triggerEl).bind(params.eventName, function (e) {
        e.preventDefault();
        createCalendar();
    });

    if (params.inputField) {
        enhanceInputField();
    }

    function createCalendar() {
        if  (Calendar._UNSUPPORTED === true) {
            /* [alert] */
            alert("The JIRA Calendar does not currently support your language.");
            /* [alert] end */
            return;
        }
		var dateEl = params.inputField || params.displayArea;
		var dateFmt = params.inputField ? params.ifFormat : params.daFormat;
		var mustCreate = false;
		var cal = window.calendar;
		if (cal) {
			cal.hide();
		}

		if (dateEl) {
            if (dateEl.value || dateEl.innerHTML) {
                params.date = Date.parseDate(dateEl.value || dateEl.innerHTML, dateFmt);
            }
        }

		if (!(cal && params.cache)) {
			window.calendar = cal = new Calendar(params.firstDay,
							     params.date,
				 			     params.todayDate,
							     params.onSelect || onSelect,
							     params.onClose || function(cal) { cal.hide(); });
			cal.showsTime = params.showsTime;
			cal.time24 = (params.timeFormat == "24");
			cal.weekNumbers = params.weekNumbers;
            // BB - At the Date object level not Calendar
            Date.useISO8601WeekNumbers = params.useISO8601WeekNumbers;
            if (params.useISO8601WeekNumbers) {
                // ISO8601 assumes that first day of week is Monday
                cal.firstDayOfWeek = 1;
            }
            mustCreate = true;
		} else {
			if (params.date)
				cal.setDate(params.date);
			cal.hide();
		}
		if (params.multiple) {
			cal.multiple = {};
			for (var i = params.multiple.length; --i >= 0;) {
				var d = params.multiple[i];
				var ds = d.print("%Y%m%d");
				cal.multiple[ds] = d;
			}
		}
		cal.showsOtherMonths = params.showOthers;
		cal.yearStep = params.step;
		cal.setRange(params.range[0], params.range[1]);
		cal.params = params;
		cal.setDateStatusHandler(params.dateStatusFunc);
		cal.getDateText = params.dateText;
		cal.setDateFormat(dateFmt);
		if (mustCreate)
			cal.create();
		cal.refresh();
		if (!params.position)
			cal.showAtElement(params.button || params.displayArea || params.inputField, params.align);
		else
			cal.showAt(params.position[0], params.position[1]);
		return false;
	}

    // UX enhancements for when the calendar is used in conjunction with an input
    function enhanceInputField() {
        var $inputField = jQuery(params.inputField);

        // Prevent interactions with the calendar from blurring input.
        // Since the calendar already prevents default on mousedown inside the calendar popup,
        // this only needs to be done for the trigger button.
        if (params.button) {
            jQuery(params.button).mousedown(function(e) {
                e.preventDefault();

                // Give the inputField focus if it doesn't have it already.
                // Do not attempt to focus a disabled form element.
                if (!$inputField.is(':focus') && $inputField.is(":enabled")) {
                    $inputField.focus();
                }
            });
        }

        $inputField.keydown(function (e) {
            var cal = window.calendar;

            if (e.keyCode === 40) { // Down
                if (!cal || cal.hidden) {
                    // setTimeout is needed so that pressing the down arrow doesn't create the calendar AND cause the date to jump by a week
                    setTimeout(function() {
                        createCalendar();
                    }, 1);
                }
            }
        });
    }

	return cal;
};
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/dropdown/Dropdown.js' */
/**
 * Creates a dropdown list from a JSON object
 *
 * @constructor JIRA.Dropdown
 * @deprecated
 * @author Scott Harwood
 *
 * NOTE: Please use {@link Dropdown} instead of this for future dropdown implementations.
 */
JIRA.Dropdown = (function() {

    // private

    var instances = [];

    return /** @lends JIRA.Dropdown */ {

        // public

        /**
         * Adds this instance to private var <em>instances</em>
         * This reference can be used to access all instances
         */
        addInstance: function() {
            instances.push(this);
        },


        /**
         * Calls the hideList method on all instances of <em>dropdown</em>
         */
        hideInstances: function() {
            var that = this;
            jQuery(instances).each(function(){
                if (that !== this) {
                    this.hideDropdown();
                }
            });
        },


        getHash: function () {
            if (!this.hash) {
                this.hash = {
                    container: this.dropdown,
                    hide: this.hideDropdown,
                    show: this.displayDropdown
                };
            }
            return this.hash;
        },

        /**
         * Calls <em>hideInstances</em> method to hide all other dropdowns.
         * Adds <em>active</em> class to <em>dropdown</em> and styles to make it visible.
         */
        displayDropdown: function() {
            if (JIRA.Dropdown.current === this) {
                return;
            }

            this.hideInstances();
            JIRA.Dropdown.current = this;
            this.dropdown.css({display: "block"});

            this.displayed = true;

            var dd = this.dropdown;
            if (window.top.JIRA && !window.top.JIRA.Dialog.current) {
                setTimeout(function() {
                    // Scroll dropdown into view
                    var win = jQuery(window);
                    var minScrollTop = dd.offset().top + dd.prop("offsetHeight") - win.height() + 10;

                    if (win.scrollTop() < minScrollTop) {
                        jQuery("html,body").animate({scrollTop: minScrollTop}, 300, "linear");
                    }
                }, 100);
            }
        },

        /**
         * Removes <em>active</em> class from <em>dropdown</em> and styles to make it hidden.
         */
        hideDropdown: function() {
            if (this.displayed === false) {
                return;
            }

            JIRA.Dropdown.current = null;
            this.dropdown.css({display: "none"});

            this.displayed = false;
        },

        /**
         * Initialises instance by, applying primary handler, user options and a Internet Explorer hack.
         * @param {HTMLElement} trigger
         * @param {HTMLElement} dropdown
         */
        init: function(trigger, dropdown) {

            var that = this;

            this.addInstance(this);
            this.dropdown = jQuery(dropdown);

            this.dropdown.css({display: "none"});

            // hide dropdown on tab
            jQuery(document).keydown(function(e){
                if(e.keyCode === 9) {
                    that.hideDropdown();
                }
            });

            // this instance is triggered by a method call
            if (trigger.target) {
                jQuery.aop.before(trigger, function(){
                    if (!that.displayed) {
                        that.displayDropdown();
                    }
                });

            // this instance is triggered by a click event
            } else {
                that.dropdown.css("top",jQuery(trigger).outerHeight() + "px");
                trigger.click(function(e){
                    if (!that.displayed) {
                        that.displayDropdown();
                        e.stopPropagation();
                        // lets not follow the link (if it is a link)
                    } else {
                        that.hideDropdown();
                    }
                    e.preventDefault();
                });
            }

            // hide dropdown when click anywhere other than on this instance
            jQuery(document.body).click(function(){
                if (that.displayed) {
                    that.hideDropdown();
                }
            });
        }
    };

})();

/**
 * Standard dropdown constructor
 * @constuctor JIRA.Dropdown.Standard
 * @extends JIRA.Dropdown
 * @param {HTMLElement} trigger
 * @param {HTMLElement} dropdown
 * @return {JIRA.Dropdown} instance
 */
JIRA.Dropdown.Standard = function(trigger, dropdown) {

    /** @lends JIRA.Dropdown.Standard.prototype */
    var that = begetObject(JIRA.Dropdown);
    that.init(trigger, dropdown);

    return that;
};

/**
 * Standard dropdown constructor
 * @constructor JIRA.Dropdown.AutoComplete
 * @extends JIRA.Dropdown
 * @param {HTMLElement} trigger
 * @param {HTMLElement} dropdown
 * @return {Object} - instance
 */
JIRA.Dropdown.AutoComplete = function(trigger, dropdown) {

    /** @lends JIRA.Dropdown.AutoComplete.prototype */
    var that = begetObject(JIRA.Dropdown);

    that.init = function(trigger, dropdown) {

        this.addInstance(this);
        this.dropdown = jQuery(dropdown).click(function(e){
            // lets not hide dropdown when we click on it
            e.stopPropagation();
        });
        this.dropdown.css({display: "none"});

        // this instance is triggered by a method call
        if (trigger.target) {
            jQuery.aop.before(trigger, function(){
                if (!that.displayed) {
                    that.displayDropdown();
                }
            });

        // this instance is triggered by a click event
        } else {
            trigger.click(function(e){
                if (!that.displayed) {
                    that.displayDropdown();
                    e.stopPropagation();
                }
            });
        }

        // hide dropdown when click anywhere other than on this instance
        jQuery(document.body).click(function(){
            if (that.displayed) {
                that.hideDropdown();
            }
        });
    };

    that.init(trigger, dropdown);

    return that;
};

/** Preserve legacy namespace
    @deprecated jira.widget.dropdown */
AJS.namespace("jira.widget.dropdown", null, JIRA.Dropdown);
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/AutoComplete.js' */
define('jira/autocomplete/autocomplete', [
    'jira/ajs/ajax/smart-ajax',
    'jira/util/objects',
    'jquery'
], function(
    SmartAjax,
    Objects,
    jQuery
) {

    /**
     * @class AutoComplete
     * @requires jQuery.aop
     */
    return function() {

        var inFocus;

        /**
         * Calls a callback after specified delay
         * @memberof AutoComplete.prototype
         * @param {Number} l - length of delay in <em>seconds</em>
         * @param {Function} callback - function to call after delay
         */
        var delay = function(callback,l) {
            if (delay.t) {
                clearTimeout(delay.t);
                delay.t = undefined;
            }
            delay.t = setTimeout(callback, l * 1000);
        };

        var INVALID_KEYS = {
              9: true,
             13: true,
             14: true,
             25: true,
             27: true,
             38: true,
             40: true,
            224: true
        };

        return /** @lends AutoComplete.prototype */{

            /**
            * Checks whether a saved version (cached) of the request exists, if not performs a request and saves response,
            * then dispatches saved response to <em>renderSuggestions</em> method.
            *
            * @public
            */
            dispatcher: function() {},


            /**
             * Gets cached response
             *
             * @public
             * @param {String} val
             * @returns {Object}
             */
            getSavedResponse: function() {},

            /**
             * Saves response
             *
             * @public
             * @param {String} val
             * @param {Object} response
             */
            saveResponse: function() {},

            /**
             * Called to render suggestions. Used to define interface only.
             * Rendering is difficult to make generic, best to leave this to extending prototypes.
             *
             * @public
             * @param {Object} res - results object
             */
            renderSuggestions: function() {},

            /**
             * Disables autocomplete. Useful for shared inputs.
             * i.e The selection of a radio button may disable the instance
             * @Public
             */
            disable: function() {
                this.disabled = true;
            },

            /**
             * Enables autocomplete. Useful for shared inputs.
             * i.e The selection of a radio button may disable the instance
             * @Public
             */
            enable: function() {
                this.disabled = false;
            },

            /**
             * Sets instance variables from options object
             * to do: make function create getters and setters
             * @public
             * @param {Object} options
             */
            set: function(options) {
                for (var name in options) {
                    // safeguard to stop looping up the inheritance chain
                    if (options.hasOwnProperty(name)) {
                        this[name] = options[name];
                    }
                }
            },

            /**
             * Adds value to input field
             * @public
             * @param {String} value
             */
            completeField: function(value) {
                if (value) {
                    this.field.val(value).focus();
                    this.field.trigger("change");
                }
            },

            /**
             * Returns the text from the start of the field up to the end of
             * the position where suggestions are generated from.
             */
            textToSuggestionCursorPosition: function () {
                return this.field.val();
            },


            /**
             * An ajax request filter that only allows one request at a time. If there is another it will abort then issue
             * the new request.
             *
             * @param options - jQuery formatted ajax options
             */
            _makeRequest: function (options) {
                var that = this,
                    requestParams = Objects.copyObject(options);

                // if we have we are still waiting for an old request, lets abort it as we are firing a new
                if (this.pendingRequest) {
                    this.pendingRequest.abort();
                }

                requestParams.complete = function () {
                    that.pendingRequest = null;
                };

                requestParams.error = function (xhr) {

                    // We abort stale requests and this subsequently throws an error so we need to check if the request is aborted first.
                    // We detect this using xhr.aborted property for native XHR requests but for "Microsoft.XMLHTTP" we use the status code, which is 0.
                    // Status code is set to 0 when it is an unknown error so sense to fail silently.
                    if (!xhr.aborted && xhr.status !== 0 && options.error) {
                        options.error.apply(this, arguments);
                    }
                };

                return this.pendingRequest = SmartAjax.makeRequest(requestParams);
            },

            /**
             * Allows users to navigate/select suggestions using the keyboard
             * @public
             */
             addSuggestionControls: function(suggestionNodes) {

                // reference to this for closures
                var that = this;

                /**
                 * Make sure the index is within the threshold
                 * Looks ugly! Has to be a better way.
                 * @private
                 * @param {Integer} idx
                 * @param {Integer} max
                 * @return {Integer} valid threshold
                 */
                var evaluateIndex = function(idx, max) {
                    var minBoundary = (that.autoSelectFirst === false) ? -1 : 0;
                    if (that.allowArrowCarousel) {
                        if (idx > max) {
                            return minBoundary;
                        } else if (idx < minBoundary) {
                            return max;
                        } else {
                            return idx;
                        }
                    }
                    else {
                        if (idx > max) {
                            return max;
                        } else if (idx < minBoundary) {
                            that.responseContainer.scrollTop(0);
                            return minBoundary;
                        } else {
                            return idx;
                        }
                    }
                };

                /**
                 * Highlights focused node and removes highlight from previous.
                 * Actual highlight styles to come from css, adding and removing classes here.
                 * @private
                 * @param {Integer} idx - Index of node to be highlighted
                 */
                var setActive = function(idx) {

                        // if nothing is selected, select the first suggestion
                        if (that.selectedIndex !== undefined && that.selectedIndex > -1) {
                            that.suggestionNodes[that.selectedIndex][0].removeClass("active");
                        }
                        that.selectedIndex = evaluateIndex(idx, that.suggestionNodes.length-1);
                        if (that.selectedIndex > -1) {
                            that.suggestionNodes[that.selectedIndex][0].addClass("active");
                        }
                };

                 /**
                  * Checks to see if there is actually a suggestion in focus before attempting to use it
                  * @private
                  * @returns {boolean}
                  */
                 var evaluateIfActive = function() {
                    return that.suggestionNodes && that.suggestionNodes[that.selectedIndex] &&
                           that.suggestionNodes[that.selectedIndex][0].hasClass("active");
                 };


                /**
                 * When the responseContainer (dropdown) is visible listen for keyboard events
                 * that represent focus or selection.
                 * @private
                 * @param {Object} e - event object
                 */
                var keyPressHandler = function(e) {
                    // only use keyboard events if dropdown is visible
                    if (that.responseContainer.is(":visible")) {
                        // if enter key is pressed check that there is a node selected, then hide dropdown and complete field
                        if (e.keyCode === 13) {
                            if (evaluateIfActive() && !that.pendingRequest) {
                                that.completeField(that.suggestionNodes[that.selectedIndex][1]);
                            }
                            e.preventDefault();
                            // hack - stop propagation to prevent dialog from submitting. Looking for eg JIRA.Dropdown.current doesn't work.
                            e.stopPropagation();
                        }
                    }
                };

                /**
                * sets focus on suggestion nodes using the "up" and "down" arrows
                * These events need to be fired on mouseup as modifier keys don't register on keypress
                * @private
                * @param {Object} e - event object
                */
                var keyboardNavigateHandler = function(e) {

                    // only use keyboard events if dropdown is visible
                    if (that.responseContainer.is(":visible")) {

                        // keep cursor inside input field
                        if (that.field[0] !== document.activeElement){
                            that.field.focus();
                        }
                        // move selection down when down arrow is pressed
                        if (e.keyCode === 40) {
                            setActive(that.selectedIndex + 1);
                            if (that.selectedIndex >= 0) {
                                // move selection up when up arrow is pressed
                                var containerHeight = that.responseContainer.height();
                                var bottom = that.suggestionNodes[that.selectedIndex][0].position().top + that.suggestionNodes[that.selectedIndex][0].outerHeight() ;

                                if (bottom - containerHeight > 0){
                                    that.responseContainer.scrollTop(that.responseContainer.scrollTop() + bottom - containerHeight + 2);
                                }
                            } else {
                                that.responseContainer.scrollTop(0);
                            }
                            e.preventDefault();
                        } else if (e.keyCode === 38) {
                            setActive(that.selectedIndex-1);
                            if (that.selectedIndex >= 0) {
                                // if tab key is pressed check that there is a node selected, then hide dropdown and complete field
                                var top = that.suggestionNodes[that.selectedIndex][0].position().top;
                                if (top < 0){
                                    that.responseContainer.scrollTop(that.responseContainer.scrollTop() + top - 2);
                                }
                            }
                            e.preventDefault();
                        } else if (e.keyCode === 9) {
                            if (evaluateIfActive()) {
                                that.completeField(that.suggestionNodes[that.selectedIndex][1]);
                                e.preventDefault();
                            } else {
                                that.dropdownController.hideDropdown();
                            }
                        }
                    }
                };

                if (suggestionNodes.length) {

                    this.selectedIndex = 0;
                    this.suggestionNodes = suggestionNodes;

                    for (var i=0; i < that.suggestionNodes.length; i++) {
                        var eventData = { instance: this, index: i };
                        this.suggestionNodes[i][0]
                            .bind("mouseover", eventData, activate)
                            .bind("mouseout", eventData, deactivate)
                            .bind("click", eventData, complete);
                    }

                    // make sure we don't bind more than once
                    if (!this.keyboardHandlerBinded) {
                        jQuery(this.field).keypress(keyPressHandler);
                        jQuery(this.field).keydown(keyboardNavigateHandler);
                        this.keyboardHandlerBinded = true;
                    }

                    // automatically select the first in the list
                    if(that.autoSelectFirst === false) {
                        setActive(-1);
                    } else {
                        setActive(0);
                    }

                    // sets the autocomplete singleton infocus var to this instance
                    // is used to toggle event propagation. In short, the instance that it is set to will not hide the
                    // dropdown each time you click the input field
                    inFocus = this;
                }

                function activate(event) {
                    if (that.dropdownController.displayed) {
                        setActive(event.data.index);
                    }
                }
                function deactivate(event) {
                    if (event.data.index === 0) {
                        that.selectedIndex = -1;
                    }
                    jQuery(this).removeClass("active");
                }
                function complete(event) {
                    that.completeField(that.suggestionNodes[event.data.index][1]);
                }
            },


            /**
             * Uses jquery empty command, this is VERY important as it unassigns handlers
             * used for mouseover, click events which expose an opportunity for memory leaks
             * @public
             */
            clearResponseContainer: function() {
                this.responseContainer.empty();
                this.suggestionNodes = undefined;
            },

            delay: delay,

            /**
             * Builds HTML container for suggestions.
             * Positions container top position to be that of the field height
             * @public
             */
            buildResponseContainer: function() {
                var inputParent = this.field.parent().addClass('atlassian-autocomplete');
                this.responseContainer = jQuery(document.createElement("div"));
                this.responseContainer.addClass("suggestions");
                this.positionResponseContainer();
                this.responseContainer.appendTo(inputParent);
            },

            positionResponseContainer: function() {
                this.responseContainer.css({ top: this.field.outerHeight() });
            },

            /**
             * Validates the keypress by making sure the field value is beyond the set threshold and the key was either an
             * up or down arrow
             * @public
             * @param {Object} e - event object
             */
            keyUpHandler: (function () {
                function callback() {
                    if (!this.responseContainer) {
                        this.buildResponseContainer();
                    }
                    // send value to dispatcher to check if we have already got the response or if we need to go
                    // back to the server
                    this.dispatcher(this.field.val());
                }

                return function (e) {
                    // only initialises once the field length is past set length
                    if (this.field.val().length >= this.minQueryLength) {
                        // don't do anything if the key pressed is "enter" or "down" or "up" or "right" "left"
                        if (!(e.keyCode in INVALID_KEYS) || (this.responseContainer && !this.responseContainer.is(":visible") && (e.keyCode === 38 || e.keyCode === 40))) {
                            callback.call(this);
                        }
                    }
                    return e;
                };
            })(),

            /**
             * Adds in methods via AOP to handle multiple selections
             * @Public
             */
            addMultiSelectAdvice: function(delim) {

                // reference to this for closures
                var that = this;

                /**
                 * Alerts user if value already exists
                 * @private
                 * @param {String} val - value that already exists, will be displayed in message to user.
                 */
                var alertUserValueAlreadyExists = function(val) {

                    // check if there is an existing alert before adding another
                    if (!alertUserValueAlreadyExists.isAlerting) {

                        alertUserValueAlreadyExists.isAlerting = true;

                        // create alert node and append it to the input field's parent, fade it in then out with a short
                        // delay in between.
                        //TODO: JRA-1800 - Needs i18n!
                        var userAlert = jQuery(document.createElement("div"))
                        .css({"float": "left", display: "none"})
                        .addClass("warningBox")
                        .html("Oops! You have already entered the value <em>" + val + "</em>" )
                        .appendTo(that.field.parent())
                        .show("fast", function(){
                            // display message for 4 seconds before fading out
                            that.delay(function(){
                                userAlert.hide("fast",function(){
                                    // removes element from dom
                                    userAlert.remove();
                                    alertUserValueAlreadyExists.isAlerting = false;
                                });
                            }, 4);
                        });
                    }
                };

              // rather than request the entire field return the last comma seperated value
                jQuery.aop.before({target: this, method: "dispatcher"}, function(innvocation){
                    // matches everything after last comma
                    var val = this.field.val();
                    innvocation[0] = jQuery.trim(val.slice(val.lastIndexOf(delim) + 1));
                    return innvocation;
                });

                // rather than replacing this field just append the new value
                jQuery.aop.before({target: this, method: "completeField"}, function(args){
                    var valueToAdd = args[0],
                    // create array of values
                    untrimmedVals = this.field.val().split(delim);
                    // trim the values in the array so we avoid extra spaces being appended to the usernames - see JRA-20657
                    var trimmedVals = jQuery(untrimmedVals).map(function() {
                            return jQuery.trim(this);
                       }).get();
                    // check if the value to append already exists. If it does then call alert to to tell user and sets
                    // the last value to "". The value to add will either appear:
                    // 1) at the start of the string
                    // 2) after some whitespace; or
                    // 3) directly after the delimiter
                    // It is assumed that the value is delimited by the delimiter character surrounded by any number of spaces.
                    if (!this.allowDuplicates && new RegExp("(?:^|[\\s" + delim + "])" + valueToAdd + "\\s*" + delim).test(this.field.val())) {
                        alertUserValueAlreadyExists(valueToAdd);
                        trimmedVals[trimmedVals.length-1] = "";
                    } else {
                        // add the new value to the end of the array and then an empty value so we
                        // can get an extra delimiter at the end of the joined string
                        trimmedVals[trimmedVals.length-1] = valueToAdd;
                        trimmedVals[trimmedVals.length] = "";
                    }

                    // join the array of values with the delimiter plus an extra space to make the list of values readable
                    args[0] = trimmedVals.join(delim.replace(/([^\s]$)/,"$1 "));

                    return args;
                });
            },


            /**
             * Adds and manages state of dropdown control
             * @Public
             */
            addDropdownAdvice: function() {
                var that = this;

                // add dropdown functionality to response container
                jQuery.aop.after({target: this, method: "buildResponseContainer"}, function(args){
                    this.dropdownController = JIRA.Dropdown.AutoComplete({target: this, method: "renderSuggestions"}, this.responseContainer);

                    jQuery.aop.after({ target: this.dropdownController, method: "hideDropdown" }, function () {
                        this.dropdown.removeClass("dropdown-ready");
                    });

                    return args;
                });

                // display dropdown afer suggestions are updated
                jQuery.aop.after({target: this, method: "renderSuggestions"}, function(args){
                    if (args && args.length > 0) {
                        this.dropdownController.displayDropdown();

                        if (this.maxHeight && this.dropdownController.dropdown.prop("scrollHeight") > this.maxHeight) {
                            this.dropdownController.dropdown.css({
                                height: this.maxHeight,
                                overflowX: "visible",
                                overflowY: "scroll"
                            });
                        } else if (this.maxHeight) {
                            this.dropdownController.dropdown.css({
                                height: "",
                                overflowX: "",
                                overflowY: ""
                            });
                        }
                        this.dropdownController.dropdown.addClass("dropdown-ready");
                    } else {
                        this.dropdownController.hideDropdown();
                    }
                    return args;
                });

                // hide dropdown after suggestion value is applied to field
                jQuery.aop.after({target: this, method: "completeField"}, function(args){
                    this.dropdownController.hideDropdown();
                    return args;
                });

                jQuery.aop.after({target: this, method: "keyUpHandler"}, function(e) {
                    // only initialises once the field length is past set length
                    if ((!(this.field.val().length >= this.minQueryLength) || e.keyCode === 27)
                            && this.dropdownController && this.dropdownController.displayed) {
                        this.dropdownController.hideDropdown();
                        if (e.keyCode === 27) {
                            e.stopPropagation();
                        }
                    }
                    return e;
                });
            },

            /**
             * Initialises autocomplete by setting options, and assigning event handler to input field.
             * @param {Object} options
             * @constructs
             */
            init: function(options) {
                var that = this;
                this.set(options);
                this.field = this.field || jQuery("#" + this.fieldID);
                 // turn off browser default autocomplete
                this.field.attr("autocomplete","off")
                .keyup(function(e){
                    if (!that.disabled) {
                        that.keyUpHandler(e);
                    }
                })
                .keydown(function (e) {
                    var ESC_KEY = 27;
                    // do not clear field in IE
                    if (e.keyCode === ESC_KEY && that.responseContainer && that.responseContainer.is(":visible")) {
                        e.preventDefault();
                    }
                })
                // this will stop the dropdown with the suggestions hiding whenever you click the field
                .click(function(e){
                    if (inFocus === that) {
                        e.stopPropagation();
                    }
                })
                .blur(function () {
                    // we don't want the request to come back and show suggestions if we have already moved away from field
                    if (that.pendingRequest) {
                        that.pendingRequest.abort();
                    }
                });

                this.addDropdownAdvice();

                if (options.delimChar) {
                    this.addMultiSelectAdvice(options.delimChar);
                }
            }
        };

    }();

});

/** Preserve legacy namespace
 @deprecated jira.widget.autocomplete */
AJS.namespace("jira.widget.autocomplete", null, require('jira/autocomplete/autocomplete'));
AJS.namespace('JIRA.AutoComplete', null, require('jira/autocomplete/autocomplete'));
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/RESTAutoComplete.js' */
define('jira/autocomplete/rest-autocomplete', [
    'jira/autocomplete/autocomplete',
    'jira/util/objects'
], function(
    AutoComplete,
    Objects
) {
    /**
     * Designed for prototypical inheritance !!Abstract only
     * @class RESTAutoComplete
     * @extends AutoComplete
     * @abstract
     */
    return function() {

        /** @lends RESTAutoComplete.prototype */
        var that = Objects.begetObject(AutoComplete);

       /**
        * Checks whether a saved version (cached) of the request exists, if not performs a request and saves response,
        * then dispatches saved response to <em>renderSuggestions</em> method.
        * @param {String} reqFieldVal
        */
        that.dispatcher = function(reqFieldVal) {

            // reference to "this" for use in closures
             var that = this;

             if (reqFieldVal.length < this.minQueryLength) {
                 return;
             }

             if (!this.getSavedResponse(reqFieldVal)) {
                // Add a delay so that we don't go the server for every keypress,
                // some people type fast and may have already typed an entire word by the time the server comes
                // back with a response

                this.delay(function(){
                    var params = that.getAjaxParams();
                    params.data.query = reqFieldVal;
                    params.success = function(data){
                        // for use later so we don't have to go back to the server for the same query
                        that.saveResponse(reqFieldVal, data);
                        // creates html elements from JSON object
                        that.responseContainer.scrollTop(0);
                        that.renderSuggestions(data);

                    };
                    that._makeRequest(params);

                }, that.queryDelay);
            } else {
                that.renderSuggestions(that.getSavedResponse(reqFieldVal));
                that.responseContainer.scrollTop(0);
            }
        };


        that.getAjaxParams = function(){};

        /**
         * Gets cached response from <em>requested</em> object
         * @param {String} val
         * @returns {Object}
         */
        that.getSavedResponse = function(val) {
            if (!this.requested) {
                this.requested = {};
            }
            return this.requested[val];
        };

        /**
         * Saves response to <em>requested</em> object
         * @param {String} val
         * @param {Object} response
         */
        that.saveResponse = function(val, response) {
            if (typeof val === "string" && typeof response === "object") {
                if (!this.requested) {
                    this.requested = {};
                }
                this.requested[val] = response;
            }
        };

        return that;

    }();

});

/** Preserve legacy namespace
 @deprecated jira.widget.autocomplete.REST */
AJS.namespace("jira.widget.autocomplete.REST", null, require('jira/autocomplete/rest-autocomplete'));
AJS.namespace('JIRA.RESTAutoComplete', null, require('jira/autocomplete/rest-autocomplete'));
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/IssueAutoComplete.js' */
define('jira/autocomplete/issue-autocomplete', [
    'jira/autocomplete/rest-autocomplete',
    'jira/util/objects',
    'jquery'
], function(
    RESTAutoComplete,
    Objects,
    jQuery
) {
    /**
     * @constructor IssueAutoComplete
     * @extends RESTAutoComplete
     * @param options
     */
    var IssueAutoComplete = function(options) {

        /** @lends IssueAutoComplete.prototype */
        var that = Objects.begetObject(RESTAutoComplete);

        that.getAjaxParams = function(){
            return {
                url: contextPath + "/rest/api/2/issue/picker",
                data: options.ajaxData,
                dataType: "json",
                type: "GET"
            };
        };

        /**
         * @param {Object} response
         */
        that.renderSuggestions = function(response) {

            var resultsContainer, suggestionNodes = [];

            // remove previous results
            this.clearResponseContainer();

            if (response && response.sections && response.sections.length > 0) {

                resultsContainer = jQuery("<ul/>").appendTo(this.responseContainer);

                jQuery(response.sections).each(function() {
                    var section = this;
                    var subSection = jQuery("<div/>").attr("id", options.fieldID + "_s_" + section.id).addClass("yag").text(section.label);
                    if (section.sub){
                        subSection.append(jQuery("<span/>").addClass("yagt").text("(" + section.sub + ")"));
                    }
                    resultsContainer.append(jQuery("<li/>").append(subSection).mouseover(function(){
                            jQuery(this).addClass("active");
                        }).mouseout(function(){
                            jQuery(this).removeClass("active");
                        })
                    );

                    if (section.msg){
                        // add message node
                        var msg = jQuery("<div/>").attr("id", options.fieldID + "_i_" + section.id + "_n").addClass("yad").text(section.msg);
                        resultsContainer.append(jQuery("<li/>").append(msg).mouseover(function(){
                                jQuery(this).addClass("active");
                            }).mouseout(function(){
                                jQuery(this).removeClass("active");
                            })
                        );
                    }

                    if (section.issues && section.issues.length > 0){
                        jQuery(section.issues).each(function(){
                            // add issue
                            var imgUrl;
                            if (/^http/.test(this.img)){
                                imgUrl = this.img;
                            } else {
                                imgUrl =  contextPath + this.img;
                            }
                            var issueNode = jQuery("<li/>").append(
                                jQuery("<div/>").attr("id", options.fieldID + "_i_" + section.id + "_" + this.key).addClass("yad").append(
                                    jQuery("<table/>").addClass("yat").attr({
                                        cellpadding: "0",
                                        cellspacing: "0"
                                    }).append(
                                        jQuery("<tr/>").append(
                                            jQuery("<td/>").append(
                                                jQuery("<img/>").attr("src", imgUrl)
                                            )
                                        ).append(
                                             jQuery("<td/>").append(
                                                jQuery("<div/>").addClass("yak").html(this.keyHtml)
                                            )
                                        ).append(
                                             jQuery("<td/>").css("width", "100%").html(this.summary)
                                        )
                                    )
                                )
                            );

                            resultsContainer.append(issueNode);
                            suggestionNodes.push([issueNode, this.key]);
                        });
                    }
                });

                that.addSuggestionControls(suggestionNodes);

                return suggestionNodes;

            }
        };
        options.minQueryLength = 1;
        options.queryDelay = 0.25;

        that.init(options);

        return that;

    };

    /**
     * Iterates over the entire DOM to find issue autocomplete controls to initialize, and initializes them.
     * @static
     */
    IssueAutoComplete.init = function(){

        jQuery("fieldset.issue-picker-params").each(function(){
            var params = JIRA.parseOptionsFromFieldset(jQuery(this)),
                $container = jQuery("#" + params.fieldId + "-container").add("#" + params.fieldName + "_container");

            $container.find("a.popup-trigger").click(function(e){
                var url = contextPath + '/secure/popups/IssuePicker.jspa?';
                url += 'currentIssue=' + params.currentIssueKey + '&';
                url += 'singleSelectOnly=' + params.singleSelectOnly + '&';
                url += 'showSubTasks=' + params.showSubTasks + '&';
                url += 'showSubTasksParent=' + params.showSubTaskParent;
                if (params.currentProjectId && params.currentProjectId !== "")
                {
                    url += '&selectedProjectId=' + params.currentProjectId;
                }

                /**
                 * Provide a callback to the window for execution when the user selects an issue. This implies that only one
                 * popup can be displayed at a time.
                 *
                 * @param keysMap the issue keys selected.
                 */
                JIRA.IssuePicker.callback = function(keysMap){
                    var $formElement, keys = [];

                    keysMap = JSON.parse(keysMap);

                    if (params.fieldId && keys) {
                        $formElement = jQuery("#" + params.fieldId);
                        if ($formElement){
                            jQuery.each(keysMap, function () {
                                keys.push(this.value);
                            });
                            $formElement.val(keys.join(", "));
                        }
                    }
                };

                var vWinUsers = window.open(url, 'IssueSelectorPopup', 'status=no,resizable=yes,top=100,left=200,width=620,height=500,scrollbars=yes,resizable');
                vWinUsers.opener = self;
                vWinUsers.focus();
                e.preventDefault();
            });

            if (!params.fieldId) {
                params.fieldId = params.fieldName;
            }

            if (params.issuePickerEnabled === true){
                IssueAutoComplete({
                    fieldID: params.fieldId,
                    delimChar: params.singleSelectOnly === true ? undefined : ",",
                    ajaxData: params
                });
            }
        });
    };

    return IssueAutoComplete;
});

/** Preserve legacy namespace
 @deprecated jira.widget.autocomplete.Issues */
AJS.namespace("jira.widget.autocomplete.Issues", null, require('jira/autocomplete/issue-autocomplete'));
AJS.namespace('JIRA.IssueAutoComplete', null, require('jira/autocomplete/issue-autocomplete'));
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/UserAutoComplete.js' */
define('jira/autocomplete/user-autocomplete', [
    'jira/autocomplete/rest-autocomplete',
    'jira/data/parse-options-from-fieldset',
    'jira/util/browser',
    'jira/util/elements',
    'jira/util/objects',
    'jquery'
], function(
    RESTAutoComplete,
    parseOptionsFromFieldset,
    Browser,
    Elements,
    Objects,
    jQuery
) {
    /**
     * User picker - converted from YUI based autocomplete. There is some code in here that probably isn't necessary,
     * if removed though selenium tests would need to be re-written.
     * @class UserAutoComplete
     * @extends RESTAutoComplete
     * @param {Object} options
     */
    var UserAutoComplete = function(options) {

        /** @lends UserAutoComplete.prototype */
        var that = Objects.begetObject(RESTAutoComplete);

        that.getAjaxParams = function(){
            return {
                url: contextPath + "/rest/api/1.0/users/picker",
                data: {
                    fieldName: options.fieldID,
                    fieldConfigId: options.fieldConfigID,
                    projectId: options.projectId
                },
                dataType: "json",
                type: "GET"
            };
        };

        /**
         * Returns true if the field's containing form has the 'submitted' class.
         *
         * @param field The reference to the field whose form to check for the 'submitted' class.
         * @return {Boolean}
         */
        function fieldsFormHasBeenSubmitted(field) {
            var submitting = false,
                form = field.closest("form");

            if (form.length && form.hasClass("submitting")) {
                submitting = true;
            }

            return submitting;
        }

        /**
         * Create html elements from JSON object
         * @param {Object} response - JSON object
         * @returns {Array} Multidimensional array, one column being the html element and the other being its
         * corresponding complete value.
         */
        that.renderSuggestions = function(response) {

            if (fieldsFormHasBeenSubmitted(this.field) || !Browser.isSelenium() && !Elements.elementIsFocused(this.field)) {
                return false;
            }

            var resultsContainer, suggestionNodes = [];

            // remove previous results
            this.clearResponseContainer();


            if (response && response.users && response.users.length > 0) {

                resultsContainer = jQuery("<ul/>").appendTo(this.responseContainer);

                jQuery(response.users).each(function() {

                    // add html element and corresponding complete value  to sugestionNodes Array
                    suggestionNodes.push([jQuery("<li/>")
                    .html(this.html)
                    .appendTo(resultsContainer), this.name]);

                });
            }

            if (response.footer) {
                this.responseContainer.append(jQuery("<div/>")
                .addClass("yui-ac-ft")
                .html(response.footer)
                .css("display","block"));
            }

            if (suggestionNodes.length > 0) {
                that.addSuggestionControls(suggestionNodes);
                jQuery('.atlassian-autocomplete div.yad, .atlassian-autocomplete .labels li').textOverflow({
                    autoUpdate: true
                });
            }

            return suggestionNodes;

        };

        // Use autocomplete only once the field has at least 2 characters
        options.minQueryLength = 2;

        // wait 1/4 of after someone starts typing before going to server
        options.queryDelay = 0.25;

        that.init(options);

        return that;

    };

    /**
     * Searches for and initialises User autocomplete controls within a DOM context.
     * @param {HTMLElement|String} [parent] - element or CSS selector within which
     * autocomplete controls will be searched for. Defaults to entire DOM.
     * @static
     */
    UserAutoComplete.init = function(parent){
        jQuery("fieldset.user-picker-params", parent).each(function(){
            var params = parseOptionsFromFieldset(jQuery(this)),
                field = (params.fieldId || params.fieldName),
                $container = jQuery("#" + field + "_container");


            $container.find("a.popup-trigger").click(function(e){
                var url = contextPath,
                    vWinUsers;

                e.preventDefault();

                if (!params.formName)
                {
                    params.formName = $container.find("#" + field).parents("form").attr("name");
                }

                if (params.actionToOpen) {
                    url = url + params.actionToOpen;
                } else {
                    url = url + '/secure/popups/UserPickerBrowser.jspa';
                }
                url += '?formName=' + params.formName + '&';
                url += 'multiSelect=' + params.multiSelect + '&';
                url += 'decorator=popup&';
                url += 'element=' + field;

                if (params.fieldConfigId) {
                    url += '&fieldConfigId=' + params.fieldConfigId;
                }
                if (params.projectId) { // an array of project ids
                    if (jQuery.isArray(params.projectId)) {
                        for (var projectId in params.projectId) {
                            url += '&projectId=' + projectId;
                        }
                    } else {
                        url += '&projectId=' + params.projectId;
                    }
                }

                vWinUsers = window.open(url, 'UserPicker', 'status=yes,resizable=yes,top=100,left=100,width=800,height=750,scrollbars=yes');
                vWinUsers.opener = self;
                vWinUsers.focus();
            });


            if (params.userPickerEnabled === true ){
                UserAutoComplete({
                    field: parent ? parent.find("#" + field) : null,
                    fieldID: field,
                    fieldConfigID: params.fieldConfigId,
                    projectId: params.projectId,
                    delimChar: params.multiSelect === false ? undefined : ",",
                    ajaxData: {
                        fieldName: params.fieldName
                    }
                });
            }
        });
    };

    return UserAutoComplete;
});

/** Preserve legacy namespace
    @deprecated jira.widget.autocomplete.Users */
AJS.namespace("jira.widget.autocomplete.Users", null, require('jira/autocomplete/user-autocomplete'));
AJS.namespace('JIRA.UserAutoComplete', null, require('jira/autocomplete/user-autocomplete'));
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/initAutoCompleteFields.js' */
(function() {
    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            JIRA.UserAutoComplete.init(context);
            JIRA.IssueAutoComplete.init(context);
        }
    });

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            AJS.$("fieldset.user-searcher-params", context).each(function () {
                var params = JIRA.parseOptionsFromFieldset(AJS.$(this)),
                    $container = AJS.$("#" + params.fieldId + "_container", context);

                if (params.userPickerEnabled === true) {
                    var autocompleter = JIRA.UserAutoComplete({
                        fieldID: params.fieldId,
                        delimChar: params.multiSelect === true ? "," : undefined,
                        ajaxData: {
                            fieldName: params.fieldName
                        }
                    });
                }

                var setupFields = function (related) {
                    var field = AJS.$("#" + params.fieldId, context);
                    var userImage = AJS.$("#" + params.fieldId + "Image", context);
                    var groupImage = AJS.$("#" + params.fieldId + "GroupImage", context);
                    var fieldDesc = AJS.$("#" + params.fieldId + "_desc", context);
                    if (related === "select.list.none") {
                        field.val("").attr("disabled", "true");
                        userImage.hide();
                        groupImage.hide();
                        fieldDesc.hide();
                    } else {
                        field.removeAttr("disabled");
                        if (related === "select.list.group") {
                            userImage.hide();
                            groupImage.show();
                            if (params.userPickerEnabled === true) {
                                autocompleter.disable();
                                fieldDesc.hide();
                            }
                        } else {
                            userImage.show();
                            groupImage.hide();
                            if (params.userPickerEnabled === true) {
                                autocompleter.enable();
                                fieldDesc.show();
                            }
                        }
                    }
                };

                AJS.$("#" + params.userSelect, context).change(function () {
                    var related = AJS.$(this).find("option:selected").attr("rel");
                    setupFields(related);
                }).find("option:selected").each(function () {
                    setupFields(AJS.$(this).attr("rel"));
                });

                $container.find("a.user-popup-trigger").click(function (e) {
                    var url = contextPath + '/secure/popups/UserPickerBrowser.jspa?';
                    url += 'formName=' + params.formName + '&';
                    url += 'multiSelect=' + params.multiSelect + '&';
                    url += 'decorator=popup&';
                    url += 'element=' + params.fieldId;

                    var vWinUsers = window.open(url, 'UserPicker', 'status=yes,resizable=yes,top=100,left=100,width=800,height=750,scrollbars=yes');
                    vWinUsers.opener = self;
                    vWinUsers.focus();
                    e.preventDefault();
                });

                $container.find("a.group-popup-trigger").click(function (e) {
                    var url = contextPath + '/secure/popups/GroupPickerBrowser.jspa?';
                    url += 'formName=' + params.formName + '&';
                    url += 'multiSelect=' + params.multiSelect + '&';
                    url += 'decorator=popup&';
                    url += 'element=' + params.fieldId;

                    var vWinUsers = window.open(url, 'GroupPicker', 'status=yes,resizable=yes,top=100,left=100,width=800,height=750,scrollbars=yes');
                    vWinUsers.opener = self;
                    vWinUsers.focus();
                    e.preventDefault();
                });
            });
        }
    });
})();
;
;
/* module-key = 'jira.webresources:group-label-lozenge', location = '/includes/jira/admin/group-browser/group-label-lozenge.js' */
define('jira/admin/group-browser/group-label-lozenge', [
    'jquery',
    'jira/skate'
], function(
    $,
    skate
) {
    skate('group-label-lozenge', {
        type: skate.type.CLASSNAME,
        attached: function(element) {
            $(element).tooltip({gravity: 'w', html: true});
        }
    });
});
;
;
/* module-key = 'jira.webresources:group-label-lozenge', location = '/includes/jira/admin/group-browser/group-label-lozenge.soy' */
// This file was automatically generated from group-label-lozenge.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }


JIRA.Templates.groupLabelLozenge = function(opt_data, opt_ignored) {
  return '' + aui.lozenges.lozenge({text: opt_data.label.text, title: opt_data.label.title, isSubtle: true, extraClasses: 'group-label-lozenge'});
};
if (goog.DEBUG) {
  JIRA.Templates.groupLabelLozenge.soyTemplateName = 'JIRA.Templates.groupLabelLozenge';
}
;
;
/* module-key = 'jira.webresources:groupbrowser', location = '/includes/jira/admin/group-browser/group-browser.js' */
require([
    'jquery',
    'jira/admin/group-browser/group-label-lozenge'
], function(
    $
) {
    $(function(){
        $(".operations-list .aui-button[disabled]").tooltip({gravity: 'e', html: false});
    });
});;
;
/* module-key = 'jira.webresources:group-pickers', location = '/includes/jira/field/groupPickerUtil.js' */
    JIRA.GroupPickerUtil = {
        formatResponseWithLabels: function(data) {
            return JIRA.GroupPickerUtil.formatResponse(data, true);
        },

        formatResponse: function (data, showLabels) {
            var ret = [];

            var template = showLabels ? JIRA.Templates.GroupPickerUtil.formatResponseWithLabels :
                                        JIRA.Templates.GroupPickerUtil.formatResponse;

            AJS.$(data).each(function(i, suggestions) {

                var groupDescriptor = new AJS.GroupDescriptor({
                    weight: i, // order or groups in suggestions dropdown
                    label: suggestions.header
                });
                AJS.$(suggestions.groups).each(function(){
                        groupDescriptor.addItem(new AJS.ItemDescriptor({
                            value: this.name, // value of item added to select
                            label: this.name, // title of lozenge
                            title: this.name, // tooltip
                            html: template(this),
                            highlighted: true
                        }));
                });

                ret.push(groupDescriptor);
            });

            return ret;
        }
    };
;
;
/* module-key = 'jira.webresources:group-pickers', location = '/includes/jira/field/templates/groupPickerUtil.soy' */
// This file was automatically generated from groupPickerUtil.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.GroupPickerUtil.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.GroupPickerUtil == 'undefined') { JIRA.Templates.GroupPickerUtil = {}; }


JIRA.Templates.GroupPickerUtil.formatResponseWithLabels = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.GroupPickerUtil.formatResponse(soy.$$augmentMap(opt_data, {showLabels: true}));
};
if (goog.DEBUG) {
  JIRA.Templates.GroupPickerUtil.formatResponseWithLabels.soyTemplateName = 'JIRA.Templates.GroupPickerUtil.formatResponseWithLabels';
}


JIRA.Templates.GroupPickerUtil.formatResponse = function(opt_data, opt_ignored) {
  var output = '<div class="group-suggestion-item"><span class="group-suggestion-item__name">' + soy.$$filterNoAutoescape(opt_data.html) + '</span>';
  if (opt_data.showLabels) {
    output += '<span class="group-suggestion-item__labels group-labels-lozenges">';
    var labelList13 = opt_data.labels;
    var labelListLen13 = labelList13.length;
    for (var labelIndex13 = 0; labelIndex13 < labelListLen13; labelIndex13++) {
      var labelData13 = labelList13[labelIndex13];
      output += JIRA.Templates.groupLabelLozenge({label: labelData13}) + ' ';
    }
    output += '</span>';
  }
  output += '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.GroupPickerUtil.formatResponse.soyTemplateName = 'JIRA.Templates.GroupPickerUtil.formatResponse';
}
;
;
/* module-key = 'jira.webresources:group-pickers', location = '/includes/jira/field/initMultiGroupPickers.js' */
(function () {

    function initMultiGroupPickers(ctx) {
        ctx.find('.js-default-multi-group-picker').each(function () {
            var $el = jQuery(this);
            var showLabels = $el.data("show-labels") === true;
            var userName = $el.data("user-name");
            new AJS.MultiSelect({
                element: this,
                itemAttrDisplayed: "label",
                showDropdownButton: false,
                ajaxOptions:  {
                    data: function (query) {
                        return {
                            userName: userName,
                            query: query,
                            exclude: $el.val()
                        };
                    },
                    url: contextPath + "/rest/api/2/groups/picker",
                    query: true, // keep going back to the sever for each keystroke
                    formatResponse: showLabels ? JIRA.GroupPickerUtil.formatResponseWithLabels :
                                                JIRA.GroupPickerUtil.formatResponse
                }
            });
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initMultiGroupPickers(context);
        }
    });

})();
;
;
/* module-key = 'jira.webresources:group-pickers', location = '/includes/jira/field/initSingleGroupPickers.js' */
(function () {
    var SingleSelect = require('jira/ajs/select/single-select');

    function initSingleGroupPickers(ctx) {
        ctx.find('.js-default-single-group-picker').each(function () {
            var $el = jQuery(this);
            var $emptyValue = $el.find('option[data-empty]');
            var showLabels = $el.data("show-labels") === true;
            var userName = $el.data("user-name");
            new SingleSelect({
                element: this,
                itemAttrDisplayed: "label",
                revertOnInvalid: true,
                ajaxOptions:  {
                    data: function (query) {
                        return {
                            userName: userName,
                            query: query,
                            exclude: $el.val()
                        };
                    },
                    url: contextPath + "/rest/api/2/groups/picker",
                    query: true, // keep going back to the sever for each keystroke
                    formatResponse: function(data) {
                        var formattedData = JIRA.GroupPickerUtil.formatResponse(data, showLabels);
                        if ($emptyValue.length && $el.val() !== '') {
                            formattedData.unshift(new AJS.ItemDescriptor({
                                value: '',
                                label: $emptyValue.text(),
                                highlighted:true
                            }));
                        }
                        return formattedData;
                    }
                }
            });
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initSingleGroupPickers(context);
        }
    });

})();
;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/userPickerUtil.js' */
(function ($) {

    JIRA.UserPickerUtil = {

        formatResponse: function (data) {

            var ret = [];

            $(data).each(function(i, suggestions) {

                var groupDescriptor = new AJS.GroupDescriptor({
                    weight: i, // order or groups in suggestions dropdown
                    label: suggestions.footer
                });

                $(suggestions.users).each(function(){
                    groupDescriptor.addItem(new AJS.ItemDescriptor({
                        value: this.name, // value of item added to select
                        label: this.displayName, // title of lozenge
                        html: this.html,
                        icon: this.avatarUrl,
                        allowDuplicate: false,
                        highlighted: true
                    }));
                });
                ret.push(groupDescriptor);
            });
            return ret;
        }

    };

})(AJS.$);

;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/initSingleUserPickers.js' */
(function ($) {

    function createSingleUserPickers(ctx) {

        var restPath = "/rest/api/1.0/users/picker";

        $(".js-default-user-picker", ctx).each(function () {
            var $this = $(this);
            if ($this.data("aui-ss")) return;
            var data = {showAvatar: true},
                inputText = $this.data('inputValue');

            new AJS.SingleSelect({
                element: $this,
                submitInputVal: true,
                showDropdownButton: !!$this.data('show-dropdown-button'),
                errorMessage: AJS.format("There is no user \'\'{0}\'\'.", "'{0}'"),
                ajaxOptions: {
                    url: contextPath + restPath,
                    query: true, // keep going back to the sever for each keystroke
                    data: data,
                    formatResponse: JIRA.UserPickerUtil.formatResponse
                },
                inputText: inputText
            });
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            createSingleUserPickers(context);
        }
    });

})(AJS.$);



;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/NoBrowseUserNamePicker.js' */
    /**
     * Caters for addition of users in frotherized MultiSelect inputs when the user
     * does not have the Browse User permission.
     *
     * Whilst this control could potentially give away valid usernames it is not new in this behaviour.
     * The old-style user picker used in the Edit Issue form will reveal if a particular username is invalid or not.
     * @class
     * @extends MultiSelect
     */
    AJS.NoBrowseUserNamePicker = AJS.MultiSelect.extend({

        /**
         * Use the User REST interface to attempt to get a user by username.
         */
        _getDefaultOptions: function () {
            return AJS.$.extend(true, this._super(), {
                errorMessage: "The requested user does not exist.",
                showDropdownButton: false,
                removeOnUnSelect: true,
                itemAttrDisplayed: "label"
            });
        },

        /**
         * Override to prevent requesting per keypress.
         *
         * NoBrowseUserNamePicker does not send a request per keypress.
         * Instead it will request for validity when enter or space is pressed
         * or when the field is blurred.
         */
        _handleCharacterInput: function() {
            //this.hideErrorMessage();
        },

        /**
         * Prevents the display of Suggestions for this control.
         *
         * We don't want any suggestions for the NoBrowseUserNamePicker
         * as the user using doesn't have access to see a list of users.
         * Also, using this REST enpoint will not retrieve a list of users anyway.
         */
        _setSuggestions: function() {},

        /**
         * Handles an error from the REST endpoint.
         *
         * The REST endpoint used for this operation returns a 404 if the user requested
         * does not exist. This situation is handled here.
         *
         * If any other error is returned the parent's error handler will be used.
         *
         * @param smartAjaxResult The error.
         */
        _handleServerError: function(smartAjaxResult) {
            if (smartAjaxResult.status === 404) {
                this.showErrorMessage();
            } else {
                this._super();
            }
        },

        /**
         * Called when the field is blurred.
         *
         * When the field is deactivated (i.e. blurred) we want to issue a
         * request to check if the currently entered username (if any) is valid or not.
         */
        _deactivate: function() {
            this.validateAndAdd();
        },

        /**
         * Issues a request to the User REST endpoint with the current field value.
         *
         * Hides any existing error messages before issuing a request to the User endpoint
         * to determine the validity of the current input.
         */
        validateAndAdd: function() {
            var instance = this;
            if (AJS.$.trim(this.$field.val()) === "") {
                this.hideErrorMessage();
            } else {
                jQuery.ajax({
                    url: contextPath + "/rest/api/2/user",
                    data: {
                        username: AJS.$.trim(instance.getQueryVal())
                    },
                    success: function (user) {
                        instance.hideErrorMessage();
                        instance.$field.val("");
                        instance.addItem(new AJS.ItemDescriptor({
                            label: user.displayName,
                            value: user.name
                        }));
                    },
                    error: function () {
                        instance.showErrorMessage();
                    }
                });
            }
        },

        /**
         * Sends a request to the REST endpoint using the currently entered username (if any)
         * when space is pressed.
         *
         * This allows for quick entry of usernames.
         *
         * If the username is not valid the space keypress event is prevented and an error message
         * displayed.
         */
        _handleSpace: function() {
            this.validate();
        },

        /**
         * Transforms the successfully returned username into a Lozenge.
         *
         * @param data The successfully selected username.
         */
        _handleServerSuggestions: function() {
            this.hideErrorMessage();
            this.handleFreeInput();
        },

        /**
         * Adds the current user input as a lozenge.
         *
         * By this time the input has been validated as a username.
         * If the input is not a valid username the response comes back as a
         * 404 triggering _handleServerError.
         */
        handleFreeInput: function() {
            var value = AJS.$.trim(this.$field.val());

            if (value !== "") {
                this.addItem({ value: value, label: value });
                this.model.$element.trigger("change");
            }

            this.$field.val("");
        },

        keys: {
            /**
             * Issue a request for the currently entered username when Return is pressed.
             *
             * @param event The aui:keypress event.
             */
            "Return": function(event) {
                event.preventDefault();
                this.validateAndAdd();
            },

            /**
             * Issue a request for the currently entered username when the Spacebar is pressed.
             *
             * @param event The aui:keypress event.
             */
            "Spacebar": function(event) {
                event.preventDefault();
                this.validateAndAdd();
            }
        }
    });
;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/initMultiUserPickers.js' */
(function () {

    function initMultiUserPicker(ctx) {
        ctx.find(".js-default-multi-user-picker").each(function () {
            var $el = jQuery(this);
            if (AJS.params.currentUserCanBrowseUsers) {
                new AJS.MultiSelect({
                    element: this,
                    itemAttrDisplayed: "label",
                    showDropdownButton: false,
                    removeOnUnSelect: true,
                    submitInputVal: true,
                    ajaxOptions: {
                        url: contextPath + "/rest/api/1.0/users/picker",
                        query: true, // keep going back to the sever for each keystroke
                        data: function (query) {
                            return {
                                showAvatar: true,
                                query: query,
                                exclude: $el.val()
                            };
                        },
                        formatResponse: JIRA.UserPickerUtil.formatResponse
                    }
                });
            } else {
                new AJS.NoBrowseUserNamePicker({
                    element: this
                });
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initMultiUserPicker(context);
        }
    });

})();
;
;
/* module-key = 'jira.webresources:ie-imitation-placeholder', location = '/includes/jira/field/IEImitationPlaceholder.js' */
/**
 * Temporary functionality to allow HTML5 input placeholder text
 * functionality in IE.
 *
 * Please remove this file if/when IE supports placeholder.
 */
(function($) {
    $.fn.ieImitationPlaceholder = function () {
        if ($.browser.msie) {
            var form = this,
                fields = form.find("[placeholder]");

            fields.focus(clearTextIfUnchanged);
            fields.blur(setTextFromPlaceholder);
            form.submit(clearAllIfUnchanged);

            fields.each(setTextFromPlaceholder);

            function setTextFromPlaceholder() {
                var field = $(this);
                if (field.val() === "") {
                    field.val(field.attr("placeholder"));
                    field.addClass("input-placeholder");
                }
            }

            function clearTextIfUnchanged() {
                var field = $(this);
                if (field.val() === field.attr("placeholder")) {
                    field.val("");
                    field.removeClass("input-placeholder");
                }
            }

            function clearAllIfUnchanged() {
                fields.each(clearTextIfUnchanged);
            }
        }
    };
})(AJS.$);
;
;
/* module-key = 'jira.webresources:jira-project-issuetype-fields', location = '/includes/jira/field/ProjectIssueTypeSelect.js' */
    /**
     * @class
     * @extends Class
     */
    JIRA.ProjectIssueTypeSelect = Class.extend({

        init: function (options) {

            var val,
                instance = this;

            this.$project = options.project;

            this.issueTypeSelect = options.issueTypeSelect;
            this.$projectIssueTypesSchemes = options.projectIssueTypesSchemes;
            this.$issueTypeSchemeIssueDefaults = options.issueTypeSchemeIssueDefaults;
            this.projectIssueTypeSchemes = JSON.parse(this.$projectIssueTypesSchemes.html());
            this.issueTypesSchemeDefaults = JSON.parse(this.$issueTypeSchemeIssueDefaults.html() || '[]');

            //may not have a project select on the edit issue page!
            if(instance.$project.length > 0) {
                val = instance.$project.val();
                instance.setIssueTypeScheme(instance.getIssueTypeSchemeForProject(val));

                this.$project.change(function () {
                    var val = instance.$project.val();
                    instance.setIssueTypeScheme(instance.getIssueTypeSchemeForProject(val));
                });
            }
        },

        getIssueTypeSchemeForProject: function (projectId) {
            return this.projectIssueTypeSchemes[projectId];
        },

        getDefaultIssueTypeForScheme: function (issueTypeSchemeId) {
            return this.issueTypesSchemeDefaults[issueTypeSchemeId];
        },

        setIssueTypeScheme: function (issueTypeSchemeId) {
            var selectedIssueType = this.issueTypeSelect.model.getValue();

            this.issueTypeSelect.model.setFilterGroup(issueTypeSchemeId);

            //retain value if possible, if not set default value
            //we set selection using model method since this change doesn't deal with dropdown
            if (!this.issueTypeSelect.model.setSelected(selectedIssueType, false)) {
                this.setDefaultIssueType(issueTypeSchemeId);
            }

            this.issueTypeSelect.model.$element.data('project',this.$project.val());
        },
        /**
         * Sets the default issue type for given issue type scheme.
         * If there is no default issue type in model set the first one
         *
         * @param {string} issueTypeSchemeId id of the issue type scheme
         */
        setDefaultIssueType: function (issueTypeSchemeId) {
            var defaultIssueType = this.getDefaultIssueTypeForScheme(issueTypeSchemeId),
                descriptor = this.issueTypeSelect.model.getDescriptor(defaultIssueType);

            if (!descriptor) {
                descriptor = this.issueTypeSelect.model.getAllDescriptors()[0];
            }
            this.issueTypeSelect.setSelection(descriptor,false);
        }
    });;
;
/* module-key = 'jira.webresources:jira-project-issuetype-fields', location = '/includes/jira/field/initProjectIssueTypeSelect.js' */
(function () {

    var SuggestionCollectionModel = require('jira/ajs/select/suggestion-collection-model');

    function findProjectAndIssueTypeSelectAndConvertToPicker(ctx) {
        var $ctx = ctx || jQuery("body");

        $ctx.find(".issuetype-field").each(function (index) {
            var $project = $ctx.find(".project-field, .project-field-readonly"),
                $issueTypeSelect = jQuery(this),
                $projectIssueTypes = $ctx.find("#" + $issueTypeSelect.attr('id') + '-projects'),
                $defaultProjectIssueTypes = $ctx.find("#" + $issueTypeSelect.attr('id') + '-defaults'),
                issueTypeSelect = new AJS.SingleSelect({
                    element: $issueTypeSelect,
                    revertOnInvalid: true,
                    model: SuggestionCollectionModel
                });

            // Remove redundant "please select" option
            issueTypeSelect.model.remove("");

            //if there is accompanied project field link them together
            if ($project.length > 0) {
                new JIRA.ProjectIssueTypeSelect({
                    project: $project.eq(index), //link correct project field in case of multiple project fields
                    issueTypeSelect: issueTypeSelect,
                    projectIssueTypesSchemes: $projectIssueTypes,
                    issueTypeSchemeIssueDefaults: $defaultProjectIssueTypes
                });
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            findProjectAndIssueTypeSelectAndConvertToPicker(context);
        }
    });

})();;
;
/* module-key = 'jira.webresources:jira-project-issuetype-fields', location = '/includes/jira/field/initIssueTypePickers.js' */
/**
 * Initialises issuetype picker frother fields
 *
 * @deprecated All initialization of issue type fields has been moved to initProjectIssueTypeSelect.
 */

(function () {

    function createissueTypePicker(context) {
        context.find(".issuetype-field").each(function () {

            var $select = jQuery(this);

            // Remove redundant "please select" option
            $select.bind("reset", function () {
                $select.find("option[value='']").remove();
            }).trigger("reset");

            new AJS.SingleSelect({
                element: this,
                revertOnInvalid: true
            });

        });
    }
})();

;
;
/* module-key = 'jira.webresources:jira-project-issuetype-fields', location = '/includes/jira/field/initProjectPickers.js' */
/**
 * Initialises project picker frother fields
 *
 * Please not that project fields interact with issue type fields in create issue. This interation is handled in
 * initIssueTypeSelect.js
 */
(function() {
    var ScrollableSingleSelect = require('jira/ajs/select/scrollable-single-select');
    var SuggestionCollectionModel = require('jira/ajs/select/suggestion-collection-model');

    function createProjectPicker(context) {
        context.find(".project-field").each(function () {
            new ScrollableSingleSelect({
                element: this,
                revertOnInvalid: true,
                pageSize: 50,
                pagingThreshold: 100,
                model: SuggestionCollectionModel
            });
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            createProjectPicker(context);
        }
    });

})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/field-templates.soy' */
// This file was automatically generated from field-templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Fields.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Fields == 'undefined') { JIRA.Templates.Fields = {}; }


JIRA.Templates.Fields.username = function(opt_data, opt_ignored) {
  return '' + ((opt_data.escape) ? soy.$$escapeHtml(opt_data.displayName) : soy.$$filterNoAutoescape(opt_data.displayName));
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.username.soyTemplateName = 'JIRA.Templates.Fields.username';
}


JIRA.Templates.Fields.recipientUsername = function(opt_data, opt_ignored) {
  return '<li data-username="' + soy.$$escapeHtml(opt_data.username) + '" title=' + soy.$$escapeHtml(opt_data.username) + '><span><span class="user-hover" rel="' + soy.$$escapeHtml(opt_data.username) + '"><img alt="" src="' + soy.$$escapeHtml(opt_data.icon) + '" title="' + JIRA.Templates.Fields.username(opt_data) + '"><span title="' + JIRA.Templates.Fields.username(opt_data) + '">' + JIRA.Templates.Fields.username(opt_data) + '</span></span>' + ((! opt_data.readOnly) ? '<button type="button" class="remove-recipient item-delete"><span class="icon-default aui-icon aui-icon-small aui-iconfont-delete">' + soy.$$escapeHtml(AJS.format("Remove watcher: {0}",opt_data.username)) + '</span></button>' : '') + '</span></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.recipientUsername.soyTemplateName = 'JIRA.Templates.Fields.recipientUsername';
}


JIRA.Templates.Fields.recipientEmail = function(opt_data, opt_ignored) {
  return '<li data-email="' + soy.$$escapeHtml(opt_data.email) + '" title=' + soy.$$escapeHtml(opt_data.email) + '><span><img src="' + soy.$$escapeHtml(opt_data.icon) + '" title="' + soy.$$escapeHtml(opt_data.email) + '"><span title="' + soy.$$escapeHtml(opt_data.email) + '">' + soy.$$escapeHtml(opt_data.email) + '</span><span class="remove-recipient item-delete"><span class="icon-default aui-icon aui-icon-small aui-iconfont-delete"></span></span></span></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.recipientEmail.soyTemplateName = 'JIRA.Templates.Fields.recipientEmail';
}
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/IssuePicker.js' */
define('jira/field/issue-picker', [
    'jira/ajs/select/multi-select',
    'jira/ajs/list/group-descriptor',
    'jira/ajs/list/item-descriptor',
    'jquery'
], function(
    MultiSelect,
    GroupDescriptor,
    ItemDescriptor,
    jQuery
) {
    /**
     * A multiselect list for querying and selecting issues. Issues can also be selected via a popup.
     *
     * @class IssuePicker
     * @extends MultiSelect
     */
    var IssuePicker = MultiSelect.extend({

        /**
         *
         * Note: We could probably have the server return in a format that can be digested by appendOptionsFromJSON, but
         * we currently have a legacy issue picker that uses the same end point.
         *
         * @param {Object} response
         */
        _formatResponse: function (response) {
            var ret = [],
                canonicalBaseUrl = (function(){
                    var uri = parseUri(window.location);
                    return uri.protocol + "://" + uri.authority;
                })();

            if (response && response.sections) {

                jQuery(response.sections).each(function(i, section) {

                    var groupDescriptor = new GroupDescriptor({
                        weight: i, // order or groups in suggestions dropdown
                        label: section.label, // Heading of group
                        description: section.sub // description for the group heading
                    });

                    if (section.issues && section.issues.length > 0){

                        jQuery(section.issues).each(function(){

                            groupDescriptor.addItem(new ItemDescriptor({
                                highlighted: true,
                                value: this.key, // value of item added to select
                                label: this.key + " - " + this.summaryText, // title of lozenge
                                icon: this.img ? canonicalBaseUrl + contextPath + this.img : null, // Need to have the canonicalBaseUrl for IE7 to avoid mixed content warnings when viewing the issuepicker over https
                                html: this.keyHtml + " - " + this.summary // html used in suggestion
                            }));
                        });
                    }

                    ret.push(groupDescriptor);

                });
            }

            return ret;
        },


        /**
         * Gets default options
         *
         * @protected
         * @return {Object}
         */
        _getDefaultOptions: function () {
            return jQuery.extend(true, this._super(), {
                ajaxOptions: {
                    formatResponse: this._formatResponse
                }
            });
        },

        /**
         * Launches a popup window, where issues can be fixed based on filter/history and current search. Installs
         * a callback in the current window that can be used by the popup window to add items to the control.
         *
         * @override
         */
        _launchPopup: function () {

            function getWithDefault(value, def) {
                if(value == null){
                    return def;
                } else {
                    return value;
                }
            }

            var url, urlParam, vWinUsers, options, instance = this;

            IssuePicker.callback = function (items) {
                if (typeof items === "string") {
                    items = JSON.parse(items);
                }
                instance._addMultipleItems(items, true);
                instance.$field.focus();
            };

            options = this.options.ajaxOptions.data;
            url = contextPath + '/secure/popups/IssuePicker.jspa?';
            urlParam = {
                singleSelectOnly: "false",
                decorator: "popup",
                currentIssue: options.currentIssueKey || "",
                showSubTasks: getWithDefault(options.showSubTasks, false),
                /* Note the slightly different option name here showSubTasksParent vs. showSubTaskParent */
                showSubTasksParent: getWithDefault(options.showSubTaskParent, false)
            };

            if (options.currentProjectId) {
                urlParam["currentProjectId"] = options.currentProjectId;
            }

            url += jQuery.param(urlParam);

            vWinUsers = window.open(url, 'IssueSelectorPopup', 'status=no,resizable=yes,top=100,left=200,width=' + this.options.popupWidth + ',height=' + this.options.popupHeight + ',scrollbars=yes,resizable');
            vWinUsers.opener = self;
            vWinUsers.focus();
        },

        /**
         * Adds popup link next to picker and assigns event to open popup window
         *
         * @param {Boolean} disabled - Adds a standard text box instead of ajax picker if set to true
         * @override
         */
        _createFurniture: function (disabled) {
            var $popupLink;

            this._super(disabled);

            $popupLink = this._render("popupLink");

            this._assignEvents("popupLink", $popupLink);
            this.$container.addClass('jira-issue-picker');
            this.$container.addClass('hasIcon');
            this.$container.after($popupLink);

        },

        handleFreeInput: function() {
            var values = this.$field.val().toUpperCase().match(/\S+/g);

            if (values) {
                this._addMultipleItems(jQuery.map(values, function(value) {
                    return { value: value, label: value };
                }));
            }

            this.$field.val("");
        },

        _events: {
            popupLink: {
                click: function (e) {
                    this._launchPopup();
                    e.preventDefault();
                }
            }
        },

        _renders: {
            popupLink: function () {
                return jQuery("<a class='issue-picker-popup' />")
                        .attr({
                            href: "#",
                            title: this.options.popupLinkMessage
                        })
                        .text("" + this.options.popupLinkMessage + "");
            }
        }

    });

    IssuePicker.callback = null;

    return IssuePicker;
});

/** @deprecated */
AJS.namespace("jira.issuepicker", null, require('jira/field/issue-picker'));
/** @deprecated */
AJS.namespace("AJS.IssuePicker", null, require('jira/field/issue-picker'));
AJS.namespace('JIRA.IssuePicker', null, require('jira/field/issue-picker'));
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/LabelPicker.js' */
define('jira/field/label-picker', [
    'jira/ajs/select/multi-select',
    'jira/ajs/list/group-descriptor',
    'jira/ajs/list/item-descriptor',
    'jquery'
], function(
    MultiSelect,
    GroupDescriptor,
    ItemDescriptor,
    jQuery
) {
    /**
     * @class LabelPicker
     * @extends MultiSelect
     */
    return MultiSelect.extend({

        _getDefaultOptions: function () {
            return jQuery.extend(true, this._super(), {
                ajaxOptions: {
                    url: contextPath + "/includes/js/ajs/layer/labeldata.js",
                    query: true,
                    formatResponse: this._formatResponse
                },
                removeDuplicates: true,
                removeOnUnSelect: true,
                userEnteredOptionsMsg: "New Label"
            });
        },

        isValidItem: function(itemValue) {
            return !/\s/.test(itemValue);
        },

        _handleServerSuggestions: function (data) {
            // if the suggestions brought back from the server include the original token and it doesn't match with the
            // token provided by the user disregard the suggestions
            if(data && data.token) {
                if(jQuery.trim(this.$field.val()) !== data.token) {
                    return;
                }
            }
            this._super(data);
        },

        _handleSpace: function () {
            if(jQuery.trim(this.$field.val()) !== "") {
                if(this.handleFreeInput()) {
                    this.hideSuggestions();
                }
            }
        },

        keys: {

            //if the user presses space, turn the text entered into labels.
            //if they pressed enter and the dropdown is *not* visible, then also turn text into labels.  Otherwise if the
            //dropdown is visibly enter should just select the item from the dropdown.
            "Spacebar": function (event) {
                this._handleSpace();
                event.preventDefault();
            }
        },

        _formatResponse: function (data) {

            var optgroup = new GroupDescriptor({
                label: "Suggestions",
                type: "optgroup",
                styleClass: 'labels-suggested'
            });

            if (data && data.suggestions) {
                jQuery.each(data.suggestions, function () {
                    optgroup.addItem(new ItemDescriptor({
                        value: this.label,
                        label: this.label,
                        html: this.html,
                        highlighted: true
                    }));
                });
            }
            return [optgroup];
        },

        handleFreeInput: function() {
            var values = jQuery.trim(this.$field.val()).match(/\S+/g);

            if (values) {
                // If there are multiple space-separated values, add them separately.
                for (var value, i = 0; value = values[i]; i++) {
                    this.addItem({ value: value, label: value });
                }
                this.model.$element.trigger("change");
            }

            this.$field.val("");
        }
    });

});

/** Preserve legacy namespace
 @deprecated AJS.LabelPicker */
AJS.namespace("AJS.LabelPicker", null, require('jira/field/label-picker'));
AJS.namespace('JIRA.LabelPicker', null, require('jira/field/label-picker'));
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/MultiUserListPicker.js' */
(function($) {


    /**
     * A multi-select list for selecting recipients to Share an issue or filter with. Shares are to 2 types of recipients:
     * - Users: selected from a dropdown list, and
     * - Email: addresses typed out in full
     *
     * @constructor JIRA.MultiUserListPicker
     * @extends AJS.MultiSelect
     */
    JIRA.MultiUserListPicker = AJS.MultiSelect.extend({

        init: function (options) {

            var restPath = "/rest/api/1.0/users/picker";

            function formatResponse(response) {

                var ret = [];

                $(response).each(function(i, suggestions) {

                    var groupDescriptor = new AJS.GroupDescriptor({
                        weight: i, // order or groups in suggestions dropdown
                        label: suggestions.footer // Heading of group
                    });

                    $(suggestions.users).each(function(){
                        groupDescriptor.addItem(new AJS.ItemDescriptor({
                            value: this.name, // value of item added to select
                            label: this.displayName, // title of lozenge
                            html: this.html,
                            icon: this.avatarUrl,
                            allowDuplicate: false,
                            highlighted: true
                        }));
                    });

                    ret.push(groupDescriptor);
                });

                return ret;
            }

            $.extend(options, {
                itemAttrDisplayed: "label",
                userEnteredOptionsMsg: "Email address",
                showDropdownButton: false,
                removeOnUnSelect: true,
                ajaxOptions: {
                    url: contextPath + restPath,
                    query: true,                // keep going back to the server for each keystroke
                    data: { showAvatar: true },
                    formatResponse: formatResponse
                },
                suggestionsHandler: AJS.UserListSuggestHandler,
                itemGroup: new AJS.Group(),
                itemBuilder: function (descriptor) {
                    return new JIRA.MultiUserListPicker.Item({
                        descriptor: descriptor,
                        container: this.$selectedItemsContainer
                    });
                }
            });

            this._super(options);
        },

        _createFurniture: function (disabled) {
            this._super(disabled);
            if (this.options.description) {
                this._render("description", this.options.description).insertAfter(this.$field);
            }
        },

        /**
         * The share textarea has no lozenges inside it and no need for cursor and indent nonsense.
         * It could even be a plain text field.
         */
        updateItemsIndent: $.noop,

        _renders: {
            selectedItemsWrapper: function () {
                return $('<div class="recipients"></div>');
            },
            selectedItemsContainer: function () {
                return $('<ol />');
            },
            description: function (description) {
                return $("<div />").addClass("description").text(description);
            }
        }

    });

}(AJS.$));;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/MultiUserListPicker.Item.js' */
    /**
     * A JIRA.MultiUserListPicker.Item represents an item selected in the Share Dialog & Watchers Dialog.
     * It is much like an AJS.MultiSelect.Lozenge but is rendered differently with slightly altered behaviour.
     *
     * @constructor JIRA.MultiUserListPicker.Item
     * @extends AJS.Control
     */
    JIRA.MultiUserListPicker.Item = AJS.Control.extend({

        init: function(options) {
            this._setOptions(options);

            this.$lozenge = this._render("item");
            this.$removeButton = this.$lozenge.find('.remove-recipient');

            this._assignEvents("instance", this);
            this._assignEvents("lozenge", this.$lozenge);
            this._assignEvents("removeButton", this.$removeButton);

            this.$lozenge.prependTo(this.options.container);
        },

        _getDefaultOptions: function() {
            return {
                label: null,
                title: null,
                container: null,
                focusClass: "focused"
            };
        },

        _renders: {
            "item": function() {
                var descriptor = this.options.descriptor;

                var data;
                if (descriptor.noExactMatch() !== true) {
                    // A User selected from the matches
                    data = {
                        escape: false,
                        username: descriptor.value(),
                        icon: descriptor.icon(),
                        displayName: AJS.escapeHtml(descriptor.label())
                    };

                    return AJS.$(JIRA.Templates.Fields.recipientUsername(data));
                } else {
                    // Just an email
                    data = {
                        email: descriptor.value(),
                        icon: AJS.Meta.get('default-avatar-url')
                    };
                    return AJS.$(JIRA.Templates.Fields.recipientEmail(data));
                }
            }
        },

        _events: {
            "instance": {
                "remove": function() {
                    this.$lozenge.remove();
                }
            },
            "removeButton": {
                "click": function(e) {
                    // We need to stop the click propagation, else by the time the InlineDialog catches the event the span
                    // will no longer be in the DOM and the click handler will think the user clicked outside of the dialog,
                    // closing it.
                    e.stopPropagation();
                    this.trigger("remove");
                }
            }
        }
    });
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initCascadingSelects.js' */
(function () {

    function initCascadingSelect(el) {
        AJS.$(el || document.body).find('div.aui-field-cascadingselect').add('tr.aui-field-cascadingselect').add('td.aui-field-cascadingselect').each(function () {
            var $container = AJS.$(this),
                parent = $container.find('.cascadingselect-parent'),
                parentOptions = parent.find('option'),
                oldClass = "",
                child = $container.find('.cascadingselect-child'),
                childOptions = child.find('option'),
                selectedChild = child.find(':selected');

            function update() {
                var placeholder,
                    currentClass = parent.find('option:selected').attr('class');
                // Compare so we're not redrawing the child dropdown when changing between the options with the class "default-option"
                if (currentClass !== oldClass) {
                    // Hide all the options other than ones relating to the selected parent

                    placeholder = jQuery("<span />").insertAfter(child);
                    child.detach();
                    child.find('option').each(function (i, elem) {
                        elem.parentNode.removeChild(this);
                    });
                    child.insertAfter(placeholder);
                    placeholder.remove();

                    childOptions.filter('.'+parent.find('option:selected').attr('class')).appendTo(child);
                    // Select the option which is to be selected on page load - default to the first one if none specified.
                    if (selectedChild.hasClass(parent.find('option:selected').attr('class'))) {
                        child.val(selectedChild.val());
                    } else {
                        child.val(child.find('option:first').val());
                    }
                    oldClass = currentClass;
                }
            }
            parent.bind('cascadingSelectChanged', update)
                  .change(function(){
                        AJS.$(this).trigger('cascadingSelectChanged');
                  })
                  .trigger('cascadingSelectChanged');
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initCascadingSelect(context);
        }
    });

})();;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initComponentPickers.js' */
(function () {

    JIRA.ComponentPicker = AJS.MultiSelect.extend({

        init: function(options) {
            this._super(options);
            this.suggestionsHandler = new AJS.OnlyNewItemsSuggestHandler(this.options, this.model);
        },

        _getDefaultOptions: function (opts) {
            var canCreate = false;
            if(opts && opts.element) {
                canCreate = AJS.$(opts.element).data("create-permission");
            }
            if(canCreate) {
                return AJS.$.extend(true, this._super(), {
                    userEnteredOptionsMsg: "New Component"
                });
            } else {
                return this._super(opts);
            }
        },

        _selectionHandler: function (selected, e) {
            var allExistingDescriptors = this.model.getDisplayableSelectedDescriptors().concat(this.model.getDisplayableUnSelectedDescriptors());
            var selectedDescriptor = selected.data("descriptor");
            var existingDescriptor = _.find(allExistingDescriptors, function(descriptor) {
                return descriptor.label() === selectedDescriptor.label();
            });
            if(!existingDescriptor)
            {
                selectedDescriptor.properties.value = "nv_" + selectedDescriptor.value();
                JIRA.trigger("Issue.Component.new.selected", [selectedDescriptor.value()]);
            }
            this._super(selected, e);
        }
    });


    function createPicker($selectField) {
        new JIRA.ComponentPicker({
            element: $selectField,
            itemAttrDisplayed: "label",
            errorMessage: "{0} is not a valid component.",
            maxInlineResultsDisplayed: 15,
            expandAllResults: true
        });
    }

    function locateSelect(parent) {

        var $parent = AJS.$(parent),
            $selectField;

        if ($parent.is("select")) {
            $selectField = $parent;
        } else {
            $selectField = $parent.find("select");
        }

        return $selectField;
    }

    var DEFAULT_SELECTORS = [
        "div.aui-field-componentspicker.frother-control-renderer", // aui forms
        "td.aui-field-componentspicker.frother-control-renderer", // convert to subtask and move
        "tr.aui-field-componentspicker.frother-control-renderer" // bulk edit
    ];

    function findComponentSelectAndConvertToPicker(context, selector) {

        selector = selector || DEFAULT_SELECTORS.join(", ");

        AJS.$(selector, context).each(function () {

            var $selectField = locateSelect(this);

            if ($selectField.length) {
                createPicker($selectField);
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            findComponentSelectAndConvertToPicker(context);
        }
    });
})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initMultiselectPickers.js' */
/*
 Copied over from initComponentPickers.js
 Slightly changed the way the Multiselect component is initialized.
 */

(function () {

    function createPicker($selectField) {
        new AJS.MultiSelect({
            element: $selectField,
            itemAttrDisplayed: "label",
            errorMessage: "{0} is not a valid value.",
            maxInlineResultsDisplayed: 15,
            submitInputVal: true,
            expandAllResults: true
        });
    }

    function locateSelect(parent) {

        var $parent = AJS.$(parent),
            $selectField;

        if ($parent.is("select")) {
            $selectField = $parent;
        } else {
            $selectField = $parent.find("select");
        }

        return $selectField;
    }

    var DEFAULT_SELECTORS = [
        "div.aui-field-multiselectpicker.frother-control-renderer" // aui forms
    ];

    function findComponentSelectAndConvertToPicker(context, selector) {

        selector = selector || DEFAULT_SELECTORS.join(", ");

        AJS.$(selector, context).each(function () {

            var $selectField = locateSelect(this);

            if ($selectField.length) {
                createPicker($selectField);
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            findComponentSelectAndConvertToPicker(context);
        }
    });
})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initDatePickers.js' */
(function () {

    function initDatePicker(el) {
        AJS.$(el || document.body).find('div.aui-field-datepicker').add('tr.aui-field-datepicker').add('td.aui-field-datepicker').each(function () {
            var $container = AJS.$(this),
                field = $container.find('input:text'),
                defaultCheckbox = $container.find('#useCurrentDate'),
                params = JIRA.parseOptionsFromFieldset($container.find('fieldset.datepicker-params'));

            params.context = el;

            Calendar.setup(params);

            function toggleField() {
                field.prop('disabled',defaultCheckbox.is(':checked'));
            }

            if (defaultCheckbox.length) {
                toggleField();
                defaultCheckbox.click(toggleField);
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context,reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initDatePicker(context);
        }

    });

})();

;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initLegacyGroupPickers.js' */
(function () {


    /**
     * USE initMultiGroupPicker instead.
     *
     * @deprecated
     * @param el
     */
    function initLegacyGroupPicker(el) {
        AJS.$(el || document.body).find('div.aui-field-grouppicker').add('tr.aui-field-grouppicker').add('td.aui-field-grouppicker').each(function () {
            var $container = AJS.$(this),
                trigger = $container.find('a.grouppicker-trigger'),
                url = trigger.attr('href');

            function openGroupPickerWindow(e) {
                e.preventDefault();
                window.open(url, 'GroupPicker', 'status=yes,resizable=yes,top=100,left=100,width=800,height=750,scrollbars=yes');
            }

            trigger.click(openGroupPickerWindow);
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initLegacyGroupPicker(context);
        }
    });

})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initIssuePickers.js' */
;(function() {
    var IssuePicker = require('jira/field/issue-picker');
    var Events = require('jira/util/events');
    var Types = require('jira/util/events/types');
    var Reasons = require('jira/util/events/reasons');
    var $ = require('jquery');

    function initIssuePicker(el) {
        $(el || document.body).find('.aui-field-issuepicker').each(function () {
            new IssuePicker({
                element: $(this),
                userEnteredOptionsMsg: "Enter issue key",
                uppercaseUserEnteredOnSelect: true
            });
        });
    }

    Events.bind(Types.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== Reasons.panelRefreshed) {
            initIssuePicker(context);
        }
    });
})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initLabelPickers.js' */
define('jira/field/label-picker-factory', [
    'jira/field/label-picker',
    'jira/data/parse-options-from-fieldset',
    'jquery',
    'exports'
], function(
    LabelPicker,
    parseOptionsFromFieldset,
    $,
    exports
) {
    exports.createPicker = function($fieldset, context) {

        var opts = parseOptionsFromFieldset($fieldset),
            $select = $('#' + opts.id, context),
            issueId = opts.issueId,
            data = {};

        if (/customfield_\d/.test(opts.id)) {
            data.customFieldId = parseInt(opts.id.replace('customfield_', ''), 10);
        }

        new LabelPicker({
            element: $select,
            ajaxOptions: {
                url: contextPath + '/rest/api/1.0/labels' + (issueId ? '/' + issueId : '') + '/suggest',
                data: data
            }
        });
    };

});

(function() {
    var LabelPickerFactory = require('jira/field/label-picker-factory');
    var Events = require('jira/util/events');
    var Types = require('jira/util/events/types');
    var Reasons = require('jira/util/events/reasons');
    var $ = require('jquery');

    var FIELDSET_SELECTOR = "fieldset.labelpicker-params";

    function locateFieldset(parent) {
        var $parent = $(parent),
            $fieldset;

        if ($parent.is(FIELDSET_SELECTOR)) {
            $fieldset = $parent;
        } else {
            $fieldset = $parent.find(FIELDSET_SELECTOR);
        }

        return $fieldset;
    }

    function findLabelsFieldsetAndConvertToPicker(context, selector) {
        selector = selector || ".aui-field-labelpicker";

        $(selector, context).each(function () {
            var $fieldset = locateFieldset(this);

            if ($fieldset.length > 0) {
                LabelPickerFactory.createPicker($fieldset, context);
            }
        });
    }

    Events.bind(Types.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== Reasons.panelRefreshed) {
            findLabelsFieldsetAndConvertToPicker(context);
        }
    });
})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initVersionPickers.js' */
(function () {

    JIRA.VersionPicker = AJS.MultiSelect.extend({

        init: function(options) {
            this._super(options);
            this.suggestionsHandler = new AJS.OnlyNewItemsSuggestHandler(this.options, this.model);
        },

        _getDefaultOptions: function (opts) {
            var canCreate = false;
            if(opts && opts.element) {
                canCreate = AJS.$(opts.element).data("create-permission");
            }
            if(canCreate) {
                return AJS.$.extend(true, this._super(), {
                    userEnteredOptionsMsg: "New Version"
                });
            } else {
                return this._super(opts);
            }
        },

        _selectionHandler: function (selected, e) {
            var allExistingVersionDescriptors = this.model.getDisplayableSelectedDescriptors().concat(this.model.getDisplayableUnSelectedDescriptors());
            var selectedDescriptor = selected.data("descriptor");
            var existingVersion = _.find(allExistingVersionDescriptors, function(descriptor) {
                return descriptor.label() === selectedDescriptor.label();
            });
            if(!existingVersion)
            {
                selectedDescriptor.properties.value = "nv_" + selectedDescriptor.value();
                JIRA.trigger("Issue.Version.new.selected", [selectedDescriptor.value()]);
            }
            this._super(selected, e);
        }
    });

    function createPicker($selectField) {
        new JIRA.VersionPicker({
            element: $selectField,
            itemAttrDisplayed: "label",
            removeOnUnSelect: false,
            submitInputVal: true,
            errorMessage: "{0} is not a valid version.",
            maxInlineResultsDisplayed: 15,
            expandAllResults: true
        });
    }

    function locateSelect(parent) {
        var $parent = AJS.$(parent),
            $selectField;

        if ($parent.is("select")) {
            $selectField = $parent;
        } else {
            $selectField = $parent.find("select");
        }

        return $selectField;
    }

    function findVersionSelectAndConvertToPicker(context, selector) {
        selector = selector || ".aui-field-versionspicker.frother-control-renderer";
        AJS.$(selector, context).each(function () {
            var $selectField = locateSelect(this);
            if ($selectField.length) {
                createPicker($selectField);
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            findVersionSelectAndConvertToPicker(context);
        }
    });

})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initCommentControls.js' */
(function () {
    var skate = require('jira/skate');
    var SecurityLevelSelect = require('jira/ajs/select/security-level-select');
    var wikiPreview = require('jira/wikipreview/wiki-preview');

    /**
     *
     */
    skate('jira-wikifield', {
        type: skate.type.CLASSNAME,
        created: function(el) {
            var prefs = {
                fieldId: el.getAttribute('field-id'),
                trigger: el.querySelector('.wiki-preview').id,
                issueKey: el.getAttribute('issue-key'),
                rendererType: el.getAttribute('renderer-type')
            };
            wikiPreview(prefs, el).init();
        }
    });

    skate('security-level', {
        type: skate.type.CLASSNAME,
        created: function(el) {
            var commentLevel = el.querySelector('#commentLevel');
            if (commentLevel) {
                new SecurityLevelSelect(commentLevel);
            }
        }
    });

})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initLogWorkControls.js' */
(function ($) {

    JIRA.Events.VALIDATE_TIMETRACKING = "validateTimeTracking";

    function toggleTimeTrackingContainer(context, activate) {

        var $logWorkContainer = $(context).find("#worklog-logworkcontainer"),
            $timeTrackingContainer = $(context).find("#worklog-timetrackingcontainer"),
            $logWorkCheckbox = $(context).find("#log-work-activate");

        if (activate) {
            $logWorkContainer.removeClass("hidden");
            $timeTrackingContainer.addClass("hidden");
            $logWorkCheckbox.prop("checked", true);
        } else {
            $logWorkContainer.addClass("hidden");
            $timeTrackingContainer.removeClass("hidden");
            $logWorkCheckbox.prop("checked", false);
        }
    }

    function applyLogworkControls(context) {

        $('#log-work-adjust-estimate-new-value, #log-work-adjust-estimate-manual-value', context).attr('disabled','disabled');

        $('#log-work-adjust-estimate-'+$('input[name=worklog_adjustEstimate]:checked,input[name=adjustEstimate]:checked', context).val()+'-value', context).removeAttr('disabled');
        $('input[name=worklog_adjustEstimate],input[name=adjustEstimate]', context).change(function(){
            $('#log-work-adjust-estimate-new-value,#log-work-adjust-estimate-manual-value', context).attr('disabled','disabled');
            $('#log-work-adjust-estimate-'+$(this).val()+'-value', context).removeAttr('disabled');
        });

        $("#delete-log-work-adjust-estimate-new-value").change(function() {
            $("#delete-log-work-adjust-estimate-new").prop("checked", true);
        });
        $("#delete-log-work-adjust-estimate-manual-value").change(function() {
            $("#delete-log-work-adjust-estimate-manual").prop("checked", true);
        });

        $(context).find("#log-work-activate").change(function() {
            toggleTimeTrackingContainer(context, $(this).is(":checked"));
        });
    }

    // In Quick Edit/Create we need to ensure the container is visible to append error messages
    JIRA.bind(JIRA.Events.VALIDATE_TIMETRACKING, function (e, context) {
        toggleTimeTrackingContainer(context, true);
    });

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            applyLogworkControls(context);
        }
    });

})(AJS.$);;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initPriorityPickers.js' */
(function ($) {

    function createPriorityPicker(context) {
        context.find("select#priority").each(function (i, el) {
            new AJS.SingleSelect({
                element: el,
                revertOnInvalid: true
            });
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            createPriorityPicker(context);
        }
    });

})(AJS.$);;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initInlineAttach.js' */
;(function() {
    var Events = require('jira/util/events');
    var Types = require('jira/util/events/types');
    var Reasons = require('jira/util/events/reasons');
    require('jira/jquery/plugins/attachment/inline-attach'); // Ensure jQuery plugin is defined)

    /**
     * @param {jQuery} context
     */
    function createInlineAttach(context) {
        context.find("input[type=file]:not('.ignore-inline-attach')").inlineAttach();
    }

    Events.bind(Types.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== Reasons.panelRefreshed) {
            createInlineAttach(context);
        }
    });
})();
;
;
/* module-key = 'com.atlassian.jira.jira-share-plugin:share-resources', location = 'templates/share-dialog.soy' */
// This file was automatically generated from share-dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Dialogs.Share.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Dialogs == 'undefined') { JIRA.Templates.Dialogs = {}; }
if (typeof JIRA.Templates.Dialogs.Share == 'undefined') { JIRA.Templates.Dialogs.Share = {}; }


JIRA.Templates.Dialogs.Share.contentPopup = function(opt_data, opt_ignored) {
  return '<form action="#" method="post" class="aui recipients-form share-content-popup ' + ((opt_data.shareData.issue) ? ' viewissue ' : (opt_data.shareData.filter) ? ' issuenav ' : '') + '">' + JIRA.Templates.Dialogs.Share.shareLink(opt_data) + '<fieldset class="padding">' + ((opt_data.showForm) ? JIRA.Templates.Dialogs.Share.shareForm(opt_data) : JIRA.Templates.Dialogs.Share.disabledMailMessage(soy.$$augmentMap(opt_data.isAdmin, {isAdmin: opt_data.isAdmin}))) + '</fieldset></form>';
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.Share.contentPopup.soyTemplateName = 'JIRA.Templates.Dialogs.Share.contentPopup';
}


JIRA.Templates.Dialogs.Share.shareForm = function(opt_data, opt_ignored) {
  return '<label for="sharenames-multi-select">' + soy.$$escapeHtml("User name or email") + '</label><div class="autocomplete-user-target"><select id="sharenames" name="sharenames" class="share-user-picker hidden" multiple="multiple"></select></div><ol class="recipients"></ol><div><label for="note">' + soy.$$escapeHtml("Note") + '</label></div><textarea class="textarea long-field" id="note" placeholder="' + soy.$$escapeHtml("Add an optional note") + '"/><div class="button-panel"><div class="status"><div class="icon"></div><div class="progress-messages"></div></div><div class="buttons"><input accesskey="' + soy.$$escapeHtml("s") + '" id="submitShare" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to submit this form","s",opt_data.modifierKey)) + '" class="button submit" type="submit" value="' + soy.$$escapeHtml("Share") + '" disabled/> <a accesskey="' + soy.$$escapeHtml("`") + '" id="cancelShare" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to cancel","`",opt_data.modifierKey)) + '" class="close-dialog" href="javascript:">' + soy.$$escapeHtml("Cancel") + '</a></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.Share.shareForm.soyTemplateName = 'JIRA.Templates.Dialogs.Share.shareForm';
}


JIRA.Templates.Dialogs.Share.disabledMailMessage = function(opt_data, opt_ignored) {
  return '' + ((! opt_data.isAdmin) ? aui.message.generic({content: '<p>' + soy.$$escapeHtml("Outgoing mail is not configured. Please contact your JIRA administrator to enable sharing.") + '</p>', extraClasses: 'disabled-mail-message'}) : aui.message.generic({content: '<p>' + soy.$$escapeHtml("Outgoing mail is not configured. You can configure it here") + '<a class="aui-list-item-link" id="configure_mail_server" href="' + soy.$$escapeHtml("/jira") + '/secure/admin/OutgoingMailServers.jspa"><em> ' + soy.$$escapeHtml("Outgoing mail") + '</em></a>.</p>', extraClasses: 'disabled-mail-message'}));
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.Share.disabledMailMessage.soyTemplateName = 'JIRA.Templates.Dialogs.Share.disabledMailMessage';
}


JIRA.Templates.Dialogs.Share.shareLink = function(opt_data, opt_ignored) {
  return '' + ((opt_data.shareData.permlink) ? '<div class="issuenav-permalink padding"><label>' + ((opt_data.shareData.issue) ? soy.$$escapeHtml("Link to Issue") : (opt_data.shareData.filter) ? soy.$$escapeHtml("Link to Filter") : '') + '</label><input class="permalink text long-field" value="' + soy.$$escapeHtml(opt_data.shareData.permlink) + '" readonly></div>' : '');
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.Share.shareLink.soyTemplateName = 'JIRA.Templates.Dialogs.Share.shareLink';
}
;
;
/* module-key = 'com.atlassian.jira.jira-share-plugin:share-resources', location = 'js/share-user-multi-select.js' */
define('jira/share-plugin/share-user-picker', [
    'jira/skate',
    'jquery'
], function(skate, $) {
    var MultiUserListPicker = JIRA.MultiUserListPicker;
    var $doc = $(document);

    return skate('share-user-picker', {
        type: skate.type.CLASSNAME,
        attached: function shareUserPickerAttached(element) {
            var $el = $(element);
            var control = new MultiUserListPicker({
                layerId: $el.attr('id') + '-layer',
                element: $el,
                freeEmailInput: true
            });
            $doc.trigger('ready.multi-select.share-user', control);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-share-plugin:share-resources', location = 'js/share-dialog.js' */
define('jira/share-plugin/share-plugin-dialog', [
    'underscore',
    'jira/share-plugin/share-user-picker',
    'jira/ajs/layer/inline-layer',
    'jira/ajs/ajax/smart-ajax',
    'jira/util/events',
    'jira/util/events/types',
    'jira/util/data/meta',
    'jira/util/events/reasons',
    'aui/inline-dialog',
    'jquery'
], function(
    _,
    ShareUserPickerElement,
    InlineLayer,
    SmartAjax,
    JiraEvents,
    JiraEventTypes,
    Meta,
    JiraEventReasons,
    InlineDialog,
    jQuery
) {
    return function () {
        var shareDialog,
            currentShareLink,
            dialogContents,
            allowDialogHide = true;

        this.resetAndHide = function resetAndHide() {
            // We have to bind to the event triggered by the inline-dialog hide code, as the actual hide runs in a
            // setTimeout callback. This caused JRADEV-7962 when trying to empty the contents synchronously.
            jQuery(document).one("hideLayer", function (e, type, dialog) {
                if (type === "inlineDialog" && dialog.popup === shareDialog) {
                    jQuery(document).unbind('.share-dialog');
                    dialogContents.empty();
                    dialogContents = undefined;
                    currentShareLink = undefined;
                }
            });
            return this.hideDialog();
        };

        this.hideDialog = function hideDialog() {
            shareDialog.hide();
            return false;
        };

        function getUsernameValue() {
            return jQuery(this).attr("data-username");
        };

        function getEmailValue() {
            return jQuery(this).attr("data-email");
        };

        this._buildSendShareUrl = function buildSendShareUrl(options, data) {
            var url = AJS.contextPath() + '/rest/share/1.0';
            if (options.issue) {
                // Share Issue
                url += '/issue/' + options.issueKey;
            }
            else if (options.filter) {
                // Share Search
                if (options.filterId) {
                    // A saved search
                    url += '/filter/' + options.filterId;
                }
                else {
                    // A JQL search
                    data.jql = options.jql;
                    url += '/search';
                }
            }
            return url;
        };

        this._successShareHandler = function successShareHandler()
        {
            var icon = dialogContents.find(".button-panel .icon");
            icon.removeClass("throbber loading")
                .addClass('icon-tick');

            var messages = dialogContents.find(".progress-messages");
            messages.removeClass("sending")
                .addClass("success")
                .text("Sent");
            setTimeout(_.bind(this.resetAndHide, this), 1000);
        };

        this._errorShareHandler = function errorShareHandler()
        {
            var icon = dialogContents.find(".button-panel .icon");
            icon.removeClass("throbber loading")
                .addClass('icon-cross');
            var messages = dialogContents.find(".progress-messages");
            messages.removeClass("sending")
                .addClass("error")
                .text("Error while sending");
        };

        /**
         * Sets up the state and send a share ajax request
         *
         * @param data
         * @param data.usernames A list of users to share to
         * @param data.emails A list of emails to share to
         * @param data.message An optional share message
         * @param options.issueKey {undefined | string} The issue key to share
         * @param options.filterId {undefined | string} The filter id to share
         * @param options.issue {undefined | true} Whether the share target is issue
         * @param options.filter {undefined | true} Whether the share target is filter
         */
        this._sendShare = function sendShare(data, options) {
            jQuery("button,input,textarea", this).attr("disabled", "disabled");

            var icon = dialogContents.find(".button-panel .icon");
            icon.addClass("throbber loading");

            var messages = dialogContents.find(".progress-messages");
            messages.text("Sending");
            messages.addClass("sending");

            var url = this._buildSendShareUrl(options, data);

            JIRA.trace("jira.plugins.share.send", _.defaults({
                url: url
            }, data));

            var requestOptions = {
                type: "POST",
                contentType: "application/json",
                dataType: "json",
                url: url,
                data: JSON.stringify(data),
                success: _.bind(this._successShareHandler, this),
                error: _.bind(this._errorShareHandler, this)
            };
            SmartAjax.makeRequest(requestOptions);
        };

        this._collectMailData = function collectMailData() {
            var recipients = dialogContents.find('.recipients');
            var users = recipients.find('li[data-username]').map(getUsernameValue).toArray();
            var emails = recipients.find('li[data-email]').map(getEmailValue).toArray();

            if (!(users.length || emails.length)) {
                return false;
            }

            var message = dialogContents.find("#note").val();
            var data = {
                usernames: users,
                emails: emails,
                message: message
            };
            return data;
        };

        this.submit = function submit(shareData) {
            var mailData = this._collectMailData();
            if(mailData) {
                this._sendShare(mailData, shareData);
            }
            return false;
        };

        this._enableSubmit = function enableSubmit(enabled) {
            dialogContents.find(".submit").prop("disabled", !enabled);
        };

        /**
         * Invoke a bunch of magical JS event delegation to make sure that we only trigger the execution of the
         * functions attached to the access keys defined within this dialog's form.
         *
         * @param shareDialogForm the share dialog's form.
         */
        this.enableAccessKeys = function enableAccessKeys(shareDialogForm) {
            jQuery(shareDialogForm).handleAccessKeys({
                selective: false // only trigger the access keys defined in this form.
            });
        };

        this._getShareData = function getShareData(trigger) {
            var $trigger = jQuery(trigger),
                shareTarget,
                permlinkFull;

            if ($trigger.hasClass("viewissue-share")) {
                shareTarget = "issue";
                permlinkFull = Meta.get("viewissue-permlink");
            } else if ($trigger.hasClass("issuenav-share")) {
                shareTarget = "filter";
                permlinkFull = Meta.get("issuenav-permlink");
            }

            var shareData = {
                issueKey: JIRA.Meta.getIssueKey(),
                filterId: Meta.get('filter-id'),
                jql: Meta.get('filter-jql'),
                permlink: permlinkFull
            };
            shareData[shareTarget] = true;

            return shareData;
        };

        this._enableSubmitWhenIsRecipient = function enableSubmitWhenIsRecipient() {
            var shareNames = dialogContents.find('#sharenames').val();
            var isUserProvided = (shareNames != null) && (shareNames.length > 0);
            this._enableSubmit(isUserProvided);
        };

        this._addInteractionHandlersToDialog = function addInteractionHandlersToDialog(shareData) {
            dialogContents.find('#sharenames').bind('change unselect', _.bind(this._enableSubmitWhenIsRecipient, this));
            dialogContents.find(".close-dialog").click(_.bind(this.resetAndHide, this));
            dialogContents.find("form").submit(_.bind(this.submit, this, shareData));
            dialogContents.find(".issuenav-permalink .text").click(function (e) {
                e.target.select();
                return false;
            });
            jQuery(document).bind('keyup.share-dialog', _.bind(function (e) {
                if (e.keyCode === jQuery.ui.keyCode.ESCAPE) {
                    return this.hideDialog();   // leave the dialog contents alone
                }
                return true;
            }, this));
            jQuery(document).bind("showLayer.share-dialog", function (e, type, dialog) {
                if (type === "inlineDialog" && dialog.popup === shareDialog) {
                    dialogContents.find("#sharenames-textarea").focus();
                }
            });
        };

        this._renderDialogContent = function renderDialogContent(shareData) {
            dialogContents.html(JIRA.Templates.Dialogs.Share.contentPopup({
                shareData: shareData,
                modifierKey: Meta.get("keyboard-accesskey-modifier"),
                //Only show the share form when outgoing mail is enabled
                showForm: Meta.get("outgoing-mail-enabled"),
                isAdmin: Meta.get("is-admin")
            }));
        };

        this._generatePopup = function generatePopup(contents, trigger, doShowPopup) {
            var shareData = this._getShareData(trigger);

            //If the share dialog has already been rendered and still on the issue it was rendered in
            if (dialogContents && currentShareLink === shareData.permlink) {
                dialogContents = contents;
                doShowPopup();
                return;
            }
            currentShareLink = shareData.permlink;
            dialogContents = contents;
            this._renderDialogContent(shareData);
            if (jQuery.browser.msie) {
                dialogContents.find("form").ieImitationPlaceholder();
            }
            this._enableSubmit(false);
            this._addInteractionHandlersToDialog.call(this, shareData);
            this.enableAccessKeys(jQuery("form", dialogContents));

            doShowPopup();

            JiraEvents.trigger(JiraEventTypes.NEW_CONTENT_ADDED, [dialogContents, JiraEventReasons.shareDialogOpened]);
        };

        this._scrollIntoViewForAuto = function _scrollIntoViewForAuto() {
            var self = this;
            var $context = jQuery(this.context);
            $context.scrollIntoViewForAuto({
                complete: function ()
                {
                    // $(this) is the element being scrolled to reveal the trigger.
                    var scrollers = jQuery(this).add(window);

                    // JRA-27476 - share dialog doesn't stalk. So hide it, without reset, when the page is
                    // scrolled. Delay to avoid catching the scroll events caused by scrollIntoViewForAuto()
                    _.delay(function ()
                    {
                        scrollers.one("scroll", function ()
                        {
                            jQuery(document.activeElement).blur();
                            self.hideDialog();
                        });
                    }, 20);
                }
            });
        };

        this._createDialogOptions = function _createDialogOptions(dialogId) {
            var offsetX = (dialogId.indexOf("issuenav") !== -1) ? -110 : -170;
            var dialogOptions = {
                preHideCallback: function () {
                    return allowDialogHide;
                },
                hideCallback: function () {
                    jQuery(".dashboard-actions .explanation").hide();
                },
                offsetY: 17,
                offsetX: offsetX,
                hideDelay: 36e5,         // needed for debugging! Sit for an hour.
                useLiveEvents: true,
                // Before showing the dialog, we want to ensure the trigger is scrolled into view, transitively this
                // will ensure that the dialog is visible. The page might be scrolled down to the bottom when the
                // user presses 's'.
                initCallback: _.bind(this._scrollIntoViewForAuto, this)
            };
            return dialogOptions;
        };

        this._addAJSInlineLayerEventHandlers = function _addAJSInlineLayerEventHandlers() {
            JiraEvents.bind(InlineLayer.EVENTS.beforeShow, function (e, layer, id) {
                if (id === "sharenames-layer") {
                    allowDialogHide = false;
                }
            });
            JiraEvents.bind(InlineLayer.EVENTS.hide, function (e, layer, reason, id) {
                if (id === "sharenames-layer") {
                    setTimeout(function () { allowDialogHide = true; }, 0);
                }
            });
        };

        this._initShareDialog = function _initShareDialog(dialogId, context) {
            var self = this;
            this.context = context;

            this._addAJSInlineLayerEventHandlers();

            var dialogOptions = this._createDialogOptions(dialogId);

            shareDialog = InlineDialog(jQuery(context), dialogId, _.bind(self._generatePopup, self), dialogOptions);

            shareDialog[0].popup._validateClickToClose = function(event) {
                return validationResult = shareDialog.has(event.target).length === 0;
            };

            // JRADEV-8136 - Clicking the share button again doesn't close the share dialog.
            jQuery(context).live("click", function() {
                if (shareDialog.find(".contents:visible").length) {
                    shareDialog.find("a.close-dialog").click();
                }
            });

            jQuery(document).bind("keydown", function (e) {
                // special case for when user hover is open at same time
                if (e.keyCode === jQuery.ui.keyCode.ESCAPE &&
                        InlineDialog.current !== shareDialog && shareDialog.is(":visible")) {
                    if (InlineDialog.current) {
                        InlineDialog.current.hide();
                    }
                    shareDialog.hide();
                }
            });
        };

        this._overrideContents = function overrideContents(newContents) {
            dialogContents = newContents;
        };

        this._getCurrentDialogContent = function getCurrentDialogContent() {
            return dialogContents;
        };

        this._getAllowDialogHide = function _getAllowDialogHide(){
            return allowDialogHide;
        };
    };
});

AJS.namespace('JIRA.JiraSharePlugin.SharePluginDialog', null, require('jira/share-plugin/share-plugin-dialog'));
;
;
/* module-key = 'com.atlassian.jira.jira-share-plugin:share-resources-init', location = 'js/share-dialog-init.js' */
// There may be multiple share button on the page, for example split view
// This is to ensure both works within its own scope and not affect each other

define('jira/share-plugin/initialiser', [
    'underscore',
    'jira/share-plugin/share-plugin-dialog',
    'jquery'
], function (
    _,
    SharePluginDialog,
    jQuery
) {
    return {
        init: _.once (function initShareDialogs() {
            var exports = {};
            exports.viewIssueDialog = new SharePluginDialog(jQuery);
            exports.issueNavDialog = new SharePluginDialog(jQuery);

            jQuery(_.bind(exports.viewIssueDialog._initShareDialog, exports.viewIssueDialog,
                    "share-entity-popup-viewissue", "#jira-share-trigger.viewissue-share"));
            jQuery(_.bind(exports.issueNavDialog._initShareDialog, exports.issueNavDialog,
                    "share-entity-popup-issuenav", "#jira-share-trigger.issuenav-share"));

            return exports;
        })
    };
});

// This IIFE will immediately and synchronously require the initialiser
// (thus create the dialogs), and immediately place the dialogs
// in to the global namespace. Use of AJS.namespace will add
// a deprecation warning whenever the global is accessed by other code.
(function(initialiser) {
    var dialogs = initialiser.init();
    AJS.namespace('JIRA.JiraSharePlugin.viewIssueDialog', null, dialogs.viewIssueDialog);
    AJS.namespace('JIRA.JiraSharePlugin.issueNavDialog', null, dialogs.issueNavDialog);
}(require('jira/share-plugin/initialiser')));
;
;
/* module-key = 'com.atlassian.plugin.jslibs:marionette-2.1.0-factory', location = 'factories/marionette/2.1.0/marionette-2.1.0-factory.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
  define('atlassian/libs/factories/marionette-2.1.0', function() {
    return function(_, Backbone) {
      var env = {
        _: _,
        Backbone: Backbone
      };
      factory.call(env);
      return env.Marionette.noConflict();
    }
  });
})(function(){
/////// End of Atlassian modification ///////

  // MarionetteJS (Backbone.Marionette)
  // ----------------------------------
  // v2.1.0
  //
  // Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.
  // Distributed under MIT license
  //
  // http://marionettejs.com


  /*!
   * Includes BabySitter
   * https://github.com/marionettejs/backbone.babysitter/
   *
   * Includes Wreqr
   * https://github.com/marionettejs/backbone.wreqr/
   */


  (function(root, factory) {

    if (typeof define === 'function' && define.amd) {
      define(['backbone', 'underscore'], function(Backbone, _) {
        return (root.Marionette = factory(root, Backbone, _));
      });
    } else if (typeof exports !== 'undefined') {
      var Backbone = require('backbone');
      var _ = require('underscore');
      module.exports = factory(root, Backbone, _);
    } else {
      root.Marionette = factory(root, root.Backbone, root._);
    }

  }(this, function(root, Backbone, _) {
    'use strict';

    // Backbone.BabySitter
    // -------------------
    // v0.1.4
    //
    // Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.
    // Distributed under MIT license
    //
    // http://github.com/marionettejs/backbone.babysitter
    (function(Backbone, _) {
      "use strict";
      var previousChildViewContainer = Backbone.ChildViewContainer;
      // BabySitter.ChildViewContainer
      // -----------------------------
      //
      // Provide a container to store, retrieve and
      // shut down child views.
      Backbone.ChildViewContainer = function(Backbone, _) {
        // Container Constructor
        // ---------------------
        var Container = function(views) {
          this._views = {};
          this._indexByModel = {};
          this._indexByCustom = {};
          this._updateLength();
          _.each(views, this.add, this);
        };
        // Container Methods
        // -----------------
        _.extend(Container.prototype, {
          // Add a view to this container. Stores the view
          // by `cid` and makes it searchable by the model
          // cid (and model itself). Optionally specify
          // a custom key to store an retrieve the view.
          add: function(view, customIndex) {
            var viewCid = view.cid;
            // store the view
            this._views[viewCid] = view;
            // index it by model
            if (view.model) {
              this._indexByModel[view.model.cid] = viewCid;
            }
            // index by custom
            if (customIndex) {
              this._indexByCustom[customIndex] = viewCid;
            }
            this._updateLength();
            return this;
          },
          // Find a view by the model that was attached to
          // it. Uses the model's `cid` to find it.
          findByModel: function(model) {
            return this.findByModelCid(model.cid);
          },
          // Find a view by the `cid` of the model that was attached to
          // it. Uses the model's `cid` to find the view `cid` and
          // retrieve the view using it.
          findByModelCid: function(modelCid) {
            var viewCid = this._indexByModel[modelCid];
            return this.findByCid(viewCid);
          },
          // Find a view by a custom indexer.
          findByCustom: function(index) {
            var viewCid = this._indexByCustom[index];
            return this.findByCid(viewCid);
          },
          // Find by index. This is not guaranteed to be a
          // stable index.
          findByIndex: function(index) {
            return _.values(this._views)[index];
          },
          // retrieve a view by its `cid` directly
          findByCid: function(cid) {
            return this._views[cid];
          },
          // Remove a view
          remove: function(view) {
            var viewCid = view.cid;
            // delete model index
            if (view.model) {
              delete this._indexByModel[view.model.cid];
            }
            // delete custom index
            _.any(this._indexByCustom, function(cid, key) {
              if (cid === viewCid) {
                delete this._indexByCustom[key];
                return true;
              }
            }, this);
            // remove the view from the container
            delete this._views[viewCid];
            // update the length
            this._updateLength();
            return this;
          },
          // Call a method on every view in the container,
          // passing parameters to the call method one at a
          // time, like `function.call`.
          call: function(method) {
            this.apply(method, _.tail(arguments));
          },
          // Apply a method on every view in the container,
          // passing parameters to the call method one at a
          // time, like `function.apply`.
          apply: function(method, args) {
            _.each(this._views, function(view) {
              if (_.isFunction(view[method])) {
                view[method].apply(view, args || []);
              }
            });
          },
          // Update the `.length` attribute on this container
          _updateLength: function() {
            this.length = _.size(this._views);
          }
        });
        // Borrowing this code from Backbone.Collection:
        // http://backbonejs.org/docs/backbone.html#section-106
        //
        // Mix in methods from Underscore, for iteration, and other
        // collection related features.
        var methods = [ "forEach", "each", "map", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "toArray", "first", "initial", "rest", "last", "without", "isEmpty", "pluck" ];
        _.each(methods, function(method) {
          Container.prototype[method] = function() {
            var views = _.values(this._views);
            var args = [ views ].concat(_.toArray(arguments));
            return _[method].apply(_, args);
          };
        });
        // return the public API
        return Container;
      }(Backbone, _);
      Backbone.ChildViewContainer.VERSION = "0.1.4";
      Backbone.ChildViewContainer.noConflict = function() {
        Backbone.ChildViewContainer = previousChildViewContainer;
        return this;
      };
      return Backbone.ChildViewContainer;
    })(Backbone, _);
    // Backbone.Wreqr (Backbone.Marionette)
    // ----------------------------------
    // v1.3.1
    //
    // Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.
    // Distributed under MIT license
    //
    // http://github.com/marionettejs/backbone.wreqr
    (function(Backbone, _) {
      "use strict";
      var previousWreqr = Backbone.Wreqr;
      var Wreqr = Backbone.Wreqr = {};
      Backbone.Wreqr.VERSION = "1.3.1";
      Backbone.Wreqr.noConflict = function() {
        Backbone.Wreqr = previousWreqr;
        return this;
      };
      // Handlers
      // --------
      // A registry of functions to call, given a name
      Wreqr.Handlers = function(Backbone, _) {
        "use strict";
        // Constructor
        // -----------
        var Handlers = function(options) {
          this.options = options;
          this._wreqrHandlers = {};
          if (_.isFunction(this.initialize)) {
            this.initialize(options);
          }
        };
        Handlers.extend = Backbone.Model.extend;
        // Instance Members
        // ----------------
        _.extend(Handlers.prototype, Backbone.Events, {
          // Add multiple handlers using an object literal configuration
          setHandlers: function(handlers) {
            _.each(handlers, function(handler, name) {
              var context = null;
              if (_.isObject(handler) && !_.isFunction(handler)) {
                context = handler.context;
                handler = handler.callback;
              }
              this.setHandler(name, handler, context);
            }, this);
          },
          // Add a handler for the given name, with an
          // optional context to run the handler within
          setHandler: function(name, handler, context) {
            var config = {
              callback: handler,
              context: context
            };
            this._wreqrHandlers[name] = config;
            this.trigger("handler:add", name, handler, context);
          },
          // Determine whether or not a handler is registered
          hasHandler: function(name) {
            return !!this._wreqrHandlers[name];
          },
          // Get the currently registered handler for
          // the specified name. Throws an exception if
          // no handler is found.
          getHandler: function(name) {
            var config = this._wreqrHandlers[name];
            if (!config) {
              return;
            }
            return function() {
              var args = Array.prototype.slice.apply(arguments);
              return config.callback.apply(config.context, args);
            };
          },
          // Remove a handler for the specified name
          removeHandler: function(name) {
            delete this._wreqrHandlers[name];
          },
          // Remove all handlers from this registry
          removeAllHandlers: function() {
            this._wreqrHandlers = {};
          }
        });
        return Handlers;
      }(Backbone, _);
      // Wreqr.CommandStorage
      // --------------------
      //
      // Store and retrieve commands for execution.
      Wreqr.CommandStorage = function() {
        "use strict";
        // Constructor function
        var CommandStorage = function(options) {
          this.options = options;
          this._commands = {};
          if (_.isFunction(this.initialize)) {
            this.initialize(options);
          }
        };
        // Instance methods
        _.extend(CommandStorage.prototype, Backbone.Events, {
          // Get an object literal by command name, that contains
          // the `commandName` and the `instances` of all commands
          // represented as an array of arguments to process
          getCommands: function(commandName) {
            var commands = this._commands[commandName];
            // we don't have it, so add it
            if (!commands) {
              // build the configuration
              commands = {
                command: commandName,
                instances: []
              };
              // store it
              this._commands[commandName] = commands;
            }
            return commands;
          },
          // Add a command by name, to the storage and store the
          // args for the command
          addCommand: function(commandName, args) {
            var command = this.getCommands(commandName);
            command.instances.push(args);
          },
          // Clear all commands for the given `commandName`
          clearCommands: function(commandName) {
            var command = this.getCommands(commandName);
            command.instances = [];
          }
        });
        return CommandStorage;
      }();
      // Wreqr.Commands
      // --------------
      //
      // A simple command pattern implementation. Register a command
      // handler and execute it.
      Wreqr.Commands = function(Wreqr) {
        "use strict";
        return Wreqr.Handlers.extend({
          // default storage type
          storageType: Wreqr.CommandStorage,
          constructor: function(options) {
            this.options = options || {};
            this._initializeStorage(this.options);
            this.on("handler:add", this._executeCommands, this);
            var args = Array.prototype.slice.call(arguments);
            Wreqr.Handlers.prototype.constructor.apply(this, args);
          },
          // Execute a named command with the supplied args
          execute: function(name, args) {
            name = arguments[0];
            args = Array.prototype.slice.call(arguments, 1);
            if (this.hasHandler(name)) {
              this.getHandler(name).apply(this, args);
            } else {
              this.storage.addCommand(name, args);
            }
          },
          // Internal method to handle bulk execution of stored commands
          _executeCommands: function(name, handler, context) {
            var command = this.storage.getCommands(name);
            // loop through and execute all the stored command instances
            _.each(command.instances, function(args) {
              handler.apply(context, args);
            });
            this.storage.clearCommands(name);
          },
          // Internal method to initialize storage either from the type's
          // `storageType` or the instance `options.storageType`.
          _initializeStorage: function(options) {
            var storage;
            var StorageType = options.storageType || this.storageType;
            if (_.isFunction(StorageType)) {
              storage = new StorageType();
            } else {
              storage = StorageType;
            }
            this.storage = storage;
          }
        });
      }(Wreqr);
      // Wreqr.RequestResponse
      // ---------------------
      //
      // A simple request/response implementation. Register a
      // request handler, and return a response from it
      Wreqr.RequestResponse = function(Wreqr) {
        "use strict";
        return Wreqr.Handlers.extend({
          request: function() {
            var name = arguments[0];
            var args = Array.prototype.slice.call(arguments, 1);
            if (this.hasHandler(name)) {
              return this.getHandler(name).apply(this, args);
            }
          }
        });
      }(Wreqr);
      // Event Aggregator
      // ----------------
      // A pub-sub object that can be used to decouple various parts
      // of an application through event-driven architecture.
      Wreqr.EventAggregator = function(Backbone, _) {
        "use strict";
        var EA = function() {};
        // Copy the `extend` function used by Backbone's classes
        EA.extend = Backbone.Model.extend;
        // Copy the basic Backbone.Events on to the event aggregator
        _.extend(EA.prototype, Backbone.Events);
        return EA;
      }(Backbone, _);
      // Wreqr.Channel
      // --------------
      //
      // An object that wraps the three messaging systems:
      // EventAggregator, RequestResponse, Commands
      Wreqr.Channel = function(Wreqr) {
        "use strict";
        var Channel = function(channelName) {
          /////////// Modified by Atlassian ///////////
          this.vent = new Wreqr.EventAggregator();
          this.reqres = new Wreqr.RequestResponse();
          this.commands = new Wreqr.Commands();
          /////// End of Atlassian modification ///////
          this.channelName = channelName;
        };
        _.extend(Channel.prototype, {
          // Remove all handlers from the messaging systems of this channel
          reset: function() {
            this.vent.off();
            this.vent.stopListening();
            this.reqres.removeAllHandlers();
            this.commands.removeAllHandlers();
            return this;
          },
          // Connect a hash of events; one for each messaging system
          connectEvents: function(hash, context) {
            this._connect("vent", hash, context);
            return this;
          },
          connectCommands: function(hash, context) {
            this._connect("commands", hash, context);
            return this;
          },
          connectRequests: function(hash, context) {
            this._connect("reqres", hash, context);
            return this;
          },
          // Attach the handlers to a given message system `type`
          _connect: function(type, hash, context) {
            if (!hash) {
              return;
            }
            context = context || this;
            var method = type === "vent" ? "on" : "setHandler";
            _.each(hash, function(fn, eventName) {
              this[type][method](eventName, _.bind(fn, context));
            }, this);
          }
        });
        return Channel;
      }(Wreqr);
      // Wreqr.Radio
      // --------------
      //
      // An object that lets you communicate with many channels.
      Wreqr.radio = function(Wreqr) {
        "use strict";
        var Radio = function() {
          this._channels = {};
          this.vent = {};
          this.commands = {};
          this.reqres = {};
          this._proxyMethods();
        };
        _.extend(Radio.prototype, {
          channel: function(channelName) {
            if (!channelName) {
              throw new Error("Channel must receive a name");
            }
            return this._getChannel(channelName);
          },
          _getChannel: function(channelName) {
            var channel = this._channels[channelName];
            if (!channel) {
              channel = new Wreqr.Channel(channelName);
              this._channels[channelName] = channel;
            }
            return channel;
          },
          _proxyMethods: function() {
            _.each([ "vent", "commands", "reqres" ], function(system) {
              _.each(messageSystems[system], function(method) {
                this[system][method] = proxyMethod(this, system, method);
              }, this);
            }, this);
          }
        });
        var messageSystems = {
          vent: [ "on", "off", "trigger", "once", "stopListening", "listenTo", "listenToOnce" ],
          commands: [ "execute", "setHandler", "setHandlers", "removeHandler", "removeAllHandlers" ],
          reqres: [ "request", "setHandler", "setHandlers", "removeHandler", "removeAllHandlers" ]
        };
        var proxyMethod = function(radio, system, method) {
          return function(channelName) {
            var messageSystem = radio._getChannel(channelName)[system];
            var args = Array.prototype.slice.call(arguments, 1);
            return messageSystem[method].apply(messageSystem, args);
          };
        };
        return new Radio();
      }(Wreqr);
      return Backbone.Wreqr;
    })(Backbone, _);

    /////////// Modified by Atlassian ///////////
    var BackboneChildViewContainer = Backbone.ChildViewContainer.noConflict();
    var BackboneWreqr = Backbone.Wreqr.noConflict();
    /////// End of Atlassian modification ///////

    var previousMarionette = root.Marionette;

    var Marionette = Backbone.Marionette = {};

    Marionette.VERSION = '2.1.0';

    Marionette.noConflict = function() {
      root.Marionette = previousMarionette;
      return this;
    };

    Backbone.Marionette = Marionette;

    // Get the Deferred creator for later use
    Marionette.Deferred = Backbone.$.Deferred;

    /* jshint unused: false */

    // Helpers
    // -------

    // For slicing `arguments` in functions
    var slice = Array.prototype.slice;

    function throwError(message, name) {
      var error = new Error(message);
      error.name = name || 'Error';
      throw error;
    }

    // Marionette.extend
    // -----------------

    // Borrow the Backbone `extend` method so we can use it as needed
    Marionette.extend = Backbone.Model.extend;

    // Marionette.getOption
    // --------------------

    // Retrieve an object, function or other value from a target
    // object or its `options`, with `options` taking precedence.
    Marionette.getOption = function(target, optionName) {
      if (!target || !optionName) { return; }
      var value;

      if (target.options && (target.options[optionName] !== undefined)) {
        value = target.options[optionName];
      } else {
        value = target[optionName];
      }

      return value;
    };

    // Proxy `Marionette.getOption`
    Marionette.proxyGetOption = function(optionName) {
      return Marionette.getOption(this, optionName);
    };

    // Marionette.normalizeMethods
    // ----------------------

    // Pass in a mapping of events => functions or function names
    // and return a mapping of events => functions
    Marionette.normalizeMethods = function(hash) {
      var normalizedHash = {};
      _.each(hash, function(method, name) {
        if (!_.isFunction(method)) {
          method = this[method];
        }
        if (!method) {
          return;
        }
        normalizedHash[name] = method;
      }, this);
      return normalizedHash;
    };


    // allows for the use of the @ui. syntax within
    // a given key for triggers and events
    // swaps the @ui with the associated selector
    Marionette.normalizeUIKeys = function(hash, ui) {
      if (typeof(hash) === 'undefined') {
        return;
      }

      _.each(_.keys(hash), function(v) {
        var pattern = /@ui\.[a-zA-Z_$0-9]*/g;
        if (v.match(pattern)) {
          hash[v.replace(pattern, function(r) {
            return ui[r.slice(4)];
          })] = hash[v];
          delete hash[v];
        }
      });

      return hash;
    };

    // Mix in methods from Underscore, for iteration, and other
    // collection related features.
    // Borrowing this code from Backbone.Collection:
    // http://backbonejs.org/docs/backbone.html#section-121
    Marionette.actAsCollection = function(object, listProperty) {
      var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
        'select', 'reject', 'every', 'all', 'some', 'any', 'include',
        'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
        'last', 'without', 'isEmpty', 'pluck'];

      _.each(methods, function(method) {
        object[method] = function() {
          var list = _.values(_.result(this, listProperty));
          var args = [list].concat(_.toArray(arguments));
          return _[method].apply(_, args);
        };
      });
    };

    // Trigger an event and/or a corresponding method name. Examples:
    //
    // `this.triggerMethod("foo")` will trigger the "foo" event and
    // call the "onFoo" method.
    //
    // `this.triggerMethod("foo:bar")` will trigger the "foo:bar" event and
    // call the "onFooBar" method.
    Marionette.triggerMethod = (function() {

      // split the event name on the ":"
      var splitter = /(^|:)(\w)/gi;

      // take the event section ("section1:section2:section3")
      // and turn it in to uppercase name
      function getEventName(match, prefix, eventName) {
        return eventName.toUpperCase();
      }

      // actual triggerMethod implementation
      var triggerMethod = function(event) {
        // get the method name from the event name
        var methodName = 'on' + event.replace(splitter, getEventName);
        var method = this[methodName];
        var result;

        // call the onMethodName if it exists
        if (_.isFunction(method)) {
          // pass all arguments, except the event name
          result = method.apply(this, _.tail(arguments));
        }

        // trigger the event, if a trigger method exists
        if (_.isFunction(this.trigger)) {
          this.trigger.apply(this, arguments);
        }

        return result;
      };

      return triggerMethod;
    })();

    // DOMRefresh
    // ----------
    //
    // Monitor a view's state, and after it has been rendered and shown
    // in the DOM, trigger a "dom:refresh" event every time it is
    // re-rendered.

    Marionette.MonitorDOMRefresh = (function(documentElement) {
      // track when the view has been shown in the DOM,
      // using a Marionette.Region (or by other means of triggering "show")
      function handleShow(view) {
        view._isShown = true;
        triggerDOMRefresh(view);
      }

      // track when the view has been rendered
      function handleRender(view) {
        view._isRendered = true;
        triggerDOMRefresh(view);
      }

      // Trigger the "dom:refresh" event and corresponding "onDomRefresh" method
      function triggerDOMRefresh(view) {
        if (view._isShown && view._isRendered && isInDOM(view)) {
          if (_.isFunction(view.triggerMethod)) {
            view.triggerMethod('dom:refresh');
          }
        }
      }

      function isInDOM(view) {
        return Backbone.$.contains(documentElement, view.el);
      }

      // Export public API
      return function(view) {
        view.listenTo(view, 'show', function() {
          handleShow(view);
        });

        view.listenTo(view, 'render', function() {
          handleRender(view);
        });
      };
    })(document.documentElement);


    /* jshint maxparams: 5 */

    // Marionette.bindEntityEvents & unbindEntityEvents
    // ---------------------------
    //
    // These methods are used to bind/unbind a backbone "entity" (collection/model)
    // to methods on a target object.
    //
    // The first parameter, `target`, must have a `listenTo` method from the
    // EventBinder object.
    //
    // The second parameter is the entity (Backbone.Model or Backbone.Collection)
    // to bind the events from.
    //
    // The third parameter is a hash of { "event:name": "eventHandler" }
    // configuration. Multiple handlers can be separated by a space. A
    // function can be supplied instead of a string handler name.

    (function(Marionette) {
      'use strict';

      // Bind the event to handlers specified as a string of
      // handler names on the target object
      function bindFromStrings(target, entity, evt, methods) {
        var methodNames = methods.split(/\s+/);

        _.each(methodNames, function(methodName) {

          var method = target[methodName];
          if (!method) {
            throwError('Method "' + methodName +
              '" was configured as an event handler, but does not exist.');
          }

          target.listenTo(entity, evt, method);
        });
      }

      // Bind the event to a supplied callback function
      function bindToFunction(target, entity, evt, method) {
        target.listenTo(entity, evt, method);
      }

      // Bind the event to handlers specified as a string of
      // handler names on the target object
      function unbindFromStrings(target, entity, evt, methods) {
        var methodNames = methods.split(/\s+/);

        _.each(methodNames, function(methodName) {
          var method = target[methodName];
          target.stopListening(entity, evt, method);
        });
      }

      // Bind the event to a supplied callback function
      function unbindToFunction(target, entity, evt, method) {
        target.stopListening(entity, evt, method);
      }


      // generic looping function
      function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {
        if (!entity || !bindings) { return; }

        // allow the bindings to be a function
        if (_.isFunction(bindings)) {
          bindings = bindings.call(target);
        }

        // iterate the bindings and bind them
        _.each(bindings, function(methods, evt) {

          // allow for a function as the handler,
          // or a list of event names as a string
          if (_.isFunction(methods)) {
            functionCallback(target, entity, evt, methods);
          } else {
            stringCallback(target, entity, evt, methods);
          }

        });
      }

      // Export Public API
      Marionette.bindEntityEvents = function(target, entity, bindings) {
        iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);
      };

      Marionette.unbindEntityEvents = function(target, entity, bindings) {
        iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);
      };

      // Proxy `bindEntityEvents`
      Marionette.proxyBindEntityEvents = function(entity, bindings) {
        return Marionette.bindEntityEvents(this, entity, bindings);
      };

      // Proxy `unbindEntityEvents`
      Marionette.proxyUnbindEntityEvents = function(entity, bindings) {
        return Marionette.unbindEntityEvents(this, entity, bindings);
      };
    })(Marionette);


    // Callbacks
    // ---------

    // A simple way of managing a collection of callbacks
    // and executing them at a later point in time, using jQuery's
    // `Deferred` object.
    Marionette.Callbacks = function() {
      this._deferred = Marionette.Deferred();
      this._callbacks = [];
    };

    _.extend(Marionette.Callbacks.prototype, {

      // Add a callback to be executed. Callbacks added here are
      // guaranteed to execute, even if they are added after the
      // `run` method is called.
      add: function(callback, contextOverride) {
        var promise = _.result(this._deferred, 'promise');

        this._callbacks.push({cb: callback, ctx: contextOverride});

        promise.then(function(args) {
          if (contextOverride){ args.context = contextOverride; }
          callback.call(args.context, args.options);
        });
      },

      // Run all registered callbacks with the context specified.
      // Additional callbacks can be added after this has been run
      // and they will still be executed.
      run: function(options, context) {
        this._deferred.resolve({
          options: options,
          context: context
        });
      },

      // Resets the list of callbacks to be run, allowing the same list
      // to be run multiple times - whenever the `run` method is called.
      reset: function() {
        var callbacks = this._callbacks;
        this._deferred = Marionette.Deferred();
        this._callbacks = [];

        _.each(callbacks, function(cb) {
          this.add(cb.cb, cb.ctx);
        }, this);
      }
    });

    // Marionette Controller
    // ---------------------
    //
    // A multi-purpose object to use as a controller for
    // modules and routers, and as a mediator for workflow
    // and coordination of other objects, views, and more.
    Marionette.Controller = function(options) {
      this.options = options || {};

      if (_.isFunction(this.initialize)) {
        this.initialize(this.options);
      }
    };

    Marionette.Controller.extend = Marionette.extend;

    // Controller Methods
    // --------------

    // Ensure it can trigger events with Backbone.Events
    _.extend(Marionette.Controller.prototype, Backbone.Events, {
      destroy: function() {
        var args = slice.call(arguments);
        this.triggerMethod.apply(this, ['before:destroy'].concat(args));
        this.triggerMethod.apply(this, ['destroy'].concat(args));

        this.stopListening();
        this.off();
        return this;
      },

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod,

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption

    });

    // Marionette Object
    // ---------------------
    //
    // A Base Class that other Classes should descend from.
    // Object borrows many conventions and utilities from Backbone.
    Marionette.Object = function(options) {

      this.options = _.extend({}, _.result(this, 'options'), options);

      this.initialize(this.options);
    };

    Marionette.Object.extend = Marionette.extend;

    // Object Methods
    // --------------

    _.extend(Marionette.Object.prototype, {

      //this is a noop method intended to be overridden by classes that extend from this base
      initialize: function() {},

      destroy: function() {
        this.triggerMethod('before:destroy');
        this.triggerMethod('destroy');
        this.stopListening();
      },

      // Import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod,

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption,

      // Proxy `unbindEntityEvents` to enable binding view's events from another entity.
      bindEntityEvents: Marionette.proxyBindEntityEvents,

      // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
      unbindEntityEvents: Marionette.proxyUnbindEntityEvents
    });

    // Ensure it can trigger events with Backbone.Events
    _.extend(Marionette.Object.prototype, Backbone.Events);

    /* jshint maxcomplexity: 10, maxstatements: 29 */

    // Region
    // ------
    //
    // Manage the visual regions of your composite application. See
    // http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/

    Marionette.Region = function(options) {
      this.options = options || {};
      this.el = this.getOption('el');

      // Handle when this.el is passed in as a $ wrapped element.
      this.el = this.el instanceof Backbone.$ ? this.el[0] : this.el;

      if (!this.el) {
        throwError('An "el" must be specified for a region.', 'NoElError');
      }

      this.$el = this.getEl(this.el);

      if (this.initialize) {
        var args = slice.apply(arguments);
        this.initialize.apply(this, args);
      }
    };


    // Region Class methods
    // -------------------

    _.extend(Marionette.Region, {

      // Build an instance of a region by passing in a configuration object
      // and a default region class to use if none is specified in the config.
      //
      // The config object should either be a string as a jQuery DOM selector,
      // a Region class directly, or an object literal that specifies both
      // a selector and regionClass:
      //
      // ```js
      // {
      //   selector: "#foo",
      //   regionClass: MyCustomRegion
      // }
      // ```
      //
      buildRegion: function(regionConfig, DefaultRegionClass) {
        if (_.isString(regionConfig)) {
          return this._buildRegionFromSelector(regionConfig, DefaultRegionClass);
        }

        if (regionConfig.selector || regionConfig.el || regionConfig.regionClass) {
          return this._buildRegionFromObject(regionConfig, DefaultRegionClass);
        }

        if (_.isFunction(regionConfig)) {
          return this._buildRegionFromRegionClass(regionConfig);
        }

        throwError('Improper region configuration type. Please refer ' +
          'to http://marionettejs.com/docs/marionette.region.html#region-configuration-types');
      },

      // Build the region from a string selector like '#foo-region'
      _buildRegionFromSelector: function(selector, DefaultRegionClass) {
        return new DefaultRegionClass({ el: selector });
      },

      // Build the region from a configuration object
      // ```js
      // { selector: '#foo', regionClass: FooRegion }
      // ```
      _buildRegionFromObject: function(regionConfig, DefaultRegionClass) {
        var RegionClass = regionConfig.regionClass || DefaultRegionClass;
        var options = _.omit(regionConfig, 'selector', 'regionClass');

        if (regionConfig.selector && !options.el) {
          options.el = regionConfig.selector;
        }

        var region = new RegionClass(options);

        // override the `getEl` function if we have a parentEl
        // this must be overridden to ensure the selector is found
        // on the first use of the region. if we try to assign the
        // region's `el` to `parentEl.find(selector)` in the object
        // literal to build the region, the element will not be
        // guaranteed to be in the DOM already, and will cause problems
        if (regionConfig.parentEl) {
          region.getEl = function(el) {
            if (_.isObject(el)) {
              return Backbone.$(el);
            }
            var parentEl = regionConfig.parentEl;
            if (_.isFunction(parentEl)) {
              parentEl = parentEl();
            }
            return parentEl.find(el);
          };
        }

        return region;
      },

      // Build the region directly from a given `RegionClass`
      _buildRegionFromRegionClass: function(RegionClass) {
        return new RegionClass();
      }

    });

    // Region Instance Methods
    // -----------------------

    _.extend(Marionette.Region.prototype, Backbone.Events, {

      // Displays a backbone view instance inside of the region.
      // Handles calling the `render` method for you. Reads content
      // directly from the `el` attribute. Also calls an optional
      // `onShow` and `onDestroy` method on your view, just after showing
      // or just before destroying the view, respectively.
      // The `preventDestroy` option can be used to prevent a view from
      // the old view being destroyed on show.
      // The `forceShow` option can be used to force a view to be
      // re-rendered if it's already shown in the region.

      show: function(view, options){
        this._ensureElement();

        var showOptions = options || {};
        var isDifferentView = view !== this.currentView;
        var preventDestroy =  !!showOptions.preventDestroy;
        var forceShow = !!showOptions.forceShow;

        // we are only changing the view if there is a view to change to begin with
        var isChangingView = !!this.currentView;

        // only destroy the view if we don't want to preventDestroy and the view is different
        var _shouldDestroyView = !preventDestroy && isDifferentView;

        if (_shouldDestroyView) {
          this.empty();
        }

        // show the view if the view is different or if you want to re-show the view
        var _shouldShowView = isDifferentView || forceShow;

        if (_shouldShowView) {

          // We need to listen for if a view is destroyed
          // in a way other than through the region.
          // If this happens we need to remove the reference
          // to the currentView since once a view has been destroyed
          // we can not reuse it.
          view.once('destroy', _.bind(this.empty, this));
          view.render();

          if (isChangingView) {
            this.triggerMethod('before:swap', view);
          }

          this.triggerMethod('before:show', view);

          if (_.isFunction(view.triggerMethod)) {
            view.triggerMethod('before:show');
          } else {
            this.triggerMethod.call(view, 'before:show');
          }

          this.attachHtml(view);
          this.currentView = view;

          if (isChangingView) {
            this.triggerMethod('swap', view);
          }

          this.triggerMethod('show', view);

          if (_.isFunction(view.triggerMethod)) {
            view.triggerMethod('show');
          } else {
            this.triggerMethod.call(view, 'show');
          }

          return this;
        }

        return this;
      },

      _ensureElement: function(){
        if (!_.isObject(this.el)) {
          this.$el = this.getEl(this.el);
          this.el = this.$el[0];
        }

        if (!this.$el || this.$el.length === 0) {
          throwError('An "el" ' + this.$el.selector + ' must exist in DOM');
        }
      },

      // Override this method to change how the region finds the
      // DOM element that it manages. Return a jQuery selector object.
      getEl: function(el) {
        return Backbone.$(el);
      },

      // Override this method to change how the new view is
      // appended to the `$el` that the region is managing
      attachHtml: function(view) {
        // empty the node and append new view
        this.el.innerHTML='';
        this.el.appendChild(view.el);
      },

      // Destroy the current view, if there is one. If there is no
      // current view, it does nothing and returns immediately.
      empty: function() {
        var view = this.currentView;

        // If there is no view in the region
        // we should not remove anything
        if (!view) { return; }

        this.triggerMethod('before:empty', view);
        this._destroyView();
        this.triggerMethod('empty', view);

        // Remove region pointer to the currentView
        delete this.currentView;
        return this;
      },

      // call 'destroy' or 'remove', depending on which is found
      // on the view (if showing a raw Backbone view or a Marionette View)
      _destroyView: function() {
        var view = this.currentView;

        if (view.destroy && !view.isDestroyed) {
          view.destroy();
        } else if (view.remove) {
          view.remove();
        }
      },

      // Attach an existing view to the region. This
      // will not call `render` or `onShow` for the new view,
      // and will not replace the current HTML for the `el`
      // of the region.
      attachView: function(view) {
        this.currentView = view;
        return this;
      },

      // Checks whether a view is currently present within
      // the region. Returns `true` if there is and `false` if
      // no view is present.
      hasView: function() {
        return !!this.currentView;
      },

      // Reset the region by destroying any existing view and
      // clearing out the cached `$el`. The next time a view
      // is shown via this region, the region will re-query the
      // DOM for the region's `el`.
      reset: function() {
        this.empty();

        if (this.$el) {
          this.el = this.$el.selector;
        }

        delete this.$el;
        return this;
      },

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption,

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod
    });

    // Copy the `extend` function used by Backbone's classes
    Marionette.Region.extend = Marionette.extend;

    // Marionette.RegionManager
    // ------------------------
    //
    // Manage one or more related `Marionette.Region` objects.
    Marionette.RegionManager = (function(Marionette) {

      var RegionManager = Marionette.Controller.extend({
        constructor: function(options) {
          this._regions = {};
          Marionette.Controller.call(this, options);
        },

        // Add multiple regions using an object literal or a
        // function that returns an object literal, where
        // each key becomes the region name, and each value is
        // the region definition.
        addRegions: function(regionDefinitions, defaults) {
          if (_.isFunction(regionDefinitions)) {
            regionDefinitions = regionDefinitions.apply(this, arguments);
          }

          var regions = {};

          _.each(regionDefinitions, function(definition, name) {
            if (_.isString(definition)) {
              definition = {selector: definition};
            }

            if (definition.selector) {
              definition = _.defaults({}, definition, defaults);
            }

            var region = this.addRegion(name, definition);
            regions[name] = region;
          }, this);

          return regions;
        },

        // Add an individual region to the region manager,
        // and return the region instance
        addRegion: function(name, definition) {
          var region;

          var isObject = _.isObject(definition);
          var isString = _.isString(definition);
          var hasSelector = !!definition.selector;

          if (isString || (isObject && hasSelector)) {
            region = Marionette.Region.buildRegion(definition, Marionette.Region);
          } else if (_.isFunction(definition)) {
            region = Marionette.Region.buildRegion(definition, Marionette.Region);
          } else {
            region = definition;
          }

          this.triggerMethod('before:add:region', name, region);

          this._store(name, region);

          this.triggerMethod('add:region', name, region);
          return region;
        },

        // Get a region by name
        get: function(name) {
          return this._regions[name];
        },

        // Gets all the regions contained within
        // the `regionManager` instance.
        getRegions: function(){
          return _.clone(this._regions);
        },

        // Remove a region by name
        removeRegion: function(name) {
          var region = this._regions[name];
          this._remove(name, region);

          return region;
        },

        // Empty all regions in the region manager, and
        // remove them
        removeRegions: function() {
          var regions = this.getRegions();
          _.each(this._regions, function(region, name) {
            this._remove(name, region);
          }, this);

          return regions;
        },

        // Empty all regions in the region manager, but
        // leave them attached
        emptyRegions: function() {
          var regions = this.getRegions();
          _.each(regions, function(region) {
            region.empty();
          }, this);

          return regions;
        },

        // Destroy all regions and shut down the region
        // manager entirely
        destroy: function() {
          this.removeRegions();
          return Marionette.Controller.prototype.destroy.apply(this, arguments);
        },

        // internal method to store regions
        _store: function(name, region) {
          this._regions[name] = region;
          this._setLength();
        },

        // internal method to remove a region
        _remove: function(name, region) {
          this.triggerMethod('before:remove:region', name, region);
          region.empty();
          region.stopListening();
          delete this._regions[name];
          this._setLength();
          this.triggerMethod('remove:region', name, region);
        },

        // set the number of regions current held
        _setLength: function() {
          this.length = _.size(this._regions);
        }

      });

      Marionette.actAsCollection(RegionManager.prototype, '_regions');

      return RegionManager;
    })(Marionette);


    // Template Cache
    // --------------

    // Manage templates stored in `<script>` blocks,
    // caching them for faster access.
    Marionette.TemplateCache = function(templateId) {
      this.templateId = templateId;
    };

    // TemplateCache object-level methods. Manage the template
    // caches from these method calls instead of creating
    // your own TemplateCache instances
    _.extend(Marionette.TemplateCache, {
      templateCaches: {},

      // Get the specified template by id. Either
      // retrieves the cached version, or loads it
      // from the DOM.
      get: function(templateId) {
        var cachedTemplate = this.templateCaches[templateId];

        if (!cachedTemplate) {
          cachedTemplate = new Marionette.TemplateCache(templateId);
          this.templateCaches[templateId] = cachedTemplate;
        }

        return cachedTemplate.load();
      },

      // Clear templates from the cache. If no arguments
      // are specified, clears all templates:
      // `clear()`
      //
      // If arguments are specified, clears each of the
      // specified templates from the cache:
      // `clear("#t1", "#t2", "...")`
      clear: function() {
        var i;
        var args = slice.call(arguments);
        var length = args.length;

        if (length > 0) {
          for (i = 0; i < length; i++) {
            delete this.templateCaches[args[i]];
          }
        } else {
          this.templateCaches = {};
        }
      }
    });

    // TemplateCache instance methods, allowing each
    // template cache object to manage its own state
    // and know whether or not it has been loaded
    _.extend(Marionette.TemplateCache.prototype, {

      // Internal method to load the template
      load: function() {
        // Guard clause to prevent loading this template more than once
        if (this.compiledTemplate) {
          return this.compiledTemplate;
        }

        // Load the template and compile it
        var template = this.loadTemplate(this.templateId);
        this.compiledTemplate = this.compileTemplate(template);

        return this.compiledTemplate;
      },

      // Load a template from the DOM, by default. Override
      // this method to provide your own template retrieval
      // For asynchronous loading with AMD/RequireJS, consider
      // using a template-loader plugin as described here:
      // https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs
      loadTemplate: function(templateId) {
        var template = Backbone.$(templateId).html();

        if (!template || template.length === 0) {
          throwError('Could not find template: "' + templateId + '"', 'NoTemplateError');
        }

        return template;
      },

      // Pre-compile the template before caching it. Override
      // this method if you do not need to pre-compile a template
      // (JST / RequireJS for example) or if you want to change
      // the template engine used (Handebars, etc).
      compileTemplate: function(rawTemplate) {
        return _.template(rawTemplate);
      }
    });

    // Renderer
    // --------

    // Render a template with data by passing in the template
    // selector and the data to render.
    Marionette.Renderer = {

      // Render a template with data. The `template` parameter is
      // passed to the `TemplateCache` object to retrieve the
      // template function. Override this method to provide your own
      // custom rendering and template handling for all of Marionette.
      render: function(template, data) {
        if (!template) {
          throwError('Cannot render the template since its false, null or undefined.',
            'TemplateNotFoundError');
        }

        var templateFunc;
        if (typeof template === 'function') {
          templateFunc = template;
        } else {
          templateFunc = Marionette.TemplateCache.get(template);
        }

        return templateFunc(data);
      }
    };


    /* jshint maxlen: 114, nonew: false */
    // Marionette.View
    // ---------------

    // The core view class that other Marionette views extend from.
    Marionette.View = Backbone.View.extend({

      constructor: function(options) {
        _.bindAll(this, 'render');

        // this exposes view options to the view initializer
        // this is a backfill since backbone removed the assignment
        // of this.options
        // at some point however this may be removed
        this.options = _.extend({}, _.result(this, 'options'), _.isFunction(options) ? options.call(this) : options);
        // parses out the @ui DSL for events
        this.events = this.normalizeUIKeys(_.result(this, 'events'));

        if (_.isObject(this.behaviors)) {
          new Marionette.Behaviors(this);
        }

        Backbone.View.apply(this, arguments);

        Marionette.MonitorDOMRefresh(this);
        this.listenTo(this, 'show', this.onShowCalled);
      },

      // Get the template for this view
      // instance. You can set a `template` attribute in the view
      // definition or pass a `template: "whatever"` parameter in
      // to the constructor options.
      getTemplate: function() {
        return this.getOption('template');
      },

      // Serialize a model by returning its attributes. Clones
      // the attributes to allow modification.
      serializeModel: function(model){
        return model.toJSON.apply(model, slice.call(arguments, 1));
      },

      // Mix in template helper methods. Looks for a
      // `templateHelpers` attribute, which can either be an
      // object literal, or a function that returns an object
      // literal. All methods and attributes from this object
      // are copies to the object passed in.
      mixinTemplateHelpers: function(target) {
        target = target || {};
        var templateHelpers = this.getOption('templateHelpers');
        if (_.isFunction(templateHelpers)) {
          templateHelpers = templateHelpers.call(this);
        }
        return _.extend(target, templateHelpers);
      },


      normalizeUIKeys: function(hash) {
        var ui = _.result(this, 'ui');
        var uiBindings = _.result(this, '_uiBindings');
        return Marionette.normalizeUIKeys(hash, uiBindings || ui);
      },

      // Configure `triggers` to forward DOM events to view
      // events. `triggers: {"click .foo": "do:foo"}`
      configureTriggers: function() {
        if (!this.triggers) { return; }

        var triggerEvents = {};

        // Allow `triggers` to be configured as a function
        var triggers = this.normalizeUIKeys(_.result(this, 'triggers'));

        // Configure the triggers, prevent default
        // action and stop propagation of DOM events
        _.each(triggers, function(value, key) {

          var hasOptions = _.isObject(value);
          var eventName = hasOptions ? value.event : value;

          // build the event handler function for the DOM event
          triggerEvents[key] = function(e) {

            // stop the event in its tracks
            if (e) {
              var prevent = e.preventDefault;
              var stop = e.stopPropagation;

              var shouldPrevent = hasOptions ? value.preventDefault : prevent;
              var shouldStop = hasOptions ? value.stopPropagation : stop;

              if (shouldPrevent && prevent) { prevent.apply(e); }
              if (shouldStop && stop) { stop.apply(e); }
            }

            // build the args for the event
            var args = {
              view: this,
              model: this.model,
              collection: this.collection
            };

            // trigger the event
            this.triggerMethod(eventName, args);
          };

        }, this);

        return triggerEvents;
      },

      // Overriding Backbone.View's delegateEvents to handle
      // the `triggers`, `modelEvents`, and `collectionEvents` configuration
      delegateEvents: function(events) {
        this._delegateDOMEvents(events);
        this.bindEntityEvents(this.model, this.getOption('modelEvents'));
        this.bindEntityEvents(this.collection, this.getOption('collectionEvents'));
        return this;
      },

      // internal method to delegate DOM events and triggers
      _delegateDOMEvents: function(events) {
        events = events || this.events;
        if (_.isFunction(events)) { events = events.call(this); }

        // normalize ui keys
        events = this.normalizeUIKeys(events);

        var combinedEvents = {};

        // look up if this view has behavior events
        var behaviorEvents = _.result(this, 'behaviorEvents') || {};
        var triggers = this.configureTriggers();

        // behavior events will be overriden by view events and or triggers
        _.extend(combinedEvents, behaviorEvents, events, triggers);

        Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
      },

      // Overriding Backbone.View's undelegateEvents to handle unbinding
      // the `triggers`, `modelEvents`, and `collectionEvents` config
      undelegateEvents: function() {
        var args = slice.call(arguments);
        Backbone.View.prototype.undelegateEvents.apply(this, args);
        this.unbindEntityEvents(this.model, this.getOption('modelEvents'));
        this.unbindEntityEvents(this.collection, this.getOption('collectionEvents'));
        return this;
      },

      // Internal method, handles the `show` event.
      onShowCalled: function() {},

      // Internal helper method to verify whether the view hasn't been destroyed
      _ensureViewIsIntact: function() {
        if (this.isDestroyed) {
          var err = new Error('Cannot use a view thats already been destroyed.');
          err.name = 'ViewDestroyedError';
          throw err;
        }
      },

      // Default `destroy` implementation, for removing a view from the
      // DOM and unbinding it. Regions will call this method
      // for you. You can specify an `onDestroy` method in your view to
      // add custom code that is called after the view is destroyed.
      destroy: function() {
        if (this.isDestroyed) { return; }

        var args = slice.call(arguments);

        this.triggerMethod.apply(this, ['before:destroy'].concat(args));

        // mark as destroyed before doing the actual destroy, to
        // prevent infinite loops within "destroy" event handlers
        // that are trying to destroy other views
        this.isDestroyed = true;
        this.triggerMethod.apply(this, ['destroy'].concat(args));

        // unbind UI elements
        this.unbindUIElements();

        // remove the view from the DOM
        this.remove();
        return this;
      },

      // This method binds the elements specified in the "ui" hash inside the view's code with
      // the associated jQuery selectors.
      bindUIElements: function() {
        if (!this.ui) { return; }

        // store the ui hash in _uiBindings so they can be reset later
        // and so re-rendering the view will be able to find the bindings
        if (!this._uiBindings) {
          this._uiBindings = this.ui;
        }

        // get the bindings result, as a function or otherwise
        var bindings = _.result(this, '_uiBindings');

        // empty the ui so we don't have anything to start with
        this.ui = {};

        // bind each of the selectors
        _.each(_.keys(bindings), function(key) {
          var selector = bindings[key];
          this.ui[key] = this.$(selector);
        }, this);
      },

      // This method unbinds the elements specified in the "ui" hash
      unbindUIElements: function() {
        if (!this.ui || !this._uiBindings) { return; }

        // delete all of the existing ui bindings
        _.each(this.ui, function($el, name) {
          delete this.ui[name];
        }, this);

        // reset the ui element to the original bindings configuration
        this.ui = this._uiBindings;
        delete this._uiBindings;
      },

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod,

      // Imports the "normalizeMethods" to transform hashes of
      // events=>function references/names to a hash of events=>function references
      normalizeMethods: Marionette.normalizeMethods,

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption,

      // Proxy `unbindEntityEvents` to enable binding view's events from another entity.
      bindEntityEvents: Marionette.proxyBindEntityEvents,

      // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
      unbindEntityEvents: Marionette.proxyUnbindEntityEvents
    });

    // Item View
    // ---------

    // A single item view implementation that contains code for rendering
    // with underscore.js templates, serializing the view's model or collection,
    // and calling several methods on extended views, such as `onRender`.
    Marionette.ItemView = Marionette.View.extend({

      // Setting up the inheritance chain which allows changes to
      // Marionette.View.prototype.constructor which allows overriding
      constructor: function() {
        Marionette.View.apply(this, arguments);
      },

      // Serialize the model or collection for the view. If a model is
      // found, the view's `serializeModel` is called. If a collection is found,
      // each model in the collection is serialized by calling
      // the view's `serializeCollection` and put into an `items` array in
      // the resulting data. If both are found, defaults to the model.
      // You can override the `serializeData` method in your own view definition,
      // to provide custom serialization for your view's data.
      serializeData: function(){
        var data = {};

        if (this.model) {
          data = _.partial(this.serializeModel, this.model).apply(this, arguments);
        }
        else if (this.collection) {
          data = { items: _.partial(this.serializeCollection, this.collection).apply(this, arguments) };
        }

        return data;
      },

      // Serialize a collection by serializing each of its models.
      serializeCollection: function(collection){
        return collection.toJSON.apply(collection, slice.call(arguments, 1));
      },

      // Render the view, defaulting to underscore.js templates.
      // You can override this in your view definition to provide
      // a very specific rendering for your view. In general, though,
      // you should override the `Marionette.Renderer` object to
      // change how Marionette renders views.
      render: function() {
        this._ensureViewIsIntact();

        this.triggerMethod('before:render', this);

        this._renderTemplate();
        this.bindUIElements();

        this.triggerMethod('render', this);

        return this;
      },

      // Internal method to render the template with the serialized data
      // and template helpers via the `Marionette.Renderer` object.
      // Throws an `UndefinedTemplateError` error if the template is
      // any falsely value but literal `false`.
      _renderTemplate: function() {
        var template = this.getTemplate();

        // Allow template-less item views
        if (template === false) {
          return;
        }

        if (!template) {
          throwError('Cannot render the template since it is null or undefined.',
            'UndefinedTemplateError');
        }

        // Add in entity data and template helpers
        var data = this.serializeData();
        data = this.mixinTemplateHelpers(data);

        // Render and add to el
        var html = Marionette.Renderer.render(template, data, this);
        this.attachElContent(html);

        return this;
      },

      // Attaches the content of a given view.
      // This method can be overriden to optimize rendering,
      // or to render in a non standard way.
      //
      // For example, using `innerHTML` instead of `$el.html`
      //
      // ```js
      // attachElContent: function(html) {
      //   this.el.innerHTML = html;
      //   return this;
      // }
      // ```
      attachElContent: function(html) {
        this.$el.html(html);

        return this;
      },

      // Override the default destroy event to add a few
      // more events that are triggered.
      destroy: function() {
        if (this.isDestroyed) { return; }

        return Marionette.View.prototype.destroy.apply(this, arguments);
      }
    });

    /* jshint maxstatements: 14 */

    // Collection View
    // ---------------

    // A view that iterates over a Backbone.Collection
    // and renders an individual child view for each model.
    Marionette.CollectionView = Marionette.View.extend({

      // used as the prefix for child view events
      // that are forwarded through the collectionview
      childViewEventPrefix: 'childview',

      // constructor
      // option to pass `{sort: false}` to prevent the `CollectionView` from
      // maintaining the sorted order of the collection.
      // This will fallback onto appending childView's to the end.
      constructor: function(options){
        var initOptions = options || {};
        this.sort = _.isUndefined(initOptions.sort) ? true : initOptions.sort;

        this._initChildViewStorage();

        Marionette.View.apply(this, arguments);

        this._initialEvents();
        this.initRenderBuffer();
      },

      // Instead of inserting elements one by one into the page,
      // it's much more performant to insert elements into a document
      // fragment and then insert that document fragment into the page
      initRenderBuffer: function() {
        this.elBuffer = document.createDocumentFragment();
        this._bufferedChildren = [];
      },

      startBuffering: function() {
        this.initRenderBuffer();
        this.isBuffering = true;
      },

      endBuffering: function() {
        this.isBuffering = false;
        this._triggerBeforeShowBufferedChildren();
        this.attachBuffer(this, this.elBuffer);
        this._triggerShowBufferedChildren();
        this.initRenderBuffer();
      },

      _triggerBeforeShowBufferedChildren: function() {
        if (this._isShown) {
          _.invoke(this._bufferedChildren, 'triggerMethod', 'before:show');
        }
      },

      _triggerShowBufferedChildren: function() {
        if (this._isShown) {
          _.each(this._bufferedChildren, function (child) {
            if (_.isFunction(child.triggerMethod)) {
              child.triggerMethod('show');
            } else {
              Marionette.triggerMethod.call(child, 'show');
            }
          });
          this._bufferedChildren = [];
        }
      },

      // Configured the initial events that the collection view
      // binds to.
      _initialEvents: function() {
        if (this.collection) {
          this.listenTo(this.collection, 'add', this._onCollectionAdd);
          this.listenTo(this.collection, 'remove', this._onCollectionRemove);
          this.listenTo(this.collection, 'reset', this.render);

          if (this.sort) {
            this.listenTo(this.collection, 'sort', this._sortViews);
          }
        }
      },

      // Handle a child added to the collection
      _onCollectionAdd: function(child) {
        this.destroyEmptyView();
        var ChildView = this.getChildView(child);
        var index = this.collection.indexOf(child);
        this.addChild(child, ChildView, index);
      },

      // get the child view by model it holds, and remove it
      _onCollectionRemove: function(model) {
        var view = this.children.findByModel(model);
        this.removeChildView(view);
        this.checkEmpty();
      },

      // Override from `Marionette.View` to trigger show on child views
      onShowCalled: function(){
        this.children.each(function(child){
          if (_.isFunction(child.triggerMethod)) {
            child.triggerMethod('show');
          } else {
            Marionette.triggerMethod.call(child, 'show');
          }
        });
      },

      // Render children views. Override this method to
      // provide your own implementation of a render function for
      // the collection view.
      render: function() {
        this._ensureViewIsIntact();
        this.triggerMethod('before:render', this);
        this._renderChildren();
        this.triggerMethod('render', this);
        return this;
      },

      // Render view after sorting. Override this method to
      // change how the view renders after a `sort` on the collection.
      // An example of this would be to only `renderChildren` in a `CompositeView`
      // rather than the full view.
      resortView: function() {
        this.render();
      },

      // Internal method. This checks for any changes in the order of the collection.
      // If the index of any view doesn't match, it will render.
      _sortViews: function() {
        // check for any changes in sort order of views
        var orderChanged = this.collection.find(function(item, index){
          var view = this.children.findByModel(item);
          return !view || view._index !== index;
        }, this);

        if (orderChanged) {
          this.resortView();
        }
      },

      // Internal method. Separated so that CompositeView can have
      // more control over events being triggered, around the rendering
      // process
      _renderChildren: function() {
        this.destroyEmptyView();
        this.destroyChildren();

        if (this.isEmpty(this.collection)) {
          this.showEmptyView();
        } else {
          this.triggerMethod('before:render:collection', this);
          this.startBuffering();
          this.showCollection();
          this.endBuffering();
          this.triggerMethod('render:collection', this);
        }
      },

      // Internal method to loop through collection and show each child view.
      showCollection: function() {
        var ChildView;
        this.collection.each(function(child, index) {
          ChildView = this.getChildView(child);
          this.addChild(child, ChildView, index);
        }, this);
      },

      // Internal method to show an empty view in place of
      // a collection of child views, when the collection is empty
      showEmptyView: function() {
        var EmptyView = this.getEmptyView();

        if (EmptyView && !this._showingEmptyView) {
          this.triggerMethod('before:render:empty');

          this._showingEmptyView = true;
          var model = new Backbone.Model();
          this.addEmptyView(model, EmptyView);

          this.triggerMethod('render:empty');
        }
      },

      // Internal method to destroy an existing emptyView instance
      // if one exists. Called when a collection view has been
      // rendered empty, and then a child is added to the collection.
      destroyEmptyView: function() {
        if (this._showingEmptyView) {
          this.destroyChildren();
          delete this._showingEmptyView;
        }
      },

      // Retrieve the empty view class
      getEmptyView: function() {
        return this.getOption('emptyView');
      },

      // Render and show the emptyView. Similar to addChild method
      // but "child:added" events are not fired, and the event from
      // emptyView are not forwarded
      addEmptyView: function(child, EmptyView){

        // get the emptyViewOptions, falling back to childViewOptions
        var emptyViewOptions = this.getOption('emptyViewOptions') ||
                              this.getOption('childViewOptions');

        if (_.isFunction(emptyViewOptions)){
          emptyViewOptions = emptyViewOptions.call(this);
        }

        // build the empty view
        var view = this.buildChildView(child, EmptyView, emptyViewOptions);

        // trigger the 'before:show' event on `view` if the collection view
        // has already been shown
        if (this._isShown){
          this.triggerMethod.call(view, 'before:show');
        }

        // Store the `emptyView` like a `childView` so we can properly
        // remove and/or close it later
        this.children.add(view);

        // Render it and show it
        this.renderChildView(view, -1);

        // call the 'show' method if the collection view
        // has already been shown
        if (this._isShown){
          this.triggerMethod.call(view, 'show');
        }
      },

      // Retrieve the `childView` class, either from `this.options.childView`
      // or from the `childView` in the object definition. The "options"
      // takes precedence.
      // This method receives the model that will be passed to the instance
      // created from this `childView`. Overriding methods may use the child
      // to determine what `childView` class to return.
      getChildView: function(child) {
        var childView = this.getOption('childView');

        if (!childView) {
          throwError('A "childView" must be specified', 'NoChildViewError');
        }

        return childView;
      },

      // Render the child's view and add it to the
      // HTML for the collection view at a given index.
      // This will also update the indices of later views in the collection
      // in order to keep the children in sync with the collection.
      addChild: function(child, ChildView, index) {
        var childViewOptions = this.getOption('childViewOptions');
        if (_.isFunction(childViewOptions)) {
          childViewOptions = childViewOptions.call(this, child, index);
        }

        var view = this.buildChildView(child, ChildView, childViewOptions);

        // increment indices of views after this one
        this._updateIndices(view, true, index);

        this._addChildView(view, index);

        return view;
      },

      // Internal method. This decrements or increments the indices of views after the
      // added/removed view to keep in sync with the collection.
      _updateIndices: function(view, increment, index) {
        if (!this.sort) {
          return;
        }

        if (increment) {
          // assign the index to the view
          view._index = index;

          // increment the index of views after this one
          this.children.each(function (laterView) {
            if (laterView._index >= view._index) {
              laterView._index++;
            }
          });
        }
        else {
          // decrement the index of views after this one
          this.children.each(function (laterView) {
            if (laterView._index >= view._index) {
              laterView._index--;
            }
          });
        }
      },


      // Internal Method. Add the view to children and render it at
      // the given index.
      _addChildView: function(view, index) {
        // set up the child view event forwarding
        this.proxyChildEvents(view);

        this.triggerMethod('before:add:child', view);

        // Store the child view itself so we can properly
        // remove and/or destroy it later
        this.children.add(view);
        this.renderChildView(view, index);

        if (this._isShown && !this.isBuffering){
          if (_.isFunction(view.triggerMethod)) {
            view.triggerMethod('show');
          } else {
            Marionette.triggerMethod.call(view, 'show');
          }
        }

        this.triggerMethod('add:child', view);
      },

      // render the child view
      renderChildView: function(view, index) {
        view.render();
        this.attachHtml(this, view, index);
        return view;
      },

      // Build a `childView` for a model in the collection.
      buildChildView: function(child, ChildViewClass, childViewOptions) {
        var options = _.extend({model: child}, childViewOptions);
        return new ChildViewClass(options);
      },

      // Remove the child view and destroy it.
      // This function also updates the indices of
      // later views in the collection in order to keep
      // the children in sync with the collection.
      removeChildView: function(view) {

        if (view) {
          this.triggerMethod('before:remove:child', view);
          // call 'destroy' or 'remove', depending on which is found
          if (view.destroy) { view.destroy(); }
          else if (view.remove) { view.remove(); }

          this.stopListening(view);
          this.children.remove(view);
          this.triggerMethod('remove:child', view);

          // decrement the index of views after this one
          this._updateIndices(view, false);
        }

        return view;
      },

      // check if the collection is empty
      isEmpty: function(collection) {
        return !this.collection || this.collection.length === 0;
      },

      // If empty, show the empty view
      checkEmpty: function() {
        if (this.isEmpty(this.collection)) {
          this.showEmptyView();
        }
      },

      // You might need to override this if you've overridden attachHtml
      attachBuffer: function(collectionView, buffer) {
        collectionView.$el.append(buffer);
      },

      // Append the HTML to the collection's `el`.
      // Override this method to do something other
      // than `.append`.
      attachHtml: function(collectionView, childView, index) {
        if (collectionView.isBuffering) {
          // buffering happens on reset events and initial renders
          // in order to reduce the number of inserts into the
          // document, which are expensive.
          collectionView.elBuffer.appendChild(childView.el);
          collectionView._bufferedChildren.push(childView);
        }
        else {
          // If we've already rendered the main collection, append
          // the new child into the correct order if we need to. Otherwise
          // append to the end.
          if (!collectionView._insertBefore(childView, index)){
            collectionView._insertAfter(childView);
          }
        }
      },

      // Internal method. Check whether we need to insert the view into
      // the correct position.
      _insertBefore: function(childView, index) {
        var currentView;
        var findPosition = this.sort && (index < this.children.length - 1);
        if (findPosition) {
          // Find the view after this one
          currentView = this.children.find(function (view) {
            return view._index === index + 1;
          });
        }

        if (currentView) {
          currentView.$el.before(childView.el);
          return true;
        }

        return false;
      },

      // Internal method. Append a view to the end of the $el
      _insertAfter: function(childView) {
        this.$el.append(childView.el);
      },

      // Internal method to set up the `children` object for
      // storing all of the child views
      _initChildViewStorage: function() {
        this.children = new BackboneChildViewContainer();
      },

      // Handle cleanup and other destroying needs for the collection of views
      destroy: function() {
        if (this.isDestroyed) { return; }

        this.triggerMethod('before:destroy:collection');
        this.destroyChildren();
        this.triggerMethod('destroy:collection');

        return Marionette.View.prototype.destroy.apply(this, arguments);
      },

      // Destroy the child views that this collection view
      // is holding on to, if any
      destroyChildren: function() {
        var childViews = this.children.map(_.identity);
        this.children.each(this.removeChildView, this);
        this.checkEmpty();
        return childViews;
      },

      // Set up the child view event forwarding. Uses a "childview:"
      // prefix in front of all forwarded events.
      proxyChildEvents: function(view) {
        var prefix = this.getOption('childViewEventPrefix');

        // Forward all child view events through the parent,
        // prepending "childview:" to the event name
        this.listenTo(view, 'all', function() {
          var args = slice.call(arguments);
          var rootEvent = args[0];
          var childEvents = this.normalizeMethods(_.result(this, 'childEvents'));

          args[0] = prefix + ':' + rootEvent;
          args.splice(1, 0, view);

          // call collectionView childEvent if defined
          if (typeof childEvents !== 'undefined' && _.isFunction(childEvents[rootEvent])) {
            childEvents[rootEvent].apply(this, args.slice(1));
          }

          this.triggerMethod.apply(this, args);
        }, this);
      }
    });

    /* jshint maxstatements: 17, maxlen: 117 */

    // Composite View
    // --------------

    // Used for rendering a branch-leaf, hierarchical structure.
    // Extends directly from CollectionView and also renders an
    // a child view as `modelView`, for the top leaf
    Marionette.CompositeView = Marionette.CollectionView.extend({

      // Setting up the inheritance chain which allows changes to
      // Marionette.CollectionView.prototype.constructor which allows overriding
      // option to pass '{sort: false}' to prevent the CompositeView from
      // maintaining the sorted order of the collection.
      // This will fallback onto appending childView's to the end.
      constructor: function() {
        Marionette.CollectionView.apply(this, arguments);
      },

      // Configured the initial events that the composite view
      // binds to. Override this method to prevent the initial
      // events, or to add your own initial events.
      _initialEvents: function() {

        // Bind only after composite view is rendered to avoid adding child views
        // to nonexistent childViewContainer
        this.once('render', function() {
          if (this.collection) {
            this.listenTo(this.collection, 'add', this._onCollectionAdd);
            this.listenTo(this.collection, 'remove', this._onCollectionRemove);
            this.listenTo(this.collection, 'reset', this._renderChildren);

            if (this.sort) {
              this.listenTo(this.collection, 'sort', this._sortViews);
            }
          }
        });

      },

      // Retrieve the `childView` to be used when rendering each of
      // the items in the collection. The default is to return
      // `this.childView` or Marionette.CompositeView if no `childView`
      // has been defined
      getChildView: function(child) {
        var childView = this.getOption('childView') || this.constructor;

        if (!childView) {
          throwError('A "childView" must be specified', 'NoChildViewError');
        }

        return childView;
      },

      // Serialize the collection for the view.
      // You can override the `serializeData` method in your own view
      // definition, to provide custom serialization for your view's data.
      serializeData: function() {
        var data = {};

        if (this.model){
          data = _.partial(this.serializeModel, this.model).apply(this, arguments);
        }

        return data;
      },

      // Renders the model once, and the collection once. Calling
      // this again will tell the model's view to re-render itself
      // but the collection will not re-render.
      render: function() {
        this._ensureViewIsIntact();
        this.isRendered = true;
        this.resetChildViewContainer();

        this.triggerMethod('before:render', this);

        this._renderTemplate();
        this._renderChildren();

        this.triggerMethod('render', this);
        return this;
      },

      _renderChildren: function() {
        if (this.isRendered) {
          Marionette.CollectionView.prototype._renderChildren.call(this);
        }
      },

      // Render the root template that the children
      // views are appended to
      _renderTemplate: function() {
        var data = {};
        data = this.serializeData();
        data = this.mixinTemplateHelpers(data);

        this.triggerMethod('before:render:template');

        var template = this.getTemplate();
        var html = Marionette.Renderer.render(template, data, this);
        this.attachElContent(html);

        // the ui bindings is done here and not at the end of render since they
        // will not be available until after the model is rendered, but should be
        // available before the collection is rendered.
        this.bindUIElements();
        this.triggerMethod('render:template');
      },

      // Attaches the content of the root.
      // This method can be overriden to optimize rendering,
      // or to render in a non standard way.
      //
      // For example, using `innerHTML` instead of `$el.html`
      //
      // ```js
      // attachElContent: function(html) {
      //   this.el.innerHTML = html;
      //   return this;
      // }
      // ```
      attachElContent: function(html) {
        this.$el.html(html);

        return this;
      },

      // You might need to override this if you've overridden attachHtml
      attachBuffer: function(compositeView, buffer) {
        var $container = this.getChildViewContainer(compositeView);
        $container.append(buffer);
      },

      // Internal method. Append a view to the end of the $el.
      // Overidden from CollectionView to ensure view is appended to
      // childViewContainer
      _insertAfter: function (childView) {
        var $container = this.getChildViewContainer(this);
        $container.append(childView.el);
      },

      // Internal method to ensure an `$childViewContainer` exists, for the
      // `attachHtml` method to use.
      getChildViewContainer: function(containerView) {
        if ('$childViewContainer' in containerView) {
          return containerView.$childViewContainer;
        }

        var container;
        var childViewContainer = Marionette.getOption(containerView, 'childViewContainer');
        if (childViewContainer) {

          var selector = _.isFunction(childViewContainer) ? childViewContainer.call(containerView) : childViewContainer;

          if (selector.charAt(0) === '@' && containerView.ui) {
            container = containerView.ui[selector.substr(4)];
          } else {
            container = containerView.$(selector);
          }

          if (container.length <= 0) {
            throwError('The specified "childViewContainer" was not found: ' +
              containerView.childViewContainer, 'ChildViewContainerMissingError');
          }

        } else {
          container = containerView.$el;
        }

        containerView.$childViewContainer = container;
        return container;
      },

      // Internal method to reset the `$childViewContainer` on render
      resetChildViewContainer: function() {
        if (this.$childViewContainer) {
          delete this.$childViewContainer;
        }
      }
    });

    // LayoutView
    // ----------

    // Used for managing application layoutViews, nested layoutViews and
    // multiple regions within an application or sub-application.
    //
    // A specialized view class that renders an area of HTML and then
    // attaches `Region` instances to the specified `regions`.
    // Used for composite view management and sub-application areas.
    Marionette.LayoutView = Marionette.ItemView.extend({
      regionClass: Marionette.Region,

      // Ensure the regions are available when the `initialize` method
      // is called.
      constructor: function(options) {
        options = options || {};

        this._firstRender = true;
        this._initializeRegions(options);

        Marionette.ItemView.call(this, options);
      },

      // LayoutView's render will use the existing region objects the
      // first time it is called. Subsequent calls will destroy the
      // views that the regions are showing and then reset the `el`
      // for the regions to the newly rendered DOM elements.
      render: function() {
        this._ensureViewIsIntact();

        if (this._firstRender) {
          // if this is the first render, don't do anything to
          // reset the regions
          this._firstRender = false;
        } else {
          // If this is not the first render call, then we need to
          // re-initialize the `el` for each region
          this._reInitializeRegions();
        }

        return Marionette.ItemView.prototype.render.apply(this, arguments);
      },

      // Handle destroying regions, and then destroy the view itself.
      destroy: function() {
        if (this.isDestroyed) { return this; }

        this.regionManager.destroy();
        return Marionette.ItemView.prototype.destroy.apply(this, arguments);
      },

      // Add a single region, by name, to the layoutView
      addRegion: function(name, definition) {
        this.triggerMethod('before:region:add', name);
        var regions = {};
        regions[name] = definition;
        return this._buildRegions(regions)[name];
      },

      // Add multiple regions as a {name: definition, name2: def2} object literal
      addRegions: function(regions) {
        this.regions = _.extend({}, this.regions, regions);
        return this._buildRegions(regions);
      },

      // Remove a single region from the LayoutView, by name
      removeRegion: function(name) {
        this.triggerMethod('before:region:remove', name);
        delete this.regions[name];
        return this.regionManager.removeRegion(name);
      },

      // Provides alternative access to regions
      // Accepts the region name
      // getRegion('main')
      getRegion: function(region) {
        return this.regionManager.get(region);
      },

      // Get all regions
      getRegions: function(){
        return this.regionManager.getRegions();
      },

      // internal method to build regions
      _buildRegions: function(regions) {
        var that = this;

        var defaults = {
          regionClass: this.getOption('regionClass'),
          parentEl: function() { return that.$el; }
        };

        return this.regionManager.addRegions(regions, defaults);
      },

      // Internal method to initialize the regions that have been defined in a
      // `regions` attribute on this layoutView.
      _initializeRegions: function(options) {
        var regions;
        this._initRegionManager();

        if (_.isFunction(this.regions)) {
          regions = this.regions(options);
        } else {
          regions = this.regions || {};
        }

        // Enable users to define `regions` as instance options.
        var regionOptions = this.getOption.call(options, 'regions');

        // enable region options to be a function
        if (_.isFunction(regionOptions)) {
          regionOptions = regionOptions.call(this, options);
        }

        _.extend(regions, regionOptions);

        this.addRegions(regions);
      },

      // Internal method to re-initialize all of the regions by updating the `el` that
      // they point to
      _reInitializeRegions: function() {
        this.regionManager.emptyRegions();
        this.regionManager.each(function(region) {
          region.reset();
        });
      },

      // Enable easy overiding of the default `RegionManager`
      // for customized region interactions and buisness specific
      // view logic for better control over single regions.
      getRegionManager: function() {
        return new Marionette.RegionManager();
      },

      // Internal method to initialize the region manager
      // and all regions in it
      _initRegionManager: function() {
        this.regionManager = this.getRegionManager();

        this.listenTo(this.regionManager, 'before:add:region', function(name) {
          this.triggerMethod('before:add:region', name);
        });

        this.listenTo(this.regionManager, 'add:region', function(name, region) {
          this[name] = region;
          this.triggerMethod('add:region', name, region);
        });

        this.listenTo(this.regionManager, 'before:remove:region', function(name) {
          this.triggerMethod('before:remove:region', name);
        });

        this.listenTo(this.regionManager, 'remove:region', function(name, region) {
          delete this[name];
          this.triggerMethod('remove:region', name, region);
        });
      }
    });


    // Behavior
    // -----------

    // A Behavior is an isolated set of DOM /
    // user interactions that can be mixed into any View.
    // Behaviors allow you to blackbox View specific interactions
    // into portable logical chunks, keeping your views simple and your code DRY.

    Marionette.Behavior = (function(_, Backbone) {
      function Behavior(options, view) {
        // Setup reference to the view.
        // this comes in handle when a behavior
        // wants to directly talk up the chain
        // to the view.
        this.view = view;
        this.defaults = _.result(this, 'defaults') || {};
        this.options  = _.extend({}, this.defaults, options);

        // proxy behavior $ method to the view
        // this is useful for doing jquery DOM lookups
        // scoped to behaviors view.
        this.$ = function() {
          return this.view.$.apply(this.view, arguments);
        };

        // Call the initialize method passing
        // the arguments from the instance constructor
        this.initialize.apply(this, arguments);
      }

      _.extend(Behavior.prototype, Backbone.Events, {
        initialize: function() {},

        // stopListening to behavior `onListen` events.
        destroy: function() {
          this.stopListening();
        },

        // import the `triggerMethod` to trigger events with corresponding
        // methods if the method exists
        triggerMethod: Marionette.triggerMethod,

        // Proxy `getOption` to enable getting options from this or this.options by name.
        getOption: Marionette.proxyGetOption,

        // Proxy `unbindEntityEvents` to enable binding view's events from another entity.
        bindEntityEvents: Marionette.proxyBindEntityEvents,

        // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
        unbindEntityEvents: Marionette.proxyUnbindEntityEvents
      });

      // Borrow Backbones extend implementation
      // this allows us to setup a proper
      // inheritence pattern that follow in suite
      // with the rest of Marionette views.
      Behavior.extend = Marionette.extend;

      return Behavior;
    })(_, Backbone);

    /* jshint maxlen: 143, nonew: false */
    // Marionette.Behaviors
    // --------

    // Behaviors is a utility class that takes care of
    // glueing your behavior instances to their given View.
    // The most important part of this class is that you
    // **MUST** override the class level behaviorsLookup
    // method for things to work properly.

    Marionette.Behaviors = (function(Marionette, _) {

      function Behaviors(view, behaviors) {
        // Behaviors defined on a view can be a flat object literal
        // or it can be a function that returns an object.
        behaviors = Behaviors.parseBehaviors(view, behaviors || _.result(view, 'behaviors'));

        // Wraps several of the view's methods
        // calling the methods first on each behavior
        // and then eventually calling the method on the view.
        Behaviors.wrap(view, behaviors, _.keys(methods));
      }

      var methods = {
        setElement: function(setElement, behaviors) {
          setElement.apply(this, _.tail(arguments, 2));

          // proxy behavior $el to the view's $el.
          // This is needed because a view's $el proxy
          // is not set until after setElement is called.
          _.each(behaviors, function(b) {
            b.$el = this.$el;
            b.el = this.el;
          }, this);

          return this;
        },

        destroy: function(destroy, behaviors) {
          var args = _.tail(arguments, 2);
          destroy.apply(this, args);

          // Call destroy on each behavior after
          // destroying the view.
          // This unbinds event listeners
          // that behaviors have registerd for.
          _.invoke(behaviors, 'destroy', args);
          return this;
        },

        bindUIElements: function(bindUIElements, behaviors) {
          bindUIElements.apply(this);
          _.invoke(behaviors, bindUIElements);
        },

        unbindUIElements: function(unbindUIElements, behaviors) {
          unbindUIElements.apply(this);
          _.invoke(behaviors, unbindUIElements);
        },

        triggerMethod: function(triggerMethod, behaviors) {
          var args = _.tail(arguments, 2);
          triggerMethod.apply(this, args);

          _.each(behaviors, function(b) {
            triggerMethod.apply(b, args);
          });
        },

        delegateEvents: function(delegateEvents, behaviors) {
          var args = _.tail(arguments, 2);
          delegateEvents.apply(this, args);

          _.each(behaviors, function(b) {
            Marionette.bindEntityEvents(b, this.model, Marionette.getOption(b, 'modelEvents'));
            Marionette.bindEntityEvents(b, this.collection, Marionette.getOption(b, 'collectionEvents'));
          }, this);

          return this;
        },

        undelegateEvents: function(undelegateEvents, behaviors) {
          var args = _.tail(arguments, 2);
          undelegateEvents.apply(this, args);

          _.each(behaviors, function(b) {
            Marionette.unbindEntityEvents(b, this.model, Marionette.getOption(b, 'modelEvents'));
            Marionette.unbindEntityEvents(b, this.collection, Marionette.getOption(b, 'collectionEvents'));
          }, this);

          return this;
        },

        behaviorEvents: function(behaviorEvents, behaviors) {
          var _behaviorsEvents = {};
          var viewUI = _.result(this, 'ui');

          _.each(behaviors, function(b, i) {
            var _events = {};
            var behaviorEvents = _.clone(_.result(b, 'events')) || {};
            var behaviorUI = _.result(b, 'ui');

            // Construct an internal UI hash first using
            // the views UI hash and then the behaviors UI hash.
            // This allows the user to use UI hash elements
            // defined in the parent view as well as those
            // defined in the given behavior.
            var ui = _.extend({}, viewUI, behaviorUI);

            // Normalize behavior events hash to allow
            // a user to use the @ui. syntax.
            behaviorEvents = Marionette.normalizeUIKeys(behaviorEvents, ui);

            _.each(_.keys(behaviorEvents), function(key) {
              // Append white-space at the end of each key to prevent behavior key collisions.
              // This is relying on the fact that backbone events considers "click .foo" the same as
              // "click .foo ".

              // +2 is used because new Array(1) or 0 is "" and not " "
              var whitespace = (new Array(i + 2)).join(' ');
              var eventKey   = key + whitespace;
              var handler    = _.isFunction(behaviorEvents[key]) ? behaviorEvents[key] : b[behaviorEvents[key]];

              _events[eventKey] = _.bind(handler, b);
            });

            _behaviorsEvents = _.extend(_behaviorsEvents, _events);
          });

          return _behaviorsEvents;
        }
      };

      _.extend(Behaviors, {

        // Placeholder method to be extended by the user.
        // The method should define the object that stores the behaviors.
        // i.e.
        //
        // ```js
        // Marionette.Behaviors.behaviorsLookup: function() {
        //   return App.Behaviors
        // }
        // ```
        behaviorsLookup: function() {
          throw new Error('You must define where your behaviors are stored.' +
            'See https://github.com/marionettejs/backbone.marionette' +
            '/blob/master/docs/marionette.behaviors.md#behaviorslookup');
        },

        // Takes care of getting the behavior class
        // given options and a key.
        // If a user passes in options.behaviorClass
        // default to using that. Otherwise delegate
        // the lookup to the users `behaviorsLookup` implementation.
        getBehaviorClass: function(options, key) {
          if (options.behaviorClass) {
            return options.behaviorClass;
          }

          // Get behavior class can be either a flat object or a method
          return _.isFunction(Behaviors.behaviorsLookup) ? Behaviors.behaviorsLookup.apply(this, arguments)[key] : Behaviors.behaviorsLookup[key];
        },

        // Iterate over the behaviors object, for each behavior
        // instantiate it and get its grouped behaviors.
        parseBehaviors: function(view, behaviors) {
          return _.chain(behaviors).map(function(options, key) {
            var BehaviorClass = Behaviors.getBehaviorClass(options, key);

            var behavior = new BehaviorClass(options, view);
            var nestedBehaviors = Behaviors.parseBehaviors(view, _.result(behavior, 'behaviors'));

            return [behavior].concat(nestedBehaviors);
          }).flatten().value();
        },

        // Wrap view internal methods so that they delegate to behaviors. For example,
        // `onDestroy` should trigger destroy on all of the behaviors and then destroy itself.
        // i.e.
        //
        // `view.delegateEvents = _.partial(methods.delegateEvents, view.delegateEvents, behaviors);`
        wrap: function(view, behaviors, methodNames) {
          _.each(methodNames, function(methodName) {
            view[methodName] = _.partial(methods[methodName], view[methodName], behaviors);
          });
        }
      });

      return Behaviors;

    })(Marionette, _);


    // AppRouter
    // ---------

    // Reduce the boilerplate code of handling route events
    // and then calling a single method on another object.
    // Have your routers configured to call the method on
    // your object, directly.
    //
    // Configure an AppRouter with `appRoutes`.
    //
    // App routers can only take one `controller` object.
    // It is recommended that you divide your controller
    // objects in to smaller pieces of related functionality
    // and have multiple routers / controllers, instead of
    // just one giant router and controller.
    //
    // You can also add standard routes to an AppRouter.

    Marionette.AppRouter = Backbone.Router.extend({

      constructor: function(options) {
        Backbone.Router.apply(this, arguments);

        this.options = options || {};

        var appRoutes = this.getOption('appRoutes');
        var controller = this._getController();
        this.processAppRoutes(controller, appRoutes);
        this.on('route', this._processOnRoute, this);
      },

      // Similar to route method on a Backbone Router but
      // method is called on the controller
      appRoute: function(route, methodName) {
        var controller = this._getController();
        this._addAppRoute(controller, route, methodName);
      },

      // process the route event and trigger the onRoute
      // method call, if it exists
      _processOnRoute: function(routeName, routeArgs) {
        // find the path that matched
        var routePath = _.invert(this.getOption('appRoutes'))[routeName];

        // make sure an onRoute is there, and call it
        if (_.isFunction(this.onRoute)) {
          this.onRoute(routeName, routePath, routeArgs);
        }
      },

      // Internal method to process the `appRoutes` for the
      // router, and turn them in to routes that trigger the
      // specified method on the specified `controller`.
      processAppRoutes: function(controller, appRoutes) {
        if (!appRoutes) { return; }

        var routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes

        _.each(routeNames, function(route) {
          this._addAppRoute(controller, route, appRoutes[route]);
        }, this);
      },

      _getController: function() {
        return this.getOption('controller');
      },

      _addAppRoute: function(controller, route, methodName) {
        var method = controller[methodName];

        if (!method) {
          throwError('Method "' + methodName + '" was not found on the controller');
        }

        this.route(route, methodName, _.bind(method, controller));
      },

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption
    });

    // Application
    // -----------

    // Contain and manage the composite application as a whole.
    // Stores and starts up `Region` objects, includes an
    // event aggregator as `app.vent`
    Marionette.Application = function(options) {
      this._initializeRegions(options);
      this._initCallbacks = new Marionette.Callbacks();
      this.submodules = {};
      _.extend(this, options);
      this._initChannel();
    };

    _.extend(Marionette.Application.prototype, Backbone.Events, {
      // Command execution, facilitated by Backbone.Wreqr.Commands
      execute: function() {
        this.commands.execute.apply(this.commands, arguments);
      },

      // Request/response, facilitated by Backbone.Wreqr.RequestResponse
      request: function() {
        return this.reqres.request.apply(this.reqres, arguments);
      },

      // Add an initializer that is either run at when the `start`
      // method is called, or run immediately if added after `start`
      // has already been called.
      addInitializer: function(initializer) {
        this._initCallbacks.add(initializer);
      },

      // kick off all of the application's processes.
      // initializes all of the regions that have been added
      // to the app, and runs all of the initializer functions
      start: function(options) {
        this.triggerMethod('before:start', options);
        this._initCallbacks.run(options, this);
        this.triggerMethod('start', options);
      },

      // Add regions to your app.
      // Accepts a hash of named strings or Region objects
      // addRegions({something: "#someRegion"})
      // addRegions({something: Region.extend({el: "#someRegion"}) });
      addRegions: function(regions) {
        return this._regionManager.addRegions(regions);
      },

      // Empty all regions in the app, without removing them
      emptyRegions: function() {
        return this._regionManager.emptyRegions();
      },

      // Removes a region from your app, by name
      // Accepts the regions name
      // removeRegion('myRegion')
      removeRegion: function(region) {
        return this._regionManager.removeRegion(region);
      },

      // Provides alternative access to regions
      // Accepts the region name
      // getRegion('main')
      getRegion: function(region) {
        return this._regionManager.get(region);
      },

      // Get all the regions from the region manager
      getRegions: function(){
        return this._regionManager.getRegions();
      },

      // Create a module, attached to the application
      module: function(moduleNames, moduleDefinition) {

        // Overwrite the module class if the user specifies one
        var ModuleClass = Marionette.Module.getClass(moduleDefinition);

        // slice the args, and add this application object as the
        // first argument of the array
        var args = slice.call(arguments);
        args.unshift(this);

        // see the Marionette.Module object for more information
        return ModuleClass.create.apply(ModuleClass, args);
      },

      // Enable easy overriding of the default `RegionManager`
      // for customized region interactions and business-specific
      // view logic for better control over single regions.
      getRegionManager: function() {
        return new Marionette.RegionManager();
      },

      // Internal method to initialize the regions that have been defined in a
      // `regions` attribute on the application instance
      _initializeRegions: function(options) {
        var regions = _.isFunction(this.regions) ? this.regions(options) : this.regions || {};

        this._initRegionManager();

        // Enable users to define `regions` in instance options.
        var optionRegions = Marionette.getOption(options, 'regions');

        // Enable region options to be a function
        if (_.isFunction(optionRegions)) {
          optionRegions = optionRegions.call(this, options);
        }

        // Overwrite current regions with those passed in options
        _.extend(regions, optionRegions);

        this.addRegions(regions);

        return this;
      },

      // Internal method to set up the region manager
      _initRegionManager: function() {
        this._regionManager = this.getRegionManager();

        this.listenTo(this._regionManager, 'before:add:region', function(name) {
          this.triggerMethod('before:add:region', name);
        });

        this.listenTo(this._regionManager, 'add:region', function(name, region) {
          this[name] = region;
          this.triggerMethod('add:region', name, region);
        });

        this.listenTo(this._regionManager, 'before:remove:region', function(name) {
          this.triggerMethod('before:remove:region', name);
        });

        this.listenTo(this._regionManager, 'remove:region', function(name, region) {
          delete this[name];
          this.triggerMethod('remove:region', name, region);
        });
      },

      // Internal method to setup the Wreqr.radio channel
      _initChannel: function() {
        this.channelName = _.result(this, 'channelName') || 'global';
        this.channel = _.result(this, 'channel') || BackboneWreqr.radio.channel(this.channelName);
        this.vent = _.result(this, 'vent') || this.channel.vent;
        this.commands = _.result(this, 'commands') || this.channel.commands;
        this.reqres = _.result(this, 'reqres') || this.channel.reqres;
      },

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod,

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption
    });

    // Copy the `extend` function used by Backbone's classes
    Marionette.Application.extend = Marionette.extend;

    /* jshint maxparams: 9 */

    // Module
    // ------

    // A simple module system, used to create privacy and encapsulation in
    // Marionette applications
    Marionette.Module = function(moduleName, app, options) {
      this.moduleName = moduleName;
      this.options = _.extend({}, this.options, options);
      // Allow for a user to overide the initialize
      // for a given module instance.
      this.initialize = options.initialize || this.initialize;

      // Set up an internal store for sub-modules.
      this.submodules = {};

      this._setupInitializersAndFinalizers();

      // Set an internal reference to the app
      // within a module.
      this.app = app;

      // By default modules start with their parents.
      this.startWithParent = true;

      if (_.isFunction(this.initialize)) {
        this.initialize(moduleName, app, this.options);
      }
    };

    Marionette.Module.extend = Marionette.extend;

    // Extend the Module prototype with events / listenTo, so that the module
    // can be used as an event aggregator or pub/sub.
    _.extend(Marionette.Module.prototype, Backbone.Events, {

      // Initialize is an empty function by default. Override it with your own
      // initialization logic when extending Marionette.Module.
      initialize: function() {},

      // Initializer for a specific module. Initializers are run when the
      // module's `start` method is called.
      addInitializer: function(callback) {
        this._initializerCallbacks.add(callback);
      },

      // Finalizers are run when a module is stopped. They are used to teardown
      // and finalize any variables, references, events and other code that the
      // module had set up.
      addFinalizer: function(callback) {
        this._finalizerCallbacks.add(callback);
      },

      // Start the module, and run all of its initializers
      start: function(options) {
        // Prevent re-starting a module that is already started
        if (this._isInitialized) { return; }

        // start the sub-modules (depth-first hierarchy)
        _.each(this.submodules, function(mod) {
          // check to see if we should start the sub-module with this parent
          if (mod.startWithParent) {
            mod.start(options);
          }
        });

        // run the callbacks to "start" the current module
        this.triggerMethod('before:start', options);

        this._initializerCallbacks.run(options, this);
        this._isInitialized = true;

        this.triggerMethod('start', options);
      },

      // Stop this module by running its finalizers and then stop all of
      // the sub-modules for this module
      stop: function() {
        // if we are not initialized, don't bother finalizing
        if (!this._isInitialized) { return; }
        this._isInitialized = false;

        this.triggerMethod('before:stop');

        // stop the sub-modules; depth-first, to make sure the
        // sub-modules are stopped / finalized before parents
        _.each(this.submodules, function(mod) { mod.stop(); });

        // run the finalizers
        this._finalizerCallbacks.run(undefined, this);

        // reset the initializers and finalizers
        this._initializerCallbacks.reset();
        this._finalizerCallbacks.reset();

        this.triggerMethod('stop');
      },

      // Configure the module with a definition function and any custom args
      // that are to be passed in to the definition function
      addDefinition: function(moduleDefinition, customArgs) {
        this._runModuleDefinition(moduleDefinition, customArgs);
      },

      // Internal method: run the module definition function with the correct
      // arguments
      _runModuleDefinition: function(definition, customArgs) {
        // If there is no definition short circut the method.
        if (!definition) { return; }

        // build the correct list of arguments for the module definition
        var args = _.flatten([
          this,
          this.app,
          Backbone,
          Marionette,
          Backbone.$, _,
          customArgs
        ]);

        definition.apply(this, args);
      },

      // Internal method: set up new copies of initializers and finalizers.
      // Calling this method will wipe out all existing initializers and
      // finalizers.
      _setupInitializersAndFinalizers: function() {
        this._initializerCallbacks = new Marionette.Callbacks();
        this._finalizerCallbacks = new Marionette.Callbacks();
      },

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod
    });

    // Class methods to create modules
    _.extend(Marionette.Module, {

      // Create a module, hanging off the app parameter as the parent object.
      create: function(app, moduleNames, moduleDefinition) {
        var module = app;

        // get the custom args passed in after the module definition and
        // get rid of the module name and definition function
        var customArgs = slice.call(arguments);
        customArgs.splice(0, 3);

        // Split the module names and get the number of submodules.
        // i.e. an example module name of `Doge.Wow.Amaze` would
        // then have the potential for 3 module definitions.
        moduleNames = moduleNames.split('.');
        var length = moduleNames.length;

        // store the module definition for the last module in the chain
        var moduleDefinitions = [];
        moduleDefinitions[length - 1] = moduleDefinition;

        // Loop through all the parts of the module definition
        _.each(moduleNames, function(moduleName, i) {
          var parentModule = module;
          module = this._getModule(parentModule, moduleName, app, moduleDefinition);
          this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs);
        }, this);

        // Return the last module in the definition chain
        return module;
      },

      _getModule: function(parentModule, moduleName, app, def, args) {
        var options = _.extend({}, def);
        var ModuleClass = this.getClass(def);

        // Get an existing module of this name if we have one
        var module = parentModule[moduleName];

        if (!module) {
          // Create a new module if we don't have one
          module = new ModuleClass(moduleName, app, options);
          parentModule[moduleName] = module;
          // store the module on the parent
          parentModule.submodules[moduleName] = module;
        }

        return module;
      },

      // ## Module Classes
      //
      // Module classes can be used as an alternative to the define pattern.
      // The extend function of a Module is identical to the extend functions
      // on other Backbone and Marionette classes.
      // This allows module lifecyle events like `onStart` and `onStop` to be called directly.
      getClass: function(moduleDefinition) {
        var ModuleClass = Marionette.Module;

        if (!moduleDefinition) {
          return ModuleClass;
        }

        // If all of the module's functionality is defined inside its class,
        // then the class can be passed in directly. `MyApp.module("Foo", FooModule)`.
        if (moduleDefinition.prototype instanceof ModuleClass) {
          return moduleDefinition;
        }

        return moduleDefinition.moduleClass || ModuleClass;
      },

      // Add the module definition and add a startWithParent initializer function.
      // This is complicated because module definitions are heavily overloaded
      // and support an anonymous function, module class, or options object
      _addModuleDefinition: function(parentModule, module, def, args) {
        var fn = this._getDefine(def);
        var startWithParent = this._getStartWithParent(def, module);

        if (fn) {
          module.addDefinition(fn, args);
        }

        this._addStartWithParent(parentModule, module, startWithParent);
      },

      _getStartWithParent: function(def, module) {
        var swp;

        if (_.isFunction(def) && (def.prototype instanceof Marionette.Module)) {
          swp = module.constructor.prototype.startWithParent;
          return _.isUndefined(swp) ? true : swp;
        }

        if (_.isObject(def)) {
          swp = def.startWithParent;
          return _.isUndefined(swp) ? true : swp;
        }

        return true;
      },

      _getDefine: function(def) {
        if (_.isFunction(def) && !(def.prototype instanceof Marionette.Module)) {
          return def;
        }

        if (_.isObject(def)) {
          return def.define;
        }

        return null;
      },

      _addStartWithParent: function(parentModule, module, startWithParent) {
        module.startWithParent = module.startWithParent && startWithParent;

        if (!module.startWithParent || !!module.startWithParentIsConfigured) {
          return;
        }

        module.startWithParentIsConfigured = true;

        parentModule.addInitializer(function(options) {
          if (module.startWithParent) {
            module.start(options);
          }
        });
      }
    });


    return Marionette;
  }));

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:marionette', location = 'lib/backbone/marionette/backbone.marionette-amd.js' */
define('jira/view-issue-plugin/lib/marionette', [
    'backbone',
    'underscore',
    'atlassian/libs/factories/marionette-2.1.0'
], function defineMarionette(Backbone, _, MarionetteFactory) {
    return MarionetteFactory(_, Backbone);
});
;
;
/* module-key = 'jira.webresources:jquery-easing', location = '/includes/jquery/plugins/easing/jquery.easing.1.3.js' */
/*
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Uses the built in easing capabilities added In jQuery 1.1
 * to offer multiple easing options
 *
 * TERMS OF USE - jQuery Easing
 * 
 * Open source under the BSD License. 
 * 
 * Copyright © 2008 George McGinley Smith
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this list of 
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list 
 * of conditions and the following disclaimer in the documentation and/or other materials 
 * provided with the distribution.
 * 
 * Neither the name of the author nor the names of contributors may be used to endorse 
 * or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 *
*/

// t: current time, b: begInnIng value, c: change In value, d: duration
jQuery.easing['jswing'] = jQuery.easing['swing'];

jQuery.extend( jQuery.easing,
{
	def: 'easeOutQuad',
	swing: function (x, t, b, c, d) {
		//alert(jQuery.easing.default);
		return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158; 
		if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t < d/2) return jQuery.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return jQuery.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 * 
 * Open source under the BSD License. 
 * 
 * Copyright © 2001 Robert Penner
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this list of 
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list 
 * of conditions and the following disclaimer in the documentation and/or other materials 
 * provided with the distribution.
 * 
 * Neither the name of the author nor the names of contributors may be used to endorse 
 * or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 *
 */;
;
/* module-key = 'jira.webresources:jquery-fancybox', location = '/includes/jquery/plugins/fancybox/jquery.fancybox-1.3.4.js' */
/*
 * FancyBox - jQuery Plugin
 * Simple and fancy lightbox alternative
 *
 * Examples and documentation at: http://fancybox.net
 *
 * Copyright (c) 2008 - 2010 Janis Skarnelis
 * That said, it is hardly a one-person project. Many people have submitted bugs, code, and offered their advice freely. Their support is greatly appreciated.
 *
 * Version: 1.3.4 (11/11/2010)
 * Requires: jQuery v1.3+
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */

;(function($) {
	var tmp, loading, overlay, wrap, outer, content, close, title, nav_left, nav_right,

		selectedIndex = 0, selectedOpts = {}, selectedArray = [], currentIndex = 0, currentOpts = {}, currentArray = [],

		ajaxLoader = null, imgPreloader = new Image(), imgRegExp = /\.(jpg|gif|png|bmp|jpeg)(.*)?$/i, swfRegExp = /[^\.]\.(swf)\s*$/i,

		loadingTimer, loadingFrame = 1,

		titleHeight = 0, titleStr = '', start_pos, final_pos, busy = false, fx = $.extend($('<div/>')[0], { prop: 0 }),

		isIE6 = $.browser.msie && $.browser.version < 7 && !window.XMLHttpRequest,

		/*
		 * Private methods 
		 */

		_abort = function() {
			loading.hide();

			imgPreloader.onerror = imgPreloader.onload = null;

			if (ajaxLoader) {
				ajaxLoader.abort();
			}

			tmp.empty();
		},

		_error = function() {
			if (false === selectedOpts.onError(selectedArray, selectedIndex, selectedOpts)) {
				loading.hide();
				busy = false;
				return;
			}

			selectedOpts.titleShow = false;

			selectedOpts.width = 'auto';
			selectedOpts.height = 'auto';

			tmp.html( '<p id="fancybox-error">The requested content cannot be loaded.<br />Please try again later.</p>' );

			_process_inline();
		},

		_start = function() {
			var obj = selectedArray[ selectedIndex ],
				href, 
				type, 
				title,
				str,
				emb,
				ret;

			_abort();

			selectedOpts = $.extend({}, $.fn.fancybox.defaults, (typeof $(obj).data('fancybox') == 'undefined' ? selectedOpts : $(obj).data('fancybox')));

			ret = selectedOpts.onStart(selectedArray, selectedIndex, selectedOpts);

			if (ret === false) {
				busy = false;
				return;
			} else if (typeof ret == 'object') {
				selectedOpts = $.extend(selectedOpts, ret);
			}

			title = selectedOpts.title || (obj.nodeName ? $(obj).attr('title') : obj.title) || '';

			if (obj.nodeName && !selectedOpts.orig) {
				selectedOpts.orig = $(obj).children("img:first").length ? $(obj).children("img:first") : $(obj);
			}

			if (title === '' && selectedOpts.orig && selectedOpts.titleFromAlt) {
				title = selectedOpts.orig.attr('alt');
			}

			href = selectedOpts.href || (obj.nodeName ? $(obj).attr('href') : obj.href) || null;

			if ((/^(?:javascript)/i).test(href) || href == '#') {
				href = null;
			}

			if (selectedOpts.type) {
				type = selectedOpts.type;

				if (!href) {
					href = selectedOpts.content;
				}

			} else if (selectedOpts.content) {
				type = 'html';

			} else if (href) {
				if (href.match(imgRegExp)) {
					type = 'image';

				} else if (href.match(swfRegExp)) {
					type = 'swf';

				} else if ($(obj).hasClass("iframe")) {
					type = 'iframe';

				} else if (href.indexOf("#") === 0) {
					type = 'inline';

				} else {
					type = 'ajax';
				}
			}

			if (!type) {
				_error();
				return;
			}

			if (type == 'inline') {
				obj	= href.substr(href.indexOf("#"));
				type = $(obj).length > 0 ? 'inline' : 'ajax';
			}

			selectedOpts.type = type;
			selectedOpts.href = href;
			selectedOpts.title = title;

			if (selectedOpts.autoDimensions) {
				if (selectedOpts.type == 'html' || selectedOpts.type == 'inline' || selectedOpts.type == 'ajax') {
					selectedOpts.width = 'auto';
					selectedOpts.height = 'auto';
				} else {
					selectedOpts.autoDimensions = false;	
				}
			}

			if (selectedOpts.modal) {
				selectedOpts.overlayShow = true;
				selectedOpts.hideOnOverlayClick = false;
				selectedOpts.hideOnContentClick = false;
				selectedOpts.enableEscapeButton = false;
				selectedOpts.showCloseButton = false;
			}

			selectedOpts.padding = parseInt(selectedOpts.padding, 10);
			selectedOpts.margin = parseInt(selectedOpts.margin, 10);

			tmp.css('padding', (selectedOpts.padding + selectedOpts.margin));

			$('.fancybox-inline-tmp').unbind('fancybox-cancel').bind('fancybox-change', function() {
				$(this).replaceWith(content.children());				
			});

			switch (type) {
				case 'html' :
					tmp.html( selectedOpts.content );
					_process_inline();
				break;

				case 'inline' :
					if ( $(obj).parent().is('#fancybox-content') === true) {
						busy = false;
						return;
					}

					$('<div class="fancybox-inline-tmp" />')
						.hide()
						.insertBefore( $(obj) )
						.bind('fancybox-cleanup', function() {
							$(this).replaceWith(content.children());
						}).bind('fancybox-cancel', function() {
							$(this).replaceWith(tmp.children());
						});

					$(obj).appendTo(tmp);

					_process_inline();
				break;

				case 'image':
					busy = false;

					$.fancybox.showActivity();

					imgPreloader = new Image();

					imgPreloader.onerror = function() {
						_error();
					};

					imgPreloader.onload = function() {
						busy = true;

						imgPreloader.onerror = imgPreloader.onload = null;

						_process_image();
					};

					imgPreloader.src = href;
				break;

				case 'swf':
					selectedOpts.scrolling = 'no';

					str = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="' + selectedOpts.width + '" height="' + selectedOpts.height + '"><param name="movie" value="' + href + '"></param>';
					emb = '';

					$.each(selectedOpts.swf, function(name, val) {
						str += '<param name="' + name + '" value="' + val + '"></param>';
						emb += ' ' + name + '="' + val + '"';
					});

					str += '<embed src="' + href + '" type="application/x-shockwave-flash" width="' + selectedOpts.width + '" height="' + selectedOpts.height + '"' + emb + '></embed></object>';

					tmp.html(str);

					_process_inline();
				break;

				case 'ajax':
					busy = false;

					$.fancybox.showActivity();

					selectedOpts.ajax.win = selectedOpts.ajax.success;

					ajaxLoader = $.ajax($.extend({}, selectedOpts.ajax, {
						url	: href,
						data : selectedOpts.ajax.data || {},
						error : function(XMLHttpRequest, textStatus, errorThrown) {
							if ( XMLHttpRequest.status > 0 ) {
								_error();
							}
						},
						success : function(data, textStatus, XMLHttpRequest) {
							var o = typeof XMLHttpRequest == 'object' ? XMLHttpRequest : ajaxLoader;
							if (o.status == 200) {
								if ( typeof selectedOpts.ajax.win == 'function' ) {
									ret = selectedOpts.ajax.win(href, data, textStatus, XMLHttpRequest);

									if (ret === false) {
										loading.hide();
										return;
									} else if (typeof ret == 'string' || typeof ret == 'object') {
										data = ret;
									}
								}

								tmp.html( data );
								_process_inline();
							}
						}
					}));

				break;

				case 'iframe':
					_show();
				break;
			}
		},

		_process_inline = function() {
			var
				w = selectedOpts.width,
				h = selectedOpts.height;

			if (w.toString().indexOf('%') > -1) {
				w = parseInt( ($(window).width() - (selectedOpts.margin * 2)) * parseFloat(w) / 100, 10) + 'px';

			} else {
				w = w == 'auto' ? 'auto' : w + 'px';	
			}

			if (h.toString().indexOf('%') > -1) {
				h = parseInt( ($(window).height() - (selectedOpts.margin * 2)) * parseFloat(h) / 100, 10) + 'px';

			} else {
				h = h == 'auto' ? 'auto' : h + 'px';	
			}

			tmp.wrapInner('<div style="width:' + w + ';height:' + h + ';overflow: ' + (selectedOpts.scrolling == 'auto' ? 'auto' : (selectedOpts.scrolling == 'yes' ? 'scroll' : 'hidden')) + ';position:relative;"></div>');

			selectedOpts.width = tmp.width();
			selectedOpts.height = tmp.height();

			_show();
		},

		_process_image = function() {
			selectedOpts.width = imgPreloader.width;
			selectedOpts.height = imgPreloader.height;

			$("<img />").attr({
				'id' : 'fancybox-img',
				'src' : imgPreloader.src,
				'alt' : selectedOpts.title
			}).appendTo( tmp );

			_show();
		},

		_show = function() {
			var pos, equal;

			loading.hide();

			if (wrap.is(":visible") && false === currentOpts.onCleanup(currentArray, currentIndex, currentOpts)) {
				$.event.trigger('fancybox-cancel');

				busy = false;
				return;
			}

			busy = true;

			$(content.add( overlay )).unbind();

			$(window).unbind("resize.fb scroll.fb");
			$(document).unbind('keydown.fb');

			if (wrap.is(":visible") && currentOpts.titlePosition !== 'outside') {
				wrap.css('height', wrap.height());
			}

			currentArray = selectedArray;
			currentIndex = selectedIndex;
			currentOpts = selectedOpts;

			if (currentOpts.overlayShow) {
				overlay.css({
					'background-color' : currentOpts.overlayColor,
					'opacity' : currentOpts.overlayOpacity,
					'cursor' : currentOpts.hideOnOverlayClick ? 'pointer' : 'auto',
					'height' : $(document).height()
				});

				if (!overlay.is(':visible')) {
					if (isIE6) {
						$('select:not(#fancybox-tmp select)').filter(function() {
							return this.style.visibility !== 'hidden';
						}).css({'visibility' : 'hidden'}).one('fancybox-cleanup', function() {
							this.style.visibility = 'inherit';
						});
					}

					overlay.show();
				}
			} else {
				overlay.hide();
			}

			final_pos = _get_zoom_to();

			_process_title();

			if (wrap.is(":visible")) {
				$( close.add( nav_left ).add( nav_right ) ).hide();

				pos = wrap.position(),

				start_pos = {
					top	 : pos.top,
					left : pos.left,
					width : wrap.width(),
					height : wrap.height()
				};

				equal = (start_pos.width == final_pos.width && start_pos.height == final_pos.height);

				content.fadeTo(currentOpts.changeFade, 0.3, function() {
					var finish_resizing = function() {
						content.html( tmp.contents() ).fadeTo(currentOpts.changeFade, 1, _finish);
					};

					$.event.trigger('fancybox-change');

					content
						.empty()
						.removeAttr('filter')
						.css({
							'border-width' : currentOpts.padding,
							'width'	: final_pos.width - currentOpts.padding * 2,
							'height' : selectedOpts.autoDimensions ? 'auto' : final_pos.height - titleHeight - currentOpts.padding * 2
						});

					if (equal) {
						finish_resizing();

					} else {
						fx.prop = 0;

						$(fx).animate({prop: 1}, {
							 duration : currentOpts.changeSpeed,
							 easing : currentOpts.easingChange,
							 step : _draw,
							 complete : finish_resizing
						});
					}
				});

				return;
			}

			wrap.removeAttr("style");

			content.css('border-width', currentOpts.padding);

			if (currentOpts.transitionIn == 'elastic') {
				start_pos = _get_zoom_from();

				content.html( tmp.contents() );

				wrap.show();

				if (currentOpts.opacity) {
					final_pos.opacity = 0;
				}

				fx.prop = 0;

				$(fx).animate({prop: 1}, {
					 duration : currentOpts.speedIn,
					 easing : currentOpts.easingIn,
					 step : _draw,
					 complete : _finish
				});

				return;
			}

			if (currentOpts.titlePosition == 'inside' && titleHeight > 0) {	
				title.show();	
			}

			content
				.css({
					'width' : final_pos.width - currentOpts.padding * 2,
					'height' : selectedOpts.autoDimensions ? 'auto' : final_pos.height - titleHeight - currentOpts.padding * 2
				})
				.html( tmp.contents() );

			wrap
				.css(final_pos)
				.fadeIn( currentOpts.transitionIn == 'none' ? 0 : currentOpts.speedIn, _finish );
		},

		_format_title = function(title) {
			if (title && title.length) {
				if (currentOpts.titlePosition == 'float') {
					return '<table id="fancybox-title-float-wrap" cellpadding="0" cellspacing="0"><tr><td id="fancybox-title-float-left"></td><td id="fancybox-title-float-main">' + title + '</td><td id="fancybox-title-float-right"></td></tr></table>';
				}

				return '<div id="fancybox-title-' + currentOpts.titlePosition + '">' + title + '</div>';
			}

			return false;
		},

		_process_title = function() {
			titleStr = currentOpts.title || '';
			titleHeight = 0;

			title
				.empty()
				.removeAttr('style')
				.removeClass();

			if (currentOpts.titleShow === false) {
				title.hide();
				return;
			}

			titleStr = $.isFunction(currentOpts.titleFormat) ? currentOpts.titleFormat(titleStr, currentArray, currentIndex, currentOpts) : _format_title(titleStr);

			if (!titleStr || titleStr === '') {
				title.hide();
				return;
			}

			title
				.addClass('fancybox-title-' + currentOpts.titlePosition)
				.html( titleStr )
				.appendTo( 'body' )
				.show();

			switch (currentOpts.titlePosition) {
				case 'inside':
					title
						.css({
							'width' : final_pos.width - (currentOpts.padding * 2),
							'marginLeft' : currentOpts.padding,
							'marginRight' : currentOpts.padding
						});

					titleHeight = title.outerHeight(true);

					title.appendTo( outer );

					final_pos.height += titleHeight;
				break;

				case 'over':
					title
						.css({
							'marginLeft' : currentOpts.padding,
							'width'	: final_pos.width - (currentOpts.padding * 2),
							'bottom' : currentOpts.padding
						})
						.appendTo( outer );
				break;

				case 'float':
					title
						.css('left', parseInt((title.width() - final_pos.width - 40)/ 2, 10) * -1)
						.appendTo( wrap );
				break;

				default:
					title
						.css({
							'width' : final_pos.width - (currentOpts.padding * 2),
							'paddingLeft' : currentOpts.padding,
							'paddingRight' : currentOpts.padding
						})
						.appendTo( wrap );
				break;
			}

			title.hide();
		},

		_set_navigation = function() {
			if (currentOpts.enableEscapeButton || currentOpts.enableKeyboardNav) {
				$(document).bind('keydown.fb', function(e) {
					if (e.keyCode == 27 && currentOpts.enableEscapeButton) {
						e.preventDefault();
						$.fancybox.close();

					} else if ((e.keyCode == 37 || e.keyCode == 39) && currentOpts.enableKeyboardNav && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'SELECT') {
						e.preventDefault();
						$.fancybox[ e.keyCode == 37 ? 'prev' : 'next']();
					}
				});
			}

			if (!currentOpts.showNavArrows) { 
				nav_left.hide();
				nav_right.hide();
				return;
			}

			if ((currentOpts.cyclic && currentArray.length > 1) || currentIndex !== 0) {
				nav_left.show();
			}

			if ((currentOpts.cyclic && currentArray.length > 1) || currentIndex != (currentArray.length -1)) {
				nav_right.show();
			}
		},

		_finish = function () {
			if (!$.support.opacity) {
				content.get(0).style.removeAttribute('filter');
				wrap.get(0).style.removeAttribute('filter');
			}

			if (selectedOpts.autoDimensions) {
				content.css('height', 'auto');
			}

			wrap.css('height', 'auto');

			if (titleStr && titleStr.length) {
				title.show();
			}

			if (currentOpts.showCloseButton) {
				close.show();
			}

			_set_navigation();
	
			if (currentOpts.hideOnContentClick)	{
				content.bind('click', $.fancybox.close);
			}

			if (currentOpts.hideOnOverlayClick)	{
				overlay.bind('click', $.fancybox.close);
			}

			$(window).bind("resize.fb", $.fancybox.resize);

			if (currentOpts.centerOnScroll) {
				$(window).bind("scroll.fb", $.fancybox.center);
			}

			if (currentOpts.type == 'iframe') {
				$('<iframe id="fancybox-frame" name="fancybox-frame' + new Date().getTime() + '" frameborder="0" hspace="0" ' + ($.browser.msie ? 'allowtransparency="true""' : '') + ' scrolling="' + selectedOpts.scrolling + '" src="' + currentOpts.href + '"></iframe>').appendTo(content);
			}

			wrap.show();

			busy = false;

			$.fancybox.center();

			currentOpts.onComplete(currentArray, currentIndex, currentOpts);

			_preload_images();
		},

		_preload_images = function() {
			var href, 
				objNext;

			if ((currentArray.length -1) > currentIndex) {
				href = currentArray[ currentIndex + 1 ].href;

				if (typeof href !== 'undefined' && href.match(imgRegExp)) {
					objNext = new Image();
					objNext.src = href;
				}
			}

			if (currentIndex > 0) {
				href = currentArray[ currentIndex - 1 ].href;

				if (typeof href !== 'undefined' && href.match(imgRegExp)) {
					objNext = new Image();
					objNext.src = href;
				}
			}
		},

		_draw = function(pos) {
			var dim = {
				width : parseInt(start_pos.width + (final_pos.width - start_pos.width) * pos, 10),
				height : parseInt(start_pos.height + (final_pos.height - start_pos.height) * pos, 10),

				top : parseInt(start_pos.top + (final_pos.top - start_pos.top) * pos, 10),
				left : parseInt(start_pos.left + (final_pos.left - start_pos.left) * pos, 10)
			};

			if (typeof final_pos.opacity !== 'undefined') {
				dim.opacity = pos < 0.5 ? 0.5 : pos;
			}

			wrap.css(dim);

			content.css({
				'width' : dim.width - currentOpts.padding * 2,
				'height' : dim.height - (titleHeight * pos) - currentOpts.padding * 2
			});
		},

		_get_viewport = function() {
			return [
				$(window).width() - (currentOpts.margin * 2),
				$(window).height() - (currentOpts.margin * 2),
				$(document).scrollLeft() + currentOpts.margin,
				$(document).scrollTop() + currentOpts.margin
			];
		},

		_get_zoom_to = function () {
			var view = _get_viewport(),
				to = {},
				resize = currentOpts.autoScale,
				double_padding = currentOpts.padding * 2,
				ratio;

			if (currentOpts.width.toString().indexOf('%') > -1) {
				to.width = parseInt((view[0] * parseFloat(currentOpts.width)) / 100, 10);
			} else {
				to.width = currentOpts.width + double_padding;
			}

			if (currentOpts.height.toString().indexOf('%') > -1) {
				to.height = parseInt((view[1] * parseFloat(currentOpts.height)) / 100, 10);
			} else {
				to.height = currentOpts.height + double_padding;
			}

			if (resize && (to.width > view[0] || to.height > view[1])) {
				if (selectedOpts.type == 'image' || selectedOpts.type == 'swf') {
					ratio = (currentOpts.width ) / (currentOpts.height );

					if ((to.width ) > view[0]) {
						to.width = view[0];
						to.height = parseInt(((to.width - double_padding) / ratio) + double_padding, 10);
					}

					if ((to.height) > view[1]) {
						to.height = view[1];
						to.width = parseInt(((to.height - double_padding) * ratio) + double_padding, 10);
					}

				} else {
					to.width = Math.min(to.width, view[0]);
					to.height = Math.min(to.height, view[1]);
				}
			}

			to.top = parseInt(Math.max(view[3] - 20, view[3] + ((view[1] - to.height - 40) * 0.5)), 10);
			to.left = parseInt(Math.max(view[2] - 20, view[2] + ((view[0] - to.width - 40) * 0.5)), 10);

			return to;
		},

		_get_obj_pos = function(obj) {
			var pos = obj.offset();

			pos.top += parseInt( obj.css('paddingTop'), 10 ) || 0;
			pos.left += parseInt( obj.css('paddingLeft'), 10 ) || 0;

			pos.top += parseInt( obj.css('border-top-width'), 10 ) || 0;
			pos.left += parseInt( obj.css('border-left-width'), 10 ) || 0;

			pos.width = obj.width();
			pos.height = obj.height();

			return pos;
		},

		_get_zoom_from = function() {
			var orig = selectedOpts.orig ? $(selectedOpts.orig) : false,
				from = {},
				pos,
				view;

			if (orig && orig.length) {
				pos = _get_obj_pos(orig);

				from = {
					width : pos.width + (currentOpts.padding * 2),
					height : pos.height + (currentOpts.padding * 2),
					top	: pos.top - currentOpts.padding - 20,
					left : pos.left - currentOpts.padding - 20
				};

			} else {
				view = _get_viewport();

				from = {
					width : currentOpts.padding * 2,
					height : currentOpts.padding * 2,
					top	: parseInt(view[3] + view[1] * 0.5, 10),
					left : parseInt(view[2] + view[0] * 0.5, 10)
				};
			}

			return from;
		},

		_animate_loading = function() {
			if (!loading.is(':visible')){
				clearInterval(loadingTimer);
				return;
			}

			$('div', loading).css('top', (loadingFrame * -40) + 'px');

			loadingFrame = (loadingFrame + 1) % 12;
		};

	/*
	 * Public methods 
	 */

	$.fn.fancybox = function(options) {
		if (!$(this).length) {
			return this;
		}

		$(this)
			.data('fancybox', $.extend({}, options, ($.metadata ? $(this).metadata() : {})))
			.unbind('click.fb')
			.bind('click.fb', function(e) {
				e.preventDefault();

				if (busy) {
					return;
				}

				busy = true;

				$(this).blur();

				selectedArray = [];
				selectedIndex = 0;

				var rel = $(this).attr('rel') || '';

				if (!rel || rel == '' || rel === 'nofollow') {
					selectedArray.push(this);

				} else {
					selectedArray = $("a[rel=" + rel + "], area[rel=" + rel + "]");
					selectedIndex = selectedArray.index( this );
				}

				_start();

				return;
			});

		return this;
	};

	$.fancybox = function(obj) {
		var opts;

		if (busy) {
			return;
		}

		busy = true;
		opts = typeof arguments[1] !== 'undefined' ? arguments[1] : {};

		selectedArray = [];
		selectedIndex = parseInt(opts.index, 10) || 0;

		if ($.isArray(obj)) {
			for (var i = 0, j = obj.length; i < j; i++) {
				if (typeof obj[i] == 'object') {
					$(obj[i]).data('fancybox', $.extend({}, opts, obj[i]));
				} else {
					obj[i] = $({}).data('fancybox', $.extend({content : obj[i]}, opts));
				}
			}

			selectedArray = jQuery.merge(selectedArray, obj);

		} else {
			if (typeof obj == 'object') {
				$(obj).data('fancybox', $.extend({}, opts, obj));
			} else {
				obj = $({}).data('fancybox', $.extend({content : obj}, opts));
			}

			selectedArray.push(obj);
		}

		if (selectedIndex > selectedArray.length || selectedIndex < 0) {
			selectedIndex = 0;
		}

		_start();
	};

	$.fancybox.showActivity = function() {
		clearInterval(loadingTimer);

		loading.show();
		loadingTimer = setInterval(_animate_loading, 66);
	};

	$.fancybox.hideActivity = function() {
		loading.hide();
	};

	$.fancybox.next = function() {
		return $.fancybox.pos( currentIndex + 1);
	};

	$.fancybox.prev = function() {
		return $.fancybox.pos( currentIndex - 1);
	};

	$.fancybox.pos = function(pos) {
		if (busy) {
			return;
		}

		pos = parseInt(pos);

		selectedArray = currentArray;

		if (pos > -1 && pos < currentArray.length) {
			selectedIndex = pos;
			_start();

		} else if (currentOpts.cyclic && currentArray.length > 1) {
			selectedIndex = pos >= currentArray.length ? 0 : currentArray.length - 1;
			_start();
		}

		return;
	};

	$.fancybox.cancel = function() {
		if (busy) {
			return;
		}

		busy = true;

		$.event.trigger('fancybox-cancel');

		_abort();

		selectedOpts.onCancel(selectedArray, selectedIndex, selectedOpts);

		busy = false;
	};

	// Note: within an iframe use - parent.$.fancybox.close();
	$.fancybox.close = function() {
		if (busy || wrap.is(':hidden')) {
			return;
		}

		busy = true;

		if (currentOpts && false === currentOpts.onCleanup(currentArray, currentIndex, currentOpts)) {
			busy = false;
			return;
		}

		_abort();

		$(close.add( nav_left ).add( nav_right )).hide();

		$(content.add( overlay )).unbind();

		$(window).unbind("resize.fb scroll.fb");
		$(document).unbind('keydown.fb');

		content.find('iframe').attr('src', isIE6 && /^https/i.test(window.location.href || '') ? 'javascript:void(false)' : 'about:blank');

		if (currentOpts.titlePosition !== 'inside') {
			title.empty();
		}

		wrap.stop();

		function _cleanup() {
			overlay.fadeOut('fast');

			title.empty().hide();
			wrap.hide();

			$.event.trigger('fancybox-cleanup');

			content.empty();

			currentOpts.onClosed(currentArray, currentIndex, currentOpts);

			currentArray = selectedOpts	= [];
			currentIndex = selectedIndex = 0;
			currentOpts = selectedOpts	= {};

			busy = false;
		}

		if (currentOpts.transitionOut == 'elastic') {
			start_pos = _get_zoom_from();

			var pos = wrap.position();

			final_pos = {
				top	 : pos.top ,
				left : pos.left,
				width :	wrap.width(),
				height : wrap.height()
			};

			if (currentOpts.opacity) {
				final_pos.opacity = 1;
			}

			title.empty().hide();

			fx.prop = 1;

			$(fx).animate({ prop: 0 }, {
				 duration : currentOpts.speedOut,
				 easing : currentOpts.easingOut,
				 step : _draw,
				 complete : _cleanup
			});

		} else {
			wrap.fadeOut( currentOpts.transitionOut == 'none' ? 0 : currentOpts.speedOut, _cleanup);
		}
	};

	$.fancybox.resize = function() {
		if (overlay.is(':visible')) {
			overlay.css('height', $(document).height());
		}

		$.fancybox.center(true);
	};

	$.fancybox.center = function() {
		var view, align;

		if (busy) {
			return;	
		}

		align = arguments[0] === true ? 1 : 0;
		view = _get_viewport();

		if (!align && (wrap.width() > view[0] || wrap.height() > view[1])) {
			return;	
		}

		wrap
			.stop()
			.animate({
				'top' : parseInt(Math.max(view[3] - 20, view[3] + ((view[1] - content.height() - 40) * 0.5) - currentOpts.padding)),
				'left' : parseInt(Math.max(view[2] - 20, view[2] + ((view[0] - content.width() - 40) * 0.5) - currentOpts.padding))
			}, typeof arguments[0] == 'number' ? arguments[0] : 200);
	};

	$.fancybox.init = function() {
		if ($("#fancybox-wrap").length) {
			return;
		}

		$('body').append(
			tmp	= $('<div id="fancybox-tmp"></div>'),
			loading	= $('<div id="fancybox-loading"><div></div></div>'),
			overlay	= $('<div id="fancybox-overlay"></div>'),
			wrap = $('<div id="fancybox-wrap"></div>')
		);

		outer = $('<div id="fancybox-outer"></div>')
			.append('<div class="fancybox-bg" id="fancybox-bg-n"></div><div class="fancybox-bg" id="fancybox-bg-ne"></div><div class="fancybox-bg" id="fancybox-bg-e"></div><div class="fancybox-bg" id="fancybox-bg-se"></div><div class="fancybox-bg" id="fancybox-bg-s"></div><div class="fancybox-bg" id="fancybox-bg-sw"></div><div class="fancybox-bg" id="fancybox-bg-w"></div><div class="fancybox-bg" id="fancybox-bg-nw"></div>')
			.appendTo( wrap );

		outer.append(
			content = $('<div id="fancybox-content"></div>'),
			close = $('<a id="fancybox-close"></a>'),
			title = $('<div id="fancybox-title"></div>'),

			nav_left = $('<a href="javascript:;" id="fancybox-left"><span class="fancy-ico" id="fancybox-left-ico"></span></a>'),
			nav_right = $('<a href="javascript:;" id="fancybox-right"><span class="fancy-ico" id="fancybox-right-ico"></span></a>')
		);

		close.click($.fancybox.close);
		loading.click($.fancybox.cancel);

		nav_left.click(function(e) {
			e.preventDefault();
			$.fancybox.prev();
		});

		nav_right.click(function(e) {
			e.preventDefault();
			$.fancybox.next();
		});

		if ($.fn.mousewheel) {
			wrap.bind('mousewheel.fb', function(e, delta) {
				if (busy) {
					e.preventDefault();

				} else if ($(e.target).get(0).clientHeight == 0 || $(e.target).get(0).scrollHeight === $(e.target).get(0).clientHeight) {
					e.preventDefault();
					$.fancybox[ delta > 0 ? 'prev' : 'next']();
				}
			});
		}

		if (!$.support.opacity) {
			wrap.addClass('fancybox-ie');
		}

		if (isIE6) {
			loading.addClass('fancybox-ie6');
			wrap.addClass('fancybox-ie6');

			$('<iframe id="fancybox-hide-sel-frame" src="' + (/^https/i.test(window.location.href || '') ? 'javascript:void(false)' : 'about:blank' ) + '" scrolling="no" border="0" frameborder="0" tabindex="-1"></iframe>').prependTo(outer);
		}
	};

	$.fn.fancybox.defaults = {
		padding : 10,
		margin : 40,
		opacity : false,
		modal : false,
		cyclic : false,
		scrolling : 'auto',	// 'auto', 'yes' or 'no'

		width : 560,
		height : 340,

		autoScale : true,
		autoDimensions : true,
		centerOnScroll : false,

		ajax : {},
		swf : { wmode: 'transparent' },

		hideOnOverlayClick : true,
		hideOnContentClick : false,

		overlayShow : true,
		overlayOpacity : 0.7,
		overlayColor : '#777',

		titleShow : true,
		titlePosition : 'float', // 'float', 'outside', 'inside' or 'over'
		titleFormat : null,
		titleFromAlt : false,

		transitionIn : 'fade', // 'elastic', 'fade' or 'none'
		transitionOut : 'fade', // 'elastic', 'fade' or 'none'

		speedIn : 300,
		speedOut : 300,

		changeSpeed : 300,
		changeFade : 'fast',

		easingIn : 'swing',
		easingOut : 'swing',

		showCloseButton	 : true,
		showNavArrows : true,
		enableEscapeButton : true,
		enableKeyboardNav : true,

		onStart : function(){},
		onCancel : function(){},
		onComplete : function(){},
		onCleanup : function(){},
		onClosed : function(){},
		onError : function(){}
	};

	$(document).ready(function() {
		$.fancybox.init();
	});

})(jQuery);
;
;
/* module-key = 'jira.webresources:jquery-fancybox', location = '/includes/jquery/plugins/fancybox/jquery.fancybox.jira.js' */
AJS.$.fn.fancybox.defaults.titleFormat = function(title) {
    if (title && title.length) {
        title = AJS.escapeHtml(title);
        if (this.titlePosition == 'float') {
            return '<table id="fancybox-title-float-wrap" cellpadding="0" cellspacing="0"><tr><td id="fancybox-title-float-left"></td><td id="fancybox-title-float-main">' + title + '</td><td id="fancybox-title-float-right"></td></tr></table>';
        }
        return '<div id="fancybox-title-' + this.titlePosition + '">' + title + '</div>';
    }
};
;
;
/* module-key = 'jira.webresources:jquery-livestamp', location = '/includes/jquery/plugins/livestamp/time.js' */
/**
 * @note Mostly copied from Stash by skalsi on 10/01/14.
 * @module jira/jquery/plugins/livestamp/time
 */
define('jira/jquery/plugins/livestamp/time', [
    'jquery',
    'jira/moment',
    'jira/util/data/meta'
], function ($, moment, Meta) {

    'use strict';

    /** @exports jira/jquery/plugins/livestamp/time */
    var Time = {};

    function Type(str, isAge) {
        this.key = str;
        this.isAge = isAge;
    }

    var relativize = Meta.getBoolean("date-relativize");

    Type.types = {};

    for (var a = ['shortAge', 'longAge', 'fullAge', 'short', 'long', 'full', 'timestamp'], i = 0, l = a.length, t; i < l; i++) {
        t = a[i];
        Type.types[t] = new Type(t, t.toLowerCase().indexOf('age') !== -1);
    }

    var momentTranslations = {};
    Time.FormatType = Type;

    function getTextForRelativeAge(age, type, param) {
        // NOTE: AJS cannot be an AMD dependency as the minifier then changes the AJS.I18n.getText references
        // NOTE: and the transformer doesn't do any translation. IMO this is a webresources _bug_ (https://ecosystem.atlassian.net/browse/PLUGWEB-17).
        if (age in momentTranslations) {
            return AJS.format(momentTranslations[age], param);
        } else {
            return null;
        }
    }

    // TODO These should match http://developer-fe.stg.internal.atlassian.com/design/1.3/foundations/dates/
    // by default.
    function getFormatString(type) {
        switch (type.key) {
            case 'short':
            case 'shortAge':
                return 'll';
            case 'long':
            case 'longAge':
                return 'LL';
            case 'full':
            case 'fullAge':
                return 'LLL';
            case 'timestamp':
                return "LLL";
            default:
                return null;
        }
    }

    function beginningOfDay(time)
    {
        return time.clone().hours(0).minutes(0).seconds(0).milliseconds(0);
    }

    function isYesterday(now, date) {
        var end = beginningOfDay(now);
        var start = end.clone().subtract('d', 1);
        return start <= date && date < end;
    }

    function isTomorrow(now, date) {
        var start = beginningOfDay(now).add('d', 1);
        var end = start.clone().add('d', 1);
        return start <= date && date < end;
    }

    function getMinutesBetween(start, end) {
        return Math.floor(end.diff(start, 'minutes', true));
    }

    function getHoursBetween(start, end) {
        var hourDiff = end.diff(start, 'hours', true);  // Moment's diff does a floor rather than a round so we pass 'true' for a float value
        return Math.round(hourDiff);                    // Then round it ourself
    }

    function getDaysBetween(start, end) {
        return Math.floor(end.diff(start, 'days', true));
    }

    function formatDateWithFormatString(date, type) {
        var formatString = getFormatString(type);
        return date.format(formatString);
    }

    function formatDateWithRelativeAge(date, type, now) {
        now = now || moment();

        if (date <= now) {
            if (date > now.clone().subtract('m', 1)) {
                return getTextForRelativeAge('aMomentAgo', type);
            } else if (date > now.clone().subtract('m', 2)) {
                return getTextForRelativeAge('oneMinuteAgo', type);
            } else if (date > now.clone().subtract('m', 50)) {
                return getTextForRelativeAge('xMinutesAgo', type, getMinutesBetween(date, now));
            } else if (date > now.clone().subtract('m', 90)) {
                return getTextForRelativeAge('oneHourAgo', type);
            } else if (isYesterday(now, date) && date < now.clone().subtract('h', 5)) {
                return getTextForRelativeAge('oneDayAgo', type);
            } else if (date > now.clone().subtract('d', 1)) {
                return getTextForRelativeAge('xHoursAgo', type, getHoursBetween(date, now));
            } else if (date > now.clone().subtract('d', 7)) {
                return getTextForRelativeAge('xDaysAgo', type, Math.max(getDaysBetween(date, now), 2));// if it's not yesterday then don't say it's one day ago
            } else if (date > now.clone().subtract('d', 8)) {
                return getTextForRelativeAge('oneWeekAgo', type);
            }
        } else {
            if (date < now.clone().add('m', 1)) {
                return getTextForRelativeAge('inAMoment', type);
            } else if (date < now.clone().add('m', 2)) {
                return getTextForRelativeAge('inOneMinute', type);
            } else if (date < now.clone().add('m', 50)) {
                return getTextForRelativeAge('inXMinutes', type, getMinutesBetween(now, date));
            } else if (date < now.clone().add('m', 90)) {
                return getTextForRelativeAge('inOneHour', type);
            } else if (isTomorrow(now, date) && date > now.clone().add('h', 5)) {
                return getTextForRelativeAge('inOneDay', type);
            } else if (date < now.clone().add('d', 1)) {
                return getTextForRelativeAge('inXHours', type, getHoursBetween(now, date));
            } else if (date < now.clone().add('d', 7)) {
                return getTextForRelativeAge('inXDays', type, Math.max(getDaysBetween(now, date), 2));// if it's not yesterday then don't say it's one day ago
            } else if (date < now.clone().add('d', 8)) {
                return getTextForRelativeAge('inOneWeek', type);
            }
        }
        return formatDateWithFormatString(date, type);
    }

    Time.formatDate = function formatDate(momentDate, type, forceRelativize) {
        if (momentDate && type) {
            if ((relativize || forceRelativize) && type.isAge) {
                return formatDateWithRelativeAge(momentDate, type);
            } else {
                return formatDateWithFormatString(momentDate, type);
            }
        } else {
            return null;
        }
    };

    Time.setRelativeTranslations = function(values) {
        for (var k in values) {
            momentTranslations[k] = values[k];
        }
    };

    Time.restoreDefaultRelativeTranslations = function() {
        this.setRelativeTranslations({
            'inAMoment': "Now",
            'inOneMinute': "In 1 minute",
            'inXMinutes': "In {0} minutes",
            'inOneHour': "In 1 hour",
            'inXHours': "In {0} hours",
            'inOneDay': "Tomorrow",
            'inXDays': "In {0} days",
            'inOneWeek': "In 1 week",
            'aMomentAgo': "Just now",
            'oneMinuteAgo': "1 minute ago",
            'xMinutesAgo': "{0} minutes ago",
            'oneHourAgo': "1 hour ago",
            'xHoursAgo': "{0} hours ago",
            'oneDayAgo': "Yesterday",
            'xDaysAgo': "{0} days ago",
            'oneWeekAgo': "1 week ago"
        });
    };
    Time.restoreDefaultRelativeTranslations();

    Time.formatDateWithRelativeAge = formatDateWithRelativeAge;
    Time.formatDateWithFormatString = formatDateWithFormatString;

    return Time;
});

AJS.namespace('JIRA.Time', null, require('jira/jquery/plugins/livestamp/time'));
;
;
/* module-key = 'jira.webresources:jquery-livestamp', location = '/includes/jquery/plugins/livestamp/livestamp.js' */
define('jira/jquery/plugins/livestamp/livestamp', [
    'jquery',
    'jira/moment',
    'jira/util/data/meta',
    'jira/jquery/plugins/livestamp/time'
], function ($, moment, Meta, Time) {

    "use strict";

    var timeout,

        updateInterval = 6000,

        relativize = Meta.getBoolean("date-relativize"),

        livestamps = [],

        prep = function ($el, timestamp) {
            $el.data("livestampdata", timestamp);
            livestamps.push($el);
        },

        run = function () {
            clearTimeout(timeout);
            update();
            timeout = setTimeout(run, updateInterval);
        },

        update = function () {
            livestamps = $.grep(livestamps, function ($el) {
                var timestamp = $el.data("livestampdata"),
                    forceRelativize = $el.data('relativize'),
                    from,
                    to;
                if (!moment.isMoment(timestamp) || !$el.closest("html").length) {
                    $el.removeData("livestampdata");
                } else {
                    from = $el.text();
                    var tsFormat = $el.data("datetime-format");

                    tsFormat = tsFormat ? tsFormat : "fullAge"; // TODO We should transition to longAge.
                    if (!(relativize || forceRelativize)) {
                        // We should try not to have any tsFormats like 'AgeAge'
                        tsFormat = tsFormat.replace("Age", "");
                    }

                    to = Time.formatDate(timestamp, Time.FormatType.types[tsFormat], forceRelativize);

                    if (from !== to) {
                        $el.text(to);
                    }
                }
                return !!$el.data("livestampdata");
            });
        },

        add = function ($el) {
            $el.each(function () {
                var $this = $(this),
                    timestamp = $this.attr("datetime");
                if (timestamp) {
                    //reset the timezone to what's specified by the timestamp
                    var timestampMoment = isNaN(timestamp) ?
                        // assuming iso8601 timestamp, let moment#zone() handle it
                        moment(timestamp).zone(timestamp) :
                        // unix epoch timestamp (in milli-seconds)
                        moment(parseInt(timestamp, 10));
                    prep($this, timestampMoment);
                }
            });
            run();
            return $el;
        };

    $.fn.livestamp = function () {
        return add(this);
    };

    return add;
});

// Make extension available in global scope immediately / synchronously.
// TODO INC-71 - remove synchronous require
(function() {
    require('jira/jquery/plugins/livestamp/livestamp');
})();
;
;
/* module-key = 'com.atlassian.jira.jira-fileviewer-plugin:fileviewer', location = '/file-service.js' */
define('jira/fileviewer/file-service', [
    "featureflags/feature-manager",
    "jquery"
], function (
    featureManager,
    $
) {
    'use strict';

    var selectors = {
        image: [
            "a[file-preview-type=image]"
        ],
        document: []
    };

    if (!featureManager.isFeatureEnabled("jira.fileviewer.disable.pdf")) {
        selectors.document.push("a[file-preview-type=document]");
    }

    function getPreviewableFileSelector() {
        return Object.keys(selectors)
            .map(function(k) {
                return selectors[k].join(", ");
            })
            .join(", ");
    }

    function pushSingleOrArray(target, toPush) {
        if (Array.isArray(toPush)) {
            // we do not .concat as this would create a new array with a different reference
            target.push.apply(target, toPush);
        } else {
            target.push(toPush);
        }
    }

    return {
        findFiles: function findPreviewableFiles(context) {
            return $(context || document.body).find(getPreviewableFileSelector());
        },
        getFileSelector: getPreviewableFileSelector,

        getImageSelector: function getPreviewableImageSelector() {
            return selectors.image.join(", ");
        },
        addImageSelector: function addImageSelector(sel) {
            pushSingleOrArray(selectors.image, sel);
        },

        getDocumentSelector: function getPreviewableDocumentSelector() {
            return selectors.document.join(", ");
        },
        addDocumentSelector: function addDocumentSelector(sel) {
            pushSingleOrArray(selectors.document, sel);
        }
    };
});;
;
/* module-key = 'com.atlassian.jira.jira-fileviewer-plugin:fileviewer', location = '/fileviewer.js' */
define('jira/fileviewer', [
    "jira/fileviewer/file-service",
    "jira/loading/loading",
    "jira/ajs/keyboardshortcut/keyboard-shortcut-toggle",
    "jquery",
    "underscore"
], function (
    fileService,
    Loading,
    KeyboardShortcuts,
    $,
    _
) {
    'use strict';

    var viewerReady;
    var viewer;

    function getDownloadUrl($fileElement) {
        return $fileElement.data("download-url") || $fileElement.attr("href")
    }

    function initViewer() {
        if (!viewerReady) {
            viewerReady = WRM.require(['wr!com.atlassian.jira.jira-fileviewer-plugin:atlassian-fileviewer']);
            viewerReady
                .done(function () {
                    viewer = new FileViewer({
                        enableMiniMode: true,
                        viewers: ["image", "document"],
                        // we require these modules just now because they arrive with the fileviewer
                        moduleBackend: require("jira/fileviewer/module-backend/asynchronous"),
                        analyticsBackend: require("jira/fileviewer/module-backend/analytics")
                    });
                    viewer.on('fv.open', KeyboardShortcuts.disable);
                    viewer.on('fv.close', KeyboardShortcuts.enable);
                });
        }
        return viewerReady;
    }

    function closeViewer() {
        if (viewer) {
            viewer.close();
        }
    }

    function updateFiles() {
        var files = [];
        var imageSelector = fileService.getImageSelector();
        var documentSelector = fileService.getDocumentSelector();
        var $files = $(imageSelector + ", " + documentSelector);

        $files.each(function () {
            var $el = $(this).closest('a');
            if ($el.is(imageSelector)) {
                files.push({
                    type: 'image/png',
                    id: $el.attr("file-preview-id"),
                    src: getDownloadUrl($el),
                    title: $el.attr("file-preview-title"),
                    thumbnail: $el.attr("file-preview-url") || $el.attr("data-download-url") || $el.find("img").attr("src")
                });
            }
            if ($el.is(documentSelector)) {
                files.push({
                    type: 'application/pdf',
                    id: $el.attr("file-preview-id"),
                    src: getDownloadUrl($el),
                    title: $el.attr("file-preview-title")
                });
            }
        });

        var uniqFiles = _.uniq(files, false, function (el) {
            return el.id;
        });
        viewer.setFiles(uniqFiles);
        $files
            .off("simpleClick.fvOpen")
            .on("simpleClick.fvOpen",function(e) {
                e.preventDefault();
                viewer.open({
                    id: $(this).attr("file-preview-id")
                });
            });
    }

    function initializePreviews(searchContext) {
        if (!viewer) {
            var $files = fileService.findFiles(searchContext);
            $files
                .off("simpleClick.fvInit")
                .on("simpleClick.fvInit", function(e) {
                    e.preventDefault();
                    var $file = $(this);
                    Loading.showLoadingIndicator();
                    AJS.dim();
                    initViewer()
                        .done(function() {
                            updateFiles();
                            viewer.open({ id: $file.attr("file-preview-id") });
                        })
                        .fail(function() {
                            window.location = getDownloadUrl($file);
                        })
                        .always(function() {
                            $files.off("simpleClick.fvInit");
                            AJS.undim();
                            Loading.hideLoadingIndicator();
                        });
                });
        } else {
            updateFiles();
        }
    }

    return {
        attachToElements: initializePreviews,

        closeViewer: closeViewer,

        addImageSelector: function(sel) {
            fileService.addImageSelector(sel);
        },
        addDocumentSelector: function(sel) {
            fileService.addDocumentSelector(sel);
        }
    };
});;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/issuecomponents.soy' */
// This file was automatically generated from issuecomponents.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Issue.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Issue == 'undefined') { JIRA.Templates.Issue = {}; }


JIRA.Templates.Issue.watchersWithBrowse = function(opt_data, opt_ignored) {
  var output = '<form action="#" method="post" class="aui recipients-form"><a href="#" class="cancel" role="button"><span class="icon-default aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Close") + '</span></a><fieldset><label class="js-add-watchers-label">' + soy.$$escapeHtml("Add Watchers") + '</label><div class="autocomplete-user-target"><select id="watchers" name="watchers" data-description="' + soy.$$escapeHtml("Start Typing for Users") + '" class="watchers-user-picker hidden" multiple="multiple">';
  var watcherList10 = opt_data.watchers;
  var watcherListLen10 = watcherList10.length;
  for (var watcherIndex10 = 0; watcherIndex10 < watcherListLen10; watcherIndex10++) {
    var watcherData10 = watcherList10[watcherIndex10];
    output += '<option style="background-image:url(\'' + soy.$$escapeHtml(watcherData10.avatarUrls['16x16']) + '\')" selected="selected" value="' + soy.$$escapeHtml(watcherData10.name) + '">' + soy.$$escapeHtml(watcherData10.displayName) + '</option>';
  }
  output += '</select></div></fieldset></form>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Issue.watchersWithBrowse.soyTemplateName = 'JIRA.Templates.Issue.watchersWithBrowse';
}


JIRA.Templates.Issue.watchersNoBrowse = function(opt_data, opt_ignored) {
  var output = '<form action="#" method="post" class="aui recipients-form"><a href="#" class="cancel" role="button"><span class="icon-default aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Close") + '</span></a><fieldset><label for="watchers-multi-select">' + soy.$$escapeHtml("Add Watchers") + '</label><div><input type="text" class="text" id="watchers-nosearch" /><div class="description">' + soy.$$escapeHtml("Type username and press enter.") + '</div></div><div class="recipients"><ol class="watchers">';
  var watcherList28 = opt_data.watchers;
  var watcherListLen28 = watcherList28.length;
  for (var watcherIndex28 = 0; watcherIndex28 < watcherListLen28; watcherIndex28++) {
    var watcherData28 = watcherList28[watcherIndex28];
    output += JIRA.Templates.Fields.recipientUsername({username: watcherData28.name, icon: watcherData28.avatarUrls['16x16'], displayName: watcherData28.displayName, escape: true});
  }
  output += '</ol></div></fieldset></form>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Issue.watchersNoBrowse.soyTemplateName = 'JIRA.Templates.Issue.watchersNoBrowse';
}


JIRA.Templates.Issue.error = function(opt_data, opt_ignored) {
  var output = '<p>' + soy.$$escapeHtml(opt_data.msg) + '</p><ul>';
  var messageList40 = opt_data.errors;
  var messageListLen40 = messageList40.length;
  for (var messageIndex40 = 0; messageIndex40 < messageListLen40; messageIndex40++) {
    var messageData40 = messageList40[messageIndex40];
    output += '<li>' + soy.$$escapeHtml(messageData40) + '</li>';
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Issue.error.soyTemplateName = 'JIRA.Templates.Issue.error';
}


JIRA.Templates.Issue.usersListReadOnly = function(opt_data, opt_ignored) {
  var output = '<form class="aui recipients-form"><a href="#" class="cancel" role="button"><span class="icon-default aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Close") + '</span></a><fieldset><div class="recipients"><ol class="voters">';
  var voterList50 = opt_data.users;
  var voterListLen50 = voterList50.length;
  for (var voterIndex50 = 0; voterIndex50 < voterListLen50; voterIndex50++) {
    var voterData50 = voterList50[voterIndex50];
    output += JIRA.Templates.Fields.recipientUsername({username: voterData50.name, icon: voterData50.avatarUrls['16x16'], displayName: voterData50.displayName, readOnly: true, escape: true});
  }
  output += '</ol></div></fieldset></form>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Issue.usersListReadOnly.soyTemplateName = 'JIRA.Templates.Issue.usersListReadOnly';
}
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/entities/user-collection.js' */
define('jira/viewissue/watchers-voters/entities/user-collection', ['require'], function(require) {
    var Messages = require('jira/message');
    var Backbone = require('backbone');
    var _ = require('underscore');
    var $ = require('jquery');
    var contextPath = require('wrm/context-path');
    var TEMPLATES = JIRA.Templates.Issue;

    var JIRAUserModel = Backbone.Model.extend({
        idAttribute: "key"
    });

    return Backbone.Collection.extend({
        model: JIRAUserModel,

        initialize: function(options) {
            if(options === undefined) {
                throw new Error("Must supply options");
            }
            if(options.issueKey) {
                this.issueKey = options.issueKey;
            }else{
                throw new Error("Must supply issue key");
            }

            if(options.endpoint) {
                this.endpoint = options.endpoint;
            }else{
                throw new Error("Must supply an endpoint");
            }

            if(options.modelKey) {
                this.modelKey = options.modelKey;
            }else{
                throw new Error("Must supply an model key");
            }

        },

        url: function() {
            return [contextPath(), 'rest/api/2/issue', this.issueKey, this.endpoint].join("/");
        },

        parse: function(response) {
            return (response && response[this.modelKey]) ? response[this.modelKey]: [];
        },

        ajax:function(options) {
            options = _.extend({
                url: this.url(),
                headers: {"Content-Type": "application/json"},
                success: _.bind(function () {
                    this.fetch();
                }, this),
                error: _.bind(function (xhr) {
                    if (xhr.status !== 404) {
                        this.handleErrorResponse(xhr, "There was an error adding watcher");
                    }
                }, this)
            }, options);
            return $.ajax(options);
        },

        getUser: function (username) {
            return $.ajax({
                url: contextPath() + "/rest/api/2/user?username=" + encodeURIComponent(username),
                error:_.bind(function (xhr) {
                    if (xhr.status !== 404) {
                        this.handleErrorResponse(xhr, "There was an error adding watcher");
                    }
                }, this)
            });
        },

        handleErrorResponse: function (xhr, msg) {
            var errorCollection = this._parseResponse(xhr.responseText);
            if (errorCollection.errorMessages) {
                var html = TEMPLATES.error({
                    msg: msg,
                    errors: errorCollection.errorMessages
                });
                Messages.showErrorMsg(html, {
                    closeable: true
                });
            }
            this.trigger("errorOccurred");
        },

        _parseResponse: function(responseText) {
            try {
                return JSON.parse(responseText);
            } catch (e) {
                // parse JSON failed
                this._showFatalErrorMessage();
                return null;
            }
        },

        _showFatalErrorMessage: function() {
            // TODO: would be nice to extract this error from smartAjax and make it uniform in JIRA
            var msg = '<p>' + "Communications Breakdown" + '</p>' +
                '<p>' + "Close this dialog and press refresh in your browser" + '</p>';
            Messages.showErrorMsg(msg, {
                closeable: true
            });
        }
    });

});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/entities/voters-user-collection.js' */
define('jira/viewissue/watchers-voters/entities/voters-user-collection', [
    'jira/viewissue/watchers-voters/entities/user-collection'
], function(WatchersAndVoterUsers) {

    return WatchersAndVoterUsers.extend({
        initialize: function(issueKey) {
            // add options for the underlying Collection
            var options = { issueKey:issueKey, endpoint:"votes", modelKey:"voters" };
            // super initialize
            WatchersAndVoterUsers.prototype.initialize.apply(this, [options]);
        },

        vote: function() {
            return this.ajax({ type:"POST" });
        },

        unvote: function() {
            return this.ajax({ type:"DELETE" });
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/entities/watchers-user-collection.js' */
define('jira/viewissue/watchers-voters/entities/watchers-user-collection', [
    'jira/viewissue/watchers-voters/entities/user-collection',
    'jira/util/data/meta'
], function(WatchersAndVoterUsers, Meta) {

    return WatchersAndVoterUsers.extend({
        initialize: function(issueKey) {
            this.canBrowseUsers = Meta.get("can-search-users");
            this.isReadOnly = !Meta.get("can-edit-watchers");

            // add options for the underlying Collection
            var options = { issueKey:issueKey, endpoint:"watchers", modelKey:"watchers" };
            // super initialize
            WatchersAndVoterUsers.prototype.initialize.apply(this, [options]);
        },

        addWatcher: function(user) {
            return this.ajax({ type: "POST", data: '"' + user + '"' });
        },

        removeWatcher: function(user) {
            return this.ajax({ type: "DELETE", url: this.url() + "?username=" + user});
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/views/voters-view.js' */
define('jira/viewissue/watchers-voters/views/voters-view', ['require'], function(require) {
    var AuiMessages = require('aui/message');
    var Backbone = require('backbone');
    var _ = require('underscore');
    var jQuery = require('jquery');
    var TEMPLATES = JIRA.Templates.Issue;

    /**
     * View for Voters
     * @class VotersView
     * @extends Backbone.View
     */
    return Backbone.View.extend({
        $empty: undefined,

        initialize: function(options) {
            this.collection = options.collection;
            this.collection.bind("replace reset add remove", this.render, this);
        },

        renderNoWatchers: function () {
            if (this.$(".recipients li").length === 0) {
                this.$empty = AuiMessages.info({
                    closeable: false,
                    body: "There are no voters for this issue"
                });
                this.$("fieldset").append(this.$empty);
            } else if (this.$empty) {
                this.$empty.remove();
            }
        },

        /**
         * Goes to server to get watchers before rendering contents
         *
         * @return {jQuery.Deferred}
         */
        render: function () {
            var deferred = jQuery.Deferred();
            this.collection.fetch().done(_.bind(function () {
                this.$el.html(TEMPLATES.usersListReadOnly({ users: this.collection.toJSON() }));
                this.renderNoWatchers();
                deferred.resolve(this.$el);
            }, this));
            return deferred.promise();
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/views/abstract-watchers-view.js' */
define('jira/viewissue/watchers-voters/views/abstract-watchers-view', ['require'], function(require) {
    var AuiMessages = require('aui/message');
    var Backbone = require('backbone');
    var _ = require('underscore');
    var jQuery = require('jquery');

    /**
     * Views for watchers
     * @class AbstractWatchersView
     * @extends Backbone.View
     * @abstract
     */
    return Backbone.View.extend({
        $empty: undefined,

        renderNoWatchers: function () {
            if (this.$(".recipients li").length === 0) {
                this.$empty = AuiMessages.info({
                    closeable: false,
                    body: "There are no watchers."
                });
                this.$("fieldset").append(this.$empty);
            } else if (this.$empty) {
                this.$empty.remove();
            }
        },

        /**
         * Goes to server to get watchers before rendering contents
         *
         * @return {jQuery.Deferred}
         */
        render: function () {
            var deferred = jQuery.Deferred();
            this.collection.fetch().done(_.bind(function () {
                this._render();
                this.renderNoWatchers();
                deferred.resolve(this.$el);
                setTimeout(_.bind(function () {
                    this.focus();
                }, this), 0);
            }, this));
            return deferred.promise();
        },

        watch: function () {
            jQuery("#watching-toggle").text("Stop watching this issue");
        },

        unwatch: function () {
            jQuery("#watching-toggle").text("Start watching this issue");
        },

        /**
         * Focuses input field
         * @abstract
         * @function
         */
        focus: jQuery.noop,

        /**
         * Increments watcher count by 1
         * @private
         */
        _incrementWatcherCount: function () {
            var $el = jQuery("#watcher-data");
            var currentCount = parseInt($el.text(), 10);
            $el.text(currentCount + 1);
            this.renderNoWatchers();
        },

        /**
         * Decrements watcher count by 1
         * @private
         */
        _decrementWatcherCount: function () {
            var $el = jQuery("#watcher-data");
            var currentCount = parseInt($el.text(), 10);
            $el.text(currentCount - 1);
            this.renderNoWatchers();
        }
    });
});

;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/views/watchers-view.js' */
define('jira/viewissue/watchers-voters/views/watchers-view', ['require'], function(require) {
    var AbstractWatchersView = require('jira/viewissue/watchers-voters/views/abstract-watchers-view');
    var MultiUserListPicker = JIRA.MultiUserListPicker;
    var Meta = require('jira/util/data/meta');
    var _ = require('underscore');
    var TEMPLATES = JIRA.Templates.Issue;

    /**
     * View to handles internal content of inline dialog
     *
     * @class WatchersView
     * @extends AbstractWatchersView
     */
    return AbstractWatchersView.extend({

        events: {
            selected: "addWatcherToModel",
            unselect: "removeWatcherFromModel"
        },

        /**
         * Renders contents. Should only be called when watchers have been fetched.
         * @private
         */
        _render: function () {
            this.$el.html(TEMPLATES.watchersWithBrowse({ watchers: this.collection.toJSON() }));
            var picker = new MultiUserListPicker({
                element: this.$el.find(".watchers-user-picker"),
                width: 220
            });
            this.$el.find('.js-add-watchers-label').attr('for', picker.$field.attr('id'));
        },

        /**
         * @inheritdoc
         */
        focus: function () {
            this.$el.find("#watchers-textarea").focus();
        },

        /**
         * Adds watcher on server
         * @param e
         * @param descriptor
         */
        addWatcherToModel: function (e, descriptor) {
            e.preventDefault();
            this.collection.addWatcher(descriptor.value()).done(_.bind(function () {
                this._incrementWatcherCount();
                if (descriptor.value() === Meta.get("remote-user")) {
                    this.watch();
                }
            }, this));
        },

        /**
         * Removes watcher on server
         * @param e
         * @param descriptor
         */
        removeWatcherFromModel: function (e, descriptor) {
            this.collection.removeWatcher(descriptor.value()).done(_.bind(function () {
                this._decrementWatcherCount();
                if (descriptor.value() === Meta.get("remote-user")) {
                    this.unwatch();
                    JIRA.trace("jira.issue.watcher.deleted");
                }
            }, this));
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/views/watchers-no-browse-view.js' */
define('jira/viewissue/watchers-voters/views/watchers-no-browse-view', ['require'], function(require) {
    var AbstractWatchersView = require('jira/viewissue/watchers-voters/views/abstract-watchers-view');
    var Meta = require('jira/util/data/meta');
    var _ = require('underscore');
    var $ = require('jquery');
    var TEMPLATES = JIRA.Templates.Issue;

    /**
     * @class WatchersNoBrowseView
     * @extends AbstractWatchersView
     */
    return AbstractWatchersView.extend({

        events: {
            "click .remove-recipient" : "removeWatcher",
            "submit" : "addWatcher"
        },

        addWatcher: function (e) {
            e.preventDefault();
            this.removeInlineError();
            var $field = $("#watchers-nosearch");
            var username = $.trim($field.val());
            $field.attr("disabled", "disabled");
            if (this.hasUsername(username)) {
                $field.removeAttr("disabled");
                this.showInlineError(AJS.format("User {0} is already watching this issue", username));
                $field.val("");
            } else {
                this.collection.getUser(username).done(_.bind(function (data) {
                    var html = JIRA.Templates.Fields.recipientUsername({
                        icon: data.avatarUrls["16x16"],
                        username: data.name,
                        displayName: data.displayName
                    });
                    if (username === Meta.get("remote-user")) {
                        this.watch();
                    }
                    $field.val("");
                    this.$(".watchers").append(html);
                    this.collection.addWatcher(data.name);
                    this._incrementWatcherCount();
                }, this)).fail(_.bind(function (xhr) {
                    if (xhr.status === 404) {
                        this.showInlineError("User does not exist");
                    }
                }, this)).always(function () {
                    $field.removeAttr("disabled").focus();
                });
            }

        },

        hasUsername: function (username) {
            var result = false;
            this.$(".watchers li").each(function () {
                if ($(this).attr("data-username") === username) {
                    result = true;
                    return false;
                }
            });
            return result;
        },

        removeInlineError: function () {
            this.$(".error").remove();
        },

        showInlineError: function (msg) {
            $("<div />").addClass("error").text(msg).insertAfter(this.$(".description"));
        },

        focus: function () {
            $("#watchers-nosearch").focus();
        },

        removeWatcher: function (e) {
            e.preventDefault();
            var $item = $(e.target).closest("li");
            var username = $item.attr("data-username");
            if (username) {
                $item.remove();
                this.collection.removeWatcher(username);
                this._decrementWatcherCount();
                if (username === Meta.get("remote-user")) {
                    this.unwatch();
                }
            }
            JIRA.trace("jira.issue.watcher.deleted");
        },
        _render: function () {
            this.$el.html(TEMPLATES.watchersNoBrowse({ watchers: this.collection.toJSON() }));
        }
    });

});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/views/watchers-read-only-view.js' */
define('jira/viewissue/watchers-voters/views/watchers-read-only-view', ['require'], function(require) {
    var AbstractWatchersView = require('jira/viewissue/watchers-voters/views/abstract-watchers-view');
    var TEMPLATES = JIRA.Templates.Issue;

    /**
     * @class WatchersReadOnlyView
     * @extends AbstractWatchersView
     */
    return AbstractWatchersView.extend({
        _render: function () {
            this.$el.html(TEMPLATES.usersListReadOnly({ users: this.collection.toJSON() }));
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/views/watchers-inline-dialog-view.js' */
define('jira/viewissue/watchers-voters/views/watchers-inline-dialog-view', ['require'], function (require) {
    var InlineDialog = require('aui/inline-dialog');
    var InlineDialog2 = require('aui/inline-dialog2'); // Initialises our view dialog
    var Backbone = require('backbone');
    var skate = require('jira/skate');

    var _setElement = Backbone.View.prototype.setElement;

    /**
     * A wrapper layer to house an AUI Inline Dialog for the Watchers list.
     * Exists because inline dialogs are finicky things and their API changes
     * across multiple versions of AUI.
     */
    return Backbone.View.extend({
        tagName: 'aui-inline-dialog2',
        className: 'aui-layer aui-inline-dialog',

        events: {
            'click .cancel': function(e) {
                e.preventDefault();
                this.hide();
            }
        },

        setElement: function(val) {
            var el = (val instanceof Backbone.$) ? val.get(0) : val;
            if (!el) {
                return; // don't set an empty element.
            }
            if (this.el && this.el !== el) {
                this.el.remove(); // detach from DOM, allow for GC.
            }
            _setElement.call(this, el);
            skate.init(this.el);
            return this;
        },
        contents: function(html) {
            this.$el.find('.aui-inline-dialog-contents').html(html);
        },
        show: function() {
            this.el.show(); // will break in AUI 5.9
        },
        hide: function() {
            this.el.hide(); // will break in AUI 5.9
        },
        isVisible: function() {
            return this.el.isVisible ? this.el.isVisible() : this.$el.is(':visible');
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/watchers.js' */
define('jira/viewissue/watchers-voters/watchers', ['require'], function (require) {
    'use strict';

    var WatchersReadOnlyView = require('jira/viewissue/watchers-voters/views/watchers-read-only-view');
    var WatchersNoBrowseView = require('jira/viewissue/watchers-voters/views/watchers-no-browse-view');
    var WatchersView = require('jira/viewissue/watchers-voters/views/watchers-view');
    var WatchersUsersCollection = require('jira/viewissue/watchers-voters/entities/watchers-user-collection');
    var WatchersInlineDialogView = require('jira/viewissue/watchers-voters/views/watchers-inline-dialog-view');
    var Events = require('jira/util/events');
    var Types = require('jira/util/events/types');
    var Reasons = require('jira/util/events/reasons');
    var Issue = require('jira/issue');
    var InlineDialog = require('aui/inline-dialog');
    var $ = require('jquery');

    var dialogView = null;

    function getDialog() {
        if (!dialogView) {
            dialogView = new WatchersInlineDialogView({
                el: $('#inline-dialog-watchers').get(0)
            });
        }
        return dialogView;
    }

    function getView(collection) {
        if (collection.isReadOnly) {
            return WatchersReadOnlyView;
        } else if (collection.canBrowseUsers) {
            return WatchersView;
        } else {
            return WatchersNoBrowseView;
        }
    }

    $(document).on('click', '#view-watcher-list', function (e) {
        e.preventDefault();
        var dialog = getDialog();
        var loadingIcon = $('#watching-toggle').next('.icon');
        var collection = new WatchersUsersCollection(Issue.getIssueKey());
        loadingIcon.addClass('loading');
        var ViewClass = getView(collection);
        new ViewClass({
            collection: collection
        }).render().done(function(viewHtml) {
            loadingIcon.removeClass('loading');
            dialog.contents(viewHtml);
            dialog.show();
        });
        collection.on('errorOccurred', function () {
            dialog.hide();
        });
    });

    $(document).on('keydown', function (e) {
        if (dialogView) {
            // special case for when user hover is open at same time
            if (e.keyCode === 27 && InlineDialog.current !== dialogView.el && dialogView.isVisible()) {
                if (InlineDialog.current) {
                    InlineDialog.current.hide();
                }
                dialogView.hide();
            }
        }
    });

    // JRA-28786 Clicking any whitespace outside of the Watch dialog should dismiss the dialog
    $(document).on('click', function (e) {
        if (dialogView) {
            var watchersDialogOrSuggestionClicked = $(e.target).closest('#inline-dialog-watchers, #watchers-suggestions').length;
            if (watchersDialogOrSuggestionClicked === 0 && dialogView.isVisible()) {
                dialogView.hide();
            }
        }
    });

    Events.bind(Types.NEW_CONTENT_ADDED, function(e, context, reason) {
        //-- remove existing floating #inline-dialog-watchers before refresh adds another one
        if (reason === Reasons.panelRefreshed && context.is('#peoplemodule')) {
            getDialog().setElement(context.find('#inline-dialog-watchers').get(0));
        }
    });

});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/voters.js' */
define('jira/viewissue/watchers-voters/voters', ['require'], function (require) {
    'use strict';

    var VotersUsersCollection = require('jira/viewissue/watchers-voters/entities/voters-user-collection');
    var VotersView = require('jira/viewissue/watchers-voters/views/voters-view');
    var Issue = require('jira/issue');
    var InlineLayer = require('jira/ajs/layer/inline-layer');
    var InlineDialog = require('aui/inline-dialog');
    var $ = require('jquery');

    // Wire up inline dialog to our Backbone view
    var dialog = InlineDialog("#view-voter-list", "voters", function (contents, trigger, doShowPopup) {
                var loadingIcon = $('#vote-toggle').next('.icon');
                var collection = new VotersUsersCollection(Issue.getIssueKey());
                loadingIcon.addClass("loading");
                new VotersView({
                    collection: collection
                }).render().done(function (viewHtml) {
                            contents.html(viewHtml);
                            contents.find(".cancel").click(function (e) {
                                dialog.hide();
                                e.preventDefault();
                            });
                            loadingIcon.removeClass('loading');
                            doShowPopup();
                        });
                collection.on("errorOccurred", function () {
                    dialog.hide();
                });
            },
            {
                width: 240,
                useLiveEvents: true,
                items: "#view-voters-list",
                preHideCallback: function () {
                    return !InlineLayer.current; // Don't close if we have inline layer shown
                }
            });

    $(document).bind("keydown", function (e) {
        // special case for when user hover is open at same time
        if (e.keyCode === 27 && InlineDialog.current !== dialog && dialog.is(":visible")) {
            if (InlineDialog.current) {
                InlineDialog.current.hide();
            }
            dialog.hide();
        }
    });

    // Clicking any whitespace outside of the dialog should dismiss the dialog
    $(document).click(function (e) {
        var currentDialog = InlineDialog.current;
        if (currentDialog && currentDialog.id === "voters") {
            if (!$(e.target).closest("#inline-dialog-voters").length) {
                // I am not a child of the inline dialog
                currentDialog.hide();
            }
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/toggler.js' */
define('jira/viewissue/watchers-voters/toggler', ['require'], function(require) {
    var SmartAjax = require('jira/ajs/ajax/smart-ajax');
    var Messages = require('jira/flag');
    var $ = require('jquery');
    var contextPath = require('wrm/context-path');

    var toggleVotingAndWatching = function(trigger, className, resultContainer, issueOpTrigger, i18n) {

        var classNameOn = className + "-on";
        var classNameOff = className + "-off";
        var restPath = "/voters";
        var spinner = trigger.next('.icon');
        var data;
        var method = "POST";

        if(trigger.hasClass(classNameOn)) {
            method = "DELETE";
        }

        if(className.indexOf("watch") !== -1) {
            restPath = "/watchers";
        }
        trigger.removeClass(classNameOn).removeClass(classNameOff);

        if (method === "POST") {
            // If we are a post we want to include dummy data to prevent JRA-20675 BUT we cannot have data for DELETE
            // otherwise we introduce JRA-23257
            data = {
                dummy: true
            };
        }

        $(SmartAjax.makeRequest({
            url:contextPath() + "/rest/api/1.0/issues/" + trigger.attr("rel") + restPath,
            type: method,
            dataType: "json",
            data: data,
            contentType: "application/json",
            complete: function (xhr, textStatus, smartAjaxResult) {
                var optIn = method === "POST";
                if (smartAjaxResult.successful) {
                    if(optIn) {
                        trigger.addClass(classNameOn);
                        trigger.text(i18n.titleOn);
                        issueOpTrigger.attr("title", i18n.titleOn).text(i18n.textOn);
                    } else {
                        trigger.addClass(classNameOff);
                        trigger.text(i18n.titleOff);
                        issueOpTrigger.attr("title", i18n.titleOff).text(i18n.textOff);
                    }

                    resultContainer.text(smartAjaxResult.data.count);
                    resultContainer[optIn ? "addClass" : "removeClass"](classNameOn);
                    resultContainer[optIn ? "removeClass" : "addClass"](classNameOff);
                } else {
                    if (!smartAjaxResult.aborted) {
                        displayErrorMessage(smartAjaxResult);
                    }
                    if(optIn) {
                        trigger.addClass(classNameOff);
                        trigger.text(i18n.titleOff);
                        issueOpTrigger.attr("title", i18n.titleOff).text(i18n.textOff);
                    } else {
                        trigger.addClass(classNameOn);
                        trigger.text(i18n.titleOn);
                        issueOpTrigger.attr("title", i18n.titleOn).text(i18n.textOn);
                    }
                }
            }
        })).throbber({target: spinner});
    };

    var displayErrorMessage = function(smartAjaxResult) {
        var message = SmartAjax.buildSimpleErrorContent(smartAjaxResult,{ alert : true });
        if (smartAjaxResult.hasData) {
            var data = JSON.parse(smartAjaxResult.data);
            if (data.errorMessages) {
                message = data.errorMessages[0];
            }
        }
        Messages.showErrorMsg(message, { closeable: true });
    };

    $(document).delegate("#toggle-vote-issue", "click", function(e) {
        e.preventDefault();
        $("#vote-toggle").click();
    });

    $(document).delegate("#toggle-watch-issue", "click", function(e) {
        e.preventDefault();
        $("#watching-toggle").click();
    });

    var addI18nErrorCodes = function(i18n) {
        $("input[type=hidden][id|=error]").each(function(index, elem) {
            var i18n_id = elem.id.replace("error-", "");
            i18n[i18n_id] = elem.value;
        });
    };

    $(document).delegate("#vote-toggle", "click", function(e) {
        e.preventDefault();
        var i18n = {
            titleOn: "Remove vote for this issue",
            titleOff: "Vote for this issue",
            textOn: "Remove Vote",
            textOff: "Add Vote",
            actionTextOff: "Vote",
            actionTextOn: "Voted"
        };
        var trigger = $(this);
        var resultContainer = $(document.querySelectorAll("#vote-data"));
        var issueOpTrigger = $(document.querySelectorAll("#toggle-vote-issue"));
        addI18nErrorCodes(i18n);
        toggleVotingAndWatching(trigger, "vote-state", resultContainer, issueOpTrigger, i18n);
    });

    $(document).delegate("#watching-toggle", "click", function(e) {
        e.preventDefault();
        var i18n = {
            titleOn: "Stop watching this issue",
            titleOff: "Start watching this issue",
            textOn: "Stop Watching",
            textOff: "Watch Issue",
            actionTextOff: "Watch",
            actionTextOn: "Watching"
        };
        var trigger = $(this);
        var resultContainer = $(document.querySelectorAll("#watcher-data"));
        var issueOpTrigger = $(document.querySelectorAll("#toggle-watch-issue"));
        addI18nErrorCodes(i18n);
        toggleVotingAndWatching(trigger, "watch-state", resultContainer, issueOpTrigger, i18n);
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/initWatchersAndVoters.js' */
require([
    'jira/viewissue/watchers-voters/watchers',
    'jira/viewissue/watchers-voters/voters',
    'jira/viewissue/watchers-voters/toggler'
], function() {
    // Watchers and voters initialised
});

//
// Legacy namespacing for watchers and voters
// Deprecated since JIRA 7.1
//
AJS.namespace('JIRA.VotersUsersCollection', null, require('jira/viewissue/watchers-voters/entities/voters-user-collection'));
AJS.namespace('JIRA.WatchersUsersCollection', null, require('jira/viewissue/watchers-voters/entities/watchers-user-collection'));
AJS.namespace('JIRA.VotersView', null, require('jira/viewissue/watchers-voters/views/voters-view'));

AJS.namespace('JIRA.WatchersView', null, require('jira/viewissue/watchers-voters/views/watchers-view'));
AJS.namespace('JIRA.WatchersNoBrowseView', null, require('jira/viewissue/watchers-voters/views/watchers-no-browse-view'));
AJS.namespace('JIRA.WatchersReadOnly', null, require('jira/viewissue/watchers-voters/views/watchers-read-only-view'));
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/AnalyticsUtils.js' */
define("jira/viewissue/analytics-utils", [
    'jira/util/data/meta',
    'jira/issuenavigator/issue-navigator',
    'jira/util/strings',
    'wrm/context-path',
    'jquery',
    'exports'
], function(
    Meta,
    IssueNav,
    StringUtils,
    ContextPath,
    jQuery,
    exports
) {
    function isFullscreenIssue() {
        return jQuery(document.body).hasClass("navigator-issue-only");
    }

    function isServiceDeskQueue() {
        return !!Meta.get("is-servicedesk-rendered");
    }

    function isIssueNav() {
        return IssueNav.isNavigator();
    }

    function isIssueNavFullScreen() {
        return isFullscreenIssue() && StringUtils.contains(location.search, "jql=");
    }

    function isProjectView() {
        return StringUtils.startsWith(location.pathname, ContextPath() + "/projects/");
    }

    exports.context = function() {
        if (isIssueNavFullScreen()) {
            return "fullscreen-issuenav";
        }

        if (isFullscreenIssue()) {
            return "fullscreen";
        }

        if (isServiceDeskQueue()) {
            return "sd-queue";
        }

        if (isIssueNav()) {
            return "issuenav";
        }

        if (isProjectView()) {
            return "project";
        }

        return "unknown";
    };
});

;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/slideshow/slideshow-configuration.js' */
define('jira/viewissue/slideshow/slideshow-configuration', [
    'jira/ajs/keyboardshortcut/keyboard-shortcut-toggle',
    'jquery'
], function(KST, $) {

    var defaultOpts = {
        type: 'image',
        centerOnScroll: true,

        // disable JIRA's keyboard shortcuts when displaying a lightbox
        onStart: KST.disable,
        onClosed: KST.enable
    };

    var transition = 'elastic';

    return $.extend({}, defaultOpts, {
        transitionIn: transition,
        transitionOut: transition
    });
});
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/element/image-wrap.js' */
define('jira/viewissue/element/image-wrap', [
    'jira/fileviewer',
    'jira/skate',
    'featureflags/feature-manager',
    'underscore'
], function(
    fileviewer,
    skate,
    featureManager,
    _
) {
    if (featureManager.isFeatureEnabled("jira.fileviewer.disabled")) {
        return;
    }

    skate('file-preview-type', {
        type: skate.type.ATTRIBUTE,
        attached: _.debounce(function elementAttachedHandler() {
            fileviewer.attachToElements();
        }, 0),
        detached: function() {
            fileviewer.closeViewer();
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jquery/plugins/shorten/shorten.js' */
define('jira/ajs/shorten/shortener', [
    'jira/ajs/control',
    'jira/data/local-storage',
//    'aui',
    'jquery'
], function(
    Control,
    localStorage,
//    AJS,
    jQuery
) {
    /**
     * Shorten long lists with an ellipsis
     *
     * <h4>Use </h4>
     *
     * <h5>Markup:</h5>
     *
     * <pre>
     * <div id="mylist">
     *      <a href='#'>a</a>
     *      <a href='#'>b</a>
     *      <a href='#'>c</a>
     *      <a href='#'>d</a>
     *      <a href='#'>e</a>
     *      <a href='#'>f</a>
     *      <a href='#'>g</a>
     *      <a href='#'>h</a>
     *      <a href='#'>i</a>
     *      <a href='#'>j</a>
     *      <a href='#'>k</a>
     * </div>
     * </pre>
     *
     * <h5>JavaScript</h5>
     *
     * <pre>
     * // no options
     * new AJS.Shortener("#mylist");
     *
     * // with options
     * new AJS.Shortener({
     *      element: "#myList",
     *      numRows: 2
     * });
     * </pre>
     *
     * @class Shortener
     * @extends Control
     *
     */
    return Control.extend({

        _getDefaultOptions: function () {
            return {
                items: "a, span",
                numRows: 1,
                shortenText: "hide",
                shortenOnInit: true,
                persist: true,
                expandButtonTooltip: "Click to view {0} more",
                collapseButtonTooltip: "Hide"
            };
        },

        /**
         * Creates a shorten control
         *
         * @constructs
         * @param {Object} options
         * @param {String |jQuery} [options.items=a,span] - selector or jQuery collection specifying items
         * @param {Number} [options.numRows=1] - Number of rows to display when shortened
         * @param {String} [options.shortenText=hide] - Text to display in link at the end of the list when expanded
         * @param {Boolean} [options.shortenOnInit=true] - If true will shorten onload
         */
        init: function (options) {

            if (typeof options === "string") {
                options = {element: options};
            }

            options = options || {};

            this.options = jQuery.extend(this._getDefaultOptions(), options);
            this._timerId = 0;
            this.expanded = false;

            this.$container = jQuery(this.options.element);
            this._assignEvents("body", document.body);
            this._ready();
        },

        /**
         * Validate initialization
         * @return {Boolean}
         */
        _isValid: function () {
            return !this.initialized && this.$container.is(":visible") && this.$container.children().length > 0;
        },

        /**
         * Lazy initialization, so that we can init on dom ready if it is visible or when a activating a tab makes it visible
         * @private
         */
        _ready: function () {
            if (this._isValid()) {

                this.$items = this.$container.children(this.options.items);
                this.$expandButton = this._render("expandButton");
                this.$collapseButton = this._render("collapseButton");

                this._assignEvents("expand-button", ".shortener-expand");
                this._assignEvents("collapse-button", ".shortener-collapse");

                if (!jQuery.browser.msie || jQuery.browser.version >= "9") {
                    // IE8 is excluded from reflowing on "resize" events. Rendering this thing
                    // is very expensive in IE8 and "resize" events occur too frequently.
                    this._assignEvents("resize-region", window);
                }

                if (this._isCollapsedOnInit()) {
                    this.collapse();
                } else {
                    this.expand();
                }

                this.initialized = true;
            }
        },


        _renders: {

            /**
             * Creates the jQuery object representing an ellipsis. The ellipsis appended to the shortened list of items. It
             * contains text representing how many items have been hidden. When clicked it reveals the full list.
             * The ellipsis has a class of <strong>ellipsis</strong> and styling should be controlled in css.
             *
             * @method #_renders.expandButton
             * @private
             * @param {number} itemsHidden - number of items hidden
             * @return {jQuery} jQuery wrapped HTML element
             *
             */
            "expandButton": function () {
                return jQuery("<a href='#' class='ellipsis shortener-expand' title='" + this.options.expandButtonTooltip + "'></a><br>");
            },

            /**
             * Creates the jQuery object representing the shorten tip. The shorten tip is appended to the expanded list of
             * items. When clicked it shortens the list to the user specified paramater <strong>numRows</strong> Ellipsis has
             * a calss of <strong>icon-hide</strong> and styling should be controlled in css.
             *
             * @method #_renders.shortenTip
             * @private
             * @param {string} removeText - number of items hidden
             * @return {jQuery} jQuery wrapped HTML element
             *
             */
            "collapseButton": function () {
                return jQuery("<a title='Hide' class='icon icon-hide shortener-collapse' href='#'><span>" + this.options.collapseButtonTooltip + "</span></a>");
            }
        },

        _events: {
            "expand-button": {
                "click": function(event) {
                    if (event.currentTarget === this.$expandButton[0]) {
                        event.preventDefault();
                        this.expand();
                        this._saveState("expanded");
                    }
                }
            },
            "collapse-button": {
                "click": function(event) {
                    if (event.currentTarget === this.$collapseButton[0]) {
                        event.preventDefault();
                        this.collapse();
                        this._saveState("collapsed");
                        this.$container.scrollIntoView();
                    }
                }
            },
            "resize-region": {
                "resize": function() {
                    clearTimeout(this._timerId);
                    if (!this.expanded) {
                        var instance = this;
                        this._timerId = setTimeout(function() {
                            instance.collapse();
                        }, 400);
                    }
                }
            },
            "body": {
                // handling for the case where control is in a tab, and as a result hidden.
                tabSelect: function () {
                    this._ready();
                }
            }
        },

        /**
         * @private
         * @param {string} value
         */
        _saveState: function(value) {
            try {
                localStorage.setItem("AJS.Shortener#" + this.$container.closest("[id]").attr("id"), value);
            } catch (QUOTA_EXCEEDED_ERR) {
                // ignore
            }
        },

        /**
         * @private
         * @return {?string}
         */
        _loadState: function() {
            return localStorage.getItem("AJS.Shortener#" + this.$container.closest("[id]").attr("id"));
        },

        /**
         * Should list should be shortened on load. This is determined by cookie, if persist options is true, or "shortenOnInit"
         * option. Please not that if persist option is set to true, the list will not be shortened if use has expanded it previously
         * regardless of the shortenOnInit set to true.
         *
         * @private
         * @return boolean
         */
        _isCollapsedOnInit: function() {
            var shortenOnInit = this._loadState();
            if (shortenOnInit !== null) {
                return shortenOnInit !== "expanded";
            }
            return this.options.shortenOnInit;
        },

        /**
         * Removes $expandButton and $collapseButton.
         *
         * @private
         */
        _removeButtons: function () {
            this.$expandButton.remove();
            this.$collapseButton.remove();
        },

        /**
         * Get the index within this.$items of the first element that flows over
         * the allowed number of lines, or (-1) if all items fit within the limit.
         *
         * Note: The first item in the list is never considered overflowing, even
         * when it contains several words that might wrap multiple lines, so this
         * function will never return 0.
         *
         * @private
         * @return {number}
         */
        _getOverflowIndex: function() {

            if (this.$items.length > 1) {

                var currentRow = 1;
                var prevItemPageX = -1;

                for (var i = 0; i < this.$items.length; i++) {
                    var itemPageX = this.$items.eq(i).offset().left;
                    if (itemPageX <= prevItemPageX) {
                        // This item flows to a new line.
                        currentRow++;
                        if (currentRow > this.options.numRows) {
                            // This item exceeds the allowed number of lines.
                            return i;
                        }
                    }
                    prevItemPageX = itemPageX;
                }
            }

            return -1;
        },

        /**
         * Expands list to full height, adding a link to shorten
         */
        expand: function() {

            this._removeButtons();

            if (this._getOverflowIndex() > 0) {

                this.$collapseButton = this._render("collapseButton");

                this.$container.append(this.$collapseButton);
                this.$container.css("height", "auto");

                // Ensure IE8 renders the new layout.
                if (jQuery.browser.msie && jQuery.browser.version < "9") {
                    jQuery('body').toggleClass('reflow');
                }
            }

            this.expanded = true;
        },

        /**
         * Contracts list to user specified number of rows, adding a link to shorten.
         */
        collapse: function() {

            this._removeButtons();

            var i = this._getOverflowIndex();

            if (i > 0) {
                // Isolate $container in render tree while we make adjustments.
                this.$container.css({
                    "position": "absolute",
                    "visibility": "hidden",
                    "width": this.$container[0].clientWidth + "px"
                });

                var $expandButtonContent = this.$expandButton.first();

                do {
                    var remainingItemCount = (this.$items.length - i);

                    $expandButtonContent.text("(" + remainingItemCount + ")");
                    this.$expandButton.insertBefore(this.$items[i]);

                    // Check that $expandButton fits on the same line as the previous item,
                    // otherwise try again with the item before that.
                    i--;

                    var oi = this.$items.eq(i).offset();
                    var ob = this.$expandButton.offset();

                    if (oi.left < ob.left && ob.top < oi.top + 10) {
                        // It fits! We assume $expandButton is on the same line as the previous
                        // item if it's offsetTop is less than a line-height below the item's
                        // offsetTop. Hard-coding 10px is a best approximation of line-height.
                        break;
                    }
                } while (i > 0);

                // Set the $container height required to clip the item immediately after $expandButton.
                var height = (i < this.$items.length - 1)
                           ? (this.$items.eq(i + 1).offset().top - this.$container.offset().top) + "px"
                           : "auto";

                this.$container.css({
                    "height": height,
                    "position": "static",
                    "visibility": "visible",
                    "width": "auto"
                });

                $expandButtonContent.attr("title", AJS.format(this.options.expandButtonTooltip, remainingItemCount));

                // Ensure IE8 renders the new layout.
                // Otherwise, shortening a field in the "People" group will leave the things below it hanging.
                if (jQuery.browser.msie && jQuery.browser.version < "9") {
                    jQuery('body').toggleClass('reflow');
                }

            } else {
                // Make sure no items are being clipped.
                this.$container.css("height", "auto");
            }

            this.expanded = false;
        }
    });
});

define('jira/jquery/plugins/shorten/shorten', [
    'jira/ajs/shorten/shortener',
    'jquery'
], function(
    Shortener,
    jQuery
) {
    /**
     *
     * jQuery plugin to shorten long lists with an ellipsis.
     *
     * For full options see {@link Shortener}
     *
     * @note Delegates to {@link Shortener}
     *
     * @example
     *
     * // no options
     * jQuery("#my-container").shorten();
     *
     * // options
     * jQuery("#my-container").shorten({
     *      numRows: 5
     * });
     *
     * @function external:"jQuery.fn".shorten
     * @param {Object} [options]
     * @param {HTMLElement | jQuery} options.element
     */
    jQuery.fn.shorten = function (options) {

        var res = [];
        options = options || {};

        this.each(function () {
            options.element = this;
            res.push(new Shortener(options));
        });

        return res;
    };
});

AJS.namespace('AJS.Shortener', null, require('jira/ajs/shorten/shortener'));

// Make extension available in global scope immediately / synchronously.
// TODO INC-71 - remove synchronous require
(function() {
    require('jira/jquery/plugins/shorten/shorten');
})();
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/element/shorten.js' */
define('jira/viewissue/element/shorten', [
    'jira/ajs/shorten/shortener',
    'jira/skate'
], function(Shortener, skate) {
    return skate('shorten', {
        type: skate.type.CLASSNAME,
        attached: function(element) {
            var options = {};
            options.element = element;
            new Shortener(options);
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/initToggleBlock.js' */
AJS.$(function() {
    new JIRA.ToggleBlock({
        blockSelector: ".toggle-wrap",
        triggerSelector: ".mod-header .toggle-title",
        storageCollectionName: "block-states"
    });

    // When we refresh the issue page we also need make sure we restore twixi block state
    if (JIRA.Events.ISSUE_REFRESHED) {
        JIRA.bind(JIRA.Events.ISSUE_REFRESHED, function () {
            if (JIRA.Events.REFRESH_TOGGLE_BLOCKS) {
                JIRA.trigger(JIRA.Events.REFRESH_TOGGLE_BLOCKS);
            }
        });
    }
});;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/initComment.js' */
(function ($) {

    /**
     * This is used to control the logic of showing confirmation dialog.
     * If the comment form is being submitted, there should be no confirmation dialog appearing at all.
     * Its value will be changed when successfully submitting the form and start opening a new form.
     * @type {boolean}
     */
    var commentFormIsBeingSubmitted = false;
    var isInPreviewMode = false;
    var commentForm = JIRA.Issue.CommentForm = {
        /**
         * Cancels a comment. This means clearing the text area, resetting the
         * dirty state for the closes form, and collapsing the comment box.
         *
         * If comment preview mode is enabled, this function disables it before
         * attempting to clear the comment textarea.
         */
        setCaretAtEndOfCommentField: function () {
            var $field = this.getField(),
                field = $field[0],
                length;
            if ($field.length) {
                length = $field.val().length;
                $field.scrollTop($field.attr("scrollHeight"));
                if (field.setSelectionRange && length > 0) {
                    field.setSelectionRange(length, length);
                }
            }
        },

        /**
         * When we submit disable all the fields to avoid mods and double submit
         */
        disable: function () {
            this.getForm().find("textarea").attr("readonly", "readonly");
            this.getForm().find("input[type=submit]").attr("disabled", "disabled");
        },

        /**
         * Check if value has changed
         *
         * @return {Boolean}
         */
        isDirty: function () {
            var field = this.getField();
            if (field.length) {
                return field[0].value !== field[0].defaultValue;
            }
            return false;
        },

        handleBrowseAway: function () {
            // If the form isn't dirty, no point continuing.
            if (!commentForm.isDirty()) return;

            // If the form isn't visible, then don't show a dirty warning. This
            // is particularly important for the issue search single-page-app.
            var form = commentForm.getForm();
            var isVisible = form.length && form.is(":visible");

            if (isVisible) {
                return "You have entered a comment on this issue. If you navigate away from this page without first saving, the comment will be lost.";
            }
        },

        isVisibilityAvailble: function() {
            return this.getForm().find("#commentLevel :selected").val() != 'none';
        },

        setSubmitState: function () {
            if (jQuery.trim(this.getField().val()).length > 0 && this.isVisibilityAvailble()) {
                this.getForm().find("#issue-comment-add-submit").removeAttr("disabled");
            } else {
                this.getForm().find("#issue-comment-add-submit").attr("disabled", "disabled");
            }
        },

        /**
         * Enables the comment form
         */
        enable: function () {
            this.getForm().find("textarea").removeAttr("readonly");
            this.getForm().find("input[type=submit]").removeAttr("disabled");
        },

        /**
         * Get comment visibility permission.
         *
         * @return {Object} -- null if no value has been selected
         */
        getCommentVisibility: function() {
            var visibility = this.getForm().find("#commentLevel :selected").val();
            if (visibility) {
                var split_v = visibility.split(':');
                return {
                    "type" : split_v[0],
                    "value" : this.getForm().find("#commentLevel :selected").text()
                };
            }
            return null;
        },

        /**
         * Submits comments via ajax, used in kickass
         */
        ajaxSubmit: function (callback) {
            var $loading = jQuery('<span class="icon throbber loading"></span>');
            var issueId = JIRA.Issue.getIssueId();
            var issueKey = JIRA.Issue.getIssueKey();
            var restURL = contextPath + "/rest/api/2/issue/" + issueKey + "/comment";
            //build rest request
            var newComment = {
                // set line ending to CRLF for consistency with other comment methods
                // for example: add comment in new tab (midlde click), add comment in edit issue, or edit comment - they all use CRLF
                "body":this.getField()[0].value.replace(/\r?\n/g, "\r\n")
            };
            var visibility = this.getCommentVisibility();
            if (visibility) {
                newComment["visibility"] = visibility;
            }

            $.ajax({
                url:restURL,
                type:"POST",
                contentType:"application/json",
                data:JSON.stringify(newComment),
                success:function (data)
                {
                    JIRA.trigger(JIRA.Events.UNLOCK_PANEL_REFRESHING, ["addcommentmodule"]);
                    JIRA.trigger(JIRA.Events.REFRESH_ISSUE_PAGE, [issueId, {
                        complete:function () {
                            //highlight comment, set anchor
                            var newCommentId = "comment-" + data.id;
                            //Do not append the hash to the url (to let browser scroll the element into view)
                            //Appending the hash will add a new history point and as of 6.0 it will be incompatible,
                            //as back/forward button will be navigation between issues, instead of the states in the current issue.
                            //Instead manually scroll the element into view
                            jQuery("#" + newCommentId).scrollIntoView({
                                marginBottom: 200,
                                marginTop: 200
                            });
                            //remove the focusing from any other comments
                            var $focusedTabs = $("#issue_actions_container > .issue-data-block.focused");
                            $focusedTabs.removeClass("focused");
                            var $newfocusedTab = $("#" + newCommentId);
                            //assume only one focused comment
                            $newfocusedTab.addClass("focused");
                            $loading.remove();
                            footerComment.hide(true); //hiding both?
                            // Re-enable the comment form after successful complete in preparation for future use.
                            commentForm.enable();
                        }
                    }]);
                },
                error: function (xhr) {
                    function buildErrorDialog(errorMessage) {
                        var errorContent =
                            '<h2>' + "Error" + '</h2>' +
                            '<div class="ajaxerror">' +
                                '<div class="aui-message error">' +
                                    '<span class="aui-icon icon-warning"/>' +
                                    errorMessage +
                                '</div>' +
                            '</div>';
                        return $(errorContent);
                    }

                    var response = $.parseJSON(xhr.responseText);
                    var content;
                    if (response && response.errors && response.errors.comment) {
                        content = buildErrorDialog(response.errors.comment);
                    } else {
                        content = JIRA.SmartAjax.buildDialogErrorContent(xhr);
                    }
                    new JIRA.FormDialog({
                        content: content
                    }).show();
                    $loading.remove();
                    commentForm.enable();
                }
            });
            $loading.appendTo(this.getForm().find("input[type=submit]").parent());
        },

        /**
         * Gets form from dom or cached one
         *
         * @return {jQuery}
         */
        getForm: function () {
            var $form = $("form#issue-comment-add");
            if ($form.length === 1) {
                // on page load or panels have been refeshed and we have another comment form
                this.$form = $form;
            }
            return this.$form || $();
        },

        /**
         * Gets the comment textarea
         * @return {jQuery}
         */
        getField: function () {
            return this.getForm().find("#comment");
        },

        getSubmitButton: function () {
            return this.getForm().find("#issue-comment-add-submit");
        },

        /**
         * Hides form by removing it from dom
         *
         * @param cancel
         */
        hide: function (cancel) {
            if (cancel) {
                this.cancel();
            }
            this.getForm().detach();
            if (JIRA.Events.UNLOCK_PANEL_REFRESHING) {
                // disable panel refreshing in kickass
                JIRA.trigger(JIRA.Events.UNLOCK_PANEL_REFRESHING, ["addcommentmodule"]);
            }
        },

        /**
         * Focuses form
         */
        show: function () {
            this.focus();
            if (JIRA.Events.LOCK_PANEL_REFRESHING) {
                // disable panel refreshing in kickass
                JIRA.trigger(JIRA.Events.LOCK_PANEL_REFRESHING, ["addcommentmodule"]);
            }
        },

        /**
         * Focuses field and puts cursor at end of text
         */
        focus: function () {
            this.focusField();
            this.setCaretAtEndOfCommentField();
        },

        focusField: function() {
            this.getField().focus().trigger("keyup");

            this.getSubmitButton().scrollIntoView({
                marginBottom: 200
            });
        },

        /**
         *
         * @param e
         * @return {Boolean} - Did it show message or not
         */
        showNoCommentMsg: function (e) {
            if (this.getField().val() === "") {
                $("#emptyCommentErrMsg").show();
                return true;
            }
        },
        /**
         * Cancels comment, removing the value from the textarea
         */
        cancel: function () {
            var instance = this;
            // now clear the input value.  Need to do this in a timeout since FF 3.0 otherwise doesn't
            //clear things.
            setTimeout(function() {instance.getField().val('');}, 100);
            // JRADEV-3411: disable preview if necessary so the comment gets cleared properly
            $('#comment-preview_link.selected').click();
        }
    };


    var footerComment = {
        /**
         * Gets comment module
         * @return {jQuery}
         */
        getModule: function () {
            return $("#addcomment");
        },
        /**
         * Is the comment area visible
         * @return {*}
         */
        isActive: function () {
            return this.getModule().hasClass("active");
        },
        /**
         * Hides comment area
         *
         * @param cancel - clear textarea
         */
        hide: function (cancel) {
            if (this.isActive()) {
                var dirtyMessage = commentForm.handleBrowseAway();
                if (isInPreviewMode || commentFormIsBeingSubmitted || !dirtyMessage || confirm(dirtyMessage)) {
                    this.getModule().removeClass("active");
                    commentForm.hide(cancel);
                }
            }
        },
        ajaxSubmit: function () {
            commentFormIsBeingSubmitted = true;
            commentForm.ajaxSubmit(function () {
                footerComment.hide();
            });
        },
        /**
         * Shows comment area
         */
        show: function () {
            if (!this.isActive()) {
                commentFormIsBeingSubmitted = false;
                this.getModule().addClass("active");
                this.appendForm();
                commentForm.show();
            } else {
                commentForm.focusField();
            }
        },
        /**
         * Appends form to correct location
         */
        appendForm: function () {
            this.getModule().find(".mod-content").append(commentForm.getForm());
        }
    };

    var oldBeforeUnload = window.onbeforeunload;

    $(document)
        // issue comments are always ajax submitted
        .delegate("#addcomment #issue-comment-add", "submit", function (e) {
            footerComment.ajaxSubmit();
            e.preventDefault();
        })
        // show/hide of comment in header
        .delegate(".issue-header #comment-issue", "click", function (e) {
            footerComment.show();
            e.preventDefault();
        })
        // show/hide of comment in footer
        .delegate("#footer-comment-button", "click", function (e) {
            footerComment.show();

            commentForm.getForm().find('#commentLevel').bind('change', function() {
                commentForm.setSubmitState();
            });
            commentForm.setSubmitState();
            e.preventDefault();
        })
        // Cancel comment in footer
        .delegate("#addcomment .cancel", "click", function (e) {
            e.preventDefault();
            footerComment.hide(true);
        })
        .delegate("#issue-comment-add", "submit", function () {
            window.setTimeout(function () { // JRADEV-11111 - IE8 requires a timeout
                commentForm.disable();
            }, 0);
        })
        .delegate("#issue-comment-add #comment", "input", function () {
            commentForm.setSubmitState();
        })
        .delegate("#issue-comment-add input[type='submit']", "click", function (e) {
            if (commentForm.showNoCommentMsg()) {
                e.preventDefault();
            }
        })
        .bind("showWikiInput", function () {
            isInPreviewMode = false;
            var $commentField = commentForm.getField();
            if ($commentField.is(":visible:enabled")) {
                JIRA.Issue.getStalker().trigger("stalkerHeightUpdated");
                if ($commentField.length > 0) {
                    $commentField.focus();
                }
                commentForm.setCaretAtEndOfCommentField();
            }
        })
        .bind("showWikiPreview", function () {
            isInPreviewMode = true;
            JIRA.Issue.getStalker().trigger("stalkerHeightUpdated");
        });

    // Why not just use jQuery I hear you say?? Well it doesn't work for IE!
    // JRADEV-11612
    window.onbeforeunload = function () {
        return oldBeforeUnload.apply(this, arguments) ||
            commentForm.handleBrowseAway.apply(this, arguments);
    };

    /**
     * Construct a dirty comment warning if the comment form is dirty.
     *
     * @returns {string|undefined} A dirty comment warning or undefined.
     */
    JIRA.Issue.getDirtyCommentWarning = commentForm.handleBrowseAway;

    /**
     * Invoke the most appropriate comment trigger on page.
     * If the header toolbar trigger is present then invoke that.
     * Otherwise invoke the first link with ".add-issue-comment" class (needed for adding comments in Issue Nav list view).
     */
    JIRA.Issue.invokeCommentTrigger = function() {
        var addIssueComment = AJS.$(".add-issue-comment");
        if (addIssueComment.length === 0) {
            return;
        }

        var toolbarTrigger = addIssueComment.filter(".toolbar-trigger");
        if (toolbarTrigger.length > 0) {
            // Click issue page toolbar trigger if it's present.
            toolbarTrigger.click();
        } else {
            // Otherwise click the first link on page (needed for Issue Nav list view).
            addIssueComment.click();
        }
    };
})(AJS.$);

/**
 * Check for add-comment anchor and open the bottom comment box
 */
AJS.$(function () {
    if (parseUri(window.location.href).anchor === "add-comment") {
        AJS.$("#footer-comment-button").click();
    }
});
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/initCustomFieldTabs.js' */
(function ($, scope) {
    var activateTab = function(tabName) {
        var tabTrigger;
        if (typeof tabName !== "string" && tabName.length > 0) return;
        if (tabName[0] !== "#") tabName = "#" + tabName; // Ensure there's a hash. It'll work for both jQuery + href selectors

        console.log("activating tab", tabName);
        tabTrigger = $("a[href='" + tabName +"']", scope);
        if (tabTrigger.length) {
            AJS.tabs.change(tabTrigger);
        }
    };

    var revealer = function(e) {
        var $containingTab = $(e.target).closest(".tabs-pane");
        if ($containingTab.length > 0) {
            activateTab($containingTab.attr("id"));
        }
    };

    $(function () {
        if (JIRA.Events.NEW_CONTENT_ADDED) {
            JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, $context) {
                // Bind the revealer to new content.
                var $customFieldModule = $context.find(scope);
                $customFieldModule.unbind("reveal");
                $customFieldModule.bind("reveal", revealer);

                // Set up and tabs in the new content.
                AJS.tabs.setup();
            });
        }

        // Preserve the active custom field tab when refreshing the details panel.
        if (JIRA.Events.PANEL_REFRESHED) {
            JIRA.bind(JIRA.Events.PANEL_REFRESHED, function (e, panel, $new, $existing) {
                if (panel === "details-module") {
                    var $activeTab = $existing.find(scope).find(".active-tab");
                    if ($activeTab.length === 1) {
                        activateTab($activeTab.find("a").attr("href"));
                    }
                }
            });
        }

        $(scope).bind("reveal", revealer);
    });
})(AJS.$, "#customfieldmodule");;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/initSubtaskTimeLogging.js' */
(function ($) {
    $(document).delegate("#tt_include_subtasks input", "click", function(e) {
        if (AJS.$(this).is(":checked")){
            AJS.$("#tt_info_single").hide();
            AJS.$("#tt_info_aggregate").show();
        } else {
            AJS.$("#tt_info_aggregate").hide();
            AJS.$("#tt_info_single").show();
        }
    });
})(AJS.$);;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/ViewIssueTabs.soy' */
// This file was automatically generated from ViewIssueTabs.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Issue.Tabs.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Issue == 'undefined') { JIRA.Templates.Issue = {}; }
if (typeof JIRA.Templates.Issue.Tabs == 'undefined') { JIRA.Templates.Issue.Tabs = {}; }


JIRA.Templates.Issue.Tabs.label = function(opt_data, opt_ignored) {
  return '<strong>' + soy.$$escapeHtml(opt_data.text) + '</strong>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issue.Tabs.label.soyTemplateName = 'JIRA.Templates.Issue.Tabs.label';
}


JIRA.Templates.Issue.Tabs.tab = function(opt_data, opt_ignored) {
  return '<a id="' + soy.$$escapeHtml(opt_data.id) + '" href="' + soy.$$escapeHtml(opt_data.href) + '" class="' + soy.$$escapeHtml(opt_data.linkClass) + '">' + JIRA.Templates.Issue.Tabs.label(opt_data) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issue.Tabs.tab.soyTemplateName = 'JIRA.Templates.Issue.Tabs.tab';
}
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/ViewIssueTabsAnalytics.js' */
define("jira/viewissue/tabs/analytics", [
    'jquery',
    'jira/util/strings',
    'jira/viewissue/analytics-utils',
    'underscore'
], function (
    jQuery,
    StringUtils,
    AnalyticsUtils,
    _
) {
    var Trigger = AJS.trigger;

    var privacyPolicyWhitlistedTabs = [
        "com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel",
        "com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel",
        "com.atlassian.jira.plugin.system.issuetabpanels:worklog-tabpanel",
        "com.atlassian.jira.plugin.system.issuetabpanels:changehistory-tabpanel",
        "com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab"
    ];

    function whitelistedTabId (tabId) {
        if (privacyPolicyWhitlistedTabs.indexOf(tabId) > -1) {
            return tabId;
        }
        return StringUtils.hashCode(tabId);
    }

    function getTabData($tabElement) {
        return {
            tab: whitelistedTabId($tabElement.attr('data-key')),
            tabPosition: $tabElement.index()
        }
    }

    function baseEventData(openedInNewWindow, triggeredByKeyboard) {
        return {
            inNewWindow: openedInNewWindow,
            keyboard: triggeredByKeyboard,
            context: AnalyticsUtils.context()
        }
    }

    return {
        tabClicked: function($elementClicked, openedInNewWindow, triggeredByKeyboard) {
            var $parent = $elementClicked.parent();
            var data = _.extend({}, baseEventData(openedInNewWindow, triggeredByKeyboard), getTabData($parent));
            Trigger("analyticsEvent", {
                name: "jira.viewissue.tab.clicked",
                data: data
            });
        },

        buttonClicked: function($elementClicked, openedInNewWindow, triggeredByKeyboard) {
            if (!$elementClicked.is("[data-tab-sort]")) {
                return;
            }

            var order = $elementClicked.data("order");
            var $activeTab = $elementClicked.parents(".tabwrap").find("li.active");

            Trigger("analyticsEvent", {
                name: "jira.viewissue.tabsort.clicked",
                data: _.extend({}, baseEventData(openedInNewWindow, triggeredByKeyboard), getTabData($activeTab), {
                    order: order
                })
            });
        }
    };
});;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/ViewIssueTabs.js' */
/**
 * This module encapsulates issue tab-related functionality

 * @namespace JIRA.ViewIssueTabs
 * @requires jQuery
 * @requires JIRA.Dialog
 */
define("jira/viewissue/tabs", [
    "jquery",
    "jira/util/data/meta",
    "jira/dialog/form-dialog",
    "jira/ajs/ajax/smart-ajax",
    "jira/userhover/userhover",
    "jira/viewissue/tabs/analytics"
], function(
    jQuery,
    Meta,
    FormDialog,
    SmartAjax,
    Userhover,
    Analytics
) {
    var Format = AJS.format;
    var Templates = JIRA.Templates.Issue.Tabs;

    /**
     * Whether to use the HTML5 History API when switching between tabs. Setting this to false will cause tab switching
     * to just use a plain AJAX request without changing the URL.
     *
     * @type {Boolean}
     */
    var useHistoryApi = Meta.get('viewissue-use-history-api') !== false;

    /**
     * The CSS class used to mark issue tab panel links that can be loaded using AJAX.
     */
    var AJAX_LOAD_CLASS = 'ajax-activity-content';

    /**
     * The selector for container that should contain contents be loaded using AJAX.
     */
    var CONTAINER_SELECTOR = '#activitymodule div.mod-content';

    /**
     * The selector for links that should be loaded using AJAX.
     */
    var AJAX_LINK_SELECTOR = Format('a.{0}', AJAX_LOAD_CLASS);

    /**
     *
     * This array holds the functions that will be called after a issue tab is loaded.
     */
    var issueTabLoadedListeners = [];

    /**
     * These are used to display progress and the tab contents.
     */
    var $tabWrapper,
        $tabContents;

    /**
     * The XHR that's currently in progress and hasn't been aborted, or null.
     */
    var xhrInProgress;

    /**
     * Dispatches the "issue tab loaded" event to the registered listeners.
     *
     * @param container the DOM node that was loaded (may be a tab or the whole document)
     */
    function dispatchIssueTabLoadedEvent(container) {
        container = container || document;
        jQuery.each(issueTabLoadedListeners, function (i, fn) {
            fn(container);
        });
    }

    /**
     * Binds this class's $tabWrapper and $tabContents vars to the loaded tab.
     *
     * @param container the tab
     */
    function bindToTabDivs(container) {
        // these are the DOM elements we'll manipulate

        // JRADEV-17627 - Don't overwrite old elements if the container doesn't contain them.
        //
        // This method is called as a listener to the event JIRA.Events.NEW_CONTENT_ADDED, and that event is fired
        // twice. The first time it is fired when the page is loaded and container == document. The second time is fired
        // with container == some other div. In that second case, the container doesn't contain the elements we are after.
        var $newTabWrapper = jQuery(container).find('.issuePanelWrapper');
        var $newTabContents = jQuery(container).find('#issue_actions_container');
        $tabContents = $newTabContents.length ? $newTabContents : $tabContents;
        $tabWrapper = $newTabWrapper.length ? $newTabWrapper : $tabWrapper;
    }

    /**
     * Dispatches the "issue tab error" event to the registered listeners.
     */
    function dispatchIssueTabErrorEvent(smartAjaxResult, activeTabKey) {
        var errorPopup = new FormDialog({
            id: 'issue-tab-error-dialog',
            widthClass: 'small',
            content: SmartAjax.buildDialogErrorContent(smartAjaxResult, false)
        });

        // restore the previously-active tab before showing the pop-up
        setActiveTab(activeTabKey);
        $tabContents.show();

        errorPopup.show();
    }

    function setActiveTab(activeTabKey) {
        jQuery('#issue-tabs li').each(function() {
            var $li = jQuery(this);

            // activate the right tab
            var tabKey = $li.data('key');
            var tabLabel = $li.data('label');
            if (tabKey == activeTabKey)
            {
                $li.addClass('active');
                $li.html(Templates.label({
                    text: tabLabel
                }));
            }
            else
            {
                $li.removeClass('active');
                var id = $li.data('id');
                var href = $li.data('href');
                $li.html(Templates.tab({
                    id: id,
                    href: href,
                    linkClass: AJAX_LOAD_CLASS,
                    text: tabLabel
                }));
            }
        });

        enableAjaxOnLinks(jQuery('#issue-tabs'));
    }

    /**
     * Puts a tab in the loading state: marks the tab title as active, hides the previous tab's content, and shows a
     * "loading" image.
     */
    function putTabInLoadingState(activeTabKey) {
        setActiveTab(activeTabKey);
    }

    /**
     * Detect if event trigger by keyboard or mouse based on position
     * because we cannot based on event.type (always return "click" inner click handler function
     */

    function isTriggerByKeyBoard(event, $trigger){
        var eventX = event.pageX;
        var eventY = event.pageY;
        var triggerOffset = $trigger.offset();
        var triggerWidth = $trigger.outerWidth();
        var triggerHeight = $trigger.outerHeight();

        if(eventX == 0 && eventY == 0) {
            return true;
        }
        else {
            return ! (eventX >= triggerOffset.left && eventX <= (triggerOffset.left + triggerWidth) && eventY >= triggerOffset.top && eventY <= (triggerOffset.top + triggerHeight));
        }
    }

    /**
     * Make all activitymodule links PJAX-enabled.
     */
    function enableAjaxOnLinks(context) {
        var activeTabKey = jQuery(context).find('li.active').data('key');
        jQuery(context).find(AJAX_LINK_SELECTOR).click(function (event) {
            var $trigger = jQuery(this);

            var isTriggerByKeyboard = isTriggerByKeyBoard(event, $trigger);

            // hide the contents, and activate the other tab
            var loadingTabKey = $trigger.parent().data('key');

            var openInNewWindow = event.metaKey;

            if (loadingTabKey) {
                Analytics.tabClicked($trigger, openInNewWindow, isTriggerByKeyboard);
            } else {
                Analytics.buttonClicked($trigger, openInNewWindow, isTriggerByKeyboard);
            }

            if (openInNewWindow) {
                // allow people to meta-click to open link in a new tab or window
                return;
            }

            event.preventDefault();

            // not all links change tabs - e.g. sort icon
            if (loadingTabKey) {
                putTabInLoadingState(loadingTabKey);
            }


            handleAjaxContentsLoading(activeTabKey, $trigger.attr("href"))
                .done(function($container){
                    if(!isTriggerByKeyboard){
                        //if user trigger action by mouse , we don't get focus
                        return;
                    }
                    //focus into tab or sort action element after update content
                    if(loadingTabKey) {
                        //focus into active tab
                        $container.find("#"+$trigger.attr("id")+" > :first-child").focus();
                    }
                    else {
                        //focus into sort action
                        $container.find(".sortwrap  > :first-child").focus();
                    }
                })
                .done(dispatchIssueTabLoadedEvent);
        });
    }

    /**
     * Loading new content by Ajax and update dom content based on the Ajax'result
     */
    function handleAjaxContentsLoading(activeTabKey, loadingUrl){
        var deferred = jQuery.Deferred();
        // cancel any pending requests
        if (xhrInProgress) {
            xhrInProgress.abort();
        }

        var xhr = SmartAjax.makeRequest({
            jqueryAjaxFn: useHistoryApi ? jQuery.pjax : jQuery.ajax,
            headers: { "X-PJAX": true }, // needed for the ViewIssue action to return only the activity panel
            container: CONTAINER_SELECTOR,
            url: loadingUrl,
            timeout: null,
            complete: function (xhr, status, smartAjaxResult) {
                if (status != 'abort') {
                    xhrInProgress = null;

                    if (!smartAjaxResult.successful)
                    {
                        // don't display error when we're going to redirect anyway
                        if (smartAjaxResult.status < 300 || smartAjaxResult.status >= 400)
                        {
                            dispatchIssueTabErrorEvent(smartAjaxResult, activeTabKey);
                        }

                        return;
                    }

                    var $container = jQuery(this.container);
                    /**
                     * var newElements = AJS.$(smartAjaxResult.data);
                     * Above line of code caused the RangeError: Maximum call stack size exceeds error,
                     * when trying to wrap the huge smartAjaxResult.data.
                     */

                    var newElementsHtml = document.createElement("div");
                    newElementsHtml.innerHTML = smartAjaxResult.data;
                    var newElements = document.createDocumentFragment().appendChild(newElementsHtml);
                    if (!useHistoryApi) {
                        // if not using PJAX then we need to manually write the retrieved content into the page
                        smartUpdate($container, newElements);
                    }

                    JIRA.trace('jira.issue.tab.loaded');

                    deferred.resolve($container);
                }
            }
        });
        jQuery(xhr).throbber({target: $tabWrapper});
        xhrInProgress = xhr;
        return deferred;
    }

    /**
     * Attempts to find tab and content elements in newElements and update the respective elements in the container.
     * If the elements can't be matched up, it simply replaces the contents of container with newElements.
     * @param container
     * @param newElements
     */
    function smartUpdate(container, newElements) {
        var newTabs = newElements.querySelectorAll('.tabwrap');
        var oldTabs = container.find('.tabwrap');
        var newContents = jQuery(newElements.querySelectorAll("#issue_actions_container")).contents();
        var oldContents = $tabContents.contents();
        if (newTabs.length && oldTabs.length && newContents.length && oldContents.length) {
            // Replace the tabs
            oldTabs.replaceWith(newTabs);

            var currentContentHeight = $tabContents.height();
            // If the new content would cause the page to 'jump' due to being shorter than the
            // previous content, animate it smoothly from the edge of the window.
            // Otherwise, simply replace the content.
            $tabContents.append(newContents);
            var newContentHeight = $tabContents.height() - currentContentHeight;
            var visibleHeightDifference = jQuery(window).scrollTop() + jQuery(window).height() - ($tabContents.offset().top + newContentHeight);
            if (visibleHeightDifference > 0) {
                $tabContents.css('height', newContentHeight + visibleHeightDifference);
                oldContents.remove();

                // Delay the animation so the user has time to recognise that it is shrinking due to
                // the extra whitespace.
                var preDelay = 150;
                setTimeout(function() {
                    var pixelsPerSecond = 500;
                    var animSpeed = visibleHeightDifference / pixelsPerSecond * 1000;
                    $tabContents.animate({
                        height: newContentHeight
                    }, animSpeed, 'easeOutQuart', function() {
                        $tabContents.css('height', 'auto');
                    });
                }, preDelay);
            } else {
                $tabContents.empty().append(newContents);
            }

            // jQuery pulls out inline <script> elements from the hierarchy and places them at the top level
            // Execute any such scripts at the end
            jQuery(newElements.querySelectorAll('script')).each(function() {
                jQuery.globalEval(this.text || this.textContent || this.innerHTML || '');
            });
        } else {
            container.empty().append(newElements);
        }
    }

    /**
     * Appends "#issue-tabs" to each activity module link, in order to
     * maintain the legacy behaviour.
     */
    function appendHashCodeToLinks(context) {
        jQuery(context).find(AJAX_LINK_SELECTOR).each(function () {
            var $a = jQuery(this);

            $a.attr('href', $a.attr('href') + '#issue-tabs');
        });
    }

    /**
     * Either appends "#issue-tabs" to each link or PJAXifies them, depending
     * on whether the browser supports the pushState API.
     */
    function processActivityModuleLinks(context) {
        if (!useHistoryApi || jQuery.support.pjax) {
            enableAjaxOnLinks(context);
        } else {
            appendHashCodeToLinks(context);
        }
    }

    function setupMouseoverBehaviour(context) {
        jQuery(context).bind("moveToFinished", function (event, target) {
            jQuery("a.twixi:visible", target).focus();
        });
    }

    function initLivestamp(context) {
        context.find("time.livestamp").livestamp();
    }

    function onTabReady(listener) {
        // Prevent duplicate listeners.
        if (jQuery.inArray(listener, issueTabLoadedListeners) < 0) {
            issueTabLoadedListeners.push(listener);
        }
    }

    // sprinkle AJAX magic all over the tab links after they are loaded
    onTabReady(bindToTabDivs);
    onTabReady(processActivityModuleLinks);
    onTabReady(setupMouseoverBehaviour);
    onTabReady(Userhover);
    onTabReady(initLivestamp);

    /**
     * @borrows onTabReady
     * @borrows dispatchIssueTabLoadedEvent as domReady
     */
    return {
        onTabReady: onTabReady,
        domReady: dispatchIssueTabLoadedEvent
    };
});

AJS.namespace('JIRA.ViewIssueTabs', null, require('jira/viewissue/tabs'));
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/initViewIssueTabs.js' */
(function () {
    var jQuery =  require('jquery');
    var Events =  require('jira/util/events');
    var Types =  require('jira/util/events/types');
    var Tabs = require('jira/viewissue/tabs');

    jQuery(function () {
        // Remembering focused activity after we refresh panel
        if (Types.PANEL_REFRESHED) {
            // kickass
            Events.bind(Types.PANEL_REFRESHED, function (e, panel, $new, $existing) {
                if (panel === "activitymodule") {
                    var $focusedTab = $existing.find("#issue_actions_container > .issue-data-block.focused");
                    //assume only one focused tab
                    if ($focusedTab.length === 1) {
                        $new.find("#" + $focusedTab.attr("id")).addClass("focused");
                    }
                }
            });
        }
    });

    Events.bind(Types.NEW_CONTENT_ADDED, function(event, $el) {
        Tabs.domReady($el);
    });
})();;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/initViewissue.js' */
require([
    'jira/viewissue/element/shorten',
    'jira/viewissue/element/image-wrap'
], function() {
    // View issue components initialised
});
;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:asynchronous-attachment-expansion', location = 'viewissue/attachment/attachment-contents-view.js' */
/**
 * @module jira/view-issue-plugin/attachment/attachment-contents-view
 * @requires module:jira/view-issue-plugin/lib/marionette
 */
define('jira/view-issue-plugin/attachment/attachment-contents-view', [
    'jira/view-issue-plugin/lib/marionette'
], function defineAttachmentContentsView(Marionette) {
    'use strict';

    return Marionette.ItemView.extend({
        template: JIRA.Templates.ViewIssue.attachmentContents,

        initialize: function initialize(options) {
            this.attachment = options.attachment;
            this.issueId = options.issueId;
            this.baseUrl = options.baseUrl;
        },

        serializeData: function serializeData() {
            return {
                attachment: this.attachment,
                issueId: this.issueId,
                baseUrl: this.baseUrl
            };
        }

    });
});

/**
 * @module jira/attachment/attachment-contents-view
 * @deprecated use {@link module:jira/view-issue-plugin/attachment/attachment-contents-view}
 */
define('jira/attachment/attachment-contents-view', ['jira/view-issue-plugin/attachment/attachment-contents-view'], function(View) { return View; });
;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:asynchronous-attachment-expansion', location = 'viewissue/attachment/attachment-element.js' */
/**
 * @module jira/view-issue-plugin/attachment/attachment-element
 *
 * @requires module:jira/attachment/attachment-contents-view
 * @requires module:jira/viewissue/slideshow/slideshow-configuration
 * @requires module:jira/view-issue-plugin/lib/marionette
 * @requires module:jira/skate
 * @requires external:jQuery
 */
define('jira/view-issue-plugin/attachment/attachment-element', [
    'jquery',
    'jira/skate',
    'jira/viewissue/slideshow/slideshow-configuration',
    'jira/view-issue-plugin/lib/marionette',
    'jira/attachment/attachment-contents-view'
], function($, skate, galleryOpts, Marionette, AttachmentContentsView) {
    'use strict';

    /**
     * @skate js-file-attachment
     */
    return skate('js-file-attachment', {
        type: skate.type.CLASSNAME,
        attached: function elementAttachedHandler(element) {
            $(element).find('.expander').one('expandBlock', function elementExpandedHandler() {
                expandArchive(element);
            });
            JIRA.trace('jira.plugins.viewissue.expansion.wired');
        },
        events: {
            'click .attachment-title': function elementClickedHandler(element, e) {
                if (e.which !== 1) {
                    return;
                }
                var $thumb = element.getThumbnailImage();
                if ($thumb.length) {
                    $thumb.click();
                    e.preventDefault();
                }
            }
        },
        prototype: {
            getThumbnailImage: function() {
                var element = this;
                return $('.gallery', element);
            }
        }
    });

    function expandArchive(element) {
        var $attachmentRow = $(element);
        var attachmentId = $attachmentRow.data('attachment-id');
        var issueId = $attachmentRow.data('issue-id');
        var expansionResource = AJS.contextPath() + "/rest/api/2/attachment/" + attachmentId + "/expand/human";
        var promise = $.get(expansionResource);
        promise.done(function renderAttachmentContents(data) {
            var region = new Marionette.Region({
                el: $attachmentRow.find('.zip-contents').first()
            });
            var view = new AttachmentContentsView({
                attachment: data,
                issueId: issueId,
                baseUrl: window.location.protocol + "//" + window.location.host + AJS.contextPath()
            });
            region.show(view);
        });
        promise.error(function handleAttachmentExpansionError(data) {
            console.error(data);
        });
    }

});
;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:asynchronous-attachment-expansion', location = 'viewissue/attachment/attachment.soy' */
// This file was automatically generated from attachment.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ViewIssue.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ViewIssue == 'undefined') { JIRA.Templates.ViewIssue = {}; }


JIRA.Templates.ViewIssue.attachmentContents = function(opt_data, opt_ignored) {
  var output = '<ol class="archive-expanded">';
  var entries__soy4 = opt_data.attachment.entries;
  var entryList5 = entries__soy4;
  var entryListLen5 = entryList5.length;
  for (var entryIndex5 = 0; entryIndex5 < entryListLen5; entryIndex5++) {
    var entryData5 = entryList5[entryIndex5];
    output += JIRA.Templates.ViewIssue.attachmentArchiveEntry(soy.$$augmentMap(opt_data, {entry: entryData5}));
  }
  output += ((opt_data.attachment.totalEntryCount == 0) ? '<li><div class="aui-message aui-message-warning" style="display: inline-block"><p>' + soy.$$escapeHtml("This archive is either corrupt, empty or not an archive at all") + '.</p></div></li>' : '') + '</ol><span class="zip-contents-trailer">' + ((entries__soy4.length < opt_data.attachment.totalEntryCount) ? '<span class="limit-info">' + soy.$$escapeHtml(AJS.format("Showing {0} of {1} items",entries__soy4.length,opt_data.attachment.totalEntryCount)) + ' </span>' : '');
  var attachmentUrl__soy20 = soy.$$escapeHtml(opt_data.baseUrl) + '/secure/attachment/' + soy.$$escapeHtml(opt_data.attachment.id) + '/';
  output += '<a href="' + soy.$$escapeHtml(attachmentUrl__soy20) + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(opt_data.attachment.mediaType) + ':' + soy.$$escapeHtml(opt_data.attachment.name) + ':' + soy.$$escapeHtml(attachmentUrl__soy20) + '">' + soy.$$escapeHtml("Download Zip") + '</a></span>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.attachmentContents.soyTemplateName = 'JIRA.Templates.ViewIssue.attachmentContents';
}


JIRA.Templates.ViewIssue.attachmentArchiveEntry = function(opt_data, opt_ignored) {
  var output = '';
  var entryUrl__soy37 = soy.$$escapeHtml(opt_data.baseUrl) + '/secure/attachmentzip/unzip/' + soy.$$escapeHtml(opt_data.issueId) + '/' + soy.$$escapeHtml(opt_data.attachment.id) + '%5B' + soy.$$escapeHtml(opt_data.entry.index) + '%5D/';
  var entryDownloadUrl__soy49 = soy.$$filterNoAutoescape(opt_data.entry.mediaType) + ':' + soy.$$filterNoAutoescape(opt_data.entry.path) + ':' + soy.$$filterNoAutoescape(entryUrl__soy37);
  output += '<li class="archive-entry" data-entry-index="' + soy.$$escapeHtml(opt_data.entry.index) + '"><div class="attachment-thumb"><a href="' + soy.$$escapeHtml(entryUrl__soy37) + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(entryDownloadUrl__soy49) + '"' + JIRA.Templates.ViewIssue.tagFilePreview({id: opt_data.attachment.id + '/' + opt_data.entry.index, title: opt_data.entry.label, mimeType: opt_data.entry.mediaType}) + '>' + JIRA.Templates.ViewIssue.renderAttachmentIcon({mimetype: opt_data.entry.mediaType, baseurl: opt_data.baseUrl}) + '</a></div><a class="file-path" href="' + soy.$$escapeHtml(entryUrl__soy37) + '" title="' + soy.$$escapeHtml(opt_data.entry.path) + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(entryDownloadUrl__soy49) + '"' + JIRA.Templates.ViewIssue.tagFilePreview({id: opt_data.attachment.id + '/' + opt_data.entry.index, title: opt_data.entry.label, mimeType: opt_data.entry.mediaType}) + '>' + soy.$$escapeHtml(opt_data.entry.label) + '</a><span class="attachment-size">' + soy.$$escapeHtml(opt_data.entry.size) + '</span></li>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.attachmentArchiveEntry.soyTemplateName = 'JIRA.Templates.ViewIssue.attachmentArchiveEntry';
}
;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:draggableattachment', location = 'viewissue/initDraggableAttachment.js' */
define('jira/view-issue-plugin/init-draggable-attachment', ['jquery'], function($) {
    $.event.props.push("dataTransfer");

    $('[draggable=true]').live("dragstart", function(evt) {
        var $this = $(this);
        var dataTransfer = evt.dataTransfer;
        dataTransfer.effectAllowed = 'copy';
        dataTransfer.dropEffect = 'copy';
        dataTransfer.setData("DownloadURL", $this.data('downloadurl'));
        if (!$this.find('img').length) {
            dataTransfer.setDragImage($this.closest('li').find('img:visible')[0], 8, 8);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:analytics', location = 'viewissue/analytics.js' */
/**
 * Reports bulk move events to analytics.
 */
define('jira/view-issue-plugin/analytics', ['jquery'], function ($) {
    var $doc = $(document);

    $doc.on('click', '#subtasks-bulk-operation', function () {
        AJS.trigger('analyticsEvent', {name: "jira.bulk.move.click.subtasks-bulk-operation"});
    });
    $doc.on('click', '#subtasks-open-issue-navigator', function () {
        AJS.trigger('analyticsEvent', {name: "jira.bulk.move.click.subtasks-open-issue-navigator"});
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:initialiser', location = 'viewissue/initViewIssue.js' */
require([
    'jira/view-issue-plugin/attachment/attachment-element',
    'jira/view-issue-plugin/init-draggable-attachment',
    'jira/view-issue-plugin/analytics'
]);
;
;
/* module-key = 'com.atlassian.jira.jira-quick-edit-plugin:loading-indicator', location = 'js/util/loading-indicator.js' */
define('quick-edit/util/loading-indicator',[
    'jira/loading/loading',
    'jira/flag'
], function (
    Loading,
    Flag
) {
    var dim = AJS.dim;
    var undim = AJS.undim;

    return {
        showLoadingIndicator: function () {
            dim();
            Loading.showLoadingIndicator();
        },

        hideLoadingIndicator: function (showErrorFlag) {
            undim();
            Loading.hideLoadingIndicator();
            if (showErrorFlag) {
                Flag.showErrorMsg(null, "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.");
            }
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.jira-quick-edit-plugin:quick-edit-issue-bootstrap', location = 'js/init/edit-bootstrap-wrm.js' */
require([
    'jquery',
    'underscore',
    'wrm/require',
    'quick-edit/util/loading-indicator',
    'jira/ajs/keyboardshortcut/keyboard-shortcut-toggle'
], function (
    jQuery,
    _,
    wrmRequire,
    LoadingIndicator,
    KeyboardShortcutToggle
) {
        var showLoadingIndicator = function () {
            KeyboardShortcutToggle.disable();
            LoadingIndicator.showLoadingIndicator();
        };
        var hideLoadingIndicator = function () {
            LoadingIndicator.hideLoadingIndicator(true);
            KeyboardShortcutToggle.enable();
        };

        var dialog;
        var bootstrapFunction = function (event) {
            event.preventDefault();
            showLoadingIndicator();
            var resourceKey = 'wr!com.atlassian.jira.jira-quick-edit-plugin:quick-edit-issue';
            var wrmRequireDeferred = wrmRequire([resourceKey]);
            wrmRequireDeferred.then(function () {
                var initEditDialogFactory = require('quick-edit/init/edit');
                // Creates edit issue dialog
                if (!dialog) {
                    dialog = initEditDialogFactory.initDialog();
                }
                dialog._events.trigger.simpleClick.call(dialog, event, jQuery(event.target));
                KeyboardShortcutToggle.enable();
            }, function onFail() {
                hideLoadingIndicator();
            });
        };

        jQuery(document).delegate('.issueaction-edit-issue', 'click', bootstrapFunction);
});


;
;
/* module-key = 'jira.webresources:attach-screenshot-resources', location = '/includes/jira/issue/attachScreenshot.js' */

AJS.namespace('JIRA.Issue.AttachScreenshot');

(function initializeAttachScreenshot () {
    "use strict";

    AJS.EventQueue = AJS.EventQueue || [];

    // Atlassian Analytics - Capture 'Attach Screenshot' click events for Java Applet
    AJS.$(document).on("click", "#attach-screenshot", function () {
        AJS.EventQueue.push({
            name: "attach.screenshot.display",
            properties: {}
        });
    });
})();;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:hipchat-user-link-support', location = 'user/hipchat-user-link.js' */
AJS.toInit(function ($) {

    var Routes = {
        removeLink: AJS.contextPath() + '/rest/hipchat/integration/latest/oauth2'
    };

    var pluginKey = "com.atlassian.plugins.base-hipchat-integration-plugin";
    var wrmData = WRM.data instanceof Function ? WRM.data : WRM.data.claim;
    var userLinkContext = wrmData(pluginKey + ":hipchat-user-link-support.user-link-context");
    function getRedirect() {
        var location = window.location;
        var contextPath = AJS.contextPath();
        var path = location.pathname;
        if(path.indexOf(contextPath) === 0) {
            path = path.substr(contextPath.length);
        }
        var query = location.search;
        if(query) {
            query = query.substr(1); // remove leading ?
        }
        return {
            path: path,
            query: query
        };
    }

    function doRedirect(hipchatOauthUri) {
        window.location.assign(hipchatOauthUri);
    }

    function getFragmentFrom(container){

        if(container){
            var redirectHash = container.attr("href");
            if(redirectHash !== undefined &&
                    redirectHash.length > 1 &&
                    redirectHash.indexOf("#") === 0){
                return redirectHash.substr(1); // We remove the hash
            }
        }
        return "";
    }

    var centerSpinner = function() {
        var center = $("<div></div>");
        center.css({
            position: "fixed",
            left: "50%",
            top: "50%"
        });
        $("body").append(center);
        center.spin("large");
    };

    /**
     * Starts the user link process.
     *
     * @param e the event if initiated by an event (optional).
     *          Meant to preventing the default behaviour of the event.
     */
    var startUserLink = function (e) {
        var redirect = getRedirect();
        var postData = {
            url: userLinkContext.beginOauth,
            type: "POST",
            dataType: 'json',
            contentType: 'application/json',
            data: JSON.stringify({
                redirect: redirect.path,
                redirectQuery: redirect.query,
                redirectFragment : e && e.target && getFragmentFrom($(e.target))
            })
        };

        $.ajax(postData)
            .done(doRedirect);

        e && e.preventDefault && e.preventDefault();

        centerSpinner();
    };

    $(document).on('click', '.hipchat-user-link', startUserLink);

    var userUnlink = function (e) {
        var deleteData = {
            url: Routes.removeLink,
            type: 'DELETE',
            contentType: 'application/json'
        };
        $.ajax(deleteData)
            .always(function() {
                window.location.reload();
            });
        e && e.preventDefault && e.preventDefault();

        centerSpinner();
    };

    $(document).delegate('.hipchat-user-unlink', 'click', userUnlink);

    // exports
    window.HipChat = window.HipChat || {};
    window.HipChat.UserLink = window.HipChat.UserLink || {};
    window.HipChat.UserLink.context = userLinkContext;
    window.HipChat.UserLink.linkUser = startUserLink;
    window.HipChat.UserLink.unlinkUser = userUnlink;
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:hipchat-links-support', location = 'links/hipchat-links.js' */
/**
 * this script will be used to redirect to the web client
 * or the hipchat client depending on the user preferences.
 * We are going to store this in a cookie to avoid problems if the
 * user changes from computer.
 *
 * hipchat-room-link-url will need api-url, room-id, user-id
 */
(function ($) {

    var HIPCHAT_NATIVE_LINK_ENABLED = "HIPCHAT_NATIVE_LINK_ENABLED";

    function isHipChatNativeLinkEnabled() {
        return AJS.Cookie.read(HIPCHAT_NATIVE_LINK_ENABLED) === "true";
    }

    function getDomainFromUrl(url) {
        var tmp = document.createElement('a');
        tmp.href = url;
        return tmp.hostname;
    }

    function createUrl(baseUrl, path) {
        return baseUrl + (endsWith(baseUrl, "/") ? "" : "/") + path;
    }

    function endsWith(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }

    function sendAnalyticEvent() {
        var linkType = isHipChatNativeLinkEnabled() ? "inapp" : "web";
        var nativeEnabled = navigator.platform.toUpperCase().indexOf('MAC') >= 0 ? "native.enabled" : "native.disabled";
        var metric  = 'notifications.hipchat.link.clicked.' + linkType  + '.' + nativeEnabled;
        AJS.trigger('analyticsEvent', {name: metric});
    }

    function findTheRightElement(element, tagName) {
        var levels = 2;
        while (levels > 0 && element.prop("tagName").toLowerCase() !== tagName.toLowerCase()) {
            element = element.parent();
            levels--;
        }
        return element;
    }

    $(document).on("click", ".hipchat-room-link-url", function (event) {

        event.preventDefault();

        var target = findTheRightElement($(event.target), "A");
        var url = target.data("api-url");
        var roomId = target.data("room-id");

        if (isHipChatNativeLinkEnabled()) {
            window.location = "hipchat://" + getDomainFromUrl(url) + "/room/" + roomId;
        } else {
            window.open(createUrl(url, "chat/room/" + roomId), "hipchat");
        }

        sendAnalyticEvent();
    });


    $(document).on("click", ".hipchat-user-link-url", function (event) {

        event.preventDefault();

        var target = findTheRightElement($(event.target), "A");
        var url = target.data("api-url");
        var userId = target.data("user-id");

        if (isHipChatNativeLinkEnabled()) {
            window.location = "hipchat://" + getDomainFromUrl(url) + "/user/" + userId;
        } else {
            window.open(createUrl(url, "chat/user/" + userId), "hipchat");
        }

        sendAnalyticEvent();
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:almond', location = 'lib/amd/almond-noconflict-pre.js' */
window.__require = window.require;
window.__requirejs = window.requirejs;
window.__define = window.define;
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:almond', location = 'lib/amd/almond.js' */
/**
 * MODIFIED BY ATLASSIAN
 *
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

//    ATLASSIAN PATCH (CQ-102)
//    define.amd = {
//        jQuery: true
//    };
//    END ATLASSIAN PATCH
}());
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:almond', location = 'lib/amd/almond-noconflict-post.js' */
// noConflict
if (window.__require) {
    window.require = window.__require;
    window.requirejs = window.__requirejs;
    window.define = window.__define;
} else {
    // Patch our own version of Almond.
    //
    // If "define.amd" is truthy, some 3rd-party libs (e.g. jQuery, spin.js)
    // automatically register themselves via define(). We don't want that,
    // we'll take care of calling define() for each lib.
    delete window.define.amd;
}

// IE8 doesn't support delete window.?
try { delete window.__require; } catch (e) { window.__require = undefined; }
try { delete window.__requirejs; } catch (e) { window.__requirejs = undefined; }
try { delete window.__define; } catch (e) { window.__define = undefined; }
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:almond', location = 'lib/amd/ajs-amd.js' */
define("ajs", function () {
    return AJS;
});;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:wrm-amd', location = 'lib/amd/wrm-amd.js' */
define("wrm", function () {

    if (WRM.data instanceof Function) {
        // WRM.data.claim does not exist in 5.3
        WRM.data.claim = WRM.data;
    }

    return WRM;
});;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:backbone-amd', location = 'lib/amd/backbone-amd.js' */
define("backbone", function () {
    return Backbone;
});;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:jquery-amd', location = 'lib/amd/jquery-amd.js' */
define('jquery', function () {
    return AJS.$;
});;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:underscore-amd', location = 'lib/amd/underscore-amd.js' */
define('underscore', function () {
    return _;
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:configure-integration-data', location = 'admin/configure-integration-data.js' */
define('hipchat/admin/configure-integration-data', [
    'jquery'
], function (
    $
) {
    var pluginKey = "com.atlassian.plugins.base-hipchat-integration-plugin";
    var resourceKey = "configure-integration-data";
    var providerKey = "configure-integration";
    var wrmData = WRM.data instanceof Function ? WRM.data : WRM.data.claim;
    var context = wrmData(pluginKey + ":" + resourceKey + "." + providerKey);
    return context;
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:connection-status-resources', location = 'feature/connectionstatus/connectionstatus.soy' */
// This file was automatically generated from connectionstatus.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace HipChat.Templates.Configuration.ConnectionStatus.
 */

if (typeof HipChat == 'undefined') { var HipChat = {}; }
if (typeof HipChat.Templates == 'undefined') { HipChat.Templates = {}; }
if (typeof HipChat.Templates.Configuration == 'undefined') { HipChat.Templates.Configuration = {}; }
if (typeof HipChat.Templates.Configuration.ConnectionStatus == 'undefined') { HipChat.Templates.Configuration.ConnectionStatus = {}; }


HipChat.Templates.Configuration.ConnectionStatus.status = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<h6 class="hipchat-connection-status-container">' + ((opt_data.label) ? soy.$$escapeHtml(opt_data.label) : soy.$$escapeHtml("Connection status")) + '<span class="hipchat-connection-status"></span></h6>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.status.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.status';
}


HipChat.Templates.Configuration.ConnectionStatus.lozenge = function(opt_data, opt_ignored) {
  return '<' + soy.$$escapeHtml(opt_data.tagName ? opt_data.tagName : 'span') + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ((opt_data.title) ? ' title="' + soy.$$escapeHtml(opt_data.title) + '"' : '') + ' class="aui-lozenge' + soy.$$escapeHtml(opt_data.type ? ' aui-lozenge-' + opt_data.type : '') + soy.$$escapeHtml(opt_data.isSubtle ? ' aui-lozenge-subtle' : '') + '">' + ((opt_data.maxLength) ? soy.$$truncate(soy.$$escapeHtml(opt_data.text), opt_data.maxLength, true) : soy.$$escapeHtml(opt_data.text)) + '</' + soy.$$escapeHtml(opt_data.tagName ? opt_data.tagName : 'span') + '>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.lozenge.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.lozenge';
}


HipChat.Templates.Configuration.ConnectionStatus.connectedStatus = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.ConnectionStatus.lozenge({text: "Connected", type: 'success', isSubtle: true, extraClasses: opt_data.extraClasses});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.connectedStatus.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.connectedStatus';
}


HipChat.Templates.Configuration.ConnectionStatus.partialConnectivityStatus = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.ConnectionStatus.lozenge({text: "Limited", type: 'current', isSubtle: true, extraClasses: opt_data.extraClasses});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.partialConnectivityStatus.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.partialConnectivityStatus';
}


HipChat.Templates.Configuration.ConnectionStatus.unknownStatus = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.ConnectionStatus.lozenge({text: "Unknown", type: '', isSubtle: true, extraClasses: opt_data.extraClasses});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.unknownStatus.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.unknownStatus';
}


HipChat.Templates.Configuration.ConnectionStatus.notConnectedStatus = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.ConnectionStatus.lozenge({text: "Not connected", type: 'error', isSubtle: true, extraClasses: opt_data.extraClasses});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.notConnectedStatus.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.notConnectedStatus';
}


HipChat.Templates.Configuration.ConnectionStatus.oauthFailureStatus = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.ConnectionStatus.lozenge({text: "Oauth Failure", type: 'error', isSubtle: true, extraClasses: opt_data.extraClasses});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.oauthFailureStatus.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.oauthFailureStatus';
}


HipChat.Templates.Configuration.ConnectionStatus.connectivityTooltip = function(opt_data, opt_ignored) {
  return '<div class="hipchat-connection-status-tooltip"><h6>' + soy.$$escapeHtml(opt_data.title) + '</h6><p>' + soy.$$filterNoAutoescape(opt_data.description) + '</p>' + ((opt_data.link) ? '<p><a href="' + soy.$$escapeHtml(opt_data.link.href) + '">' + soy.$$escapeHtml(opt_data.link.text) + '</a></p>' : '') + '</div>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.connectivityTooltip.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.connectivityTooltip';
}
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:connection-status-resources', location = 'feature/connectionstatus/connectionstatus.js' */
require([
    "jquery"
], function (
    $
) {
    var connectionStatusTemplateMap = {
        "CONNECTED": "connectedStatus",
        "PARTIAL_CONNECTIVITY": "partialConnectivityStatus",
        "NOT_CONNECTED": "notConnectedStatus",
        "UNKNOWN": "unknownStatus",
        "OAUTH_FAILURE": "oauthFailureStatus"
    };

    var connectionStatusViews = {
        "CONNECTED": {
            status: HipChat.Templates.Configuration.ConnectionStatus.connectedStatus
        },
        "PARTIALLY_CONNECTED": {
            status: HipChat.Templates.Configuration.ConnectionStatus.partialConnectivityStatus,
            toolTipTitle: "Connectivity issues",
            toolTipDescription: "HipChat cannot connect to your JIRA server - it may be behind a firewall. \u003cbr\u003e You can still receive messages from JIRA in HipChat, but some functionality (such as Issue Preview) may not work."
        },
        "NO_CONNECTION": {
            status: HipChat.Templates.Configuration.ConnectionStatus.notConnectedStatus,
            toolTipTitle: "Connectivity issues",
            toolTipDescription: "Could not connect to the HipChat server. Integration features will be unavailable until the connection is restored."
        },
        "UNKNOWN": {
            status: HipChat.Templates.Configuration.ConnectionStatus.unknownStatus,
            toolTipTitle: "\u00af\\_(\u30c4)_/\u00af",
            toolTipDescription: "We cannot determine the connection status. You\'re probably using an old version of HipChat."
        },
        "OAUTH_FAILURE": {
            status: HipChat.Templates.Configuration.ConnectionStatus.oauthFailureStatus,
            toolTipTitle: "Error authenticating with HipChat",
            toolTipDescription: "The integration may have been removed from HipChat. Please remove and reinstall the integration in JIRA."
        }
    };

    function getViewDataForStatus(data) {
        var view = connectionStatusViews[data];
        if (view === undefined) {
            view = connectionStatusTemplateMap.UNKNOWN;
        }

        return view;
    }

    function getConnectionStatusHtml(data) {
        var view = getViewDataForStatus(data);

        return view.status({extraClasses: view.toolTipDescription !== undefined ? "has-tooltip" : ""});
    }

    function getConnectionStatus() {
        return $.ajax({
            url: AJS.contextPath() + "/rest/hipchat/integration/1.0/connection-status",
            cache: false,
            dataType: 'json',
            type: "GET"
        });
    }

    function initConnectionStatusTooltip($connectionStatus, data) {
        var viewData = getViewDataForStatus(data);
        if (viewData.toolTipDescription !== undefined) {
            AJS.InlineDialog($connectionStatus, "connection-status-tooltip", function (content, trigger, showPopup) {

                var html = HipChat.Templates.Configuration.ConnectionStatus.connectivityTooltip({
                    title: viewData.toolTipTitle,
                    description: viewData.toolTipDescription,
                    link: viewData.toolTipLink
                });
                content.html(html);

                showPopup();
            }, {
                onHover: true,
                gravity: 'w'
            });
        }
    }

    function updateConnectionStatus(status) {
        var $connectionStatus = $(".hipchat-connection-status");
        $connectionStatus.html(getConnectionStatusHtml(status));
        initConnectionStatusTooltip($connectionStatus, status);
    }

    AJS.toInit(function($) {
        var $connectionStatus = $(".hipchat-connection-status");
        if ($connectionStatus.length > 0) {
            $connectionStatus.spin();
            getConnectionStatus().done(function(status) {
                updateConnectionStatus(status);
            }).fail(function() {
                updateConnectionStatus("UNKNOWN");
            }).always(function() {
                $connectionStatus.spinStop();
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:integration-steps-resources', location = 'feature/invites/invite-hipchat-enabler.js' */
define('hipchat/invite/enabler', [
    'jquery'
], function (
    $
) {

    var INVITE_VISITED_KEY = "hipchat-invite-visited";
    var enableInviteData = null;
    var discoveryDisabled = false;

    function enableInviteButtonIfFreePlan() {
        if (!enableInviteData) {
            var pluginKey = "com.atlassian.plugins.base-hipchat-integration-plugin";
            var wrmData = WRM.data instanceof Function ? WRM.data : WRM.data.claim;
            enableInviteData = wrmData(pluginKey + ":integration-steps-resources.enable-invite");
        }
        if (!enableInviteData.inviteToHipChatEnabled) {
            return;
        }
        var isInvitationsToGroupAllowedURI = enableInviteData.isInvitationsToGroupAllowedURI;
        $.ajax(isInvitationsToGroupAllowedURI, {
            type: "GET"
        })
            .done(function (isInvitationsToGroupAllowedURI) {
                var inviteButton = $('#hipchat-invite-button');
                inviteButton.click(handleInvitePageVisit);

                if (isInvitationsToGroupAllowedURI && isInvitationsToGroupAllowedURI.free) {
                    inviteButton.removeClass("hidden");
                    conditionallyShowInviteDiscovery(inviteButton);
                } else {
                    $("#hipchat-integration-invite-step-normal-text").hide({
                        complete: function() {
                            $("#hipchat-integration-invite-step-unable-text").show();
                        }
                    });
                }
            });
    }

    function handleInvitePageVisit() {
        try {
            AJS.Cookie.save(INVITE_VISITED_KEY, "true");
        } catch (e) {
            discoveryDisabled = true;
        }
    }

    function hasVistedInvitePage() {
        try {
            var visited = AJS.Cookie.read(INVITE_VISITED_KEY);
            return visited;
        } catch (e) {
            discoveryDisabled = true;
        }
    }

    function conditionallyShowInviteDiscovery(inviteButton) {
        if (AJS.HelpTip && !hasVistedInvitePage() && !discoveryDisabled) {
            var inviteUsersHelpTip = new AJS.HelpTip({
                id: 'hipchat-invite-user-help',
                title: 'Invite users to HipChat',
                bodyHtml: "If you would like to invite users in the future, click here.",
                anchor: inviteButton
            });
            inviteUsersHelpTip.show();
            inviteUsersHelpTip.view.popup.addClass('hipchat-invite-user-help');
        }
    }

    return {
        enableInviteButtonIfFreePlan: enableInviteButtonIfFreePlan
    }
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:integration-steps-resources', location = 'feature/integrationsteps/integrationsteps.js' */
require([
    'hipchat/invite/enabler'
], function (
    hipchatInviteEnabler
) {
    AJS.toInit(function($) {
        var $steps = $(".hipchat-integration-steps");

        $steps.on('mapping-added.integration-steps', function () {
            $steps.addClass("complete");
            hipchatInviteEnabler.enableInviteButtonIfFreePlan();
        });

        var inviteButtonWaitingForMapping = $('#inviteButtonWaitingForMapping').val();
        if (inviteButtonWaitingForMapping === 'false') {
            hipchatInviteEnabler.enableInviteButtonIfFreePlan();
        }
    });
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:invites-soy-resources', location = 'feature/invites/invite-hipchat-client.soy' */
// This file was automatically generated from invite-hipchat-client.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace HipChat.Templates.Configuration.
 */

if (typeof HipChat == 'undefined') { var HipChat = {}; }
if (typeof HipChat.Templates == 'undefined') { HipChat.Templates = {}; }
if (typeof HipChat.Templates.Configuration == 'undefined') { HipChat.Templates.Configuration = {}; }


HipChat.Templates.Configuration.inviteeList = function(opt_data, opt_ignored) {
  return '<ul class="hipchat-invitee-list"></ul>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.inviteeList.soyTemplateName = 'HipChat.Templates.Configuration.inviteeList';
}


HipChat.Templates.Configuration.invitee = function(opt_data, opt_ignored) {
  var output = '';
  var userUrl__soy5 = '' + HipChat.Templates.Invite.Support.userLinkUrl(opt_data);
  output += '<li class="hipchat-invitee" data-username="' + soy.$$escapeHtml(opt_data.username) + '"><img class="hipchat-invitee-avatar" src="' + soy.$$escapeHtml(opt_data.avatarUrl) + '"><div class="lines"><div class="line hipchat-invitee-name-container" title="' + soy.$$escapeHtml(opt_data.fullname) + '"><a href="' + soy.$$escapeHtml(userUrl__soy5) + '" class="hipchat-invitee-name invitee-line-1" target="_blank">' + soy.$$escapeHtml(opt_data.fullname) + '</a></div><div class="line"><span data-invite-processing="running" class="aui-lozenge aui-lozenge-current aui-lozenge-subtle hidden">' + soy.$$escapeHtml("inviting...") + '</span>' + ((opt_data.email) ? '<div class="email-container" title="' + soy.$$escapeHtml(opt_data.email) + '"><span class="email">' + soy.$$escapeHtml(opt_data.emailDomain) + '</span></div>' : '<span>&nbsp;</span>') + '<span class="aui-lozenge aui-lozenge-current aui-lozenge-subtle" style="display:none"></span><span class="aui-lozenge aui-lozenge-success aui-lozenge-subtle" style="display:none"></span></div></div><div class="icon-holder"><button class="remove-invite-button aui-button aui-button-link">' + aui.icons.icon({useIconFont: true, icon: 'remove'}) + '</button></div><div class="status-icon-holder"><span class="aui-icon aui-icon-small aui-iconfont-approve success"> </span><span class="aui-icon aui-icon-small aui-iconfont-error failure"> </span></div></li>';
  return output;
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.invitee.soyTemplateName = 'HipChat.Templates.Configuration.invitee';
}
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:resources', location = 'admin/configure-hipchat.js' */
require([
        'hipchat/admin/configure-integration-data'
    ],

    function (integrationData) {
        'use strict';

        AJS.toInit(function ($) {
            "use strict";

            /**
             * Hipchat configuration state
             * @type {String} The current configuration state of hipchat
             */
            var state = $("#hipchat-integration-configuration").val();

            var localStorage = window.localStorage;

            // If the state element is not present, do not load the rest as this is
            //   the wrong page
            if (state) {

                /**
                 * Routes used in directing requests/redirects
                 */
                var routes = {
                    self: $("#hipchat-route-config").val(),
                    serverPing: $("#hipchat-route-check-server-connectivity").val(),
                    clientPing: $("#hipchat-route-check-client-connectivity").val(),
                    beginInstall: $("#hipchat-route-begin-install").val(),
                    completeInstall: $("#hipchat-route-complete-install").val(),
                    installableUrl:  $("#hipchat-route-installable-url").val(),
                    uninstall: $("#hipchat-route-uninstall").val(),
                    redirectUrl: $("#hipchat-route-redirectUrl").val()
                };

                /**
                 * Resource urls
                 */
                var resources = {
                    screenshotResource: $("#hipchat-server-resource-screenshot").val(),
                    screenshotResource2x: $("#hipchat-server-resource-screenshot-2x").val(),
                    uninstalling: $("#hipchat-server-resource-uninstalling").val()
                };

                /**
                 * Misc other values/imports
                 */
                var Templates = HipChat.Templates.Configuration;
                var panel = $("#hipchat-configuration-panel");
                if (integrationData.link) {
                    var linkId = integrationData.link.id;
                }

                /**
                 * All views for this page
                 */
                var Views = (function () {
                    var confirmDialog;

                    return {
                        /**
                         * Load configure template
                         */
                        installing: function () {
                            $('#hipchat-installing .hipchat-install-message').spin('large');
                        },
                        /**
                         * Load error template
                         * @param msg {String} Error message to display
                         */
                        error: function (msg) {
                            panel.html(Templates.error({msg: msg}));
                        },
                        /**
                         * Load uninstall error template
                         */
                        uninstallError: function (msg) {
                            if (msg.status == 401) {
                                panel.html(Templates.uninstallPermissionError());
                            } else {
                                panel.html(Templates.uninstallConnectionError());
                            }
                        },
                        /**
                         * Confirms removal of the link to HipChat
                         *
                         * @return promise resolved if the user confirms removed, rejected if they cancel
                         */
                        confirmUninstall: function () {
                            var deferred = $.Deferred();

                            if (!confirmDialog) {
                                // TODO CONFDEV-28519 ADG 2 - new confirmation dialog (and remove related CSS)
                                confirmDialog = new AJS.Dialog(600, 300, "hipchat-remove-link-dialog");
                                confirmDialog.addHeader("Remove integration", "remove-warning");
                                confirmDialog.addPanel("Message Panel", Templates.removeLinkMessage());
                                confirmDialog.addButton("Remove integration", function () {
                                    confirmDialog.hide();
                                    Views.uninstall();
                                    deferred.resolve();
                                });
                                confirmDialog.addCancel("Cancel", function () {
                                    confirmDialog.hide();
                                    deferred.reject();
                                });
                            }
                            confirmDialog.show();

                            return deferred.promise();
                        },
                        uninstall: function () {
                            panel.html(Templates.uninstalling({
                                uninstallingImage: resources.uninstalling
                            }));
                            $('#hipchat-uninstalling .hipchat-install-message').spin('large');
                        },
                        reinstallationSucceeded: function () {
                            try {
                                var flag = require('aui/flag');
                                flag({
                                    type: "success",
                                    title: "HipChat Integration updated",
                                    persistent: false,
                                    body: "Your HipChat Integration has been successfully updated to the latest version, enjoy the new features."
                                });
                            } catch (e) {
                                // AUI flag is not available, do not bother.
                            }
                        }
                    };
                })();

                /**
                 * Remote APIs service
                 */
                var Remote = {
                    /**
                     * Begin a server request to ping the hipchat server
                     *  to ensure server is visible
                     * @returns {*}
                     */
                    serverPing: function () {
                        return $.ajax(routes.serverPing, {
                            type: "GET"
                        });
                    },

                    /**
                     * Server ping with a specific url
                     * @param url
                     * @returns {*}
                     */
                    serverPingToUrl: function (url) {
                        var paramDelimiter = (routes.serverPing.indexOf("?") < 0) ? "?" : "&";
                        return $.ajax(routes.serverPing + paramDelimiter + "url=" + encodeURIComponent(url), {
                            type: "GET"
                        });
                    },

                    /**
                     * Request information to begin installing a hipchat
                     *  plugin. This request also sets a cookie which is
                     *  used for XSRF protection
                     * @returns {*}
                     */
                    beginInstall: function (url, reinstall) {
                        return $.ajax(routes.beginInstall, {
                            type: "POST",
                            dataType: 'json',
                            contentType: 'application/json',
                            data: JSON.stringify({
                                installableUrl: url,
                                reinstall: reinstall
                            })
                        })
                    },
                    /**
                     * Submit the installation completion data to the server
                     * @param url
                     * @returns {*}
                     */
                    completeInstall: function (url) {
                        return $.ajax(routes.completeInstall, {
                            type: "POST",
                            dataType: 'json',
                            contentType: 'application/json',
                            data: JSON.stringify({
                                installableUrl: url
                            })
                        })
                    },
                    /**
                     * Remove link with the given id
                     * @param linkId
                     * @returns {*}
                     */
                    remove: function (linkId) {
                        return $.ajax({
                            url: routes.uninstall + "/" + linkId,
                            type: "POST",
                            dataType: 'json',
                            contentType: 'application/json',
                            data: JSON.stringify({})
                        })
                    },

                    reinstall: function (linkId) {
                        return $.ajax({
                            url: routes.uninstall + "/" + linkId,
                            type: "POST",
                            dataType: 'json',
                            contentType: 'application/json',
                            data: JSON.stringify({
                                reinstall: true
                            })
                        })
                    },

                    removeDefault: function () {
                        return $.ajax(routes.uninstall, {
                            type: "POST",
                            dataType: 'json',
                            contentType: 'application/json',
                            data: JSON.stringify({})
                        })
                    }
                };

                /**
                 * Code related to the various actions on this page
                 */
                var Actions = {
                    /**
                     * Setup the initial state of the screen
                     * @param state
                     */
                    initialize: function (state) {
                        switch (state) {
                            case "installing":
                                Actions.installing();
                                break;

                            case "installed":
                                Actions.installed(linkId);
                                break;

                            case "uninstalling":
                                Actions.uninstalling();
                                break;

                            case "reinstall":
                                Actions.reinstalling();
                                break;

                            case "configure":
                            default:
                                Actions.configure();
                        }
                    },

                    /**
                     * Utility function to redirect the client's browser (current url is not in history)
                     * @param url
                     */
                    redirect: function (url) {
                        window.location.replace(url);
                    },

                    /**
                     * Utility function to redirect the client's browser while keeping the current url in the browser history.
                     */
                    navigate: function (url) {
                        window.location.assign(url);
                    },

                    /**
                     * Load the configuration screen
                     *
                     * Trigger a server ping, if successful request
                     *  installation information and redirect to hipchat
                     *  plugin installation.
                     */
                    configure: function () {
                        Remote.serverPing()
                            .done(function () {
                                $("#hipchat-install").removeAttr("disabled");
                            })
                            .fail(function () {
                                $("#hipchat-server-failure").removeClass("hidden");
                            })
                            .always(function () {
                                $("#hipchat-loading").hide();
                            });

                        $("#hipchat-install").click(function (e) {
                            e.preventDefault();
                            if ($(this).attr('aria-disabled')) {
                                return;
                            }
                            $(this).attr('aria-disabled', 'true');

                            AJS.trigger('analyticsEvent', {
                                name: 'notifications.hipchat.server.registration.started',
                                data: {}
                            });

                            Remote.beginInstall(undefined, false)
                                .done(Actions.navigate);
                        });

                        $('#enable-btf-install').click(function (e) {
                            e.preventDefault();
                            window.onbeforeunload = null; // Prevent "Are you sure you want to navigate away" dialog to appear

                            enableHipChatBTF();
                        });

                        //Fire analytics event
                        AJS.trigger('analyticsEvent', {
                            name: 'notifications.hipchat.server.discovered',
                            data: {}
                        });

                        /**
                         * We enable the page to set a url
                         */
                        function enableHipChatBTF() {
                            $('.hipchat-install-form').toggleClass("hipchat-btf");
                            $('#btf-url').focus();
                            $('#btf-install').click(function (j) {
                                $("#btf-error").hide();
                                j.preventDefault();
                                var url = $('#btf-url').val();
                                var regex = /^https?:\/\//i;

                                // If the user did not put anything we put https on the url
                                if (!regex.test(url)) {
                                    url = 'https://' + url;
                                }

                                Remote.serverPingToUrl(url)
                                    .done(function () {
                                        Remote.beginInstall(url, false).done(Actions.navigate)
                                    })
                                    .fail(function () {
                                        $("#btf-error").show();
                                    });
                            });
                        }

                        $('#btf-install-cancel').click(function (e) {
                            e.preventDefault();
                            $('.hipchat-install-form').toggleClass("hipchat-btf");
                        });
                    },

                    /**
                     * Load the installing screen
                     *
                     * Posts the installation information to the server.
                     *
                     * Done using javascript as this lets the process be sort
                     *  of async, and the user gets some feedback on slow connections
                     *  instead of just seeing a white screen.
                     */
                    installing: function () {
                        Views.installing();
                        Remote.completeInstall(routes.installableUrl)
                            .done(function (data) {
                                Actions.redirect(routes.self);
                            }).error(Views.error)
                    },

                    /**
                     * Load the installed screen
                     */
                    installed: function () {
                        $("#hipchat-uninstall").click(function (e) {
                            e.preventDefault();
                            if ($(this).attr('aria-disabled')) {
                                return;
                            }
                            Views.confirmUninstall().done(function () {
                                Remote.remove(linkId).done(Actions.redirect).error(Views.uninstallError);
                            });

                        });

                        $(".hipchat-reinstall").click(function () {
                            if ($(this).attr('aria-disabled')) {
                                return;
                            }

                            var $el = $(this);
                            $el.attr('aria-disabled', true);
                            $el.find(".aui-icon-wait").css("display", "inline-block");

                            Remote.reinstall(linkId).done(Actions.redirect).error(Views.uninstallError);
                        });

                        if (localStorage.getItem("hipchat-reinstalling")) {
                            Views.reinstallationSucceeded();
                            localStorage.removeItem("hipchat-reinstalling");
                        }
                    },

                    uninstalling: function () {
                        Remote.removeDefault().done(function () {
                            Actions.redirect(routes.redirectUrl)
                        }).error(Views.uninstallError)
                    },

                    reinstalling: function () {
                        function getURLParameter(sParam) {
                            var sPageURL = window.location.search.substring(1);
                            var sURLVariables = sPageURL.split('&');
                            for (var i = 0; i < sURLVariables.length; i++)
                            {
                                var sParameterName = sURLVariables[i].split('=');
                                if (sParameterName[0] == sParam)
                                {
                                    if (sParameterName.length > 1) {
                                        return sParameterName[1];
                                    } else {
                                        return null;
                                    }
                                }
                            }
                        }
                        var paramValue = getURLParameter("installable_url");
                        if (paramValue === undefined) {
                            console.log("ERROR: the 'installable_url' parameter was missing from the request URL:'" + window.location.search + "'");
                        } else {
                            var url = decodeURIComponent(paramValue);
                            var a = document.createElement('a');
                            a.href = url;
                            var hipchatUrl = a.protocol + "//" + a.host;
                            Remote.serverPingToUrl(hipchatUrl)
                                    .done(function () {
                                        localStorage.setItem("hipchat-reinstalling", true);
                                        Remote.beginInstall(hipchatUrl, true).done(Actions.navigate)
                                    })
                                    .fail(function () {
                                        $("#btf-error").show();
                                    });
                        }
                    }

                };

                Actions.initialize(state);
            }
        }
    )

});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:resources', location = 'admin/configure-hipchat.soy' */
// This file was automatically generated from configure-hipchat.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace HipChat.Templates.Configuration.
 */

if (typeof HipChat == 'undefined') { var HipChat = {}; }
if (typeof HipChat.Templates == 'undefined') { HipChat.Templates = {}; }
if (typeof HipChat.Templates.Configuration == 'undefined') { HipChat.Templates.Configuration = {}; }


HipChat.Templates.Configuration.installing = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.connected({id: 'hipchat-installing', installHeading: "Integrating with HipChat", installImage: opt_data.installingImage, showRemove: false});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.installing.soyTemplateName = 'HipChat.Templates.Configuration.installing';
}


HipChat.Templates.Configuration.uninstalling = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.connected({id: 'hipchat-uninstalling', installHeading: "Removing HipChat Integration", installImage: opt_data.uninstallingImage, showRemove: false});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.uninstalling.soyTemplateName = 'HipChat.Templates.Configuration.uninstalling';
}


HipChat.Templates.Configuration.connected = function(opt_data, opt_ignored) {
  return '<div id="' + soy.$$escapeHtml(opt_data.id) + '">' + ((opt_data.showRemove) ? HipChat.Templates.Configuration.uninstallButton(null) : '') + ((opt_data.installImage) ? '<img src="' + soy.$$escapeHtml(opt_data.installImage) + '" />' : '') + ((opt_data.installHeading) ? '<h5>' + soy.$$escapeHtml(opt_data.installHeading) + '</h5>' : '') + '<hr/><div class="hipchat-install-message">' + ((opt_data.installMessageHtml) ? '<p>' + soy.$$filterNoAutoescape(opt_data.installMessageHtml) + '</p>' : '') + '</div></div>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.connected.soyTemplateName = 'HipChat.Templates.Configuration.connected';
}


HipChat.Templates.Configuration.error = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.message({type: 'error', title: "Error encountered creating your hipchat link", content: soy.$$escapeHtml("Something went wrong integrating JIRA and HipChat. We probably had trouble connecting to the HipChat server. Check that the connection between your server and HipChat is working correctly and try again.") + '<p>' + soy.$$escapeHtml("Try uninstalling the existing integration from HipChat before trying again.") + '</p>'});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.error.soyTemplateName = 'HipChat.Templates.Configuration.error';
}


HipChat.Templates.Configuration.uninstallConnectionError = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.message({type: 'error', title: "Error encountered removing your hipchat link", content: '' + soy.$$escapeHtml("Something went wrong removing the integration in HipChat. We probably had trouble connecting to the HipChat server. You may need to remove the integration from HipChat\'s admin page. The link has been removed from JIRA.")});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.uninstallConnectionError.soyTemplateName = 'HipChat.Templates.Configuration.uninstallConnectionError';
}


HipChat.Templates.Configuration.uninstallPermissionError = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.message({type: 'error', title: "Error encountered removing your hipchat link", content: '' + soy.$$escapeHtml("You do not have permission to remove this integration, please contact your site admin if you wish to remove the HipChat integration.")});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.uninstallPermissionError.soyTemplateName = 'HipChat.Templates.Configuration.uninstallPermissionError';
}


HipChat.Templates.Configuration.refreshToken = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.message({type: 'error', title: 'Setting up your HipChat link', content: '' + soy.$$escapeHtml("Error encountered creating your hipchat link")});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.refreshToken.soyTemplateName = 'HipChat.Templates.Configuration.refreshToken';
}


HipChat.Templates.Configuration.message = function(opt_data, opt_ignored) {
  return '<div class="aui-message ' + soy.$$escapeHtml(opt_data.type) + ' ' + ((opt_data.altClass) ? soy.$$escapeHtml(opt_data.altClass) : '') + '"><p class="title"><span class="aui-icon icon-' + soy.$$escapeHtml(opt_data.type) + '"></span><strong>' + soy.$$escapeHtml(opt_data.title) + '</strong></p>' + ((opt_data.content) ? '<p>' + soy.$$filterNoAutoescape(opt_data.content) + '</p>' : '') + '</div>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.message.soyTemplateName = 'HipChat.Templates.Configuration.message';
}


HipChat.Templates.Configuration.removeLinkMessage = function(opt_data, opt_ignored) {
  return '<div class=\'remove-link-message\'>' + soy.$$filterNoAutoescape("\u003cp>Are you sure you want to completely remove your HipChat integration?\u003c\/p>\u003cp>The JIRA plugin will not be removed from HipChat.\u003c\/p>") + '</div>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.removeLinkMessage.soyTemplateName = 'HipChat.Templates.Configuration.removeLinkMessage';
}


HipChat.Templates.Configuration.installButton = function(opt_data, opt_ignored) {
  return '<div class="hipchat-install-form"><button class="aui-button aui-button-primary" type="submit" id="hipchat-install" disabled="disabled">' + soy.$$escapeHtml("Connect HipChat") + '</button><div id="hipchat-loading"><span class="aui-icon aui-icon-wait"></span> ' + soy.$$escapeHtml("Checking your server can see HipChat") + '</div><div id="hipchat-server-failure" class="hidden"><p><span class="aui-icon aui-icon-small aui-iconfont-warning hipchat-failure-marker"></span> ' + soy.$$escapeHtml("Unable to reach HipChat") + '</p><p class="details">' + soy.$$escapeHtml("If JIRA does not have access to the internet you won\'t be able to integrate with HipChat.") + '</p></div><div><button class="cancel aui-link aui-button aui-button-link" id="enable-btf-install">' + soy.$$escapeHtml("Or, if you\x27re using HipChat Server, click here.") + '</button>' + HipChat.Templates.Configuration.btfInstall(null) + '</div></div>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.installButton.soyTemplateName = 'HipChat.Templates.Configuration.installButton';
}


HipChat.Templates.Configuration.btfInstall = function(opt_data, opt_ignored) {
  return '<form class="aui top-label" id="hipchat-btf-install"><fieldset class="top-label"><div class="field-group top-label"><label for="hipchat-btf-url" style="text-align:center">' + soy.$$escapeHtml("First things first, let us know where we can find your HipChat Server:") + '</label><input class="text long-field" type="text" id="btf-url" name="btf-url" data-aui-notification-field="" placeholder="http://www.hipchat.com"></input><div class="error" id="btf-error">' + soy.$$escapeHtml("We couldn\x27t reach your server") + '</div></div></fieldset><div class="buttons-container"><button class="aui-button aui-button-primary" type="submit" id="btf-install">' + soy.$$escapeHtml("Connect HipChat") + '</button><a class="cancel" href="#" id="btf-install-cancel">Cancel</a></div></form>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.btfInstall.soyTemplateName = 'HipChat.Templates.Configuration.btfInstall';
}


HipChat.Templates.Configuration.uninstallButton = function(opt_data, opt_ignored) {
  return '<button class="aui-button aui-button-subtle" id="hipchat-uninstall"><span class="aui-icon aui-icon-small aui-iconfont-delete">Configure</span> ' + soy.$$escapeHtml("Remove integration") + '</button>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.uninstallButton.soyTemplateName = 'HipChat.Templates.Configuration.uninstallButton';
}


HipChat.Templates.Configuration.inviteButton = function(opt_data, opt_ignored) {
  return '<input type="hidden" id="inviteButtonWaitingForMapping" value="' + soy.$$escapeHtml(opt_data.inviteButtonWaitingForMapping) + '"/><a class="aui-button aui-button-subtle hidden" id="hipchat-invite-button" href="' + soy.$$escapeHtml(opt_data.adminInviteUrl) + '"><span class="aui-icon aui-icon-small aui-iconfont-space-personal">Invite</span> ' + soy.$$escapeHtml("Invite users to HipChat") + '</a>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.inviteButton.soyTemplateName = 'HipChat.Templates.Configuration.inviteButton';
}
;
;
/* module-key = 'com.atlassian.auiplugin:aui-select2', location = 'js-vendor/jquery/plugins/jquery.select2.js' */
/*
 Copyright 2012 Igor Vaynberg

 Version: 3.4.5 Timestamp: Mon Nov  4 08:22:42 PST 2013

 This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 General Public License version 2 (the "GPL License"). You may choose either license to govern your
 use of this software only upon the condition that you accept all of the terms of either the Apache
 License or the GPL License.

 You may obtain a copy of the Apache License and the GPL License at:

 http://www.apache.org/licenses/LICENSE-2.0
 http://www.gnu.org/licenses/gpl-2.0.html

 Unless required by applicable law or agreed to in writing, software distributed under the
 Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 the specific language governing permissions and limitations under the Apache License and the GPL License.
 */
(function ($) {
    if(typeof $.fn.each2 == "undefined") {
        $.extend($.fn, {
            /*
             * 4-10 times faster .each replacement
             * use it carefully, as it overrides jQuery context of element on each iteration
             */
            each2 : function (c) {
                var j = $([0]), i = -1, l = this.length;
                while (
                    ++i < l
                        && (j.context = j[0] = this[i])
                        && c.call(j[0], i, j) !== false //"this"=DOM, i=index, j=jQuery object
                    );
                return this;
            }
        });
    }
})(jQuery);

(function ($, undefined) {
    "use strict";
    /*global document, window, jQuery, console */

    if (window.Select2 !== undefined) {
        return;
    }

    var KEY, AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
        lastMousePosition={x:0,y:0}, $document, scrollBarDimensions,

        KEY = {
            TAB: 9,
            ENTER: 13,
            ESC: 27,
            SPACE: 32,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            HOME: 36,
            END: 35,
            BACKSPACE: 8,
            DELETE: 46,
            isArrow: function (k) {
                k = k.which ? k.which : k;
                switch (k) {
                    case KEY.LEFT:
                    case KEY.RIGHT:
                    case KEY.UP:
                    case KEY.DOWN:
                        return true;
                }
                return false;
            },
            isControl: function (e) {
                var k = e.which;
                switch (k) {
                    case KEY.SHIFT:
                    case KEY.CTRL:
                    case KEY.ALT:
                        return true;
                }

                if (e.metaKey) return true;

                return false;
            },
            isFunctionKey: function (k) {
                k = k.which ? k.which : k;
                return k >= 112 && k <= 123;
            }
        },
        MEASURE_SCROLLBAR_TEMPLATE = "<div class='select2-measure-scrollbar'></div>",

        DIACRITICS = {"\u24B6":"A","\uFF21":"A","\u00C0":"A","\u00C1":"A","\u00C2":"A","\u1EA6":"A","\u1EA4":"A","\u1EAA":"A","\u1EA8":"A","\u00C3":"A","\u0100":"A","\u0102":"A","\u1EB0":"A","\u1EAE":"A","\u1EB4":"A","\u1EB2":"A","\u0226":"A","\u01E0":"A","\u00C4":"A","\u01DE":"A","\u1EA2":"A","\u00C5":"A","\u01FA":"A","\u01CD":"A","\u0200":"A","\u0202":"A","\u1EA0":"A","\u1EAC":"A","\u1EB6":"A","\u1E00":"A","\u0104":"A","\u023A":"A","\u2C6F":"A","\uA732":"AA","\u00C6":"AE","\u01FC":"AE","\u01E2":"AE","\uA734":"AO","\uA736":"AU","\uA738":"AV","\uA73A":"AV","\uA73C":"AY","\u24B7":"B","\uFF22":"B","\u1E02":"B","\u1E04":"B","\u1E06":"B","\u0243":"B","\u0182":"B","\u0181":"B","\u24B8":"C","\uFF23":"C","\u0106":"C","\u0108":"C","\u010A":"C","\u010C":"C","\u00C7":"C","\u1E08":"C","\u0187":"C","\u023B":"C","\uA73E":"C","\u24B9":"D","\uFF24":"D","\u1E0A":"D","\u010E":"D","\u1E0C":"D","\u1E10":"D","\u1E12":"D","\u1E0E":"D","\u0110":"D","\u018B":"D","\u018A":"D","\u0189":"D","\uA779":"D","\u01F1":"DZ","\u01C4":"DZ","\u01F2":"Dz","\u01C5":"Dz","\u24BA":"E","\uFF25":"E","\u00C8":"E","\u00C9":"E","\u00CA":"E","\u1EC0":"E","\u1EBE":"E","\u1EC4":"E","\u1EC2":"E","\u1EBC":"E","\u0112":"E","\u1E14":"E","\u1E16":"E","\u0114":"E","\u0116":"E","\u00CB":"E","\u1EBA":"E","\u011A":"E","\u0204":"E","\u0206":"E","\u1EB8":"E","\u1EC6":"E","\u0228":"E","\u1E1C":"E","\u0118":"E","\u1E18":"E","\u1E1A":"E","\u0190":"E","\u018E":"E","\u24BB":"F","\uFF26":"F","\u1E1E":"F","\u0191":"F","\uA77B":"F","\u24BC":"G","\uFF27":"G","\u01F4":"G","\u011C":"G","\u1E20":"G","\u011E":"G","\u0120":"G","\u01E6":"G","\u0122":"G","\u01E4":"G","\u0193":"G","\uA7A0":"G","\uA77D":"G","\uA77E":"G","\u24BD":"H","\uFF28":"H","\u0124":"H","\u1E22":"H","\u1E26":"H","\u021E":"H","\u1E24":"H","\u1E28":"H","\u1E2A":"H","\u0126":"H","\u2C67":"H","\u2C75":"H","\uA78D":"H","\u24BE":"I","\uFF29":"I","\u00CC":"I","\u00CD":"I","\u00CE":"I","\u0128":"I","\u012A":"I","\u012C":"I","\u0130":"I","\u00CF":"I","\u1E2E":"I","\u1EC8":"I","\u01CF":"I","\u0208":"I","\u020A":"I","\u1ECA":"I","\u012E":"I","\u1E2C":"I","\u0197":"I","\u24BF":"J","\uFF2A":"J","\u0134":"J","\u0248":"J","\u24C0":"K","\uFF2B":"K","\u1E30":"K","\u01E8":"K","\u1E32":"K","\u0136":"K","\u1E34":"K","\u0198":"K","\u2C69":"K","\uA740":"K","\uA742":"K","\uA744":"K","\uA7A2":"K","\u24C1":"L","\uFF2C":"L","\u013F":"L","\u0139":"L","\u013D":"L","\u1E36":"L","\u1E38":"L","\u013B":"L","\u1E3C":"L","\u1E3A":"L","\u0141":"L","\u023D":"L","\u2C62":"L","\u2C60":"L","\uA748":"L","\uA746":"L","\uA780":"L","\u01C7":"LJ","\u01C8":"Lj","\u24C2":"M","\uFF2D":"M","\u1E3E":"M","\u1E40":"M","\u1E42":"M","\u2C6E":"M","\u019C":"M","\u24C3":"N","\uFF2E":"N","\u01F8":"N","\u0143":"N","\u00D1":"N","\u1E44":"N","\u0147":"N","\u1E46":"N","\u0145":"N","\u1E4A":"N","\u1E48":"N","\u0220":"N","\u019D":"N","\uA790":"N","\uA7A4":"N","\u01CA":"NJ","\u01CB":"Nj","\u24C4":"O","\uFF2F":"O","\u00D2":"O","\u00D3":"O","\u00D4":"O","\u1ED2":"O","\u1ED0":"O","\u1ED6":"O","\u1ED4":"O","\u00D5":"O","\u1E4C":"O","\u022C":"O","\u1E4E":"O","\u014C":"O","\u1E50":"O","\u1E52":"O","\u014E":"O","\u022E":"O","\u0230":"O","\u00D6":"O","\u022A":"O","\u1ECE":"O","\u0150":"O","\u01D1":"O","\u020C":"O","\u020E":"O","\u01A0":"O","\u1EDC":"O","\u1EDA":"O","\u1EE0":"O","\u1EDE":"O","\u1EE2":"O","\u1ECC":"O","\u1ED8":"O","\u01EA":"O","\u01EC":"O","\u00D8":"O","\u01FE":"O","\u0186":"O","\u019F":"O","\uA74A":"O","\uA74C":"O","\u01A2":"OI","\uA74E":"OO","\u0222":"OU","\u24C5":"P","\uFF30":"P","\u1E54":"P","\u1E56":"P","\u01A4":"P","\u2C63":"P","\uA750":"P","\uA752":"P","\uA754":"P","\u24C6":"Q","\uFF31":"Q","\uA756":"Q","\uA758":"Q","\u024A":"Q","\u24C7":"R","\uFF32":"R","\u0154":"R","\u1E58":"R","\u0158":"R","\u0210":"R","\u0212":"R","\u1E5A":"R","\u1E5C":"R","\u0156":"R","\u1E5E":"R","\u024C":"R","\u2C64":"R","\uA75A":"R","\uA7A6":"R","\uA782":"R","\u24C8":"S","\uFF33":"S","\u1E9E":"S","\u015A":"S","\u1E64":"S","\u015C":"S","\u1E60":"S","\u0160":"S","\u1E66":"S","\u1E62":"S","\u1E68":"S","\u0218":"S","\u015E":"S","\u2C7E":"S","\uA7A8":"S","\uA784":"S","\u24C9":"T","\uFF34":"T","\u1E6A":"T","\u0164":"T","\u1E6C":"T","\u021A":"T","\u0162":"T","\u1E70":"T","\u1E6E":"T","\u0166":"T","\u01AC":"T","\u01AE":"T","\u023E":"T","\uA786":"T","\uA728":"TZ","\u24CA":"U","\uFF35":"U","\u00D9":"U","\u00DA":"U","\u00DB":"U","\u0168":"U","\u1E78":"U","\u016A":"U","\u1E7A":"U","\u016C":"U","\u00DC":"U","\u01DB":"U","\u01D7":"U","\u01D5":"U","\u01D9":"U","\u1EE6":"U","\u016E":"U","\u0170":"U","\u01D3":"U","\u0214":"U","\u0216":"U","\u01AF":"U","\u1EEA":"U","\u1EE8":"U","\u1EEE":"U","\u1EEC":"U","\u1EF0":"U","\u1EE4":"U","\u1E72":"U","\u0172":"U","\u1E76":"U","\u1E74":"U","\u0244":"U","\u24CB":"V","\uFF36":"V","\u1E7C":"V","\u1E7E":"V","\u01B2":"V","\uA75E":"V","\u0245":"V","\uA760":"VY","\u24CC":"W","\uFF37":"W","\u1E80":"W","\u1E82":"W","\u0174":"W","\u1E86":"W","\u1E84":"W","\u1E88":"W","\u2C72":"W","\u24CD":"X","\uFF38":"X","\u1E8A":"X","\u1E8C":"X","\u24CE":"Y","\uFF39":"Y","\u1EF2":"Y","\u00DD":"Y","\u0176":"Y","\u1EF8":"Y","\u0232":"Y","\u1E8E":"Y","\u0178":"Y","\u1EF6":"Y","\u1EF4":"Y","\u01B3":"Y","\u024E":"Y","\u1EFE":"Y","\u24CF":"Z","\uFF3A":"Z","\u0179":"Z","\u1E90":"Z","\u017B":"Z","\u017D":"Z","\u1E92":"Z","\u1E94":"Z","\u01B5":"Z","\u0224":"Z","\u2C7F":"Z","\u2C6B":"Z","\uA762":"Z","\u24D0":"a","\uFF41":"a","\u1E9A":"a","\u00E0":"a","\u00E1":"a","\u00E2":"a","\u1EA7":"a","\u1EA5":"a","\u1EAB":"a","\u1EA9":"a","\u00E3":"a","\u0101":"a","\u0103":"a","\u1EB1":"a","\u1EAF":"a","\u1EB5":"a","\u1EB3":"a","\u0227":"a","\u01E1":"a","\u00E4":"a","\u01DF":"a","\u1EA3":"a","\u00E5":"a","\u01FB":"a","\u01CE":"a","\u0201":"a","\u0203":"a","\u1EA1":"a","\u1EAD":"a","\u1EB7":"a","\u1E01":"a","\u0105":"a","\u2C65":"a","\u0250":"a","\uA733":"aa","\u00E6":"ae","\u01FD":"ae","\u01E3":"ae","\uA735":"ao","\uA737":"au","\uA739":"av","\uA73B":"av","\uA73D":"ay","\u24D1":"b","\uFF42":"b","\u1E03":"b","\u1E05":"b","\u1E07":"b","\u0180":"b","\u0183":"b","\u0253":"b","\u24D2":"c","\uFF43":"c","\u0107":"c","\u0109":"c","\u010B":"c","\u010D":"c","\u00E7":"c","\u1E09":"c","\u0188":"c","\u023C":"c","\uA73F":"c","\u2184":"c","\u24D3":"d","\uFF44":"d","\u1E0B":"d","\u010F":"d","\u1E0D":"d","\u1E11":"d","\u1E13":"d","\u1E0F":"d","\u0111":"d","\u018C":"d","\u0256":"d","\u0257":"d","\uA77A":"d","\u01F3":"dz","\u01C6":"dz","\u24D4":"e","\uFF45":"e","\u00E8":"e","\u00E9":"e","\u00EA":"e","\u1EC1":"e","\u1EBF":"e","\u1EC5":"e","\u1EC3":"e","\u1EBD":"e","\u0113":"e","\u1E15":"e","\u1E17":"e","\u0115":"e","\u0117":"e","\u00EB":"e","\u1EBB":"e","\u011B":"e","\u0205":"e","\u0207":"e","\u1EB9":"e","\u1EC7":"e","\u0229":"e","\u1E1D":"e","\u0119":"e","\u1E19":"e","\u1E1B":"e","\u0247":"e","\u025B":"e","\u01DD":"e","\u24D5":"f","\uFF46":"f","\u1E1F":"f","\u0192":"f","\uA77C":"f","\u24D6":"g","\uFF47":"g","\u01F5":"g","\u011D":"g","\u1E21":"g","\u011F":"g","\u0121":"g","\u01E7":"g","\u0123":"g","\u01E5":"g","\u0260":"g","\uA7A1":"g","\u1D79":"g","\uA77F":"g","\u24D7":"h","\uFF48":"h","\u0125":"h","\u1E23":"h","\u1E27":"h","\u021F":"h","\u1E25":"h","\u1E29":"h","\u1E2B":"h","\u1E96":"h","\u0127":"h","\u2C68":"h","\u2C76":"h","\u0265":"h","\u0195":"hv","\u24D8":"i","\uFF49":"i","\u00EC":"i","\u00ED":"i","\u00EE":"i","\u0129":"i","\u012B":"i","\u012D":"i","\u00EF":"i","\u1E2F":"i","\u1EC9":"i","\u01D0":"i","\u0209":"i","\u020B":"i","\u1ECB":"i","\u012F":"i","\u1E2D":"i","\u0268":"i","\u0131":"i","\u24D9":"j","\uFF4A":"j","\u0135":"j","\u01F0":"j","\u0249":"j","\u24DA":"k","\uFF4B":"k","\u1E31":"k","\u01E9":"k","\u1E33":"k","\u0137":"k","\u1E35":"k","\u0199":"k","\u2C6A":"k","\uA741":"k","\uA743":"k","\uA745":"k","\uA7A3":"k","\u24DB":"l","\uFF4C":"l","\u0140":"l","\u013A":"l","\u013E":"l","\u1E37":"l","\u1E39":"l","\u013C":"l","\u1E3D":"l","\u1E3B":"l","\u017F":"l","\u0142":"l","\u019A":"l","\u026B":"l","\u2C61":"l","\uA749":"l","\uA781":"l","\uA747":"l","\u01C9":"lj","\u24DC":"m","\uFF4D":"m","\u1E3F":"m","\u1E41":"m","\u1E43":"m","\u0271":"m","\u026F":"m","\u24DD":"n","\uFF4E":"n","\u01F9":"n","\u0144":"n","\u00F1":"n","\u1E45":"n","\u0148":"n","\u1E47":"n","\u0146":"n","\u1E4B":"n","\u1E49":"n","\u019E":"n","\u0272":"n","\u0149":"n","\uA791":"n","\uA7A5":"n","\u01CC":"nj","\u24DE":"o","\uFF4F":"o","\u00F2":"o","\u00F3":"o","\u00F4":"o","\u1ED3":"o","\u1ED1":"o","\u1ED7":"o","\u1ED5":"o","\u00F5":"o","\u1E4D":"o","\u022D":"o","\u1E4F":"o","\u014D":"o","\u1E51":"o","\u1E53":"o","\u014F":"o","\u022F":"o","\u0231":"o","\u00F6":"o","\u022B":"o","\u1ECF":"o","\u0151":"o","\u01D2":"o","\u020D":"o","\u020F":"o","\u01A1":"o","\u1EDD":"o","\u1EDB":"o","\u1EE1":"o","\u1EDF":"o","\u1EE3":"o","\u1ECD":"o","\u1ED9":"o","\u01EB":"o","\u01ED":"o","\u00F8":"o","\u01FF":"o","\u0254":"o","\uA74B":"o","\uA74D":"o","\u0275":"o","\u01A3":"oi","\u0223":"ou","\uA74F":"oo","\u24DF":"p","\uFF50":"p","\u1E55":"p","\u1E57":"p","\u01A5":"p","\u1D7D":"p","\uA751":"p","\uA753":"p","\uA755":"p","\u24E0":"q","\uFF51":"q","\u024B":"q","\uA757":"q","\uA759":"q","\u24E1":"r","\uFF52":"r","\u0155":"r","\u1E59":"r","\u0159":"r","\u0211":"r","\u0213":"r","\u1E5B":"r","\u1E5D":"r","\u0157":"r","\u1E5F":"r","\u024D":"r","\u027D":"r","\uA75B":"r","\uA7A7":"r","\uA783":"r","\u24E2":"s","\uFF53":"s","\u00DF":"s","\u015B":"s","\u1E65":"s","\u015D":"s","\u1E61":"s","\u0161":"s","\u1E67":"s","\u1E63":"s","\u1E69":"s","\u0219":"s","\u015F":"s","\u023F":"s","\uA7A9":"s","\uA785":"s","\u1E9B":"s","\u24E3":"t","\uFF54":"t","\u1E6B":"t","\u1E97":"t","\u0165":"t","\u1E6D":"t","\u021B":"t","\u0163":"t","\u1E71":"t","\u1E6F":"t","\u0167":"t","\u01AD":"t","\u0288":"t","\u2C66":"t","\uA787":"t","\uA729":"tz","\u24E4":"u","\uFF55":"u","\u00F9":"u","\u00FA":"u","\u00FB":"u","\u0169":"u","\u1E79":"u","\u016B":"u","\u1E7B":"u","\u016D":"u","\u00FC":"u","\u01DC":"u","\u01D8":"u","\u01D6":"u","\u01DA":"u","\u1EE7":"u","\u016F":"u","\u0171":"u","\u01D4":"u","\u0215":"u","\u0217":"u","\u01B0":"u","\u1EEB":"u","\u1EE9":"u","\u1EEF":"u","\u1EED":"u","\u1EF1":"u","\u1EE5":"u","\u1E73":"u","\u0173":"u","\u1E77":"u","\u1E75":"u","\u0289":"u","\u24E5":"v","\uFF56":"v","\u1E7D":"v","\u1E7F":"v","\u028B":"v","\uA75F":"v","\u028C":"v","\uA761":"vy","\u24E6":"w","\uFF57":"w","\u1E81":"w","\u1E83":"w","\u0175":"w","\u1E87":"w","\u1E85":"w","\u1E98":"w","\u1E89":"w","\u2C73":"w","\u24E7":"x","\uFF58":"x","\u1E8B":"x","\u1E8D":"x","\u24E8":"y","\uFF59":"y","\u1EF3":"y","\u00FD":"y","\u0177":"y","\u1EF9":"y","\u0233":"y","\u1E8F":"y","\u00FF":"y","\u1EF7":"y","\u1E99":"y","\u1EF5":"y","\u01B4":"y","\u024F":"y","\u1EFF":"y","\u24E9":"z","\uFF5A":"z","\u017A":"z","\u1E91":"z","\u017C":"z","\u017E":"z","\u1E93":"z","\u1E95":"z","\u01B6":"z","\u0225":"z","\u0240":"z","\u2C6C":"z","\uA763":"z"};

    $document = $(document);

    nextUid=(function() { var counter=1; return function() { return counter++; }; }());


    function stripDiacritics(str) {
        var ret, i, l, c;

        if (!str || str.length < 1) return str;

        ret = "";
        for (i = 0, l = str.length; i < l; i++) {
            c = str.charAt(i);
            ret += DIACRITICS[c] || c;
        }
        return ret;
    }

    function indexOf(value, array) {
        var i = 0, l = array.length;
        for (; i < l; i = i + 1) {
            if (equal(value, array[i])) return i;
        }
        return -1;
    }

    function measureScrollbar () {
        var $template = $( MEASURE_SCROLLBAR_TEMPLATE );
        $template.appendTo('body');

        var dim = {
            width: $template.width() - $template[0].clientWidth,
            height: $template.height() - $template[0].clientHeight
        };
        $template.remove();

        return dim;
    }

    /**
     * Compares equality of a and b
     * @param a
     * @param b
     */
    function equal(a, b) {
        if (a === b) return true;
        if (a === undefined || b === undefined) return false;
        if (a === null || b === null) return false;
        // Check whether 'a' or 'b' is a string (primitive or object).
        // The concatenation of an empty string (+'') converts its argument to a string's primitive.
        if (a.constructor === String) return a+'' === b+''; // a+'' - in case 'a' is a String object
        if (b.constructor === String) return b+'' === a+''; // b+'' - in case 'b' is a String object
        return false;
    }

    /**
     * Splits the string into an array of values, trimming each value. An empty array is returned for nulls or empty
     * strings
     * @param string
     * @param separator
     */
    function splitVal(string, separator) {
        var val, i, l;
        if (string === null || string.length < 1) return [];
        val = string.split(separator);
        for (i = 0, l = val.length; i < l; i = i + 1) val[i] = $.trim(val[i]);
        return val;
    }

    function getSideBorderPadding(element) {
        return element.outerWidth(false) - element.width();
    }

    function installKeyUpChangeEvent(element) {
        var key="keyup-change-value";
        element.on("keydown", function () {
            if ($.data(element, key) === undefined) {
                $.data(element, key, element.val());
            }
        });
        element.on("keyup", function () {
            var val= $.data(element, key);
            if (val !== undefined && element.val() !== val) {
                $.removeData(element, key);
                element.trigger("keyup-change");
            }
        });
    }

    $document.on("mousemove", function (e) {
        lastMousePosition.x = e.pageX;
        lastMousePosition.y = e.pageY;
    });

    /**
     * filters mouse events so an event is fired only if the mouse moved.
     *
     * filters out mouse events that occur when mouse is stationary but
     * the elements under the pointer are scrolled.
     */
    function installFilteredMouseMove(element) {
        element.on("mousemove", function (e) {
            var lastpos = lastMousePosition;
            if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
                $(e.target).trigger("mousemove-filtered", e);
            }
        });
    }

    /**
     * Debounces a function. Returns a function that calls the original fn function only if no invocations have been made
     * within the last quietMillis milliseconds.
     *
     * @param quietMillis number of milliseconds to wait before invoking fn
     * @param fn function to be debounced
     * @param ctx object to be used as this reference within fn
     * @return debounced version of fn
     */
    function debounce(quietMillis, fn, ctx) {
        ctx = ctx || undefined;
        var timeout;
        return function () {
            var args = arguments;
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function() {
                fn.apply(ctx, args);
            }, quietMillis);
        };
    }

    /**
     * A simple implementation of a thunk
     * @param formula function used to lazily initialize the thunk
     * @return {Function}
     */
    function thunk(formula) {
        var evaluated = false,
            value;
        return function() {
            if (evaluated === false) { value = formula(); evaluated = true; }
            return value;
        };
    };

    function installDebouncedScroll(threshold, element) {
        var notify = debounce(threshold, function (e) { element.trigger("scroll-debounced", e);});
        element.on("scroll", function (e) {
            if (indexOf(e.target, element.get()) >= 0) notify(e);
        });
    }

    function focus($el) {
        if ($el[0] === document.activeElement) return;

        /* set the focus in a 0 timeout - that way the focus is set after the processing
         of the current event has finished - which seems like the only reliable way
         to set focus */
        window.setTimeout(function() {
            var el=$el[0], pos=$el.val().length, range;

            $el.focus();

            /* make sure el received focus so we do not error out when trying to manipulate the caret.
             sometimes modals or others listeners may steal it after its set */
            if ($el.is(":visible") && el === document.activeElement) {

                /* after the focus is set move the caret to the end, necessary when we val()
                 just before setting focus */
                if(el.setSelectionRange)
                {
                    el.setSelectionRange(pos, pos);
                }
                else if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                }
            }
        }, 0);
    }

    function getCursorInfo(el) {
        el = $(el)[0];
        var offset = 0;
        var length = 0;
        if ('selectionStart' in el) {
            offset = el.selectionStart;
            length = el.selectionEnd - offset;
        } else if ('selection' in document) {
            el.focus();
            var sel = document.selection.createRange();
            length = document.selection.createRange().text.length;
            sel.moveStart('character', -el.value.length);
            offset = sel.text.length - length;
        }
        return { offset: offset, length: length };
    }

    function killEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    function killEventImmediately(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    function measureTextWidth(e) {
        if (!sizer){
            var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
            sizer = $(document.createElement("div")).css({
                position: "absolute",
                left: "-10000px",
                top: "-10000px",
                display: "none",
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                fontStyle: style.fontStyle,
                fontWeight: style.fontWeight,
                letterSpacing: style.letterSpacing,
                textTransform: style.textTransform,
                whiteSpace: "nowrap"
            });
            sizer.attr("class","select2-sizer");
            $("body").append(sizer);
        }
        sizer.text(e.val());
        return sizer.width();
    }

    function syncCssClasses(dest, src, adapter) {
        var classes, replacements = [], adapted;

        classes = dest.attr("class");
        if (classes) {
            classes = '' + classes; // for IE which returns object
            $(classes.split(" ")).each2(function() {
                if (this.indexOf("select2-") === 0) {
                    replacements.push(this);
                }
            });
        }
        classes = src.attr("class");
        if (classes) {
            classes = '' + classes; // for IE which returns object
            $(classes.split(" ")).each2(function() {
                if (this.indexOf("select2-") !== 0) {
                    adapted = adapter(this);
                    if (adapted) {
                        replacements.push(adapted);
                    }
                }
            });
        }
        dest.attr("class", replacements.join(" "));
    }


    function markMatch(text, term, markup, escapeMarkup) {
        var match=stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())),
            tl=term.length;

        if (match<0) {
            markup.push(escapeMarkup(text));
            return;
        }

        markup.push(escapeMarkup(text.substring(0, match)));
        markup.push("<span class='select2-match'>");
        markup.push(escapeMarkup(text.substring(match, match + tl)));
        markup.push("</span>");
        markup.push(escapeMarkup(text.substring(match + tl, text.length)));
    }

    function defaultEscapeMarkup(markup) {
        var replace_map = {
            '\\': '&#92;',
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            "/": '&#47;'
        };

        return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
            return replace_map[match];
        });
    }

    /**
     * Produces an ajax-based query function
     *
     * @param options object containing configuration paramters
     * @param options.params parameter map for the transport ajax call, can contain such options as cache, jsonpCallback, etc. see $.ajax
     * @param options.transport function that will be used to execute the ajax request. must be compatible with parameters supported by $.ajax
     * @param options.url url for the data
     * @param options.data a function(searchTerm, pageNumber, context) that should return an object containing query string parameters for the above url.
     * @param options.dataType request data type: ajax, jsonp, other datatatypes supported by jQuery's $.ajax function or the transport function if specified
     * @param options.quietMillis (optional) milliseconds to wait before making the ajaxRequest, helps debounce the ajax function if invoked too often
     * @param options.results a function(remoteData, pageNumber) that converts data returned form the remote request to the format expected by Select2.
     *      The expected format is an object containing the following keys:
     *      results array of objects that will be used as choices
     *      more (optional) boolean indicating whether there are more results available
     *      Example: {results:[{id:1, text:'Red'},{id:2, text:'Blue'}], more:true}
     */
    function ajax(options) {
        var timeout, // current scheduled but not yet executed request
            handler = null,
            quietMillis = options.quietMillis || 100,
            ajaxUrl = options.url,
            self = this;

        return function (query) {
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                var data = options.data, // ajax data function
                    url = ajaxUrl, // ajax url string or function
                    transport = options.transport || $.fn.select2.ajaxDefaults.transport,
                // deprecated - to be removed in 4.0  - use params instead
                    deprecated = {
                        type: options.type || 'GET', // set type of request (GET or POST)
                        cache: options.cache || false,
                        jsonpCallback: options.jsonpCallback||undefined,
                        dataType: options.dataType||"json"
                    },
                    params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);

                data = data ? data.call(self, query.term, query.page, query.context) : null;
                url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;

                if (handler) { handler.abort(); }

                if (options.params) {
                    if ($.isFunction(options.params)) {
                        $.extend(params, options.params.call(self));
                    } else {
                        $.extend(params, options.params);
                    }
                }

                $.extend(params, {
                    url: url,
                    dataType: options.dataType,
                    data: data,
                    success: function (data) {
                        // TODO - replace query.page with query so users have access to term, page, etc.
                        var results = options.results(data, query.page);
                        query.callback(results);
                    }
                });
                handler = transport.call(self, params);
            }, quietMillis);
        };
    }

    /**
     * Produces a query function that works with a local array
     *
     * @param options object containing configuration parameters. The options parameter can either be an array or an
     * object.
     *
     * If the array form is used it is assumed that it contains objects with 'id' and 'text' keys.
     *
     * If the object form is used ti is assumed that it contains 'data' and 'text' keys. The 'data' key should contain
     * an array of objects that will be used as choices. These objects must contain at least an 'id' key. The 'text'
     * key can either be a String in which case it is expected that each element in the 'data' array has a key with the
     * value of 'text' which will be used to match choices. Alternatively, text can be a function(item) that can extract
     * the text.
     */
    function local(options) {
        var data = options, // data elements
            dataText,
            tmp,
            text = function (item) { return ""+item.text; }; // function used to retrieve the text portion of a data item that is matched against the search

        if ($.isArray(data)) {
            tmp = data;
            data = { results: tmp };
        }

        if ($.isFunction(data) === false) {
            tmp = data;
            data = function() { return tmp; };
        }

        var dataItem = data();
        if (dataItem.text) {
            text = dataItem.text;
            // if text is not a function we assume it to be a key name
            if (!$.isFunction(text)) {
                dataText = dataItem.text; // we need to store this in a separate variable because in the next step data gets reset and data.text is no longer available
                text = function (item) { return item[dataText]; };
            }
        }

        return function (query) {
            var t = query.term, filtered = { results: [] }, process;
            if (t === "") {
                query.callback(data());
                return;
            }

            process = function(datum, collection) {
                var group, attr;
                datum = datum[0];
                if (datum.children) {
                    group = {};
                    for (attr in datum) {
                        if (datum.hasOwnProperty(attr)) group[attr]=datum[attr];
                    }
                    group.children=[];
                    $(datum.children).each2(function(i, childDatum) { process(childDatum, group.children); });
                    if (group.children.length || query.matcher(t, text(group), datum)) {
                        collection.push(group);
                    }
                } else {
                    if (query.matcher(t, text(datum), datum)) {
                        collection.push(datum);
                    }
                }
            };

            $(data().results).each2(function(i, datum) { process(datum, filtered.results); });
            query.callback(filtered);
        };
    }

    // TODO javadoc
    function tags(data) {
        var isFunc = $.isFunction(data);
        return function (query) {
            var t = query.term, filtered = {results: []};
            $(isFunc ? data() : data).each(function () {
                var isObject = this.text !== undefined,
                    text = isObject ? this.text : this;
                if (t === "" || query.matcher(t, text)) {
                    filtered.results.push(isObject ? this : {id: this, text: this});
                }
            });
            query.callback(filtered);
        };
    }

    /**
     * Checks if the formatter function should be used.
     *
     * Throws an error if it is not a function. Returns true if it should be used,
     * false if no formatting should be performed.
     *
     * @param formatter
     */
    function checkFormatter(formatter, formatterName) {
        if ($.isFunction(formatter)) return true;
        if (!formatter) return false;
        throw new Error(formatterName +" must be a function or a falsy value");
    }

    function evaluate(val) {
        return $.isFunction(val) ? val() : val;
    }

    function countResults(results) {
        var count = 0;
        $.each(results, function(i, item) {
            if (item.children) {
                count += countResults(item.children);
            } else {
                count++;
            }
        });
        return count;
    }

    /**
     * Default tokenizer. This function uses breaks the input on substring match of any string from the
     * opts.tokenSeparators array and uses opts.createSearchChoice to create the choice object. Both of those
     * two options have to be defined in order for the tokenizer to work.
     *
     * @param input text user has typed so far or pasted into the search field
     * @param selection currently selected choices
     * @param selectCallback function(choice) callback tho add the choice to selection
     * @param opts select2's opts
     * @return undefined/null to leave the current input unchanged, or a string to change the input to the returned value
     */
    function defaultTokenizer(input, selection, selectCallback, opts) {
        var original = input, // store the original so we can compare and know if we need to tell the search to update its text
            dupe = false, // check for whether a token we extracted represents a duplicate selected choice
            token, // token
            index, // position at which the separator was found
            i, l, // looping variables
            separator; // the matched separator

        if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) return undefined;

        while (true) {
            index = -1;

            for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
                separator = opts.tokenSeparators[i];
                index = input.indexOf(separator);
                if (index >= 0) break;
            }

            if (index < 0) break; // did not find any token separator in the input string, bail

            token = input.substring(0, index);
            input = input.substring(index + separator.length);

            if (token.length > 0) {
                token = opts.createSearchChoice.call(this, token, selection);
                if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
                    dupe = false;
                    for (i = 0, l = selection.length; i < l; i++) {
                        if (equal(opts.id(token), opts.id(selection[i]))) {
                            dupe = true; break;
                        }
                    }

                    if (!dupe) selectCallback(token);
                }
            }
        }

        if (original!==input) return input;
    }

    /**
     * Creates a new class
     *
     * @param superClass
     * @param methods
     */
    function clazz(SuperClass, methods) {
        var constructor = function () {};
        constructor.prototype = new SuperClass;
        constructor.prototype.constructor = constructor;
        constructor.prototype.parent = SuperClass.prototype;
        constructor.prototype = $.extend(constructor.prototype, methods);
        return constructor;
    }

    AbstractSelect2 = clazz(Object, {

        // abstract
        bind: function (func) {
            var self = this;
            return function () {
                func.apply(self, arguments);
            };
        },

        // abstract
        init: function (opts) {
            var results, search, resultsSelector = ".select2-results";

            // prepare options
            this.opts = opts = this.prepareOpts(opts);

            this.id=opts.id;

            // destroy if called on an existing component
            if (opts.element.data("select2") !== undefined &&
                opts.element.data("select2") !== null) {
                opts.element.data("select2").destroy();
            }

            this.container = this.createContainer();

            this.containerId="s2id_"+(opts.element.attr("id") || "autogen"+nextUid());
            this.containerSelector="#"+this.containerId.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
            this.container.attr("id", this.containerId);

            // cache the body so future lookups are cheap
            this.body = thunk(function() { return opts.element.closest("body"); });

            syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);

            this.container.attr("style", opts.element.attr("style"));
            this.container.css(evaluate(opts.containerCss));
            this.container.addClass(evaluate(opts.containerCssClass));

            this.elementTabIndex = this.opts.element.attr("tabindex");

            // swap container for the element
            this.opts.element
                .data("select2", this)
                .attr("tabindex", "-1")
                .before(this.container)
                .on("click.select2", killEvent); // do not leak click events

            this.container.data("select2", this);

            this.dropdown = this.container.find(".select2-drop");

            syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);

            this.dropdown.addClass(evaluate(opts.dropdownCssClass));
            this.dropdown.data("select2", this);
            this.dropdown.on("click", killEvent);

            this.results = results = this.container.find(resultsSelector);
            this.search = search = this.container.find("input.select2-input");

            this.queryCount = 0;
            this.resultsPage = 0;
            this.context = null;

            // initialize the container
            this.initContainer();

            this.container.on("click", killEvent);

            installFilteredMouseMove(this.results);
            this.dropdown.on("mousemove-filtered touchstart touchmove touchend", resultsSelector, this.bind(this.highlightUnderEvent));

            installDebouncedScroll(80, this.results);
            this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));

            // do not propagate change event from the search field out of the component
            $(this.container).on("change", ".select2-input", function(e) {e.stopPropagation();});
            $(this.dropdown).on("change", ".select2-input", function(e) {e.stopPropagation();});

            // if jquery.mousewheel plugin is installed we can prevent out-of-bounds scrolling of results via mousewheel
            if ($.fn.mousewheel) {
                results.mousewheel(function (e, delta, deltaX, deltaY) {
                    var top = results.scrollTop();
                    if (deltaY > 0 && top - deltaY <= 0) {
                        results.scrollTop(0);
                        killEvent(e);
                    } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
                        results.scrollTop(results.get(0).scrollHeight - results.height());
                        killEvent(e);
                    }
                });
            }

            installKeyUpChangeEvent(search);
            search.on("keyup-change input paste", this.bind(this.updateResults));
            search.on("focus", function () { search.addClass("select2-focused"); });
            search.on("blur", function () { search.removeClass("select2-focused");});

            this.dropdown.on("mouseup", resultsSelector, this.bind(function (e) {
                if ($(e.target).closest(".select2-result-selectable").length > 0) {
                    this.highlightUnderEvent(e);
                    this.selectHighlighted(e);
                }
            }));

            // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
            // for mouse events outside of itself so it can close itself. since the dropdown is now outside the select2's
            // dom it will trigger the popup close, which is not what we want
            this.dropdown.on("click mouseup mousedown", function (e) { e.stopPropagation(); });

            if ($.isFunction(this.opts.initSelection)) {
                // initialize selection based on the current value of the source element
                this.initSelection();

                // if the user has provided a function that can set selection based on the value of the source element
                // we monitor the change event on the element and trigger it, allowing for two way synchronization
                this.monitorSource();
            }

            if (opts.maximumInputLength !== null) {
                this.search.attr("maxlength", opts.maximumInputLength);
            }

            var disabled = opts.element.prop("disabled");
            if (disabled === undefined) disabled = false;
            this.enable(!disabled);

            var readonly = opts.element.prop("readonly");
            if (readonly === undefined) readonly = false;
            this.readonly(readonly);

            // Calculate size of scrollbar
            scrollBarDimensions = scrollBarDimensions || measureScrollbar();

            this.autofocus = opts.element.prop("autofocus");
            opts.element.prop("autofocus", false);
            if (this.autofocus) this.focus();

            this.nextSearchTerm = undefined;
        },

        // abstract
        destroy: function () {
            var element=this.opts.element, select2 = element.data("select2");

            this.close();

            if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }

            if (select2 !== undefined) {
                select2.container.remove();
                select2.dropdown.remove();
                element
                    .removeClass("select2-offscreen")
                    .removeData("select2")
                    .off(".select2")
                    .prop("autofocus", this.autofocus || false);
                if (this.elementTabIndex) {
                    element.attr({tabindex: this.elementTabIndex});
                } else {
                    element.removeAttr("tabindex");
                }
                element.show();
            }
        },

        // abstract
        optionToData: function(element) {
            if (element.is("option")) {
                return {
                    id:element.prop("value"),
                    text:element.text(),
                    element: element.get(),
                    css: element.attr("class"),
                    disabled: element.prop("disabled"),
                    locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
                };
            } else if (element.is("optgroup")) {
                return {
                    text:element.attr("label"),
                    children:[],
                    element: element.get(),
                    css: element.attr("class")
                };
            }
        },

        // abstract
        prepareOpts: function (opts) {
            var element, select, idKey, ajaxUrl, self = this;

            element = opts.element;

            if (element.get(0).tagName.toLowerCase() === "select") {
                this.select = select = opts.element;
            }

            if (select) {
                // these options are not allowed when attached to a select because they are picked up off the element itself
                $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function () {
                    if (this in opts) {
                        throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                    }
                });
            }

            opts = $.extend({}, {
                populateResults: function(container, results, query) {
                    var populate, id=this.opts.id;

                    populate=function(results, container, depth) {

                        var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;

                        results = opts.sortResults(results, container, query);

                        for (i = 0, l = results.length; i < l; i = i + 1) {

                            result=results[i];

                            disabled = (result.disabled === true);
                            selectable = (!disabled) && (id(result) !== undefined);

                            compound=result.children && result.children.length > 0;

                            node=$("<li></li>");
                            node.addClass("select2-results-dept-"+depth);
                            node.addClass("select2-result");
                            node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
                            if (disabled) { node.addClass("select2-disabled"); }
                            if (compound) { node.addClass("select2-result-with-children"); }
                            node.addClass(self.opts.formatResultCssClass(result));

                            label=$(document.createElement("div"));
                            label.addClass("select2-result-label");

                            formatted=opts.formatResult(result, label, query, self.opts.escapeMarkup);
                            if (formatted!==undefined) {
                                label.html(formatted);
                            }

                            node.append(label);

                            if (compound) {

                                innerContainer=$("<ul></ul>");
                                innerContainer.addClass("select2-result-sub");
                                populate(result.children, innerContainer, depth+1);
                                node.append(innerContainer);
                            }

                            node.data("select2-data", result);
                            container.append(node);
                        }
                    };

                    populate(results, container, 0);
                }
            }, $.fn.select2.defaults, opts);

            if (typeof(opts.id) !== "function") {
                idKey = opts.id;
                opts.id = function (e) { return e[idKey]; };
            }

            if ($.isArray(opts.element.data("select2Tags"))) {
                if ("tags" in opts) {
                    throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
                }
                opts.tags=opts.element.data("select2Tags");
            }

            if (select) {
                opts.query = this.bind(function (query) {
                    var data = { results: [], more: false },
                        term = query.term,
                        children, placeholderOption, process;

                    process=function(element, collection) {
                        var group;
                        if (element.is("option")) {
                            if (query.matcher(term, element.text(), element)) {
                                collection.push(self.optionToData(element));
                            }
                        } else if (element.is("optgroup")) {
                            group=self.optionToData(element);
                            element.children().each2(function(i, elm) { process(elm, group.children); });
                            if (group.children.length>0) {
                                collection.push(group);
                            }
                        }
                    };

                    children=element.children();

                    // ignore the placeholder option if there is one
                    if (this.getPlaceholder() !== undefined && children.length > 0) {
                        placeholderOption = this.getPlaceholderOption();
                        if (placeholderOption) {
                            children=children.not(placeholderOption);
                        }
                    }

                    children.each2(function(i, elm) { process(elm, data.results); });

                    query.callback(data);
                });
                // this is needed because inside val() we construct choices from options and there id is hardcoded
                opts.id=function(e) { return e.id; };
                opts.formatResultCssClass = function(data) { return data.css; };
            } else {
                if (!("query" in opts)) {

                    if ("ajax" in opts) {
                        ajaxUrl = opts.element.data("ajax-url");
                        if (ajaxUrl && ajaxUrl.length > 0) {
                            opts.ajax.url = ajaxUrl;
                        }
                        opts.query = ajax.call(opts.element, opts.ajax);
                    } else if ("data" in opts) {
                        opts.query = local(opts.data);
                    } else if ("tags" in opts) {
                        opts.query = tags(opts.tags);
                        if (opts.createSearchChoice === undefined) {
                            opts.createSearchChoice = function (term) { return {id: $.trim(term), text: $.trim(term)}; };
                        }
                        if (opts.initSelection === undefined) {
                            opts.initSelection = function (element, callback) {
                                var data = [];
                                $(splitVal(element.val(), opts.separator)).each(function () {
                                    var obj = { id: this, text: this },
                                        tags = opts.tags;
                                    if ($.isFunction(tags)) tags=tags();
                                    $(tags).each(function() { if (equal(this.id, obj.id)) { obj = this; return false; } });
                                    data.push(obj);
                                });

                                callback(data);
                            };
                        }
                    }
                }
            }
            if (typeof(opts.query) !== "function") {
                throw "query function not defined for Select2 " + opts.element.attr("id");
            }

            return opts;
        },

        /**
         * Monitor the original element for changes and update select2 accordingly
         */
        // abstract
        monitorSource: function () {
            var el = this.opts.element, sync, observer;

            el.on("change.select2", this.bind(function (e) {
                if (this.opts.element.data("select2-change-triggered") !== true) {
                    this.initSelection();
                }
            }));

            sync = this.bind(function () {

                // sync enabled state
                var disabled = el.prop("disabled");
                if (disabled === undefined) disabled = false;
                this.enable(!disabled);

                var readonly = el.prop("readonly");
                if (readonly === undefined) readonly = false;
                this.readonly(readonly);

                syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
                this.container.addClass(evaluate(this.opts.containerCssClass));

                syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
                this.dropdown.addClass(evaluate(this.opts.dropdownCssClass));

            });

            // IE8-10
            el.on("propertychange.select2", sync);

            // hold onto a reference of the callback to work around a chromium bug
            if (this.mutationCallback === undefined) {
                this.mutationCallback = function (mutations) {
                    mutations.forEach(sync);
                }
            }

            // safari, chrome, firefox, IE11
            observer = window.MutationObserver || window.WebKitMutationObserver|| window.MozMutationObserver;
            if (observer !== undefined) {
                if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }
                this.propertyObserver = new observer(this.mutationCallback);
                this.propertyObserver.observe(el.get(0), { attributes:true, subtree:false });
            }
        },

        // abstract
        triggerSelect: function(data) {
            var evt = $.Event("select2-selecting", { val: this.id(data), object: data });
            this.opts.element.trigger(evt);
            return !evt.isDefaultPrevented();
        },

        /**
         * Triggers the change event on the source element
         */
        // abstract
        triggerChange: function (details) {

            details = details || {};
            details= $.extend({}, details, { type: "change", val: this.val() });
            // prevents recursive triggering
            this.opts.element.data("select2-change-triggered", true);
            this.opts.element.trigger(details);
            this.opts.element.data("select2-change-triggered", false);

            // some validation frameworks ignore the change event and listen instead to keyup, click for selects
            // so here we trigger the click event manually
            this.opts.element.click();

            // ValidationEngine ignorea the change event and listens instead to blur
            // so here we trigger the blur event manually if so desired
            if (this.opts.blurOnChange)
                this.opts.element.blur();
        },

        //abstract
        isInterfaceEnabled: function()
        {
            return this.enabledInterface === true;
        },

        // abstract
        enableInterface: function() {
            var enabled = this._enabled && !this._readonly,
                disabled = !enabled;

            if (enabled === this.enabledInterface) return false;

            this.container.toggleClass("select2-container-disabled", disabled);
            this.close();
            this.enabledInterface = enabled;

            return true;
        },

        // abstract
        enable: function(enabled) {
            if (enabled === undefined) enabled = true;
            if (this._enabled === enabled) return;
            this._enabled = enabled;

            this.opts.element.prop("disabled", !enabled);
            this.enableInterface();
        },

        // abstract
        disable: function() {
            this.enable(false);
        },

        // abstract
        readonly: function(enabled) {
            if (enabled === undefined) enabled = false;
            if (this._readonly === enabled) return false;
            this._readonly = enabled;

            this.opts.element.prop("readonly", enabled);
            this.enableInterface();
            return true;
        },

        // abstract
        opened: function () {
            return this.container.hasClass("select2-dropdown-open");
        },

        // abstract
        positionDropdown: function() {
            var $dropdown = this.dropdown,
                offset = this.container.offset(),
                height = this.container.outerHeight(false),
                width = this.container.outerWidth(false),
                dropHeight = $dropdown.outerHeight(false),
                $window = $(window),
                windowWidth = $window.width(),
                windowHeight = $window.height(),
                viewPortRight = $window.scrollLeft() + windowWidth,
                viewportBottom = $window.scrollTop() + windowHeight,
                dropTop = offset.top + height,
                dropLeft = offset.left,
                enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
                enoughRoomAbove = (offset.top - dropHeight) >= this.body().scrollTop(),
                dropWidth = $dropdown.outerWidth(false),
                enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight,
                aboveNow = $dropdown.hasClass("select2-drop-above"),
                bodyOffset,
                above,
                changeDirection,
                css,
                resultsListNode;

            // always prefer the current above/below alignment, unless there is not enough room
            if (aboveNow) {
                above = true;
                if (!enoughRoomAbove && enoughRoomBelow) {
                    changeDirection = true;
                    above = false;
                }
            } else {
                above = false;
                if (!enoughRoomBelow && enoughRoomAbove) {
                    changeDirection = true;
                    above = true;
                }
            }

            //if we are changing direction we need to get positions when dropdown is hidden;
            if (changeDirection) {
                $dropdown.hide();
                offset = this.container.offset();
                height = this.container.outerHeight(false);
                width = this.container.outerWidth(false);
                dropHeight = $dropdown.outerHeight(false);
                viewPortRight = $window.scrollLeft() + windowWidth;
                viewportBottom = $window.scrollTop() + windowHeight;
                dropTop = offset.top + height;
                dropLeft = offset.left;
                dropWidth = $dropdown.outerWidth(false);
                enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
                $dropdown.show();
            }

            if (this.opts.dropdownAutoWidth) {
                resultsListNode = $('.select2-results', $dropdown)[0];
                $dropdown.addClass('select2-drop-auto-width');
                $dropdown.css('width', '');
                // Add scrollbar width to dropdown if vertical scrollbar is present
                dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
                dropWidth > width ? width = dropWidth : dropWidth = width;
                enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
            }
            else {
                this.container.removeClass('select2-drop-auto-width');
            }

            //console.log("below/ droptop:", dropTop, "dropHeight", dropHeight, "sum", (dropTop+dropHeight)+" viewport bottom", viewportBottom, "enough?", enoughRoomBelow);
            //console.log("above/ offset.top", offset.top, "dropHeight", dropHeight, "top", (offset.top-dropHeight), "scrollTop", this.body().scrollTop(), "enough?", enoughRoomAbove);

            // fix positioning when body has an offset and is not position: static
            if (this.body().css('position') !== 'static') {
                bodyOffset = this.body().offset();
                dropTop -= bodyOffset.top;
                dropLeft -= bodyOffset.left;
            }

            if (!enoughRoomOnRight) {
                dropLeft = offset.left + width - dropWidth;
            }

            css =  {
                left: dropLeft,
                width: width
            };

            if (above) {
                css.bottom = windowHeight - offset.top;
                css.top = 'auto';
                this.container.addClass("select2-drop-above");
                $dropdown.addClass("select2-drop-above");
            }
            else {
                css.top = dropTop;
                css.bottom = 'auto';
                this.container.removeClass("select2-drop-above");
                $dropdown.removeClass("select2-drop-above");
            }
            css = $.extend(css, evaluate(this.opts.dropdownCss));

            $dropdown.css(css);
        },

        // abstract
        shouldOpen: function() {
            var event;

            if (this.opened()) return false;

            if (this._enabled === false || this._readonly === true) return false;

            event = $.Event("select2-opening");
            this.opts.element.trigger(event);
            return !event.isDefaultPrevented();
        },

        // abstract
        clearDropdownAlignmentPreference: function() {
            // clear the classes used to figure out the preference of where the dropdown should be opened
            this.container.removeClass("select2-drop-above");
            this.dropdown.removeClass("select2-drop-above");
        },

        /**
         * Opens the dropdown
         *
         * @return {Boolean} whether or not dropdown was opened. This method will return false if, for example,
         * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
         */
        // abstract
        open: function () {

            if (!this.shouldOpen()) return false;

            this.opening();

            return true;
        },

        /**
         * Performs the opening of the dropdown
         */
        // abstract
        opening: function() {
            var cid = this.containerId,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid,
                mask;

            this.container.addClass("select2-dropdown-open").addClass("select2-container-active");

            this.clearDropdownAlignmentPreference();

            if(this.dropdown[0] !== this.body().children().last()[0]) {
                this.dropdown.detach().appendTo(this.body());
            }

            // create the dropdown mask if doesnt already exist
            mask = $("#select2-drop-mask");
            if (mask.length == 0) {
                mask = $(document.createElement("div"));
                mask.attr("id","select2-drop-mask").attr("class","select2-drop-mask");
                mask.hide();
                mask.appendTo(this.body());
                mask.on("mousedown touchstart click", function (e) {
                    var dropdown = $("#select2-drop"), self;
                    if (dropdown.length > 0) {
                        self=dropdown.data("select2");
                        if (self.opts.selectOnBlur) {
                            self.selectHighlighted({noFocus: true});
                        }
                        self.close({focus:true});
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
            }

            // ensure the mask is always right before the dropdown
            if (this.dropdown.prev()[0] !== mask[0]) {
                this.dropdown.before(mask);
            }

            // move the global id to the correct dropdown
            $("#select2-drop").removeAttr("id");
            this.dropdown.attr("id", "select2-drop");

            // show the elements
            mask.show();

            this.positionDropdown();
            this.dropdown.show();
            this.positionDropdown();

            this.dropdown.addClass("select2-drop-active");

            // attach listeners to events that can change the position of the container and thus require
            // the position of the dropdown to be updated as well so it does not come unglued from the container
            var that = this;
            this.container.parents().add(window).each(function () {
                $(this).on(resize+" "+scroll+" "+orient, function (e) {
                    that.positionDropdown();
                });
            });


        },

        // abstract
        close: function () {
            if (!this.opened()) return;

            var cid = this.containerId,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid;

            // unbind event listeners
            this.container.parents().add(window).each(function () { $(this).off(scroll).off(resize).off(orient); });

            this.clearDropdownAlignmentPreference();

            $("#select2-drop-mask").hide();
            this.dropdown.removeAttr("id"); // only the active dropdown has the select2-drop id
            this.dropdown.hide();
            this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
            this.results.empty();


            this.clearSearch();
            this.search.removeClass("select2-active");
            this.opts.element.trigger($.Event("select2-close"));
        },

        /**
         * Opens control, sets input value, and updates results.
         */
        // abstract
        externalSearch: function (term) {
            this.open();
            this.search.val(term);
            this.updateResults(false);
        },

        // abstract
        clearSearch: function () {

        },

        //abstract
        getMaximumSelectionSize: function() {
            return evaluate(this.opts.maximumSelectionSize);
        },

        // abstract
        ensureHighlightVisible: function () {
            var results = this.results, children, index, child, hb, rb, y, more;

            index = this.highlight();

            if (index < 0) return;

            if (index == 0) {

                // if the first element is highlighted scroll all the way to the top,
                // that way any unselectable headers above it will also be scrolled
                // into view

                results.scrollTop(0);
                return;
            }

            children = this.findHighlightableChoices().find('.select2-result-label');

            child = $(children[index]);

            hb = child.offset().top + child.outerHeight(true);

            // if this is the last child lets also make sure select2-more-results is visible
            if (index === children.length - 1) {
                more = results.find("li.select2-more-results");
                if (more.length > 0) {
                    hb = more.offset().top + more.outerHeight(true);
                }
            }

            rb = results.offset().top + results.outerHeight(true);
            if (hb > rb) {
                results.scrollTop(results.scrollTop() + (hb - rb));
            }
            y = child.offset().top - results.offset().top;

            // make sure the top of the element is visible
            if (y < 0 && child.css('display') != 'none' ) {
                results.scrollTop(results.scrollTop() + y); // y is negative
            }
        },

        // abstract
        findHighlightableChoices: function() {
            return this.results.find(".select2-result-selectable:not(.select2-disabled, .select2-selected)");
        },

        // abstract
        moveHighlight: function (delta) {
            var choices = this.findHighlightableChoices(),
                index = this.highlight();

            while (index > -1 && index < choices.length) {
                index += delta;
                var choice = $(choices[index]);
                if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
                    this.highlight(index);
                    break;
                }
            }
        },

        // abstract
        highlight: function (index) {
            var choices = this.findHighlightableChoices(),
                choice,
                data;

            if (arguments.length === 0) {
                return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
            }

            if (index >= choices.length) index = choices.length - 1;
            if (index < 0) index = 0;

            this.removeHighlight();

            choice = $(choices[index]);
            choice.addClass("select2-highlighted");

            this.ensureHighlightVisible();

            data = choice.data("select2-data");
            if (data) {
                this.opts.element.trigger({ type: "select2-highlight", val: this.id(data), choice: data });
            }
        },

        removeHighlight: function() {
            this.results.find(".select2-highlighted").removeClass("select2-highlighted");
        },

        // abstract
        countSelectableResults: function() {
            return this.findHighlightableChoices().length;
        },

        // abstract
        highlightUnderEvent: function (event) {
            var el = $(event.target).closest(".select2-result-selectable");
            if (el.length > 0 && !el.is(".select2-highlighted")) {
                var choices = this.findHighlightableChoices();
                this.highlight(choices.index(el));
            } else if (el.length == 0) {
                // if we are over an unselectable item remove all highlights
                this.removeHighlight();
            }
        },

        // abstract
        loadMoreIfNeeded: function () {
            var results = this.results,
                more = results.find("li.select2-more-results"),
                below, // pixels the element is below the scroll fold, below==0 is when the element is starting to be visible
                page = this.resultsPage + 1,
                self=this,
                term=this.search.val(),
                context=this.context;

            if (more.length === 0) return;
            below = more.offset().top - results.offset().top - results.height();

            if (below <= this.opts.loadMorePadding) {
                more.addClass("select2-active");
                this.opts.query({
                    element: this.opts.element,
                    term: term,
                    page: page,
                    context: context,
                    matcher: this.opts.matcher,
                    callback: this.bind(function (data) {

                        // ignore a response if the select2 has been closed before it was received
                        if (!self.opened()) return;


                        self.opts.populateResults.call(this, results, data.results, {term: term, page: page, context:context});
                        self.postprocessResults(data, false, false);

                        if (data.more===true) {
                            more.detach().appendTo(results).text(self.opts.formatLoadMore(page+1));
                            window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                        } else {
                            more.remove();
                        }
                        self.positionDropdown();
                        self.resultsPage = page;
                        self.context = data.context;
                        this.opts.element.trigger({ type: "select2-loaded", items: data });
                    })});
            }
        },

        /**
         * Default tokenizer function which does nothing
         */
        tokenize: function() {

        },

        /**
         * @param initial whether or not this is the call to this method right after the dropdown has been opened
         */
        // abstract
        updateResults: function (initial) {
            var search = this.search,
                results = this.results,
                opts = this.opts,
                data,
                self = this,
                input,
                term = search.val(),
                lastTerm = $.data(this.container, "select2-last-term"),
            // sequence number used to drop out-of-order responses
                queryNumber;

            // prevent duplicate queries against the same term
            if (initial !== true && lastTerm && equal(term, lastTerm)) return;

            $.data(this.container, "select2-last-term", term);

            // if the search is currently hidden we do not alter the results
            if (initial !== true && (this.showSearchInput === false || !this.opened())) {
                return;
            }

            function postRender() {
                search.removeClass("select2-active");
                self.positionDropdown();
            }

            function render(html) {
                results.html(html);
                postRender();
            }

            queryNumber = ++this.queryCount;

            var maxSelSize = this.getMaximumSelectionSize();
            if (maxSelSize >=1) {
                data = this.data();
                if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
                    render("<li class='select2-selection-limit'>" + opts.formatSelectionTooBig(maxSelSize) + "</li>");
                    return;
                }
            }

            if (search.val().length < opts.minimumInputLength) {
                if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
                    render("<li class='select2-no-results'>" + opts.formatInputTooShort(search.val(), opts.minimumInputLength) + "</li>");
                } else {
                    render("");
                }
                if (initial && this.showSearch) this.showSearch(true);
                return;
            }

            if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
                if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
                    render("<li class='select2-no-results'>" + opts.formatInputTooLong(search.val(), opts.maximumInputLength) + "</li>");
                } else {
                    render("");
                }
                return;
            }

            if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
                render("<li class='select2-searching'>" + opts.formatSearching() + "</li>");
            }

            search.addClass("select2-active");

            this.removeHighlight();

            // give the tokenizer a chance to pre-process the input
            input = this.tokenize();
            if (input != undefined && input != null) {
                search.val(input);
            }

            this.resultsPage = 1;

            opts.query({
                element: opts.element,
                term: search.val(),
                page: this.resultsPage,
                context: null,
                matcher: opts.matcher,
                callback: this.bind(function (data) {
                    var def; // default choice

                    // ignore old responses
                    if (queryNumber != this.queryCount) {
                        return;
                    }

                    // ignore a response if the select2 has been closed before it was received
                    if (!this.opened()) {
                        this.search.removeClass("select2-active");
                        return;
                    }

                    // save context, if any
                    this.context = (data.context===undefined) ? null : data.context;
                    // create a default choice and prepend it to the list
                    if (this.opts.createSearchChoice && search.val() !== "") {
                        def = this.opts.createSearchChoice.call(self, search.val(), data.results);
                        if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
                            if ($(data.results).filter(
                                function () {
                                    return equal(self.id(this), self.id(def));
                                }).length === 0) {
                                data.results.unshift(def);
                            }
                        }
                    }

                    if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
                        render("<li class='select2-no-results'>" + opts.formatNoMatches(search.val()) + "</li>");
                        return;
                    }

                    results.empty();
                    self.opts.populateResults.call(this, results, data.results, {term: search.val(), page: this.resultsPage, context:null});

                    if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
                        results.append("<li class='select2-more-results'>" + self.opts.escapeMarkup(opts.formatLoadMore(this.resultsPage)) + "</li>");
                        window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                    }

                    this.postprocessResults(data, initial);

                    postRender();

                    this.opts.element.trigger({ type: "select2-loaded", items: data });
                })});
        },

        // abstract
        cancel: function () {
            this.close();
        },

        // abstract
        blur: function () {
            // if selectOnBlur == true, select the currently highlighted option
            if (this.opts.selectOnBlur)
                this.selectHighlighted({noFocus: true});

            this.close();
            this.container.removeClass("select2-container-active");
            // synonymous to .is(':focus'), which is available in jquery >= 1.6
            if (this.search[0] === document.activeElement) { this.search.blur(); }
            this.clearSearch();
            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
        },

        // abstract
        focusSearch: function () {
            focus(this.search);
        },

        // abstract
        selectHighlighted: function (options) {
            var index=this.highlight(),
                highlighted=this.results.find(".select2-highlighted"),
                data = highlighted.closest('.select2-result').data("select2-data");

            if (data) {
                this.highlight(index);
                this.onSelect(data, options);
            } else if (options && options.noFocus) {
                this.close();
            }
        },

        // abstract
        getPlaceholder: function () {
            var placeholderOption;
            return this.opts.element.attr("placeholder") ||
                this.opts.element.attr("data-placeholder") || // jquery 1.4 compat
                this.opts.element.data("placeholder") ||
                this.opts.placeholder ||
                ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
        },

        // abstract
        getPlaceholderOption: function() {
            if (this.select) {
                var firstOption = this.select.children('option').first();
                if (this.opts.placeholderOption !== undefined ) {
                    //Determine the placeholder option based on the specified placeholderOption setting
                    return (this.opts.placeholderOption === "first" && firstOption) ||
                        (typeof this.opts.placeholderOption === "function" && this.opts.placeholderOption(this.select));
                } else if (firstOption.text() === "" && firstOption.val() === "") {
                    //No explicit placeholder option specified, use the first if it's blank
                    return firstOption;
                }
            }
        },

        /**
         * Get the desired width for the container element.  This is
         * derived first from option `width` passed to select2, then
         * the inline 'style' on the original element, and finally
         * falls back to the jQuery calculated element width.
         */
        // abstract
        initContainerWidth: function () {
            function resolveContainerWidth() {
                var style, attrs, matches, i, l, attr;

                if (this.opts.width === "off") {
                    return null;
                } else if (this.opts.width === "element"){
                    return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
                } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
                    // check if there is inline style on the element that contains width
                    style = this.opts.element.attr('style');
                    if (style !== undefined) {
                        attrs = style.split(';');
                        for (i = 0, l = attrs.length; i < l; i = i + 1) {
                            attr = attrs[i].replace(/\s/g, '');
                            matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
                            if (matches !== null && matches.length >= 1)
                                return matches[1];
                        }
                    }

                    if (this.opts.width === "resolve") {
                        // next check if css('width') can resolve a width that is percent based, this is sometimes possible
                        // when attached to input type=hidden or elements hidden via css
                        style = this.opts.element.css('width');
                        if (style.indexOf("%") > 0) return style;

                        // finally, fallback on the calculated width of the element
                        return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
                    }

                    return null;
                } else if ($.isFunction(this.opts.width)) {
                    return this.opts.width();
                } else {
                    return this.opts.width;
                }
            };

            var width = resolveContainerWidth.call(this);
            if (width !== null) {
                this.container.css("width", width);
            }
        }
    });

    SingleSelect2 = clazz(AbstractSelect2, {

        // single

        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container"
            }).html([
                    "<a href='javascript:void(0)' onclick='return false;' class='select2-choice' tabindex='-1'>",
                    "   <span class='select2-chosen'>&nbsp;</span><abbr class='select2-search-choice-close'></abbr>",
                    "   <span class='select2-arrow'><b></b></span>",
                    "</a>",
                    "<input class='select2-focusser select2-offscreen' type='text'/>",
                    "<div class='select2-drop select2-display-none'>",
                    "   <div class='select2-search'>",
                    "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'/>",
                    "   </div>",
                    "   <ul class='select2-results'>",
                    "   </ul>",
                    "</div>"].join(""));
            return container;
        },

        // single
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.focusser.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // single
        opening: function () {
            var el, range, len;

            if (this.opts.minimumResultsForSearch >= 0) {
                this.showSearch(true);
            }

            this.parent.opening.apply(this, arguments);

            if (this.showSearchInput !== false) {
                // IE appends focusser.val() at the end of field :/ so we manually insert it at the beginning using a range
                // all other browsers handle this just fine

                this.search.val(this.focusser.val());
            }
            this.search.focus();
            // move the cursor to the end after focussing, otherwise it will be at the beginning and
            // new text will appear *before* focusser.val()
            el = this.search.get(0);
            if (el.createTextRange) {
                range = el.createTextRange();
                range.collapse(false);
                range.select();
            } else if (el.setSelectionRange) {
                len = this.search.val().length;
                el.setSelectionRange(len, len);
            }

            // initializes search's value with nextSearchTerm (if defined by user)
            // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
            if(this.search.val() === "") {
                if(this.nextSearchTerm != undefined){
                    this.search.val(this.nextSearchTerm);
                    this.search.select();
                }
            }

            this.focusser.prop("disabled", true).val("");
            this.updateResults(true);
            this.opts.element.trigger($.Event("select2-open"));
        },

        // single
        close: function (params) {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);

            params = params || {focus: true};
            this.focusser.removeAttr("disabled");

            if (params.focus) {
                this.focusser.focus();
            }
        },

        // single
        focus: function () {
            if (this.opened()) {
                this.close();
            } else {
                this.focusser.removeAttr("disabled");
                this.focusser.focus();
            }
        },

        // single
        isFocused: function () {
            return this.container.hasClass("select2-container-active");
        },

        // single
        cancel: function () {
            this.parent.cancel.apply(this, arguments);
            this.focusser.removeAttr("disabled");
            this.focusser.focus();
        },

        // single
        destroy: function() {
            $("label[for='" + this.focusser.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);
        },

        // single
        initContainer: function () {

            var selection,
                container = this.container,
                dropdown = this.dropdown;

            if (this.opts.minimumResultsForSearch < 0) {
                this.showSearch(false);
            } else {
                this.showSearch(true);
            }

            this.selection = selection = container.find(".select2-choice");

            this.focusser = container.find(".select2-focusser");

            // rewrite labels from original element to focusser
            this.focusser.attr("id", "s2id_autogen"+nextUid());

            $("label[for='" + this.opts.element.attr("id") + "']")
                .attr('for', this.focusser.attr('id'));

            this.focusser.attr("tabindex", this.elementTabIndex);

            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                    return;
                }

                switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({noFocus: true});
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                }
            }));

            this.search.on("blur", this.bind(function(e) {
                // a workaround for chrome to keep the search field focussed when the scroll bar is used to scroll the dropdown.
                // without this the search field loses focus which is annoying
                if (document.activeElement === this.body().get(0)) {
                    window.setTimeout(this.bind(function() {
                        this.search.focus();
                    }), 0);
                }
            }));

            this.focusser.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                    return;
                }

                if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DOWN || e.which == KEY.UP
                    || (e.which == KEY.ENTER && this.opts.openOnEnter)) {

                    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) return;

                    this.open();
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
                    if (this.opts.allowClear) {
                        this.clear();
                    }
                    killEvent(e);
                    return;
                }
            }));


            installKeyUpChangeEvent(this.focusser);
            this.focusser.on("keyup-change input", this.bind(function(e) {
                if (this.opts.minimumResultsForSearch >= 0) {
                    e.stopPropagation();
                    if (this.opened()) return;
                    this.open();
                }
            }));

            selection.on("mousedown", "abbr", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;
                this.clear();
                killEventImmediately(e);
                this.close();
                this.selection.focus();
            }));

            selection.on("mousedown", this.bind(function (e) {

                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }

                if (this.opened()) {
                    this.close();
                } else if (this.isInterfaceEnabled()) {
                    this.open();
                }

                killEvent(e);
            }));

            dropdown.on("mousedown", this.bind(function() { this.search.focus(); }));

            selection.on("focus", this.bind(function(e) {
                killEvent(e);
            }));

            this.focusser.on("focus", this.bind(function(){
                    if (!this.container.hasClass("select2-container-active")) {
                        this.opts.element.trigger($.Event("select2-focus"));
                    }
                    this.container.addClass("select2-container-active");
                })).on("blur", this.bind(function() {
                    if (!this.opened()) {
                        this.container.removeClass("select2-container-active");
                        this.opts.element.trigger($.Event("select2-blur"));
                    }
                }));
            this.search.on("focus", this.bind(function(){
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            }));

            this.initContainerWidth();
            this.opts.element.addClass("select2-offscreen");
            this.setPlaceholder();

        },

        // single
        clear: function(triggerChange) {
            var data=this.selection.data("select2-data");
            if (data) { // guard against queued quick consecutive clicks
                var evt = $.Event("select2-clearing");
                this.opts.element.trigger(evt);
                if (evt.isDefaultPrevented()) {
                    return;
                }
                var placeholderOption = this.getPlaceholderOption();
                this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
                this.selection.find(".select2-chosen").empty();
                this.selection.removeData("select2-data");
                this.setPlaceholder();

                if (triggerChange !== false){
                    this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
                    this.triggerChange({removed:data});
                }
            }
        },

        /**
         * Sets selection based on source element's value
         */
        // single
        initSelection: function () {
            var selected;
            if (this.isPlaceholderOptionSelected()) {
                this.updateSelection(null);
                this.close();
                this.setPlaceholder();
            } else {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(selected){
                    if (selected !== undefined && selected !== null) {
                        self.updateSelection(selected);
                        self.close();
                        self.setPlaceholder();
                    }
                });
            }
        },

        isPlaceholderOptionSelected: function() {
            var placeholderOption;
            if (!this.getPlaceholder()) return false; // no placeholder specified so no option should be considered
            return ((placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop("selected"))
                || (this.opts.element.val() === "")
                || (this.opts.element.val() === undefined)
                || (this.opts.element.val() === null);
        },

        // single
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install the selection initializer
                opts.initSelection = function (element, callback) {
                    var selected = element.find("option").filter(function() { return this.selected });
                    // a single select box always has a value, no need to null check 'selected'
                    callback(self.optionToData(selected));
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var id = element.val();
                    //search in data by id, storing the actual matching item
                    var match = null;
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = equal(id, opts.id(el));
                            if (is_match) {
                                match = el;
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            callback(match);
                        }
                    });
                };
            }

            return opts;
        },

        // single
        getPlaceholder: function() {
            // if a placeholder is specified on a single select without a valid placeholder option ignore it
            if (this.select) {
                if (this.getPlaceholderOption() === undefined) {
                    return undefined;
                }
            }

            return this.parent.getPlaceholder.apply(this, arguments);
        },

        // single
        setPlaceholder: function () {
            var placeholder = this.getPlaceholder();

            if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {

                // check for a placeholder option if attached to a select
                if (this.select && this.getPlaceholderOption() === undefined) return;

                this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));

                this.selection.addClass("select2-default");

                this.container.removeClass("select2-allowclear");
            }
        },

        // single
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var selected = 0, self = this, showSearchInput = true;

            // find the selected element in the result list

            this.findHighlightableChoices().each2(function (i, elm) {
                if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
                    selected = i;
                    return false;
                }
            });

            // and highlight it
            if (noHighlightUpdate !== false) {
                if (initial === true && selected >= 0) {
                    this.highlight(selected);
                } else {
                    this.highlight(0);
                }
            }

            // hide the search box if this is the first we got the results and there are enough of them for search

            if (initial === true) {
                var min = this.opts.minimumResultsForSearch;
                if (min >= 0) {
                    this.showSearch(countResults(data.results) >= min);
                }
            }
        },

        // single
        showSearch: function(showSearchInput) {
            if (this.showSearchInput === showSearchInput) return;

            this.showSearchInput = showSearchInput;

            this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
            this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
            //add "select2-with-searchbox" to the container if search box is shown
            $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
        },

        // single
        onSelect: function (data, options) {

            if (!this.triggerSelect(data)) { return; }

            var old = this.opts.element.val(),
                oldData = this.data();

            this.opts.element.val(this.id(data));
            this.updateSelection(data);

            this.opts.element.trigger({ type: "select2-selected", val: this.id(data), choice: data });

            this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
            this.close();

            if (!options || !options.noFocus)
                this.focusser.focus();

            if (!equal(old, this.id(data))) { this.triggerChange({added:data,removed:oldData}); }
        },

        // single
        updateSelection: function (data) {

            var container=this.selection.find(".select2-chosen"), formatted, cssClass;

            this.selection.data("select2-data", data);

            container.empty();
            if (data !== null) {
                formatted=this.opts.formatSelection(data, container, this.opts.escapeMarkup);
            }
            if (formatted !== undefined) {
                container.append(formatted);
            }
            cssClass=this.opts.formatSelectionCssClass(data, container);
            if (cssClass !== undefined) {
                container.addClass(cssClass);
            }

            this.selection.removeClass("select2-default");

            if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
                this.container.addClass("select2-allowclear");
            }
        },

        // single
        val: function () {
            var val,
                triggerChange = false,
                data = null,
                self = this,
                oldData = this.data();

            if (arguments.length === 0) {
                return this.opts.element.val();
            }

            val = arguments[0];

            if (arguments.length > 1) {
                triggerChange = arguments[1];
            }

            if (this.select) {
                this.select
                    .val(val)
                    .find("option").filter(function() { return this.selected }).each2(function (i, elm) {
                        data = self.optionToData(elm);
                        return false;
                    });
                this.updateSelection(data);
                this.setPlaceholder();
                if (triggerChange) {
                    this.triggerChange({added: data, removed:oldData});
                }
            } else {
                // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
                if (!val && val !== 0) {
                    this.clear(triggerChange);
                    return;
                }
                if (this.opts.initSelection === undefined) {
                    throw new Error("cannot call val() if initSelection() is not defined");
                }
                this.opts.element.val(val);
                this.opts.initSelection(this.opts.element, function(data){
                    self.opts.element.val(!data ? "" : self.id(data));
                    self.updateSelection(data);
                    self.setPlaceholder();
                    if (triggerChange) {
                        self.triggerChange({added: data, removed:oldData});
                    }
                });
            }
        },

        // single
        clearSearch: function () {
            this.search.val("");
            this.focusser.val("");
        },

        // single
        data: function(value) {
            var data,
                triggerChange = false;

            if (arguments.length === 0) {
                data = this.selection.data("select2-data");
                if (data == undefined) data = null;
                return data;
            } else {
                if (arguments.length > 1) {
                    triggerChange = arguments[1];
                }
                if (!value) {
                    this.clear(triggerChange);
                } else {
                    data = this.data();
                    this.opts.element.val(!value ? "" : this.id(value));
                    this.updateSelection(value);
                    if (triggerChange) {
                        this.triggerChange({added: value, removed:data});
                    }
                }
            }
        }
    });

    MultiSelect2 = clazz(AbstractSelect2, {

        // multi
        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container select2-container-multi"
            }).html([
                    "<ul class='select2-choices'>",
                    "  <li class='select2-search-field'>",
                    "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>",
                    "  </li>",
                    "</ul>",
                    "<div class='select2-drop select2-drop-multi select2-display-none'>",
                    "   <ul class='select2-results'>",
                    "   </ul>",
                    "</div>"].join(""));
            return container;
        },

        // multi
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            // TODO validate placeholder is a string if specified

            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install sthe selection initializer
                opts.initSelection = function (element, callback) {

                    var data = [];

                    element.find("option").filter(function() { return this.selected }).each2(function (i, elm) {
                        data.push(self.optionToData(elm));
                    });
                    callback(data);
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var ids = splitVal(element.val(), opts.separator);
                    //search in data by array of ids, storing matching items in a list
                    var matches = [];
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = $.grep(ids, function(id) {
                                return equal(id, opts.id(el));
                            }).length;
                            if (is_match) {
                                matches.push(el);
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            // reorder matches based on the order they appear in the ids array because right now
                            // they are in the order in which they appear in data array
                            var ordered = [];
                            for (var i = 0; i < ids.length; i++) {
                                var id = ids[i];
                                for (var j = 0; j < matches.length; j++) {
                                    var match = matches[j];
                                    if (equal(id, opts.id(match))) {
                                        ordered.push(match);
                                        matches.splice(j, 1);
                                        break;
                                    }
                                }
                            }
                            callback(ordered);
                        }
                    });
                };
            }

            return opts;
        },

        // multi
        selectChoice: function (choice) {

            var selected = this.container.find(".select2-search-choice-focus");
            if (selected.length && choice && choice[0] == selected[0]) {

            } else {
                if (selected.length) {
                    this.opts.element.trigger("choice-deselected", selected);
                }
                selected.removeClass("select2-search-choice-focus");
                if (choice && choice.length) {
                    this.close();
                    choice.addClass("select2-search-choice-focus");
                    this.opts.element.trigger("choice-selected", choice);
                }
            }
        },

        // multi
        destroy: function() {
            $("label[for='" + this.search.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);
        },

        // multi
        initContainer: function () {

            var selector = ".select2-choices", selection;

            this.searchContainer = this.container.find(".select2-search-field");
            this.selection = selection = this.container.find(selector);

            var _this = this;
            this.selection.on("click", ".select2-search-choice:not(.select2-locked)", function (e) {
                //killEvent(e);
                _this.search[0].focus();
                _this.selectChoice($(this));
            });

            // rewrite labels from original element to focusser
            this.search.attr("id", "s2id_autogen"+nextUid());
            $("label[for='" + this.opts.element.attr("id") + "']")
                .attr('for', this.search.attr('id'));

            this.search.on("input paste", this.bind(function() {
                if (!this.isInterfaceEnabled()) return;
                if (!this.opened()) {
                    this.open();
                }
            }));

            this.search.attr("tabindex", this.elementTabIndex);

            this.keydowns = 0;
            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                ++this.keydowns;
                var selected = selection.find(".select2-search-choice-focus");
                var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
                var next = selected.next(".select2-search-choice:not(.select2-locked)");
                var pos = getCursorInfo(this.search);

                if (selected.length &&
                    (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
                    var selectedChoice = selected;
                    if (e.which == KEY.LEFT && prev.length) {
                        selectedChoice = prev;
                    }
                    else if (e.which == KEY.RIGHT) {
                        selectedChoice = next.length ? next : null;
                    }
                    else if (e.which === KEY.BACKSPACE) {
                        this.unselect(selected.first());
                        this.search.width(10);
                        selectedChoice = prev.length ? prev : next;
                    } else if (e.which == KEY.DELETE) {
                        this.unselect(selected.first());
                        this.search.width(10);
                        selectedChoice = next.length ? next : null;
                    } else if (e.which == KEY.ENTER) {
                        selectedChoice = null;
                    }

                    this.selectChoice(selectedChoice);
                    killEvent(e);
                    if (!selectedChoice || !selectedChoice.length) {
                        this.open();
                    }
                    return;
                } else if (((e.which === KEY.BACKSPACE && this.keydowns == 1)
                    || e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {

                    this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
                    killEvent(e);
                    return;
                } else {
                    this.selectChoice(null);
                }

                if (this.opened()) {
                    switch (e.which) {
                        case KEY.UP:
                        case KEY.DOWN:
                            this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                            killEvent(e);
                            return;
                        case KEY.ENTER:
                            this.selectHighlighted();
                            killEvent(e);
                            return;
                        case KEY.TAB:
                            this.selectHighlighted({noFocus:true});
                            this.close();
                            return;
                        case KEY.ESC:
                            this.cancel(e);
                            killEvent(e);
                            return;
                    }
                }

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e)
                    || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
                    return;
                }

                if (e.which === KEY.ENTER) {
                    if (this.opts.openOnEnter === false) {
                        return;
                    } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                        return;
                    }
                }

                this.open();

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                }

                if (e.which === KEY.ENTER) {
                    // prevent form from being submitted
                    killEvent(e);
                }

            }));

            this.search.on("keyup", this.bind(function (e) {
                this.keydowns = 0;
                this.resizeSearch();
            })
            );

            this.search.on("blur", this.bind(function(e) {
                this.container.removeClass("select2-container-active");
                this.search.removeClass("select2-focused");
                this.selectChoice(null);
                if (!this.opened()) this.clearSearch();
                e.stopImmediatePropagation();
                this.opts.element.trigger($.Event("select2-blur"));
            }));

            this.container.on("click", selector, this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;
                if ($(e.target).closest(".select2-search-choice").length > 0) {
                    // clicked inside a select2 search choice, do not open
                    return;
                }
                this.selectChoice(null);
                this.clearPlaceholder();
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.open();
                this.focusSearch();
                e.preventDefault();
            }));

            this.container.on("focus", selector, this.bind(function () {
                if (!this.isInterfaceEnabled()) return;
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
                this.dropdown.addClass("select2-drop-active");
                this.clearPlaceholder();
            }));

            this.initContainerWidth();
            this.opts.element.addClass("select2-offscreen");

            // set the placeholder if necessary
            this.clearSearch();
        },

        // multi
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.search.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // multi
        initSelection: function () {
            var data;
            if (this.opts.element.val() === "" && this.opts.element.text() === "") {
                this.updateSelection([]);
                this.close();
                // set the placeholder if necessary
                this.clearSearch();
            }
            if (this.select || this.opts.element.val() !== "") {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(data){
                    if (data !== undefined && data !== null) {
                        self.updateSelection(data);
                        self.close();
                        // set the placeholder if necessary
                        self.clearSearch();
                    }
                });
            }
        },

        // multi
        clearSearch: function () {
            var placeholder = this.getPlaceholder(),
                maxWidth = this.getMaxSearchWidth();

            if (placeholder !== undefined  && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
                this.search.val(placeholder).addClass("select2-default");
                // stretch the search box to full width of the container so as much of the placeholder is visible as possible
                // we could call this.resizeSearch(), but we do not because that requires a sizer and we do not want to create one so early because of a firefox bug, see #944
                this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
            } else {
                this.search.val("").width(10);
            }
        },

        // multi
        clearPlaceholder: function () {
            if (this.search.hasClass("select2-default")) {
                this.search.val("").removeClass("select2-default");
            }
        },

        // multi
        opening: function () {
            this.clearPlaceholder(); // should be done before super so placeholder is not used to search
            this.resizeSearch();

            this.parent.opening.apply(this, arguments);

            this.focusSearch();

            this.updateResults(true);
            this.search.focus();
            this.opts.element.trigger($.Event("select2-open"));
        },

        // multi
        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);
        },

        // multi
        focus: function () {
            this.close();
            this.search.focus();
        },

        // multi
        isFocused: function () {
            return this.search.hasClass("select2-focused");
        },

        // multi
        updateSelection: function (data) {
            var ids = [], filtered = [], self = this;

            // filter out duplicates
            $(data).each(function () {
                if (indexOf(self.id(this), ids) < 0) {
                    ids.push(self.id(this));
                    filtered.push(this);
                }
            });
            data = filtered;

            this.selection.find(".select2-search-choice").remove();
            $(data).each(function () {
                self.addSelectedChoice(this);
            });
            self.postprocessResults();
        },

        // multi
        tokenize: function() {
            var input = this.search.val();
            input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
            if (input != null && input != undefined) {
                this.search.val(input);
                if (input.length > 0) {
                    this.open();
                }
            }

        },

        // multi
        onSelect: function (data, options) {

            if (!this.triggerSelect(data)) { return; }

            this.addSelectedChoice(data);

            this.opts.element.trigger({ type: "selected", val: this.id(data), choice: data });

            if (this.select || !this.opts.closeOnSelect) this.postprocessResults(data, false, this.opts.closeOnSelect===true);

            if (this.opts.closeOnSelect) {
                this.close();
                this.search.width(10);
            } else {
                if (this.countSelectableResults()>0) {
                    this.search.width(10);
                    this.resizeSearch();
                    if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
                        // if we reached max selection size repaint the results so choices
                        // are replaced with the max selection reached message
                        this.updateResults(true);
                    }
                    this.positionDropdown();
                } else {
                    // if nothing left to select close
                    this.close();
                    this.search.width(10);
                }
            }

            // since its not possible to select an element that has already been
            // added we do not need to check if this is a new element before firing change
            this.triggerChange({ added: data });

            if (!options || !options.noFocus)
                this.focusSearch();
        },

        // multi
        cancel: function () {
            this.close();
            this.focusSearch();
        },

        addSelectedChoice: function (data) {
            var enableChoice = !data.locked,
                enabledItem = $(
                    "<li class='select2-search-choice'>" +
                        "    <div></div>" +
                        "    <a href='#' onclick='return false;' class='select2-search-choice-close' tabindex='-1'></a>" +
                        "</li>"),
                disabledItem = $(
                    "<li class='select2-search-choice select2-locked'>" +
                        "<div></div>" +
                        "</li>");
            var choice = enableChoice ? enabledItem : disabledItem,
                id = this.id(data),
                val = this.getVal(),
                formatted,
                cssClass;

            formatted=this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
            if (formatted != undefined) {
                choice.find("div").replaceWith("<div>"+formatted+"</div>");
            }
            cssClass=this.opts.formatSelectionCssClass(data, choice.find("div"));
            if (cssClass != undefined) {
                choice.addClass(cssClass);
            }

            if(enableChoice){
                choice.find(".select2-search-choice-close")
                    .on("mousedown", killEvent)
                    .on("click dblclick", this.bind(function (e) {
                        if (!this.isInterfaceEnabled()) return;

                        $(e.target).closest(".select2-search-choice").fadeOut('fast', this.bind(function(){
                            this.unselect($(e.target));
                            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                            this.close();
                            this.focusSearch();
                        })).dequeue();
                        killEvent(e);
                    })).on("focus", this.bind(function () {
                        if (!this.isInterfaceEnabled()) return;
                        this.container.addClass("select2-container-active");
                        this.dropdown.addClass("select2-drop-active");
                    }));
            }

            choice.data("select2-data", data);
            choice.insertBefore(this.searchContainer);

            val.push(id);
            this.setVal(val);
        },

        // multi
        unselect: function (selected) {
            var val = this.getVal(),
                data,
                index;
            selected = selected.closest(".select2-search-choice");

            if (selected.length === 0) {
                throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
            }

            data = selected.data("select2-data");

            if (!data) {
                // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
                // and invoked on an element already removed
                return;
            }

            while((index = indexOf(this.id(data), val)) >= 0) {
                val.splice(index, 1);
                this.setVal(val);
                if (this.select) this.postprocessResults();
            }

            var evt = $.Event("select2-removing");
            evt.val = this.id(data);
            evt.choice = data;
            this.opts.element.trigger(evt);

            if (evt.isDefaultPrevented()) {
                return;
            }

            selected.remove();

            this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
            this.triggerChange({ removed: data });
        },

        // multi
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var val = this.getVal(),
                choices = this.results.find(".select2-result"),
                compound = this.results.find(".select2-result-with-children"),
                self = this;

            choices.each2(function (i, choice) {
                var id = self.id(choice.data("select2-data"));
                if (indexOf(id, val) >= 0) {
                    choice.addClass("select2-selected");
                    // mark all children of the selected parent as selected
                    choice.find(".select2-result-selectable").addClass("select2-selected");
                }
            });

            compound.each2(function(i, choice) {
                // hide an optgroup if it doesnt have any selectable children
                if (!choice.is('.select2-result-selectable')
                    && choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
                    choice.addClass("select2-selected");
                }
            });

            if (this.highlight() == -1 && noHighlightUpdate !== false){
                self.highlight(0);
            }

            //If all results are chosen render formatNoMAtches
            if(!this.opts.createSearchChoice && !choices.filter('.select2-result:not(.select2-selected)').length > 0){
                if(!data || data && !data.more && this.results.find(".select2-no-results").length === 0) {
                    if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
                        this.results.append("<li class='select2-no-results'>" + self.opts.formatNoMatches(self.search.val()) + "</li>");
                    }
                }
            }

        },

        // multi
        getMaxSearchWidth: function() {
            return this.selection.width() - getSideBorderPadding(this.search);
        },

        // multi
        resizeSearch: function () {
            var minimumWidth, left, maxWidth, containerLeft, searchWidth,
                sideBorderPadding = getSideBorderPadding(this.search);

            minimumWidth = measureTextWidth(this.search) + 10;

            left = this.search.offset().left;

            maxWidth = this.selection.width();
            containerLeft = this.selection.offset().left;

            searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;

            if (searchWidth < minimumWidth) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth < 40) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth <= 0) {
                searchWidth = minimumWidth;
            }

            this.search.width(Math.floor(searchWidth));
        },

        // multi
        getVal: function () {
            var val;
            if (this.select) {
                val = this.select.val();
                return val === null ? [] : val;
            } else {
                val = this.opts.element.val();
                return splitVal(val, this.opts.separator);
            }
        },

        // multi
        setVal: function (val) {
            var unique;
            if (this.select) {
                this.select.val(val);
            } else {
                unique = [];
                // filter out duplicates
                $(val).each(function () {
                    if (indexOf(this, unique) < 0) unique.push(this);
                });
                this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
            }
        },

        // multi
        buildChangeDetails: function (old, current) {
            var current = current.slice(0),
                old = old.slice(0);

            // remove intersection from each array
            for (var i = 0; i < current.length; i++) {
                for (var j = 0; j < old.length; j++) {
                    if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
                        current.splice(i, 1);
                        if(i>0){
                            i--;
                        }
                        old.splice(j, 1);
                        j--;
                    }
                }
            }

            return {added: current, removed: old};
        },


        // multi
        val: function (val, triggerChange) {
            var oldData, self=this;

            if (arguments.length === 0) {
                return this.getVal();
            }

            oldData=this.data();
            if (!oldData.length) oldData=[];

            // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
            if (!val && val !== 0) {
                this.opts.element.val("");
                this.updateSelection([]);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange({added: this.data(), removed: oldData});
                }
                return;
            }

            // val is a list of ids
            this.setVal(val);

            if (this.select) {
                this.opts.initSelection(this.select, this.bind(this.updateSelection));
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(oldData, this.data()));
                }
            } else {
                if (this.opts.initSelection === undefined) {
                    throw new Error("val() cannot be called if initSelection() is not defined");
                }

                this.opts.initSelection(this.opts.element, function(data){
                    var ids=$.map(data, self.id);
                    self.setVal(ids);
                    self.updateSelection(data);
                    self.clearSearch();
                    if (triggerChange) {
                        self.triggerChange(self.buildChangeDetails(oldData, self.data()));
                    }
                });
            }
            this.clearSearch();
        },

        // multi
        onSortStart: function() {
            if (this.select) {
                throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
            }

            // collapse search field into 0 width so its container can be collapsed as well
            this.search.width(0);
            // hide the container
            this.searchContainer.hide();
        },

        // multi
        onSortEnd:function() {

            var val=[], self=this;

            // show search and move it to the end of the list
            this.searchContainer.show();
            // make sure the search container is the last item in the list
            this.searchContainer.appendTo(this.searchContainer.parent());
            // since we collapsed the width in dragStarted, we resize it here
            this.resizeSearch();

            // update selection
            this.selection.find(".select2-search-choice").each(function() {
                val.push(self.opts.id($(this).data("select2-data")));
            });
            this.setVal(val);
            this.triggerChange();
        },

        // multi
        data: function(values, triggerChange) {
            var self=this, ids, old;
            if (arguments.length === 0) {
                return this.selection
                    .find(".select2-search-choice")
                    .map(function() { return $(this).data("select2-data"); })
                    .get();
            } else {
                old = this.data();
                if (!values) { values = []; }
                ids = $.map(values, function(e) { return self.opts.id(e); });
                this.setVal(ids);
                this.updateSelection(values);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(old, this.data()));
                }
            }
        }
    });

    $.fn.select2 = function () {

        var args = Array.prototype.slice.call(arguments, 0),
            opts,
            select2,
            method, value, multiple,
            allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search"],
            valueMethods = ["opened", "isFocused", "container", "dropdown"],
            propertyMethods = ["val", "data"],
            methodsMap = { search: "externalSearch" };

        this.each(function () {
            if (args.length === 0 || typeof(args[0]) === "object") {
                opts = args.length === 0 ? {} : $.extend({}, args[0]);
                opts.element = $(this);

                if (opts.element.get(0).tagName.toLowerCase() === "select") {
                    multiple = opts.element.prop("multiple");
                } else {
                    multiple = opts.multiple || false;
                    if ("tags" in opts) {opts.multiple = multiple = true;}
                }

                select2 = multiple ? new MultiSelect2() : new SingleSelect2();
                select2.init(opts);
            } else if (typeof(args[0]) === "string") {

                if (indexOf(args[0], allowedMethods) < 0) {
                    throw "Unknown method: " + args[0];
                }

                value = undefined;
                select2 = $(this).data("select2");
                if (select2 === undefined) return;

                method=args[0];

                if (method === "container") {
                    value = select2.container;
                } else if (method === "dropdown") {
                    value = select2.dropdown;
                } else {
                    if (methodsMap[method]) method = methodsMap[method];

                    value = select2[method].apply(select2, args.slice(1));
                }
                if (indexOf(args[0], valueMethods) >= 0
                    || (indexOf(args[0], propertyMethods) && args.length == 1)) {
                    return false; // abort the iteration, ready to return first matched value
                }
            } else {
                throw "Invalid arguments to select2 plugin: " + args;
            }
        });
        return (value === undefined) ? this : value;
    };

    // plugin defaults, accessible to users
    $.fn.select2.defaults = {
        width: "copy",
        loadMorePadding: 0,
        closeOnSelect: true,
        openOnEnter: true,
        containerCss: {},
        dropdownCss: {},
        containerCssClass: "",
        dropdownCssClass: "",
        formatResult: function(result, container, query, escapeMarkup) {
            var markup=[];
            markMatch(result.text, query.term, markup, escapeMarkup);
            return markup.join("");
        },
        formatSelection: function (data, container, escapeMarkup) {
            return data ? escapeMarkup(data.text) : undefined;
        },
        sortResults: function (results, container, query) {
            return results;
        },
        formatResultCssClass: function(data) {return undefined;},
        formatSelectionCssClass: function(data, container) {return undefined;},
        formatNoMatches: function () { return "No matches found"; },
        formatInputTooShort: function (input, min) { var n = min - input.length; return "Please enter " + n + " more character" + (n == 1? "" : "s"); },
        formatInputTooLong: function (input, max) { var n = input.length - max; return "Please delete " + n + " character" + (n == 1? "" : "s"); },
        formatSelectionTooBig: function (limit) { return "You can only select " + limit + " item" + (limit == 1 ? "" : "s"); },
        formatLoadMore: function (pageNumber) { return "Loading more results..."; },
        formatSearching: function () { return "Searching..."; },
        minimumResultsForSearch: 0,
        minimumInputLength: 0,
        maximumInputLength: null,
        maximumSelectionSize: 0,
        id: function (e) { return e.id; },
        matcher: function(term, text) {
            return stripDiacritics(''+text).toUpperCase().indexOf(stripDiacritics(''+term).toUpperCase()) >= 0;
        },
        separator: ",",
        tokenSeparators: [],
        tokenizer: defaultTokenizer,
        escapeMarkup: defaultEscapeMarkup,
        blurOnChange: false,
        selectOnBlur: false,
        adaptContainerCssClass: function(c) { return c; },
        adaptDropdownCssClass: function(c) { return null; },
        nextSearchTerm: function(selectedObject, currentSearchTerm) { return undefined; }
    };

    $.fn.select2.ajaxDefaults = {
        transport: $.ajax,
        params: {
            type: "GET",
            cache: false,
            dataType: "json"
        }
    };

    // exports
    window.Select2 = {
        query: {
            ajax: ajax,
            local: local,
            tags: tags
        }, util: {
            debounce: debounce,
            markMatch: markMatch,
            escapeMarkup: defaultEscapeMarkup,
            stripDiacritics: stripDiacritics
        }, "class": {
            "abstract": AbstractSelect2,
            "single": SingleSelect2,
            "multi": MultiSelect2
        }
    };

}(jQuery));
;
;
/* module-key = 'com.atlassian.auiplugin:aui-select2', location = 'js/aui-select2.js' */
/**
 * Wraps a vanilla Select2 with ADG _style_, as an auiSelect2 method on jQuery objects.
 *
 * @since 5.2
 */
(function ($) {

    /**
     * We make a copy of the original select2 so that later we might re-specify $.fn.auiSelect2 as $.fn.select2. That
     * way, calling code will be able to call $thing.select2() as if they were calling the original library,
     * and ADG styling will just magically happen.
     */
    var originalSelect2 = $.fn.select2;

    // AUI-specific classes
    var auiContainer = 'aui-select2-container';
    var auiDropdown = 'aui-select2-drop aui-dropdown2 aui-style-default';
    var auiHasAvatar = 'aui-has-avatar';

    $.fn.auiSelect2 = function (first) {
        var updatedArgs;

        if ($.isPlainObject(first)) {
            var auiOpts = $.extend({}, first);
            var auiAvatarClass = auiOpts.hasAvatar ? ' ' + auiHasAvatar : '';
            //add our classes in addition to those the caller specified
            auiOpts.containerCssClass  = auiContainer + auiAvatarClass + (auiOpts.containerCssClass ? ' ' + auiOpts.containerCssClass : '');
            auiOpts.dropdownCssClass  = auiDropdown + auiAvatarClass + (auiOpts.dropdownCssClass  ? ' ' + auiOpts.dropdownCssClass : '');
            updatedArgs = Array.prototype.slice.call(arguments, 1);
            updatedArgs.unshift(auiOpts);
        }
        else if (!arguments.length) {
            updatedArgs = [{
                containerCssClass: auiContainer,
                dropdownCssClass: auiDropdown
            }];
        }
        else {
            updatedArgs = arguments;
        }

        return originalSelect2.apply(this, updatedArgs);
    };

})(AJS.$);
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:invites-resources', location = 'feature/invites/invite-hipchat-service.js' */
define('hipchat/invite/service', [
    'hipchat/admin/configure-integration-data',
    'jquery',
    'underscore'
], function (
    integrationData,
    $,
    _
) {

    var MAX_INVITATIONS_PER_REQUEST = 24;
    var MAX_USER_PRE_POPULATION_COUNT = 12;

    var users = [];
    var events = $({});
    var uiConfig = {};

    var routes = {
        inviteUsersURL: AJS.contextPath() + '/rest/hipchat/integration/latest/users/invite'
    };

    function getMaxInvitationsPerRequest() {
        return MAX_INVITATIONS_PER_REQUEST;
    }

    function getUsers() {
        return users;
    }

    function findUser(username) {
        return _.find(users, function(userInList) {
            if (userInList.username == username) {
                return userInList;
            }
        });
    }

    function addUser(user) {
        user.username = $("<div/>").text(user.username).html();
        var foundUser = findUser(user.username);
        if (!_.contains(users, foundUser)) {
            users.push(user);
            events.trigger('user-added', user);
            checkInvitationLimit();
        }
    }

    function removeUser(username) {
        var user = findUser(username);

        if(user.isSuggested) {
            AJS.trigger('analyticsEvent', {name: 'notifications.hipchat.user.invite.remove.suggested', data: {}});
        }

        if (_.contains(users, user)) {
            users = _.filter(users, function(userInList) {
                return userInList.username != username;
            });
            events.trigger('user-removed', user.username);
            checkInvitationLimit();
        }
    }

    function checkInvitationLimit() {
        var userCount = users.length;
        if (userCount >= MAX_INVITATIONS_PER_REQUEST) {
            $("#invite-users-picker-container").hide();
            $("#inviation-limit-message").show();
        } else {
            $("#inviation-limit-message").hide();
            $("#invite-users-picker-container").show();
        }
    }

    function clear() {
        users = [];
        events.off();
    }

    function sendInvitations() {
        AJS.$("#invite-users-picker-container input[type='text']").prop("disabled", true);
        AJS.$('#hipchat-invite-form').on('select2-opening', function(e) { e.preventDefault(); });
        uiConfig.invitationProcessingStartedRenderer.call();
        var usernames = _.map(getUsers(), function(user) {
            return user.username;
        });
        var userNamesJson = JSON.stringify({"user-names": usernames});
        $.ajax({
            url: routes.inviteUsersURL,
            type: "POST",
            contentType: 'application/json',
            data: userNamesJson
        })
        .done(function(invitationResults) {
            for (var i = 0; i < invitationResults.resultSet.length; i++) {
                var result = invitationResults.resultSet[i];
                uiConfig.resultRenderer(result.userName, result.errorMessage);
            }
            uiConfig.renderDoneStep.call();
        })
        .fail(function(xhr) {
            var title = "Error";
            var messageText = AJS.escapeHtml(xhr.responseText);
            var messageReason = AJS.escapeHtml(AJS.format("Reason: {1} ({0})", xhr.status, xhr.statusText));
            uiConfig.errorRenderer.call(this, title, messageText, messageReason);
        })
        .always(function() {
            uiConfig.invitationProcessingCompletedRenderer.call();
        });
    }

    function handleDone() {
        var adminConfigurationPageURI = $("#admin-configuration-page-uri").val();
        window.location = adminConfigurationPageURI;
    }

    function initialise(
            invitationProcessingStartedRenderer,
            invitationProcessingCompletedRenderer,
            resultRenderer,
            renderDoneStep,
            errorRenderer) {
        uiConfig.invitationProcessingStartedRenderer = invitationProcessingStartedRenderer;
        uiConfig.invitationProcessingCompletedRenderer = invitationProcessingCompletedRenderer;
        uiConfig.resultRenderer = resultRenderer;
        uiConfig.renderDoneStep = renderDoneStep;
        uiConfig.errorRenderer = errorRenderer;
        routes.findInviteUsersURL = $("#hipchat-find-invite-users-uri").val() + "?max-results=" + MAX_USER_PRE_POPULATION_COUNT;
        $.ajax(routes.findInviteUsersURL, {
            type: "GET"
        })
            .done(function(userReferenceSet) {
                var listHasBeenManuallyPopulated = users.length > 0;
                if (listHasBeenManuallyPopulated) {
                    // QA decision: don't auto populate the list since it would be disruptive to the user.
                } else {
                    if (userReferenceSet.users) {
                        var userCount = userReferenceSet.users.length;
                        var usersToDisplay = Math.min(userCount, MAX_USER_PRE_POPULATION_COUNT);
                        for (var i = 0; i < usersToDisplay; i++) {
                            var userReference = userReferenceSet.users[i];
                            var uiUser = {
                                username: userReference.name,
                                avatarUrl: userReference.extraSmallPictureURI,
                                fullname: userReference.displayName,
                                email: userReference.email,
                                isSuggested: true
                            };
                            addUser(uiUser);
                        }
                    }
                }
            });
    }

    return {
        getMaxInvitationsPerRequest: getMaxInvitationsPerRequest,
        getUsers: getUsers,
        addUser: addUser,
        removeUser: removeUser,
        clear: clear,
        initialise: initialise,
        sendInvitations: sendInvitations,
        handleDone: handleDone,
        events: events
    }
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:invites-resources', location = 'feature/invites/invite-hipchat.js' */
require([
        'hipchat/invite/service'
    ],
    /**
     * Internal ui integration services for invite configuration.
     *
     * @tainted HipChat.Templates.Configuration (soy template)
     */
    function (inviteService) {
        'use strict';

        AJS.toInit(function ($) {
            var form = $('#hipchat-invite-form');
            var inviteeTemplate = HipChat.Templates.Configuration.invitee;
            var inviteeList = form.find('.hipchat-invitee-list');
            var sendInvitesButton = form.find('.send-invites-button');
            var cancelButton = form.find('.cancel');
            var doneButton = form.find('.done-button');
            var authorizeNotNowLink = $('#authorize-not-now-link');
            var inviteNotNowLink = $('#invite-not-now-link');

            window.onbeforeunload = null; // Prevent the "Are you sure you want to navigate away" dialog from appearing

            inviteNotNowLink.click(function() {
                AJS.trigger('analyticsEvent', {name: 'notifications.hipchat.user.invite.wizard.dropout.invite.notnow', data: {}});
            });

            authorizeNotNowLink.click(function() {
                AJS.trigger('analyticsEvent', {name: 'notifications.hipchat.user.invite.wizard.dropout.authorize.notnow', data: {}});
            });

            var maxInvitationsPerRequest = inviteService.getMaxInvitationsPerRequest();
            $("#invite-explanation-message").html(AJS.format("Inviting your teammates to HipChat creates a HipChat account and sends them an activation email. Note that only {0} invitations can be sent at a time, but you can always return here to invite more users.", maxInvitationsPerRequest));

            if (form.length == 0) {
                return;
            }

            form.on('user-picker-user-selected', function (e, user) {
                inviteService.addUser(user);
            });
            inviteeList.on('click', '.remove-invite-button', function (e) {
                e.preventDefault();
                var invitee = $(this).closest('.hipchat-invitee');
                inviteService.removeUser(invitee.attr('data-username'));
            });

            // Tooltips
            $('.hipchat-invitee-name-container').tipsy({live: true, gravity: 's'});
            $('.hipchat-invitee .email-container, .hipchat-invitee .aui-lozenge').tipsy({live: true, gravity: 'n'});

            function getEmailDomain(email) {
                var atIdx;
                if(email && (atIdx = email.indexOf('@')) && atIdx >= 0) {
                    return email.substr(atIdx);
                }
                // Fallback
                return email;
            }

            function renderUser(e, user) {
                if(!user.emailDomain) {
                    user.emailDomain = getEmailDomain(user.email);
                }
                inviteeList.append(inviteeTemplate(user));
                sendInvitesButton.prop('disabled', false);
                sendInvitesButton.removeAttr('aria-disabled');
            }

            function removeUser(e, username) {
                var invitee = inviteeList.find("[data-username='" + username + "']");
                invitee.remove();
                if (!inviteService.getUsers().length) {
                    sendInvitesButton.prop('disabled', true);
                    sendInvitesButton.attr('aria-disabled', true);
                }
            }

            function invitationProcessingStartedRenderer() {
                sendInvitesButton.attr('aria-disabled', true);

                var inviteProcessingIdleIndicators = $("[data-invite-processing='idle']");
                inviteProcessingIdleIndicators.addClass("hidden");

                var inviteProcessingRunningIndicators = $("[data-invite-processing='running']");
                inviteProcessingRunningIndicators.removeClass("hidden");

                var emailHolders = $(".email");
                emailHolders.hide();

                var removeButton = $(".remove-invite-button");
                removeButton.hide();
            }

            function invitationProcessingCompletedRenderer() {
                var inviteProcessingRunningIndicators = $("[data-invite-processing='running']");
                inviteProcessingRunningIndicators.addClass("hidden");

                var inviteProcessingIdleIndicators = $("[data-invite-processing='idle']");
                inviteProcessingIdleIndicators.removeClass("hidden");
            }

            function resultRenderer(userName, errorMessage) {
                var userDiv = $("[data-username='" + userName + "']");
                var successStatusHolder = userDiv.find(".aui-lozenge-success");
                var errorStatusHolder = userDiv.find(".aui-lozenge-current");
                if (errorMessage) {
                    errorStatusHolder.text("Unable to invite");
                    errorStatusHolder.show();
                    successStatusHolder.hide();

                    errorStatusHolder.tooltip({
                        title: function () {
                            return errorMessage;
                        }
                    });
                } else {
                    successStatusHolder.text("sent");
                    successStatusHolder.show();
                    errorStatusHolder.hide();
                }
            }

            function renderDoneStep() {
                sendInvitesButton.hide();
                cancelButton.hide();
                doneButton.show();
                doneButton.removeAttr('aria-disabled');
                doneButton.removeAttr('disabled');
            }

            function errorRenderer(title, messageText, messageReason) {
                var messageContainer = $('#invite-banner-messages');
                messageContainer.empty();
                AJS.messages.error("#invite-banner-messages", {
                    title: title,
                    body: "<p>" + messageText + "<br/>" + messageReason + "</p>"
                });
            }

            inviteService.events.on('user-added.invite-hipchat', renderUser);
            inviteService.events.on('user-removed', removeUser);

            inviteService.initialise(
                invitationProcessingStartedRenderer,
                invitationProcessingCompletedRenderer,
                resultRenderer,
                renderDoneStep,
                errorRenderer);

            form.on('submit', function (e) {
                e.preventDefault();
                inviteService.sendInvitations();
            });

            doneButton.click(function (e) {
                e.preventDefault();
                inviteService.handleDone();
            });
        });
    });
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:invites-resources', location = 'feature/invites/user-picker.js' */
define('hipchat/invite/user-picker', [
    'jquery'
], function ($) {

    return function (field, form, options) {
        field = $(field);
        form = $(form);

        field.auiSelect2({
            ajax: {
                url: options.url,
                dataType: 'json',
                delay: 200,
                data: options.params,
                results: options.results,
                cache: true
            },
            multiple: true,
            minimumInputLength: 2
        });

        field.select2('focus');

        function onSelect(e) {
            var user = options.choice(e.choice);

            if(user.always) {
                // looks like a promise, so must be a duck,  wait for it to be done...
                user.always(function(user) {
                    if (!user.isRejected || !user.isRejected())
                        selectUser(user);
                });
            } else {
                // assume it's must be a user
                selectUser(user);
            }
        }

        function selectUser(user) {
            form.trigger('user-picker-user-selected', user);
            field.select2('val', '');
        }

        field.on('selected', onSelect);
    };

});
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:amd', location = 'js/lib/amd/jira/jira-components-query-amd.js' */
define("hipchat/jira/query-component", function () {
    return JIRA.Components.Query;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:amd', location = 'js/lib/amd/jira/jira-issues-amd.js' */
define("hipchat/jira/issues/searcher-collection", function () {
    return JIRA.Issues.SearcherCollection;
});

define("hipchat/jira/issues/query-state-model", function () {
    return JIRA.Issues.QueryStateModel;
});

define("hipchat/jira/issues/criteria-model", function () {
    return JIRA.Issues.CriteriaModel;
});

define("hipchat/jira/issues/criteria-view", function () {
    return JIRA.Issues.CriteriaView;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:amd', location = 'js/lib/amd/hipchat-scopes-provider-amd.js' */
define("hipchat/scopes-provider", function () {
    return HipChat.ScopesProvider;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:global', location = 'js/base.js' */
/**
 * Top level configuration/information object.
 */
define("hipchat/base", [ "underscore", "backbone", "exports" ], function (_, Backbone, exports) {
    if (typeof HipChat === "undefined" || !HipChat) {
        window.HipChat = {};
    }

    /**
     * Provide our own sub classes of the backbone objects for common methods.
     */
    function setupBackbone() {
        exports.View = Backbone.View;

        exports.Model = Backbone.Model.extend({

            saveWrapper: function(saveFunction) {
                this.trigger("waitingToSave");
                saveFunction.apply(this);
                this.trigger("saved");
            },

            addDebounceSave: function(milliseconds) {
                this.save = _.wrap(_.debounce(this.save, milliseconds), this.saveWrapper);
            },

            /**
             * Observes this model for request/sync/error events and logs the beginning and the end.
             * This is mainly used for testing to tell page objects when ajax operations have finished.
             *
             * @param {string} [traceSuffix] suffix to append to the trace key
             */
            traceAjaxRequests: function(traceSuffix) {
                var attribute = null;
                var request = attribute ? "request:" + attribute : "request";
                var sync = attribute ? "sync:" + attribute : "sync";
                var error = attribute ? "error:" + attribute : "error";
                var observed = this;

                observed.on(request, function () {
                    JIRA.trace("ajax.request.started." + traceSuffix);
                }, this);

                observed.on(sync + " " + error, function () {
                    JIRA.trace("ajax.request.completed." + traceSuffix);
                }, this);
            }

        });

        exports.Collection = Backbone.Collection;
        exports.Events = Backbone.Events;
    }

    setupBackbone();
});;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:hipchat-installed-scopes', location = 'install/hipchat-scopes-provider.js' */
(function() {

    function ScopesProvider() {

        var pluginKey = "com.atlassian.plugins.base-hipchat-integration-plugin";
        var wrmData = WRM.data instanceof Function ? WRM.data : WRM.data.claim;
        var installedScopes = wrmData(pluginKey + ":hipchat-installed-scopes.scopes");

        function hasScope(scopeName) {
            return installedScopes[scopeName] !== undefined;
        }

        return {
            hasScope: hasScope
        }
    }

    // exports
    window.HipChat = window.HipChat || {};
    window.HipChat.ScopesProvider = ScopesProvider();

})();;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:widget-roomselector', location = 'js/widget/roomselector/roommapping-service.js' */
define("hipchat/widget/roomselector/roommapping-service",
[
    "ajs",
    "jquery",
    "underscore"
],
function (
    AJS,
    $,
    _
) {

    var roomServicePromise = (function() {
        var roomMap = {}; // { "roomId": { roomId: "roomId", roomName: "roomName" }, ... }
        var rooms = []; // cache of [ { id: "roomId", text: "roomName } ] for use by select2 query. Derived from roomMap
        var listeners = {};

        function rebuildRoomData() {
            rooms = _.map(roomMap, function(item) { return {id: item.roomId, text: item.roomName, isPrivate: item.isPrivate}; });
            rooms = _.sortBy(rooms, function (item) { return item.text.toLocaleLowerCase(); });
            _.each(listeners, function(fn) {
                fn.apply(null, [ rooms ]);
            });
        }

        function createRoom(name) {
            // Note that we set cache to false to prevent IE9 caching previous results. See CONFDEV-29008.
            var dfd = $.Deferred();
            $.ajax({
                url: AJS.contextPath() + '/rest/hipchat/integration/1.0/rooms?roomName=' + name,
                type: 'POST',
                dataType: 'json',
                cache: false
            }).done(function(data) {
                var room = {
                    roomId: data.id,
                    roomName: data.name
                };
                addRoom(room);

                dfd.resolve(room);
            }).fail(function(err) {
                dfd.reject(err);
            });

            return dfd;
        }

        function addRoom(room) {
            roomMap[room.roomId] = room;
            rebuildRoomData();
        }

        function removeRoom(room) {
            delete roomMap[room.roomId];
            rebuildRoomData();
        }

        function onChange(fn) {
            listeners[fn] = fn;
        }

        function offChange(fn) {
            delete listeners[fn];
        }

        function getRoomById(roomId) {
            return roomMap[roomId];
        }

        function getRooms() {
            return rooms;
        }

        var roomService = {
            createRoom: createRoom,
            addRoom: addRoom,
            removeRoom: removeRoom,
            getRoomById: getRoomById,
            getRooms: getRooms,
            onChange: onChange,
            offChange: offChange
        };

        var roomsAvailablePromise = (function (isHipChatConfigured, projectKey) {
            var roomLoader = $.Deferred();
            if (isHipChatConfigured) {
                // Note that we set cache to false to prevent IE9 caching previous results. See CONFDEV-29008.
                $.ajax({
                    url: AJS.contextPath() + '/rest/hipchat/integration/1.0/rooms?projectKey=' + (_.isString(projectKey) ?
                            projectKey : ""),
                    dataType: 'json',
                    cache: false
                }).done(function (data) {
                    roomMap = _.object(_.map(data, function (item) {
                        return [item.id, {
                            roomId: item.id,
                            roomName: item.name,
                            isPrivate: item["private"]
                        }];
                    }));
                    rebuildRoomData(roomMap);
                    roomLoader.resolve(roomService);
                }).fail(function (err) {
                    roomLoader.reject(err);
                });
            } else {
                roomLoader.resolve(roomService);
            }
            return roomLoader.promise();
        });

        var promises = {};
        var promiseBuilder = function (isHipChatConfigured, projectKey) {
            if (promises[projectKey] === undefined) {
                promises[projectKey] = roomsAvailablePromise(isHipChatConfigured, projectKey);
            }

            return promises[projectKey];
        };
        promiseBuilder.reset = function() {
            promises = {};
        };

        return promiseBuilder;
    })();

    return {
        roomServicePromise: roomServicePromise
    };
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:widget-roomselector', location = 'js/widget/roomselector/roomselector-view.js' */
define("hipchat/widget/roomselector/roomselector-view",
        [
            "jquery",
            "backbone",
            "hipchat/widget/roomselector/roommapping-service",
            "hipchat/scopes-provider"
        ], function (
                $,
                Backbone,
                RoomMappingService,
                HipChatScopesProvider
        ) {

            var PRIVATE_ROOM_CLASS = "private-room";
            var PUBLIC_ROOM_CLASS = "public-room";

            function escapeResult(markup) {
                var replace_map = {
                    '\\': '&#92;',
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;',
                    "/": '&#47;'
                };

                return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
                    return replace_map[match];
                });
            }

            function getProjectKey() {
                return $("[name='projectKey']").attr("content");
            }

            function makeSuggestionsHandler(loggedIn, hasManageRoomScope) {
                //this is only called when the integration is installed
                var roomServicePromise = RoomMappingService.roomServicePromise(true, getProjectKey());

                return Class.extend({
                    _formatResponse: function(rooms, query, showCreateRoom) {
                        var groupDescriptors = [];
                        if (rooms.length > 0) {

                            var suggestionsGroupDescriptor = new AJS.GroupDescriptor({
                                weight: 0,
                                label: loggedIn? "All rooms" :
                                        "Public rooms"
                            });

                            _.each(rooms, function(item) {
                                suggestionsGroupDescriptor.addItem(new AJS.ItemDescriptor({
                                    value: item.id,
                                    label: item.text,
                                    html: escapeResult(item.text),
                                    title: item.text,
                                    meta: {
                                        roomId: item.id,
                                        roomName: item.roomName || item.text,
                                        existing: true
                                    },
                                    styleClass: item.isPrivate ? PRIVATE_ROOM_CLASS : PUBLIC_ROOM_CLASS
                                }));
                            });

                            groupDescriptors.push(suggestionsGroupDescriptor);
                        }


                        if (!loggedIn) {
                            var roomActionsGroupDescriptor = new AJS.GroupDescriptor({
                                weight: 1,
                                footerHtml: JIRA.Templates.HipChat.RoomSelector.loginDropdownFooter({
                                    hasManageRoomScope: hasManageRoomScope
                                })
                            });
                            roomActionsGroupDescriptor.addItem(new AJS.ItemDescriptor({
                                label: "filler",
                                html: "filler",
                                highlighted: true
                            }));

                            groupDescriptors.push(roomActionsGroupDescriptor);
                        } else if (showCreateRoom) {
                            var createRoomGroupDescriptor = new AJS.GroupDescriptor({
                                weight: 1,
                                label: "Create room"
                            });

                            createRoomGroupDescriptor.addItem(new AJS.ItemDescriptor({
                                value: query,
                                label: query,
                                html: escapeResult(query) + "<span class='aui-lozenge aui-lozenge-subtle aui-lozenge-complete'>new</span>",
                                title: query,
                                meta: {
                                    roomId: query,
                                    roomName: query,
                                    existing: false
                                },
                                highlighted: true,
                                styleClass: PUBLIC_ROOM_CLASS
                            }));

                            groupDescriptors.push(createRoomGroupDescriptor);
                        }

                        return groupDescriptors;
                    },

                    execute: function(query) {
                        var deferred = jQuery.Deferred();
                        var self = this;
                        roomServicePromise.done(function(roomService) {
                            var rooms = roomService.getRooms();
                            var searchStr = query.toLocaleLowerCase();
                            var exactMatch = false;
                            var filteredRooms = _.filter(rooms, function(item) {
                                var lowerCasedItem = item.text.toLocaleLowerCase();
                                if (lowerCasedItem === searchStr) {
                                    exactMatch = true;
                                }

                                return lowerCasedItem.indexOf(searchStr) >= 0;
                            });

                            var showCreateRoom = hasManageRoomScope && (!exactMatch && searchStr.length > 0);
                            var suggestions = self._formatResponse(filteredRooms, query, showCreateRoom);

                            JIRA.trace("ajax.request.completed.RoomSelector");
                            deferred.resolve(suggestions, query);
                        }).fail(function(err) {
                            if (loggedIn && (err.status == 403 || err.status == 401)) {
                                var dialog = new AJS.Dialog({
                                    width: 600,
                                    height: 200,
                                    id: "oauth-failure",
                                    closeOnOutsideClick: true
                                });
                                dialog.addHeader("Authentication Failure");
                                dialog.addPanel("panel 0", JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage({}));
                                dialog.show();
                                deferred.reject(err);
                            } else {
                                var errorGroupDescriptor = new AJS.GroupDescriptor({
                                    weight: 1,
                                    footerHtml: JIRA.Templates.HipChat.RoomSelector.errorDropdownFooter({})
                                });
                                errorGroupDescriptor.addItem(new AJS.ItemDescriptor({
                                    label: "filler",
                                    html: "filler",
                                    highlighted: true
                                }));

                                deferred.resolve([errorGroupDescriptor], query);
                            }
                        });

                        return deferred;
                    }
                });
            }

            function initRoomSelector($el, loggedIn, maxWidth) {

                var hasManageRoomScope = HipChatScopesProvider.hasScope("manage_rooms");
                return new AJS.SingleSelect({
                    element: $el,
                    width: maxWidth,
                    suggestionsHandler: makeSuggestionsHandler(loggedIn, hasManageRoomScope),
                    submitInputVal: true,
                    matchingStrategy: "(.*)()({0})(.*)" // expected groups: prefix, spaceOrParenthesis (ignored), match, suffix
                });
            }

            var RoomSelectorView = Backbone.View.extend({

                events: {
                },

                initialize: function(options) {

                    if (!this.$el.length) {
                        return;
                    }

                    this.roomSelector = initRoomSelector(this.$el, options.loggedIn, options.maxWidth);
                    var self = this;
                    this.roomSelector.model.$element.on("selected", function(e, itemDescriptor) {
                        if (itemDescriptor.properties.value !== "") {
                            self.roomSelector.$field.addClass(itemDescriptor.properties.styleClass);
                            self.trigger("change");
                        } else {
                            self.roomSelector.$field.removeClass(PUBLIC_ROOM_CLASS).removeClass(PRIVATE_ROOM_CLASS);
                            self.trigger("clear");
                        }
                    });

                    this.roomSelector.model.$element.on("unselect", function(e) {
                        self.trigger("clear");
                    });
                },

                getSelectedRoom: function() {
                    var selectedDescriptor = this.roomSelector.getSelectedDescriptor();
                    var meta = JSON.parse(selectedDescriptor.properties.meta);
                    return {
                        id: meta.roomId,
                        roomName: meta.roomName,
                        existing: meta.existing
                    };
                },

                clearSelectedRoom: function() {
                    this.roomSelector.clear();
                    this.roomSelector._deactivate(); // We need that to get the placeholder back
                }
            });


            return RoomSelectorView;
        });;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:widget-roomselector', location = 'soy/widget/roomselector/roomselector-client.soy' */
// This file was automatically generated from roomselector-client.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.RoomSelector.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.RoomSelector == 'undefined') { JIRA.Templates.HipChat.RoomSelector = {}; }


JIRA.Templates.HipChat.RoomSelector.loginDropdownFooter = function(opt_data, opt_ignored) {
  return '<div class="hipchat-login-dropdown-footer"><h6>' + soy.$$escapeHtml("Rooms") + '</h6><p>' + ((opt_data.hasManageRoomScope) ? soy.$$filterNoAutoescape("\x3ca href\x3d\x22#\x22 class\x3d\x22hipchat-user-link\x22\x3eConfirm access to your HipChat account\x3c/a\x3e, to view private rooms and create new rooms.") : soy.$$filterNoAutoescape("\x3ca href\x3d\x22#\x22 class\x3d\x22hipchat-user-link\x22\x3eConfirm access to your HipChat account\x3ca/\x3e, to view private rooms.")) + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.RoomSelector.loginDropdownFooter.soyTemplateName = 'JIRA.Templates.HipChat.RoomSelector.loginDropdownFooter';
}


JIRA.Templates.HipChat.RoomSelector.errorDropdownFooter = function(opt_data, opt_ignored) {
  return '<div class="hipchat-login-dropdown-footer error"><h6>' + soy.$$escapeHtml("Error") + '</h6><p>' + soy.$$escapeHtml("Failed to load the list of rooms from HipChat.") + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.RoomSelector.errorDropdownFooter.soyTemplateName = 'JIRA.Templates.HipChat.RoomSelector.errorDropdownFooter';
}
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:widget-roomselector', location = 'soy/issuepanel/issuepanel-client.soy' */
// This file was automatically generated from issuepanel-client.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.Project.IssuePanel.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.Project == 'undefined') { JIRA.Templates.HipChat.Project = {}; }
if (typeof JIRA.Templates.HipChat.Project.IssuePanel == 'undefined') { JIRA.Templates.HipChat.Project.IssuePanel = {}; }


JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription = function(opt_data, opt_ignored) {
  var output = '';
  var noOfMentionRooms__soy3 = opt_data.mentionedRooms.length;
  output += ((noOfMentionRooms__soy3 > 0) ? '<a id="hipchat-issue-mentions-list" href="' + soy.$$escapeHtml("/jira" + '/secure/HipChatMentionedRooms.jspa?issueKey=' + opt_data.issueKey) + '"' + ((opt_data.userLoggedIntoHipChat) ? 'class="trigger-dialog-large">' : 'class="trigger-dialog">') : '<span>') + soy.$$escapeHtml(AJS.format("Issue mentioned in {0} {0,choice,0#rooms|1#room|1\x3crooms}",noOfMentionRooms__soy3)) + ((noOfMentionRooms__soy3 > 0) ? '</a>' : '</span>');
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription';
}


JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails = function(opt_data, opt_ignored) {
  return '<div class="hipchat-dedicated-room"><div class="hipchat-dedicated-room-icon ' + ((opt_data.justLinked) ? 'success' : '') + '"><span class="aui-icon aui-icon-small aui-iconfont-approve"> </span>' + ((opt_data.dedicatedRoom.privateRoom) ? '<span class="aui-icon private-room"> </span>' : '<span class="aui-icon public-room"> </span>') + '</div><a href="#" class="hipchat-dedicated-room-name public-room hipchat-room-link-url" data-api-url="' + soy.$$escapeHtml(opt_data.dedicatedRoom.apiUrl) + '" data-room-id="' + soy.$$escapeHtml(opt_data.dedicatedRoom.roomId) + '" data-issue-id="' + soy.$$escapeHtml(opt_data.dedicatedRoom.issueId) + '" data-room="' + soy.$$escapeHtml(opt_data.dedicatedRoom.roomId) + '">' + soy.$$escapeHtml(opt_data.dedicatedRoom.name) + '</a>' + ((! opt_data.hideUnlink) ? '<a class="trash-dedicated-room" href="#" title="' + soy.$$escapeHtml("Unlink room") + '"><span class="aui-icon aui-icon-small aui-iconfont-remove-label">Delete</span></a>' : '') + '<div class="hc-button-spinner"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails';
}


JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm = function(opt_data, opt_ignored) {
  return '<div class="hipchat-no-dedicated-room">' + ((opt_data.canAssignRoom) ? '<div id="hipchat-dedicated-room-buttons" class="buttons-container">' + ((opt_data.canCreateRoom || opt_data.isAdmin) ? aui.buttons.button({text: "Create a room", extraClasses: 'hipchat-create-dedicated-room hipchat-issue-panel-button'}) : '') + '<a id="hipchat-select-dedicated-room" href="' + soy.$$escapeHtml("/jira" + '/secure/HipChatSelectRoom.jspa?issueKey=' + opt_data.issueKey) + '" class="hipchat-issue-panel-button hipchat-select-dedicated-room trigger-dialog-select-room">' + soy.$$escapeHtml("Choose a room") + '</a><div class="hc-button-spinner"></div></div>' : '<div>' + soy.$$escapeHtml("None") + '</div>') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm';
}


JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content">' + ((opt_data.action == 'create') ? '<p>' + soy.$$filterNoAutoescape("\x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#create-dedicated-room\x22\x3eConfirm access to your HipChat account\x3c/a\x3e to create a dedicated room for this issue.") + '</p>' : (opt_data.action == 'delete') ? '<p>' + soy.$$filterNoAutoescape("\x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#delete-dedicated-room\x22\x3eConfirm access to your HipChat account\x3c/a\x3e to delete the dedicated room for this issue.") + '</p>' : '') + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage';
}


JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content"><p>' + soy.$$filterNoAutoescape("Please \x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#create-dedicated-room\x22\x3ereconfirm access to your HipChat account\x3c/a\x3e.") + '</p></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom';
}


JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content"><p>' + soy.$$filterNoAutoescape("Please \x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22\x22\x3ereconfirm access to your HipChat account\x3c/a\x3e.") + '</p></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage';
}


JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content"><p>' + soy.$$filterNoAutoescape(AJS.format("HipChat integration \x3ca href\x3d\x22{0}\x22\x3ehas to be reinstalled\x3c/a\x3e in order to create dedicated rooms.","/jira" + '/plugins/servlet/hipchat/configure')) + '</p></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage';
}


JIRA.Templates.HipChat.Project.IssuePanel.invitee = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.invitee({username: opt_data.user.userKey, avatarUrl: opt_data.user.avatarUrl, fullname: opt_data.user.displayName, email: opt_data.user.emailAddress, emailDomain: opt_data.user.emailDomain});
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.invitee.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.invitee';
}
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'soy/invites/hipchat-invite-jira-support.soy' */
// This file was automatically generated from hipchat-invite-jira-support.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace HipChat.Templates.Invite.Support.
 */

if (typeof HipChat == 'undefined') { var HipChat = {}; }
if (typeof HipChat.Templates == 'undefined') { HipChat.Templates = {}; }
if (typeof HipChat.Templates.Invite == 'undefined') { HipChat.Templates.Invite = {}; }
if (typeof HipChat.Templates.Invite.Support == 'undefined') { HipChat.Templates.Invite.Support = {}; }


HipChat.Templates.Invite.Support.userLinkUrl = function(opt_data, opt_ignored) {
  return soy.$$escapeHtml("/jira") + '/secure/ViewProfile.jspa?name=' + soy.$$escapeHtml(opt_data.username);
};
if (goog.DEBUG) {
  HipChat.Templates.Invite.Support.userLinkUrl.soyTemplateName = 'HipChat.Templates.Invite.Support.userLinkUrl';
}
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'soy/issuepanel/issuepanel.soy' */
// This file was automatically generated from issuepanel.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.Project.IssuePanel.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.Project == 'undefined') { JIRA.Templates.HipChat.Project = {}; }
if (typeof JIRA.Templates.HipChat.Project.IssuePanel == 'undefined') { JIRA.Templates.HipChat.Project.IssuePanel = {}; }


JIRA.Templates.HipChat.Project.IssuePanel.hipChatPanel = function(opt_data, opt_ignored) {
  return '<div class="hipchat-issue-panel" data-issue-key="' + soy.$$escapeHtml(opt_data.issueKey) + '">' + ((! opt_data.hipChatConfigured) ? JIRA.Templates.HipChat.Project.IssuePanel.hipChatNotConfigured(opt_data) : (opt_data.jirauser && ! opt_data.hipChatUserName) ? soy.$$filterNoAutoescape("\x3ca href\x3d\x22#\x22 class\x3d\x22hipchat-user-link\x22\x3eConfirm access to your HipChat account\x3c/a\x3e for more information.") + '<p>' : (opt_data.privateRoom && opt_data.hipChatUserName && ! opt_data.personalToken) ? soy.$$filterNoAutoescape("\x3ca href\x3d\x22#\x22 class\x3d\x22hipchat-user-link\x22\x3eConfirm access to your HipChat account\x3c/a\x3e for more information.") + '<p>' : '<div id="hipchat-issue-panel-rooms-container" data-logged-in="' + soy.$$escapeHtml(opt_data.personalToken) + '" data-can-create-room="' + soy.$$escapeHtml(opt_data.canCreateRoom) + '" data-can-assign-room="' + soy.$$escapeHtml(opt_data.canAssignRoom) + '" data-hipchat-configured="' + soy.$$escapeHtml(opt_data.hipChatConfigured) + '"' + ((opt_data.hipChatUserName) ? 'data-hipchat-username="' + soy.$$escapeHtml(opt_data.hipChatUserName) + '"' : '') + ((opt_data.dedicatedRoom) ? 'data-dedicated-room-id="' + soy.$$escapeHtml(opt_data.dedicatedRoom.roomId) + '"' : '') + '><ul class="item-details">' + ((opt_data.privateRoom && opt_data.hipChatUserName && opt_data.personalToken && ! opt_data.userCanAccessPrivateRoom) ? soy.$$escapeHtml("The dedicated room for this issue is private.") + '<p>' : JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomSection({issueKey: opt_data.issueKey, dedicatedRoom: opt_data.dedicatedRoom, loggedIn: opt_data.personalToken, canCreateRoom: opt_data.canCreateRoom, canAssignRoom: opt_data.canAssignRoom, isAdmin: opt_data.isAdmin})) + ((opt_data.connectionStatus == 'CONNECTED') ? JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomSection(null) : '') + '</ul></div>') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.hipChatPanel.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.hipChatPanel';
}


JIRA.Templates.HipChat.Project.IssuePanel.hipChatNotConfigured = function(opt_data, opt_ignored) {
  var output = '<div id="hipchat-issue-panel-rooms-container" data-project-key="' + soy.$$escapeHtml(opt_data.projectKey) + '">';
  var configureUrl__soy62 = '' + ((opt_data.isAdmin) ? soy.$$escapeHtml("/jira" + '/plugins/servlet/hipchat/configure?source=issue-panel') : (opt_data.isProjectAdmin) ? soy.$$escapeHtml("/jira" + '/secure/ConfigureHipChat.jspa?source=issue-panel&projectKey=' + opt_data.projectKey) : '');
  output += '<p>' + soy.$$filterNoAutoescape(AJS.format("Do you want to discuss this issue? Connect to HipChat.",configureUrl__soy62)) + '</p><p>' + aui.buttons.button({id: 'hipchat-issue-panel-configure-button', text: "Connect", extraAttributes: 'data-configure-url="' + configureUrl__soy62 + '"'}) + '<a id="hipchat-issue-panel-hide" href="#">' + soy.$$escapeHtml("Dismiss") + '</a></p></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.hipChatNotConfigured.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.hipChatNotConfigured';
}


JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomSection = function(opt_data, opt_ignored) {
  return '<li id="hipchat-dedicated-room-section"><div class="hipchat-settings-button"><span class="aui-icon aui-icon-small aui-iconfont-configure hidden" id="hipchat-panel-settings"></span></div><dl><dt class="dedicated-room-label">' + soy.$$escapeHtml("Dedicated room") + ':</dt><dd class="hipchat-dedicated-room-content">' + ((opt_data.dedicatedRoom) ? JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails(opt_data) : JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm(opt_data)) + '</dd></dl><div id="hipchat-dedicated-room-footer"><div id="hipchat-dedicated-room-errors" class="errors"/><div id="dedicated-room-message-bar" /></div></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomSection.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomSection';
}


JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialog = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<h1>' + soy.$$escapeHtml("Choose a room") + '</h1>' + ((opt_data.hipChatUserName) ? '<div class="dialog-panel-body"><form class="hipchat-room-select-form aui"><div class="dialog-panel-body-header aui-item">' + soy.$$escapeHtml("Discuss this issue and be notified of any changes in a room of your choice.") + '</div><div class="field-group"><div id="hipchat-dedicated-room-select-container" class="hipchat-room-selector-container" ' + ((opt_data.hipChatUserName) ? 'data-hipchat-username="' + soy.$$escapeHtml(opt_data.hipChatUserName) + '"' : '') + '><select id="hipchat-dedicated-room-select" class="hidden hipchat-room-selector"><option value="" disabled selected>' + soy.$$escapeHtml("Select HipChat room") + '</option></select></div></div><div class="dialog-errors error"></div></form></div><div class="buttons-container form-footer">' + JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialogButtons(null) + '</div>' : '<div class="dialog-panel-body"><p>' + soy.$$filterNoAutoescape("\x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#choose-room\x22\x3eConfirm access to your HipChat account\x3c/a\x3e to choose a dedicated room for this issue.") + '</p></div>');
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialog.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialog';
}


JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialogButtons = function(opt_data, opt_ignored) {
  return '<div class="buttons"><button class="aui-button submit" id="hipchat-select-dedicated-room-dialog-submit">' + soy.$$escapeHtml("Select") + '</button><button class="aui-button aui-button-link cancel" id="hipchat-select-dedicated-room-dialog-close">' + soy.$$escapeHtml("Cancel") + '</button></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialogButtons.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialogButtons';
}


JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomSection = function(opt_data, opt_ignored) {
  return '<li id="hipchat-mentioned-rooms-section"><dl><dt class="mentions-label">' + soy.$$escapeHtml("Other rooms:") + '</dt><dd class="hipchat-mentioned-rooms-content"><span class="aui-icon aui-icon-wait"></span></dd></dl></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomSection.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomSection';
}


JIRA.Templates.HipChat.Project.IssuePanel.loginMentionsDialog = function(opt_data, opt_ignored) {
  return '<div class="hipchat-mentions-dialog-login"><h6>' + soy.$$escapeHtml("HipChat discussions") + '</h6><p>' + soy.$$filterNoAutoescape("\x3ca href\x3d\x22#open-issue-mentions\x22 class\x3d\x22hipchat-user-link\x22\x3eConfirm access to your HipChat account\x3c/a\x3e to see issue mention details") + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.loginMentionsDialog.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.loginMentionsDialog';
}


JIRA.Templates.HipChat.Project.IssuePanel.errorPage = function(opt_data, opt_ignored) {
  var output = '<h1>' + soy.$$escapeHtml("HipChat discussions") + '</h1><div class="hipchat-mentions-dialog-content">';
  var param141 = '<ul>';
  var errorList143 = opt_data.errors;
  var errorListLen143 = errorList143.length;
  for (var errorIndex143 = 0; errorIndex143 < errorListLen143; errorIndex143++) {
    var errorData143 = errorList143[errorIndex143];
    param141 += '<li>' + soy.$$escapeHtml(errorData143) + '</li>';
  }
  param141 += '</ul>';
  output += aui.message.error({titleContent: "Failed to get issue mention details", content: param141});
  output += '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.errorPage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.errorPage';
}


JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomDialog = function(opt_data, opt_ignored) {
  var output = '<h1>' + soy.$$escapeHtml("HipChat discussions") + '</h1><div class="hipchat-mentions-dialog-content">';
  var roomsMentionsLength__soy155 = opt_data.mentionRooms.length;
  var roomsNotAvailable__soy156 = opt_data.totalRooms - roomsMentionsLength__soy155;
  output += '<h4>' + soy.$$escapeHtml(AJS.format("{0} {0,choice,0#mentions|1#mention|1\x3cmentions} in {1} {1,choice,0#rooms|1#room|1\x3crooms}",opt_data.issueMentions.length,roomsMentionsLength__soy155)) + '</h4>' + ((roomsNotAvailable__soy156 > 0) ? '<h7>' + soy.$$escapeHtml(AJS.format("There are mentions in {0} private room(s) you do not have access to.",roomsNotAvailable__soy156)) + '</h7>' : '') + '<table class="aui"><thead><tr><th id="hipchat-mentioned-author">' + soy.$$escapeHtml("Author") + '</th><th id="hipchat-mentioned-room">' + soy.$$escapeHtml("Room") + '</th><th id="hipchat-mentioned-message">' + soy.$$escapeHtml("Message") + '</th><th id="hipchat-mentioned-date">' + soy.$$escapeHtml("Date") + '</th></tr></thead><tbody>';
  var mentionList174 = opt_data.issueMentions;
  var mentionListLen174 = mentionList174.length;
  for (var mentionIndex174 = 0; mentionIndex174 < mentionListLen174; mentionIndex174++) {
    var mentionData174 = mentionList174[mentionIndex174];
    var mentionMessage__soy175 = mentionData174.message;
    var mentionRoom__soy176 = mentionData174.room;
    var mentionUser__soy177 = mentionData174.user;
    output += '<tr><td headers="hipchat-mentioned-author"><a href="#" class="hipchat-user-link-url" data-user-id="' + soy.$$escapeHtml(mentionUser__soy177.id) + '" data-api-url="' + soy.$$escapeHtml(opt_data.apiUrl) + '">' + soy.$$truncate(soy.$$escapeHtml(mentionUser__soy177.name), 50, true) + '</a></td><td headers="hipchat-mentioned-room"><a href="#" class="hipchat-dedicated-room-name public-room hipchat-room-link-url" data-api-url="' + soy.$$escapeHtml(opt_data.apiUrl) + '" data-room-id="' + soy.$$escapeHtml(mentionRoom__soy176.id) + '">' + soy.$$truncate(soy.$$escapeHtml(mentionRoom__soy176.name), 50, true) + '</a></td><td headers="hipchat-mentioned-message" title="' + soy.$$escapeHtml(mentionMessage__soy175.text) + '">' + soy.$$truncate(soy.$$escapeHtml(mentionMessage__soy175.text), 100, true) + '</td><td headers="hipchat-mentioned-date"><time class="livestamp date user-tz" data-datetime-format="fullAge" datetime="' + soy.$$escapeHtml(mentionData174.localizedMessageDate) + '">$' + soy.$$escapeHtml(mentionData174.localizedMessageDate) + '</time></td></tr>';
  }
  output += '</tbody></table></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomDialog.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomDialog';
}


JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialog = function(opt_data, opt_ignored) {
  return '<h1>' + soy.$$escapeHtml("Invite users to room") + '</h1>' + ((opt_data.hipChatUserName) ? (opt_data.dedicatedRoom) ? '<div class="dialog-panel-body"><form id="hipchat-invite-contributors-form" class="hipchat-invite-contributors-form aui" data-dedicated-room-id="' + soy.$$escapeHtml(opt_data.dedicatedRoom.roomId) + '"><div class="dialog-panel-body-header aui-item">' + JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails({loggedIn: opt_data.hipChatUserName, dedicatedRoom: opt_data.dedicatedRoom, hideUnlink: true, justLinked: false}) + '</div><div id="dedicated-room-invite-users-picker-container" class="field-group dedicated-room-invite-user-field"><label for="dedicated-room-invite-user">' + soy.$$escapeHtml("Search for collaborators") + '</label><input type="hidden" name="dedicated-room-invite-user" id="dedicated-room-invite-user" placeholder="' + soy.$$escapeHtml("Search for collaborators") + '"/><div class="user-picker-errors"></div></div>' + HipChat.Templates.Configuration.inviteeList(null) + '<div class="dialog-errors"></div></form></div><div class="buttons-container form-footer">' + JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialogButtons(null) + '</div>' : '<div class="dialog-panel-body"><p>' + soy.$$escapeHtml("Couldn\x27t find the dedicated room for this issue.") + '</p></div>' : '<div class="dialog-panel-body"><p>' + soy.$$filterNoAutoescape("You cannot invite people without granting JIRA access to your HipChat account.") + '</p></div>');
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialog.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialog';
}


JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialogButtons = function(opt_data, opt_ignored) {
  return '<div class="buttons"><button class="aui-button submit" id="hipchat-invite-contributors-dialog-submit">' + soy.$$escapeHtml("Invite") + '</button><button class="aui-button aui-button-link cancel" id="hipchat-invite-contributors-dialog-close">' + soy.$$escapeHtml("Close") + '</button></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialogButtons.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialogButtons';
}
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'soy/issuepanel/issuepanel-client.soy' */
// This file was automatically generated from issuepanel-client.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.Project.IssuePanel.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.Project == 'undefined') { JIRA.Templates.HipChat.Project = {}; }
if (typeof JIRA.Templates.HipChat.Project.IssuePanel == 'undefined') { JIRA.Templates.HipChat.Project.IssuePanel = {}; }


JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription = function(opt_data, opt_ignored) {
  var output = '';
  var noOfMentionRooms__soy3 = opt_data.mentionedRooms.length;
  output += ((noOfMentionRooms__soy3 > 0) ? '<a id="hipchat-issue-mentions-list" href="' + soy.$$escapeHtml("/jira" + '/secure/HipChatMentionedRooms.jspa?issueKey=' + opt_data.issueKey) + '"' + ((opt_data.userLoggedIntoHipChat) ? 'class="trigger-dialog-large">' : 'class="trigger-dialog">') : '<span>') + soy.$$escapeHtml(AJS.format("Issue mentioned in {0} {0,choice,0#rooms|1#room|1\x3crooms}",noOfMentionRooms__soy3)) + ((noOfMentionRooms__soy3 > 0) ? '</a>' : '</span>');
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription';
}


JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails = function(opt_data, opt_ignored) {
  return '<div class="hipchat-dedicated-room"><div class="hipchat-dedicated-room-icon ' + ((opt_data.justLinked) ? 'success' : '') + '"><span class="aui-icon aui-icon-small aui-iconfont-approve"> </span>' + ((opt_data.dedicatedRoom.privateRoom) ? '<span class="aui-icon private-room"> </span>' : '<span class="aui-icon public-room"> </span>') + '</div><a href="#" class="hipchat-dedicated-room-name public-room hipchat-room-link-url" data-api-url="' + soy.$$escapeHtml(opt_data.dedicatedRoom.apiUrl) + '" data-room-id="' + soy.$$escapeHtml(opt_data.dedicatedRoom.roomId) + '" data-issue-id="' + soy.$$escapeHtml(opt_data.dedicatedRoom.issueId) + '" data-room="' + soy.$$escapeHtml(opt_data.dedicatedRoom.roomId) + '">' + soy.$$escapeHtml(opt_data.dedicatedRoom.name) + '</a>' + ((! opt_data.hideUnlink) ? '<a class="trash-dedicated-room" href="#" title="' + soy.$$escapeHtml("Unlink room") + '"><span class="aui-icon aui-icon-small aui-iconfont-remove-label">Delete</span></a>' : '') + '<div class="hc-button-spinner"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails';
}


JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm = function(opt_data, opt_ignored) {
  return '<div class="hipchat-no-dedicated-room">' + ((opt_data.canAssignRoom) ? '<div id="hipchat-dedicated-room-buttons" class="buttons-container">' + ((opt_data.canCreateRoom || opt_data.isAdmin) ? aui.buttons.button({text: "Create a room", extraClasses: 'hipchat-create-dedicated-room hipchat-issue-panel-button'}) : '') + '<a id="hipchat-select-dedicated-room" href="' + soy.$$escapeHtml("/jira" + '/secure/HipChatSelectRoom.jspa?issueKey=' + opt_data.issueKey) + '" class="hipchat-issue-panel-button hipchat-select-dedicated-room trigger-dialog-select-room">' + soy.$$escapeHtml("Choose a room") + '</a><div class="hc-button-spinner"></div></div>' : '<div>' + soy.$$escapeHtml("None") + '</div>') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm';
}


JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content">' + ((opt_data.action == 'create') ? '<p>' + soy.$$filterNoAutoescape("\x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#create-dedicated-room\x22\x3eConfirm access to your HipChat account\x3c/a\x3e to create a dedicated room for this issue.") + '</p>' : (opt_data.action == 'delete') ? '<p>' + soy.$$filterNoAutoescape("\x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#delete-dedicated-room\x22\x3eConfirm access to your HipChat account\x3c/a\x3e to delete the dedicated room for this issue.") + '</p>' : '') + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage';
}


JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content"><p>' + soy.$$filterNoAutoescape("Please \x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#create-dedicated-room\x22\x3ereconfirm access to your HipChat account\x3c/a\x3e.") + '</p></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom';
}


JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content"><p>' + soy.$$filterNoAutoescape("Please \x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22\x22\x3ereconfirm access to your HipChat account\x3c/a\x3e.") + '</p></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage';
}


JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content"><p>' + soy.$$filterNoAutoescape(AJS.format("HipChat integration \x3ca href\x3d\x22{0}\x22\x3ehas to be reinstalled\x3c/a\x3e in order to create dedicated rooms.","/jira" + '/plugins/servlet/hipchat/configure')) + '</p></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage';
}


JIRA.Templates.HipChat.Project.IssuePanel.invitee = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.invitee({username: opt_data.user.userKey, avatarUrl: opt_data.user.avatarUrl, fullname: opt_data.user.displayName, email: opt_data.user.emailAddress, emailDomain: opt_data.user.emailDomain});
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.invitee.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.invitee';
}
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/invitecontributors.js' */
define("hipchat/feature/issuepanel/invitecontributors",
[
    "jquery",
    "backbone"
], function (
    $,
    Backbone
) {

    var InviteContributors = Backbone.Model.extend({

        defaults : {
            hipChatUsersMap: {},
            appUsersMap: {}
        },

        initialize: function() {
            this.attributes.hipChatUsersMap = {};
            this.attributes.appUsersMap = {};
        },

        url: function () {
            return AJS.contextPath() + '/rest/hipchat/integrations/1.0/invite/issue/' + this.attributes.issueKey;
        },

        destroy: function () {
            // By default, Backbone doesn't send anything on destroy
            //this.id = this.get("configurationGroupId") + "-" + this.get("name");
            var options = {
                data: JSON.stringify(this.toJSON()),
                contentType: 'application/json'
            };

            return Backbone.Model.prototype.destroy.call(this, options);
        }
    });

    return InviteContributors;

});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/invitecontributors-view.js' */
define("hipchat/feature/issuepanel/invitecontributors-view",
[
    "jquery",
    "backbone",
    "hipchat/base",
    "hipchat/feature/issuepanel/invitecontributors",
    "hipchat/invite/user-picker"
], function (
        $,
        Backbone,
        HipChat,
        InviteContributors,
        UserPicker
) {
    var InviteContributorsView = HipChat.View.extend({

        events: {
        },

        initialize: function (options) {
            this.loggedIn = options.loggedIn;
            this.canCreateRoom = options.canCreateRoom;
            this.canAssignRoom = options.canAssignRoom;
            this.isAdmin = options.isAdmin;
            this.hipChatUserName = options.hipChatUserName;
            this.issueKey = options.issueKey;
        },

        close: function () {
            this.unbind();
        },

        openInviteDialog: function (roomId) {
            var self = this;
            var issueKey = self.issueKey;
            if (!self.dialog) {
                self.dialog = new JIRA.FormDialog({
                    id: "hipchat-invite-contributors-dialog",
                    ajaxOptions: {
                        url: AJS.contextPath() + '/secure/HipChatInviteContributors.jspa?issueKey=' + issueKey,
                        data: {
                            decorator: "dialog",
                            inline: "false"
                        }
                    },
                    width: 400
                });
                self.initInviteContributorsDialog(self.dialog);
            }

            self.dialog.show();
        },

        initInviteContributorsDialog: function (dialog) {
            var self = this;
            self.dialogContentReadyCallback = function(e, data) {
                if (data.options.id === "hipchat-invite-contributors-dialog") {
                    self.initializeDialogUi();
                    self.initializeUserPicker();
                    self.initializeContributorsList();
                    // To make sure this block runs only once.
                    $(document).unbind("dialogContentReady", self.dialogContentReadyCallback);
                }
            };
            $(document).bind("dialogContentReady", {}, self.dialogContentReadyCallback);
        },

        getEmailDomain: function (email) {
                var atIdx;
                if(email && (atIdx = email.indexOf('@')) && atIdx >= 0) {
                    return email.substr(atIdx);
                }
                // Fallback
                return email;
        },

        setInviteButtonStatus: function() {
            var self = this;
            var hipChatUsersMap = self.model.get("hipChatUsersMap");
            var anyoneToInvite = false;
            var userKeys = Object.keys(hipChatUsersMap);
            userKeys.forEach(function (userKey) {
                if (!hipChatUsersMap[userKey].invitedAlready)
                    anyoneToInvite = true;
            });
            self.$inviteButton.prop('disabled', !anyoneToInvite);
        },

        addHipChatUser: function (hipChatUser) {
            var self = this;
            var hipChatUsersMap = self.model.get("hipChatUsersMap");
            if (hipChatUser.userKey in hipChatUsersMap) {
                console.log("User " + hipChatUser.userKey + " is already in the list, ignoring.");
                return;
            }
            if (!hipChatUser.emailDomain) {
                hipChatUser.emailDomain = self.getEmailDomain(hipChatUser.emailAddress);
            }
            hipChatUsersMap[ hipChatUser.userKey ] = hipChatUser;
            self.$inviteeList.append(self.inviteeTemplate({user: hipChatUser}));
            self.setInviteButtonStatus();
        },

        removeHipChatUser: function (userKey) {
            var self = this;
            var invitee = self.$inviteeList.find("[data-username='" + userKey + "']");
            invitee.remove();
            var hipChatUsersMap = self.model.get("hipChatUsersMap");
            if (!(userKey in hipChatUsersMap)) {
                console.log("User " + userKey + " is not in the list but it is asked to be removed, WTF?");
                return;
            }
            hipChatUsersMap = _.omit(hipChatUsersMap, userKey);
            self.model.set("hipChatUsersMap", hipChatUsersMap);
            self.setInviteButtonStatus();
        },

        submitInviteContributorsDialog: function () {
            var self = this;

            self.$inviteButton.attr("disabled", "disabled");
            self.$userFieldContainer.prop('disabled', "disabled");
            self.dialog.showFooterLoadingIndicator();
            var $errorContainer = $("#hipchat-invite-contributors-dialog").find(".dialog-errors");
            var dfd = $.Deferred();

            $errorContainer.empty();
            var hipChatUsersMap = self.model.get("hipChatUsersMap");
            var userKeys = Object.keys(hipChatUsersMap);
            if (!userKeys.length) {
                console.log("No user to be invited but this method is called, WTF?");
                return;
            }
            var mentionNames = [];
            userKeys.forEach(function (userKey) {
                var mentionName = hipChatUsersMap[userKey].mentionName;
                if (!hipChatUsersMap[userKey].invitedAlready && mentionNames.indexOf(mentionName) < 0)
                    mentionNames.push(mentionName);
            });
            self.model.save({mentionNames: mentionNames})
                    .done(function (response) {
                        dfd.resolve();
                        self.dialog.hideFooterLoadingIndicator();
                    }).fail(function (err) {
                        console.log('An error occurred while making a server-side call to invite contributors.');
                        dfd.reject(err);
                    });

            var updateStatus = function(success) {
                // Hide the remove buttons
                var inviteeIcons = self.$form.find(".icon-holder");
                inviteeIcons.each(function(index) {
                    $(this).hide();
                });
                // Show success icons
                var $inviteeStatuses = self.$form.find(".status-icon-holder");
                $inviteeStatuses.show();
                $inviteeStatuses.each(function(index) {
                    var $element = $(this);
                    if (!$element.data('already-invited')) {
                        if (success) {
                            $element.data('already-invited', true);
                        }
                        var $successIcon = $(this).find(".success");
                        var $failureIcon = $(this).find(".failure");
                        setTimeout(function() {
                            $($successIcon).css('display', success ? 'inline-block' : 'none');
                            $($failureIcon).css('display', success ? 'none' : 'inline-block');
                        }, 100 * index);
                    }
                });
            };

            dfd.done(function (room) {
                updateStatus(true);
                // Mark users
                var hipChatUsersMap = self.model.get("hipChatUsersMap");
                var userKeys = Object.keys(hipChatUsersMap);
                userKeys.forEach(function (userKey) {
                    hipChatUsersMap[userKey].invitedAlready = true;
                });
                self.model.set("hipChatUsersMap", hipChatUsersMap);
                JIRA.trace("hipchat.invite.contributors.successful");
                // $('#hipchat-invite-contributors-dialog-close').click();
            }).fail(function (err) {
                updateStatus(false);
                $errorContainer.empty();
                $errorContainer.append(AJS.format("Failed to invite users: {0}", err.statusText));
                self.$inviteButton.removeAttr("disabled");
                self.$userFieldContainer.removeAttr("disabled");
            }).always(function () {
                self.dialog.hideFooterLoadingIndicator();
            });
        },

        initializeDialogUi: function () {
            var self = this;
            self.$form = $("#hipchat-invite-contributors-dialog").find("form");
            self.$userFieldContainer = self.$form.find('#dedicated-room-invite-users-picker-container');
            self.$userField = self.$form.find('#dedicated-room-invite-user');
            self.$closeButton = $('#hipchat-invite-contributors-dialog-close');
            self.$inviteButton = $('#hipchat-invite-contributors-dialog-submit');
            self.$inviteeList = self.$form.find('.hipchat-invitee-list');
            self.inviteeTemplate = JIRA.Templates.HipChat.Project.IssuePanel.invitee;

            self.$inviteeList.on('click', '.remove-invite-button', function (e) {
                e.preventDefault();
                var invitee = $(this).closest('.hipchat-invitee');
                self.removeHipChatUser(invitee.attr('data-username'));
            });

            self.$form.on('user-picker-user-selected', function (e, user) {
                self.addHipChatUser(user);
            });

            self.$inviteButton.on("click", function (e) {
                self.submitInviteContributorsDialog();
            });
        },

        initializeContributorsList: function() {
            var self = this;
            var issueKey = AJS.Meta.get("issue-key");
            self.model = new InviteContributors({issueKey: issueKey});
            self.setInviteButtonStatus();
            var $errorContainer = $("#hipchat-invite-contributors-dialog").find(".dialog-errors");
            $errorContainer.empty();
            var $spinner = self.$form.find('.hc-button-spinner');
            $spinner.css({display: "inline-block"});
            $spinner.spin();
            self.model.fetch({
                success: function (result) {
                    $spinner.spinStop();
                    $spinner.css({display: "none"});
                    self.$inviteeList.empty();
                    result.attributes.hipChatUsers.forEach(function (hipChatUser) {
                        self.addHipChatUser(hipChatUser);
                    });
                },
                error: function (result) {
                    $spinner.spinStop();
                    $spinner.css({display: "none"});
                    $errorContainer.empty();
                    $errorContainer.append("Failed to fetch list of issue contributors.");
                }
            });
        },

        initializeUserPicker: function () {
            var self = this;

            function makeParams(val) {
                return {
                    maxResults: 10,
                    query: val,
                    showAvatar: true
                };
            }

            function processResults(data, page) {
                var results = _.reduce(data.users, function (m, item) {
                    m.push({
                        id: item.name,
                        text: item.displayName,
                        restObj: item
                    });
                    return m;
                }, []);
                return {
                    results: results
                };
            }

            function processChoice(props) {
                var deferred = $.Deferred();
                var $errorContainer = $("#dedicated-room-invite-users-picker-container").find(".user-picker-errors");

                $errorContainer.empty();
                var $spinner = self.$form.find('.hc-button-spinner');
                $spinner.css({display: "inline-block"});
                $spinner.spin();
                getExtraData(props.restObj.key).done(function (contributor) {
                    deferred.resolve(contributor);
                }).always(function () {
                    $spinner.spinStop();
                    $spinner.css({display: "none"});
                }).fail(function (err) {
                    $errorContainer.empty();
                    $errorContainer.append("Sorry, this user doesn\'t have a HipChat account.");
                    self.$userField.select2('val', '');
                    deferred.reject(err);
                });

                return deferred.promise();
            }

            function getExtraData(userKey) {
                var url = AJS.contextPath() + '/rest/hipchat/integrations/1.0/invite/user/' + userKey;
                var deferred = $.Deferred();
                $.ajax(url, {
                    type: "GET",
                    dataType: 'json'
                }).done(function (contributor) {
                    if (contributor.hipChatUser)
                        deferred.resolve(contributor);
                    else
                        deferred.reject();
                }).fail(function (err) {
                    deferred.reject(err);
                });
                return deferred.promise();
            }

            UserPicker(self.$userField, self.$form, {
                url: AJS.contextPath() + "/rest/api/2/user/picker",
                params: makeParams,
                results: processResults,
                choice: processChoice
            });
        }
    });

    return InviteContributorsView;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/dedicatedroom.js' */
define("hipchat/feature/issuepanel/dedicatedroom",
[
    "jquery",
    "backbone"
], function (
    $,
    Backbone
) {

    var DedicatedRoom = Backbone.Model.extend({

        url: function () {
            return AJS.contextPath() + '/rest/hipchat/integrations/1.0/dedicatedroom/';
        },

        destroy: function () {
            // By default, Backbone doesn't send anything on destroy
            //this.id = this.get("configurationGroupId") + "-" + this.get("name");
            var options = {
                data: JSON.stringify(this.toJSON()),
                contentType: 'application/json'
            };

            this.id = -1;
            return Backbone.Model.prototype.destroy.call(this, options);
        }
    });

    return DedicatedRoom;

});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/dedicatedroom-view.js' */
define("hipchat/feature/issuepanel/dedicatedroom-view",
[
    "jquery",
    "backbone",
    "hipchat/base",
    "hipchat/feature/issuepanel/dedicatedroom",
    "hipchat/widget/roomselector/roommapping-service",
    "hipchat/widget/roomselector/roomselector-view",
    "hipchat/feature/issuepanel/invitecontributors",
    "hipchat/feature/issuepanel/invitecontributors-view"
], function (
        $,
        Backbone,
        HipChat,
        DedicatedRoom,
        RoomMappingService,
        RoomSelectorView,
        InviteContributors,
        InviteContributorsView
) {
    var DedicatedRoomView = HipChat.View.extend({

        events: {
            "click .hipchat-create-dedicated-room": "createDedicatedRoom",
            "click a.trigger-dialog-select-room": "openSelectRoomDialog",
            "click .trash-dedicated-room": "unassignDedicatedRoom"
        },

        initialize: function (options) {
            this.loggedIn = options.loggedIn;
            this.canCreateRoom = options.canCreateRoom;
            this.canAssignRoom = options.canAssignRoom;
            this.isAdmin = options.isAdmin;
            this.hipChatUserName = options.hipChatUserName;
            this.issueKey = options.issueKey;
        },

        initInviteContributorsView: function(issueKey) {
            var inviteContributorsOptions = {
                issueKey: issueKey
            };
            var inviteModel = new InviteContributors(inviteContributorsOptions);

            var options = _.extend(this.options, {
                model: inviteModel
            });
            this.inviteContributorsView = new InviteContributorsView(options);
        },

        close: function () {
            if (this.inviteContributorsView) {
                this.inviteContributorsView.close();
            }
            if (this.dialogContentReadycallback) {
                $(document).unbind("dialogContentReady", this.dialogContentReadycallback);
            }
            this.unbind();
        },

        createDedicatedRoom: function (e) {
            var $createButton = this.$(".hipchat-create-dedicated-room");

            var self = this;
            if (self.loggedIn && self.canCreateRoom) {
                $createButton.attr("disabled", "disabled");
                self.createOrAssignDedicatedRoom().done(function (dedicatedRoom) {
                    JIRA.trace("hipchat.dedicated.room.created");
                    if (!dedicatedRoom.privateRoom)
                        self.inviteContributorsView.openInviteDialog(dedicatedRoom.roomId);
                }).always(function () {
                    $createButton.removeAttr("disabled");
                });
            } else {
                if (!self.loggedIn || !self.canCreateRoom) {
                    var dialog = AJS.InlineDialog($createButton, "dedicated-room-not-logged-in-dialog", function (content, trigger, showPopup) {

                        var html;
                        if (!self.canCreateRoom && self.isAdmin) {
                            html = JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage({});
                        } else {
                            html = JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage({action: "create"});
                        }

                        content.html(html);

                        showPopup();
                    }, self.dialogConfig());

                    dialog.show(e, $createButton);
                }
            }
        },

        createOrAssignDedicatedRoom: function (roomId) {
            var self = this;
            var issueKey = self.issueKey;
            var dfd = $.Deferred();

            var $errorsContainer = self.$("#hipchat-dedicated-room-errors");
            self.clearError($errorsContainer);
            var $spinner = self.$('.hc-button-spinner');
            $spinner.css({display: "inline-block"});
            $spinner.spin();

            self.model.save({issue_key: issueKey, room_id: roomId})
                    .done(function (dedicatedRoom) {
                var html = JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails({
                    loggedIn: self.loggedIn,
                    dedicatedRoom: dedicatedRoom,
                    created: true
                });

                self.$(".hipchat-dedicated-room-content")
                        .hide()
                        .html(html)
                        .fadeIn({
                            complete: function () {
                                setTimeout(function () {
                                    self.$(".hipchat-dedicated-room-icon").removeClass("success");
                                }, 1500);
                            }
                        });

                var $panelContainer = $("#hipchat-issue-panel-rooms-container");
                $panelContainer.data("dedicated-room-id", dedicatedRoom.roomId);

                JIRA.trace("hipchat.dedicated.room.created");
                self.initInviteContributorsView(self.issueKey);
                dfd.resolve(dedicatedRoom);
            }).fail(function (err) {
                if (self.loggedIn && (err.status == 403 || err.status == 401)) {
                    var dialog = new AJS.Dialog({
                        width: 500,
                        height: 300,
                        id: "oauth-failure",
                        closeOnOutsideClick: true
                    });
                    dialog.addHeader("Authentication Failure");
                    dialog.addPanel("panel 0", JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom({}));
                    dialog.show();
                } else {
                    self.displayError($errorsContainer,
                            roomId === undefined ?
                                    "Failed to create a dedicated room" :
                                    "We can\'t assign that name. The room name may already be taken or you don\'t have access to it.", err);
                }
                dfd.reject(err);
            }).always(function () {
                $spinner.spinStop();
                $spinner.css({display: "none"});
                var $createButton = $(".hipchat-create-dedicated-room");
                $createButton.removeAttr("disabled");
            });

            return dfd;
        },

        openSelectRoomDialog: function (e) {
            e.preventDefault();
            var target = e.currentTarget;
            if (this.dialog === undefined) {
                this.dialog = new JIRA.FormDialog({
                    id: target.id + "-dialog",
                    ajaxOptions: {
                        url: target.href,
                        data: {
                            decorator: "dialog",
                            inline: "false"
                        }
                    },
                    width: 400
                });
                this.initSelectRoomDialog(this.dialog);
            }

            this.dialog.show();
        },

        initSelectRoomDialog: function (dialog) {
            var self = this;
            self.dialogContentReadycallback = function (e, data) {
                if (data.options.id === "hipchat-select-dedicated-room-dialog") {
                    var roomServicePromise = RoomMappingService.roomServicePromise(true);
                    //var loggedIn = $("#hipchat-issue-panel-rooms-container").data("hipchat-username") !== undefined;
                    if (!self.loggedIn) {
                        return;
                    }
                    var roomSelector = new RoomSelectorView({
                        el: $('#hipchat-dedicated-room-select'),
                        loggedIn: self.loggedIn,
                        maxWidth: "480px"
                    });
                    var roomSelectorWatcher = {
                        roomSelector: roomSelector,
                        clearSelectedRoom: function () {
                            this.roomSelector.clearSelectedRoom();
                            this.disableSubmitButton();
                        },
                        enableSubmitButton: function () {
                            var selectedRoom = this.roomSelector.getSelectedRoom();
                            if (selectedRoom && selectedRoom.id !== "") {
                                $("#hipchat-select-dedicated-room-dialog-submit").removeAttr('aria-disabled').removeAttr('disabled');
                            }
                        },
                        disableSubmitButton: function () {
                            $('#hipchat-select-dedicated-room-dialog-submit').attr({
                                'aria-disabled': 'true',
                                'disabled': ''
                            });
                        },
                        roomSelected: function () {
                            return $('#hipchat-select-dedicated-room-dialog-submit').attr("disabled") === undefined;
                        },
                        init: function () {
                            this.roomSelector.on("change", this.enableSubmitButton, this);
                            this.roomSelector.on("clear", this.disableSubmitButton, this);
                        }
                    };
                    roomSelectorWatcher.init();

                    var submitSelectRoomDialog = function () {
                        dialog.showFooterLoadingIndicator();

                        var dfd = $.Deferred();
                        var selectedRoom = roomSelector.getSelectedRoom();
                        if (!selectedRoom.existing) {
                            // create room first
                            var roomServicePromise = RoomMappingService.roomServicePromise(true);
                            roomServicePromise.done(function (roomService) {
                                dfd = roomService.createRoom(selectedRoom.roomName);
                                dfd.fail(function(createRoomError) {
                                   dfd.reject(createRoomError);
                                });
                            }).fail(function (err) {
                                dfd.reject(err);
                            });
                        } else {
                            dfd.resolve(selectedRoom);
                        }

                        dfd.done(function (room) {
                            $('#hipchat-select-dedicated-room-dialog-close').click();

                            // The object returned by roomSelector has id, while the one returned by createRoom has roomId.
                            var roomId = room.id || room.roomId;
                            self.createOrAssignDedicatedRoom(roomId).done(function (dedicatedRoom) {
                                JIRA.trace("hipchat.dedicated.room.selected");
                                if (!dedicatedRoom.privateRoom)
                                    self.inviteContributorsView.openInviteDialog(dedicatedRoom.roomId);
                            });
                        }).fail(function (err) {

                            var $errorContainer = $("#hipchat-select-dedicated-room-dialog").find(".dialog-errors");
                            var text = "We can\'t assign that name. The room name may already be taken or you don\'t have access to it.";
                            self.displayError($errorContainer, text, err);

                        }).always(function () {
                            dialog.hideFooterLoadingIndicator();
                        });
                    };

                    var $form = $("#hipchat-select-dedicated-room-dialog").find("form");
                    $form.on("before-submit", function (e) {
                        e.preventDefault();

                        if (roomSelectorWatcher.roomSelected()) {
                            submitSelectRoomDialog();
                        }
                    });

                    roomServicePromise.done(function (roomService) {
                        roomSelectorWatcher.disableSubmitButton();
                    }).fail(function () {
                        roomSelectorWatcher.disableSubmitButton();
                    });

                    $('#hipchat-select-dedicated-room-dialog-submit').on("click", submitSelectRoomDialog);
                }
            };
            $(document).bind("dialogContentReady", {}, self.dialogContentReadycallback);
        },

        clearError: function ($errorsContainer) {
            $errorsContainer.hide();
            $errorsContainer.empty();
        },

        displayError: function ($errorsContainer, title, err) {
            $errorsContainer.show();
            $errorsContainer.empty();

            var msg;
            if (err.status === 503) {
                msg = "Unable to connect to HipChat.";
            } else {
                msg = title;
            }

            $errorsContainer.append(msg);
        },

        unassignDedicatedRoom: function (e) {
            e.preventDefault();

            var self = this;

            if (!self.loggedIn) {

                var $button = self.$(".trash-dedicated-room");
                var dialog = AJS.InlineDialog($button, "dedicated-room-not-logged-in-dialog", function (content, trigger, showPopup) {

                    var html = JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage({ action: "delete"});
                    content.html(html);
                    showPopup();
                }, self.dialogConfig());

                dialog.show(e, $button);

            } else {

                var dfd = $.Deferred();

                var $errorsContainer = self.$("#hipchat-dedicated-room-errors");
                self.clearError($errorsContainer);
                self.showSpinner();

                self.$(".trash-dedicated-room").hide();
                self.model.destroy().always(function () {
                    self.hideSpinner();
                    var $unlinkButton = self.$(".trash-dedicated-room");
                    $unlinkButton.data("hide-for-progress", false);
                }).done(function () {
                    self.model = new DedicatedRoom({});

                    var html = JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm({
                        canAssignRoom: self.canAssignRoom,
                        canCreateRoom: self.canCreateRoom,
                        isAdmin: self.isAdmin,
                        issueKey: self.issueKey
                    });

                    self.$(".hipchat-dedicated-room-content").html(html);
                    AJS.messages.success('#dedicated-room-message-bar', {
                        title: "Success",
                        body: "The HipChat room will no longer receive notifications about this issue.",
                        fadeout: true
                    });

                    JIRA.trace("hipchat.dedicated.room.deleted");
                    dfd.resolve();
                }).fail(function (err) {
                    self.displayError($errorsContainer, "Failed to un-assign a dedicated room", err);
                    dfd.reject(err);
                });

                return dfd;
            }

        },

        dialogConfig: function() {
            return {
                noBind: true,
                hideDelay: null
            };
        },

        showSpinner: function() {
            var $spinner = this.$('.hc-button-spinner');
            if ($spinner) {
                $spinner.css({display: "inline-block"});
                $spinner.spin();
            }
        },

        hideSpinner: function() {
            var $spinner = this.$('.hc-button-spinner');
            if ($spinner) {
                $spinner.spinStop();
                $spinner.css({display: "none"});
            }
        }

        });

    return DedicatedRoomView;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/issuemention.js' */
define("hipchat/feature/issuepanel/issuemention",
[
    "jquery",
    "backbone"
], function (
    $,
    Backbone
) {

    var IssueMention = Backbone.Model.extend({

        initialize: function(options) {

        },

        url: function() {
            return AJS.contextPath() + '/rest/hipchat/integrations/1.0/issue-mentions/' + this.get("issue_key") + '/rooms';
        },

        parse: function(data) {
            this.set("issueMentionRooms", data);
        }
    });

    return IssueMention;

});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/issuemention-view.js' */
define("hipchat/feature/issuepanel/issuemention-view",
[
    "jquery",
    "backbone",
    "hipchat/base"
], function (
    $,
    Backbone,
    HipChat
) {
    var IssueMentionView = HipChat.View.extend({

        events: {
            "click a.trigger-dialog-large": "openMentionDialog"
        },

        initialize: function(options) {
            this.loggedIn = options.loggedIn;
            this.canCreateRoom = options.canCreateRoom;
            this.isAdmin = options.isAdmin;
            this.issueKey = options.issueKey;
            this.hipChatUserName = options.hipChatUserName;
            this.hipChatConfigured = options.hipChatConfigured;

            this.model.on("sync", this.updateMentionCount, this);
            this.model.on("sync", this.ready, this);
            this.model.on("error", this.displayError, this);

            if (this.hipChatConfigured) {
                this.model.fetch();
            }
        },

        close: function() {
            this.unbind();
        },

        openMentionDialog: function(e) {
            e.preventDefault();

            var target = e.currentTarget;
            if (this.dialog === undefined) {
                this.dialog = new JIRA.FormDialog({
                    id: target.id + "-dialog",
                    ajaxOptions: {
                        url: target.href,
                        data: {
                            decorator: "dialog",
                            inline: "false"
                        }
                    },
                    width: 900
                });
            }

            this.dialog.show();
        },

        updateMentionCount: function() {
            var html = JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription({
                mentionedRooms: this.model.get("issueMentionRooms"),
                issueKey: this.issueKey,
                userLoggedIntoHipChat: this.loggedIn
            });

            this.$(".hipchat-mentioned-rooms-content").html(html);

            JIRA.trace("hipchat.mentioned.rooms.fetched");
        },

        ready: function() {
            this.trigger("ready");
        },

        displayError: function(model, resp, options) {
            var errorsContainer = this.$(".hipchat-mentioned-rooms-content");
            errorsContainer.empty();
            errorsContainer.append("<span class='errors'>" + "Failed to get issue room mention information" + "</span>");
        }
    });

    return IssueMentionView;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/issuepanel-view.js' */
define("hipchat/feature/issuepanel/issuepanel-view",
[
    "jquery",
    "backbone",
    "hipchat/base",
    "hipchat/feature/issuepanel/dedicatedroom",
    "hipchat/feature/issuepanel/dedicatedroom-view",
    "hipchat/feature/issuepanel/issuemention",
    "hipchat/feature/issuepanel/issuemention-view"
], function (
    $,
    Backbone,
    HipChat,
    DedicatedRoom,
    DedicatedRoomView,
    IssueMention,
    IssueMentionView
) {
        var hipchatLinkClickedKey = "hipchat.inapp.links.first.clicked";
        var hipchatNativeLinksFeatureDiscovery = "hipchat.inapp.links";
        var cookieExpiresInDays = 1;

        var IssuePanelView = HipChat.View.extend({
        events: {
            "click #hipchat-issue-panel-configure-button": "configure",
            "click #hipchat-issue-panel-hide": "dismissPanel"
        },

        initialize: function(options) {
            this.initDedicatedView();
            this.initIssueMentionView();
            this.initPanelSettings();
        },

        initDedicatedView: function() {
            var issuePanelDetails = this.getIssuePanelDetails();
            var dedicatedRoomOptions = {};
            if (issuePanelDetails.dedicatedRoomId) {
                dedicatedRoomOptions = {
                    issue_key: issuePanelDetails.issueKey,
                    room_id: issuePanelDetails.dedicatedRoomId
                };
            }
            var model = new DedicatedRoom(dedicatedRoomOptions);

            var options = _.extend(issuePanelDetails, {
                el: this.$("#hipchat-dedicated-room-section"),
                model: model
            });
            this.dedicatedRoomView = new DedicatedRoomView(options);
        },

        initIssueMentionView: function() {
            var issuePanelDetails = this.getIssuePanelDetails();
            var options = _.extend({
                el: this.$("#hipchat-mentioned-rooms-section"),
                model: new IssueMention({ issue_key: issuePanelDetails.issueKey })
            }, issuePanelDetails);
            this.issueMentionView = new IssueMentionView(options);

            this.issueMentionView.on("ready", this.ready, this);
        },

        close: function() {
            this.dedicatedRoomView.close();
            this.issueMentionView.close();
        },

        ready: function() {
            this.trigger("ready");
        },

        getIssuePanelDetails: function() {
            var $panelContainer = this.$el;
            var loggedIn = $panelContainer.data("logged-in");
            var canCreateRoom = $panelContainer.data("can-create-room");
            var canAssignRoom = $panelContainer.data("can-assign-room");
            var isAdmin = AJS.Meta.get("is-admin");
            var hipChatUserName = $panelContainer.data("hipchat-username");
            var dedicatedRoomId = $panelContainer.data("dedicated-room-id");
            var hipChatConfigured = $panelContainer.data("hipchat-configured");
            var issueKey = AJS.Meta.get("issue-key");
            return {
                loggedIn: loggedIn,
                canCreateRoom: canCreateRoom,
                canAssignRoom: canAssignRoom,
                isAdmin: isAdmin,
                hipChatUserName: hipChatUserName,
                dedicatedRoomId: dedicatedRoomId,
                hipChatConfigured: hipChatConfigured,
                issueKey: issueKey
            };
        },

        dismissPanel: function(e) {
            e.preventDefault();

            var $panelContainer = this.$el;
            var projectKey = $panelContainer.data("project-key");
            var self = this;
            $.ajax({
                type: "POST",
                url: AJS.contextPath() + '/rest/hipchat/integrations/1.0/issuepanel/hide?projectKey=' + projectKey,
                dataType: 'json',
                cache: false
            }).done(function() {
                self.close();
                $("#hipchat-viewissue-panel").remove();
            }).fail(function() {

            });
        },

        configure: function(e) {
            var target = $(e.currentTarget);
            window.location = target.data("configure-url");
        },

        initPanelSettings: function() {

            // We only show the panel if the user is a MAC user
            if(navigator.platform.toUpperCase().indexOf('MAC') >= 0 && AJS.Meta.get("issue-key") !== undefined){

                var $panel = $("#hipchat-panel-settings");

                if($panel === undefined){
                    return; //Maybe the panel is not there.
                }

                $panel.removeClass("hidden");

                $panel.click(function (event) {
                    event.preventDefault();
                    showDialog($(event.target), false);
                });

                // If someone enabled/disabled the advanced settings
                $(document).on("click", "#hipchat-inapp-links", function (event) {
                    var enabled = $(event.target).is(":checked");
                    AJS.Cookie.save("HIPCHAT_NATIVE_LINK_ENABLED", enabled);

                    var analyticEvent  = "hipchat.issuepanel.native.link." + (enabled ? "enabled" : "disabled");
                    AJS.trigger('analyticsEvent', {name: analyticEvent});
                });

                $(document).on("click", ".hipchat-room-link-url", function (event) {
                    setUserClickedALink();
                });

                $(document).on("click", ".hipchat-user-link-url", function (event) {
                    setUserClickedALink();
                });

                validateFirstTime($panel);
            }

            var confirmDialog;

            function showDialog($target, firstTime) {
                if (!confirmDialog) {
                    // we need to remove any existing dialog, which may have been left behind from previous issues
                    // when a new issue is Ajax loaded
                    AJS.$("#inline-dialog-hipchat-link-dialog").remove();
                    
                    confirmDialog = AJS.InlineDialog($target, "hipchat-link-dialog",
                            function (content, trigger, showPopup) {
                                var params = {isAppLinkEnable: AJS.Cookie.read("HIPCHAT_NATIVE_LINK_ENABLED") === "true"};
                                content.html(JIRA.Templates.HipChat.Config.LinkSettings.enableInAppLinksForHipChat(params));
                                showPopup();
                                return false;
                            }, {
                                hideDelay: null
                            });
                }
                confirmDialog.show();

                var url = AJS.contextPath() + '/rest/api/2/mypreferences?key=';

                // Now we set the variable so the feature discovery ends...
                $.ajax({
                    url: url + hipchatNativeLinksFeatureDiscovery,
                    contentType: 'application/json',
                    cache: false,
                    type: "PUT",
                    data: "true"
                });

                if(firstTime){
                    AJS.trigger('analyticsEvent', {name: 'hipchat.issuepanel.native.link.discovery'});
                }

                saveCookie(hipchatNativeLinksFeatureDiscovery, true);
            }


            /**
             * We clicked a link so we are going to store this in a cookie and a preference, and in the next
             * refresh if the user did not get the feature discovery then we show it.
             */
            function setUserClickedALink() {

                var linkClicked = getCookieForUser(hipchatLinkClickedKey);

                if(linkClicked === "undefined" || linkClicked === "false"){
                    saveCookie(hipchatLinkClickedKey , true);
                    var url = AJS.contextPath() + '/rest/api/2/mypreferences?key=' + hipchatLinkClickedKey;
                    $.ajax({ url: url, contentType: 'application/json', cache: false, type: "PUT", data: "true"});
                }
            }

            /**
             * We save the cookie with the user id, to guarantee that
             * we can login/logout without having problems
             * @param cookie the cookie
             * @param value the value to store
             */
            function saveCookie(cookie, value){
                var username = AJS.Meta.get("remote-user")
                var cookieName = cookie + "." + username;
                AJS.Cookie.save(cookieName, value, cookieExpiresInDays);
            }

            function getCookieForUser(cookie){
                var username = AJS.Meta.get("remote-user")
                var cookieName = cookie + "." + username;
                return AJS.Cookie.read(cookieName);
            }

            /**
             * First we check the cookies, if the cookies say true/true then we already checked and we forget about this
             * If no cookies are set then we ask first if something was clicked, if it was then we check if it was shown or not
             * Depending on that we show the popup.
             * This is the way to verify that the user is using the functionality and showing the things they need.
             * @param $panel the panel
             */
            function validateFirstTime($panel) {

                var url = AJS.contextPath() + '/rest/api/2/mypreferences?key=';

                // If both cookies are true it means that the user clicked a link, and we already showed
                // the popup. This is much better than asking every time the issue loads for this 2 user preferences
                var linkClicked = getCookieForUser(hipchatLinkClickedKey);

                if (linkClicked === "true") {

                    if (getCookieForUser(hipchatNativeLinksFeatureDiscovery) === "true") {
                        return;
                    }

                    $.ajax({
                        url: url + hipchatNativeLinksFeatureDiscovery,
                        dataType: 'json',
                        cache: false
                    }).fail(function (data) {

                        if (data.status == 404) {

                            showDialog($panel, true);

                        }
                    }).success(function (onsuccess) {
                        // This happened in other browser or other session
                        saveCookie(hipchatNativeLinksFeatureDiscovery, true)
                    });

                } else if (linkClicked === undefined) { // Only if we don't know anything about the link we evaluate

                    $.ajax({
                        url: url + hipchatLinkClickedKey,
                        dataType: 'json',
                        cache: false
                    }).success(function (data) {

                        saveCookie(hipchatLinkClickedKey, true);
                        validateFirstTime($panel); //We do the logic again

                    }).fail(function (failure) {
                        saveCookie(hipchatLinkClickedKey, false);
                    });
                }
            }
        }
    });

    return IssuePanelView;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/issuepanel-init.js' */
(function ($,
        AJS,
        IssuePanelView
) {

    /**
     * We track any hash actions to be able to know if we are being redirected
     * from other place
     */
    function evaluateImmediateActions() {
        var hash = window.location.hash;

        if (hash === "#choose-room") {
            $("#hipchat-select-dedicated-room").click();
            cleanHash();
        } else if (hash === "#create-dedicated-room") {
            $(".hipchat-create-dedicated-room").click();
            cleanHash();
        } else if (hash === "#open-issue-mentions") {
            $("#hipchat-issue-mentions-list").click();
            cleanHash();
        } else if(hash === "#delete-dedicated-room") {
            $(".trash-dedicated-room").click();
        }
    }

    function cleanHash() {
        window.location.hash = "";
    }

    function createIssuePanelView() {
        return new IssuePanelView({
            el: $("#hipchat-issue-panel-rooms-container")
        });
    }

    var issuePanelView = null;
    function init() {
        getTemplate();

        JIRA.bind(JIRA.Events.ISSUE_REFRESHED, function () {
            // HC-11688: Actions on the issue (transition, edit...) will refresh the content of the sidebar.

            if (issuePanelView !== null){
                issuePanelView.close();
            }
            getTemplate();
        });
    }

    function getTemplate() {
        var issueKey = AJS.Meta.get("issue-key");
        if (issueKey) {
            var $issuePanel = AJS.$("#hipchat-issue-panel");
            var $spinner = AJS.$("#hipchat-issue-panel-spinner");
            var $errors = AJS.$("#hipchat-issue-panel-errors");
            $spinner.spin();
            return AJS.$.ajax({
                url: AJS.contextPath() + "/rest/hipchat/integrations/1.0/issuepanel/data/" + issueKey,
                cache: false,
                dataType: 'json',
                type: "GET"
            }).done(function (data) {
                var template = JIRA.Templates.HipChat.Project.IssuePanel.hipChatPanel(data);
                $issuePanel.html(template);

                issuePanelView = createIssuePanelView();
                issuePanelView.on("ready", evaluateImmediateActions);
            }).fail(function (jqXHR, textStatus) {
                $errors.append("Error getting HipChat data from JIRA");
            }).always(function() {
                $spinner.spinStop();
            });
        }
    }

    $(function () {
        init();
    });
})(
        AJS.$,
        require("ajs"),
        require("hipchat/feature/issuepanel/issuepanel-view")
);
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'soy/configure/hipchat-link-dialog.soy' */
// This file was automatically generated from hipchat-link-dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.Config.LinkSettings.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.Config == 'undefined') { JIRA.Templates.HipChat.Config = {}; }
if (typeof JIRA.Templates.HipChat.Config.LinkSettings == 'undefined') { JIRA.Templates.HipChat.Config.LinkSettings = {}; }


JIRA.Templates.HipChat.Config.LinkSettings.enableInAppLinksForHipChat = function(opt_data, opt_ignored) {
  return '<div class="hipchat-settings-panel"><h6>' + soy.$$escapeHtml("Use the HipChat App") + '</h6><p>' + soy.$$escapeHtml("Would you rather open links in the HipChat application instead of your browser?") + '</p><p></p><input type="checkbox" class="matcher-type" id="hipchat-inapp-links" autocomplete="off" ' + ((opt_data.isAppLinkEnable) ? ' checked' : '') + '/><label for="hipchat-inapp-links">' + soy.$$escapeHtml("Open in the HipChat App") + '</label><p>' + soy.$$filterNoAutoescape("Don\x27t have the app?  \x3ca href\x3d\x22http://hipchat.com/downloads\x22 target\x3d\x22_blank\x22\x3eGet it\x3c/a\x3e!") + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Config.LinkSettings.enableInAppLinksForHipChat.soyTemplateName = 'JIRA.Templates.HipChat.Config.LinkSettings.enableInAppLinksForHipChat';
}
;
;
/* module-key = 'com.atlassian.jira.jira-quick-edit-plugin:create-linked-issue-init', location = '/js/create-linked-issue/create-linked-issue-init.js' */
require([
    'jquery',
    'wrm/require',
    'quick-edit/util/loading-indicator'
], function (
    jQuery,
    wrmRequire,
    LoadingIndicator
) {
    var showLoadingIndicator = function () {
        LoadingIndicator.showLoadingIndicator();
    };
    var hideLoadingIndicator = function () {
        LoadingIndicator.hideLoadingIndicator(true);
    };

    var createIssueDialogLoading = false;
    jQuery(document).on("click", ".issueaction-create-linked-issue", function(e) {
        e.preventDefault();
        if( !createIssueDialogLoading ) {
            createIssueDialogLoading = true;
            showLoadingIndicator();

            wrmRequire(['wr!com.atlassian.jira.jira-quick-edit-plugin:create-linked-issue'])
                .done(function () {
                    var formFactory = require('quick-edit/create-linked-issue/create-linked-issue-form-factory');

                    formFactory().asDialog({
                        id: "create-linked-issue-dialog",
                        windowTitle: "Create linked issue"
                    }).show();

                    createIssueDialogLoading = false;
                })
                .fail(function () {
                    hideLoadingIndicator();
                    createIssueDialogLoading = false;
                });
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:underscore', location = 'js/lib/underscore-adapter.js' */
define("workflow-designer/underscore", [
    "underscore"
], function(
    _
) {
    return _;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:workflow-designer-loader', location = 'js/require.js' */
define("workflow-designer/application-loader", [
    "wrm/require",
    "require"
], function(
    wrmRequire,
    require
) {
    return {
        /**
         * Load the resources required for the workflow designer, then execute a callback.
         *
         * This method can be safely called multiple times, the resources will only be loaded once.
         *
         * @param {function} [done] A callback to execute after the resources have been loaded. It's given the workflow designer
         *   application constructor.
         * @returns a jQuery promise that is resolved on success, or rejected on failure.
         */
        load: function requireWorkflowDesigner(done) {
            return wrmRequire(["wrc!com.atlassian.jira.plugins.jira-workflow-designer.workflow-designer"], function () {
                done && done(require("workflow-designer/application"));
            });
        }
    };

});

AJS.namespace("JIRA.WorkflowDesigner.require", null, require("workflow-designer/application-loader").load);;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:workflow-designer-templates', location = 'js/templates-amd.js' */
define('workflow-designer/templates', [], function () {

    // make sure that the template namespace is in place
    AJS.namespace("JIRA.WorkflowDesigner.Templates");

    return JIRA.WorkflowDesigner.Templates;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:dialog', location = 'js/util/DialogSizeCalculator.js' */
define("workflow-designer/dialog-size-calculator", [
    "workflow-designer/underscore",
    "jquery"
], function(
    _,
    jQuery
) {

    /**
     * An object for calculating the size of the workflow designer dialog.
     *
     * @namespace
     */
    return {
       /**
        * The distance from the edge of the window for size calculations.
        *
        * @type {number}
        * @constant
        * @default
        */
        DISTANCE_FROM_EDGE: 100,

        /**
         * Calculate the dialog size to make it fill the available space.
         *
         * @param {object} dialog The dialog to calculate size for.
         * @param {object} options
         * @param {number} [options.windowHeight] The height of the window.
         * @param {number} [options.windowWidth] The width of the window.
         * @param {number} [options.dialogHeaderHeight] The height of the dialog header.
         * @param {number} [options.dialogFooterHeight] The height of the dialog footer.
         * @returns {{height: number, width: number}}
         */
        calculateDialogSize: function(dialog, options) {
            this.dialog = dialog;
            options = _.defaults(options || {}, {
                windowHeight: this._getWindowHeight(),
                windowWidth: this._getWindowWidth(),
                dialogHeaderHeight: this._getDialogHeaderHeight(),
                dialogFooterHeight: this._getDialogFooterHeight()
            });

            return {
                height: this._calculateDialogHeight(options.windowHeight, options.dialogHeaderHeight, options.dialogFooterHeight),
                width: this._calculateDialogWidth(options.windowWidth)
            };
        },

        /**
         * Calculate the dialog height to be 100 pixels from the edge of the window on each side.
         * @returns {number} The height
         * @private
         */
        _calculateDialogHeight: function(windowHeight, dialogHeaderHeight, dialogFooterHeight) {
            return windowHeight - dialogHeaderHeight - dialogFooterHeight - (this.DISTANCE_FROM_EDGE * 2);
        },

        /**
         * Calculate the dialog width to be 100 pixels from the edge of the window on each side.
         * @returns {number} The width
         * @private
         */
        _calculateDialogWidth: function(windowWidth) {
            return windowWidth - (this.DISTANCE_FROM_EDGE * 2);
        },

        /**
         * Get the window height.
         * @returns {number}
         * @private
         */
        _getWindowHeight: function() {
            return jQuery(window).height();
        },

        /**
         * Get the window width.
         * @returns {number}
         * @private
         */
        _getWindowWidth: function() {
            return jQuery(window).width();
        },

        /**
         * Get the dialog header height.
         * @returns {number}
         * @private
         */
        _getDialogHeaderHeight: function() {
            return this.dialog.$popupHeading.outerHeight();
        },

        /**
         * Get the dialog header width.
         * @returns {number}
         * @private
         */
        _getDialogFooterHeight: function() {
            return this.dialog.$buttonContainer.outerHeight();
        }
    };
});

AJS.namespace("JIRA.WorkflowDesigner.DialogSizeCalculator", null, require("workflow-designer/dialog-size-calculator"));;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:dialog', location = 'js/views/dialogs/Dialog.js' */
define("workflow-designer/dialog", [
    "workflow-designer/dialog-size-calculator",
    "jira/dialog/form-dialog",
    "workflow-designer/application-loader",
    "workflow-designer/templates",
    "jira/dialog/dialog",
    "workflow-designer/underscore",
    "jquery"
], function(
    DialogSizeCalculator,
    FormDialog,
    ApplicationLoader,
    Templates,
    JIRADialog,
    _,
    jQuery
) {
    return FormDialog.extend(
    /** @lends JIRA.WorkflowDesigner.Dialog# */
    {
        /**
         * Initialises the dialog.
         *
         * Passes options through to <tt>JIRA.FormDialog</tt>.
         *
         * @constructs
         * @extends JIRA.FormDialog
         * @classdesc JIRA.FormDialog which displays the workflow designer.
         * @param {object} options
         * @param {function|string} [options.currentStepId] The ID of the current step.
         * @param {function|boolean} [options.isDraft=false] Whether the workflow is a draft.
         * @param {function|object} [options.layoutData] The workflow designer's layout data.
         * @param {function|string} [options.workflowId] The ID of the workflow to load.
         */
        init: function (options) {
            _.bindAll(this, "_sizeAndPositionDialog");

            options = _.defaults({}, options, {
                content: this.createDialogContent,
                isDraft: false,
                onContentRefresh: this._showWorkflowDesigner,
                widthClass: "large"
            });

            this.options = options;
            this.sizeAndPositionDialog = _.throttle(this._sizeAndPositionDialog, 100);

            this._super(options);
            this.onContentReady(this._addLabelHint);
        },

        /**
         * Creates the content structure of this dialog.
         *
         * @param {function} callback Callback that we must pass the dialog content to.
         */
        createDialogContent: function(callback) {
            callback(Templates.Dialog.workflowDialog({
                title: _.result(this.options, "workflowId")
            }));
        },

        /**
         * @method
         */
        show: function() {
            this._super.apply(this, arguments);

            jQuery(window).on("resize", this.sizeAndPositionDialog);
        },

        /**
         * @method
         */
        hide: function() {
            this._designer && this._designer.destroy();

            this._super.apply(this, arguments);

            jQuery(window).off("resize", this.sizeAndPositionDialog);
        },

        /**
         * Set the width and height of the current dialog and position it accordingly.
         * Note, this removes the max-height attribute as it causes the dialog to 'jump' when resizing and is
         * not necessary as the height and is managed.
         *
         * @private
         */
        _sizeAndPositionDialog: function () {
            var formBody,
                size;

            if (JIRADialog.current === this) {
                size = DialogSizeCalculator.calculateDialogSize(this);
                this.options.width = size.width;

                formBody = this.$popup.find(".form-body");
                formBody.css({
                    height: size.height,
                    maxHeight: ""
                });

                this._positionInCenter();
            }
        },

        /**
         * Creates the workflow designer.
         *
         * @private
         */
        _showWorkflowDesigner: function() {
            var dialog = this;

            this._sizeAndPositionDialog();

            ApplicationLoader.load(function (Application) {
                if (dialog.isCurrent()) {
                    dialog._designer = new Application({
                        actions: false,
                        element: dialog.get$popup().find(".form-body"),
                        immutable: true,
                        draft: _.result(dialog.options, "isDraft"),
                        layoutData: _.result(dialog.options, "layoutData"),
                        workflowId: _.result(dialog.options, "workflowId"),
                        currentStepId: _.result(dialog.options, "currentStepId")
                    });
                }
            });
        },

        /**
         * Adds a transition label related hint message to the dialog's footer.
         */
        _addLabelHint: function() {
            this.getButtonsContainer().prepend(Templates.Dialog.labelMouseOverHint());
        }
    });
});

AJS.namespace("JIRA.WorkflowDesigner.Dialog", null, require("workflow-designer/dialog"));;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:dialog', location = 'soy/Dialog.soy' */
// This file was automatically generated from Dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.WorkflowDesigner.Templates.Dialog.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.WorkflowDesigner == 'undefined') { JIRA.WorkflowDesigner = {}; }
if (typeof JIRA.WorkflowDesigner.Templates == 'undefined') { JIRA.WorkflowDesigner.Templates = {}; }
if (typeof JIRA.WorkflowDesigner.Templates.Dialog == 'undefined') { JIRA.WorkflowDesigner.Templates.Dialog = {}; }


JIRA.WorkflowDesigner.Templates.Dialog.workflowDialog = function(opt_data, opt_ignored) {
  return '<div class="aui-dialog-content"><h2 class="dialog-title">' + soy.$$escapeHtml(opt_data.title) + '</h2><div class="form-body"></div></div>';
};
if (goog.DEBUG) {
  JIRA.WorkflowDesigner.Templates.Dialog.workflowDialog.soyTemplateName = 'JIRA.WorkflowDesigner.Templates.Dialog.workflowDialog';
}


JIRA.WorkflowDesigner.Templates.Dialog.labelMouseOverHint = function(opt_data, opt_ignored) {
  return '<div class="buttons-container-left"><small>' + soy.$$escapeHtml("Mouse over objects to see transition names.") + '</small></div>';
};
if (goog.DEBUG) {
  JIRA.WorkflowDesigner.Templates.Dialog.labelMouseOverHint.soyTemplateName = 'JIRA.WorkflowDesigner.Templates.Dialog.labelMouseOverHint';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:workflow-designer-browser-is-supported', location = 'js/browserIsSupported.js' */
define("workflow-designer/browser-support", [
    "jira/util/navigator"
], function(
    navigator
) {
    /**
     * @returns {boolean} Whether the current browser is capable of running
     *     the workflow designer.
     */
    return {
        browserIsSupported: function browserIsSupported() {
            return !(navigator.isIE() && parseInt(navigator.majorVersion(), 10) < 10);
        }
    };
});

AJS.namespace("JIRA.WorkflowDesigner.browserIsSupported", null, require("workflow-designer/browser-support").browserIsSupported);;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:view-issue-page-workflow-designer', location = 'js/views/ViewIssue.js' */
(function () {
    var ApplicationLoader = require("workflow-designer/application-loader");
    var Dialog = require('workflow-designer/dialog');
    var jQuery = require("jquery");
    var skate = require("jira/skate");

    var WorkflowDataReader;
    var WorkflowAJAXManager;
    var Messages;

    function requireDependencies() {
        WorkflowDataReader = require("workflow-designer/io/workflow-data-reader");
        WorkflowAJAXManager = require("workflow-designer/io/ajax/workflow-ajax-manager");
        Messages = require("workflow-designer/messages");
    }



    /**
     * Current step id
     *
     * @inner
     * @type {number}
     */
    var currentStepId;

    /**
     * Cache for layout data
     *
     * @inner
     * @type {object}
     */
    var layoutData;

    /**
     * Dialog
     *
     * @inner
     * @type {JIRA.WorkflowDesigner.Dialog}
     */
    var workflowDialog;

    /**
     * Name of the workflow
     *
     * @inner
     * @type {string}
     */
    var workflowName;

    /**
     * Extract a parameter from a workflow image URL.
     *
     * @inner
     * @param {string} imageURL The workflow image URL.
     * @param {string} key The key of the parameter to extract.
     * @return {string} The value corresponding to <tt>key</tt> in <tt>imageURL</tt>'s query string.
     */
    function getImageURLParameter(imageURL, key) {
        var value = parseUri(imageURL).queryKey[key] || "";
        return decodeURIComponent(value.replace(/\+/g, "%20"));
    }

    /**
     * Load the layout data of the current issue's workflow.
     *
     * @inner
     * @return {jQuery.Deferred} A deferred that is resolved when the layout data has loaded.
     */
    function loadLayoutData() {
        var request;

        if (layoutData) {
            return jQuery.Deferred().resolve(layoutData).promise();
        } else {
            request = WorkflowAJAXManager.load(workflowName);
            request.done(function (models, response) {
                layoutData = response;
            });

            return request;
        }
    }

    workflowDialog = new Dialog({
        content: function (callback) {
            var dialog = this;

            ApplicationLoader.load()
                .pipe(requireDependencies)
                .pipe(loadLayoutData)
                .done(function () {
                    dialog.createDialogContent(callback);
                })
                .fail(function (errorMessage) {
                    errorMessage = errorMessage || "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.";
                    Messages.showErrorMessage(errorMessage);
                    workflowDialog.hide(true);
                });
        },
        id: "view-workflow-dialog",
        workflowId: function() {
            return workflowName;
        },
        currentStepId: function() {
            return currentStepId;
        },
        layoutData: function() {
            return WorkflowDataReader.read(layoutData);
        }
    });


    var CLASS_TYPE = (skate.type) ? skate.type.CLASSNAME : skate.types.CLASS;

    /**
     * @skate jira-workflow-designer-link
     */
    skate('jira-workflow-designer-link', {
        type: CLASS_TYPE,
        created: function(element) {
            var el = (this instanceof Element) ? this : element;
            el.classList.add('new-workflow-designer');
        },
        attached: function(element) {
            var el = (this instanceof Element) ? this : element;
            var workflowImageURL = el.getAttribute("href");
            workflowName = getImageURLParameter(workflowImageURL, "workflowName");
            currentStepId = parseInt(getImageURLParameter(workflowImageURL, "stepId"), 10);
            layoutData = null;
        },
        events: {
            "click": function(element, e) {
                workflowDialog && workflowDialog.show();
                e.preventDefault();
            }
        }
    });

}());


/**
 * Code related to showing a read-only version of the new workflow designer on the view issue page.
 *
 * @function JIRA.WorkflowDesigner.ViewIssue.replaceViewWorkflowLink
 * @deprecated Since JIRA 7.0. This module is unnecessary now that the {@link skate:jira-workflow-designer-link} component exists.
 */
AJS.namespace("JIRA.WorkflowDesigner.ViewIssue.replaceViewWorkflowLink", null, jQuery.noop);

/**
 * @function JIRA.WorkflowDesigner.Templates.ViewIssue.viewWorkflowLink
 * @deprecated Since JIRA 7.0. This module is unnecessary now that the {@link skate:jira-workflow-designer-link} component exists.
 */
AJS.namespace("JIRA.WorkflowDesigner.Templates.ViewIssue.viewWorkflowLink", null, jQuery.noop);
;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/rpc.js' */
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Remote procedure call library for gadget-to-container,
 * container-to-gadget, and gadget-to-gadget (thru container) communication.
 *
 *
 */

var gadgets = gadgets || {};

/**
 * @static
 * @class Provides operations for making rpc calls.
 * @name gadgets.rpc
 */
gadgets.rpc = function() {
  // General constants.
  var CALLBACK_NAME = '__cb';
  var DEFAULT_NAME = '';

  // Consts for FrameElement.
  var FE_G2C_CHANNEL = '__g2c_rpc';
  var FE_C2G_CHANNEL = '__c2g_rpc';

  var services = {};
  var iframePool = [];
  var relayUrl = {};
  var useLegacyProtocol = {};
  var authToken = {};
  var callId = 0;
  var callbacks = {};
  var setup = {};
  var sameDomain = {};

  var params = {};

  // Load the authentication token for speaking to the container
  // from the gadget's parameters, or default to '0' if not found.
  if (gadgets.util) {
    params = gadgets.util.getUrlParameters();
  }

  authToken['..'] = params.rpctoken || params.ifpctok || 0;

  /*
   * Return a short code representing the best available cross-domain
   * message transport available to the browser.
   *
   * + For those browsers that support native messaging (various implementations
   *   of the HTML5 postMessage method), use that. Officially defined at
   *   http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html.
   *
   *   postMessage is a native implementation of XDC. A page registers that
   *   it would like to receive messages by listening the the "message" event
   *   on the window (document in DPM) object. In turn, another page can
   *   raise that event by calling window.postMessage (document.postMessage
   *   in DPM) with a string representing the message and a string
   *   indicating on which domain the receiving page must be to receive
   *   the message. The target page will then have its "message" event raised
   *   if the domain matches and can, in turn, check the origin of the message
   *   and process the data contained within.
   *
   *     wpm: postMessage on the window object.
   *        - Internet Explorer 8+
   *        - Safari (latest nightlies as of 26/6/2008)
   *        - Firefox 3+
   *        - Opera 9+
   *
   *     dpm: postMessage on the document object.
   *        - Opera 8+
   *
   * + For Gecko-based browsers, the security model allows a child to call a
   *   function on the frameElement of the iframe, even if the child is in
   *   a different domain. This method is dubbed "frameElement" (fe).
   *
   *   The ability to add and call such functions on the frameElement allows
   *   a bidirectional channel to be setup via the adding of simple function
   *   references on the frameElement object itself. In this implementation,
   *   when the container sets up the authentication information for that gadget
   *   (by calling setAuth(...)) it as well adds a special function on the
   *   gadget's iframe. This function can then be used by the gadget to send
   *   messages to the container. In turn, when the gadget tries to send a
   *   message, it checks to see if this function has its own function stored
   *   that can be used by the container to call the gadget. If not, the
   *   function is created and subsequently used by the container.
   *   Note that as a result, FE can only be used by a container to call a
   *   particular gadget *after* that gadget has called the container at
   *   least once via FE.
   *
   *     fe: Gecko-specific frameElement trick.
   *        - Firefox 1+
   *
   * + For all others, we have a fallback mechanism known as "ifpc". IFPC
   *   exploits the fact that while same-origin policy prohibits a frame from
   *   accessing members on a window not in the same domain, that frame can,
   *   however, navigate the window heirarchy (via parent). This is exploited by
   *   having a page on domain A that wants to talk to domain B create an iframe
   *   on domain B pointing to a special relay file and with a message encoded
   *   after the hash (#). This relay, in turn, finds the page on domain B, and
   *   can call a receipt function with the message given to it. The relay URL
   *   used by each caller is set via the gadgets.rpc.setRelayUrl(..) and
   *   *must* be called before the call method is used.
   *
   *     ifpc: Iframe-based method, utilizing a relay page, to send a message.
   */
  function getRelayChannel() {
    return typeof window.postMessage === 'function' ? 'wpm' :
        typeof document.postMessage === 'function' ? 'dpm' :
            navigator.product === 'Gecko' ? 'fe' :
                'ifpc';
  }

  /**
   * Conducts any initial global work necessary to setup the
   * channel type chosen.
   */
  function setupChannel() {
    // If the channel type is one of the native
    // postMessage based ones, setup the handler to receive
    // messages.
    if (relayChannel === 'dpm' || relayChannel === 'wpm') {
      window.addEventListener('message', function(packet) {
        // JRA-36335: Anyone could be publishing a 'message' so need to make sure
        // we handle errors more gracefully in case the packet doesn't contain what
        // was expected
        try {
          if (packet && packet.origin && packet.origin !== "null" && typeof packet.data === 'string' ) {
            AJS.$.get(AJS.contextPath() + '/rest/whitelist/1/check', {url: packet.origin})
                .done(function (result) {
                  if (result && result.inbound && result.inbound === true) {
                    process(gadgets.json.parse(packet.data));
                  }
                  else {
                    if(AJS.debug) {
                      AJS.log("RPC: request rejected (bad origin): " + (packet && packet.origin ? packet.origin : "undefined origin"));
                    }
                  }
                })
                .fail(function (jqXHR, textStatus, errorThrown) {
                  AJS.log('RPC: REST ' + textStatus, errorThrown);
                });
          } else {
            if(AJS.debug) {
              AJS.log("RPC: request rejected (bad origin): " + (packet && packet.origin ? packet.origin : "undefined origin"));
            }
          }
        } catch (e) {
          if (AJS.debug) {
            var origin = packet && packet.origin ? packet.origin : "undefined origin";
            AJS.log("Error processing gadget rpc message from '" + origin + "': " + e);
          }
        }
      }, false);
    }
  }

  // Pick the most efficient RPC relay mechanism
  var relayChannel = getRelayChannel();

  // Conduct any setup necessary for the chosen channel.
  setupChannel();

  // Create the Default RPC handler.
  services[DEFAULT_NAME] = function() {
    throw new Error('Unknown RPC service: ' + this.s);
  };

  // Create a Special RPC handler for callbacks.
  services[CALLBACK_NAME] = function(callbackId, result) {
    var callback = callbacks[callbackId];
    if (callback) {
      delete callbacks[callbackId];
      callback(result);
    }
  };

  /**
   * Conducts any frame-specific work necessary to setup
   * the channel type chosen. This method is called when
   * the container page first registers the gadget in the
   * RPC mechanism. Gadgets, in turn, will complete the setup
   * of the channel once they send their first messages.
   */
  function setupFrame(frameId) {
    if (setup[frameId]) {
      return;
    }

    if (relayChannel === 'fe') {
      try {
        var frame = document.getElementById(frameId);
        frame[FE_G2C_CHANNEL] = function(args) {
          process(gadgets.json.parse(args));
        };
      } catch (e) {
        // Something went wrong. System will fallback to
        // IFPC.
      }
    }

    setup[frameId] = true;
  }

  /**
   * Encodes arguments for the legacy IFPC wire format.
   *
   * @param {Object} args
   * @return {String} the encoded args
   */
  function encodeLegacyData(args) {
    var stringify = gadgets.json.stringify;
    var argsEscaped = [];
    for(var i = 0, j = args.length; i < j; ++i) {
      argsEscaped.push(encodeURIComponent(stringify(args[i])));
    }
    return argsEscaped.join('&');
  }

  /**
   * Helper function to process an RPC request
   * @param {Object} rpc RPC request object
   * @private
   */
  function process(rpc) {
    //
    // RPC object contents:
    //   s: Service Name
    //   f: From
    //   c: The callback ID or 0 if none.
    //   a: The arguments for this RPC call.
    //   t: The authentication token.
    //
    if (rpc && typeof rpc.s === 'string' && typeof rpc.f === 'string' &&
        rpc.a instanceof Array) {

      // Validate auth token.
      if (authToken[rpc.f]) {
        // We allow type coercion here because all the url params are strings.
        if (authToken[rpc.f] != rpc.t) {
          if (AJS.debug) {
            console.log('Invalid auth token received for operation: ' + rpc.s);
          }
          return;
        }
      }

      // If there is a callback for this service, attach a callback function
      // to the rpc context object for asynchronous rpc services.
      //
      // Synchronous rpc request handlers should simply ignore it and return a
      // value as usual.
      // Asynchronous rpc request handlers, on the other hand, should pass its
      // result to this callback function and not return a value on exit.
      //
      // For example, the following rpc handler passes the first parameter back
      // to its rpc client with a one-second delay.
      //
      // function asyncRpcHandler(param) {
      //   var me = this;
      //   setTimeout(function() {
      //     me.callback(param);
      //   }, 1000);
      // }
      if (rpc.c) {
        rpc.callback = function(result) {
          gadgets.rpc.call(rpc.f, CALLBACK_NAME, null, rpc.c, result);
        };
      }

      // Call the requested RPC service.
      var result = (services[rpc.s] ||
      services[DEFAULT_NAME]).apply(rpc, rpc.a);

      // If the rpc request handler returns a value, immediately pass it back
      // to the callback. Otherwise, do nothing, assuming that the rpc handler
      // will make an asynchronous call later.
      if (rpc.c && typeof result != 'undefined') {
        gadgets.rpc.call(rpc.f, CALLBACK_NAME, null, rpc.c, result);
      }
    }
  }

  /**
   * Attempts to conduct an RPC call to the specified
   * target with the specified data via the FrameElement
   * method. If this method fails, the system attempts again
   * using the known default of IFPC.
   *
   * @param {String} targetId Module Id of the RPC service provider.
   * @param {String} serviceName Service name to call.
   * @param {String} from Module Id of the calling provider.
   * @param {Object} rpcData The RPC data for this call.
   * @param {Array.<Object>} callArgs Original arguments to call()
   */
  function callFrameElement(targetId, serviceName, from, rpcData, callArgs) {
    try {
      if (from != '..') {
        // Call from gadget to the container.
        var fe = window.frameElement;

        if (typeof fe[FE_G2C_CHANNEL] === 'function') {
          // Complete the setup of the FE channel if need be.
          if (typeof fe[FE_G2C_CHANNEL][FE_C2G_CHANNEL] !== 'function') {
            fe[FE_G2C_CHANNEL][FE_C2G_CHANNEL] = function(args) {
              process(gadgets.json.parse(args));
            };
          }

          // Conduct the RPC call.
          fe[FE_G2C_CHANNEL](rpcData);
          return;
        }
      } else {
        // Call from container to gadget[targetId].
        var frame = document.getElementById(targetId);

        if (typeof frame[FE_G2C_CHANNEL] === 'function' &&
            typeof frame[FE_G2C_CHANNEL][FE_C2G_CHANNEL] === 'function') {

          // Conduct the RPC call.
          frame[FE_G2C_CHANNEL][FE_C2G_CHANNEL](rpcData);
          return;
        }
      }
    } catch (e) {
    }

    // If we have reached this point, something has failed
    // with the FrameElement method, so we default to using
    // IFPC for this call.
    callIfpc(targetId, serviceName, from, rpcData, callArgs);
  }

  /**
   * Conducts an RPC call to the specified
   * target with the specified data via the IFPC
   * method.
   *
   * @param {String} targetId Module Id of the RPC service provider.
   * @param {String} serviceName Service name to call.
   * @param {String} from Module Id of the calling provider.
   * @param {Object} rpcData The RPC data for this call.
   * @param {Array.<Object>} callArgs Original arguments to call()
   */
  function callIfpc(targetId, serviceName, from, rpcData, callArgs) {
    // Retrieve the relay file used by IFPC. Note that
    // this must be set before the call, and so we conduct
    // an extra check to ensure it is not blank.
    var relay = gadgets.rpc.getRelayUrl(targetId);

    if (!relay) {
      throw new Error('No relay file assigned for IFPC');
    }

    // The RPC mechanism supports two formats for IFPC (legacy and current).
    var src = null;
    if (useLegacyProtocol[targetId]) {
      // Format: #iframe_id&callId&num_packets&packet_num&block_of_data
      src = [relay, '#', encodeLegacyData([from, callId, 1, 0,
        encodeLegacyData([from, serviceName, '', '', from].concat(
            callArgs))])].join('');
    } else {
      // Format: #targetId & sourceId@callId & packetNum & packetId & packetData
      src = [relay, '#', targetId, '&', from, '@', callId,
        '&1&0&', encodeURIComponent(rpcData)].join('');
    }

    // Conduct the IFPC call by creating the Iframe with
    // the relay URL and appended message.
    emitInvisibleIframe(src);
  }


  /**
   * Helper function to emit an invisible IFrame.
   * @param {String} src SRC attribute of the IFrame to emit.
   * @private
   */
  function emitInvisibleIframe(src) {
    var iframe;
    // Recycle IFrames
    for (var i = iframePool.length - 1; i >=0; --i) {
      var ifr = iframePool[i];
      try {
        if (ifr && (ifr.recyclable || ifr.readyState === 'complete')) {
          ifr.parentNode.removeChild(ifr);
          if (window.ActiveXObject) {
            // For MSIE, delete any iframes that are no longer being used. MSIE
            // cannot reuse the IFRAME because a navigational click sound will
            // be triggered when we set the SRC attribute.
            // Other browsers scan the pool for a free iframe to reuse.
            iframePool[i] = ifr = null;
            iframePool.splice(i, 1);
          } else {
            ifr.recyclable = false;
            iframe = ifr;
            break;
          }
        }
      } catch (e) {
        // Ignore; IE7 throws an exception when trying to read readyState and
        // readyState isn't set.
      }
    }
    // Create IFrame if necessary
    if (!iframe) {
      iframe = document.createElement('iframe');
      iframe.style.border = iframe.style.width = iframe.style.height = '0px';
      iframe.style.visibility = 'hidden';
      iframe.style.position = 'absolute';
      iframe.onload = function() { this.recyclable = true; };
      iframePool.push(iframe);
    }
    iframe.src = src;
    setTimeout(function() { document.body.appendChild(iframe); }, 0);
  }

  /**
   * Attempts to make an rpc by calling the target's receive method directly.
   * This works when gadgets are rendered on the same domain as their container,
   * a potentially useful optimization for trusted content which keeps
   * RPC behind a consistent interface.
   * @param {String} target Module id of the rpc service provider
   * @param {String} from Module id of the caller (this)
   * @param {String} callbackId Id of the call
   * @param {String} rpcData JSON-encoded RPC payload
   * @return
   */
  function callSameDomain(target, rpc) {
    if (typeof sameDomain[target] === 'undefined') {
      // Seed with a negative, typed value to avoid
      // hitting this code path repeatedly
      sameDomain[target] = false;
      var targetEl = null;
      if (target === '..') {
        targetEl = parent;
      } else {
        targetEl = frames[target];
      }
      try {
        // If this succeeds, then same-domain policy applied
        sameDomain[target] = targetEl.gadgets.rpc.receiveSameDomain;
      } catch (e) {
        // Usual case: different domains
      }
    }

    if (typeof sameDomain[target] === 'function') {
      // Call target's receive method
      sameDomain[target](rpc);
      return true;
    }

    return false;
  }

  // gadgets.config might not be available, such as when serving container js.
  if (gadgets.config) {
    /**
     * Initializes RPC from the provided configuration.
     */
    function init(config) {
      // Allow for wild card parent relay files as long as it's from a
      // white listed domain. This is enforced by the rendering servlet.
      if (config.rpc.parentRelayUrl.substring(0, 7) === 'http://') {
        relayUrl['..'] = config.rpc.parentRelayUrl;
      } else {
        // It's a relative path, and we must append to the parent.
        // We're relying on the server validating the parent parameter in this
        // case. Because of this, parent may only be passed in the query, not
        // the fragment.
        var params = document.location.search.substring(0).split("&");
        var parentParam = "";
        for (var i = 0, param; param = params[i]; ++i) {
          // Only the first parent can be validated.
          if (param.indexOf("parent=") === 0) {
            parentParam = decodeURIComponent(param.substring(7));
            break;
          }
        }
        relayUrl['..'] = parentParam + config.rpc.parentRelayUrl;
      }
      useLegacyProtocol['..'] = !!config.rpc.useLegacyProtocol;
    }

    var requiredConfig = {
      parentRelayUrl : gadgets.config.NonEmptyStringValidator
    };
    gadgets.config.register("rpc", requiredConfig, init);
  }

  return /** @scope gadgets.rpc */ {
    /**
     * Registers an RPC service.
     * @param {String} serviceName Service name to register.
     * @param {Function} handler Service handler.
     *
     * @member gadgets.rpc
     */
    register: function(serviceName, handler) {
      if (serviceName == CALLBACK_NAME) {
        throw new Error("Cannot overwrite callback service");
      }

      if (serviceName == DEFAULT_NAME) {
        throw new Error("Cannot overwrite default service:"
            + " use registerDefault");
      }

      services[serviceName] = handler;
    },

    /**
     * Unregisters an RPC service.
     * @param {String} serviceName Service name to unregister.
     *
     * @member gadgets.rpc
     */
    unregister: function(serviceName) {
      if (serviceName == CALLBACK_NAME) {
        throw new Error("Cannot delete callback service");
      }

      if (serviceName == DEFAULT_NAME) {
        throw new Error("Cannot delete default service:"
            + " use unregisterDefault");
      }

      delete services[serviceName];
    },

    /**
     * Registers a default service handler to processes all unknown
     * RPC calls which raise an exception by default.
     * @param {Function} handler Service handler.
     *
     * @member gadgets.rpc
     */
    registerDefault: function(handler) {
      services[''] = handler;
    },

    /**
     * Unregisters the default service handler. Future unknown RPC
     * calls will fail silently.
     *
     * @member gadgets.rpc
     */
    unregisterDefault: function() {
      delete services[''];
    },

    /**
     * Calls an RPC service.
     * @param {String} targetId Module Id of the RPC service provider.
     *                          Empty if calling the parent container.
     * @param {String} serviceName Service name to call.
     * @param {Function|null} callback Callback function (if any) to process
     *                                 the return value of the RPC request.
     * @param {*} var_args Parameters for the RPC request.
     *
     * @member gadgets.rpc
     */
    call: function(targetId, serviceName, callback, var_args) {
      ++callId;
      targetId = targetId || '..';
      if (callback) {
        callbacks[callId] = callback;
      }

      // Default to the container calling.
      var from = '..';

      if (targetId === '..') {
        from = window.name;
      }

      // Not used by legacy, create it anyway...
      var rpc = {
        s: serviceName,
        f: from,
        c: callback ? callId : 0,
        a: Array.prototype.slice.call(arguments, 3),
        t: authToken[targetId]
      };

      // If target is on the same domain, call method directly
      if (callSameDomain(targetId, rpc)) {
        return;
      }

      var rpcData = gadgets.json.stringify(rpc);

      var channelType = relayChannel;

      // If we are told to use the legacy format, then we must
      // default to IFPC.
      if (useLegacyProtocol[targetId]) {
        channelType = 'ifpc';
      }

      switch (channelType) {
        case 'dpm': // use document.postMessage.
          var targetDoc = targetId === '..' ? parent.document :
              frames[targetId].document;
          targetDoc.postMessage(rpcData);
          break;

        case 'wpm': // use window.postMessage.
          var targetWin = targetId === '..' ? parent : frames[targetId];
          targetWin.postMessage(rpcData, relayUrl[targetId]);
          break;

        case 'fe': // use FrameElement.
          callFrameElement(targetId, serviceName, from, rpcData, rpc.a);
          break;

        default: // use 'ifpc' as a fallback mechanism.
          callIfpc(targetId, serviceName, from, rpcData, rpc.a);
          break;
      }
    },

    /**
     * Gets the relay URL of a target frame.
     * @param {String} targetId Name of the target frame.
     * @return {String|undefined} Relay URL of the target frame.
     *
     * @member gadgets.rpc
     */
    getRelayUrl: function(targetId) {
      return relayUrl[targetId];
    },

    /**
     * Sets the relay URL of a target frame.
     * @param {String} targetId Name of the target frame.
     * @param {String} url Full relay URL of the target frame.
     * @param {Boolean} opt_useLegacy True if this relay needs the legacy IFPC
     *     wire format.
     *
     * @member gadgets.rpc
     */
    setRelayUrl: function(targetId, url, opt_useLegacy) {
      relayUrl[targetId] = url;
      useLegacyProtocol[targetId] = !!opt_useLegacy;
    },

    /**
     * Sets the auth token of a target frame.
     * @param {String} targetId Name of the target frame.
     * @param {String} token The authentication token to use for all
     *     calls to or from this target id.
     *
     * @member gadgets.rpc
     */
    setAuthToken: function(targetId, token) {
      authToken[targetId] = token;
      setupFrame(targetId);
    },

    /**
     * Gets the RPC relay mechanism.
     * @return {String} RPC relay mechanism. See above for
     *   a list of supported types.
     *
     * @member gadgets.rpc
     */
    getRelayChannel: function() {
      return relayChannel;
    },

    /**
     * Receives and processes an RPC request. (Not to be used directly.)
     * @param {Array.<String>} fragment An RPC request fragment encoded as
     *        an array. The first 4 elements are target id, source id & call id,
     *        total packet number, packet id. The last element stores the actual
     *        JSON-encoded and URI escaped packet data.
     *
     * @member gadgets.rpc
     */
    receive: function(fragment) {
      if (fragment.length > 4) {
        // TODO parse fragment[1..3] to merge multi-fragment messages
        process(gadgets.json.parse(
            decodeURIComponent(fragment[fragment.length - 1])));
      }
    },

    /**
     * Receives and processes an RPC request sent via the same domain.
     * (Not to be used directly). Converts the inbound rpc object's
     * Array into a local Array to pass the process() Array test.
     * @param {Object} rpc RPC object containing all request params
     */
    receiveSameDomain: function(rpc) {
      // Pass through to local process method but converting to a local Array
      rpc.a = Array.prototype.slice.call(rpc.a);
      window.setTimeout(function() { process(rpc) }, 0);
    }
  };
}();

;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/util.js' */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Utility functions for the Open Gadget Container
 */

Function.prototype.inherits = function(parentCtor) {
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  this.superClass_ = parentCtor.prototype;
  this.prototype = new tempCtor();
  this.prototype.constructor = this;
};;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/json.js' */
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * @fileoverview
 * The global object gadgets.json contains two methods.
 *
 * gadgets.json.stringify(value) takes a JavaScript value and produces a JSON
 * text. The value must not be cyclical.
 *
 * gadgets.json.parse(text) takes a JSON text and produces a JavaScript value.
 * It will return false if there is an error.
*/

var gadgets = gadgets || {};

/**
 * @static
 * @class Provides operations for translating objects to and from JSON.
 * @name gadgets.json
 */

/**
 * Port of the public domain JSON library by Douglas Crockford.
 * See: http://www.json.org/json2.js
 */
gadgets.json = function () {

  /**
   * Formats integers to 2 digits.
   * @param {Number} n
   */
  function f(n) {
    return n < 10 ? '0' + n : n;
  }

  Date.prototype.toJSON = function () {
    return [this.getUTCFullYear(), '-',
           f(this.getUTCMonth() + 1), '-',
           f(this.getUTCDate()), 'T',
           f(this.getUTCHours()), ':',
           f(this.getUTCMinutes()), ':',
           f(this.getUTCSeconds()), 'Z'].join("");
  };

  // table of character substitutions
  var m = {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '"' : '\\"',
    '\\': '\\\\'
  };

  /**
   * Converts a json object into a string.
   */
  function stringify(value) {
    var a,          // The array holding the partial texts.
        i,          // The loop counter.
        k,          // The member key.
        l,          // Length.
        r = /["\\\x00-\x1f\x7f-\x9f]/g,
        v;          // The member value.

    switch (typeof value) {
    case 'string':
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe ones.
      return r.test(value) ?
          '"' + value.replace(r, function (a) {
            var c = m[a];
            if (c) {
              return c;
            }
            c = a.charCodeAt();
            return '\\u00' + Math.floor(c / 16).toString(16) +
                (c % 16).toString(16);
            }) + '"'
          : '"' + value + '"';
    case 'number':
    // JSON numbers must be finite. Encode non-finite numbers as null.
      return isFinite(value) ? String(value) : 'null';
    case 'boolean':
    case 'null':
      return String(value);
    case 'object':
    // Due to a specification blunder in ECMAScript,
    // typeof null is 'object', so watch out for that case.
      if (!value) {
        return 'null';
      }
      // toJSON check removed; re-implement when it doesn't break other libs.
      a = [];
      if (typeof value.length === 'number' &&
          !(value.propertyIsEnumerable('length'))) {
        // The object is an array. Stringify every element. Use null as a
        // placeholder for non-JSON values.
        l = value.length;
        for (i = 0; i < l; i += 1) {
          a.push(stringify(value[i]) || 'null');
        }
        // Join all of the elements together and wrap them in brackets.
        return '[' + a.join(',') + ']';
      }
      // Otherwise, iterate through all of the keys in the object.
      for (k in value) if (value.hasOwnProperty(k)) {
        if (typeof k === 'string') {
          v = stringify(value[k]);
          if (v) {
            a.push(stringify(k) + ':' + v);
          }
        }
      }
      // Join all of the member texts together and wrap them in braces.
      return '{' + a.join(',') + '}';
    }
  }

  return {
    stringify: stringify,
    parse: function (text) {
// Parsing happens in three stages. In the first stage, we run the text against
// regular expressions that look for non-JSON patterns. We are especially
// concerned with '()' and 'new' because they can cause invocation, and '='
// because it can cause mutation. But just to be safe, we want to reject all
// unexpected forms.

// We split the first stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace all backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

      if (/^[\],:{}\s]*$/.test(text.replace(/\\["\\\/b-u]/g, '@').
          replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
          replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
        return eval('(' + text + ')');
      }
      // If the text is not JSON parseable, then return false.

      return false;
    }
  };
}();

;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/gadgets-core.js' */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

var gadgets = gadgets || {};

gadgets.error = {};
gadgets.error.SUBCLASS_RESPONSIBILITY = 'subclass responsibility';
gadgets.error.TO_BE_DONE = 'to be done';

gadgets.log = function(message) {
  if (window.console && console.log) {
    console.log(message);
  } else {
    var logEntry = document.createElement('div');
    logEntry.className = 'gadgets-log-entry';
    logEntry.innerHTML = message;
    document.body.appendChild(logEntry);
  }
};


//----------
//Extensible

gadgets.Extensible = function() {
};

/**
* Sets the dependencies.
* @param {Object} dependencies Object whose properties are set on this
*     container as dependencies
*/
gadgets.Extensible.prototype.setDependencies = function(dependencies) {
    for (var p in dependencies) {
        this[p] = dependencies[p];
    }
};

/**
* Returns a dependency given its name.
* @param {String} name Name of dependency
* @return {Object} Dependency with that name or undefined if not found
*/
gadgets.Extensible.prototype.getDependencies = function(name) {
    return this[name];
};


//-------------
//UserPrefStore

/**
* User preference store interface.
* @constructor
*/
gadgets.UserPrefStore = function() {
};

/**
* Gets all user preferences of a gadget.
* @param {Object} gadget Gadget object
* @return {Object} All user preference of given gadget
*/
gadgets.UserPrefStore.prototype.getPrefs = function(gadget) {
throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

/**
* Saves user preferences of a gadget in the store.
* @param {Object} gadget Gadget object
* @param {Object} prefs User preferences
*/
gadgets.UserPrefStore.prototype.savePrefs = function(gadget) {
throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};


//-------------
//DefaultUserPrefStore

/**
* User preference store implementation.
* TODO: Turn this into a real implementation that is production safe
* @constructor
*/
gadgets.DefaultUserPrefStore = function() {
gadgets.UserPrefStore.call(this);
};
gadgets.DefaultUserPrefStore.inherits(gadgets.UserPrefStore);

gadgets.DefaultUserPrefStore.prototype.getPrefs = function(gadget) { };

gadgets.DefaultUserPrefStore.prototype.savePrefs = function(gadget) { };


//-------------
//GadgetService

/**
* Interface of service provided to gadgets for resizing gadgets,
* setting title, etc.
* @constructor
*/
gadgets.GadgetService = function() {
};

gadgets.GadgetService.prototype.setHeight = function(elementId, height) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

gadgets.GadgetService.prototype.setTitle = function(gadget, title) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

gadgets.GadgetService.prototype.setUserPref = function(id) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

//----------------
//IfrGadgetService

/**
* Base implementation of GadgetService.  This implementation does not implement setting the title or user prefs as it
* is meant for gadgets that are standalone on a page.  
* @constructor
*/
gadgets.IfrGadgetService = function() {
    gadgets.GadgetService.call(this);
    
    /**
     * This is a bit funky looking but we need to be sure we always call the right method, even if the implementation
     * has been overridden after an IfrGadgetService is instantiated.
     */
    var service = this;
    gadgets.rpc.register('resize_iframe', function() { service.setHeight.apply(this, arguments); });
    gadgets.rpc.register('set_pref', function() { service.setUserPref.apply(this, arguments); });
    gadgets.rpc.register('set_title', function() { service.setTitle.apply(this, arguments); });
    gadgets.rpc.register('requestNavigateTo', function() { service.requestNavigateTo.apply(this, arguments); });
};

gadgets.IfrGadgetService.inherits(gadgets.GadgetService);

gadgets.IfrGadgetService.prototype.setHeight = function(height) {
    if (height > gadgets.container.maxheight_) {
        height = gadgets.container.maxheight_;
    }

    var element = document.getElementById(this.f);
    if (element) {
        element.style.height = height + 'px';
    }
};
    
/**
* Navigates the page to a new url based on a gadgets requested view and
* parameters.
*/
gadgets.IfrGadgetService.prototype.requestNavigateTo = function(view, opt_params) {
    var id = this.getGadgetIdFromModuleId(this.f);
    var url = this.getUrlForView(view);

    if (opt_params) {
        var paramStr = JSON.stringify(opt_params);
        if (paramStr.length > 0) {
            url += '&appParams=' + encodeURIComponent(paramStr);
        }
    }

    if (url && document.location.href.indexOf(url) == -1) {
        document.location.href = url;
    }
};

/**
* This is a silly implementation that will need to be overriden by almost all
* real containers.
* TODO: Find a better default for this function
*
* @param view The view name to get the url for
*/
gadgets.IfrGadgetService.prototype.getUrlForView = function(view) {
    if (view === 'canvas') {
        return '/canvas';
    } else if (view === 'profile') {
        return '/profile';
    } else {
        return null;
    }
};

gadgets.IfrGadgetService.prototype.getGadgetIdFromModuleId = function(moduleId) {
    // Quick hack to extract the gadget id from module id
    return parseInt(moduleId.match(/_([0-9]+)$/)[1], 10);
};

//-------------
//LayoutManager

/**
* Layout manager interface.
* @constructor
*/
gadgets.LayoutManager = function() {
};

/**
* Gets the HTML element that is the chrome of a gadget into which the content
* of the gadget can be rendered.
* @param {Object} gadget Gadget instance
* @return {Object} HTML element that is the chrome for the given gadget
*/
gadgets.LayoutManager.prototype.getGadgetChrome = function(gadget) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

//-------------------
//StaticLayoutManager

/**
* Static layout manager where gadget ids have a 1:1 mapping to chrome ids.
* @constructor
*/
gadgets.StaticLayoutManager = function() {
    gadgets.LayoutManager.call(this);
};

gadgets.StaticLayoutManager.inherits(gadgets.LayoutManager);

/**
* Sets chrome ids, whose indexes are gadget instance ids (starting from 0).
* @param {Array} gadgetIdToChromeIdMap Gadget id to chrome id map
*/
gadgets.StaticLayoutManager.prototype.setGadgetChromeIds = function(gadgetChromeIds) {
    this.gadgetChromeIds_ = gadgetChromeIds;
};

gadgets.StaticLayoutManager.prototype.getGadgetChrome = function(gadget) {
    var chromeId = this.gadgetChromeIds_[gadget.id];
    return chromeId ? document.getElementById(chromeId) : null;
};


//----------------------
//FloatLeftLayoutManager

/**
* FloatLeft layout manager where gadget ids have a 1:1 mapping to chrome ids.
* @constructor
* @param {String} layoutRootId Id of the element that is the parent of all
*     gadgets.
*/
gadgets.FloatLeftLayoutManager = function(layoutRootId) {
    gadgets.LayoutManager.call(this);
    this.layoutRootId_ = layoutRootId;
};

gadgets.FloatLeftLayoutManager.inherits(gadgets.LayoutManager);

gadgets.FloatLeftLayoutManager.prototype.getGadgetChrome = function(gadget) {
    var layoutRoot = document.getElementById(this.layoutRootId_);
    if (layoutRoot) {
        var chrome = document.createElement('div');
        chrome.className = 'gadgets-gadget-chrome';
        chrome.style.cssFloat = 'left';
        layoutRoot.appendChild(chrome);
        return chrome;
    } else {
        return null;
    }
};

;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-container-resources', location = 'js/gadgets-container.js' */
// ---------
// Container

/**
 * Container interface.
 * @constructor
 */
gadgets.Container = function() {
  this.parentUrl_ = 'http://' + document.location.host;
  this.country_ = 'ALL';
  this.language_ = 'ALL';
  this.view_ = 'default';
  this.nocache_ = 1;

  // signed max int
  this.maxheight_ = 0x7FFFFFFF;
};

gadgets.Container.inherits(gadgets.Extensible);

/**
 * Known dependencies:
 *     userPrefStore: instance of a subclass of gadgets.UserPrefStore
 *     gadgetService: instance of a subclass of gadgets.GadgetService
 *     layoutManager: instance of a subclass of gadgets.LayoutManager
 */

gadgets.Container.prototype.userPrefStore = new gadgets.DefaultUserPrefStore();

gadgets.Container.prototype.gadgetService = new gadgets.GadgetService();

gadgets.Container.prototype.layoutManager =
    new gadgets.StaticLayoutManager();

gadgets.Container.prototype.setParentUrl = function(url) {
  this.parentUrl_ = url;
};

gadgets.Container.prototype.setCountry = function(country) {
  this.country_ = country;
};

gadgets.Container.prototype.setNoCache = function(nocache) {
  this.nocache_ = nocache;
};

gadgets.Container.prototype.setLanguage = function(language) {
  this.language_ = language;
};

gadgets.Container.prototype.setView = function(view) {
  this.view_ = view;
};

gadgets.Container.prototype.setMaxHeight = function(maxheight) {
  this.maxheight_ = maxheight;
};

gadgets.Container.prototype.getGadgetKey_ = function(instanceId) {
  return 'gadget_' + instanceId;
};


// ------------
// IfrContainer

/**
 * Container that renders gadget using ifr.
 * @constructor
 */
gadgets.IfrContainer = function() {
  gadgets.Container.call(this);
};

gadgets.IfrContainer.inherits(gadgets.Container);

gadgets.IfrContainer.prototype.gadgetService = new gadgets.IfrGadgetService();

gadgets.IfrContainer.prototype.setParentUrl = function(url) {
  if (!url.match(/^http[s]?:\/\//)) {
    url = document.location.href.match(/^[^?#]+\//)[0] + url;
  }

  this.parentUrl_ = url;
};

/**
 * Default container.
 */
gadgets.container = new gadgets.IfrContainer();
;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-standalone-resources', location = 'js/gadgets-standalone.js' */
// implementations of setTitle and setPrefs would go here

new gadgets.IfrGadgetService();

gadgets.IfrGadgetService.prototype.setTitle = function(title) {
    //Ignore this call silently to avoid javascript exceptions & errors! (AG-1289)
};;
;
/* module-key = 'com.atlassian.plugin.jslibs:brace-2014.09.03-factory', location = 'factories/brace/2014.09.03/brace-2104.09.03-factory.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
    define('atlassian/libs/factories/brace-2014.09.03', function() {
        return function(_, Backbone) {
            var env = {
                _: _,
                Backbone: Backbone
            };
            factory.call(env);
            var Brace = env.Brace.noConflict();
            Brace.VERSION = "2014.09.03";
            return Brace;
        }
    });
/////// End of Atlassian modification ///////
})(function(){
    /*!
     *  Backbone Brace - 2014-06-27
     *  Copyright 2014 Atlassian Software Systems Pty Ltd
     *  Licensed under the Apache License, Version 2.0
     */
    (function (root, factory) {
        // Global to export
        var rootExport = 'Brace';
        // Store a reference to any other copies of Brace include (if any)
        var previousBrace = root[rootExport];

        // noConflict will return this version of Brace and reset the global
        // Brace variable to the previously loaded version of Brace (or undefined
        // if there was no previous version loaded).
        /**
         * Returns the current copy of Brace and sets the global Brace object to the
         * previous version (or undefined if there was no previous version loaded).
         *
         * @returns Object A reference to this version of Brace.
         */
        var noConflict = function () {
            root[rootExport] = previousBrace;
            return this;
        };

        /////////// Modified by Atlassian ///////////
        //if (typeof define === 'function' && define.amd) {
        //    // AMD. Register as an anonymous module.
        //    define(['underscore', 'backbone'], factory);
        //} else if (typeof exports === 'object') {
        //    // Node. Does not work with strict CommonJS, but
        //    // only CommonJS-like enviroments that support module.exports,
        //    // like Node.
        //    module.exports = factory(require('underscore'), require('backbone'));
        //} else {
        //    var _brace = factory(root._, root.Backbone);
        //    _brace.noConflict = noConflict;
        //    root[rootExport] = _brace;
        //}
        // Bypassing in-library AMD
        var _brace = factory(root._, root.Backbone);
        _brace.noConflict = noConflict;
        root[rootExport] = _brace;
        /////// End of Atlassian modification ///////

    }(this, function (_, Backbone)
    {

        var Brace = {};

        // ## Helper functions

        // Given an array, this function will return an object where each
        //     property name is an element of the original array. The value
        //     of each property will be null.
        // Given anything else, this function will return the object untouched.
        /**
         * This function is used to ensure a consistent shape for the namedAttributes property.
         * namedAttributes accepts two formats:
         * - An array like ['attr1', 'attr2'] if you don't care about the type of any attribute.
         * - An object like { attr1 : type1, attr2 : type2 } to specify an expected type.
         *
         * @param maybeArray {*} thing to transform into an object
         */
        function asObject(maybeArray) {
            if (_.isArray(maybeArray)) {
                return _.reduce(maybeArray, function(obj, prop) {
                    obj[prop] =  null;
                    return obj;
                }, {});
            }
            return maybeArray;
        }

        // Return a value of the specified type, generated from the value parameter.
        // If type conversion is necessary, this function will generate a new object using
        // `new type(value)`
        //
        // `value` Any value. null and undefined values will be untouched.
        //
        // `type` When given:
        //
        // * a falsy value: this function will do no type conversion.
        // * a string: this function will throw if `typeof value !== type`, and return value otherwise.
        // * an Array: this function will be recursively called for each element in value using
        //   type's first element as the type. E.g.,
        //         `ensureType([ Number ], [ 1 ])` will recursively call `ensureType(Number, 1)`
        //   It will return a new array consisting of the result of each recursive call.
        // * a Backbone.Collection constructor: this function may be recursively called for each element in
        //     value using type.model as the type. E.g.,
        //         `ensureType({ model : Number, __proto__ : Backbone.Collection.prototype }, [ 1 ])` will
        //         recursively call `ensureType(Number, 1)`
        //     It will return a Backbone.Collection via new type({array of recursive results})
        // * a function: This will check value instanceof type, and if false, will return `new type(value)`
        //     Otherwise it will return value directly
        /**
         * @param value {*}
         * @param type {Array|function(new:*, *)|string|false|null|undefined}
         */
        function ensureType(type, value) {
            /*jshint newcap: false */
            if (!type || value == null) {
                return value;
            }

            if (type === String && _.isString(value)) {
                return value;
            }
            if (type === Number && _.isNumber(value)) {
                return value;
            }
            if (type === Boolean && _.isBoolean(value)) {
                return value;
            }

            if (typeof type === 'string' || type instanceof String) {
                if (typeof value !== ""+type) {
                    throw "The typeof " + value + " is " + typeof value + " but expected it to be " + type;
                }
                return value;
            }

            if (_.isArray(type) || type === Array) {
                if (!isArrayLike(value)) {
                    throw "Array type expected, but nonnull, non-Array value provided.";
                }
                return type === Array || !type[0] ?
                    value :
                    _.map(value, _.bind(ensureType, null, type[0]));
            }

            if (typeof type !== 'function') {
                throw "Invalid expected type " + type +
                '. Should be falsy, String, Array, Backbone.Collection constructor, or function.';
            }

            if (value instanceof type) {
                return value;
            }

            if (isCollectionConstructor(type)) {
                return new type(ensureType([ type.model ], value));
            }

            return new type(value);
        }

        // Returns true if obj is extend()'ed from Backbone.Collection (or from another collection)
        /**
         * @param obj {*} object to check
         * @param rootConstructor {?function(new:Backbone.Collection)} optional constructor that inherits from
         *        Backbone.Collection. Will check that obj is extend()'ed from this instead of Backbone.Collection.
         */
        function isCollectionConstructor(obj, rootConstructor) {
            return  obj && (
                    // obj *distantly* extends Backbone.Collection (most likely case)
                    obj.__super__ instanceof (rootConstructor || Backbone.Collection) ||

                        // obj *directly* extends Backbone.Collection (e.g., Brace.Collection)
                        // !(fn.prototype instanceof fn), so the above check doesn't catch this case.
                    obj.__super__ === (rootConstructor || Backbone.Collection).prototype ||

                        // obj *is* Backbone.Collection
                    obj === (rootConstructor || Backbone.Collection)
                );
        }

        // array-like is currently defined by "has a length property, and is not a string or
        // function or Backbone.Collection."
        // Backbone.Collections are excluded because you can't do collection[0] to access models.
        function isArrayLike(value) {
            return _.has(value,'length') && !(
                    value instanceof String ||
                    _.has({'string':1, 'function':1}, typeof value) ||
                    value instanceof Backbone.Collection
                );
        }

        // With namedAttributes, we want to allow both the mixin, and the extender to define types.
        // We want to take the stricter of the two types where possible.
        // Where the types conflict, throw an error.
        function nonConflictedTypes(obj, refObj) {
            var newObj = {};
            _.each(obj, function(val, key) {
                if (!refObj[key] || assumes(val, refObj[key])) {
                    newObj[key] = val;
                } else if (!val || assumes(refObj[key], val)) {
                    return;
                } else {
                    throw key + " has conflicted type descriptors.";
                }
            });
            return newObj;
        }

        // One type *assumes* another when the conditions for meeting its
        // type-check are a super set of the assumed type's conditions.
        // E.g., `[ 'string' ]` assumes `Array` because you can't have an array of strings without an array.
        function assumes(assumer, assumed) {
            if (!assumed || assumed === assumer) {
                return true;
            }
            // if it's a string, only the previous strict equality check would have sufficed.
            if (!assumer || typeof assumer === 'string') {
                return false;
            }
            if (assumer instanceof Array) {
                return assumed === Array ||
                    (assumed instanceof Array && assumes(assumer[0], assumed[0]));
            }
            if (typeof assumed !== 'function') {
                return false;
            }
            if (isCollectionConstructor(assumed)) {
                return isCollectionConstructor(assumer, assumed);
            }
            return assumer.prototype instanceof assumed;
        }

        /**
         * @param {Object?} object
         * @return {Object} plain object
         */
        function nestedToJSON(object) {
            if (_.isObject(object)) {
                return _.reduce(object, function(memo, value, key) {
                    if (value && _.isFunction(value.toJSON)) {
                        memo[key] = value.toJSON();
                    } else if (_.isArray(value)) {
                        memo[key] = _.map(value, function(el) {
                            if (el && _.isFunction(el.toJSON)) {
                                return el.toJSON();
                            } else {
                                return el;
                            }
                        });
                    }
                    return memo;
                }, object);
            } else {
                return object;
            }
        }

        function createToJSON(previousToJSON) {
            return function toJSON() {
                var json = previousToJSON.call(this);
                return nestedToJSON(json);
            };
        }

        // ## Brace.Mixins ##
        // Mixin utilities
        Brace.Mixins = {
            // Creates a camelCased method name
            createMethodName: function(prefix, suffix) {
                return prefix + suffix.charAt(0).toUpperCase() + suffix.substr(1);
            },

            // Applies a mixin to the given constructor's prototype.
            applyMixin: function(ctor, mixin) {
                _.forEach(_.keys(mixin), function(key) {
                    var proto = ctor.prototype;

                    // `initialize` is not mixed in - we compose the mixin's initialize with the existing initialize method (if it exists).
                    if ("initialize" === key) {
                        var oldInitialize = proto.initialize;
                        proto.initialize = function() {
                            if (oldInitialize) {
                                oldInitialize.apply(this, arguments);
                            }
                            mixin.initialize.apply(this, arguments);
                        };
                        return;
                    }
                    // `validate` is not mixed in - we compose the mixin's validate with the existing validate method (if it exists).
                    if ("validate" === key) {
                        var oldValidate = proto.validate;
                        proto.validate = function() {
                            if (oldValidate) {
                                var errors = oldValidate.apply(this, arguments);
                                if (errors) {
                                    return errors;
                                }
                            }
                            return mixin.validate.apply(this, arguments);
                        };
                        return;
                    }
                    // `defaults` are not mixed in - we compose the mixin's defaults with existing defaults if they exist
                    if ("defaults" === key) {
                        var defaults = proto.defaults || (proto.defaults = {});
                        var mixinDefaults = mixin[key];
                        for (var id in mixinDefaults) {
                            if (defaults.hasOwnProperty(id)) {
                                throw "Mixin error: class already has default '" + id + "' defined";
                            }
                            defaults[id] = mixinDefaults[id];
                        }
                        return;
                    }
                    // `namedAttributes` are added to the mixin, and we mixin in getters and setters for each attribute.
                    if ("namedAttributes" === key) {
                        var protoAttrs = asObject(proto.namedAttributes) || {};
                        var mixinAttrs = asObject(mixin[key]);
                        proto.namedAttributes = _.extend(protoAttrs, nonConflictedTypes(mixinAttrs, protoAttrs));
                        return;
                    }

                    // `namedEvents` are added to the mixin, and we mix in on and trigger methods for each event.
                    if ("namedEvents" === key) {
                        // `events` must be an array
                        if (!_.isArray(mixin[key])) {
                            throw "Expects events member on mixin to be an array";
                        }
                        if (!proto.namedEvents) {
                            proto.namedEvents = [];
                        }
                        proto.namedEvents = _.uniq(proto.namedEvents.concat(mixin[key]));
                        return;
                    }
                    // Name collisions with other mixins or or the object we're mixing into result in violent and forceful disapproval.
                    if (proto.hasOwnProperty(key)) {
                        throw "Mixin error: class already has property '" + key + "' defined";
                    }
                    proto[key] = mixin[key];
                }, this);
            }
        };

        // ## Brace.AttributesMixinCreator ##
        Brace.AttributesMixinCreator = {

            // Creates a mixin of getter and setter methods for each item in the given attribute list.
            // A getter and setter for `id` is always generated.
            create: function(attributes, idAttribute) {
                var methods = {};

                if (!attributes) {
                    attributes = {};
                }

                if (!_.has(attributes, "id")) {
                    attributes.id = null;
                }

                _.each(attributes, function (expectedType, attrName) {
                    // TODO: has, escape, unset
                    var setter = Brace.Mixins.createMethodName("set", attrName);
                    methods[setter] = function (val,options) {
                        return this.set(attrName, val, options);
                    };
                    var getter = Brace.Mixins.createMethodName("get", attrName);
                    methods[getter] = function () {
                        return this.get(attrName);
                    };
                });

                // If an idAttribute is specified
                //
                //    * the ID is going to be of the same type as that attribute
                //    * alias the ID's getter/setter to that attribute's getter/setter
                //    * Don't alias if the idAttribute is set to 'id'
                if (typeof idAttribute === 'string' && typeof attributes[idAttribute] !== 'undefined' && idAttribute !== 'id') {
                    attributes.id = attributes[idAttribute];
                    var idGetter = Brace.Mixins.createMethodName("get", idAttribute);
                    var idSetter = Brace.Mixins.createMethodName("set", idAttribute);
                    methods.getId = function() { return this[idGetter](); };
                    methods.setId = function(val, options) { return this[idSetter](val, options); };
                }

                return methods;
            },
            /**
             * See JSDoc for this function in the backbone.brace file.
             *
             * Expose the ensureType function for people with custom constructors that don't call
             * .set() to initialize attributes. Hopefully this is rarely used, as I would
             * consider not calling .set() to be a code smell.
             *
             * @param type
             * @param value
             */
            ensureType : ensureType
        };

        // ## Brace.EventsMixinCreator ##
        Brace.EventsMixinCreator = {

            // Creates a mixin of on and trigger methods for each item in the given list of events.
            create: function(events) {
                var eventMethods = {};
                var createEvent = function(eventName) {
                    // TODO: off
                    var binder = Brace.Mixins.createMethodName("on", eventName);
                    eventMethods[binder] = function() {
                        return this.on.apply(this, [eventName].concat(_.toArray(arguments)));
                    };
                    var trigger = Brace.Mixins.createMethodName("trigger", eventName);
                    eventMethods[trigger] = function() {
                        return this.trigger.apply(this, [eventName].concat(_.toArray(arguments)));
                    };
                };
                _.each(events, _.bind(createEvent,this));

                return eventMethods;
            }
        };

        // Generates an `extend` method that overrides Backbone's default `extend`. The new extend calls Backbone's `extend`, then:
        //
        //   * Adds all mixins specified in the `mixins` array
        //   * Adds a `Brace.EventsMixinCreator` to mix in on and trigger methods for events specified in the `namedEvents` array
        //   * Adds a `Brace.AttributesMixinCreator` to mix in get and set methods for attributes specified in the `attributes` array
        function generateMixinExtend(oldExtend) {
            return function newExtend(protoProps, classProps) {
                var child;
                var cleanProtoProps = _.extend({}, protoProps);
                // Remove `mixins` - we don't want to see them on the created prototype. Note that we do want to see `namedAttributes` and `namedEvents` for debugging
                var mixins;
                if (protoProps && protoProps.mixins) {
                    mixins = protoProps.mixins;
                    delete cleanProtoProps.mixins;
                }
                child = oldExtend.call(this, cleanProtoProps, classProps);

                if (this.prototype.namedEvents) {
                    Brace.Mixins.applyMixin(child, { namedEvents : this.prototype.namedEvents });
                }
                if (this.prototype.namedAttributes) {
                    Brace.Mixins.applyMixin(child, { namedAttributes : this.prototype.namedAttributes });
                }

                if (mixins) {
                    _.each(protoProps.mixins, function(mixin) {
                        Brace.Mixins.applyMixin(child, mixin);
                    });
                }
                if (child.prototype.namedEvents) {
                    Brace.Mixins.applyMixin(child, Brace.EventsMixinCreator.create(child.prototype.namedEvents));
                }
                if (child.prototype.namedAttributes) {
                    child.prototype.namedAttributes = asObject(child.prototype.namedAttributes);
                    Brace.Mixins.applyMixin(child, Brace.AttributesMixinCreator.create(child.prototype.namedAttributes, child.prototype.idAttribute));
                }

                if (child.prototype.toJSON) {
                    child.prototype.toJSON = createToJSON(child.prototype.toJSON);
                }

                child.extend = newExtend;
                return child;
            };
        }

        // Overrides Backbone's `get` and `set` methods to validate that the attribute being get / set is a namedAttribute.
        function overrideSetGet(ctor, childCtor) {
            var proto = ctor.prototype;
            var childProto = childCtor.prototype;

            var oldSet = proto.set;
            childProto.set = function(key, value, options) {
                // TODO: has, escape, unset
                var attrs,
                    attributes = this.namedAttributes;

                if (!attributes || key == null) {
                    return oldSet.apply(this, arguments);
                }

                if (_.isObject(key)) {
                    attrs = _.clone(key);
                    options = value;
                } else {
                    attrs = {};
                    attrs[key] = value;
                }

                for (var attr in attrs) {
                    if (!_.has(attrs, attr)) {
                        continue;
                    }
                    if (!_.has(attributes, attr)) {
                        throw "Attribute '" + attr + "' does not exist";
                    }
                    attrs[attr] = ensureType(attributes[attr], attrs[attr]);
                }

                return oldSet.call(this, attrs, options);
            };

            var oldGet = proto.get;
            childProto.get = function(attr) {
                if (this.namedAttributes && !_.has(this.namedAttributes, attr)) {
                    throw "Attribute '" + attr + "' does not exist";
                }
                return oldGet.apply(this, arguments);
            };
        }

        // Overrides Backbone's `parse` method to parse only namedAttributes
        function overrideParse(ctor, childCtor) {
            var proto = ctor.prototype;
            var childProto = childCtor.prototype;

            var oldParse = proto.parse;
            childProto.parse = function(response, options) {
                return _.pick(oldParse(response, options), _.keys(this.namedAttributes));
            };
        }

        // Applies extensions to the given constructor function. Sets `extend` to a method generated by `generateMixinExtend`
        function applyExtensions(ctor) {
            var child = ctor.extend();
            var oldExtend = ctor.extend;
            child.extend = generateMixinExtend(oldExtend);
            return child;
        }


        // Applies extensions to the given constructor function. Sets `extend` to a method generated by `generateMixinExtend`
        function applyModelExtensions(ctor) {
            var child = applyExtensions(ctor);
            overrideSetGet(ctor, child);
            overrideParse(ctor, child);
            return child;
        }

        // Extend base Backbone classes
        Brace.Model = applyModelExtensions(Backbone.Model);
        Brace.Collection = applyExtensions(Backbone.Collection);
        Brace.View = applyExtensions(Backbone.View);
        Brace.Router = applyExtensions(Backbone.Router);
        var Evented = function() {
            this.initialize.apply(this, arguments);
        };
        _.extend(Evented.prototype, Backbone.Events, {
            initialize: function() {}
        });
        Evented.extend = Backbone.Model.extend;
        Brace.Evented = applyExtensions(Evented);

        return Brace;

    }));
/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////;
;
/* module-key = 'com.atlassian.plugin.jslibs:underscore-1.5.2', location = 'libs/underscore/1.5.2/underscore-1.5.2.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
  define('atlassian/libs/underscore-1.5.2', function() {
    var env = {};
    factory.call(env);
    return env._.noConflict();
  });
})(function(){
/////// End of Atlassian modification ///////

  //     Underscore.js 1.5.2
  //     http://underscorejs.org
  //     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  //     Underscore may be freely distributed under the MIT license.

  (function() {

    // Baseline setup
    // --------------

    // Establish the root object, `window` in the browser, or `exports` on the server.
    var root = this;

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Establish the object that gets returned to break out of a loop iteration.
    var breaker = {};

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var
      push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var
      nativeForEach      = ArrayProto.forEach,
      nativeMap          = ArrayProto.map,
      nativeReduce       = ArrayProto.reduce,
      nativeReduceRight  = ArrayProto.reduceRight,
      nativeFilter       = ArrayProto.filter,
      nativeEvery        = ArrayProto.every,
      nativeSome         = ArrayProto.some,
      nativeIndexOf      = ArrayProto.indexOf,
      nativeLastIndexOf  = ArrayProto.lastIndexOf,
      nativeIsArray      = Array.isArray,
      nativeKeys         = Object.keys,
      nativeBind         = FuncProto.bind;

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) {
      if (obj instanceof _) return obj;
      if (!(this instanceof _)) return new _(obj);
      this._wrapped = obj;
    };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `_` as a global object via a string identifier,
    // for Closure Compiler "advanced" mode.
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = _;
      }
      exports._ = _;
    } else {
      root._ = _;
    }

    // Current version.
    _.VERSION = '1.5.2';

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles objects with the built-in `forEach`, arrays, and raw objects.
    // Delegates to **ECMAScript 5**'s native `forEach` if available.
    var each = _.each = _.forEach = function(obj, iterator, context) {
      if (obj == null) return;
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, length = obj.length; i < length; i++) {
          if (iterator.call(context, obj[i], i, obj) === breaker) return;
        }
      } else {
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
        }
      }
    };

    // Return the results of applying the iterator to each element.
    // Delegates to **ECMAScript 5**'s native `map` if available.
    _.map = _.collect = function(obj, iterator, context) {
      var results = [];
      if (obj == null) return results;
      if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
      each(obj, function(value, index, list) {
        results.push(iterator.call(context, value, index, list));
      });
      return results;
    };

    var reduceError = 'Reduce of empty array with no initial value';

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
    _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
      var initial = arguments.length > 2;
      if (obj == null) obj = [];
      if (nativeReduce && obj.reduce === nativeReduce) {
        if (context) iterator = _.bind(iterator, context);
        return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
      }
      each(obj, function(value, index, list) {
        if (!initial) {
          memo = value;
          initial = true;
        } else {
          memo = iterator.call(context, memo, value, index, list);
        }
      });
      if (!initial) throw new TypeError(reduceError);
      return memo;
    };

    // The right-associative version of reduce, also known as `foldr`.
    // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
    _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
      var initial = arguments.length > 2;
      if (obj == null) obj = [];
      if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
        if (context) iterator = _.bind(iterator, context);
        return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
      }
      var length = obj.length;
      if (length !== +length) {
        var keys = _.keys(obj);
        length = keys.length;
      }
      each(obj, function(value, index, list) {
        index = keys ? keys[--length] : --length;
        if (!initial) {
          memo = obj[index];
          initial = true;
        } else {
          memo = iterator.call(context, memo, obj[index], index, list);
        }
      });
      if (!initial) throw new TypeError(reduceError);
      return memo;
    };

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = function(obj, iterator, context) {
      var result;
      any(obj, function(value, index, list) {
        if (iterator.call(context, value, index, list)) {
          result = value;
          return true;
        }
      });
      return result;
    };

    // Return all the elements that pass a truth test.
    // Delegates to **ECMAScript 5**'s native `filter` if available.
    // Aliased as `select`.
    _.filter = _.select = function(obj, iterator, context) {
      var results = [];
      if (obj == null) return results;
      if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
      each(obj, function(value, index, list) {
        if (iterator.call(context, value, index, list)) results.push(value);
      });
      return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = function(obj, iterator, context) {
      return _.filter(obj, function(value, index, list) {
        return !iterator.call(context, value, index, list);
      }, context);
    };

    // Determine whether all of the elements match a truth test.
    // Delegates to **ECMAScript 5**'s native `every` if available.
    // Aliased as `all`.
    _.every = _.all = function(obj, iterator, context) {
      iterator || (iterator = _.identity);
      var result = true;
      if (obj == null) return result;
      if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
      each(obj, function(value, index, list) {
        if (!(result = result && iterator.call(context, value, index, list))) return breaker;
      });
      return !!result;
    };

    // Determine if at least one element in the object matches a truth test.
    // Delegates to **ECMAScript 5**'s native `some` if available.
    // Aliased as `any`.
    var any = _.some = _.any = function(obj, iterator, context) {
      iterator || (iterator = _.identity);
      var result = false;
      if (obj == null) return result;
      if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
      each(obj, function(value, index, list) {
        if (result || (result = iterator.call(context, value, index, list))) return breaker;
      });
      return !!result;
    };

    // Determine if the array or object contains a given value (using `===`).
    // Aliased as `include`.
    _.contains = _.include = function(obj, target) {
      if (obj == null) return false;
      if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
      return any(obj, function(value) {
        return value === target;
      });
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = function(obj, method) {
      var args = slice.call(arguments, 2);
      var isFunc = _.isFunction(method);
      return _.map(obj, function(value) {
        return (isFunc ? method : value[method]).apply(value, args);
      });
    };

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = function(obj, key) {
      return _.map(obj, function(value){ return value[key]; });
    };

    // Convenience version of a common use case of `filter`: selecting only objects
    // containing specific `key:value` pairs.
    _.where = function(obj, attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return _[first ? 'find' : 'filter'](obj, function(value) {
        for (var key in attrs) {
          if (attrs[key] !== value[key]) return false;
        }
        return true;
      });
    };

    // Convenience version of a common use case of `find`: getting the first object
    // containing specific `key:value` pairs.
    _.findWhere = function(obj, attrs) {
      return _.where(obj, attrs, true);
    };

    // Return the maximum element or (element-based computation).
    // Can't optimize arrays of integers longer than 65,535 elements.
    // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
    _.max = function(obj, iterator, context) {
      if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
        return Math.max.apply(Math, obj);
      }
      if (!iterator && _.isEmpty(obj)) return -Infinity;
      var result = {computed : -Infinity, value: -Infinity};
      each(obj, function(value, index, list) {
        var computed = iterator ? iterator.call(context, value, index, list) : value;
        computed > result.computed && (result = {value : value, computed : computed});
      });
      return result.value;
    };

    // Return the minimum element (or element-based computation).
    _.min = function(obj, iterator, context) {
      if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
        return Math.min.apply(Math, obj);
      }
      if (!iterator && _.isEmpty(obj)) return Infinity;
      var result = {computed : Infinity, value: Infinity};
      each(obj, function(value, index, list) {
        var computed = iterator ? iterator.call(context, value, index, list) : value;
        computed < result.computed && (result = {value : value, computed : computed});
      });
      return result.value;
    };

    // Shuffle an array, using the modern version of the
    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
    _.shuffle = function(obj) {
      var rand;
      var index = 0;
      var shuffled = [];
      each(obj, function(value) {
        rand = _.random(index++);
        shuffled[index - 1] = shuffled[rand];
        shuffled[rand] = value;
      });
      return shuffled;
    };

    // Sample **n** random values from an array.
    // If **n** is not specified, returns a single random element from the array.
    // The internal `guard` argument allows it to work with `map`.
    _.sample = function(obj, n, guard) {
      if (arguments.length < 2 || guard) {
        return obj[_.random(obj.length - 1)];
      }
      return _.shuffle(obj).slice(0, Math.max(0, n));
    };

    // An internal function to generate lookup iterators.
    var lookupIterator = function(value) {
      return _.isFunction(value) ? value : function(obj){ return obj[value]; };
    };

    // Sort the object's values by a criterion produced by an iterator.
    _.sortBy = function(obj, value, context) {
      var iterator = lookupIterator(value);
      return _.pluck(_.map(obj, function(value, index, list) {
        return {
          value: value,
          index: index,
          criteria: iterator.call(context, value, index, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
      }), 'value');
    };

    // An internal function used for aggregate "group by" operations.
    var group = function(behavior) {
      return function(obj, value, context) {
        var result = {};
        var iterator = value == null ? _.identity : lookupIterator(value);
        each(obj, function(value, index) {
          var key = iterator.call(context, value, index, obj);
          behavior(result, key, value);
        });
        return result;
      };
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = group(function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });

    // Indexes the object's values by a criterion, similar to `groupBy`, but for
    // when you know that your index values will be unique.
    _.indexBy = group(function(result, key, value) {
      result[key] = value;
    });

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    _.countBy = group(function(result, key) {
      _.has(result, key) ? result[key]++ : result[key] = 1;
    });

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = function(array, obj, iterator, context) {
      iterator = iterator == null ? _.identity : lookupIterator(iterator);
      var value = iterator.call(context, obj);
      var low = 0, high = array.length;
      while (low < high) {
        var mid = (low + high) >>> 1;
        iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
      }
      return low;
    };

    // Safely create a real, live array from anything iterable.
    _.toArray = function(obj) {
      if (!obj) return [];
      if (_.isArray(obj)) return slice.call(obj);
      if (obj.length === +obj.length) return _.map(obj, _.identity);
      return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = function(obj) {
      if (obj == null) return 0;
      return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
    };

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = function(array, n, guard) {
      if (array == null) return void 0;
      return (n == null) || guard ? array[0] : slice.call(array, 0, n);
    };

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N. The **guard** check allows it to work with
    // `_.map`.
    _.initial = function(array, n, guard) {
      return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
    };

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array. The **guard** check allows it to work with `_.map`.
    _.last = function(array, n, guard) {
      if (array == null) return void 0;
      if ((n == null) || guard) {
        return array[array.length - 1];
      } else {
        return slice.call(array, Math.max(array.length - n, 0));
      }
    };

    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
    // Especially useful on the arguments object. Passing an **n** will return
    // the rest N values in the array. The **guard**
    // check allows it to work with `_.map`.
    _.rest = _.tail = _.drop = function(array, n, guard) {
      return slice.call(array, (n == null) || guard ? 1 : n);
    };

    // Trim out all falsy values from an array.
    _.compact = function(array) {
      return _.filter(array, _.identity);
    };

    // Internal implementation of a recursive `flatten` function.
    var flatten = function(input, shallow, output) {
      if (shallow && _.every(input, _.isArray)) {
        return concat.apply(output, input);
      }
      each(input, function(value) {
        if (_.isArray(value) || _.isArguments(value)) {
          shallow ? push.apply(output, value) : flatten(value, shallow, output);
        } else {
          output.push(value);
        }
      });
      return output;
    };

    // Flatten out an array, either recursively (by default), or just one level.
    _.flatten = function(array, shallow) {
      return flatten(array, shallow, []);
    };

    // Return a version of the array that does not contain the specified value(s).
    _.without = function(array) {
      return _.difference(array, slice.call(arguments, 1));
    };

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = function(array, isSorted, iterator, context) {
      if (_.isFunction(isSorted)) {
        context = iterator;
        iterator = isSorted;
        isSorted = false;
      }
      var initial = iterator ? _.map(array, iterator, context) : array;
      var results = [];
      var seen = [];
      each(initial, function(value, index) {
        if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
          seen.push(value);
          results.push(array[index]);
        }
      });
      return results;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = function() {
      return _.uniq(_.flatten(arguments, true));
    };

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    _.intersection = function(array) {
      var rest = slice.call(arguments, 1);
      return _.filter(_.uniq(array), function(item) {
        return _.every(rest, function(other) {
          return _.indexOf(other, item) >= 0;
        });
      });
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = function(array) {
      var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
      return _.filter(array, function(value){ return !_.contains(rest, value); });
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = function() {
      var length = _.max(_.pluck(arguments, "length").concat(0));
      var results = new Array(length);
      for (var i = 0; i < length; i++) {
        results[i] = _.pluck(arguments, '' + i);
      }
      return results;
    };

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values.
    _.object = function(list, values) {
      if (list == null) return {};
      var result = {};
      for (var i = 0, length = list.length; i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    };

    // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
    // we need this function. Return the position of the first occurrence of an
    // item in an array, or -1 if the item is not included in the array.
    // Delegates to **ECMAScript 5**'s native `indexOf` if available.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = function(array, item, isSorted) {
      if (array == null) return -1;
      var i = 0, length = array.length;
      if (isSorted) {
        if (typeof isSorted == 'number') {
          i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
        } else {
          i = _.sortedIndex(array, item);
          return array[i] === item ? i : -1;
        }
      }
      if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
      for (; i < length; i++) if (array[i] === item) return i;
      return -1;
    };

    // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
    _.lastIndexOf = function(array, item, from) {
      if (array == null) return -1;
      var hasIndex = from != null;
      if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
        return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
      }
      var i = (hasIndex ? from : array.length);
      while (i--) if (array[i] === item) return i;
      return -1;
    };

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function(start, stop, step) {
      if (arguments.length <= 1) {
        stop = start || 0;
        start = 0;
      }
      step = arguments[2] || 1;

      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var idx = 0;
      var range = new Array(length);

      while(idx < length) {
        range[idx++] = start;
        start += step;
      }

      return range;
    };

    // Function (ahem) Functions
    // ------------------

    // Reusable constructor function for prototype setting.
    var ctor = function(){};

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
    // available.
    _.bind = function(func, context) {
      var args, bound;
      if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
      if (!_.isFunction(func)) throw new TypeError;
      args = slice.call(arguments, 2);
      return bound = function() {
        if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
        ctor.prototype = func.prototype;
        var self = new ctor;
        ctor.prototype = null;
        var result = func.apply(self, args.concat(slice.call(arguments)));
        if (Object(result) === result) return result;
        return self;
      };
    };

    // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context.
    _.partial = function(func) {
      var args = slice.call(arguments, 1);
      return function() {
        return func.apply(this, args.concat(slice.call(arguments)));
      };
    };

    // Bind all of an object's methods to that object. Useful for ensuring that
    // all callbacks defined on an object belong to it.
    _.bindAll = function(obj) {
      var funcs = slice.call(arguments, 1);
      if (funcs.length === 0) throw new Error("bindAll must be passed function names");
      each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
      return obj;
    };

    // Memoize an expensive function by storing its results.
    _.memoize = function(func, hasher) {
      var memo = {};
      hasher || (hasher = _.identity);
      return function() {
        var key = hasher.apply(this, arguments);
        return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
      };
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = function(func, wait) {
      var args = slice.call(arguments, 2);
      return setTimeout(function(){ return func.apply(null, args); }, wait);
    };

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = function(func) {
      return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
    };

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    _.throttle = function(func, wait, options) {
      var context, args, result;
      var timeout = null;
      var previous = 0;
      options || (options = {});
      var later = function() {
        previous = options.leading === false ? 0 : new Date;
        timeout = null;
        result = func.apply(context, args);
      };
      return function() {
        var now = new Date;
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0) {
          clearTimeout(timeout);
          timeout = null;
          previous = now;
          result = func.apply(context, args);
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = function(func, wait, immediate) {
      var timeout, args, context, timestamp, result;
      return function() {
        context = this;
        args = arguments;
        timestamp = new Date();
        var later = function() {
          var last = (new Date()) - timestamp;
          if (last < wait) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) result = func.apply(context, args);
          }
        };
        var callNow = immediate && !timeout;
        if (!timeout) {
          timeout = setTimeout(later, wait);
        }
        if (callNow) result = func.apply(context, args);
        return result;
      };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = function(func) {
      var ran = false, memo;
      return function() {
        if (ran) return memo;
        ran = true;
        memo = func.apply(this, arguments);
        func = null;
        return memo;
      };
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = function(func, wrapper) {
      return function() {
        var args = [func];
        push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function() {
      var funcs = arguments;
      return function() {
        var args = arguments;
        for (var i = funcs.length - 1; i >= 0; i--) {
          args = [funcs[i].apply(this, args)];
        }
        return args[0];
      };
    };

    // Returns a function that will only be executed after being called N times.
    _.after = function(times, func) {
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    };

    // Object Functions
    // ----------------

    // Retrieve the names of an object's properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`
    _.keys = nativeKeys || function(obj) {
      if (obj !== Object(obj)) throw new TypeError('Invalid object');
      var keys = [];
      for (var key in obj) if (_.has(obj, key)) keys.push(key);
      return keys;
    };

    // Retrieve the values of an object's properties.
    _.values = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var values = new Array(length);
      for (var i = 0; i < length; i++) {
        values[i] = obj[keys[i]];
      }
      return values;
    };

    // Convert an object into a list of `[key, value]` pairs.
    _.pairs = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var pairs = new Array(length);
      for (var i = 0; i < length; i++) {
        pairs[i] = [keys[i], obj[keys[i]]];
      }
      return pairs;
    };

    // Invert the keys and values of an object. The values must be serializable.
    _.invert = function(obj) {
      var result = {};
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        result[obj[keys[i]]] = keys[i];
      }
      return result;
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`
    _.functions = _.methods = function(obj) {
      var names = [];
      for (var key in obj) {
        if (_.isFunction(obj[key])) names.push(key);
      }
      return names.sort();
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = function(obj) {
      each(slice.call(arguments, 1), function(source) {
        if (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      });
      return obj;
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = function(obj) {
      var copy = {};
      var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
      each(keys, function(key) {
        if (key in obj) copy[key] = obj[key];
      });
      return copy;
    };

     // Return a copy of the object without the blacklisted properties.
    _.omit = function(obj) {
      var copy = {};
      var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
      for (var key in obj) {
        if (!_.contains(keys, key)) copy[key] = obj[key];
      }
      return copy;
    };

    // Fill in a given object with default properties.
    _.defaults = function(obj) {
      each(slice.call(arguments, 1), function(source) {
        if (source) {
          for (var prop in source) {
            if (obj[prop] === void 0) obj[prop] = source[prop];
          }
        }
      });
      return obj;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = function(obj) {
      if (!_.isObject(obj)) return obj;
      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = function(obj, interceptor) {
      interceptor(obj);
      return obj;
    };

    // Internal recursive comparison function for `isEqual`.
    var eq = function(a, b, aStack, bStack) {
      // Identical objects are equal. `0 === -0`, but they aren't identical.
      // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
      if (a === b) return a !== 0 || 1 / a == 1 / b;
      // A strict comparison is necessary because `null == undefined`.
      if (a == null || b == null) return a === b;
      // Unwrap any wrapped objects.
      if (a instanceof _) a = a._wrapped;
      if (b instanceof _) b = b._wrapped;
      // Compare `[[Class]]` names.
      var className = toString.call(a);
      if (className != toString.call(b)) return false;
      switch (className) {
        // Strings, numbers, dates, and booleans are compared by value.
        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return a == String(b);
        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
          // other numeric values.
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') return false;
      // Assume equality for cyclic structures. The algorithm for detecting cyclic
      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
      var length = aStack.length;
      while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] == a) return bStack[length] == b;
      }
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Add the first object to the stack of traversed objects.
      aStack.push(a);
      bStack.push(b);
      var size = 0, result = true;
      // Recursively compare objects and arrays.
      if (className == '[object Array]') {
        // Compare array lengths to determine if a deep comparison is necessary.
        size = a.length;
        result = size == b.length;
        if (result) {
          // Deep compare the contents, ignoring non-numeric properties.
          while (size--) {
            if (!(result = eq(a[size], b[size], aStack, bStack))) break;
          }
        }
      } else {
        // Deep compare objects.
        for (var key in a) {
          if (_.has(a, key)) {
            // Count the expected number of properties.
            size++;
            // Deep compare each member.
            if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
          }
        }
        // Ensure that both objects contain the same number of properties.
        if (result) {
          for (key in b) {
            if (_.has(b, key) && !(size--)) break;
          }
          result = !size;
        }
      }
      // Remove the first object from the stack of traversed objects.
      aStack.pop();
      bStack.pop();
      return result;
    };

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = function(a, b) {
      return eq(a, b, [], []);
    };

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = function(obj) {
      if (obj == null) return true;
      if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
      for (var key in obj) if (_.has(obj, key)) return false;
      return true;
    };

    // Is a given value a DOM element?
    _.isElement = function(obj) {
      return !!(obj && obj.nodeType === 1);
    };

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || function(obj) {
      return toString.call(obj) == '[object Array]';
    };

    // Is a given variable an object?
    _.isObject = function(obj) {
      return obj === Object(obj);
    };

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
    each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
      _['is' + name] = function(obj) {
        return toString.call(obj) == '[object ' + name + ']';
      };
    });

    // Define a fallback version of the method in browsers (ahem, IE), where
    // there isn't any inspectable "Arguments" type.
    if (!_.isArguments(arguments)) {
      _.isArguments = function(obj) {
        return !!(obj && _.has(obj, 'callee'));
      };
    }

    // Optimize `isFunction` if appropriate.
    if (typeof (/./) !== 'function') {
      _.isFunction = function(obj) {
        return typeof obj === 'function';
      };
    }

    // Is a given object a finite number?
    _.isFinite = function(obj) {
      return isFinite(obj) && !isNaN(parseFloat(obj));
    };

    // Is the given value `NaN`? (NaN is the only number which does not equal itself).
    _.isNaN = function(obj) {
      return _.isNumber(obj) && obj != +obj;
    };

    // Is a given value a boolean?
    _.isBoolean = function(obj) {
      return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
    };

    // Is a given value equal to null?
    _.isNull = function(obj) {
      return obj === null;
    };

    // Is a given variable undefined?
    _.isUndefined = function(obj) {
      return obj === void 0;
    };

    // Shortcut function for checking if an object has a given property directly
    // on itself (in other words, not on a prototype).
    _.has = function(obj, key) {
      return hasOwnProperty.call(obj, key);
    };

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function() {
      root._ = previousUnderscore;
      return this;
    };

    // Keep the identity function around for default iterators.
    _.identity = function(value) {
      return value;
    };

    // Run a function **n** times.
    _.times = function(n, iterator, context) {
      var accum = Array(Math.max(0, n));
      for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
      return accum;
    };

    // Return a random integer between min and max (inclusive).
    _.random = function(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    };

    // List of HTML entities for escaping.
    var entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      }
    };
    entityMap.unescape = _.invert(entityMap.escape);

    // Regexes containing the keys and values listed immediately above.
    var entityRegexes = {
      escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
      unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
    };

    // Functions for escaping and unescaping strings to/from HTML interpolation.
    _.each(['escape', 'unescape'], function(method) {
      _[method] = function(string) {
        if (string == null) return '';
        return ('' + string).replace(entityRegexes[method], function(match) {
          return entityMap[method][match];
        });
      };
    });

    // If the value of the named `property` is a function then invoke it with the
    // `object` as context; otherwise, return it.
    _.result = function(object, property) {
      if (object == null) return void 0;
      var value = object[property];
      return _.isFunction(value) ? value.call(object) : value;
    };

    // Add your own custom functions to the Underscore object.
    _.mixin = function(obj) {
      each(_.functions(obj), function(name) {
        var func = _[name] = obj[name];
        _.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return result.call(this, func.apply(_, args));
        };
      });
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = function(prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
      evaluate    : /<%([\s\S]+?)%>/g,
      interpolate : /<%=([\s\S]+?)%>/g,
      escape      : /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'":      "'",
      '\\':     '\\',
      '\r':     'r',
      '\n':     'n',
      '\t':     't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    _.template = function(text, data, settings) {
      var render;
      settings = _.defaults({}, settings, _.templateSettings);

      // Combine delimiters into one regular expression via alternation.
      var matcher = new RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');

      // Compile the template source, escaping string literals appropriately.
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset)
          .replace(escaper, function(match) { return '\\' + escapes[match]; });

        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        }
        if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        }
        if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }
        index = offset + match.length;
        return match;
      });
      source += "';\n";

      // If a variable is not specified, place data values in local scope.
      if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

      source = "var __t,__p='',__j=Array.prototype.join," +
        "print=function(){__p+=__j.call(arguments,'');};\n" +
        source + "return __p;\n";

      try {
        render = new Function(settings.variable || 'obj', '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }

      if (data) return render(data, _);
      var template = function(data) {
        return render.call(this, data, _);
      };

      // Provide the compiled function source as a convenience for precompilation.
      template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

      return template;
    };

    // Add a "chain" function, which will delegate to the wrapper.
    _.chain = function(obj) {
      return _(obj).chain();
    };

    // OOP
    // ---------------
    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.

    // Helper function to continue chaining intermediate results.
    var result = function(obj) {
      return this._chain ? _(obj).chain() : obj;
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        method.apply(obj, arguments);
        if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
        return result.call(this, obj);
      };
    });

    // Add all accessor Array functions to the wrapper.
    each(['concat', 'join', 'slice'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        return result.call(this, method.apply(this._wrapped, arguments));
      };
    });

    _.extend(_.prototype, {

      // Start chaining a wrapped Underscore object.
      chain: function() {
        this._chain = true;
        return this;
      },

      // Extracts the result from a wrapped and chained object.
      value: function() {
        return this._wrapped;
      }

    });

  }).call(this);

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:underscore', location = 'libs/underscore.js' */
define("jira/components/libs/underscore", [
    "atlassian/libs/underscore-1.5.2"
], function(
    _
) {
    "use strict";

    return _;
});
;
;
/* module-key = 'com.atlassian.plugin.jslibs:backbone-1.0.0-factory', location = 'factories/backbone/1.0.0/backbone-1.0.0-factory.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
  define('atlassian/libs/factories/backbone-1.0.0', function() {
    return function(_, $) {
      var env = {
        _: _,
        $: $
      };
      factory.call(env);
      return env.Backbone.noConflict();
    }
  });
})(function(){
/////// End of Atlassian modification ///////

  //     Backbone.js 1.0.0

  //     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.
  //     Backbone may be freely distributed under the MIT license.
  //     For all details and documentation:
  //     http://backbonejs.org

  (function(){

    // Initial Setup
    // -------------

    // Save a reference to the global object (`window` in the browser, `exports`
    // on the server).
    var root = this;

    // Save the previous value of the `Backbone` variable, so that it can be
    // restored later on, if `noConflict` is used.
    var previousBackbone = root.Backbone;

    // Create local references to array methods we'll want to use later.
    var array = [];
    var push = array.push;
    var slice = array.slice;
    var splice = array.splice;

    // The top-level namespace. All public Backbone classes and modules will
    // be attached to this. Exported for both the browser and the server.
    var Backbone;
    if (typeof exports !== 'undefined') {
      Backbone = exports;
    } else {
      Backbone = root.Backbone = {};
    }

    // Current version of the library. Keep in sync with `package.json`.
    Backbone.VERSION = '1.0.0';

    // Require Underscore, if we're on the server, and it's not already present.
    var _ = root._;
    if (!_ && (typeof require !== 'undefined')) _ = require('underscore');

    // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
    // the `$` variable.
    Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;

    // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
    // to its previous owner. Returns a reference to this Backbone object.
    Backbone.noConflict = function() {
      root.Backbone = previousBackbone;
      return this;
    };

    // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
    // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
    // set a `X-Http-Method-Override` header.
    Backbone.emulateHTTP = false;

    // Turn on `emulateJSON` to support legacy servers that can't deal with direct
    // `application/json` requests ... will encode the body as
    // `application/x-www-form-urlencoded` instead and will send the model in a
    // form param named `model`.
    Backbone.emulateJSON = false;

    // Backbone.Events
    // ---------------

    // A module that can be mixed in to *any object* in order to provide it with
    // custom events. You may bind with `on` or remove with `off` callback
    // functions to an event; `trigger`-ing an event fires all callbacks in
    // succession.
    //
    //     var object = {};
    //     _.extend(object, Backbone.Events);
    //     object.on('expand', function(){ alert('expanded'); });
    //     object.trigger('expand');
    //
    var Events = Backbone.Events = {

      // Bind an event to a `callback` function. Passing `"all"` will bind
      // the callback to all events fired.
      on: function(name, callback, context) {
        if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
        this._events || (this._events = {});
        var events = this._events[name] || (this._events[name] = []);
        events.push({callback: callback, context: context, ctx: context || this});
        return this;
      },

      // Bind an event to only be triggered a single time. After the first time
      // the callback is invoked, it will be removed.
      once: function(name, callback, context) {
        if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
        var self = this;
        var once = _.once(function() {
          self.off(name, once);
          callback.apply(this, arguments);
        });
        once._callback = callback;
        return this.on(name, once, context);
      },

      // Remove one or many callbacks. If `context` is null, removes all
      // callbacks with that function. If `callback` is null, removes all
      // callbacks for the event. If `name` is null, removes all bound
      // callbacks for all events.
      off: function(name, callback, context) {
        var retain, ev, events, names, i, l, j, k;
        if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
        if (!name && !callback && !context) {
          this._events = {};
          return this;
        }

        names = name ? [name] : _.keys(this._events);
        for (i = 0, l = names.length; i < l; i++) {
          name = names[i];
          if (events = this._events[name]) {
            this._events[name] = retain = [];
            if (callback || context) {
              for (j = 0, k = events.length; j < k; j++) {
                ev = events[j];
                if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                    (context && context !== ev.context)) {
                  retain.push(ev);
                }
              }
            }
            if (!retain.length) delete this._events[name];
          }
        }

        return this;
      },

      // Trigger one or many events, firing all bound callbacks. Callbacks are
      // passed the same arguments as `trigger` is, apart from the event name
      // (unless you're listening on `"all"`, which will cause your callback to
      // receive the true name of the event as the first argument).
      trigger: function(name) {
        if (!this._events) return this;
        var args = slice.call(arguments, 1);
        if (!eventsApi(this, 'trigger', name, args)) return this;
        var events = this._events[name];
        var allEvents = this._events.all;
        if (events) triggerEvents(events, args);
        if (allEvents) triggerEvents(allEvents, arguments);
        return this;
      },

      // Tell this object to stop listening to either specific events ... or
      // to every object it's currently listening to.
      stopListening: function(obj, name, callback) {
        var listeners = this._listeners;
        if (!listeners) return this;
        var deleteListener = !name && !callback;
        if (typeof name === 'object') callback = this;
        if (obj) (listeners = {})[obj._listenerId] = obj;
        for (var id in listeners) {
          listeners[id].off(name, callback, this);
          if (deleteListener) delete this._listeners[id];
        }
        return this;
      }

    };

    // Regular expression used to split event strings.
    var eventSplitter = /\s+/;

    // Implement fancy features of the Events API such as multiple event
    // names `"change blur"` and jQuery-style event maps `{change: action}`
    // in terms of the existing API.
    var eventsApi = function(obj, action, name, rest) {
      if (!name) return true;

      // Handle event maps.
      if (typeof name === 'object') {
        for (var key in name) {
          obj[action].apply(obj, [key, name[key]].concat(rest));
        }
        return false;
      }

      // Handle space separated event names.
      if (eventSplitter.test(name)) {
        var names = name.split(eventSplitter);
        for (var i = 0, l = names.length; i < l; i++) {
          obj[action].apply(obj, [names[i]].concat(rest));
        }
        return false;
      }

      return true;
    };

    // A difficult-to-believe, but optimized internal dispatch function for
    // triggering events. Tries to keep the usual cases speedy (most internal
    // Backbone events have 3 arguments).
    var triggerEvents = function(events, args) {
      var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
      switch (args.length) {
        case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
        case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
        case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
        case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
        default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
      }
    };

    var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

    // Inversion-of-control versions of `on` and `once`. Tell *this* object to
    // listen to an event in another object ... keeping track of what it's
    // listening to.
    _.each(listenMethods, function(implementation, method) {
      Events[method] = function(obj, name, callback) {
        var listeners = this._listeners || (this._listeners = {});
        var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
        listeners[id] = obj;
        if (typeof name === 'object') callback = this;
        obj[implementation](name, callback, this);
        return this;
      };
    });

    // Aliases for backwards compatibility.
    Events.bind   = Events.on;
    Events.unbind = Events.off;

    // Allow the `Backbone` object to serve as a global event bus, for folks who
    // want global "pubsub" in a convenient place.
    _.extend(Backbone, Events);

    // Backbone.Model
    // --------------

    // Backbone **Models** are the basic data object in the framework --
    // frequently representing a row in a table in a database on your server.
    // A discrete chunk of data and a bunch of useful, related methods for
    // performing computations and transformations on that data.

    // Create a new model with the specified attributes. A client id (`cid`)
    // is automatically generated and assigned for you.
    var Model = Backbone.Model = function(attributes, options) {
      var defaults;
      var attrs = attributes || {};
      options || (options = {});
      this.cid = _.uniqueId('c');
      this.attributes = {};
      _.extend(this, _.pick(options, modelOptions));
      if (options.parse) attrs = this.parse(attrs, options) || {};
      if (defaults = _.result(this, 'defaults')) {
        attrs = _.defaults({}, attrs, defaults);
      }
      this.set(attrs, options);
      this.changed = {};
      this.initialize.apply(this, arguments);
    };

    // A list of options to be attached directly to the model, if provided.
    var modelOptions = ['url', 'urlRoot', 'collection'];

    // Attach all inheritable methods to the Model prototype.
    _.extend(Model.prototype, Events, {

      // A hash of attributes whose current and previous value differ.
      changed: null,

      // The value returned during the last failed validation.
      validationError: null,

      // The default name for the JSON `id` attribute is `"id"`. MongoDB and
      // CouchDB users may want to set this to `"_id"`.
      idAttribute: 'id',

      // Initialize is an empty function by default. Override it with your own
      // initialization logic.
      initialize: function(){},

      // Return a copy of the model's `attributes` object.
      toJSON: function(options) {
        return _.clone(this.attributes);
      },

      // Proxy `Backbone.sync` by default -- but override this if you need
      // custom syncing semantics for *this* particular model.
      sync: function() {
        return Backbone.sync.apply(this, arguments);
      },

      // Get the value of an attribute.
      get: function(attr) {
        return this.attributes[attr];
      },

      // Get the HTML-escaped value of an attribute.
      escape: function(attr) {
        return _.escape(this.get(attr));
      },

      // Returns `true` if the attribute contains a value that is not null
      // or undefined.
      has: function(attr) {
        return this.get(attr) != null;
      },

      // Set a hash of model attributes on the object, firing `"change"`. This is
      // the core primitive operation of a model, updating the data and notifying
      // anyone who needs to know about the change in state. The heart of the beast.
      set: function(key, val, options) {
        var attr, attrs, unset, changes, silent, changing, prev, current;
        if (key == null) return this;

        // Handle both `"key", value` and `{key: value}` -style arguments.
        if (typeof key === 'object') {
          attrs = key;
          options = val;
        } else {
          (attrs = {})[key] = val;
        }

        options || (options = {});

        // Run validation.
        if (!this._validate(attrs, options)) return false;

        // Extract attributes and options.
        unset           = options.unset;
        silent          = options.silent;
        changes         = [];
        changing        = this._changing;
        this._changing  = true;

        if (!changing) {
          this._previousAttributes = _.clone(this.attributes);
          this.changed = {};
        }
        current = this.attributes, prev = this._previousAttributes;

        // Check for changes of `id`.
        if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

        // For each `set` attribute, update or delete the current value.
        for (attr in attrs) {
          val = attrs[attr];
          if (!_.isEqual(current[attr], val)) changes.push(attr);
          if (!_.isEqual(prev[attr], val)) {
            this.changed[attr] = val;
          } else {
            delete this.changed[attr];
          }
          unset ? delete current[attr] : current[attr] = val;
        }

        // Trigger all relevant attribute changes.
        if (!silent) {
          if (changes.length) this._pending = true;
          for (var i = 0, l = changes.length; i < l; i++) {
            this.trigger('change:' + changes[i], this, current[changes[i]], options);
          }
        }

        // You might be wondering why there's a `while` loop here. Changes can
        // be recursively nested within `"change"` events.
        if (changing) return this;
        if (!silent) {
          while (this._pending) {
            this._pending = false;
            this.trigger('change', this, options);
          }
        }
        this._pending = false;
        this._changing = false;
        return this;
      },

      // Remove an attribute from the model, firing `"change"`. `unset` is a noop
      // if the attribute doesn't exist.
      unset: function(attr, options) {
        return this.set(attr, void 0, _.extend({}, options, {unset: true}));
      },

      // Clear all attributes on the model, firing `"change"`.
      clear: function(options) {
        var attrs = {};
        for (var key in this.attributes) attrs[key] = void 0;
        return this.set(attrs, _.extend({}, options, {unset: true}));
      },

      // Determine if the model has changed since the last `"change"` event.
      // If you specify an attribute name, determine if that attribute has changed.
      hasChanged: function(attr) {
        if (attr == null) return !_.isEmpty(this.changed);
        return _.has(this.changed, attr);
      },

      // Return an object containing all the attributes that have changed, or
      // false if there are no changed attributes. Useful for determining what
      // parts of a view need to be updated and/or what attributes need to be
      // persisted to the server. Unset attributes will be set to undefined.
      // You can also pass an attributes object to diff against the model,
      // determining if there *would be* a change.
      changedAttributes: function(diff) {
        if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
        var val, changed = false;
        var old = this._changing ? this._previousAttributes : this.attributes;
        for (var attr in diff) {
          if (_.isEqual(old[attr], (val = diff[attr]))) continue;
          (changed || (changed = {}))[attr] = val;
        }
        return changed;
      },

      // Get the previous value of an attribute, recorded at the time the last
      // `"change"` event was fired.
      previous: function(attr) {
        if (attr == null || !this._previousAttributes) return null;
        return this._previousAttributes[attr];
      },

      // Get all of the attributes of the model at the time of the previous
      // `"change"` event.
      previousAttributes: function() {
        return _.clone(this._previousAttributes);
      },

      // Fetch the model from the server. If the server's representation of the
      // model differs from its current attributes, they will be overridden,
      // triggering a `"change"` event.
      fetch: function(options) {
        options = options ? _.clone(options) : {};
        if (options.parse === void 0) options.parse = true;
        var model = this;
        var success = options.success;
        options.success = function(resp) {
          if (!model.set(model.parse(resp, options), options)) return false;
          if (success) success(model, resp, options);
          model.trigger('sync', model, resp, options);
        };
        wrapError(this, options);
        return this.sync('read', this, options);
      },

      // Set a hash of model attributes, and sync the model to the server.
      // If the server returns an attributes hash that differs, the model's
      // state will be `set` again.
      save: function(key, val, options) {
        var attrs, method, xhr, attributes = this.attributes;

        // Handle both `"key", value` and `{key: value}` -style arguments.
        if (key == null || typeof key === 'object') {
          attrs = key;
          options = val;
        } else {
          (attrs = {})[key] = val;
        }

        // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
        if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;

        options = _.extend({validate: true}, options);

        // Do not persist invalid models.
        if (!this._validate(attrs, options)) return false;

        // Set temporary attributes if `{wait: true}`.
        if (attrs && options.wait) {
          this.attributes = _.extend({}, attributes, attrs);
        }

        // After a successful server-side save, the client is (optionally)
        // updated with the server-side state.
        if (options.parse === void 0) options.parse = true;
        var model = this;
        var success = options.success;
        options.success = function(resp) {
          // Ensure attributes are restored during synchronous saves.
          model.attributes = attributes;
          var serverAttrs = model.parse(resp, options);
          if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
          if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
            return false;
          }
          if (success) success(model, resp, options);
          model.trigger('sync', model, resp, options);
        };
        wrapError(this, options);

        method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
        if (method === 'patch') options.attrs = attrs;
        xhr = this.sync(method, this, options);

        // Restore attributes.
        if (attrs && options.wait) this.attributes = attributes;

        return xhr;
      },

      // Destroy this model on the server if it was already persisted.
      // Optimistically removes the model from its collection, if it has one.
      // If `wait: true` is passed, waits for the server to respond before removal.
      destroy: function(options) {
        options = options ? _.clone(options) : {};
        var model = this;
        var success = options.success;

        var destroy = function() {
          model.trigger('destroy', model, model.collection, options);
        };

        options.success = function(resp) {
          if (options.wait || model.isNew()) destroy();
          if (success) success(model, resp, options);
          if (!model.isNew()) model.trigger('sync', model, resp, options);
        };

        if (this.isNew()) {
          options.success();
          return false;
        }
        wrapError(this, options);

        var xhr = this.sync('delete', this, options);
        if (!options.wait) destroy();
        return xhr;
      },

      // Default URL for the model's representation on the server -- if you're
      // using Backbone's restful methods, override this to change the endpoint
      // that will be called.
      url: function() {
        var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
        if (this.isNew()) return base;
        return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
      },

      // **parse** converts a response into the hash of attributes to be `set` on
      // the model. The default implementation is just to pass the response along.
      parse: function(resp, options) {
        return resp;
      },

      // Create a new model with identical attributes to this one.
      clone: function() {
        return new this.constructor(this.attributes);
      },

      // A model is new if it has never been saved to the server, and lacks an id.
      isNew: function() {
        return this.id == null;
      },

      // Check if the model is currently in a valid state.
      isValid: function(options) {
        return this._validate({}, _.extend(options || {}, { validate: true }));
      },

      // Run validation against the next complete set of model attributes,
      // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
      _validate: function(attrs, options) {
        if (!options.validate || !this.validate) return true;
        attrs = _.extend({}, this.attributes, attrs);
        var error = this.validationError = this.validate(attrs, options) || null;
        if (!error) return true;
        this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));
        return false;
      }

    });

    // Underscore methods that we want to implement on the Model.
    var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

    // Mix in each Underscore method as a proxy to `Model#attributes`.
    _.each(modelMethods, function(method) {
      Model.prototype[method] = function() {
        var args = slice.call(arguments);
        args.unshift(this.attributes);
        return _[method].apply(_, args);
      };
    });

    // Backbone.Collection
    // -------------------

    // If models tend to represent a single row of data, a Backbone Collection is
    // more analagous to a table full of data ... or a small slice or page of that
    // table, or a collection of rows that belong together for a particular reason
    // -- all of the messages in this particular folder, all of the documents
    // belonging to this particular author, and so on. Collections maintain
    // indexes of their models, both in order, and for lookup by `id`.

    // Create a new **Collection**, perhaps to contain a specific type of `model`.
    // If a `comparator` is specified, the Collection will maintain
    // its models in sort order, as they're added and removed.
    var Collection = Backbone.Collection = function(models, options) {
      options || (options = {});
      if (options.url) this.url = options.url;
      if (options.model) this.model = options.model;
      if (options.comparator !== void 0) this.comparator = options.comparator;
      this._reset();
      this.initialize.apply(this, arguments);
      if (models) this.reset(models, _.extend({silent: true}, options));
    };

    // Default options for `Collection#set`.
    var setOptions = {add: true, remove: true, merge: true};
    var addOptions = {add: true, merge: false, remove: false};

    // Define the Collection's inheritable methods.
    _.extend(Collection.prototype, Events, {

      // The default model for a collection is just a **Backbone.Model**.
      // This should be overridden in most cases.
      model: Model,

      // Initialize is an empty function by default. Override it with your own
      // initialization logic.
      initialize: function(){},

      // The JSON representation of a Collection is an array of the
      // models' attributes.
      toJSON: function(options) {
        return this.map(function(model){ return model.toJSON(options); });
      },

      // Proxy `Backbone.sync` by default.
      sync: function() {
        return Backbone.sync.apply(this, arguments);
      },

      // Add a model, or list of models to the set.
      add: function(models, options) {
        return this.set(models, _.defaults(options || {}, addOptions));
      },

      // Remove a model, or a list of models from the set.
      remove: function(models, options) {
        models = _.isArray(models) ? models.slice() : [models];
        options || (options = {});
        var i, l, index, model;
        for (i = 0, l = models.length; i < l; i++) {
          model = this.get(models[i]);
          if (!model) continue;
          delete this._byId[model.id];
          delete this._byId[model.cid];
          index = this.indexOf(model);
          this.models.splice(index, 1);
          this.length--;
          if (!options.silent) {
            options.index = index;
            model.trigger('remove', model, this, options);
          }
          this._removeReference(model);
        }
        return this;
      },

      // Update a collection by `set`-ing a new list of models, adding new ones,
      // removing models that are no longer present, and merging models that
      // already exist in the collection, as necessary. Similar to **Model#set**,
      // the core operation for updating the data contained by the collection.
      set: function(models, options) {
        options = _.defaults(options || {}, setOptions);
        if (options.parse) models = this.parse(models, options);
        if (!_.isArray(models)) models = models ? [models] : [];
        var i, l, model, attrs, existing, sort;
        var at = options.at;
        var sortable = this.comparator && (at == null) && options.sort !== false;
        var sortAttr = _.isString(this.comparator) ? this.comparator : null;
        var toAdd = [], toRemove = [], modelMap = {};

        // Turn bare objects into model references, and prevent invalid models
        // from being added.
        for (i = 0, l = models.length; i < l; i++) {
          if (!(model = this._prepareModel(models[i], options))) continue;

          // If a duplicate is found, prevent it from being added and
          // optionally merge it into the existing model.
          if (existing = this.get(model)) {
            if (options.remove) modelMap[existing.cid] = true;
            if (options.merge) {
              existing.set(model.attributes, options);
              if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
            }

            // This is a new model, push it to the `toAdd` list.
          } else if (options.add) {
            toAdd.push(model);

            // Listen to added models' events, and index models for lookup by
            // `id` and by `cid`.
            model.on('all', this._onModelEvent, this);
            this._byId[model.cid] = model;
            if (model.id != null) this._byId[model.id] = model;
          }
        }

        // Remove nonexistent models if appropriate.
        if (options.remove) {
          for (i = 0, l = this.length; i < l; ++i) {
            if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
          }
          if (toRemove.length) this.remove(toRemove, options);
        }

        // See if sorting is needed, update `length` and splice in new models.
        if (toAdd.length) {
          if (sortable) sort = true;
          this.length += toAdd.length;
          if (at != null) {
            splice.apply(this.models, [at, 0].concat(toAdd));
          } else {
            push.apply(this.models, toAdd);
          }
        }

        // Silently sort the collection if appropriate.
        if (sort) this.sort({silent: true});

        if (options.silent) return this;

        // Trigger `add` events.
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }

        // Trigger `sort` if the collection was sorted.
        if (sort) this.trigger('sort', this, options);
        return this;
      },

      // When you have more items than you want to add or remove individually,
      // you can reset the entire set with a new list of models, without firing
      // any granular `add` or `remove` events. Fires `reset` when finished.
      // Useful for bulk operations and optimizations.
      reset: function(models, options) {
        options || (options = {});
        for (var i = 0, l = this.models.length; i < l; i++) {
          this._removeReference(this.models[i]);
        }
        options.previousModels = this.models;
        this._reset();
        this.add(models, _.extend({silent: true}, options));
        if (!options.silent) this.trigger('reset', this, options);
        return this;
      },

      // Add a model to the end of the collection.
      push: function(model, options) {
        model = this._prepareModel(model, options);
        this.add(model, _.extend({at: this.length}, options));
        return model;
      },

      // Remove a model from the end of the collection.
      pop: function(options) {
        var model = this.at(this.length - 1);
        this.remove(model, options);
        return model;
      },

      // Add a model to the beginning of the collection.
      unshift: function(model, options) {
        model = this._prepareModel(model, options);
        this.add(model, _.extend({at: 0}, options));
        return model;
      },

      // Remove a model from the beginning of the collection.
      shift: function(options) {
        var model = this.at(0);
        this.remove(model, options);
        return model;
      },

      // Slice out a sub-array of models from the collection.
      slice: function(begin, end) {
        return this.models.slice(begin, end);
      },

      // Get a model from the set by id.
      get: function(obj) {
        if (obj == null) return void 0;
        return this._byId[obj.id != null ? obj.id : obj.cid || obj];
      },

      // Get the model at the given index.
      at: function(index) {
        return this.models[index];
      },

      // Return models with matching attributes. Useful for simple cases of
      // `filter`.
      where: function(attrs, first) {
        if (_.isEmpty(attrs)) return first ? void 0 : [];
        return this[first ? 'find' : 'filter'](function(model) {
          for (var key in attrs) {
            if (attrs[key] !== model.get(key)) return false;
          }
          return true;
        });
      },

      // Return the first model with matching attributes. Useful for simple cases
      // of `find`.
      findWhere: function(attrs) {
        return this.where(attrs, true);
      },

      // Force the collection to re-sort itself. You don't need to call this under
      // normal circumstances, as the set will maintain sort order as each item
      // is added.
      sort: function(options) {
        if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
        options || (options = {});

        // Run sort based on type of `comparator`.
        if (_.isString(this.comparator) || this.comparator.length === 1) {
          this.models = this.sortBy(this.comparator, this);
        } else {
          this.models.sort(_.bind(this.comparator, this));
        }

        if (!options.silent) this.trigger('sort', this, options);
        return this;
      },

      // Figure out the smallest index at which a model should be inserted so as
      // to maintain order.
      sortedIndex: function(model, value, context) {
        value || (value = this.comparator);
        var iterator = _.isFunction(value) ? value : function(model) {
          return model.get(value);
        };
        return _.sortedIndex(this.models, model, iterator, context);
      },

      // Pluck an attribute from each model in the collection.
      pluck: function(attr) {
        return _.invoke(this.models, 'get', attr);
      },

      // Fetch the default set of models for this collection, resetting the
      // collection when they arrive. If `reset: true` is passed, the response
      // data will be passed through the `reset` method instead of `set`.
      fetch: function(options) {
        options = options ? _.clone(options) : {};
        if (options.parse === void 0) options.parse = true;
        var success = options.success;
        var collection = this;
        options.success = function(resp) {
          var method = options.reset ? 'reset' : 'set';
          collection[method](resp, options);
          if (success) success(collection, resp, options);
          collection.trigger('sync', collection, resp, options);
        };
        wrapError(this, options);
        return this.sync('read', this, options);
      },

      // Create a new instance of a model in this collection. Add the model to the
      // collection immediately, unless `wait: true` is passed, in which case we
      // wait for the server to agree.
      create: function(model, options) {
        options = options ? _.clone(options) : {};
        if (!(model = this._prepareModel(model, options))) return false;
        if (!options.wait) this.add(model, options);
        var collection = this;
        var success = options.success;
        options.success = function(resp) {
          if (options.wait) collection.add(model, options);
          if (success) success(model, resp, options);
        };
        model.save(null, options);
        return model;
      },

      // **parse** converts a response into a list of models to be added to the
      // collection. The default implementation is just to pass it through.
      parse: function(resp, options) {
        return resp;
      },

      // Create a new collection with an identical list of models as this one.
      clone: function() {
        return new this.constructor(this.models);
      },

      // Private method to reset all internal state. Called when the collection
      // is first initialized or reset.
      _reset: function() {
        this.length = 0;
        this.models = [];
        this._byId  = {};
      },

      // Prepare a hash of attributes (or other model) to be added to this
      // collection.
      _prepareModel: function(attrs, options) {
        if (attrs instanceof Model) {
          if (!attrs.collection) attrs.collection = this;
          return attrs;
        }
        options || (options = {});
        options.collection = this;
        var model = new this.model(attrs, options);
        if (!model._validate(attrs, options)) {
          this.trigger('invalid', this, attrs, options);
          return false;
        }
        return model;
      },

      // Internal method to sever a model's ties to a collection.
      _removeReference: function(model) {
        if (this === model.collection) delete model.collection;
        model.off('all', this._onModelEvent, this);
      },

      // Internal method called every time a model in the set fires an event.
      // Sets need to update their indexes when models change ids. All other
      // events simply proxy through. "add" and "remove" events that originate
      // in other collections are ignored.
      _onModelEvent: function(event, model, collection, options) {
        if ((event === 'add' || event === 'remove') && collection !== this) return;
        if (event === 'destroy') this.remove(model, options);
        if (model && event === 'change:' + model.idAttribute) {
          delete this._byId[model.previous(model.idAttribute)];
          if (model.id != null) this._byId[model.id] = model;
        }
        this.trigger.apply(this, arguments);
      }

    });

    // Underscore methods that we want to implement on the Collection.
    // 90% of the core usefulness of Backbone Collections is actually implemented
    // right here:
    var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
      'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
      'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
      'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
      'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf',
      'isEmpty', 'chain'];

    // Mix in each Underscore method as a proxy to `Collection#models`.
    _.each(methods, function(method) {
      Collection.prototype[method] = function() {
        var args = slice.call(arguments);
        args.unshift(this.models);
        return _[method].apply(_, args);
      };
    });

    // Underscore methods that take a property name as an argument.
    var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

    // Use attributes instead of properties.
    _.each(attributeMethods, function(method) {
      Collection.prototype[method] = function(value, context) {
        var iterator = _.isFunction(value) ? value : function(model) {
          return model.get(value);
        };
        return _[method](this.models, iterator, context);
      };
    });

    // Backbone.View
    // -------------

    // Backbone Views are almost more convention than they are actual code. A View
    // is simply a JavaScript object that represents a logical chunk of UI in the
    // DOM. This might be a single item, an entire list, a sidebar or panel, or
    // even the surrounding frame which wraps your whole app. Defining a chunk of
    // UI as a **View** allows you to define your DOM events declaratively, without
    // having to worry about render order ... and makes it easy for the view to
    // react to specific changes in the state of your models.

    // Creating a Backbone.View creates its initial element outside of the DOM,
    // if an existing element is not provided...
    var View = Backbone.View = function(options) {
      this.cid = _.uniqueId('view');
      this._configure(options || {});
      this._ensureElement();
      this.initialize.apply(this, arguments);
      this.delegateEvents();
    };

    // Cached regex to split keys for `delegate`.
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;

    // List of view options to be merged as properties.
    var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

    // Set up all inheritable **Backbone.View** properties and methods.
    _.extend(View.prototype, Events, {

      // The default `tagName` of a View's element is `"div"`.
      tagName: 'div',

      // jQuery delegate for element lookup, scoped to DOM elements within the
      // current view. This should be prefered to global lookups where possible.
      $: function(selector) {
        return this.$el.find(selector);
      },

      // Initialize is an empty function by default. Override it with your own
      // initialization logic.
      initialize: function(){},

      // **render** is the core function that your view should override, in order
      // to populate its element (`this.el`), with the appropriate HTML. The
      // convention is for **render** to always return `this`.
      render: function() {
        return this;
      },

      // Remove this view by taking the element out of the DOM, and removing any
      // applicable Backbone.Events listeners.
      remove: function() {
        this.$el.remove();
        this.stopListening();
        return this;
      },

      // Change the view's element (`this.el` property), including event
      // re-delegation.
      setElement: function(element, delegate) {
        if (this.$el) this.undelegateEvents();
        this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
        this.el = this.$el[0];
        if (delegate !== false) this.delegateEvents();
        return this;
      },

      // Set callbacks, where `this.events` is a hash of
      //
      // *{"event selector": "callback"}*
      //
      //     {
      //       'mousedown .title':  'edit',
      //       'click .button':     'save'
      //       'click .open':       function(e) { ... }
      //     }
      //
      // pairs. Callbacks will be bound to the view, with `this` set properly.
      // Uses event delegation for efficiency.
      // Omitting the selector binds the event to `this.el`.
      // This only works for delegate-able events: not `focus`, `blur`, and
      // not `change`, `submit`, and `reset` in Internet Explorer.
      delegateEvents: function(events) {
        if (!(events || (events = _.result(this, 'events')))) return this;
        this.undelegateEvents();
        for (var key in events) {
          var method = events[key];
          if (!_.isFunction(method)) method = this[events[key]];
          if (!method) continue;

          var match = key.match(delegateEventSplitter);
          var eventName = match[1], selector = match[2];
          method = _.bind(method, this);
          eventName += '.delegateEvents' + this.cid;
          if (selector === '') {
            this.$el.on(eventName, method);
          } else {
            this.$el.on(eventName, selector, method);
          }
        }
        return this;
      },

      // Clears all callbacks previously bound to the view with `delegateEvents`.
      // You usually don't need to use this, but may wish to if you have multiple
      // Backbone views attached to the same DOM element.
      undelegateEvents: function() {
        this.$el.off('.delegateEvents' + this.cid);
        return this;
      },

      // Performs the initial configuration of a View with a set of options.
      // Keys with special meaning *(e.g. model, collection, id, className)* are
      // attached directly to the view.  See `viewOptions` for an exhaustive
      // list.
      _configure: function(options) {
        if (this.options) options = _.extend({}, _.result(this, 'options'), options);
        _.extend(this, _.pick(options, viewOptions));
        this.options = options;
      },

      // Ensure that the View has a DOM element to render into.
      // If `this.el` is a string, pass it through `$()`, take the first
      // matching element, and re-assign it to `el`. Otherwise, create
      // an element from the `id`, `className` and `tagName` properties.
      _ensureElement: function() {
        if (!this.el) {
          var attrs = _.extend({}, _.result(this, 'attributes'));
          if (this.id) attrs.id = _.result(this, 'id');
          if (this.className) attrs['class'] = _.result(this, 'className');
          var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
          this.setElement($el, false);
        } else {
          this.setElement(_.result(this, 'el'), false);
        }
      }

    });

    // Backbone.sync
    // -------------

    // Override this function to change the manner in which Backbone persists
    // models to the server. You will be passed the type of request, and the
    // model in question. By default, makes a RESTful Ajax request
    // to the model's `url()`. Some possible customizations could be:
    //
    // * Use `setTimeout` to batch rapid-fire updates into a single request.
    // * Send up the models as XML instead of JSON.
    // * Persist models via WebSockets instead of Ajax.
    //
    // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
    // as `POST`, with a `_method` parameter containing the true HTTP method,
    // as well as all requests with the body as `application/x-www-form-urlencoded`
    // instead of `application/json` with the model in a param named `model`.
    // Useful when interfacing with server-side languages like **PHP** that make
    // it difficult to read the body of `PUT` requests.
    Backbone.sync = function(method, model, options) {
      var type = methodMap[method];

      // Default options, unless specified.
      _.defaults(options || (options = {}), {
        emulateHTTP: Backbone.emulateHTTP,
        emulateJSON: Backbone.emulateJSON
      });

      // Default JSON-request options.
      var params = {type: type, dataType: 'json'};

      // Ensure that we have a URL.
      if (!options.url) {
        params.url = _.result(model, 'url') || urlError();
      }

      // Ensure that we have the appropriate request data.
      if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
        params.contentType = 'application/json';
        params.data = JSON.stringify(options.attrs || model.toJSON(options));
      }

      // For older servers, emulate JSON by encoding the request into an HTML-form.
      if (options.emulateJSON) {
        params.contentType = 'application/x-www-form-urlencoded';
        params.data = params.data ? {model: params.data} : {};
      }

      // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
      // And an `X-HTTP-Method-Override` header.
      if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
        params.type = 'POST';
        if (options.emulateJSON) params.data._method = type;
        var beforeSend = options.beforeSend;
        options.beforeSend = function(xhr) {
          xhr.setRequestHeader('X-HTTP-Method-Override', type);
          if (beforeSend) return beforeSend.apply(this, arguments);
        };
      }

      // Don't process data on a non-GET request.
      if (params.type !== 'GET' && !options.emulateJSON) {
        params.processData = false;
      }

      // If we're sending a `PATCH` request, and we're in an old Internet Explorer
      // that still has ActiveX enabled by default, override jQuery to use that
      // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
      if (params.type === 'PATCH' && window.ActiveXObject &&
          !(window.external && window.external.msActiveXFilteringEnabled)) {
        params.xhr = function() {
          return new ActiveXObject("Microsoft.XMLHTTP");
        };
      }

      // Make the request, allowing the user to override any Ajax options.
      var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
      model.trigger('request', model, xhr, options);
      return xhr;
    };

    // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
    var methodMap = {
      'create': 'POST',
      'update': 'PUT',
      'patch':  'PATCH',
      'delete': 'DELETE',
      'read':   'GET'
    };

    // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
    // Override this if you'd like to use a different library.
    Backbone.ajax = function() {
      return Backbone.$.ajax.apply(Backbone.$, arguments);
    };

    // Backbone.Router
    // ---------------

    // Routers map faux-URLs to actions, and fire events when routes are
    // matched. Creating a new one sets its `routes` hash, if not set statically.
    var Router = Backbone.Router = function(options) {
      options || (options = {});
      if (options.routes) this.routes = options.routes;
      this._bindRoutes();
      this.initialize.apply(this, arguments);
    };

    // Cached regular expressions for matching named param parts and splatted
    // parts of route strings.
    var optionalParam = /\((.*?)\)/g;
    var namedParam    = /(\(\?)?:\w+/g;
    var splatParam    = /\*\w+/g;
    var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

    // Set up all inheritable **Backbone.Router** properties and methods.
    _.extend(Router.prototype, Events, {

      // Initialize is an empty function by default. Override it with your own
      // initialization logic.
      initialize: function(){},

      // Manually bind a single named route to a callback. For example:
      //
      //     this.route('search/:query/p:num', 'search', function(query, num) {
      //       ...
      //     });
      //
      route: function(route, name, callback) {
        if (!_.isRegExp(route)) route = this._routeToRegExp(route);
        if (_.isFunction(name)) {
          callback = name;
          name = '';
        }
        if (!callback) callback = this[name];
        var router = this;
        Backbone.history.route(route, function(fragment) {
          var args = router._extractParameters(route, fragment);
          callback && callback.apply(router, args);
          router.trigger.apply(router, ['route:' + name].concat(args));
          router.trigger('route', name, args);
          Backbone.history.trigger('route', router, name, args);
        });
        return this;
      },

      // Simple proxy to `Backbone.history` to save a fragment into the history.
      navigate: function(fragment, options) {
        Backbone.history.navigate(fragment, options);
        return this;
      },

      // Bind all defined routes to `Backbone.history`. We have to reverse the
      // order of the routes here to support behavior where the most general
      // routes can be defined at the bottom of the route map.
      _bindRoutes: function() {
        if (!this.routes) return;
        this.routes = _.result(this, 'routes');
        var route, routes = _.keys(this.routes);
        while ((route = routes.pop()) != null) {
          this.route(route, this.routes[route]);
        }
      },

      // Convert a route string into a regular expression, suitable for matching
      // against the current location hash.
      _routeToRegExp: function(route) {
        route = route.replace(escapeRegExp, '\\$&')
            .replace(optionalParam, '(?:$1)?')
            .replace(namedParam, function(match, optional){
              return optional ? match : '([^\/]+)';
            })
            .replace(splatParam, '(.*?)');
        return new RegExp('^' + route + '$');
      },

      // Given a route, and a URL fragment that it matches, return the array of
      // extracted decoded parameters. Empty or unmatched parameters will be
      // treated as `null` to normalize cross-browser behavior.
      _extractParameters: function(route, fragment) {
        var params = route.exec(fragment).slice(1);
        return _.map(params, function(param) {
          return param ? decodeURIComponent(param) : null;
        });
      }

    });

    // Backbone.History
    // ----------------

    // Handles cross-browser history management, based on either
    // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
    // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
    // and URL fragments. If the browser supports neither (old IE, natch),
    // falls back to polling.
    var History = Backbone.History = function() {
      this.handlers = [];
      _.bindAll(this, 'checkUrl');

      // Ensure that `History` can be used outside of the browser.
      if (typeof window !== 'undefined') {
        this.location = window.location;
        this.history = window.history;
      }
    };

    // Cached regex for stripping a leading hash/slash and trailing space.
    var routeStripper = /^[#\/]|\s+$/g;

    // Cached regex for stripping leading and trailing slashes.
    var rootStripper = /^\/+|\/+$/g;

    // Cached regex for detecting MSIE.
    var isExplorer = /msie [\w.]+/;

    // Cached regex for removing a trailing slash.
    var trailingSlash = /\/$/;

    // Has the history handling already been started?
    History.started = false;

    // Set up all inheritable **Backbone.History** properties and methods.
    _.extend(History.prototype, Events, {

      // The default interval to poll for hash changes, if necessary, is
      // twenty times a second.
      interval: 50,

      // Gets the true hash value. Cannot use location.hash directly due to bug
      // in Firefox where location.hash will always be decoded.
      getHash: function(window) {
        var match = (window || this).location.href.match(/#(.*)$/);
        return match ? match[1] : '';
      },

      // Get the cross-browser normalized URL fragment, either from the URL,
      // the hash, or the override.
      getFragment: function(fragment, forcePushState) {
        if (fragment == null) {
          if (this._hasPushState || !this._wantsHashChange || forcePushState) {
            fragment = this.location.pathname;
            var root = this.root.replace(trailingSlash, '');
            if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
          } else {
            fragment = this.getHash();
          }
        }
        return fragment.replace(routeStripper, '');
      },

      // Start the hash change handling, returning `true` if the current URL matches
      // an existing route, and `false` otherwise.
      start: function(options) {
        if (History.started) throw new Error("Backbone.history has already been started");
        History.started = true;

        // Figure out the initial configuration. Do we need an iframe?
        // Is pushState desired ... is it available?
        this.options          = _.extend({}, {root: '/'}, this.options, options);
        this.root             = this.options.root;
        this._wantsHashChange = this.options.hashChange !== false;
        this._wantsPushState  = !!this.options.pushState;
        this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
        var fragment          = this.getFragment();
        var docMode           = document.documentMode;
        var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

        // Normalize root to always include a leading and trailing slash.
        this.root = ('/' + this.root + '/').replace(rootStripper, '/');

        if (oldIE && this._wantsHashChange) {
          this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
          this.navigate(fragment);
        }

        // Depending on whether we're using pushState or hashes, and whether
        // 'onhashchange' is supported, determine how we check the URL state.
        if (this._hasPushState) {
          Backbone.$(window).on('popstate', this.checkUrl);
        } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
          Backbone.$(window).on('hashchange', this.checkUrl);
        } else if (this._wantsHashChange) {
          this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
        }

        // Determine if we need to change the base url, for a pushState link
        // opened by a non-pushState browser.
        this.fragment = fragment;
        var loc = this.location;
        var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

        // If we've started off with a route from a `pushState`-enabled browser,
        // but we're currently in a browser that doesn't support it...
        if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + this.location.search + '#' + this.fragment);
          // Return immediately as browser will do redirect to new url
          return true;

          // Or if we've started out with a hash-based route, but we're currently
          // in a browser where it could be `pushState`-based instead...
        } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
        }

        if (!this.options.silent) return this.loadUrl();
      },

      // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
      // but possibly useful for unit testing Routers.
      stop: function() {
        Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
        clearInterval(this._checkUrlInterval);
        History.started = false;
      },

      // Add a route to be tested when the fragment changes. Routes added later
      // may override previous routes.
      route: function(route, callback) {
        this.handlers.unshift({route: route, callback: callback});
      },

      // Checks the current URL to see if it has changed, and if it has,
      // calls `loadUrl`, normalizing across the hidden iframe.
      checkUrl: function(e) {
        var current = this.getFragment();
        if (current === this.fragment && this.iframe) {
          current = this.getFragment(this.getHash(this.iframe));
        }
        if (current === this.fragment) return false;
        if (this.iframe) this.navigate(current);
        this.loadUrl() || this.loadUrl(this.getHash());
      },

      // Attempt to load the current URL fragment. If a route succeeds with a
      // match, returns `true`. If no defined routes matches the fragment,
      // returns `false`.
      loadUrl: function(fragmentOverride) {
        var fragment = this.fragment = this.getFragment(fragmentOverride);
        var matched = _.any(this.handlers, function(handler) {
          if (handler.route.test(fragment)) {
            handler.callback(fragment);
            return true;
          }
        });
        return matched;
      },

      // Save a fragment into the hash history, or replace the URL state if the
      // 'replace' option is passed. You are responsible for properly URL-encoding
      // the fragment in advance.
      //
      // The options object can contain `trigger: true` if you wish to have the
      // route callback be fired (not usually desirable), or `replace: true`, if
      // you wish to modify the current URL without adding an entry to the history.
      navigate: function(fragment, options) {
        if (!History.started) return false;
        if (!options || options === true) options = {trigger: options};
        fragment = this.getFragment(fragment || '');
        if (this.fragment === fragment) return;
        this.fragment = fragment;
        var url = this.root + fragment;

        // If pushState is available, we use it to set the fragment as a real URL.
        if (this._hasPushState) {
          this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

          // If hash changes haven't been explicitly disabled, update the hash
          // fragment to store history.
        } else if (this._wantsHashChange) {
          this._updateHash(this.location, fragment, options.replace);
          if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
            // Opening and closing the iframe tricks IE7 and earlier to push a
            // history entry on hash-tag change.  When replace is true, we don't
            // want this.
            if(!options.replace) this.iframe.document.open().close();
            this._updateHash(this.iframe.location, fragment, options.replace);
          }

          // If you've told us that you explicitly don't want fallback hashchange-
          // based history, then `navigate` becomes a page refresh.
        } else {
          return this.location.assign(url);
        }
        if (options.trigger) this.loadUrl(fragment);
      },

      // Update the hash location, either replacing the current entry, or adding
      // a new one to the browser history.
      _updateHash: function(location, fragment, replace) {
        if (replace) {
          var href = location.href.replace(/(javascript:|#).*$/, '');
          location.replace(href + '#' + fragment);
        } else {
          // Some browsers require that `hash` contains a leading #.
          location.hash = '#' + fragment;
        }
      }

    });

    // Create the default Backbone.history.
    Backbone.history = new History;

    // Helpers
    // -------

    // Helper function to correctly set up the prototype chain, for subclasses.
    // Similar to `goog.inherits`, but uses a hash of prototype properties and
    // class properties to be extended.
    var extend = function(protoProps, staticProps) {
      var parent = this;
      var child;

      // The constructor function for the new subclass is either defined by you
      // (the "constructor" property in your `extend` definition), or defaulted
      // by us to simply call the parent's constructor.
      if (protoProps && _.has(protoProps, 'constructor')) {
        child = protoProps.constructor;
      } else {
        child = function(){ return parent.apply(this, arguments); };
      }

      // Add static properties to the constructor function, if supplied.
      _.extend(child, parent, staticProps);

      // Set the prototype chain to inherit from `parent`, without calling
      // `parent`'s constructor function.
      var Surrogate = function(){ this.constructor = child; };
      Surrogate.prototype = parent.prototype;
      child.prototype = new Surrogate;

      // Add prototype properties (instance properties) to the subclass,
      // if supplied.
      if (protoProps) _.extend(child.prototype, protoProps);

      // Set a convenience property in case the parent's prototype is needed
      // later.
      child.__super__ = parent.prototype;

      return child;
    };

    // Set up inheritance for the model, collection, router, view and history.
    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

    // Throw an error when a URL is needed, and none is supplied.
    var urlError = function() {
      throw new Error('A "url" property or function must be specified');
    };

    // Wrap an optional error callback with a fallback error event.
    var wrapError = function (model, options) {
      var error = options.error;
      options.error = function(resp) {
        if (error) error(model, resp, options);
        model.trigger('error', model, resp, options);
      };
    };

  }).call(this);

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:backbone', location = 'libs/backbone.js' */
define("jira/components/libs/backbone", [
    "atlassian/libs/factories/backbone-1.0.0",
    "jira/components/libs/underscore",
    "jquery"
], function(
    backboneFactory,
    _,
    $
) {
    "use strict";

    return backboneFactory(_, $);
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:brace', location = 'libs/brace.js' */
define("jira/components/libs/brace", [
    "atlassian/libs/factories/brace-2014.09.03",
    "jira/components/libs/backbone",
    "jira/components/libs/underscore"
], function(
    braceFactory,
    Backbone,
    _
) {
    "use strict";

    return braceFactory(_, Backbone);
});
AJS.namespace("JIRA.Issues.Brace", null, require("jira/components/libs/brace"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:tipsy', location = 'lib/jquery.hoverIntent.min.js' */
// jshint ignore: start
/*eslint-disable*/
/**
* hoverIntent r6 // 2011.02.26 // jQuery 1.5.1+
* <http://cherne.net/brian/resources/jquery.hoverIntent.html>
* 
* @param  f  onMouseOver function || An object with configuration options
* @param  g  onMouseOut function  || Nothing (use configuration options object)
* @author    Brian Cherne brian(at)cherne(dot)net
*/
(function($){$.fn.hoverIntent=function(f,g){var cfg={sensitivity:7,interval:100,timeout:0};cfg=$.extend(cfg,g?{over:f,out:g}:f);var cX,cY,pX,pY;var track=function(ev){cX=ev.pageX;cY=ev.pageY};var compare=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);if((Math.abs(pX-cX)+Math.abs(pY-cY))<cfg.sensitivity){$(ob).unbind("mousemove",track);ob.hoverIntent_s=1;return cfg.over.apply(ob,[ev])}else{pX=cX;pY=cY;ob.hoverIntent_t=setTimeout(function(){compare(ev,ob)},cfg.interval)}};var delay=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);ob.hoverIntent_s=0;return cfg.out.apply(ob,[ev])};var handleHover=function(e){var ev=jQuery.extend({},e);var ob=this;if(ob.hoverIntent_t){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t)}if(e.type=="mouseenter"){pX=ev.pageX;pY=ev.pageY;$(ob).bind("mousemove",track);if(ob.hoverIntent_s!=1){ob.hoverIntent_t=setTimeout(function(){compare(ev,ob)},cfg.interval)}}else{$(ob).unbind("mousemove",track);if(ob.hoverIntent_s==1){ob.hoverIntent_t=setTimeout(function(){delay(ev,ob)},cfg.timeout)}}};return this.bind('mouseenter',handleHover).bind('mouseleave',handleHover)}})(jQuery);;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:tipsy', location = 'util/TipsyView.js' */
define("jira/issues/tipsy", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var jQuery = require("jquery");

    if (!jQuery.fn.tooltip) {
        jQuery.fn.tooltip = jQuery.noop;
        jQuery.fn.tipsy = jQuery.noop;
    }

    /**
     * Utility backbone view for creating and showing tipsy
     *
     * A number of common predefined behaviours are built into the view so tipsy creation is easy
     */
    var tipsy = Brace.View.extend({
        events: {
            'click': "hide"
        },

        /**
         * @param options
         * @param options.tipsy Options to be passed into tipsy
         * @param options.intents Function overrides for hover intents
         * @param options.showCondition {Function | selector}
         *      Whether to show the tipsy based on the conditions defined in the function or
         *      the selecter via $el.filter()
         */
        initialize: function(options) {
            if (_.isFunction(options.showCondition)) {
                this.shouldShow = options.showCondition;
            } else if (options.showCondition) {
                this.shouldShow = _.bind(function() {
                    return this.$el.filter(options.showCondition).length > 0;
                }, this);
            } else {
                this.shouldShow = function() {
                    return true;
                };
            }

            this.tipsy = this.$el.tooltip(_.extend({trigger: "manual"}, options.tipsy));
            this.hoverIntent(options.intents);
        },

        hoverIntent: function(intents) {
            if (this.tipsy) {
                this.tipsy.hoverIntent(_.extend({
                    interval: 200,
                    over: _.bind(this.show, this),
                    out: _.bind(this.hide, this)
                }, intents));
            }
            return this;
        },

        show: function() {
            if (this.shouldShow() && this.tipsy) {
                this.$el.tipsy("show");
            }
        },

        hide: function() {
            if (this.tipsy) {
                this.$el.tipsy("hide");
            }
        },

        remove: function() {
            this.hide();
            this.$el.removeData("tipsy");
        }
    });

    /* Wrapper for tipsy API */
    tipsy.revalidate = function() {
        return jQuery.fn.tipsy.revalidate();
    };

    tipsy.autoBounds = function() {
        return jQuery.fn.tipsy.autoBounds.apply(jQuery.fn.tipsy, arguments);
    };

    return tipsy;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:tipsy', location = 'util/namespace.js' */
AJS.namespace("JIRA.Issues.Tipsy", null, require("jira/issues/tipsy"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:jqueryutils', location = 'util/jquery/CatchExceptions.js' */
(function($) {
    "use strict";

    var catchExceptions = function(fn) {
        return function() {
            try {
                fn.apply(this, arguments);
            } catch (e) {
            }
            return this;
        };
    };

    $.fn.htmlCatchExceptions = catchExceptions($.fn.html);
    $.fn.appendCatchExceptions = catchExceptions($.fn.append);
    $.fn.prependCatchExceptions = catchExceptions($.fn.prepend);

    $.catchExceptions = function(html) {
        // Done this way because $(html) doesn't evaluate scripts until elements are added to the document
        return $('<div>').htmlCatchExceptions(html).children();
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:jqueryutils', location = 'util/jquery/RecurringPromise.js' */
(function() {
    "use strict";

    /**
     * @param [parent]
     */
    jQuery.RecurringPromise = function(parent) {
        if (!(this instanceof jQuery.RecurringPromise)) {
            return new jQuery.RecurringPromise();
        }

        this._parent = parent;
        this._doneCallbacks = new jQuery.Callbacks();
        this._failCallbacks = new jQuery.Callbacks();
        this._alwaysCallbacks = new jQuery.Callbacks();
    };

    jQuery.RecurringPromise.prototype = {
        add: function(deferred) {
            var wrapperDeferred = new jQuery.Deferred();
            wrapperDeferred.original = deferred;

            var pending = this._getPending();
            this._abortIfPending(pending);

            this._setPending(wrapperDeferred);

            deferred.done(_.bind(function() {
                if (wrapperDeferred === this._getPending()) {
                    wrapperDeferred.resolveWith(this, arguments);
                    this._doneCallbacks.fireWith(this, arguments);
                }
            }, this));
            deferred.fail(_.bind(function() {
                if (wrapperDeferred === this._getPending()) {
                    wrapperDeferred.rejectWith(this, arguments);
                    this._failCallbacks.fireWith(this, arguments);
                }
            }, this));
            deferred.always(_.bind(function() {
                if (wrapperDeferred === this._getPending()) {
                    this._alwaysCallbacks.fireWith(this, arguments);
                }
            }, this));

            return wrapperDeferred.promise();
        },

        done: function(callback) {
            this._doneCallbacks.add(callback);
            return this;
        },

        fail: function(callback) {
            this._failCallbacks.add(callback);
            return this;
        },

        always: function(callback) {
            this._alwaysCallbacks.add(callback);
            return this;
        },

        reset: function() {
            this._abortIfPending(this._getPending());
            this._setPending(null);
        },

        sub: function() {
            return new jQuery.RecurringPromise(this);
        },

        _getPending: function() {
            return this._parent ? this._parent._getPending() : this._pending;
        },

        _setPending: function(deferred) {
            if (this._parent) {
                this._parent._setPending(deferred);
            } else {
                this._pending = deferred;
            }
        },

        _abortIfPending: function(wrapperDeferred) {
            if (wrapperDeferred && wrapperDeferred.state() === 'pending') {
                wrapperDeferred.reject("abort");

                // Abort existing pending request if an abort function is available
                if (jQuery.isFunction(wrapperDeferred.original.abort)) {
                    wrapperDeferred.original.abort();
                }
            }
        }
    };
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:jqueryutils', location = 'util/jquery/ConcurrentDeferred.js' */
jQuery.ConcurrentDeferred = function(initialDeferred) {
    "use strict";

    var concurrentDeferred = new jQuery.Deferred();
    var activeDeferred;

    var attach = function(deferred) {
        activeDeferred = deferred;
        deferred.done(function() {
            if (activeDeferred === deferred) {
                concurrentDeferred.resolve.apply(concurrentDeferred, arguments);
            }
        }).fail(function() {
            if (activeDeferred === deferred) {
                concurrentDeferred.reject.apply(concurrentDeferred, arguments);
            }
        });
    };

    attach(initialDeferred);

    jQuery.extend(concurrentDeferred, {
        update: function(updatedDeferred) {
            if (!this.isPending()) {
                throw "Cannot update non-pending ConcurrentDeferred";
            }

            var oldDeferred = activeDeferred;
            attach(updatedDeferred);

            if (jQuery.isFunction(oldDeferred.abort)) {
                oldDeferred.abort();
            }

            return this;
        },
        isPending: function() {
            return this.state() === 'pending';
        }
    });

    return concurrentDeferred;
};
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:jqueryutils', location = 'util/jquery/ScrollLock.js' */
// Prevent the page from scrolling when using the mousewheel to scroll an element with vertical scrollbars

// Usage:
// $el.scrollLock();
// $el.scrollLock('.scrollable');
// $el.scrollLock(50);
// $el.scrollLock('.scrollable', 50);
(function($) {
    "use strict";
    var DEFAULT_SCROLL_INTERVAL = 30;

    $.fn.scrollLock = function(selector, scrollInterval) {
        if (typeof selector !== 'string') {
            scrollInterval = selector;
            selector = null;
        }
        if (!scrollInterval) {
            scrollInterval = DEFAULT_SCROLL_INTERVAL;
        }
        this.on('DOMMouseScroll mousewheel', selector, function(e) {
            e.preventDefault();
            var d;
            if (e.originalEvent.wheelDelta) d = e.originalEvent.wheelDelta / 120;
            if (e.originalEvent.detail) d = -e.originalEvent.detail / 3;
            if ($.isNumeric(d)) {
                this.scrollTop -= d * scrollInterval;
            }
        });
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:jqueryutils', location = 'util/jquery/EscapeCssIdSelector.js' */
define("jira/components/util/jquery/escapecssidselector", function() {
    "use strict";

    return function(selector) {
        return (selector.substr(0, 1) === "#" ? "" : "#") + selector.replace( /(:|\.|\[|\]|,)/g, "\\$1" );
    };
});
;
;
/* module-key = 'com.atlassian.plugin.jslibs:marionette-1.4.1-factory', location = 'factories/marionette/1.4.1/marionette-1.4.1-factory.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
    define('atlassian/libs/factories/marionette-1.4.1', function() {
        return function(_, Backbone) {
            var oldMarionette = Backbone.Marionette;
            var env = {
                _: _,
                Backbone: Backbone
            };
            factory.call(env);
            var Marionette = Backbone.Marionette;
            Marionette.VERSION = "1.4.1";
            Backbone.Marionette = oldMarionette;
            return Marionette;
        }
    });
})(function() {
    var Backbone = this.Backbone;
    var _ = this._;
/////// End of Atlassian modification ///////

    // MarionetteJS (Backbone.Marionette)
    // ----------------------------------
    // v1.4.1
    //
    // Copyright (c)2013 Derick Bailey, Muted Solutions, LLC.
    // Distributed under MIT license
    //
    // http://marionettejs.com


    /*!
     * Includes BabySitter
     * https://github.com/marionettejs/backbone.babysitter/
     *
     * Includes Wreqr
     * https://github.com/marionettejs/backbone.wreqr/
     */

    // Backbone.BabySitter
    // -------------------
    // v0.0.6
    //
    // Copyright (c)2013 Derick Bailey, Muted Solutions, LLC.
    // Distributed under MIT license
    //
    // http://github.com/babysitterjs/backbone.babysitter

    // Backbone.ChildViewContainer
    // ---------------------------
    //
    // Provide a container to store, retrieve and
    // shut down child views.

    BackboneChildViewContainer = (function (Backbone, _) {

        // Container Constructor
        // ---------------------

        var Container = function (views) {
            this._views = {};
            this._indexByModel = {};
            this._indexByCustom = {};
            this._updateLength();

            _.each(views, this.add, this);
        };

        // Container Methods
        // -----------------

        _.extend(Container.prototype, {

            // Add a view to this container. Stores the view
            // by `cid` and makes it searchable by the model
            // cid (and model itself). Optionally specify
            // a custom key to store an retrieve the view.
            add: function (view, customIndex) {
                var viewCid = view.cid;

                // store the view
                this._views[viewCid] = view;

                // index it by model
                if (view.model) {
                    this._indexByModel[view.model.cid] = viewCid;
                }

                // index by custom
                if (customIndex) {
                    this._indexByCustom[customIndex] = viewCid;
                }

                this._updateLength();
            },

            // Find a view by the model that was attached to
            // it. Uses the model's `cid` to find it.
            findByModel: function (model) {
                return this.findByModelCid(model.cid);
            },

            // Find a view by the `cid` of the model that was attached to
            // it. Uses the model's `cid` to find the view `cid` and
            // retrieve the view using it.
            findByModelCid: function (modelCid) {
                var viewCid = this._indexByModel[modelCid];
                return this.findByCid(viewCid);
            },

            // Find a view by a custom indexer.
            findByCustom: function (index) {
                var viewCid = this._indexByCustom[index];
                return this.findByCid(viewCid);
            },

            // Find by index. This is not guaranteed to be a
            // stable index.
            findByIndex: function (index) {
                return _.values(this._views)[index];
            },

            // retrieve a view by it's `cid` directly
            findByCid: function (cid) {
                return this._views[cid];
            },

            // Remove a view
            remove: function (view) {
                var viewCid = view.cid;

                // delete model index
                if (view.model) {
                    delete this._indexByModel[view.model.cid];
                }

                // delete custom index
                _.any(this._indexByCustom, function (cid, key) {
                    if (cid === viewCid) {
                        delete this._indexByCustom[key];
                        return true;
                    }
                }, this);

                // remove the view from the container
                delete this._views[viewCid];

                // update the length
                this._updateLength();
            },

            // Call a method on every view in the container,
            // passing parameters to the call method one at a
            // time, like `function.call`.
            call: function (method) {
                this.apply(method, _.tail(arguments));
            },

            // Apply a method on every view in the container,
            // passing parameters to the call method one at a
            // time, like `function.apply`.
            apply: function (method, args) {
                _.each(this._views, function (view) {
                    if (_.isFunction(view[method])) {
                        view[method].apply(view, args || []);
                    }
                });
            },

            // Update the `.length` attribute on this container
            _updateLength: function () {
                this.length = _.size(this._views);
            }
        });

        // Borrowing this code from Backbone.Collection:
        // http://backbonejs.org/docs/backbone.html#section-106
        //
        // Mix in methods from Underscore, for iteration, and other
        // collection related features.
        var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
            'select', 'reject', 'every', 'all', 'some', 'any', 'include',
            'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
            'last', 'without', 'isEmpty', 'pluck'];

        _.each(methods, function (method) {
            Container.prototype[method] = function () {
                var views = _.values(this._views);
                var args = [views].concat(_.toArray(arguments));
                return _[method].apply(_, args);
            };
        });

        // return the public API
        return Container;
    })(Backbone, _);

    // Backbone.Wreqr (Backbone.Marionette)
    // ----------------------------------
    // v0.2.0
    //
    // Copyright (c)2013 Derick Bailey, Muted Solutions, LLC.
    // Distributed under MIT license
    //
    // http://github.com/marionettejs/backbone.wreqr


    BackboneWreqr = (function (Backbone, Marionette, _) {
        "use strict";
        var Wreqr = {};

        // Handlers
        // --------
        // A registry of functions to call, given a name

        Wreqr.Handlers = (function (Backbone, _) {
            "use strict";

            // Constructor
            // -----------

            var Handlers = function (options) {
                this.options = options;
                this._wreqrHandlers = {};

                if (_.isFunction(this.initialize)) {
                    this.initialize(options);
                }
            };

            Handlers.extend = Backbone.Model.extend;

            // Instance Members
            // ----------------

            _.extend(Handlers.prototype, Backbone.Events, {

                // Add multiple handlers using an object literal configuration
                setHandlers: function (handlers) {
                    _.each(handlers, function (handler, name) {
                        var context = null;

                        if (_.isObject(handler) && !_.isFunction(handler)) {
                            context = handler.context;
                            handler = handler.callback;
                        }

                        this.setHandler(name, handler, context);
                    }, this);
                },

                // Add a handler for the given name, with an
                // optional context to run the handler within
                setHandler: function (name, handler, context) {
                    var config = {
                        callback: handler,
                        context: context
                    };

                    this._wreqrHandlers[name] = config;

                    this.trigger("handler:add", name, handler, context);
                },

                // Determine whether or not a handler is registered
                hasHandler: function (name) {
                    return !!this._wreqrHandlers[name];
                },

                // Get the currently registered handler for
                // the specified name. Throws an exception if
                // no handler is found.
                getHandler: function (name) {
                    var config = this._wreqrHandlers[name];

                    if (!config) {
                        throw new Error("Handler not found for '" + name + "'");
                    }

                    return function () {
                        var args = Array.prototype.slice.apply(arguments);
                        return config.callback.apply(config.context, args);
                    };
                },

                // Remove a handler for the specified name
                removeHandler: function (name) {
                    delete this._wreqrHandlers[name];
                },

                // Remove all handlers from this registry
                removeAllHandlers: function () {
                    this._wreqrHandlers = {};
                }
            });

            return Handlers;
        })(Backbone, _);

        // Wreqr.CommandStorage
        // --------------------
        //
        // Store and retrieve commands for execution.
        Wreqr.CommandStorage = (function () {
            "use strict";

            // Constructor function
            var CommandStorage = function (options) {
                this.options = options;
                this._commands = {};

                if (_.isFunction(this.initialize)) {
                    this.initialize(options);
                }
            };

            // Instance methods
            _.extend(CommandStorage.prototype, Backbone.Events, {

                // Get an object literal by command name, that contains
                // the `commandName` and the `instances` of all commands
                // represented as an array of arguments to process
                getCommands: function (commandName) {
                    var commands = this._commands[commandName];

                    // we don't have it, so add it
                    if (!commands) {

                        // build the configuration
                        commands = {
                            command: commandName,
                            instances: []
                        };

                        // store it
                        this._commands[commandName] = commands;
                    }

                    return commands;
                },

                // Add a command by name, to the storage and store the
                // args for the command
                addCommand: function (commandName, args) {
                    var command = this.getCommands(commandName);
                    command.instances.push(args);
                },

                // Clear all commands for the given `commandName`
                clearCommands: function (commandName) {
                    var command = this.getCommands(commandName);
                    command.instances = [];
                }
            });

            return CommandStorage;
        })();

        // Wreqr.Commands
        // --------------
        //
        // A simple command pattern implementation. Register a command
        // handler and execute it.
        Wreqr.Commands = (function (Wreqr) {
            "use strict";

            return Wreqr.Handlers.extend({
                // default storage type
                storageType: Wreqr.CommandStorage,

                constructor: function (options) {
                    this.options = options || {};

                    this._initializeStorage(this.options);
                    this.on("handler:add", this._executeCommands, this);

                    var args = Array.prototype.slice.call(arguments);
                    Wreqr.Handlers.prototype.constructor.apply(this, args);
                },

                // Execute a named command with the supplied args
                execute: function (name, args) {
                    name = arguments[0];
                    args = Array.prototype.slice.call(arguments, 1);

                    if (this.hasHandler(name)) {
                        this.getHandler(name).apply(this, args);
                    }
                    else {
                        this.storage.addCommand(name, args);
                    }

                },

                // Internal method to handle bulk execution of stored commands
                _executeCommands: function (name, handler, context) {
                    var command = this.storage.getCommands(name);

                    // loop through and execute all the stored command instances
                    _.each(command.instances, function (args) {
                        handler.apply(context, args);
                    });

                    this.storage.clearCommands(name);
                },

                // Internal method to initialize storage either from the type's
                // `storageType` or the instance `options.storageType`.
                _initializeStorage: function (options) {
                    var storage;

                    var StorageType = options.storageType || this.storageType;
                    if (_.isFunction(StorageType)) {
                        storage = new StorageType();
                    }
                    else {
                        storage = StorageType;
                    }

                    this.storage = storage;
                }
            });

        })(Wreqr);

        // Wreqr.RequestResponse
        // ---------------------
        //
        // A simple request/response implementation. Register a
        // request handler, and return a response from it
        Wreqr.RequestResponse = (function (Wreqr) {
            "use strict";

            return Wreqr.Handlers.extend({
                request: function () {
                    var name = arguments[0];
                    var args = Array.prototype.slice.call(arguments, 1);

                    return this.getHandler(name).apply(this, args);
                }
            });

        })(Wreqr);

        // Event Aggregator
        // ----------------
        // A pub-sub object that can be used to decouple various parts
        // of an application through event-driven architecture.

        Wreqr.EventAggregator = (function (Backbone, _) {
            "use strict";
            var EA = function () {};

            // Copy the `extend` function used by Backbone's classes
            EA.extend = Backbone.Model.extend;

            // Copy the basic Backbone.Events on to the event aggregator
            _.extend(EA.prototype, Backbone.Events);

            return EA;
        })(Backbone, _);


        return Wreqr;
    })(Backbone, Backbone.Marionette, _);

    var Marionette = (function (global, Backbone, _) {
        "use strict";

        // Define and export the Marionette namespace
        var Marionette = {};
        Backbone.Marionette = Marionette;

        // Get the DOM manipulator for later use
        Marionette.$ = Backbone.$;

        // Helpers
        // -------

        // For slicing `arguments` in functions
        var protoSlice = Array.prototype.slice;

        function slice(args) {
            return protoSlice.call(args);
        }

        function throwError(message, name) {
            var error = new Error(message);
            error.name = name || 'Error';
            throw error;
        }

        // Marionette.extend
        // -----------------

        // Borrow the Backbone `extend` method so we can use it as needed
        Marionette.extend = Backbone.Model.extend;

        // Marionette.getOption
        // --------------------

        // Retrieve an object, function or other value from a target
        // object or its `options`, with `options` taking precedence.
        Marionette.getOption = function (target, optionName) {
            if (!target || !optionName) { return; }
            var value;

            if (target.options && (optionName in target.options) && (target.options[optionName] !== undefined)) {
                value = target.options[optionName];
            }
            else {
                value = target[optionName];
            }

            return value;
        };

        // Trigger an event and/or a corresponding method name. Examples:
        //
        // `this.triggerMethod("foo")` will trigger the "foo" event and
        // call the "onFoo" method.
        //
        // `this.triggerMethod("foo:bar") will trigger the "foo:bar" event and
        // call the "onFooBar" method.
        Marionette.triggerMethod = (function () {

            // split the event name on the :
            var splitter = /(^|:)(\w)/gi;

            // take the event section ("section1:section2:section3")
            // and turn it in to uppercase name
            function getEventName(match, prefix, eventName) {
                return eventName.toUpperCase();
            }

            // actual triggerMethod name
            var triggerMethod = function (event) {
                // get the method name from the event name
                var methodName = 'on' + event.replace(splitter, getEventName);
                var method = this[methodName];

                // trigger the event, if a trigger method exists
                if (_.isFunction(this.trigger)) {
                    this.trigger.apply(this, arguments);
                }

                // call the onMethodName if it exists
                if (_.isFunction(method)) {
                    // pass all arguments, except the event name
                    return method.apply(this, _.tail(arguments));
                }
            };

            return triggerMethod;
        })();

        // DOMRefresh
        // ----------
        //
        // Monitor a view's state, and after it has been rendered and shown
        // in the DOM, trigger a "dom:refresh" event every time it is
        // re-rendered.

        Marionette.MonitorDOMRefresh = (function () {
            // track when the view has been shown in the DOM,
            // using a Marionette.Region (or by other means of triggering "show")
            function handleShow(view) {
                view._isShown = true;
                triggerDOMRefresh(view);
            }

            // track when the view has been rendered
            function handleRender(view) {
                view._isRendered = true;
                triggerDOMRefresh(view);
            }

            // Trigger the "dom:refresh" event and corresponding "onDomRefresh" method
            function triggerDOMRefresh(view) {
                if (view._isShown && view._isRendered) {
                    if (_.isFunction(view.triggerMethod)) {
                        view.triggerMethod("dom:refresh");
                    }
                }
            }

            // Export public API
            return function (view) {
                view.listenTo(view, "show", function () {
                    handleShow(view);
                });

                view.listenTo(view, "render", function () {
                    handleRender(view);
                });
            };
        })();


        // Marionette.bindEntityEvents & unbindEntityEvents
        // ---------------------------
        //
        // These methods are used to bind/unbind a backbone "entity" (collection/model)
        // to methods on a target object.
        //
        // The first parameter, `target`, must have a `listenTo` method from the
        // EventBinder object.
        //
        // The second parameter is the entity (Backbone.Model or Backbone.Collection)
        // to bind the events from.
        //
        // The third parameter is a hash of { "event:name": "eventHandler" }
        // configuration. Multiple handlers can be separated by a space. A
        // function can be supplied instead of a string handler name.

        (function (Marionette) {
            "use strict";

            // Bind the event to handlers specified as a string of
            // handler names on the target object
            function bindFromStrings(target, entity, evt, methods) {
                var methodNames = methods.split(/\s+/);

                _.each(methodNames, function (methodName) {

                    var method = target[methodName];
                    if (!method) {
                        throwError("Method '" + methodName + "' was configured as an event handler, but does not exist.");
                    }

                    target.listenTo(entity, evt, method, target);
                });
            }

            // Bind the event to a supplied callback function
            function bindToFunction(target, entity, evt, method) {
                target.listenTo(entity, evt, method, target);
            }

            // Bind the event to handlers specified as a string of
            // handler names on the target object
            function unbindFromStrings(target, entity, evt, methods) {
                var methodNames = methods.split(/\s+/);

                _.each(methodNames, function (methodName) {
                    var method = target[methodName];
                    target.stopListening(entity, evt, method, target);
                });
            }

            // Bind the event to a supplied callback function
            function unbindToFunction(target, entity, evt, method) {
                target.stopListening(entity, evt, method, target);
            }


            // generic looping function
            function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {
                if (!entity || !bindings) { return; }

                // allow the bindings to be a function
                if (_.isFunction(bindings)) {
                    bindings = bindings.call(target);
                }

                // iterate the bindings and bind them
                _.each(bindings, function (methods, evt) {

                    // allow for a function as the handler,
                    // or a list of event names as a string
                    if (_.isFunction(methods)) {
                        functionCallback(target, entity, evt, methods);
                    }
                    else {
                        stringCallback(target, entity, evt, methods);
                    }

                });
            }

            // Export Public API
            Marionette.bindEntityEvents = function (target, entity, bindings) {
                iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);
            };

            Marionette.unbindEntityEvents = function (target, entity, bindings) {
                iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);
            };

        })(Marionette);


        // Callbacks
        // ---------

        // A simple way of managing a collection of callbacks
        // and executing them at a later point in time, using jQuery's
        // `Deferred` object.
        Marionette.Callbacks = function () {
            this._deferred = Marionette.$.Deferred();
            this._callbacks = [];
        };

        _.extend(Marionette.Callbacks.prototype, {

            // Add a callback to be executed. Callbacks added here are
            // guaranteed to execute, even if they are added after the
            // `run` method is called.
            add: function (callback, contextOverride) {
                this._callbacks.push({cb: callback, ctx: contextOverride});

                this._deferred.done(function (context, options) {
                    if (contextOverride) { context = contextOverride; }
                    callback.call(context, options);
                });
            },

            // Run all registered callbacks with the context specified.
            // Additional callbacks can be added after this has been run
            // and they will still be executed.
            run: function (options, context) {
                this._deferred.resolve(context, options);
            },

            // Resets the list of callbacks to be run, allowing the same list
            // to be run multiple times - whenever the `run` method is called.
            reset: function () {
                var callbacks = this._callbacks;
                this._deferred = Marionette.$.Deferred();
                this._callbacks = [];

                _.each(callbacks, function (cb) {
                    this.add(cb.cb, cb.ctx);
                }, this);
            }
        });


        // Marionette Controller
        // ---------------------
        //
        // A multi-purpose object to use as a controller for
        // modules and routers, and as a mediator for workflow
        // and coordination of other objects, views, and more.
        Marionette.Controller = function (options) {
            this.triggerMethod = Marionette.triggerMethod;
            this.options = options || {};

            if (_.isFunction(this.initialize)) {
                this.initialize(this.options);
            }
        };

        Marionette.Controller.extend = Marionette.extend;

        // Controller Methods
        // --------------

        // Ensure it can trigger events with Backbone.Events
        _.extend(Marionette.Controller.prototype, Backbone.Events, {
            close: function () {
                this.stopListening();
                this.triggerMethod("close");
                this.unbind();
            }
        });

        // Region
        // ------
        //
        // Manage the visual regions of your composite application. See
        // http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/

        Marionette.Region = function (options) {
            this.options = options || {};

            this.el = Marionette.getOption(this, "el");

            if (!this.el) {
                var err = new Error("An 'el' must be specified for a region.");
                err.name = "NoElError";
                throw err;
            }

            if (this.initialize) {
                var args = Array.prototype.slice.apply(arguments);
                this.initialize.apply(this, args);
            }
        };


        // Region Type methods
        // -------------------

        _.extend(Marionette.Region, {

            // Build an instance of a region by passing in a configuration object
            // and a default region type to use if none is specified in the config.
            //
            // The config object should either be a string as a jQuery DOM selector,
            // a Region type directly, or an object literal that specifies both
            // a selector and regionType:
            //
            // ```js
            // {
            //   selector: "#foo",
            //   regionType: MyCustomRegion
            // }
            // ```
            //
            buildRegion: function (regionConfig, defaultRegionType) {

                var regionIsString = (typeof regionConfig === "string");
                var regionSelectorIsString = (typeof regionConfig.selector === "string");
                var regionTypeIsUndefined = (typeof regionConfig.regionType === "undefined");
                var regionIsType = (typeof regionConfig === "function");

                if (!regionIsType && !regionIsString && !regionSelectorIsString) {
                    throw new Error("Region must be specified as a Region type, a selector string or an object with selector property");
                }

                var selector, RegionType;

                // get the selector for the region

                if (regionIsString) {
                    selector = regionConfig;
                }

                if (regionConfig.selector) {
                    selector = regionConfig.selector;
                }

                // get the type for the region

                if (regionIsType) {
                    RegionType = regionConfig;
                }

                if (!regionIsType && regionTypeIsUndefined) {
                    RegionType = defaultRegionType;
                }

                if (regionConfig.regionType) {
                    RegionType = regionConfig.regionType;
                }

                // build the region instance
                var region = new RegionType({
                    el: selector
                });

                // override the `getEl` function if we have a parentEl
                // this must be overridden to ensure the selector is found
                // on the first use of the region. if we try to assign the
                // region's `el` to `parentEl.find(selector)` in the object
                // literal to build the region, the element will not be
                // guaranteed to be in the DOM already, and will cause problems
                if (regionConfig.parentEl) {

                    region.getEl = function (selector) {
                        var parentEl = regionConfig.parentEl;
                        if (_.isFunction(parentEl)) {
                            parentEl = parentEl();
                        }
                        return parentEl.find(selector);
                    };
                }

                return region;
            }

        });

        // Region Instance Methods
        // -----------------------

        _.extend(Marionette.Region.prototype, Backbone.Events, {

            // Displays a backbone view instance inside of the region.
            // Handles calling the `render` method for you. Reads content
            // directly from the `el` attribute. Also calls an optional
            // `onShow` and `close` method on your view, just after showing
            // or just before closing the view, respectively.
            show: function (view) {

                this.ensureEl();

                var isViewClosed = view.isClosed || _.isUndefined(view.$el);

                var isDifferentView = view !== this.currentView;

                if (isDifferentView) {
                    this.close();
                }

                view.render();

                if (isDifferentView || isViewClosed) {
                    this.open(view);
                }

                this.currentView = view;

                Marionette.triggerMethod.call(this, "show", view);
                Marionette.triggerMethod.call(view, "show");
            },

            ensureEl: function () {
                if (!this.$el || this.$el.length === 0) {
                    this.$el = this.getEl(this.el);
                }
            },

            // Override this method to change how the region finds the
            // DOM element that it manages. Return a jQuery selector object.
            getEl: function (selector) {
                return Marionette.$(selector);
            },

            // Override this method to change how the new view is
            // appended to the `$el` that the region is managing
            open: function (view) {
                this.$el.empty().append(view.el);
            },

            // Close the current view, if there is one. If there is no
            // current view, it does nothing and returns immediately.
            close: function () {
                var view = this.currentView;
                if (!view || view.isClosed) { return; }

                // call 'close' or 'remove', depending on which is found
                if (view.close) { view.close(); }
                else if (view.remove) { view.remove(); }

                Marionette.triggerMethod.call(this, "close");

                delete this.currentView;
            },

            // Attach an existing view to the region. This
            // will not call `render` or `onShow` for the new view,
            // and will not replace the current HTML for the `el`
            // of the region.
            attachView: function (view) {
                this.currentView = view;
            },

            // Reset the region by closing any existing view and
            // clearing out the cached `$el`. The next time a view
            // is shown via this region, the region will re-query the
            // DOM for the region's `el`.
            reset: function () {
                this.close();
                delete this.$el;
            }
        });

        // Copy the `extend` function used by Backbone's classes
        Marionette.Region.extend = Marionette.extend;

        // Marionette.RegionManager
        // ------------------------
        //
        // Manage one or more related `Marionette.Region` objects.
        Marionette.RegionManager = (function (Marionette) {

            var RegionManager = Marionette.Controller.extend({
                constructor: function (options) {
                    this._regions = {};
                    Marionette.Controller.prototype.constructor.call(this, options);
                },

                // Add multiple regions using an object literal, where
                // each key becomes the region name, and each value is
                // the region definition.
                addRegions: function (regionDefinitions, defaults) {
                    var regions = {};

                    _.each(regionDefinitions, function (definition, name) {
                        if (typeof definition === "string") {
                            definition = {selector: definition};
                        }

                        if (definition.selector) {
                            definition = _.defaults({}, definition, defaults);
                        }

                        var region = this.addRegion(name, definition);
                        regions[name] = region;
                    }, this);

                    return regions;
                },

                // Add an individual region to the region manager,
                // and return the region instance
                addRegion: function (name, definition) {
                    var region;

                    var isObject = _.isObject(definition);
                    var isString = _.isString(definition);
                    var hasSelector = !!definition.selector;

                    if (isString || (isObject && hasSelector)) {
                        region = Marionette.Region.buildRegion(definition, Marionette.Region);
                    }
                    else if (_.isFunction(definition)) {
                        region = Marionette.Region.buildRegion(definition, Marionette.Region);
                    }
                    else {
                        region = definition;
                    }

                    this._store(name, region);
                    this.triggerMethod("region:add", name, region);
                    return region;
                },

                // Get a region by name
                get: function (name) {
                    return this._regions[name];
                },

                // Remove a region by name
                removeRegion: function (name) {
                    var region = this._regions[name];
                    this._remove(name, region);
                },

                // Close all regions in the region manager, and
                // remove them
                removeRegions: function () {
                    _.each(this._regions, function (region, name) {
                        this._remove(name, region);
                    }, this);
                },

                // Close all regions in the region manager, but
                // leave them attached
                closeRegions: function () {
                    _.each(this._regions, function (region, name) {
                        region.close();
                    }, this);
                },

                // Close all regions and shut down the region
                // manager entirely
                close: function () {
                    this.removeRegions();
                    var args = Array.prototype.slice.call(arguments);
                    Marionette.Controller.prototype.close.apply(this, args);
                },

                // internal method to store regions
                _store: function (name, region) {
                    this._regions[name] = region;
                    this._setLength();
                },

                // internal method to remove a region
                _remove: function (name, region) {
                    region.close();
                    delete this._regions[name];
                    this._setLength();
                    this.triggerMethod("region:remove", name, region);
                },

                // set the number of regions current held
                _setLength: function () {
                    this.length = _.size(this._regions);
                }

            });

            // Borrowing this code from Backbone.Collection:
            // http://backbonejs.org/docs/backbone.html#section-106
            //
            // Mix in methods from Underscore, for iteration, and other
            // collection related features.
            var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
                'select', 'reject', 'every', 'all', 'some', 'any', 'include',
                'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
                'last', 'without', 'isEmpty', 'pluck'];

            _.each(methods, function (method) {
                RegionManager.prototype[method] = function () {
                    var regions = _.values(this._regions);
                    var args = [regions].concat(_.toArray(arguments));
                    return _[method].apply(_, args);
                };
            });

            return RegionManager;
        })(Marionette);


        // Template Cache
        // --------------

        // Manage templates stored in `<script>` blocks,
        // caching them for faster access.
        Marionette.TemplateCache = function (templateId) {
            this.templateId = templateId;
        };

        // TemplateCache object-level methods. Manage the template
        // caches from these method calls instead of creating
        // your own TemplateCache instances
        _.extend(Marionette.TemplateCache, {
            templateCaches: {},

            // Get the specified template by id. Either
            // retrieves the cached version, or loads it
            // from the DOM.
            get: function (templateId) {
                var cachedTemplate = this.templateCaches[templateId];

                if (!cachedTemplate) {
                    cachedTemplate = new Marionette.TemplateCache(templateId);
                    this.templateCaches[templateId] = cachedTemplate;
                }

                return cachedTemplate.load();
            },

            // Clear templates from the cache. If no arguments
            // are specified, clears all templates:
            // `clear()`
            //
            // If arguments are specified, clears each of the
            // specified templates from the cache:
            // `clear("#t1", "#t2", "...")`
            clear: function () {
                var i;
                var args = slice(arguments);
                var length = args.length;

                if (length > 0) {
                    for (i = 0; i < length; i++) {
                        delete this.templateCaches[args[i]];
                    }
                }
                else {
                    this.templateCaches = {};
                }
            }
        });

        // TemplateCache instance methods, allowing each
        // template cache object to manage its own state
        // and know whether or not it has been loaded
        _.extend(Marionette.TemplateCache.prototype, {

            // Internal method to load the template
            load: function () {
                // Guard clause to prevent loading this template more than once
                if (this.compiledTemplate) {
                    return this.compiledTemplate;
                }

                // Load the template and compile it
                var template = this.loadTemplate(this.templateId);
                this.compiledTemplate = this.compileTemplate(template);

                return this.compiledTemplate;
            },

            // Load a template from the DOM, by default. Override
            // this method to provide your own template retrieval
            // For asynchronous loading with AMD/RequireJS, consider
            // using a template-loader plugin as described here:
            // https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs
            loadTemplate: function (templateId) {
                var template = Marionette.$(templateId).html();

                if (!template || template.length === 0) {
                    throwError("Could not find template: '" + templateId + "'", "NoTemplateError");
                }

                return template;
            },

            // Pre-compile the template before caching it. Override
            // this method if you do not need to pre-compile a template
            // (JST / RequireJS for example) or if you want to change
            // the template engine used (Handebars, etc).
            compileTemplate: function (rawTemplate) {
                return _.template(rawTemplate);
            }
        });


        // Renderer
        // --------

        // Render a template with data by passing in the template
        // selector and the data to render.
        Marionette.Renderer = {

            // Render a template with data. The `template` parameter is
            // passed to the `TemplateCache` object to retrieve the
            // template function. Override this method to provide your own
            // custom rendering and template handling for all of Marionette.
            render: function (template, data) {

                if (!template) {
                    var error = new Error("Cannot render the template since it's false, null or undefined.");
                    error.name = "TemplateNotFoundError";
                    throw error;
                }

                var templateFunc;
                if (typeof template === "function") {
                    templateFunc = template;
                }
                else {
                    templateFunc = Marionette.TemplateCache.get(template);
                }

                return templateFunc(data);
            }
        };


        // Marionette.View
        // ---------------

        // The core view type that other Marionette views extend from.
        Marionette.View = Backbone.View.extend({

            constructor: function (options) {
                _.bindAll(this, "render");

                var args = Array.prototype.slice.apply(arguments);

                // this exposes view options to the view initializer
                // this is a backfill since backbone removed the assignment
                // of this.options
                // at some point however this may be removed
                this.options = _.extend({}, this.options, options);

                // parses out the @ui DSL for events
                this.events = this.normalizeUIKeys(_.result(this, 'events'));
                Backbone.View.prototype.constructor.apply(this, args);

                Marionette.MonitorDOMRefresh(this);
                this.listenTo(this, "show", this.onShowCalled, this);
            },

            // import the "triggerMethod" to trigger events with corresponding
            // methods if the method exists
            triggerMethod: Marionette.triggerMethod,

            // Get the template for this view
            // instance. You can set a `template` attribute in the view
            // definition or pass a `template: "whatever"` parameter in
            // to the constructor options.
            getTemplate: function () {
                return Marionette.getOption(this, "template");
            },

            // Mix in template helper methods. Looks for a
            // `templateHelpers` attribute, which can either be an
            // object literal, or a function that returns an object
            // literal. All methods and attributes from this object
            // are copies to the object passed in.
            mixinTemplateHelpers: function (target) {
                target = target || {};
                var templateHelpers = Marionette.getOption(this, "templateHelpers");
                if (_.isFunction(templateHelpers)) {
                    templateHelpers = templateHelpers.call(this);
                }
                return _.extend(target, templateHelpers);
            },

            // allows for the use of the @ui. syntax within
            // a given key for triggers and events
            // swaps the @ui with the associated selector
            normalizeUIKeys: function (hash) {
                if (typeof(hash) === "undefined") {
                    return;
                }

                _.each(_.keys(hash), function (v) {
                    var split = v.split("@ui.");
                    if (split.length === 2) {
                        hash[split[0] + this.ui[split[1]]] = hash[v];
                        delete hash[v];
                    }
                }, this);

                return hash;
            },

            // Configure `triggers` to forward DOM events to view
            // events. `triggers: {"click .foo": "do:foo"}`
            configureTriggers: function () {
                if (!this.triggers) { return; }

                var triggerEvents = {};

                // Allow `triggers` to be configured as a function
                var triggers = this.normalizeUIKeys(_.result(this, "triggers"));

                // Configure the triggers, prevent default
                // action and stop propagation of DOM events
                _.each(triggers, function (value, key) {

                    var hasOptions = _.isObject(value);
                    var eventName = hasOptions ? value.event : value;

                    // build the event handler function for the DOM event
                    triggerEvents[key] = function (e) {

                        // stop the event in its tracks
                        if (e) {
                            var prevent = e.preventDefault;
                            var stop = e.stopPropagation;

                            var shouldPrevent = hasOptions ? value.preventDefault : prevent;
                            var shouldStop = hasOptions ? value.stopPropagation : stop;

                            if (shouldPrevent && prevent) { prevent.apply(e); }
                            if (shouldStop && stop) { stop.apply(e); }
                        }

                        // build the args for the event
                        var args = {
                            view: this,
                            model: this.model,
                            collection: this.collection
                        };

                        // trigger the event
                        this.triggerMethod(eventName, args);
                    };

                }, this);

                return triggerEvents;
            },

            // Overriding Backbone.View's delegateEvents to handle
            // the `triggers`, `modelEvents`, and `collectionEvents` configuration
            delegateEvents: function (events) {
                this._delegateDOMEvents(events);
                Marionette.bindEntityEvents(this, this.model, Marionette.getOption(this, "modelEvents"));
                Marionette.bindEntityEvents(this, this.collection, Marionette.getOption(this, "collectionEvents"));
            },

            // internal method to delegate DOM events and triggers
            _delegateDOMEvents: function (events) {
                events = events || this.events;
                if (_.isFunction(events)) { events = events.call(this); }

                var combinedEvents = {};
                var triggers = this.configureTriggers();
                _.extend(combinedEvents, events, triggers);

                Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
            },

            // Overriding Backbone.View's undelegateEvents to handle unbinding
            // the `triggers`, `modelEvents`, and `collectionEvents` config
            undelegateEvents: function () {
                var args = Array.prototype.slice.call(arguments);
                Backbone.View.prototype.undelegateEvents.apply(this, args);

                Marionette.unbindEntityEvents(this, this.model, Marionette.getOption(this, "modelEvents"));
                Marionette.unbindEntityEvents(this, this.collection, Marionette.getOption(this, "collectionEvents"));
            },

            // Internal method, handles the `show` event.
            onShowCalled: function () {},

            // Default `close` implementation, for removing a view from the
            // DOM and unbinding it. Regions will call this method
            // for you. You can specify an `onClose` method in your view to
            // add custom code that is called after the view is closed.
            close: function () {
                if (this.isClosed) { return; }

                // allow the close to be stopped by returning `false`
                // from the `onBeforeClose` method
                var shouldClose = this.triggerMethod("before:close");
                if (shouldClose === false) {
                    return;
                }

                // mark as closed before doing the actual close, to
                // prevent infinite loops within "close" event handlers
                // that are trying to close other views
                this.isClosed = true;
                this.triggerMethod("close");

                // unbind UI elements
                this.unbindUIElements();

                // remove the view from the DOM
                this.remove();
            },

            // This method binds the elements specified in the "ui" hash inside the view's code with
            // the associated jQuery selectors.
            bindUIElements: function () {
                if (!this.ui) { return; }

                // store the ui hash in _uiBindings so they can be reset later
                // and so re-rendering the view will be able to find the bindings
                if (!this._uiBindings) {
                    this._uiBindings = this.ui;
                }

                // get the bindings result, as a function or otherwise
                var bindings = _.result(this, "_uiBindings");

                // empty the ui so we don't have anything to start with
                this.ui = {};

                // bind each of the selectors
                _.each(_.keys(bindings), function (key) {
                    var selector = bindings[key];
                    this.ui[key] = this.$(selector);
                }, this);
            },

            // This method unbinds the elements specified in the "ui" hash
            unbindUIElements: function () {
                if (!this.ui || !this._uiBindings) { return; }

                // delete all of the existing ui bindings
                _.each(this.ui, function ($el, name) {
                    delete this.ui[name];
                }, this);

                // reset the ui element to the original bindings configuration
                this.ui = this._uiBindings;
                delete this._uiBindings;
            }
        });

        // Item View
        // ---------

        // A single item view implementation that contains code for rendering
        // with underscore.js templates, serializing the view's model or collection,
        // and calling several methods on extended views, such as `onRender`.
        Marionette.ItemView = Marionette.View.extend({

            // Setting up the inheritance chain which allows changes to
            // Marionette.View.prototype.constructor which allows overriding
            constructor: function () {
                Marionette.View.prototype.constructor.apply(this, slice(arguments));
            },

            // Serialize the model or collection for the view. If a model is
            // found, `.toJSON()` is called. If a collection is found, `.toJSON()`
            // is also called, but is used to populate an `items` array in the
            // resulting data. If both are found, defaults to the model.
            // You can override the `serializeData` method in your own view
            // definition, to provide custom serialization for your view's data.
            serializeData: function () {
                var data = {};

                if (this.model) {
                    data = this.model.toJSON();
                }
                else if (this.collection) {
                    data = {items: this.collection.toJSON()};
                }

                return data;
            },

            // Render the view, defaulting to underscore.js templates.
            // You can override this in your view definition to provide
            // a very specific rendering for your view. In general, though,
            // you should override the `Marionette.Renderer` object to
            // change how Marionette renders views.
            render: function () {
                this.isClosed = false;

                this.triggerMethod("before:render", this);
                this.triggerMethod("item:before:render", this);

                var data = this.serializeData();
                data = this.mixinTemplateHelpers(data);

                var template = this.getTemplate();
                var html = Marionette.Renderer.render(template, data);

                this.$el.html(html);
                this.bindUIElements();

                this.triggerMethod("render", this);
                this.triggerMethod("item:rendered", this);

                return this;
            },

            // Override the default close event to add a few
            // more events that are triggered.
            close: function () {
                if (this.isClosed) { return; }

                this.triggerMethod('item:before:close');

                Marionette.View.prototype.close.apply(this, slice(arguments));

                this.triggerMethod('item:closed');
            }
        });

        // Collection View
        // ---------------

        // A view that iterates over a Backbone.Collection
        // and renders an individual ItemView for each model.
        Marionette.CollectionView = Marionette.View.extend({
            // used as the prefix for item view events
            // that are forwarded through the collectionview
            itemViewEventPrefix: "itemview",

            // constructor
            constructor: function (options) {
                this._initChildViewStorage();

                Marionette.View.prototype.constructor.apply(this, slice(arguments));

                this._initialEvents();
                this.initRenderBuffer();
            },

            // Instead of inserting elements one by one into the page,
            // it's much more performant to insert elements into a document
            // fragment and then insert that document fragment into the page
            initRenderBuffer: function () {
                this.elBuffer = document.createDocumentFragment();
            },

            startBuffering: function () {
                this.initRenderBuffer();
                this.isBuffering = true;
            },

            endBuffering: function () {
                this.appendBuffer(this, this.elBuffer);
                this.initRenderBuffer();
                this.isBuffering = false;
            },

            // Configured the initial events that the collection view
            // binds to. Override this method to prevent the initial
            // events, or to add your own initial events.
            _initialEvents: function () {
                if (this.collection) {
                    this.listenTo(this.collection, "add", this.addChildView, this);
                    this.listenTo(this.collection, "remove", this.removeItemView, this);
                    this.listenTo(this.collection, "reset", this.render, this);
                }
            },

            // Handle a child item added to the collection
            addChildView: function (item, collection, options) {
                this.closeEmptyView();
                var ItemView = this.getItemView(item);
                var index = this.collection.indexOf(item);
                this.addItemView(item, ItemView, index);
            },

            // Override from `Marionette.View` to guarantee the `onShow` method
            // of child views is called.
            onShowCalled: function () {
                this.children.each(function (child) {
                    Marionette.triggerMethod.call(child, "show");
                });
            },

            // Internal method to trigger the before render callbacks
            // and events
            triggerBeforeRender: function () {
                this.triggerMethod("before:render", this);
                this.triggerMethod("collection:before:render", this);
            },

            // Internal method to trigger the rendered callbacks and
            // events
            triggerRendered: function () {
                this.triggerMethod("render", this);
                this.triggerMethod("collection:rendered", this);
            },

            // Render the collection of items. Override this method to
            // provide your own implementation of a render function for
            // the collection view.
            render: function () {
                this.isClosed = false;
                this.triggerBeforeRender();
                this._renderChildren();
                this.triggerRendered();
                return this;
            },

            // Internal method. Separated so that CompositeView can have
            // more control over events being triggered, around the rendering
            // process
            _renderChildren: function () {
                this.startBuffering();

                this.closeEmptyView();
                this.closeChildren();

                if (this.collection && this.collection.length > 0) {
                    this.showCollection();
                }
                else {
                    this.showEmptyView();
                }

                this.endBuffering();
            },

            // Internal method to loop through each item in the
            // collection view and show it
            showCollection: function () {
                var ItemView;
                this.collection.each(function (item, index) {
                    ItemView = this.getItemView(item);
                    this.addItemView(item, ItemView, index);
                }, this);
            },

            // Internal method to show an empty view in place of
            // a collection of item views, when the collection is
            // empty
            showEmptyView: function () {
                var EmptyView = this.getEmptyView();

                if (EmptyView && !this._showingEmptyView) {
                    this._showingEmptyView = true;
                    var model = new Backbone.Model();
                    this.addItemView(model, EmptyView, 0);
                }
            },

            // Internal method to close an existing emptyView instance
            // if one exists. Called when a collection view has been
            // rendered empty, and then an item is added to the collection.
            closeEmptyView: function () {
                if (this._showingEmptyView) {
                    this.closeChildren();
                    delete this._showingEmptyView;
                }
            },

            // Retrieve the empty view type
            getEmptyView: function () {
                return Marionette.getOption(this, "emptyView");
            },

            // Retrieve the itemView type, either from `this.options.itemView`
            // or from the `itemView` in the object definition. The "options"
            // takes precedence.
            getItemView: function (item) {
                var itemView = Marionette.getOption(this, "itemView");

                if (!itemView) {
                    throwError("An `itemView` must be specified", "NoItemViewError");
                }

                return itemView;
            },

            // Render the child item's view and add it to the
            // HTML for the collection view.
            addItemView: function (item, ItemView, index) {
                // get the itemViewOptions if any were specified
                var itemViewOptions = Marionette.getOption(this, "itemViewOptions");
                if (_.isFunction(itemViewOptions)) {
                    itemViewOptions = itemViewOptions.call(this, item, index);
                }

                // build the view
                var view = this.buildItemView(item, ItemView, itemViewOptions);

                // set up the child view event forwarding
                this.addChildViewEventForwarding(view);

                // this view is about to be added
                this.triggerMethod("before:item:added", view);

                // Store the child view itself so we can properly
                // remove and/or close it later
                this.children.add(view);

                // Render it and show it
                this.renderItemView(view, index);

                // call the "show" method if the collection view
                // has already been shown
                if (this._isShown) {
                    Marionette.triggerMethod.call(view, "show");
                }

                // this view was added
                this.triggerMethod("after:item:added", view);
            },

            // Set up the child view event forwarding. Uses an "itemview:"
            // prefix in front of all forwarded events.
            addChildViewEventForwarding: function (view) {
                var prefix = Marionette.getOption(this, "itemViewEventPrefix");

                // Forward all child item view events through the parent,
                // prepending "itemview:" to the event name
                this.listenTo(view, "all", function () {
                    var args = slice(arguments);
                    args[0] = prefix + ":" + args[0];
                    args.splice(1, 0, view);

                    Marionette.triggerMethod.apply(this, args);
                }, this);
            },

            // render the item view
            renderItemView: function (view, index) {
                view.render();
                this.appendHtml(this, view, index);
            },

            // Build an `itemView` for every model in the collection.
            buildItemView: function (item, ItemViewType, itemViewOptions) {
                var options = _.extend({model: item}, itemViewOptions);
                return new ItemViewType(options);
            },

            // get the child view by item it holds, and remove it
            removeItemView: function (item) {
                var view = this.children.findByModel(item);
                this.removeChildView(view);
                this.checkEmpty();
            },

            // Remove the child view and close it
            removeChildView: function (view) {

                // shut down the child view properly,
                // including events that the collection has from it
                if (view) {
                    this.stopListening(view);

                    // call 'close' or 'remove', depending on which is found
                    if (view.close) { view.close(); }
                    else if (view.remove) { view.remove(); }

                    this.children.remove(view);
                }

                this.triggerMethod("item:removed", view);
            },

            // helper to show the empty view if the collection is empty
            checkEmpty: function () {
                // check if we're empty now, and if we are, show the
                // empty view
                if (!this.collection || this.collection.length === 0) {
                    this.showEmptyView();
                }
            },

            // You might need to override this if you've overridden appendHtml
            appendBuffer: function (collectionView, buffer) {
                collectionView.$el.append(buffer);
            },

            // Append the HTML to the collection's `el`.
            // Override this method to do something other
            // then `.append`.
            appendHtml: function (collectionView, itemView, index) {
                if (collectionView.isBuffering) {
                    // buffering happens on reset events and initial renders
                    // in order to reduce the number of inserts into the
                    // document, which are expensive.
                    collectionView.elBuffer.appendChild(itemView.el);
                }
                else {
                    // If we've already rendered the main collection, just
                    // append the new items directly into the element.
                    collectionView.$el.append(itemView.el);
                }
            },

            // Internal method to set up the `children` object for
            // storing all of the child views
            _initChildViewStorage: function () {
                /////////// Modified by Atlassian ///////////
                this.children = new BackboneChildViewContainer();
                /////// End of Atlassian modification ///////
            },

            // Handle cleanup and other closing needs for
            // the collection of views.
            close: function () {
                if (this.isClosed) { return; }

                this.triggerMethod("collection:before:close");
                this.closeChildren();
                this.triggerMethod("collection:closed");

                Marionette.View.prototype.close.apply(this, slice(arguments));
            },

            // Close the child views that this collection view
            // is holding on to, if any
            closeChildren: function () {
                this.children.each(function (child) {
                    this.removeChildView(child);
                }, this);
                this.checkEmpty();
            }
        });


        // Composite View
        // --------------

        // Used for rendering a branch-leaf, hierarchical structure.
        // Extends directly from CollectionView and also renders an
        // an item view as `modelView`, for the top leaf
        Marionette.CompositeView = Marionette.CollectionView.extend({

            // Setting up the inheritance chain which allows changes to
            // Marionette.CollectionView.prototype.constructor which allows overriding
            constructor: function () {
                Marionette.CollectionView.prototype.constructor.apply(this, slice(arguments));
            },

            // Configured the initial events that the composite view
            // binds to. Override this method to prevent the initial
            // events, or to add your own initial events.
            _initialEvents: function () {

                // Bind only after composite view in rendered to avoid adding child views
                // to unexisting itemViewContainer
                this.once('render', function () {
                    if (this.collection) {
                        this.listenTo(this.collection, "add", this.addChildView, this);
                        this.listenTo(this.collection, "remove", this.removeItemView, this);
                        this.listenTo(this.collection, "reset", this._renderChildren, this);
                    }
                });

            },

            // Retrieve the `itemView` to be used when rendering each of
            // the items in the collection. The default is to return
            // `this.itemView` or Marionette.CompositeView if no `itemView`
            // has been defined
            getItemView: function (item) {
                var itemView = Marionette.getOption(this, "itemView") || this.constructor;

                if (!itemView) {
                    throwError("An `itemView` must be specified", "NoItemViewError");
                }

                return itemView;
            },

            // Serialize the collection for the view.
            // You can override the `serializeData` method in your own view
            // definition, to provide custom serialization for your view's data.
            serializeData: function () {
                var data = {};

                if (this.model) {
                    data = this.model.toJSON();
                }

                return data;
            },

            // Renders the model once, and the collection once. Calling
            // this again will tell the model's view to re-render itself
            // but the collection will not re-render.
            render: function () {
                this.isRendered = true;
                this.isClosed = false;
                this.resetItemViewContainer();

                this.triggerBeforeRender();
                var html = this.renderModel();
                this.$el.html(html);
                // the ui bindings is done here and not at the end of render since they
                // will not be available until after the model is rendered, but should be
                // available before the collection is rendered.
                this.bindUIElements();
                this.triggerMethod("composite:model:rendered");

                this._renderChildren();

                this.triggerMethod("composite:rendered");
                this.triggerRendered();
                return this;
            },

            _renderChildren: function () {
                if (this.isRendered) {
                    Marionette.CollectionView.prototype._renderChildren.call(this);
                    this.triggerMethod("composite:collection:rendered");
                }
            },

            // Render an individual model, if we have one, as
            // part of a composite view (branch / leaf). For example:
            // a treeview.
            renderModel: function () {
                var data = {};
                data = this.serializeData();
                data = this.mixinTemplateHelpers(data);

                var template = this.getTemplate();
                return Marionette.Renderer.render(template, data);
            },


            // You might need to override this if you've overridden appendHtml
            appendBuffer: function (compositeView, buffer) {
                var $container = this.getItemViewContainer(compositeView);
                $container.append(buffer);
            },

            // Appends the `el` of itemView instances to the specified
            // `itemViewContainer` (a jQuery selector). Override this method to
            // provide custom logic of how the child item view instances have their
            // HTML appended to the composite view instance.
            appendHtml: function (compositeView, itemView, index) {
                if (compositeView.isBuffering) {
                    compositeView.elBuffer.appendChild(itemView.el);
                }
                else {
                    // If we've already rendered the main collection, just
                    // append the new items directly into the element.
                    var $container = this.getItemViewContainer(compositeView);
                    $container.append(itemView.el);
                }
            },


            // Internal method to ensure an `$itemViewContainer` exists, for the
            // `appendHtml` method to use.
            getItemViewContainer: function (containerView) {
                if ("$itemViewContainer" in containerView) {
                    return containerView.$itemViewContainer;
                }

                var container;
                var itemViewContainer = Marionette.getOption(containerView, "itemViewContainer");
                if (itemViewContainer) {

                    var selector = _.isFunction(itemViewContainer) ? itemViewContainer() : itemViewContainer;
                    container = containerView.$(selector);
                    if (container.length <= 0) {
                        throwError("The specified `itemViewContainer` was not found: " + containerView.itemViewContainer, "ItemViewContainerMissingError");
                    }

                }
                else {
                    container = containerView.$el;
                }

                containerView.$itemViewContainer = container;
                return container;
            },

            // Internal method to reset the `$itemViewContainer` on render
            resetItemViewContainer: function () {
                if (this.$itemViewContainer) {
                    delete this.$itemViewContainer;
                }
            }
        });


        // Layout
        // ------

        // Used for managing application layouts, nested layouts and
        // multiple regions within an application or sub-application.
        //
        // A specialized view type that renders an area of HTML and then
        // attaches `Region` instances to the specified `regions`.
        // Used for composite view management and sub-application areas.
        Marionette.Layout = Marionette.ItemView.extend({
            regionType: Marionette.Region,

            // Ensure the regions are available when the `initialize` method
            // is called.
            constructor: function (options) {
                options = options || {};

                this._firstRender = true;
                this._initializeRegions(options);

                Marionette.ItemView.prototype.constructor.call(this, options);
            },

            // Layout's render will use the existing region objects the
            // first time it is called. Subsequent calls will close the
            // views that the regions are showing and then reset the `el`
            // for the regions to the newly rendered DOM elements.
            render: function () {

                if (this.isClosed) {
                    // a previously closed layout means we need to
                    // completely re-initialize the regions
                    this._initializeRegions();
                }
                if (this._firstRender) {
                    // if this is the first render, don't do anything to
                    // reset the regions
                    this._firstRender = false;
                }
                else if (!this.isClosed) {
                    // If this is not the first render call, then we need to
                    // re-initializing the `el` for each region
                    this._reInitializeRegions();
                }

                var args = Array.prototype.slice.apply(arguments);
                var result = Marionette.ItemView.prototype.render.apply(this, args);

                return result;
            },

            // Handle closing regions, and then close the view itself.
            close: function () {
                if (this.isClosed) { return; }
                this.regionManager.close();
                var args = Array.prototype.slice.apply(arguments);
                Marionette.ItemView.prototype.close.apply(this, args);
            },

            // Add a single region, by name, to the layout
            addRegion: function (name, definition) {
                var regions = {};
                regions[name] = definition;
                return this._buildRegions(regions)[name];
            },

            // Add multiple regions as a {name: definition, name2: def2} object literal
            addRegions: function (regions) {
                this.regions = _.extend({}, this.regions, regions);
                return this._buildRegions(regions);
            },

            // Remove a single region from the Layout, by name
            removeRegion: function (name) {
                delete this.regions[name];
                return this.regionManager.removeRegion(name);
            },

            // internal method to build regions
            _buildRegions: function (regions) {
                var that = this;

                var defaults = {
                    regionType: Marionette.getOption(this, "regionType"),
                    parentEl: function () { return that.$el; }
                };

                return this.regionManager.addRegions(regions, defaults);
            },

            // Internal method to initialize the regions that have been defined in a
            // `regions` attribute on this layout.
            _initializeRegions: function (options) {
                var regions;
                this._initRegionManager();

                if (_.isFunction(this.regions)) {
                    regions = this.regions(options);
                }
                else {
                    regions = this.regions || {};
                }

                this.addRegions(regions);
            },

            // Internal method to re-initialize all of the regions by updating the `el` that
            // they point to
            _reInitializeRegions: function () {
                this.regionManager.closeRegions();
                this.regionManager.each(function (region) {
                    region.reset();
                });
            },

            // Internal method to initialize the region manager
            // and all regions in it
            _initRegionManager: function () {
                this.regionManager = new Marionette.RegionManager();

                this.listenTo(this.regionManager, "region:add", function (name, region) {
                    this[name] = region;
                    this.trigger("region:add", name, region);
                });

                this.listenTo(this.regionManager, "region:remove", function (name, region) {
                    delete this[name];
                    this.trigger("region:remove", name, region);
                });
            }
        });


        // AppRouter
        // ---------

        // Reduce the boilerplate code of handling route events
        // and then calling a single method on another object.
        // Have your routers configured to call the method on
        // your object, directly.
        //
        // Configure an AppRouter with `appRoutes`.
        //
        // App routers can only take one `controller` object.
        // It is recommended that you divide your controller
        // objects in to smaller pieces of related functionality
        // and have multiple routers / controllers, instead of
        // just one giant router and controller.
        //
        // You can also add standard routes to an AppRouter.

        Marionette.AppRouter = Backbone.Router.extend({

            constructor: function (options) {
                Backbone.Router.prototype.constructor.apply(this, slice(arguments));

                this.options = options || {};

                var appRoutes = Marionette.getOption(this, "appRoutes");
                var controller = this._getController();
                this.processAppRoutes(controller, appRoutes);
            },

            // Similar to route method on a Backbone Router but
            // method is called on the controller
            appRoute: function (route, methodName) {
                var controller = this._getController();
                this._addAppRoute(controller, route, methodName);
            },

            // Internal method to process the `appRoutes` for the
            // router, and turn them in to routes that trigger the
            // specified method on the specified `controller`.
            processAppRoutes: function (controller, appRoutes) {
                if (!appRoutes) { return; }

                var routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes

                _.each(routeNames, function (route) {
                    this._addAppRoute(controller, route, appRoutes[route]);
                }, this);
            },

            _getController: function () {
                return Marionette.getOption(this, "controller");
            },

            _addAppRoute: function (controller, route, methodName) {
                var method = controller[methodName];

                if (!method) {
                    throw new Error("Method '" + methodName + "' was not found on the controller");
                }

                this.route(route, methodName, _.bind(method, controller));
            }
        });


        // Application
        // -----------

        // Contain and manage the composite application as a whole.
        // Stores and starts up `Region` objects, includes an
        // event aggregator as `app.vent`
        Marionette.Application = function (options) {
            this._initRegionManager();
            this._initCallbacks = new Marionette.Callbacks();
            /////////// Modified by Atlassian ///////////
            this.vent = new BackboneWreqr.EventAggregator();
            this.commands = new BackboneWreqr.Commands();
            this.reqres = new BackboneWreqr.RequestResponse();
            /////// End of Atlassian modification ///////
            this.submodules = {};

            _.extend(this, options);

            this.triggerMethod = Marionette.triggerMethod;
        };

        _.extend(Marionette.Application.prototype, Backbone.Events, {
            // Command execution, facilitated by Backbone.Wreqr.Commands
            execute: function () {
                var args = Array.prototype.slice.apply(arguments);
                this.commands.execute.apply(this.commands, args);
            },

            // Request/response, facilitated by Backbone.Wreqr.RequestResponse
            request: function () {
                var args = Array.prototype.slice.apply(arguments);
                return this.reqres.request.apply(this.reqres, args);
            },

            // Add an initializer that is either run at when the `start`
            // method is called, or run immediately if added after `start`
            // has already been called.
            addInitializer: function (initializer) {
                this._initCallbacks.add(initializer);
            },

            // kick off all of the application's processes.
            // initializes all of the regions that have been added
            // to the app, and runs all of the initializer functions
            start: function (options) {
                this.triggerMethod("initialize:before", options);
                this._initCallbacks.run(options, this);
                this.triggerMethod("initialize:after", options);

                this.triggerMethod("start", options);
            },

            // Add regions to your app.
            // Accepts a hash of named strings or Region objects
            // addRegions({something: "#someRegion"})
            // addRegions({something: Region.extend({el: "#someRegion"}) });
            addRegions: function (regions) {
                return this._regionManager.addRegions(regions);
            },

            // Close all regions in the app, without removing them
            closeRegions: function () {
                this._regionManager.closeRegions();
            },

            // Removes a region from your app, by name
            // Accepts the regions name
            // removeRegion('myRegion')
            removeRegion: function (region) {
                this._regionManager.removeRegion(region);
            },

            // Provides alternative access to regions
            // Accepts the region name
            // getRegion('main')
            getRegion: function (region) {
                return this._regionManager.get(region);
            },

            // Create a module, attached to the application
            module: function (moduleNames, moduleDefinition) {
                // slice the args, and add this application object as the
                // first argument of the array
                var args = slice(arguments);
                args.unshift(this);

                // see the Marionette.Module object for more information
                return Marionette.Module.create.apply(Marionette.Module, args);
            },

            // Internal method to set up the region manager
            _initRegionManager: function () {
                this._regionManager = new Marionette.RegionManager();

                this.listenTo(this._regionManager, "region:add", function (name, region) {
                    this[name] = region;
                });

                this.listenTo(this._regionManager, "region:remove", function (name, region) {
                    delete this[name];
                });
            }
        });

        // Copy the `extend` function used by Backbone's classes
        Marionette.Application.extend = Marionette.extend;

        // Module
        // ------

        // A simple module system, used to create privacy and encapsulation in
        // Marionette applications
        Marionette.Module = function (moduleName, app) {
            this.moduleName = moduleName;

            // store sub-modules
            this.submodules = {};

            this._setupInitializersAndFinalizers();

            // store the configuration for this module
            this.app = app;
            this.startWithParent = true;

            this.triggerMethod = Marionette.triggerMethod;
        };

        // Extend the Module prototype with events / listenTo, so that the module
        // can be used as an event aggregator or pub/sub.
        _.extend(Marionette.Module.prototype, Backbone.Events, {

            // Initializer for a specific module. Initializers are run when the
            // module's `start` method is called.
            addInitializer: function (callback) {
                this._initializerCallbacks.add(callback);
            },

            // Finalizers are run when a module is stopped. They are used to teardown
            // and finalize any variables, references, events and other code that the
            // module had set up.
            addFinalizer: function (callback) {
                this._finalizerCallbacks.add(callback);
            },

            // Start the module, and run all of its initializers
            start: function (options) {
                // Prevent re-starting a module that is already started
                if (this._isInitialized) { return; }

                // start the sub-modules (depth-first hierarchy)
                _.each(this.submodules, function (mod) {
                    // check to see if we should start the sub-module with this parent
                    if (mod.startWithParent) {
                        mod.start(options);
                    }
                });

                // run the callbacks to "start" the current module
                this.triggerMethod("before:start", options);

                this._initializerCallbacks.run(options, this);
                this._isInitialized = true;

                this.triggerMethod("start", options);
            },

            // Stop this module by running its finalizers and then stop all of
            // the sub-modules for this module
            stop: function () {
                // if we are not initialized, don't bother finalizing
                if (!this._isInitialized) { return; }
                this._isInitialized = false;

                Marionette.triggerMethod.call(this, "before:stop");

                // stop the sub-modules; depth-first, to make sure the
                // sub-modules are stopped / finalized before parents
                _.each(this.submodules, function (mod) { mod.stop(); });

                // run the finalizers
                this._finalizerCallbacks.run(undefined, this);

                // reset the initializers and finalizers
                this._initializerCallbacks.reset();
                this._finalizerCallbacks.reset();

                Marionette.triggerMethod.call(this, "stop");
            },

            // Configure the module with a definition function and any custom args
            // that are to be passed in to the definition function
            addDefinition: function (moduleDefinition, customArgs) {
                this._runModuleDefinition(moduleDefinition, customArgs);
            },

            // Internal method: run the module definition function with the correct
            // arguments
            _runModuleDefinition: function (definition, customArgs) {
                if (!definition) { return; }

                // build the correct list of arguments for the module definition
                var args = _.flatten([
                    this,
                    this.app,
                    Backbone,
                    Marionette,
                    Marionette.$, _,
                    customArgs
                ]);

                definition.apply(this, args);
            },

            // Internal method: set up new copies of initializers and finalizers.
            // Calling this method will wipe out all existing initializers and
            // finalizers.
            _setupInitializersAndFinalizers: function () {
                this._initializerCallbacks = new Marionette.Callbacks();
                this._finalizerCallbacks = new Marionette.Callbacks();
            }
        });

        // Type methods to create modules
        _.extend(Marionette.Module, {

            // Create a module, hanging off the app parameter as the parent object.
            create: function (app, moduleNames, moduleDefinition) {
                var module = app;

                // get the custom args passed in after the module definition and
                // get rid of the module name and definition function
                var customArgs = slice(arguments);
                customArgs.splice(0, 3);

                // split the module names and get the length
                moduleNames = moduleNames.split(".");
                var length = moduleNames.length;

                // store the module definition for the last module in the chain
                var moduleDefinitions = [];
                moduleDefinitions[length - 1] = moduleDefinition;

                // Loop through all the parts of the module definition
                _.each(moduleNames, function (moduleName, i) {
                    var parentModule = module;
                    module = this._getModule(parentModule, moduleName, app);
                    this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs);
                }, this);

                // Return the last module in the definition chain
                return module;
            },

            _getModule: function (parentModule, moduleName, app, def, args) {
                // Get an existing module of this name if we have one
                var module = parentModule[moduleName];

                if (!module) {
                    // Create a new module if we don't have one
                    module = new Marionette.Module(moduleName, app);
                    parentModule[moduleName] = module;
                    // store the module on the parent
                    parentModule.submodules[moduleName] = module;
                }

                return module;
            },

            _addModuleDefinition: function (parentModule, module, def, args) {
                var fn;
                var startWithParent;

                if (_.isFunction(def)) {
                    // if a function is supplied for the module definition
                    fn = def;
                    startWithParent = true;

                }
                else if (_.isObject(def)) {
                    // if an object is supplied
                    fn = def.define;
                    startWithParent = def.startWithParent;

                }
                else {
                    // if nothing is supplied
                    startWithParent = true;
                }

                // add module definition if needed
                if (fn) {
                    module.addDefinition(fn, args);
                }

                // `and` the two together, ensuring a single `false` will prevent it
                // from starting with the parent
                module.startWithParent = module.startWithParent && startWithParent;

                // setup auto-start if needed
                if (module.startWithParent && !module.startWithParentIsConfigured) {

                    // only configure this once
                    module.startWithParentIsConfigured = true;

                    // add the module initializer config
                    parentModule.addInitializer(function (options) {
                        if (module.startWithParent) {
                            module.start(options);
                        }
                    });

                }

            }
        });


        return Marionette;
    })(this, Backbone, _);

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/marionette-1.4.1.js' */
define("jira/components/libs/marionette-1.4.1", [
    "atlassian/libs/factories/marionette-1.4.1",
    "jira/components/libs/backbone",
    "jira/components/libs/underscore"
], function(
    marionetteFactory,
    Backbone,
    _
) {
    "use strict";
    var Marionette = marionetteFactory(_, Backbone);

    return Marionette;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/mariontte-1.4.1-mixins/Mixins.js' */
define('jira/components/libs/marionette-1.4.1/mixins', ["require"], function(require) {
    "use strict";

    var _ = require("underscore");

    /**
     * @class JIRA.Marionette.Mixins
     */
    return {

        /**
         * Listen events from a source and rethrow them. By invoking this method, the current object
         * will listen (using {@link Backbone.Events.listenTo}) to those events and trigger them
         * (using {@link Backbone.Events.trigger}) with all the arguments.
         *
         * In other words, this method is a shorthand for:
         *
         *     this.listenTo(obj, "event", function(arg1, arg2, ...) {
         *         this.trigger("event", arg1, arg2, ...);
         *     }
         *
         * @param {Backbone.Events} source Object that will fire the events
         * @param {string|string[]} events Event or list of events to listen for
         */
        listenAndRethrow: function(source, events) {
            events = [].concat(events);
            _.each(events, function(event) {
                this.listenTo(source, event, function() {
                    this.trigger.apply(this, [event].concat(_.toArray(arguments)));
                }, this);
            }, this);
        },

        /**
         * Triggers a preventable event.
         *
         * The event will include an EventObject, and the handler can call
         * eventObject.preventDefault() to prevent the event.
         *
         * @param {string} eventName Name of the event being triggered.
         * @param {EventObject} [eventObject] EventObject used as template to
         * construct the actual EventObject used in the event.
         *
         * @returns {EventObject} EventObject passed to the event.
         *
         * Backported from our Marionette-2.1.0 mixins
         */
        triggerPreventable: function (eventName, eventObject) {
            /**
             * EventObject passed to preventable events
             * @typedef {Object} EventObject
             * @property {Object} emitter Original emitter of the event.
             * @property {boolean} isPrevented Whether the event has been prevented by the event handler.
             * @property {Function} preventDefault Syntax sugar for set the `isPrevented` value.
             */
            var event = _.defaults({}, eventObject || {}, {
                isPrevented: false,
                emitter: this,
                preventDefault: function () {
                    this.isPrevented = true;
                }
            });

            this.trigger(eventName, event);
            return event;
        }
    };
});
AJS.namespace("JIRA.Marionette.Mixins", null, require('jira/components/libs/marionette-1.4.1/mixins'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/mariontte-1.4.1-mixins/LinkRegion.js' */
define('jira/components/libs/marionette-1.4.1/linkregion', [
    'jira/components/libs/marionette-1.4.1'
], function(
    Marionette
) {
    "use strict";

    /**
     * @class JIRA.Marionette.LinkRegion
     * @extends Marionette.Region
     *
     * This type of region will render the view's children and set the view root element to the region itself.
     *
     *     <body>
     *       <div id="region"></div>
     *     </body>
     *
     *     var MainView = Marionette.ItemView.extend({
     *        template: function() {
     *            return '<div><p>Content</p></div>';
     *        }
     *     });
     *     var ContainerView = Marionette.Layout.extend({
     *      regions: {
     *         main: "#region", regionType: JIRA.Marionette.LinkRegion,
     *     });
     *     var view = new ContainerView();
     *     view.main(new MainView());
     *
     *     //It will generate
     *     <body>
     *       <div id="region">
     *         <p>Content</p>
     *       </div>
     *     </body>
     *
     *     //And the follow is true:
     *     view.$el.is(jQuery("#region"))
     *
     *
     * You can thin about this region as a container for views 'without container'. It will remove the view's root element
     * from the output, plus it will set the view's main element to the region element.
     *
     * For example, it is used by BodyView. Here the body template contains the regions for the left/right columns, where
     * the panels will be rendered. The list of panels is a view with a <div> as the root element, but we don't want that
     * <div> in the final output.
     *
     * This region is like {@link JIRA.Marionette.ReplaceRegion} but here we remove the view's root markup.
     */
    return Marionette.Region.extend({
        /**
         * Method used to open (i.e. inject a view) this region
         *
         * @param {Backbone.View} view View to inject
         */
        open: function(view) {
            this.$el.append(view.$el.children());
            view.setElement(this.$el);
        }
    });
});
AJS.namespace("JIRA.Marionette.LinkRegion", null, require('jira/components/libs/marionette-1.4.1/linkregion'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/mariontte-1.4.1-mixins/ReplaceRegion.js' */
define('jira/components/libs/marionette-1.4.1/replaceregion', [
    'jira/components/libs/marionette-1.4.1'
], function(
    Marionette
) {
    "use strict";

    /**
     * @class JIRA.Marionette.ReplaceRegion
     * @extends Marionette.Region
     *
     * This type of region will replace the region itself with a view. This Region is useful when the region markup should
     * not be present in the final DOM.
     *
     * With Marionette.Region:
     *
     *     <body>
     *       <div id="region"></div>
     *     </body>
     *
     *     var MainView = Marionette.ItemView.extend({
     *        template: function() {
     *            return '<section id="main"></section>';
     *        }
     *     });
     *     var ContainerView = Marionette.Layout.extend({
     *      regions: {
     *         main: "#region"
     *     });
     *     var view = new ContainerView();
     *     view.main(new MainView());
     *
     *     //Fails, it will generate
     *     <body>
     *       <div id="region">
     *         <section id="main"></section>
     *       </div>
     *     </body>
     *
     *
     * With JIRA.Marionette.ReplaceRegion:
     *
     *     var ContainerView = Marionette.Layout.extend({
     *      regions: {
     *         main: {selector: "#region", regionType: JIRA.Marionette.AppendRegion},
     *     });
     *
     *     //Works, it will generate
     *     <body>
     *       <section id="main"></section>
     *     </body>
     *
     *
     * Of course, this will destroy the original region markup. If you call addRegion() to add the same region again, it
     * won't work unless you restore the original markup.
     *
     * You can thin about this region as a 'transparent container' for views, as the markup for the region will disappear
     * when a view is rendered inside. For example, it is used by IssueView to render the body and headers. The IssueView
     * template contains placeholders for the Body/Header views, but we want those placeholders to be removed from the final
     * output.
     *
     * This region is like {@link JIRA.Marionette.LinkRegion} but here we remove the regions' markup.
     */
    return Marionette.Region.extend({
        open: function(view) {
            this.$el.replaceWith(view.el);
        }
    });
});
AJS.namespace("JIRA.Marionette.ReplaceRegion", null, require('jira/components/libs/marionette-1.4.1/replaceregion'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/mariontte-1.4.1-mixins/Controller.js' */
define('jira/components/libs/marionette-1.4.1/controller', [
    "jira/components/libs/marionette-1.4.1",
    'jira/components/libs/marionette-1.4.1/mixins',
    "underscore"
], function(
    Marionette,
    Mixins,
    _
) {
    "use strict";

    var Controller = Marionette.Controller.extend({});
    _.extend(Controller.prototype, Mixins);
    return Controller;
});
AJS.namespace("JIRA.Marionette.Controller", null, require('jira/components/libs/marionette-1.4.1/controller'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/mariontte-1.4.1-mixins/ItemView.js' */
define('jira/components/libs/marionette-1.4.1/itemview', [
    'jira/components/libs/marionette-1.4.1'
], function(
    Marionette
) {
    "use strict";

    /**
     * @class JIRA.Marionette.ItemView
     *
     * @extends JIRA.Libs.Marionette.ItemView
     */
    return Marionette.ItemView.extend({

        renderTemplate: function() {
            var data = this.serializeData();
            data = this.mixinTemplateHelpers(data);

            var template = this.getTemplate();
            var html = Marionette.Renderer.render(template, data);

            return Marionette.$(html);
        },

        applyToDom: function() {
            this.delegateEvents();
            this.bindUIElements();
            this.triggerMethod("applyToDom");
        },

        /**
         * This method unwraps the Backbone.View.
         *
         * By default, Backbone will create a <div> and render the template inside. By calling this
         * method, you can get rid of that <div>, so the main element in your template will be the
         * root element in your template.
         */
        unwrapTemplate: function() {
            if (this.$el.parent().length) {
                // If the template is already rendered in the page
                var children = this.$el.children();
                this.$el.replaceWith(children);
                this.setElement(children);
            } else {
                // If the template is in memory
                this.setElement(this.$el.children());
            }
        }
    });
});
AJS.namespace("JIRA.Marionette.ItemView", null, require('jira/components/libs/marionette-1.4.1/itemview'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/mariontte-1.4.1-mixins/CollectionView.js' */
define('jira/components/libs/marionette-1.4.1/collectionview', [
    "jira/components/libs/marionette-1.4.1",
    "jira/components/libs/marionette-1.4.1/itemview"
], function(
    Marionette,
    ItemView
) {
    "use strict";

    /**
     * @class JIRA.Marionette.CollectionView
     *
     * @extends JIRA.Libs.Marionette.CollectionView
     */
    return Marionette.CollectionView.extend({
        /**
         * Appends an itemView to a container in the specified position
         *
         * @param {jQuery} container Element where the itemView will be inserted
         * @param {JIRA.Libs.Marionette.View} itemView View being added
         * @param {number} index Position of the itemView
         */
        _appendHtmlWithIndex: function(container, itemView, index) {
            var children = container.children();
            var childrenLength = children.length;

            if (index <= 0) {
                // If we want to insert the element at the beginning, just prepend it.
                container.prepend(itemView.$el);
            } else if (!childrenLength || index >= childrenLength) {
                // If the collection has no children, or the desired position is bigger than the number of children,
                // append it to the end
                container.append(itemView.$el);
            } else {
                // Insert the child at the requested index
                itemView.$el.insertBefore(children.eq(index));
            }
        },

        /**
         * Appends an itemView to a collectionView in the specified position
         *
         * This method overwrites Marionette's default. The default implementation always appends
         * the itemView at the end, ignoring the index.
         *
         * See https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.collectionview.md#collectionviews-appendhtml
         *
         * @param {JIRA.Libs.Marionette.CollectionView} collectionView This view
         * @param {JIRA.Libs.Marionette.View} itemView View being added
         * @param {number} index Position of the itemView
         */
        appendHtml: function(collectionView, itemView, index) {
            this._appendHtmlWithIndex(collectionView.$el, itemView, index);
        },

        unwrapTemplate: function() {
            ItemView.prototype.unwrapTemplate.call(this);
        }
    });
});
AJS.namespace("JIRA.Marionette.CollectionView", null, require('jira/components/libs/marionette-1.4.1/collectionview'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/mariontte-1.4.1-mixins/CompositeView.js' */
define('jira/components/libs/marionette-1.4.1/compositeview', [
    "jira/components/libs/marionette-1.4.1",
    'jira/components/libs/marionette-1.4.1/collectionview',
    'jira/components/libs/marionette-1.4.1/itemview'
], function(
    Marionette,
    CollectionView,
    ItemView
) {
    "use strict";

    /**
     * @class JIRA.Marionette.CompositeView
     *
     * @extends JIRA.Libs.Marionette.CompositeView
     */
    return Marionette.CompositeView.extend({
        /**
         * Appends an itemView to a collectionView in the specified position
         *
         * This method overwrites Marionette's default. The default implementation always appends
         * the itemView at the end, ignoring the index.
         *
         * See https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.collectionview.md#collectionviews-appendhtml
         *
         * @param {JIRA.Libs.Marionette.CollectionView} collectionView This view
         * @param {JIRA.Libs.Marionette.View} itemView View being added
         * @param {number} index Position of the itemView
         */
        appendHtml: function(collectionView, itemView, index) {
            CollectionView.prototype._appendHtmlWithIndex(this.getItemViewContainer(collectionView), itemView, index);
        },

        unwrapTemplate: function() {
            ItemView.prototype.unwrapTemplate.call(this);
        }
    });
});
AJS.namespace("JIRA.Marionette.CompositeView", null, require('jira/components/libs/marionette-1.4.1/compositeview'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/mariontte-1.4.1-mixins/Layout.js' */
define('jira/components/libs/marionette-1.4.1/layout', [
    'jira/components/libs/marionette-1.4.1',
    'jira/components/libs/marionette-1.4.1/mixins',
    'underscore'
], function(
    Marionette,
    Mixins,
    _
) {
    "use strict";

    var Layout = Marionette.Layout.extend({
        applyToDom: function() {
            this.delegateEvents();
            this.bindUIElements();
            this._reInitializeRegions();
            this.triggerMethod("applyToDom");
        }
    });
    _.extend(Layout.prototype, Mixins);

    return Layout;
});
AJS.namespace("JIRA.Marionette.Layout", null, require('jira/components/libs/marionette-1.4.1/layout'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/mariontte-1.4.1-mixins/Application.js' */
define('jira/components/libs/marionette-1.4.1/application', [
    "jira/components/libs/marionette-1.4.1",
    "underscore"
], function(
    Marionette,
    _
) {
    "use strict";

    /**
     * @class JIRA.Marionette.Application
     * @extends Marionette.Application
     *
     * Main Application for JIRA.
     */
    return Marionette.Application.extend({
        /**
         * Override the constructor. We need this dumb method to be able to tests
         * the constructor.
         *
         * @constructor
         * @param {Object} [options] Options to pass to the real Application constructor.
         */
        constructor: function(options) {
            Marionette.Application.call(this, options);
        },

        /**
         * Starts the application
         *
         * @param {Object} [options] Object to pass to all initializer functions and initialize events.
         * @param {Object} [options.forceStop=true] Call stop() on all modules before starting them again.
         */
        start: function(options) {
            if (!options || options.forceStop !== false) {
                this.stop();
            }
            Marionette.Application.prototype.start.call(this, options);
        },

        /**
         * Stops all the modules
         */
        stop: function() {
            _.invoke(this.submodules, "stop");
        }
    });
});
AJS.namespace("JIRA.Marionette.Application", null, require('jira/components/libs/marionette-1.4.1/application'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/mariontte-1.4.1-mixins/AppModule.js' */
define('jira/components/libs/marionette-1.4.1/appmodule', [
    "jira/components/libs/marionette-1.4.1",
    'jira/components/libs/marionette-1.4.1/mixins',
    "underscore"
], function(
    Marionette,
    Mixins,
    _
) {
    "use strict";

    /**
     * @class AppModule
     * @abstract
     *
     * Base class for all AppModules. It provides a declarative way to set the commands, requests and events, decoupled
     * from the actual application where this module is being installed.
     *
     * An AppModule is a Marionette.Module that encapsulates a "native" module (i.e. a module designed to be constructed
     * using the new operator). The recommendation is to set command/requests for the module API, so others
     * Marionette.Modules's can use it in a decoupled way.
     *
     * @constructor
     */
    var AppModule = function() {
        // Ensure definition function is bound to the module
        this.definition = _.bind(this.definition, this);
    };

    // Add extend() functionality
    AppModule.extend = Marionette.extend;

    // Add methods to our prototype
    _.extend(AppModule.prototype, {

        /**
         * Creates the internal module. This method must be implemented by the descendant of this class.
         *
         * @abstract
         */
        create: function() {
            throw new Error("create() must be implemented by AppModules");
        },

        /**
         * whether this module will create a request that will return the internal module. This should be used only
         * for testing or for code that has not been completely migrated to Marionette Applications and Modules yet.
         *
         * @type {boolean}
         */
        generateMasterRequest: false,

        /**
         * Module name. Will be used as a prefix for all the commands/requests/events. For example, if the name is
         * 'myModule', all commands will be in the form 'myModule:*'. This property must be defined by each extending
         * module.
         *
         * @type {string}
         */
        name: "",

        /**
         * List of commands implemented by this module.
         *
         * The usual form is {commandName: function}. In this case, this module will implement a command named
         * '<this.name>:commandName', and function will be the handler.
         *
         *     MyModule = AppModule.extend({
         *          name: "myModule",
         *          commands: {
         *              "sayHello": function() {alert("Hello world");}
         *          }
         *     })
         *     MyApp.module("MyModule", new MyModule().definition);
         *     MyApp.execute("myModule:sayHello") //alerts "Hello world"
         *
         *
         * Calling the internal module
         * ---------------------------
         * This list can be an object, or a function that returns an object. In the function case, this function will
         * receive the internal module (created in create()) as argument.
         *
         *     myInternalModule = function() {}
         *     myInternalModule.prototype.getName = function() {return "Charlie";}
         *
         *     MyModule = AppModule.extend({
         *          name: "myModule",
         *          create: function() { return new myInternalModule(); },
         *          commands: function(internalModule) {
         *              return {
         *                  "sayHello": function() {alert(internalModule.getName());}
         *              }
         *          }
         *     })
         *     MyApp.module("MyModule", new MyModule().definition);
         *     MyApp.execute("myModule:sayHello") //alerts "Charlie"
         *
         *
         * Calling the internal module API
         * -------------------------------
         * If a command is just a call to the internal module API with the same name, AppModule provides a shortcut so you
         * don't need all the boilerplate. Just use 'true' as the value of the command, and it will call the method in
         * the internal module with the same name than the command.
         *
         *
         *     myInternalModule = function() {}
         *     myInternalModule.prototype.getName = function() {return alert("Charlie");}
         *
         *     MyModule = AppModule.extend({
         *          name: "myModule",
         *          create: function() { return new myInternalModule(); },
         *          commands: {
         *             "getName": true
         *          }
         *     })
         *
         *     MyApp.module("MyModule", new MyModule().definition);
         *     MyApp.execute("myModule:getName") //alerts "Charlie"
         *                                       //equivalent to invoking myInternalModule.getName()
         *
         * @type {Object|function}
         */
        commands: {},

        /**
         * Just like {@link commands}, but for defining requests.
         * @type {Object|function}
         */
        requests: {},

        /**
         * List of events this module will fire.
         *
         * This module will listen for the events named here fired in the internal module, and re-fire them with the prefix
         * this.name. All the events will include the original event arguments.
         *
         *     myInternalModule = function() {} //... your internal module
         *
         *     MyModule = AppModule.extend({
         *          name: "myModule",
         *          create: function() { return new myInternalModule(); },
         *          events: [
         *             "loaded"
         *          ]
         *     })
         *
         *     //MyModule will fire the event 'myModule:loaded' when myInternalModule fires the event 'loaded'
         *
         *
         * If the event name is an empty string, the event fired by MyModule will be just {@link name}
         *
         * @type {string[]}
         */
        events: [],

        /**
         * Definition for this module. This module will create the internal module and set all the events/commands/requests
         * used by this module. This is the function you need to pass to Application.module() to define a new module:
         *
         *      MyApp = new JIRA.Marionette.Application();
         *      MyApp.module("myModule", new MyModule().definition)
         *
         *
         * @param {JIRA.Libs.Marionette.Module} mod The module itself
         * @param {JIRA.Libs.Marionette.Application} app The Parent module, or Application object that .module was called from
         */
        definition: function(mod, app) {
            var prefix = this.name;
            var instance = this;
            if (!prefix) {
                throw new Error("'name' must be defined by AppModules");
            }

            // Generates the initializer used for this module. It will install all the commands and requests in the
            // application, and set the proper events.
            mod.addInitializer(function() {
                // Create the internal module
                var internalModule = instance.create.apply(instance, _.toArray(arguments));

                function generateCommands(commands) {
                    if (_.isFunction(commands)) {
                        commands = commands(internalModule);
                    }

                    var events = {};
                    _.each(commands, function(def, name) {
                        if (def === true) {
                            def = _.bind(internalModule[name], internalModule);
                        }
                        if (name && prefix) {
                            name = prefix + ":" + name;
                        } else {
                            name = prefix;
                        }
                        events[name] = def;
                    });

                    return events;
                }

                function generateEvents(app, events) {
                    if (_.isFunction(events)) {
                        events = events(internalModule);
                    }

                    _.each(events, function(originalName) {
                        var newName = prefix + ":" + originalName;
                        app.listenTo(internalModule, originalName, function() {
                            this.trigger.apply(this, [newName].concat(_.toArray(arguments)));
                        });
                    });
                }

                // Generate the commands and requests for this module.
                var commands = generateCommands(instance.commands);
                var requests = generateCommands(instance.requests);

                // Generate the master request for this module.
                if (instance.generateMasterRequest) {
                    _.extend(requests, generateCommands({
                        "": function() {
                            return internalModule;
                        }
                    }));
                }

                app.commands.setHandlers(commands);
                app.reqres.setHandlers(requests);
                generateEvents(app, instance.events);
            });
        }
    });
    _.extend(AppModule.prototype, Mixins);

    return AppModule;
});
AJS.namespace("JIRA.Marionette.AppModule", null, require('jira/components/libs/marionette-1.4.1/appmodule'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/mariontte-1.4.1-mixins/DialogView.js' */
define('jira/components/libs/marionette-1.4.1/dialogview', [
    'jira/components/libs/marionette-1.4.1',
    'jira/components/libs/marionette-1.4.1/itemview',
    'aui/message',
    'jira/dialog/form-dialog',
    'underscore',
    'jquery',
    'jira/ajs/ajax/smart-ajax',
    'jira/dialog/dialog'
], function(
    Marionette,
    ItemView,
    Messages,
    FormDialog,
    _,
    jQuery,
    SmartAjax,
    JIRADialog
) {
    "use strict";

    /**
     * @class JIRA.Marionette.DialogView
     * @abstract
     *
     * Wraps a JIRA.FormDialog in a Marionette view
     *
     * @extends JIRA.Marionette.ItemView
     */
    return ItemView.extend({

        /**
         * Internal JIRA.FormDialog instance.
         * @type {JIRA.FormDialog}
         */
        dialog: null,

        /**
         * Template used by this dialog.
         * @type {Function}
         */
        template: jQuery.noop,

        /**
         * Generates the internal JIRA.FormDialog.
         *
         * @returns {JIRA.FormDialog} The dialog.
         * @private
         */
        _generateDialog: function() {
            var data = this.serializeData();
            var template = this.getTemplate();
            var defaultDialogOptions = {
                id: this.id,
                content: function(cb) {
                    cb(template(data));
                },
                submitHandler: _.bind(this._generateSubmissionXHR, this)
            };
            var dialogOptions = Marionette.getOption(this, "dialogOptions");
            if (_.isFunction(dialogOptions)) {
                dialogOptions = dialogOptions.apply(this);
            }

            return new FormDialog(_.extend(defaultDialogOptions, dialogOptions));
        },

        /**
         * Main render method.
         *
         * @returns {JIRA.Libs.Marionette.DialogView} This view.
         */
        render: function() {
            this.isClosed = false;

            this.triggerMethod("before:render", this);

            this.dialog = this._generateDialog();
            this.dialog.show();
            this.$el = this.dialog.get$popup();

            jQuery(this.dialog).on("Dialog.hide", _.bind(function(e, popup, reason) {
                if (reason === JIRADialog.HIDE_REASON.cancel || reason === JIRADialog.HIDE_REASON.escape) {
                    this.close();
                }
            }, this));

            this.triggerMethod("render", this);

            return this;
        },

        close: function() {
            if (this.isClosed) {
                return;
            }

            var shouldClose = this.triggerMethod("before:close");
            if (shouldClose === false) {
                return;
            }

            jQuery(this.dialog).off("Dialog.hide");

            this.dialog.hide(true);
            this.dialog.destroy();
            this.isClosed = true;

            this.triggerMethod('close');

            // remove the view from the DOM
            this.remove();
        },

        /**
         * Constructs the XHR request used to submit the form data.
         *
         * @param {jQuery.Event} e Submit event.
         * @param {Function} ready  Callback to run when the form has been submitted.
         * @returns {jQuery.jqXHR} Request used to submit the form.
         * @private
         */
        _generateSubmissionXHR: function(e, ready) {
            e.preventDefault();

            var form = this.dialog.$form;
            var formData = Marionette.getOption(this, "formToRequestData");
            if (_.isFunction(formData)) {
                formData = formData.call(this, form);
            }

            var request = SmartAjax.makeRequest({
                type: form.attr("method"),
                url: form.attr('action'),
                contentType: 'application/json',
                dataType: "json",
                processData: false,
                data: JSON.stringify(formData)
            })
                .done(ready)
                .done(_.bind(this._onSubmitSuccess, this))
                .fail(_.bind(this._onSubmitError, this));

            return request;
        },

        /**
         * Handler for when the submission XHR has succeeded.
         *
         * @param {object} serverResponse Response returned by the server.
         * @private
         */
        _onSubmitSuccess: function(serverResponse) {
            this.triggerMethod('submit:success', serverResponse);
            this.close();
        },

        /**
         * Handler for when the submission XHR has failed.
         *
         * @param {jQuery.jqXHR} xhr XHR that failed.
         * @private
         */
        _onSubmitError: function(xhr) {
            this.dialog.getButtonsContainer().find('input').removeAttr('disabled');
            this.dialog.hideFooterLoadingIndicator();
            this.dialog.$form.removeClass("submitting");
            this._showErrorFromXHR(xhr);
            this.triggerMethod('submit:error');
        },

        /**
         * Display the errors related to fields (e.g. a field is required)
         *
         * @param {object} errors List of errors, in the form {fieldName: errorMessage}
         * @private
         */
        _displayFieldErrors: function(errors) {
            var popup = this.dialog.$popup;
            _.each(errors, function(message, fieldName) {
                popup.find("#" + fieldName).after("<div class='error'>" + AJS.escapeHTML(message) + "</div>");
            });
        },

        /**
         * Display the generic errors (e.g. the server returned a 500)
         *
         * @param {string[]} errorMessages List of error messages to show
         * @private
         */
        _displayGenericErrors: function(errorMessages) {
            var errorContainer = this.dialog.$popup.find(".aui-messages");

            _.each(errorMessages, function(message) {
                var messageOptions = {
                    closeable: true,
                    timeout: 5
                };
                messageOptions.body = AJS.escapeHTML(message);
                messageOptions.shadowed = false;
                Messages.error(errorContainer, messageOptions);
            });
        },

        /**
         * Display XHR errors (e.g. network timeout)
         *
         * @param {jQuery.jqXHR} xhr Request that caused the error
         * @private
         */
        _displayXHRErrors: function(xhr) {
            var errorContainer = this.dialog.$popup.find(".aui-messages");
            errorContainer.append(SmartAjax.buildDialogErrorContent(xhr, true));
        },

        /**
         * Generate errors from the XHR response and append them to the form
         *
         * @param {jQuery.jqXHR} xhr
         */
        _showErrorFromXHR: function(xhr) {
            this._removeErrorMessages();

            var errors;
            try {
                errors = JSON.parse(xhr.responseText);
            } catch (e) {
                errors = null;
            }

            if (errors) {
                this._displayFieldErrors(errors.errors);
                this._displayGenericErrors(errors.errorMessages);
            } else {
                this._displayXHRErrors(xhr);
            }
        },

        /**
         * @private
         */
        _removeErrorMessages: function() {
            // Remove field errors
            this.dialog.$popup.find(".error").remove();

            // Remove generic errors
            this.dialog.$popup.find(".aui-messages").empty();
        }
    });
});
AJS.namespace("JIRA.Marionette.DialogView", null, require('jira/components/libs/marionette-1.4.1/dialogview'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-1.4.1', location = 'libs/mariontte-1.4.1-mixins/InlineDialogView.js' */
define('jira/components/libs/marionette-1.4.1/inlinedialogview', [
    'jira/components/libs/marionette-1.4.1',
    'jira/components/libs/marionette-1.4.1/itemview',
    'underscore',
    'jquery'
], function(
    Marionette,
    ItemView,
    _,
    jQuery
) {
    "use strict";

    /**
     * @class JIRA.Marionette.InlineDialogView
     * @abstract
     *
     * Wraps a AJS.InlineDialog in a Marionette view
     *
     * @extends JIRA.Marionette.InlineDialogView
     */
    return ItemView.extend({

        /**
         * Internal AJS.InlineDialog instance.
         * @type {AJS.InlineDialog}
         */
        dialog: null,

        /**
         * Template used by this dialog.
         * @type {Function}
         */
        template: jQuery.noop,

        _getDialogOptions: function() {
            // Get dialog options
            var defaultDialogOptions = {
                noBind: true
            };

            var dialogOptions = Marionette.getOption(this, "dialogOptions") || {};
            if (_.isFunction(dialogOptions)) {
                dialogOptions = dialogOptions.apply(this);
            }

            dialogOptions = _.extend({}, defaultDialogOptions, dialogOptions);
            dialogOptions.hideCallback = _.bind(function() {
                this.close();
            }, this);

            return dialogOptions;
        },

        _getTrigger: function() {
            // Get dialog trigger
            var trigger = Marionette.getOption(this, "trigger");
            if (_.isFunction(trigger)) {
                trigger = trigger.apply(this);
            }
            return trigger;
        },

        /**
         * Generates the internal AJS.InlineDialog.
         *
         * @returns {AJS.InlineDialog} The dialog.
         * @private
         */
        _generateDialog: function() {
            var data = this.serializeData();
            var template = this.getTemplate();
            var dialogOptions = this._getDialogOptions();
            var trigger = this._getTrigger();

            return new AJS.InlineDialog(trigger, this.id, function($content, $triggerElement, showPopup) {
                $content.html(template(data));
                showPopup();
            }, dialogOptions);
        },

        /**
         * Main render method.
         *
         * @returns {JIRA.Libs.Marionette.DialogView} This view.
         */
        render: function() {
            this.isClosed = false;

            this.triggerMethod("before:render", this);

            this.dialog = this._generateDialog();
            this.$el = this.dialog;
            this.id = this.dialog.id;
            this.dialog.show();

            this.triggerMethod("render", this);

            return this;
        },

        close: function() {
            if (this.isClosed) {
                return;
            }

            var shouldClose = this.triggerMethod("before:close");
            if (shouldClose === false) {
                return;
            }

            this.dialog.hide();
            this.isClosed = true;

            this.triggerMethod('close');

            // remove the view from the DOM
            this.remove();
        }
    });
});

AJS.namespace("JIRA.Marionette.InlineDialogView", null, require('jira/components/libs/marionette-1.4.1/inlinedialogview'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:analytics-amd', location = 'issuenav-analytics/Analytics.js' */
define("jira/components/analytics", [
    "jira/components/libs/marionette-1.4.1/controller",
    "jira/components/analytics/services/trigger",
    "jira/components/analytics/services/domtracker",
    "underscore"
], function(
    MarionetteController,
    Trigger,
    DomTracker,
    _
) {
    "use strict";

    /**
     * @class JIRA.Components.Analytics
     *
     * This module provides the Analytics features. It provides two main features:
     *
     *    * Be able to trigger any arbitrary Analytic event, including extra properties.
     *    * Automatically trigger Analytic events when a DOM Event happens.
     *
     * @extends Marionette.Controller
     */
    return MarionetteController.extend({
        /**
         * @constructor
         *
         * @param {Object} options Options object
         * @param {boolean} options.useLog Whether this module should log events using AJS.log()
         */
        initialize: function(options) {
            this.triggerService = new Trigger(options);
            this.trackerService = new DomTracker(this.triggerService);
        },

        /**
         * Triggers an event, adding optional parameters. The event must have been registered using {@link registerEvent}
         * before triggering it. If not, the event will be silently discarded.
         *
         * @param {string} name Event to trigger
         * @param {Object} [parameters] Arbitrary data to include with the event
         */
        trigger: function(name, parameters) {
            this.triggerService.trigger(name, parameters);
        },

        /**
         * Registers an event. Events must be registered using this method prior firing them with
         * {@link trigger}
         *
         * This method accepts both a single tracker or an array of trackers.
         *
         * @param {string|string[]} event Event to register
         */
        registerEvent: function(event) {
            var events = [].concat(event);
            _.each(events, function(event) {
                this.triggerService.registerEvent(event);
            }, this);
        },

        /**
         * Registers a DOM tracker. A DOM tracker specifies a DOM event and the associated Analytic event. When the
         * DOM Event occurs, the analytic event is fired automatically.
         *
         * This method accepts both a single tracker or an array of trackers.
         *
         * @param {Object} tracker DOM Tracker
         * @param {string} tracker.name Analytic event name to fire
         * @param {string} tracker.selector Selector to use for detect the DOM event
         * @param {string} [tracker.type="click"] DOM Event to listen for
         * @param {Function} [tracker.handler] Handler for that event
         * @param {DOMElement} [tracker.context=document] Element used to listen for the event
         */
        registerTracker: function(tracker) {
            var trackers = [].concat(tracker);
            _.each(trackers, function(tracker) {
                this.trackerService.registerTracker(tracker);
            }, this);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:analytics-amd', location = 'issuenav-analytics/AnalyticsAppModule.js' */
define("jira/components/analytics/appmodule", [
    "jira/components/analytics",
    "underscore"
], function(
    Analytics,
    _
) {
    "use strict";

    var MarionetteAppModule = require('jira/components/libs/marionette-1.4.1/appmodule');

    return MarionetteAppModule.extend({
        name: "analytics",
        generateMasterRequest: true,

        /**
         * @param {Object} options Options object
         * @param {boolean} [options.useLog=false] Whether this module should log events using AJS.log()
         */
        create: function(options) {
            options = _.defaults({}, options, {
                useLog: false
            });

            return new Analytics(options);
        },

        commands: {
            trigger: true,
            registerEvent: true,
            registerTracker: true
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:analytics-amd', location = 'issuenav-analytics/services/Trigger.js' */
define("jira/components/analytics/services/trigger", ["require"], function(require) {
    "use strict";

    var MarionetteController = require('jira/components/libs/marionette-1.4.1/controller');
    var _ = require("underscore");

    /**
     * @class JIRA.Components.Analytics.Services.Trigger
     *
     * This service is responsible for triggering analytic events. It will inject the new events into the global array
     * AJS.EventQueue
     *
     * @extends Marionette.Controller
     */
    return MarionetteController.extend({
        /**
         * @param {Object} options Options object
         * @param {boolean} [options.useLog=false] Whether this module should log events using AJS.log()
         *
         * @constructor
         */
        initialize: function(options) {
            this.useLog = options.useLog;
            this.allowedEvents = [];
            this.startTime = new Date().getTime();
            this.pageSessionGuid = Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2);
        },

        /**
         * Triggers an event
         *
         * @param {string} name Name of the event
         * @param {Object} [parameters] Arbitrary data to include in the event
         */
        trigger: function(name, parameters) {
            // No EventQueue, nothing to do.
            if (!AJS.EventQueue) return;

            // Event has not been registered, ignore it.
            if (!_.contains(this.allowedEvents, name)) return;

            parameters = parameters || {};

            // Add GUID and time to the parameters
            /*eslint-disable camelcase*/
            parameters.context_pageSession = this.pageSessionGuid;
            parameters.context_pageTime = new Date().getTime() - this.startTime;
            /*eslint-enable camelcase*/

            // Register an analytics object for this event.
            AJS.EventQueue.push({name: name, properties: parameters});

            if (this.useLog) {
                var logMsg = "***** Analytics log [" + name + "]";
                logMsg += "[" + JSON.stringify(parameters) + "]";
                AJS.log(logMsg);
            }
        },

        /**
         * Registers an event. This allows this event to be triggered later.
         *
         * @param {string|string[]} name Event (or list of events) to register
         */
        registerEvent: function(name) {
            this.allowedEvents.push(name);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:analytics-amd', location = 'issuenav-analytics/services/DomTracker.js' */
define("jira/components/analytics/services/domtracker", ["require"], function(require) {
    "use strict";

    var MarionetteController = require('jira/components/libs/marionette-1.4.1/controller');
    var jQuery = require("jquery");
    var _ = require("underscore");

    /**
     * @class JIRA.Components.Analytics.Services.DomTracker
     *
     * This service is responsible for listening to DOM Trackers. A DOM Tracker is an event attached to the DOM
     * (usually to document) that will trigger an Analytic event when some DOM events happens.
     *
     * @extends Marionette.Controller
     */
    return MarionetteController.extend({
        /**
         * @constructor
         *
         * @param {JIRA.Components.Analytics.Services.Trigger} triggerService Service used for triggering the DOM events
         */
        initialize: function(triggerService) {
            this.triggerService = triggerService;
            this.trackers = [];
        },

        /**
         * Registers a DOM tracker.
         *
         * @param {Object} tracker
         * @param {string} tracker.name Analytic event name to fire
         * @param {string} tracker.selector Selector to use for detect the DOM event
         * @param {string} [tracker.type="click"] DOM Event to listen for
         * @param {Function} [tracker.handler] Handler for that event
         * @param {DOMElement} [tracker.context=document] Element used to listen for the event
         */
        registerTracker: function(tracker) {
            var triggerService = this.triggerService;

            // Set default values for the tracker
            _.defaults(tracker, {
                type: "click",
                handler: function(e, props) {
                    // This is a copy of the old ClientAnalytics code, but makes no sense to allow other handlers here
                    triggerService.trigger(this.name, props);
                },
                context: document
            });

            // Register the tracker
            triggerService.registerEvent(tracker.name);

            tracker.domHandler = function(e) {
                if (!e.preventFurtherAnalytics) {
                    // This is a copy of the old ClientAnalytics code, but this arguments call looks odd.
                    tracker.handler.apply(tracker, Array.prototype.slice.call(arguments));
                }
            };

            // Add the DOM tracker
            jQuery(tracker.context).on(tracker.type, tracker.selector, tracker.domHandler);

            this.trackers.push(tracker);
        },

        clear: function() {
            _.each(this.trackers, function(tracker) {
                jQuery(tracker.context).off(tracker.type, tracker.selector, tracker.domHandler);
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:analytics-ajs-namespace', location = 'issuenav-analytics/namespace.js' */
AJS.namespace("JIRA.Components.Analytics", null, require("jira/components/analytics"));
AJS.namespace("JIRA.Components.Analytics.AppModule", null, require("jira/components/analytics/appmodule"));
AJS.namespace("JIRA.Components.Analytics.Services.Trigger", null, require("jira/components/analytics/services/trigger"));
AJS.namespace("JIRA.Components.Analytics.Services.DomTracker", null, require("jira/components/analytics/services/domtracker"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:scrollintoview', location = 'lib/scrollintoview-1.8.js' */
/*!
 * jQuery scrollintoview() plugin and :scrollable selector filter
 *
 * Version 1.8 (14 Jul 2011)
 * Requires jQuery 1.4 or newer
 *
 * Copyright (c) 2011 Robert Koritnik
 * Licensed under the terms of the MIT license
 * http://www.opensource.org/licenses/mit-license.php
 */

(function ($) {
    var converter = {
        vertical: { x: false, y: true },
        horizontal: { x: true, y: false },
        both: { x: true, y: true },
        x: { x: true, y: false },
        y: { x: false, y: true }
    };

    var settings = {
        duration: 0,
        direction: "y"
    };

    var rootrx = /^(?:html)$/i;

    // gets border dimensions
    var borders = function (domElement, styles) {
        styles = styles || (document.defaultView && document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(domElement, null) : domElement.currentStyle);
        var px = document.defaultView && document.defaultView.getComputedStyle ? true : false;
        var b = {
            top: (parseFloat(px ? styles.borderTopWidth : $.css(domElement, "borderTopWidth")) || 0),
            left: (parseFloat(px ? styles.borderLeftWidth : $.css(domElement, "borderLeftWidth")) || 0),
            bottom: (parseFloat(px ? styles.borderBottomWidth : $.css(domElement, "borderBottomWidth")) || 0),
            right: (parseFloat(px ? styles.borderRightWidth : $.css(domElement, "borderRightWidth")) || 0)
        };
        return {
            top: b.top,
            left: b.left,
            bottom: b.bottom,
            right: b.right,
            vertical: b.top + b.bottom,
            horizontal: b.left + b.right
        };
    };

    var dimensions = function ($element) {
        var win = $(window);
        var isRoot = rootrx.test($element[0].nodeName);
        return {
            border: isRoot ? { top: 0, left: 0, bottom: 0, right: 0} : borders($element[0]),
            scroll: {
                top: (isRoot ? win : $element).scrollTop(),
                left: (isRoot ? win : $element).scrollLeft()
            },
            scrollbar: {
                right: isRoot ? 0 : $element.innerWidth() - $element[0].clientWidth,
                bottom: isRoot ? 0 : $element.innerHeight() - $element[0].clientHeight
            },
            rect: (function () {
                var r = $element[0].getBoundingClientRect();
                return {
                    top: isRoot ? 0 : r.top,
                    left: isRoot ? 0 : r.left,
                    bottom: isRoot ? $element[0].clientHeight : r.bottom,
                    right: isRoot ? $element[0].clientWidth : r.right
                };
            })()
        };
    };

    $.fn.extend({
        scrollIntoViewForAuto: function (options) {
            /// <summary>Scrolls the first element in the set into view by scrolling its closest scrollable parent.</summary>
            /// <param name="options" type="Object">Additional options that can configure scrolling:
            ///        duration (default: "fast") - jQuery animation speed (can be a duration string or number of milliseconds)
            ///        direction (default: "both") - select possible scrollings ("vertical" or "y", "horizontal" or "x", "both")
            ///        complete (default: none) - a function to call when scrolling completes (called in context of the DOM element being scrolled)
            /// </param>
            /// <return type="jQuery">Returns the same jQuery set that this function was run on.</return>

            options = $.extend({}, settings, options);
            options.direction = converter[typeof (options.direction) === "string" && options.direction.toLowerCase()] || converter.both;

            var dirStr = "";
            if (options.direction.x === true) dirStr = "horizontal";
            if (options.direction.y === true) dirStr = dirStr ? "both" : "vertical";

            var el = this.eq(0);
            var scroller = el.closest(":scrollable(" + dirStr + ")");

            // check if there's anything to scroll in the first place
            if (scroller.length > 0)
            {
                scroller = scroller.eq(0);

                var dim = {
                    e: dimensions(el),
                    s: dimensions(scroller)
                };

                var rel = {
                    top: dim.e.rect.top - (dim.s.rect.top + dim.s.border.top),
                    bottom: dim.s.rect.bottom - dim.s.border.bottom - dim.s.scrollbar.bottom - dim.e.rect.bottom,
                    left: dim.e.rect.left - (dim.s.rect.left + dim.s.border.left),
                    right: dim.s.rect.right - dim.s.border.right - dim.s.scrollbar.right - dim.e.rect.right
                };

                var animOptions = {};

                // vertical scroll
                if (options.direction.y === true)
                {
                    if (rel.top < 0)
                    {
                        animOptions.scrollTop = dim.s.scroll.top + rel.top - 30;
                    }
                    else if (rel.top > 0 && rel.bottom < 0)
                    {
                        animOptions.scrollTop = dim.s.scroll.top + Math.min(rel.top, -rel.bottom) + 30;
                    }
                }

                // horizontal scroll
                if (options.direction.x === true)
                {
                    if (rel.left < 0)
                    {
                        animOptions.scrollLeft = dim.s.scroll.left + rel.left;
                    }
                    else if (rel.left > 0 && rel.right < 0)
                    {
                        animOptions.scrollLeft = dim.s.scroll.left + Math.min(rel.left, -rel.right);
                    }
                }

                // scroll if needed
                if (!$.isEmptyObject(animOptions))
                {
                    if (rootrx.test(scroller[0].nodeName))
                    {
                        scroller = $("html,body");
                    }
                    scroller
                            .animate(animOptions, options.duration)
                            .eq(0) // we want function to be called just once (ref. "html,body")
                            .queue(function (next) {
                                $.isFunction(options.complete) && options.complete.call(scroller[0]);
                                next();
                            });
                }
                else
                {
                    // when there's nothing to scroll, just call the "complete" function
                    $.isFunction(options.complete) && options.complete.call(scroller[0]);
                }
            }

            // return set back
            return this;
        }
    });

    var scrollValue = {
        auto: true,
        scroll: true,
        visible: false,
        hidden: false
    };

    $.extend($.expr[":"], {
        scrollable: function (element, index, meta, stack) {
            var direction = converter[typeof (meta[3]) === "string" && meta[3].toLowerCase()] || converter.both;
            var styles = (document.defaultView && document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(element, null) : element.currentStyle);
            var overflow = {
                x: scrollValue[styles.overflowX.toLowerCase()] || false,
                y: scrollValue[styles.overflowY.toLowerCase()] || false,
                isRoot: rootrx.test(element.nodeName)
            };

            // check if completely unscrollable (exclude HTML element because it's special)
            if (!overflow.x && !overflow.y && !overflow.isRoot)
            {
                return false;
            }

            var size = {
                height: {
                    scroll: element.scrollHeight,
                    client: element.clientHeight
                },
                width: {
                    scroll: element.scrollWidth,
                    client: element.clientWidth
                },
                // check overflow.x/y because iPad (and possibly other tablets) don't dislay scrollbars
                scrollableX: function () {
                    return (overflow.x || overflow.isRoot) && this.width.scroll > this.width.client;
                },
                scrollableY: function () {
                    return (overflow.y || overflow.isRoot) && this.height.scroll > this.height.client;
                }
            };
            return direction.y && size.scrollableY() || direction.x && size.scrollableX();
        }
    });

})(jQuery);


;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:functional-utils', location = 'util/FunctionalUtils.js' */
define("jira/components/util/functionalutils", [], function() {
    "use strict";

    var _ = require("underscore");

    return {
        lambda: function(x) {
            return function() {
                return x;
            };
        },
        isNotBlank: function(object) {
            return !!object;
        },
        bindObjectTo: function (obj, context) {
            _.map(obj, function (value, key) {
                if (_.isFunction(value)) {
                    obj[key] = _.bind(value, context);
                }
            });
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issue-utils', location = 'content/js/util/Utils.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Issues.Actions");
    JIRA.Issues.Actions.DELETE = "delete";
    JIRA.Issues.Actions.UPDATE = "update";
    JIRA.Issues.Actions.INLINE_EDIT = "inlineEdit";
    JIRA.Issues.Actions.ROW_UPDATE = "rowUpdate";

    JIRA.Issues.XsrfTokenHeader = {
        "X-Atlassian-Token": "no-check"
    };

    JIRA.Issues.Utils = {


        isIssueDialog: function (dialog) {
            return !!dialog.issueId || _.include(JIRA.Dialogs, dialog);
        },

        isDeleteDialog: function (dialog) {
            return dialog.options.id === "delete-issue-dialog";
        },


        isEditCommentDialog: function (dialog) {
            return dialog.options.id === "edit-comment";
        },

        getEffectiveIssueKeyForDialog: function (dialog) {
            // Use the key from the trigger link that was used to create the
            // dialog. If that's not there, then grab it from the issue table.
            var keyFromTrigger = dialog && dialog.$activeTrigger && dialog.$activeTrigger.data("issuekey");
            if (keyFromTrigger) {
                return keyFromTrigger;
            } else {
                return JIRA.Issues.Api.getSelectedIssue().getKey();
            }
        },
        getEffectiveIssueIdForDialog: function (dialog) {
            if (dialog.issueId) {
                return dialog.issueId;
            } else {
                return JIRA.Issues.Api.getSelectedIssue().getId();
            }
        },

        getAction: function (dialog) {
            if (this.isDeleteDialog(dialog)) {
                return JIRA.Issues.Actions.DELETE;
            } else if (this.isEditCommentDialog(dialog)) {
                return JIRA.Issues.Actions.EDIT_COMMENT;
            } else {
                return JIRA.Issues.Actions.UPDATE;
            }
        },

        getMessage: function (dialog) {
            if (!this.isEditCommentDialog(dialog)) {
                return dialog.options.issueMsg || "thanks_issue_updated";
            }
        },
        getMeta: function (dialog) {
            if (this.isEditCommentDialog(dialog)) {
                return {
                    commentId: dialog.$activeTrigger.attr("id").replace("edit_comment_", "")
                };
            } else {
                return {};
            }
        },
        getUpdateCommandForDialog: function (dialog) {
            var utils = this;
            if (this.isIssueDialog(dialog)) {
                return {
                    key: utils.getEffectiveIssueKeyForDialog(dialog),
                    id: utils.getEffectiveIssueIdForDialog(dialog),
                    action: utils.getAction(dialog),
                    message: utils.getMessage(dialog),
                    meta: utils.getMeta(dialog)
                };
            }
        },
        /**
         * A debounce implementation the differs from the undercore one. This implementation:
         * 1. Executes the supplied method straight away
         * 2. Using underscore debounce, postpones its execution until 300ms since the last time it was invoked.
         * 3. After the debounced invocation, waits 500ms before restoring to the original state (step 1).
         *
         * @param {Object} ctx
         * @param {String} method
         * @param {...} arguments for first invocation.
         */
        debounce: function (ctx, method) {


            var args = Array.prototype.slice.call(arguments, 2);

            if (!ctx) {
                /*eslint-disable no-console */
                console.error("JIRA.Issues.Utils.debounce: ctx must be defined");
                /*eslint-enable no-console */
            }

            clearTimeout(ctx[method + "DebounceTimeout"]);

            // Invoke method, first time this will happen straight away. Subsequent times it will be calling the debounced
            // method.
            ctx[method].apply(ctx, args);

            if (!ctx[method + "DebounceTimeout"]) {
                ctx[method + "Original"] = ctx[method];
                ctx[method] = _.debounce(function () {
                    return ctx[method + "Original"].apply(ctx, arguments);
                }, 300);
            }

            // After 500 ms or recieving input, get rid of debounced version.
            ctx[method + "DebounceTimeout"] = setTimeout(function () {
                ctx[method] = ctx[method + "Original"];
                ctx[method + "DebounceTimeout"] = null;
            }, 500);
        },
        waitForDeferreds: function (obj, iterator, ctx) {
            ctx = ctx || window;
            var promises = [];
            var deferred = new jQuery.Deferred();

            _.each(obj, function () {
                var result = iterator.apply(ctx, arguments);
                if (result && result.promise) {
                    promises.push(result);
                }
            });
            if (promises.length) {
                jQuery.when.apply(jQuery, promises).then(function () {
                    deferred.resolveWith(ctx);
                });
            } else {
                deferred.resolveWith(ctx);
            }
            return deferred.promise();
        },
        resolvedPromise: function () {
            return new jQuery.Deferred().resolve().promise();
        },

        /**
         * Patches an attribute on an object, and provides an easy way to 'undo'.
         *
         * @param {object} object
         * @param {string} name The attribute to patch
         * @param {object} replacement
         * @return {Function} A 'restore' function that reverts the patch.
         */
        patch: function (object, name, replacement) {
            var hadOriginal = object.hasOwnProperty(name);
            var original = object[name];

            object[name] = replacement;

            return function restore() {
                if (hadOriginal) {
                    object[name] = original;
                } else {
                    delete object[name];
                }
            };
        }
    };

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:backbone-ext', location = 'content/js/base/AttributesMixinCreator.js' */
define("jira/issues/attributesmixincreator", ["require"], function(require){
    "use strict";

    var _ = require("underscore");
    var JIRAMixins = require("jira/issues/mixins");

    return {
        // Creates a mixin of getter and setter methods for each item in the given property list.
        // A getter and setter for `id` is always generated.
        create: function(properties) {
            var methods = {};

            if (_.indexOf(properties, "id") === -1) {
                properties.unshift("id");
            }

            _.each(properties, function (property) {

                var setter = JIRAMixins.createMethodName("set", property);
                methods[setter] = function (val, options) {
                    var obj = {};
                    obj[property] = val;
                    this.set(obj, options);
                    return this;
                };
                var getter = JIRAMixins.createMethodName("get", property);
                methods[getter] = function () {
                    return this.get(property);
                };
            });
            return methods;
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:backbone-ext', location = 'content/js/base/EventsMixinCreator.js' */
define("jira/issues/eventsmixincreator", ["require"], function(require){
    "use strict";

    var _ = require("underscore");
    var JIRAMixins = require("jira/issues/mixins");

     return {
        // Creates a mixin of bind and trigger methods for each item in the given list of events.
        create: function(events) {
            var eventMethods = {};
             var createEvent = function(eventName) {
                 var binder = JIRAMixins.createMethodName("bind", eventName);
                 eventMethods[binder] = function() {
                     return this.bind.apply(this, [eventName].concat(_.toArray(arguments)));
                 };

                 var unbinder = JIRAMixins.createMethodName("unbind", eventName);
                 eventMethods[unbinder] = function() {
                     return this.unbind.apply(this, [eventName].concat(_.toArray(arguments)));
                 };

                 var trigger = JIRAMixins.createMethodName("trigger", eventName);
                 eventMethods[trigger] = function() {
                     return this.trigger.apply(this, [eventName].concat(_.toArray(arguments)));
                 };
                 var one = JIRAMixins.createMethodName("one", eventName);
                 eventMethods[one] = function() {
                     var instance = this;
                     var originalHandler = arguments[0];
                     var unbindingHandler = function() {
                         instance.unbind(eventName, unbindingHandler);
                         originalHandler(arguments);
                     };

                     var rest = _.toArray(arguments).slice(1);
                     return this.bind.apply(this, [eventName, unbindingHandler].concat(rest));
                 };
             };
            _.each(events, _.bind(createEvent, this));

            return eventMethods;
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:backbone-ext', location = 'content/js/base/Extensions.js' */
define("jira/issue/extensions", ["require"], function(require) {
    "use strict";

    var _ = require("underscore");
    var EventsMixinCreator = require("jira/issues/eventsmixincreator");
    var AttributesMixinCreator = require("jira/issues/attributesmixincreator");

    // Applies all mixins to the given constructor's prototype.
    function applyMixin(ctor, mixin) {
        _.forEach(_.keys(mixin), function (key) {
            var proto = ctor.prototype;

            // `initialize` is not mixed in - we compose the mixin's initialize with the existing initialize method (if it exists).
            if ("initialize" === key) {
                var oldInitialize = proto.initialize;
                proto.initialize = function () {
                    mixin.initialize.apply(this, arguments);
                    if (oldInitialize) {
                        oldInitialize.apply(this, arguments);
                    }
                };
                return;
            }
            // `validate` is not mixed in - we compose the mixin's validate with the existing validate method (if it exists).
            if ("validate" === key) {
                var oldValidate = proto.validate;
                proto.validate = function () {
                    var errors = mixin.validate.apply(this, arguments);
                    if (errors) {
                        return errors;
                    }
                    if (oldValidate) {
                        return oldValidate.apply(this, arguments);
                    }
                };
                return;
            }
            // `defaults` are not mixed in - we compose the mixin's defaults with existing defaults if they exist
            if ("defaults" === key) {
                var defaults = proto.defaults || (proto.defaults = {});
                var mixinDefaults = mixin[key];
                for (var id in mixinDefaults) {
                    if (defaults.hasOwnProperty(id)) {
                        throw "Mixin error: object " + ctor + " already has default " + id + " defined for mixin " + mixin;
                    }
                    defaults[id] = mixinDefaults[id];
                }
                return;
            }
            // `properties` are added to the mixin, and we mixin in getters and setters for each property.
            if ("properties" === key) {
                // `properties` must be an array
                if (!_.isArray(mixin[key])) {
                    throw "Expects properties member on mixin to be an array";
                }
                if (!proto.properties) {
                    proto.properties = [];
                }
                proto.properties = proto.properties.concat(mixin[key]);
                return;
            }

            // `namedEvents` are added to the mixin, and we mix in bind and trigger methods for each property.
            if ("namedEvents" === key) {
                // `events` must be an array
                if (!_.isArray(mixin[key])) {
                    throw "Expects events member on mixin to be an array";
                }
                if (!proto.namedEvents) {
                    proto.namedEvents = [];
                }
                proto.namedEvents = proto.namedEvents.concat(mixin[key]);
                return;
            }
            // Name collisions with other mixins or or the object we're mixing into result in violent and forceful disapproval.
            if (proto.hasOwnProperty(key)) {
                throw "Mixin error: object " + ctor + " already has property " + key + " for mixin " + mixin;
            }
            proto[key] = mixin[key];
        }, this);
    }

    /*
     * Generates an `extend` method that overrides Backbone's default `extend`. The new extend calls Backbone's `extend`, then:
     * <ul>
     *     <li>Adds all mixins specified in the `mixins` array.</li>
     *     <li>Adds a `JIRA.Issues.EventsMixinCreator` to mix in bind and trigger methods for events specified in the `namedEvents` array,</li>
     *     <li>Adds a `JIRA.Issues.AttributesMixinCreator` to mix in get and set methods for attributes specified in the `attributes` array,</li>
     * </ul>
     */
    function generateMixinExtend(oldExtend) {
        return function f(protoProps, classProps) {
            var child;
            var cleanProtoProps = _.extend({}, protoProps);
            // Remove `mixins` - we don't want to see them on the created prototype. Note that we do want to see `properties` and `namedEvents` for debugging
            var mixins;
            if (protoProps && protoProps.mixins) {
                mixins = protoProps.mixins;
                delete cleanProtoProps.mixins;
            }
            child = oldExtend.call(this, cleanProtoProps, classProps);
            if (mixins) {
                _.each(protoProps.mixins, function (mixin) {
                    applyMixin(child, mixin);
                });
            }
            if (child.prototype.namedEvents) {
                applyMixin(child, EventsMixinCreator.create(child.prototype.namedEvents));
            }
            if (child.prototype.properties) {
                applyMixin(child, AttributesMixinCreator.create(child.prototype.properties));
            }
            child.extend = f;
            return child;
        };
    }

    // Overrides Backbone's default `get` and `set` methods to validate that the attribute being get / set is a valid property.
    function overrideSetGet(ctor, childCtor) {
        var proto = ctor.prototype;
        var childProto = childCtor.prototype;

        childProto.set = function (key, value) {
            // TODO: has, escape, unset
            var attrs;
            var properties = this.properties;
            if (properties) {
                if (_.isObject(key) || key == null) {
                    attrs = key;
                } else {
                    attrs = {};
                    attrs[key] = value;
                }
                for (var attr in attrs) {
                    if (_.indexOf(properties, attr) < 0) {
                        throw "Property '" + attr + "' does not exist";
                    }
                }
            }

            // calls super.set
            return proto.set.apply(this, arguments);
        };

        childProto.get = function (attr) {
            if (this.properties && _.indexOf(this.properties, attr) < 0) {
                throw "Property '" + attr + "' does not exist";
            }

            // calls super.get
            return proto.get.apply(this, arguments);
        };
    }

    function addListenMethods(ctor, childCtor) {
        var childProto = childCtor.prototype;

        /**
         * Calls <code>other.onEvent(callback, context)</code> and adds the callback to the list of listeners so it can
         * be removed later by calling <code>removeListeners()</code>.
         *
         * @param other the object to call onEvent on
         * @param event the name of the event (used to determine the method name)
         * @param callback the callback
         * @param context an optional context to use when running the callback
         */
        childProto.addListener = function (other, event, callback, context) {
            if (arguments.length < 3) {
                throw "The 'other', 'event', and 'callback' arguments are mandatory";
            }

            var capitalisedEvent = event.charAt(0).toUpperCase() + event.slice(1);
            var registerMethodName = "on" + capitalisedEvent;
            var unregisterMethodName = "off" + capitalisedEvent;
            var braceRegisterMethodName = "bind" + capitalisedEvent;
            var braceUnregisterMethodName = "unbind" + capitalisedEvent;
            var finalRegisterName;
            var finalUnRegisterName;

            if (other[registerMethodName]) {
                // listener for methods
                finalRegisterName = registerMethodName;
                finalUnRegisterName = unregisterMethodName || braceUnregisterMethodName;
                if (typeof other[finalRegisterName] !== 'function') {
                    throw "object does not have method " + registerMethodName + "'";
                }
                if (typeof other[finalUnRegisterName] !== 'function') {
                    throw "object does not have method " + unregisterMethodName + "'";
                }
            } else {
                // listener for brace events
                finalRegisterName = braceRegisterMethodName;
                finalUnRegisterName = braceUnregisterMethodName;
                if (typeof other[finalRegisterName] !== 'function') {
                    throw "object does not have event [" + event + "] registered'";
                }
            }

            // register using the listen method and add to the list so we can clean up in removeListeners()
            other[finalRegisterName](callback, context);
            this._cleanerUppers = this._cleanerUppers || [];
            this._cleanerUppers.push(function () {
                other[finalUnRegisterName](callback, context);
            });
        };

        /**
         * Removes all listeners added using <code>addListener()</code>.
         */
        childProto.removeListeners = function () {
            if (this._cleanerUppers) {
                _.each(this._cleanerUppers, function (cleanerUpper) {
                    cleanerUpper(); // un-register the listener
                });
            }
        };
    }

    /**
     * Adds a <code>deactivate()</code> method to the given constructor function and overrides its <code>remove()</code>
     * function to call <code>removeListeners()</code>. To be used in classes to which you have added the
     * <code>addListener()</code> and <code>removeListeners()</code> methods.
     *
     * @see addListenMethods
     * @param ctor
     * @param childCtor
     */
    function addViewCleanupMethods(ctor, childCtor) {
        var childProto = childCtor.prototype;

        var superRemove = ctor.prototype.remove;
        /**
         * Overrides <a href="http://backbonejs.org/#View-remove">Backbone.View.remove()</a> to also call
         * <code>this.removeListeners()</code>.
         */
        childProto.remove = function () {
            this.removeListeners();
            return superRemove.apply(this, arguments);
        };

        /**
         * Deactivates this view by calling the following methods:
         * <ul>
         *     <li><a href="http://backbonejs.org/#View-undelegateEvents">Backbone.Model.undelegateEvents()</a>
         *     <li>JIRA.Issues.BaseView.removeListeners()
         * </ul>
         */
        childProto.deactivate = function () {
            this.undelegateEvents();
            this.removeListeners();
        };
    }

    // Applies extensions to the given constructor function:
    // <ul>
    //   <li>Sets `extend` to a method generated by `generateMixinExtend`</li>
    // </ul>
    function applyExtensions(ctor) {
        var child = ctor.extend();
        var oldExtend = ctor.extend;
        child.extend = generateMixinExtend(oldExtend);
        return child;
    }

    // Applies extensions to the given constructor function:
    // <ul>
    //   <li>Sets `extend` to a method generated by `generateMixinExtend`</li>
    // </ul>
    function applyModelExtensions(ctor) {
        var child = applyExtensions(ctor);
        overrideSetGet(ctor, child);
        return child;
    }

    /**
     * Applies view-specific extensions to the given constructor function and returns a new constructor function. This
     * currently:
     * <ul>
     *   <li>adds <code>addListener()</code> and <code>removeListeners</code> methods
     *   <li>adds a <code>deactivate</code> method (similar to Backbone.View.remove() but doesn't remove 'el' from the DOM)
     *   <li>overrides <code>remove()</code> and makes it call <code>removeListeners()</code>
     * </ul>
     *
     * @param ctor {function} a constructor function for a view
     * @return {function} a new constructor function
     */
    function applyViewExtensions(ctor) {
        var child = applyExtensions(ctor);
        addListenMethods(ctor, child);
        addViewCleanupMethods(ctor, child);
        return child;
    }

    return {
        applyModelExtensions: applyModelExtensions,
        applyExtensions: applyExtensions,
        applyViewExtensions: applyViewExtensions
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:backbone-ext', location = 'content/js/base/BaseCollection.js' */
define("jira/issues/basecollection", ["require"], function(require) {
    "use strict";

    var Backbone = require("backbone");
    var Extensions = require("jira/issue/extensions");

    return Extensions.applyExtensions(Backbone.Collection);
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:backbone-ext', location = 'content/js/base/BaseEvented.js' */
/**
 * This is a generic object that is used as the base object of some clases. The features
 * of this 'class' are:
 *
 *   * Support for all Backbone.Events features
 *   * Automatic getter and setter for all the properties defined in `properties`
 *   * Automatic register and unregister methods for all the events defined in `EventsMixinCreator`
 *
 * @deprecated The usage of this base object is discouraged, as usually extending from Backbone.Events
 * is enough.
 */
define("jira/issues/baseevented", ["require"], function(require) {
    "use strict";

    var Backbone = require("backbone");
    var _ = require("underscore");
    var Extensions = require("jira/issue/extensions");

    var Evented = function() {
        this.initialize.apply(this, arguments);
    };
    _.extend(Evented.prototype, Backbone.Events, {
        initialize: function() {}
    });
    Evented.extend = Backbone.Model.extend;
    return Extensions.applyExtensions(Evented);
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:backbone-ext', location = 'content/js/base/BaseModel.js' */
define("jira/issues/basemodel", ["require"], function(require) {
    "use strict";

    var Backbone = require("backbone");
    var Extensions = require("jira/issue/extensions");

    return Extensions.applyModelExtensions(Backbone.Model);
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:backbone-ext', location = 'content/js/base/BaseRouter.js' */
define("jira/issues/baserouter", ["require"], function(require) {
    "use strict";

    var Backbone = require("backbone");
    var Extensions = require("jira/issue/extensions");

    return Extensions.applyExtensions(Backbone.Router);
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:backbone-ext', location = 'content/js/base/BaseView.js' */
define("jira/issues/baseview", ["require"], function(require) {
    "use strict";

    var Backbone = require("backbone");
    var Extensions = require("jira/issue/extensions");

    return Extensions.applyViewExtensions(Backbone.View);
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:backbone-ext', location = 'content/js/base/Mixins.js' */
define("jira/issues/mixins", function(){
    "use strict";

     return {
        /*
         * Creates a camelCased method name
         */
        createMethodName: function(prefix, suffix) {
            return prefix + suffix.charAt(0).toUpperCase() + suffix.substr(1);
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:backbone-ext', location = 'content/js/base/ModelUtils.js' */
define("jira/issues/modelutils", ["require"], function(require){
    "use strict";

    var _ = require("underscore");
    var Backbone = require("backbone");
    var IssuesUtils = JIRA.Issues.Utils;

    var transaction;

    /**
     * A collection of events that *weren't* emitted.
     * @constructor
     */
    function EventLog () {
        this.modelEvents = {};
    }

    /**
     * Record the details of an event, so it can be replayed later.
     *
     * @param {Backbone.Model} model
     * @param {*[]} args
     */
    EventLog.prototype.captureEvent = function (model, args) {
        var name = args[0];

        // We only want to trigger each type of event at most once, so they're keyed on their name.
        if (!this.modelEvents[model.cid]) {
            this.modelEvents[model.cid] = {
                model: model,
                events: {}
            };
        }

        this.modelEvents[model.cid].events[name] = args;
    };

    /**
     * Replay all the events that were captured.
     */
    EventLog.prototype.replayEvents = function () {
        _.each(this.modelEvents, function (item) {
            _.each(item.events, function (args) {
                Backbone.Events.trigger.apply(item.model, args);
            });
        });
    };

    /**
     * A drop-in replacement for Backbone.Events.trigger that captures change[:] events rather
     * than emitting them.
     */
    function filteredTrigger (name) {
        var model = this;

        if (name === "change" || name.indexOf("change:") === 0) {
            transaction.log.captureEvent(model, _.toArray(arguments));
        } else {
            Backbone.Events.trigger.apply(model, arguments);
        }
    }

    var beginTransaction = function () {
        // if there is a batch already in progress then just piggy-back onto that one. this is
        // necessary so that changes to multiple Backbone models are all published as part of
        // a single batch.
        if (transaction) {
            return {
                commit: function () {} // the outer batch will publish everything
            };
        }

        transaction = {
            log: new EventLog()
        };

        var restoreTrigger = IssuesUtils.patch(Backbone.Model.prototype, "trigger", filteredTrigger);

        return {
            commit: function () {
                restoreTrigger();
                transaction.log.replayEvents();
                transaction = null;
            }
        };
    };

    var ModelUtils = {
        /**
         * Runs the given closure within a "transaction", meaning that all change events are fired atomically AFTER the
         * closure returns. Inside the closure, this==model.
         * <p/>
         * Calling this method when there is a transaction already in progress will make the inner transaction enlist in
         * the outer (all change events will be fired at the end of the outermost transaction).
         *
         * @param closure {function} the code to run in a transaction
         * @param context {object} an optional context to use when calling the closure (defaults to undefined)
         * @return {undefined}
         */
        transaction: function (closure, context) {
            var tx = beginTransaction();

            try {
                return closure.apply(context);
            } finally {
                tx.commit();
            }
        },

        /**
         * Makes the methods with the given names transactional. If no method names are provided then any method whose name
         * does not start with _ is made transactional. "Transactional" methods will not raise Backbone change events until
         * the transaction is finished (which happens when the outermost transactional method returns).
         *
         * @param {object} object the instance on which the methods are
         * @return {undefined}
         */
        makeTransactional: function (object) {
            var transactionalise = function(realMethod) {
                return function () {
                    var args = arguments;

                    return ModelUtils.transaction(function () {
                        return realMethod.apply(this, args); // calls the original, non-transactional, method
                    }, this);
                };
            };

            var methods = Array.prototype.slice.call(arguments, 1);
            if (methods.length === 0) { methods = _.functions(object); }
            _.each(methods, function(methodName) {
                // skip "private" methods
                if (methodName.indexOf('_') !== 0) {
                    object[methodName] = transactionalise(object[methodName]);
                }
            });
        }
    };
    return ModelUtils;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:backbone-ext', location = 'content/js/base/namespace.js' */
AJS.namespace("JIRA.Issues.AttributesMixinCreator", null, require("jira/issues/attributesmixincreator"));
AJS.namespace("JIRA.Issues.BaseCollection", null, require("jira/issues/basecollection"));
AJS.namespace("JIRA.Issues.BaseEvented", null, require("jira/issues/baseevented"));
AJS.namespace("JIRA.Issues.BaseModel", null, require("jira/issues/basemodel"));
AJS.namespace("JIRA.Issues.BaseRouter", null, require("jira/issues/baserouter"));
AJS.namespace("JIRA.Issues.BaseView", null, require("jira/issues/baseview"));
AJS.namespace("JIRA.Issues.EventsMixinCreator", null, require("jira/issues/eventsmixincreator"));
AJS.namespace("JIRA.Issues.Mixins", null, require("jira/issues/mixins"));
AJS.namespace("JIRA.Issues.ModelUtils", null, require("jira/issues/modelutils"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:backbone-ext', location = 'content/js/base/init.js' */
(function() {
    "use strict";

    var FunctionalUtils = require("jira/components/util/functionalutils");
    var _ = require("underscore");

    _.mixin({
        lambda: FunctionalUtils.lambda,
        isNotBlank: FunctionalUtils.isNotBlank,
        bindObjectTo: FunctionalUtils.bindObjectTo
    });
})();
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:brace', location = 'libs/brace.js' */
define("jira/components/libs/brace", [
    "atlassian/libs/factories/brace-2014.09.03",
    "jira/components/libs/backbone",
    "jira/components/libs/underscore"
], function(
    braceFactory,
    Backbone,
    _
) {
    "use strict";

    return braceFactory(_, Backbone);
});
AJS.namespace("JIRA.Issues.Brace", null, require("jira/components/libs/brace"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:user-parms', location = 'content/js/util/UserParms.js' */
(function(){
    "use strict";
    var data = WRM.data.claim("com.atlassian.jira.jira-issue-nav-plugin:user-parms.userParms");

    /**
     * Parameters relating to the permissions of the current user
     */
    JIRA.Issues.UserParms = {

        createSharedObjects: function() {
            return data.createSharedObjects;
        },

        get: function() {
            return data;
        }
    };

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'lib/backbone.queryparams.js' */
/*! THIS FILE HAS BEEN MODIFIED BY ATLASSIAN, SEE https://github.com/jhudson8/backbone-query-parameters/pull/63/files */
(function (root, factory) {
   if (typeof exports === 'object' && root.require) {
     module.exports = factory(require("underscore"), require("backbone"));
   } else if (typeof define === "function" && define.amd) {
      // AMD. Register as an anonymous module.
      define(["underscore","backbone"], function(_, Backbone) {
        // Use global variables if the locals are undefined.
        return factory(_ || root._, Backbone || root.Backbone);
      });
   } else {
      // RequireJS isn't being used. Assume underscore and backbone are loaded in <script> tags
      factory(_, Backbone);
   }
}(this, function(_, Backbone) {

var queryStringParam = /^\?(.*)/,
    optionalParam = /\((.*?)\)/g,
    namedParam    = /(\(\?)?:\w+/g,
    splatParam    = /\*\w+/g,
    escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g,
    fragmentStrip = /^([^\?]*)/,
    namesPattern = /[\:\*]([^\:\?\/]+)/g,
    routeStripper = /^[#\/]|\s+$/g,
    trailingSlash = /\/$/;
Backbone.Router.arrayValueSplit = '|';

var _getFragment = function(fragment, forcePushState) {
  if (fragment == null) {
    if (this._hasPushState || !this._wantsHashChange || forcePushState) {
      fragment = this.location.pathname;
      var root = this.root.replace(trailingSlash, '');
      var search = this.location.search;
      if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
      if (search) fragment += search;
    } else {
      fragment = this.getHash();
    }
  }
  return fragment.replace(routeStripper, '');
};

function proxy(source, proxy, name) {
  _.each(Array.prototype.slice.call(arguments, 2), function (name) {
    Object.defineProperty(proxy, name, {
      get: function () { return source[name]; },
      set: function (value) { source[name] = value; }
    });
  });
}

proxy.isSupported = (function () {
  try {
    Object.defineProperty({}, 'x', {})
    return true;
  } catch (e) {
    return false;
  }
})();

function LocationRewriter(history) {
  var original = history.location,
      replacement = {};

  proxy(original, replacement, "assign", "ancestorOrigins",
      "origin", "hash", "search", "pathname", "port", "hostname", "host",
      "protocol", "href", "reload");

  replacement.replace = function() {
    original.replace(history.root + '#' + history.fragment);
  };

  replacement.unPatch = function() {
    return history.location = original;
  };

  history.location = replacement;
}

function HistoryRewriter(history) {
  var original = history.history,
      replacement = {};

  proxy(original, replacement, "length", "state", "back", "forward", "go",
      "pushState");

  replacement.replaceState = function(state, title, url) {
    url = history.root + history.fragment;
    return original.replaceState(state, title, url);
  };

  replacement.unPatch = function () {
    history.history = original;
  };

  history.history = replacement;
}

var _start = Backbone.History.prototype.start,
    _loadUrl = Backbone.History.prototype.loadUrl;

_.extend(Backbone.History.prototype, {
  getFragment: _getFragment,

  // this will not perform custom query param serialization specific to the router
  // but will return a map of key/value pairs (the value is a string or array)
  getQueryParameters: function(fragment, forcePushState) {
    fragment = _getFragment.apply(this, arguments);
    // if no query string exists, this will still be the original fragment
    var queryString = fragment.replace(fragmentStrip, '');
    var match = queryString.match(queryStringParam);
    if (match) {
      queryString = match[1];
      var rtn = {};
      iterateQueryString(queryString, function(name, value) {
        // decodeURIComponent doesn't touch '+'
        value = value.replace(/\+/g, '%20');
        value = decodeURIComponent(value);
        if (!rtn[name]) {
          rtn[name] = value;
        } else if (_.isString(rtn[name])) {
          rtn[name] = [rtn[name], value];
        } else {
          rtn[name].push(value);
        }
      });
      return rtn;
    } else {
      // no values
      return {};
    }
  },

  start: function() {
    if (proxy.isSupported) {
      LocationRewriter(this);
      HistoryRewriter(this);
    }
    try {
      return _start.apply(this, arguments);
    } finally {
      this.location.unPatch && this.location.unPatch();
      this.history.unPatch && this.history.unPatch();
    }
  },

  loadUrl: function () {
    this.location && this.location.unPatch && this.location.unPatch();
    this.history && this.history.unPatch && this.history.unPatch();
    return _loadUrl.apply(this, arguments);
  }
});

_.extend(Backbone.Router.prototype, {
  initialize: function(options) {
    this.encodedSplatParts = options && options.encodedSplatParts;
  },

  getFragment: _getFragment,

  _routeToRegExp: function(route) {
    var splatMatch = (splatParam.exec(route) || {index: -1}),
        namedMatch = (namedParam.exec(route) || {index: -1}),
        paramNames = route.match(namesPattern) || [];

    route = route.replace(escapeRegExp, '\\$&')
                 .replace(optionalParam, '(?:$1)?')
                 .replace(namedParam, function(match, optional){
                   return optional ? match : '([^\\/\\?]+)';
                 })
                 // `[^??]` is hacking around a regular expression bug under iOS4.
                 // If only `[^?]` is used then paths like signin/photos will fail
                 // while paths with `?` anywhere, like `signin/photos?`, will succeed.
                 .replace(splatParam, '([^??]*?)');
    route += '(\\?.*)?';
    var rtn = new RegExp('^' + route + '$');

    // use the rtn value to hold some parameter data
    if (splatMatch.index >= 0) {
      // there is a splat
      if (namedMatch >= 0) {
        // negative value will indicate there is a splat match before any named matches
        rtn.splatMatch = splatMatch.index - namedMatch.index;
      } else {
        rtn.splatMatch = -1;
      }
    }
    rtn.paramNames = _.map(paramNames, function(name) { return name.substring(1); });
    rtn.namedParameters = this.namedParameters;

    return rtn;
  },

  /**
   * Given a route, and a URL fragment that it matches, return the array of
   * extracted parameters.
   */
  _extractParameters: function(route, fragment) {
    var params = route.exec(fragment).slice(1),
        namedParams = {};
    if (params.length > 0 && _.isUndefined(params[params.length - 1])) {
    	// remove potential invalid data from query params match
    	params.splice(params.length - 1, 1);
    }

    // do we have an additional query string?
    var match = params.length && params[params.length-1] && params[params.length-1].match(queryStringParam);
    if (match) {
      var queryString = match[1];
      var data = {};
      if (queryString) {
        var self = this;
        iterateQueryString(queryString, function(name, value) {
          self._setParamValue(name, value, data);
        });
      }
      params[params.length-1] = data;
      _.extend(namedParams, data);
    }

    // decode params
    var length = params.length;
    if (route.splatMatch && this.encodedSplatParts) {
      if (route.splatMatch < 0) {
        // splat param is first
        return params;
      } else {
        length = length - 1;
      }
    }

    for (var i=0; i<length; i++) {
      if (_.isString(params[i])) {
        params[i] = decodeURIComponent(params[i]);
        if (route.paramNames && route.paramNames.length >= i-1) {
          namedParams[route.paramNames[i]] = params[i];
        }
      }
    }

    return (Backbone.Router.namedParameters || route.namedParameters) ? [namedParams] : params;
  },

  /**
   * Set the parameter value on the data hash
   */
  _setParamValue: function(key, value, data) {
    // use '.' to define hash separators
    key = key.replace('[]', '');
    var parts = key.split('.');
    var _data = data;
    for (var i=0; i<parts.length; i++) {
      var part = parts[i];
      if (i === parts.length-1) {
        // set the value
        _data[part] = this._decodeParamValue(value, _data[part]);
      } else {
        _data = _data[part] = _data[part] || {};
      }
    }
  },

  /**
   * Decode an individual parameter value (or list of values)
   * @param value the complete value
   * @param currentValue the currently known value (or list of values)
   */
  _decodeParamValue: function(value, currentValue) {
    // decodeURIComponent doesn't translate '+'
    value = value.replace(/\+/g, '%20');

    // '|' will indicate an array.  Array with 1 value is a=|b - multiple values can be a=b|c
    var splitChar = Backbone.Router.arrayValueSplit;
    if (splitChar && value.indexOf(splitChar) >= 0) {
      var values = value.split(splitChar);
      // clean it up
      for (var i=values.length-1; i>=0; i--) {
        if (!values[i]) {
          values.splice(i, 1);
        } else {
          values[i] = decodeURIComponent(values[i]);
        }
      }
      return values;
    }
    value = decodeURIComponent(value);
    if (!currentValue) {
      return value;
    } else if (_.isArray(currentValue)) {
      currentValue.push(value);
      return currentValue;
    } else {
      return [currentValue, value];
    }
  },

  /**
   * Return the route fragment with queryParameters serialized to query parameter string
   */
  toFragment: function(route, queryParameters) {
    if (queryParameters) {
      if (!_.isString(queryParameters)) {
        queryParameters = this._toQueryString(queryParameters);
      }
      if(queryParameters) {
        route += '?' + queryParameters;
      }
    }
    return route;
  },

  /**
   * Serialize the val hash to query parameters and return it.  Use the namePrefix to prefix all param names (for recursion)
   */
  _toQueryString: function(val, namePrefix) {
    var splitChar = Backbone.Router.arrayValueSplit;
    function encodeSplit(val) { return String(val).replace(splitChar, encodeURIComponent(splitChar)); }

    if (!val) return '';
    namePrefix = namePrefix || '';
    var rtn = '';
    for (var name in val) {
      var _val = val[name];
      if (_.isString(_val) || _.isNumber(_val) || _.isBoolean(_val) || _.isDate(_val)) {
        // primitive type
        _val = this._toQueryParam(_val);
        if (_.isBoolean(_val) || _.isNumber(_val) || _.isString(_val) || _val) {
          rtn += (rtn ? '&' : '') + this._toQueryParamName(name, namePrefix) + '=' + encodeSplit(encodeURIComponent(_val));
        }
      } else if (_.isArray(_val)) {
        // arrays use Backbone.Router.arrayValueSplit separator
        var str = '';
        for (var i = 0; i < _val.length; i++) {
          var param = this._toQueryParam(_val[i]);
          if (_.isBoolean(param) || param !== null) {
            str += splitChar + encodeSplit(param);
          }
        }
        if (str) {
          rtn += (rtn ? '&' : '') + this._toQueryParamName(name, namePrefix) + '=' + str;
        }
      } else {
        // dig into hash
        var result = this._toQueryString(_val, this._toQueryParamName(name, namePrefix, true));
        if (result) {
          rtn += (rtn ? '&' : '') + result;
        }
      }
    }
    return rtn;
  },

  /**
   * return the actual parameter name
   * @param name the parameter name
   * @param namePrefix the prefix to the name
   * @param createPrefix true if we're creating a name prefix, false if we're creating the name
   */
  _toQueryParamName: function(name, prefix, isPrefix) {
    return (prefix + name + (isPrefix ? '.' : ''));
  },

  /**
   * Return the string representation of the param used for the query string
   */
  _toQueryParam: function (param) {
    if (_.isNull(param) || _.isUndefined(param)) {
      return null;
    }
    return param;
  }
});

function iterateQueryString(queryString, callback) {
  var keyValues = queryString.split('&');
  _.each(keyValues, function(keyValue) {
    var arr = keyValue.split('=');
    callback(arr.shift(), arr.join('='));
  });
}

}));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/AuiOverrides.js' */
(function(){
    "use strict";

    /**
    * Removes semitransparent DIV
    * @see AJS.dim
    */
    AJS.undim = function() {
        if (AJS.dim.$dim) {
            AJS.dim.$dim.remove();
            AJS.dim.$dim = null;
            if (AJS.dim.shim) {
                AJS.dim.shim.remove();
            }

            // IE needs the overflow on the HTML element so scrollbars are hidden
            if (AJS.$.browser.msie && parseInt(AJS.$.browser.version, 10) < 8) {
                AJS.$("html").removeAttr("style");
            } else {
                AJS.$("body").removeAttr("style");
            }
        }
    };
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/ScrollIntoView.js' */
(function () {
    "use strict";

    var _scrollIntoViewForNormal = jQuery.fn.scrollIntoView;

    JIRA.Issues.overrideScrollIntoViewForSplit = function () {
        jQuery.fn.scrollIntoView = jQuery.fn.scrollIntoViewForAuto;
    };

    JIRA.Issues.restoreScrollIntoViewForNormal = function () {
        jQuery.fn.scrollIntoView = _scrollIntoViewForNormal;
    };

})();
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/IssueNavFeatures.js' */
(function(){
    "use strict";

    /**
     * The Feature class is used for querying a JIRA dark feature.
     */
    AJS.namespace("JIRA.Issues.Feature");
    JIRA.Issues.Feature = Class.extend({
        /**
         * Creates a new Feature object for the given feature key.
         *
         * @param featureKey {String} the name of the feature
         */
        init: function(featureKey) {
            this.featureKey = featureKey;
        },

        /**
         * Returns true if this Feature is enabled.
         *
         * @return {Boolean}
         */
        enabled: function() {
            return AJS.DarkFeatures.isEnabled(this.featureKey);
        }
    });

    /**
     * Holds the dark feature switches that affect how the KA app works.
     */
    AJS.namespace("JIRA.Issues.DarkFeatures");
    JIRA.Issues.DarkFeatures = {
        /**
         * If enabled, kills issue prefetching.
         */
        NO_PREFETCH: new JIRA.Issues.Feature("ka.NO_PREFETCH"),

        /**
         * If enabled, project's avatar will display a popup on click
         */
        PROJECT_SHORTCUTS: new JIRA.Issues.Feature("rotp.project.shortcuts")
    };

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/analytics.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Issues.AnalyticsLoader");

    JIRA.Issues.AnalyticsLoader = {
        init: function() {
            /**
             * App Events.
             *
             * These events are triggered from within the application.
             * This is a form of register of events which the application can broadcast.
             *
             * This event list does not need to contain all of the names of the Client Events listed below passed to
             * "analytics:registerTracker"
             *
             * IMPORTANT: Only have one level of dots under kickass or they wont show up in graphite!
             */
            JIRA.Issues.Application.execute("analytics:registerEvent", [
                /* Any client side search triggers this (including details of the search */
                "kickass.search",

                /* Triggered when the user switches back to keyword search */
                "kickass.switchtobasic",

                /* Triggered when the user moves to JQL search */
                "kickass.switchtoadvanced",

                /* Triggered when the user hits return to search */
                "kickass.returntosearch",

                /* Records if an inline edit action took place. Also includes which field is being edited */
                "kickass.editField",

                /* If more than one field was edited on a view issue page (Note: the count resets only when a new issue is loaded, *not*
                 * when the user clicked 'Save') */
                "kickass.editMultipleFields",

                /* Records the duration the user spends in edit mode until they hit save */
                "kickass.editClientDuration",

                /* Records the duration the user spends in edit mode until they hit cancel */
                "kickass.editClientCancelledDuration",

                /* Time it takes from hitting save to the view issue page having rerenderd on the client */
                "kickass.editSaveonserverDuration",

                /* Time it takes to load the view issue page */
                "kickass.issueLoadDuration",

                /* Triggered when the client opens an issue from the results table */
                "kickass.openIssueFromTable",

                /* Time it takes save an issue, from user click to full panel reblat */
                "kickass.issueTotalSaveDuration",

                /* When the user opens the focus shifter. */
                "kickass.focusshifteropened",

                /* When the query is too complex we need to switch to advanced mode */
                "kickass.queryTooComplexSwitchToAdvanced",

                /* The number of clauses when searching with basic mode */
                "kickass.basicModeCriteriaCountWhenSearching",

                /* Whether the user has auto update enabled */
                "kickass.criteriaAutoUpdateEnabled",

                /* When clicking on the refresh table button */
                "kickass.issueTableRefresh",

                /* When loading the issue from server conditionally */
                "kickass.conditionalLoading",

                /* When issue is rendered on the screen */
                "kickass.viewIssue",

                /* When issue is inline-edited */
                "kickass.inlineEdit",

                /* When issue is starting inline-edit */
                "kickass.inlineEdit.start",

                /* When issue has cancelled inline-edit */
                "kickass.inlineEdit.cancel",

                /* When full page reload has been done, because issue search resources has not been loaded */
                "kickass.viewIssueNavigationPageReload",

                /* When user requests SPA navigation before issue search resources are loaded on view issue */
                "kickass.viewIssueNavigationRequested"
            ]);

            /**
             * Track whether the user has auto updated enabled or not.
             */
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.criteriaAutoUpdateEnabled", {
                enabled: AJS.Meta.getBoolean("hasCriteriaAutoUpdate")
            });

            /**
             * An array of Analytics Event tracking definitions.
             *
             * These definitions are used for simple browser event tracking such as clicks, etc.
             *
             * There are two reasons for having these here instead of in the Backbone code itself.
             * 1) All "pushstate" links in KA do not have a trackable code path. They simply adjust the URL which
             *    causes more events to be propagated. At this point it is not possible to tell whether the user
             *    clicked on, say, a Filter link or whether they entered the Issue Navigator with that filter in the URL.
             *
             * 2) It's nice to have them all in one place.
             */
            JIRA.Issues.Application.execute("analytics:registerTracker", [
            /**
             * A user clicks on a System Filter.
             */
                {
                    name: "kickass.clickedOnSystemFilter",
                    selector: ".system-filters a",
                    handler: systemFilterClicked
                },

            /**
             * A user clicks on a Favourite Filter.
             */
                {
                    name: "kickass.clickedOnFavouriteFilter",
                    selector: ".favourite-filters a.filter-link"
                },

            /**
             * A user clicks on the Filter Actions Menu.
             */
                {
                    name: "kickass.clickedOnFavouriteFilterActionsMenu",
                    selector: ".favourite-filters a.filter-actions"
                },

            /**
             * A user renames a filter from the actions menu.
             */
                {
                    name: "kickass.renamedFilterFromActionsMenu",
                    selector: "#rename-filter-form",
                    type: "submit"
                },

            /**
             * A user deletes a filter from the actions menu
             */
                {
                    name: "kickass.deletedFilterFromActionsMenu",
                    selector: "#delete-filter-form",
                    type: "submit"
                },

            /**
             * A user copies a filter from the actions menu
             */
                {
                    name: "kickass.copiedFilterFromActionsMenu",
                    selector: "#copy-filter-dialog form",
                    type: "submit"
                },

            /**
             * A user renames a filter from the actions menu
             */
                {
                    name: "kickass.removeFilterFromFavouritesViaActionsMenu",
                    selector: ".unfavourite-filter"
                },

            /**
             * A user saves a copy of a filter from the Search Header
             */
                {
                    name: "kickass.saveACopyOfFilterFromSearchHeader",
                    selector: "#save-filter-dialog form",
                    type: "submit"
                },

            /**
             * A user saves their changes to a modified filter they own.
             */
                {
                    name: "kickass.filterChangesSaved",
                    selector: ".header-section-primary .save-changes"
                },

            /**
             * A user clicks on a System Filter
             * We have to use mousedown for the InlineDialog analytics event as
             * a) InlineDialog will stopPropagation on click events after it is initialised.
             * b) InlineDialog will send duplicate events for showLayer.
             */
                {
                    name: "kickass.clickedOnShowFiltersDetailsDropDown",
                    selector: ".show-filter-details",
                    type: "mousedown"
                },

            /**
             * A user clicks on the change permissions link.
             */
                {
                    name: "kickass.clickedOnChangePermissions",
                    selector: ".filter-permissions .change-permissions"
                },

            /**
             * A user clicks on the Un-favourite Star.
             *
             * By the time the delegated event propagates to the document the element no longer has the active class
             */
                {
                    name: "kickass.clickedOnUnfavouriteStar",
                    selector: ".filter-operations .fav-link.aui-iconfont-unstar"
                },

            /**
             * A user clicks on the Save A Copy link whilst viewing a System Filter.
             */
                {
                    name: "kickass.clickedOnSaveFilterAs",
                    selector: ".save-as-new-filter",
                    handler: clickedOnSaveFilterAs
                },

            /**
             * Tracks user's clicks on pagination links
             */
                {
                    name: "kickass.clickedOnPagniationLink",
                    selector: ".pagination a",
                    handler: clickedOnPagniationLink
                },

            /**
             * Tracks a user doing an in-browser search for text
             */
                {
                    name: "kickass.inbrowsersearch",
                    type: "keydown",
                    handler: inBrowserSearch
                },

            /**
             * Tracks when the user attempts to reload the page.
             */
                {
                    name: "kickass.reloadPage",
                    type: "keydown",
                    handler: onReloadPage
                },

            /**
             * The number of criteria newly selected when the More Criteria dropdown is displayed.
             */
                {
                    name: "kickass.moreCriteriaNewlySelectedCount",
                    type: AJS.InlineLayer.EVENTS.beforeHide,
                    handler: moreCriteriaDropdownClosed
                },

            /**
             * User clicks new search/filter button
             */
                {
                    name: "kickass.createdNewSearch",
                    selector: ".new-search"
                },

            /**
             * A user sorts by column.
             */
                {
                    name: "kickass.sortByColumn",
                    selector: ".sortable",
                    handler: columnHeaderClicked
                },

            /**
             * A user clicks on the find filters link
             */
                {
                    name: "kickass.findFiltersClicked",
                    selector: ".find-filters"
                }
            ]);

            /**
             * Send the name of the System Filter clicked.
             *
             * @param e The Click event.
             */
            function systemFilterClicked(e) {
                var target = AJS.$(e.target);
                JIRA.Issues.Application.execute("analytics:trigger", this.name, {
                    name: getFilterName(target.attr("href"))
                });
            }

            /**
             * Records a click on the "Save Filter As" link.
             *
             * @param e The Click Event
             */
            function clickedOnSaveFilterAs() {
                var systemFilterSelected = AJS.$(".system-filters a.active").length === 1;
                var favouriteFilterSelected = AJS.$(".favourite-filters a.active").length === 1;

                JIRA.Issues.Application.execute("analytics:trigger", this.name, {
                    systemFilterSelected: systemFilterSelected,
                    favouriteFilterSelected: favouriteFilterSelected
                });
            }

            /**
             * Returns the name of the current filter from a URI.
             *
             * @param uri A URI of your choosing.
             * @return The filter ID or Name.
             */
            function getFilterName(uri) {
                /*eslint-disable no-undef */
                var parsedUri = parseUri(uri);
                /*eslint-enable no-undef */

                return parsedUri.queryKey.filter;
            }

            /**
             * Tracks the page the selected to view.
             *
             * @param e The click event.
             */
            function clickedOnPagniationLink(e) {
                var target = AJS.$(e.target);
                var page = target.text();

                JIRA.Issues.Application.execute("analytics:trigger", this.name, {
                    page: page
                });
            }

            /**
             * Tracks a user pressing ctrl/command-F to search for text.
             *
             * @param e The keydown event.
             */
            function inBrowserSearch(e) {
                if (e.keyCode === 70 && (e.metaKey || e.ctrlKey)) {
                    JIRA.Issues.Application.execute("analytics:trigger", this.name);
                }
            }

            /**
             * Tracks a user pressing ctrl/command-R to reload the page.
             *
             * @param e the keydown event.
             */
            function onReloadPage(e) {
                if (e.keyCode === 82 && (e.metaKey || e.ctrlKey)) {
                    JIRA.Issues.Application.execute("analytics:trigger", this.name);
                }
            }

            function moreCriteriaDropdownClosed(e, layer) {
                if (layer && layer.find("#criteria-multi-select").length) {
                    var dropDown = AJS.$("#criteria-multi-select");
                    var numberOfSelectedCriteria = dropDown.find("input[checked]").length - dropDown.find(".selected-group input[checked]").length;
                    JIRA.Issues.Application.execute("analytics:trigger", this.name, {
                        count: numberOfSelectedCriteria
                    });
                }
            }

            /**
             * When a user clicks on a column header we want to know what they were sorting by and which way.
             *
             * @param e The click event.
             */
            function columnHeaderClicked(e) {
                var header = jQuery(e.target);

                if (!header.is("th")) {
                    header = header.parent("th");
                }

                if (header.length) {
                    JIRA.Issues.Application.execute("analytics:trigger", this.name, {
                        direction: header.hasClass("ascending") ? "descending" : "ascending", // This event occurs before HTML is replaced to display new state
                        column: header.data("id")
                    });
                }
            }


            JIRA.Issues.Application.on("issueEditor:loadComplete", function(model, props) {
                if (!props.fromCache) {
                    JIRA.Issues.Application.execute("analytics:trigger", "kickass.viewIssue", {
                        issueId: model.getId(),
                        loadReason: props.loadReason,
                        duration: props.duration,
                        loadedFromDom: false

                    });
                }

                JIRA.Issues.Application.execute("analytics:trigger", "kickass.issueLoadDuration", {
                    issueId: props.issueId,
                    duration: props.duration,
                    loadReason: props.loadReason,
                    fromCache: props.fromCache
                });
            });

            JIRA.Issues.Application.on("issueEditor:render", function(regions, props) {
                if (props.loadedFromDom) {
                    JIRA.Issues.Application.execute("analytics:trigger", "kickass.viewIssue", {
                        issueId: props.issueId,
                        loadedFromDom: true
                    });
                }
            });

            JIRA.Issues.Application.on("issueEditor:saveSuccess", function(props) {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.inlineEdit", {
                    issueId: props.issueId,
                    savedFieldIds: props.savedFieldIds,
                    savedFieldTypes: props.savedFieldTypes,
                    duration: props.duration
                });
            });

            JIRA.Issues.Application.on("issueEditor:editField", function(props) {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.inlineEdit.start", {
                    issueId: props.issueId,
                    fieldId: props.fieldId,
                    fieldType: props.fieldType
                });
            });

            JIRA.Issues.Application.on("issueEditor:editFieldCancel", function(props) {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.inlineEdit.cancel", {
                    issueId: props.issueId,
                    fieldId: props.fieldId,
                    fieldType: props.fieldType
                });
            });
        }
    };
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/Stalker.js' */
(function ($) {
    "use strict";

    var $placeholder;

    /**
     *
     * @param options
     */
    $.fn.stalker = function (options) {

        var $stalker = this;
        var offset;

        if (!$stalker.length || $stalker.data("stalker-applied")) {
            return;
        }

        $stalker.data("stalker-applied", true);

        options = options || {};
        options.offsetTop = options.offsetTop || 0;

        function unstalk () {
            if ($placeholder) {
                $stalker.css({
                    position: "",
                    top: "",
                    left: "",
                    right: "",
                    height: ""
                }).removeClass("detached");
                $stalker.unbind("stalkerHeightUpdated", updatePlaceholderHeight);
                $placeholder.remove();
                $placeholder = null;
            }
        }

        function stalk() {
            if (!$placeholder) {
                $placeholder = jQuery("<div class='stalker-placeholder' />").css("visibility", "hidden")
                        .addClass($stalker[0].className)
                        .height($stalker.outerHeight())
                        .width($stalker.outerWidth())
                        .insertBefore($stalker);

                $stalker.bind("stalkerHeightUpdated", updatePlaceholderHeight);

                $stalker.css({
                    position: "fixed",
                    top: options.offsetTop,
                    left: offset.left,
                    right: offset.right
                }).addClass("detached");

                if (typeof pollWhenStalking.timeout === 'undefined') pollWhenStalking();
            }
        }

        function updatePlaceholderHeight() {
            $placeholder.height($stalker.height());
        }

        function doStalk () {

            if (!$stalker.is(":visible")) {
                 return;
            }

            if (!offset) {
                offset = $stalker.offset(); // cache offset
            }

            // Is the window top intersecting the stalker
            if ($(window).scrollTop() + options.offsetTop >= offset.top) {
                stalk();
            } else {
                unstalk();
            }
        }

        // IE9 won't trigger a scroll when removing elements, causes the page to jump - so sadly polling is needed.
        // Trying to minimize impact by polling only when stalker is stalking
        function pollWhenStalking () {
            if ($placeholder) {
                doStalk();
                pollWhenStalking.timeout = setTimeout(pollWhenStalking, 250);
            } else {
                delete pollWhenStalking.timeout;
            }
        }

        $(window).bind('resize scroll', doStalk);

        doStalk(); // Trigger straight away incase we have scrolled the page as the result of anchor

        return {
            unstalk: function () {
                unstalk();
                $(window).unbind("resize scroll", doStalk);
            }
        };
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/Sidebar.js' */
/*!
 * Modified by Atlassian
 *
 * jQuery UI Sidebar
 * http://jqueryui.com
 *
 * Depends:
 *   jquery.ui.widget.js
 */
;(function($) {

    $.widget( "ui.sidebar",  {
        version: "0.1",

        /* defaults */
        options: {
            minWidth: function (ui) { return 50; },
            maxWidth: function (ui) { return window.innerWidth; },
            resize: $.noop,
            easeOff: 0
        },

        /**
         * @constructor
         */
        _create: function() {
            _.bindAll(this,
                "_handleDrag",
                "_persist",
                "_setContainment",
                "_setHandlePosition",
                "updatePosition");

            if (this.options.easeOff) {
                this.updatePosition = _.debounce(this.updatePosition, this.options.easeOff);
            }
            if (!this.options.id) {
                /*eslint-disable no-console */
                console.error("ui.sidebar: You must specify an id");
                /*eslint-enable no-console */
            }
            // Create the handle before restoring anything, as the restore operation could fire some events that
            // might end using the handle before it is created. JRADEV-20661
            this._addHandle();
            this._restore();
            $(window).resize(_.debounce(this.updatePosition, 30));
        },

        /**
         * Restores the sidebar to the user configured width
         * @private
         */
        _restore: function () {
            if (window.localStorage) {
                var width = localStorage.getItem("ui.sidebar." + this.options.id);
                if (width) {
                    this._setWidth(width);
                }
            }
        },

        /**
         * Persists the sidebar to the user configured width so it works across page refreshes.
         * @private
         */
        _persist: function () {
            if (window.localStorage) {
                localStorage.setItem("ui.sidebar." + this.options.id, this.element.outerWidth());
            }
        },

        /**
         * Sets the min & max width boundaries for dragging side bar
         * @private
         */
        _setContainment: function () {
            var windowHeight = window.innerHeight;
            this._elementLeft = this.element.offset().left;
            this._minLeft = this._elementLeft + this.options.minWidth(this);
            this._maxLeft = Math.max(this._minLeft, this._elementLeft + this.options.maxWidth(this));
            this.handle.draggable({containment: [this._minLeft, windowHeight,  this._maxLeft, windowHeight]});
        },

        /**\
         * Sets the width of sidebar
         * @param {Object} e
         * @param {Object} ui
         * @private
         */
        _handleDrag: function (e, ui) {
            var target = ui.position.left - this._elementLeft;
            this._setWidth(target, true);
        },

        _setWidth: function (target, force) {
            if (!force) {
                var maxWidth = this.options.maxWidth(this);
                var minWidth = this.options.minWidth(this);
                if (target > maxWidth) {
                    target = maxWidth;
                } else if (target < minWidth) {
                    target = minWidth;
                }
            }
            // JRADEV-20949 Assume box-sizing is border-box, adjusting target width for padding/border.
            // The reason this.element is not box-sizing: border-box is because Safari does not respect this
            // with display: table-cell
            target -= this.element.outerWidth() - this.element.width();
            this.element.width(target);
            this.options.resize(target);
        },


        /**
         * Appends a drag handle next to the sidebar
         * @private
         */
        _addHandle: function () {
            var el = document.createElement("div");
            el.setAttribute("class", "ui-sidebar");
            this.handle = $(el).appendTo(this.element);
            this.handle.draggable({axis: "x", drag: this._handleDrag, stop: this._persist});
            this.handle.mousedown(this._setContainment);
            _.defer(this._setHandlePosition);
        },

        /**
         * Aligns the drag handler to the sidebar
         * @private
         */
        _setHandlePosition: function () {
            this._setContainment();
            if (this._minLeft === this._maxLeft) {
                this.handle.hide();
            } else {
                var elOffset = this.element.offset();
                var left = elOffset.left + this.element.outerWidth();
                this.handle.css({
                    top: elOffset.top,
                    left: left,
                    height: this.element.outerHeight()
                }).show();
            }
        },

        /**
         * Updates position of handle. You trigger this externally by jQuery(".sidebar").sidebar("updatePosition")
         */
        updatePosition: function () {
            this._setHandlePosition();
            this._setWidth(this.handle.offset().left - this._elementLeft);
            this._persist();
        }
    });

})( jQuery );
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/PopoutSidebar.js' */
(function($) {
    "use strict";

    $.widget( "ui.popoutSidebar", {
        version: "0.1",

        options: {
            /**
             * {Function} returns html that is to be rendered when in expanded mode
             */
            renderExpanded: $.noop,
            /**
             * {Function} returns html that is to be rendered when in collapsed mode
             */
            renderCollapsed: $.noop,
            /**
             * {Function} is used to save the docked/undocked state
             */
            persist: $.noop,
            /**
             * {number} width when collapsed
             */
            collapsedWidth: 30,
            /**
             * {number} width when expanded
             */
            expandedWidth: 200,
            /**
             * {Function} returns maximum width sidebar can be extended to
             */
            minWidth: function () { return 200; },
            /**
             * {Function} returns maximum width sidebar can be extended to
             */
            maxWidth: function () { return 500; },
            /**
             * {Function} is used to perform needed operations when the sidebar is being resized
             */
            resize: $.noop,
            /**
             * {string} text to be rendered for dock link
             */
            dockText: "Dock",
            /**
             * {string} text to be rendered for undock link
             */
            undockText: "Undock",
            /**
             * {string} the dock link message when hovered over
             */
            dockTitle: "Dock the filter panel so you can always see the list of filters",
            /**
             * {string} the undock link message when hovered over
             */
            undockTitle: "Undock the filter panel so it is hidden when not being focused"
        },

        CLASS_NAMES: {
            popout: "ui-popout",
            placeholder: "ui-popout-placeholder",
            detached: "ui-popout-detached", // This guy makes the sidebar fixed positioned
            expanding: "ui-popout-expanding",
            expanded: "ui-popout-expanded",
            collapsed: "ui-popout-collapsed",
            collapsing: "ui-popout-collapsing"
        },

        _create: function () {

            _.bindAll(this,
                "_handleDropdown",
                "_registerMousePos",
                "collapse",
                "expand",
                "updateOffsets");

            // avoid binding control twice
            if (!this.element.data("popoutsidebar")) {
                this.element.data("popoutsidebar", true);
                // you can trigger this event by jQuery.event.trigger("updateOffsets.popout")
                this.element.bind("updateOffsets.popout", this.updateOffsets);
                this.element.delegate(".ui-dock", "click", _.bind(function (e) {
                    this.dock(true);
                    e.preventDefault();
                }, this));
                this.element.delegate(".ui-undock", "click", _.bind(function (e) {
                    this.undock(true);
                    e.preventDefault();
                }, this));
                this.isDocked = this.options.isDocked;
                this.expandedWidth = this.options.expandedWidth;
                this.useTransitions = !jQuery.browser.msie || parseInt(jQuery.browser.version, 10) > 8;

                if (this.options.isDocked) {
                    // If not we just render the undock link
                    this._renderUnDock();
                } else {
                    // If we are docked we add all the hover handlers etc
                    this._enableUndockedMode();
                }

                // Ensure the height and positioning of the sidebar is correct
                this.updateOffsets();
            }
        },

        _init: function() {
            if (this.options.isDocked) {
                this._setupHandle();
            }
        },

        /**
         * Persists the state of the sidebar to the user configured colapsed/expanded state and width
         * so it works across page refreshes.
         * @private
         */
        _persistState: function () {
            this.expandedWidth = this.element.outerWidth();
            this.options.persist(this.isDocked, this.expandedWidth);
        },

        /**
         * Sets the min & max width boundaries for dragging side bar
         * @private
         */
        _setContainment: function () {
            var windowHeight = window.innerHeight;
            this._elementLeft = this.element.offset().left;
            this._minLeft = this._elementLeft + this.options.minWidth();
            this._maxLeft = Math.max(this._minLeft, this._elementLeft + this.options.maxWidth());
            this.handle.draggable({containment: [this._minLeft, windowHeight, this._maxLeft, windowHeight]});
            this.handle.css("position", "absolute"); // jQuery UI sets position relative on detached elements
        },

        /**
         * Sets the width of sidebar taking into account the min/max width boundaries
         * @param {integer} target
         * @param {boolean} force
         * @private
         */
        _setWidth: function (target) {
            target = Math.min(Math.max(this.options.minWidth(), target), this.options.maxWidth());
            this.element.width(target);
        },

        /**
         * Adds drag handle to the sidebar and sets events up
         * @private
         */
        _setupHandle: function () {
            this._getContents(); // ensure proper wrapper element is in place before attaching the drag handle
            this.handle = jQuery("<div />").addClass("ui-sidebar").appendTo(this.element);
            this._setWidth(this.expandedWidth);
            this._setHandlePosition();
            this.handle.mousedown(_.bind(this._setContainment, this));
            this.handle.draggable({
                axis: "x",
                drag: _.bind(this._handleDrag, this),
                stop: _.bind(this._persistState, this)
            });
        },

        /**
         * Aligns the drag handler to the sidebar
         * @private
         */
        _setHandlePosition: function () {
            this._setContainment();
            if (this._minLeft === this._maxLeft) {
                this.handle.hide();
            } else {
                var elementOffset = this.element.offset();
                var left = elementOffset.left + this.element.outerWidth();
                this.handle.css({
                    left: left
                }).show();
            }
        },

        /**
         * Sets the width of sidebar while dragging the handle
         * @param {Object} e
         * @param {Object} ui
         * @private
         */
        _handleDrag: function (e, ui) {
            var target = ui.position.left;
            this._setWidth(target);
            this.options.resize();
        },

        /**
         * Returns the list of classes when docked
         * @return {String}
         * @private
         */
        _getUndockedClasses: function () {
            return [this.CLASS_NAMES.detached].join(" ");
        },

        /**
         * Returns the possible states that the undocked filter panel can be in.
         * @returns {string}
         * @private
         */
        _getUndockedStates: function() {
            return [this.CLASS_NAMES.collapsed, this.CLASS_NAMES.collapsing, this.CLASS_NAMES.expanding, this.CLASS_NAMES.expanded].join(" ");
        },

        /**
         * Remove all current undocked states and change it to the defined state.
         * @param stateClass
         * @private
         */
        _setUndockedState: function(stateClass) {
            this.element.removeClass(this._getUndockedStates());
            this.element.addClass(stateClass);
        },


        /**
         * Hover intent doesn't offer us a way to disable it nicely, so we are doing it in hacky way
         * @private
         */
        unbindHoverIntent: function () {
            this.element.off("mouseleave mouseenter mousemove");
            /*eslint-disable camelcase */
            this.element[0].hoverIntent_s = 0;
            /*eslint-enable camelcase */
        },


        /**
         * Applies hover intent
         * http://cherne.net/brian/resources/jquery.hoverIntent.html
         * @private
         */
        bindHoverIntent: function () {
            this.element.hoverIntent({
                interval: 40,
                over: this.expand,
                out: this.collapse,
                sensitivity: 8
            });
        },

        /**
         * Unbinds all the events we have for undocked state
         * @private
         */
        _unbindUnDockedEvents: function () {
            this.unbindHoverIntent();
            JIRA.unbind(AJS.InlineLayer.EVENTS.show, this._handleDropdown);
            $(window).unbind("scroll", this.updateOffsets);
        },

        /**
         * Binds all events needed for undocked state
         * @param {Boolean} isExpanded - Whether when we bind the events the panel is in expanded state
         * @private
         */
        _bindUnDockedEvents: function (isExpanded) {
            this.bindHoverIntent();
            $(window).scroll(this.updateOffsets);
            /*eslint-disable camelcase */
            this.element[0].hoverIntent_s = isExpanded ? 1 : 0;
            /*eslint-enable camelcase */
        },


        /**
         * Is the sidebar undocked
         * @return {Boolean}
         */
        isUndocked: function () {
            return this.element.hasClass(this.CLASS_NAMES.detached);
        },

        _registerMousePos: function (e) {
            this._clientX = e.clientX;
            this._clientY = e.clientY;
        },

        /**
         * If we open a dropdown from within the sidebar, then move our mouse outside the region to select
         * an item in the dropdown, the sidebar collapses. This is a workaround to avoid that behaviour.
         * @private
         */
        _handleDropdown: function () {

            $(document).mousemove(this._registerMousePos);

            if (this.isUndocked() && AJS.InlineLayer.current.offsetTarget().closest(this.element).size()) {
                // DODGY unbind of hover intent. As unbind is unsupported by library.
                this.unbindHoverIntent();
                JIRA.one(AJS.InlineLayer.EVENTS.hide, _.bind(function () {
                    _.defer(_.bind(function () {
                        if (!AJS.InlineLayer.current) {
                            if (JIRA.Dialog.current || this._clientX > this.element.offset().left + this.element.outerWidth()) {
                                // If selecting something in dropdown invokes a dialog we collapse without animation
                                this.collapse(JIRA.Dialog.current ? false : true);
                                // Restore mouseenter, mouseleave events
                                this.bindHoverIntent();
                            } else {
                                // We have clicked inside the sidebar, so we don't want to collapse, just restore events.
                                this.bindHoverIntent();
                                // Manually set hover intent state to reflect "mouseentered state"
                                /*eslint-disable camelcase */
                                this.element[0].hoverIntent_s = 1;
                                /*eslint-enable camelcase */
                            }
                            $(document).unbind("mousemove", this._registerMousePos);
                        }
                    }, this));

                }, this));
            }
        },

        /**
         * Updates the position and height of the sidebar. You can trigger this method by using the event
         * jQuery.event.trigger("updateOffsets.sidebar").
         * @param {Number} width - If provided will set the width of the sidebar also
         */
        updateOffsets: function (width) {
            if (this.element.is(":visible")) {
                var windowHeight = window.innerHeight;
                var isScrollable = $("body").height() > windowHeight;
                if (isScrollable) {
                    this.element.addClass("ui-sidebar-scrollable");
                } else {
                    this.element.removeClass("ui-sidebar-scrollable");
                }
                if (this.isUndocked()) {
                    var placeholderTop = this._getPlaceholder().offset().top;
                    var scrollTop = jQuery(window).scrollTop();
                    var offset = Math.max(placeholderTop - scrollTop, 0);
                    var height = isScrollable ?
                            windowHeight - offset :
                            Math.min(this._getPlaceholder().outerHeight(), windowHeight - this._getPlaceholder().offset().top);
                    var props = {top: offset, height: height};
                    if (width) {
                        props.width = width;
                    }
                    this.element.css(props);
                }
            }
        },

        /**
         * Renders undock link at bottom of sidebar
         * @private
         */
        _renderUnDock: function () {
            if (this.isDocked && !this.element.find(".ui-undock").size()) {
                this.element.find(".ui-dock").remove();
                this._renderDockingLink(this.options.undockText, this.options.undockTitle, "ui-undock");
            }
        },

        /**
         * Renders doc link at bottom of sidebar
         * @private
         */
        _renderDock: function () {
            if (this.isUndocked() && !this.element.find(".ui-dock").size()) {
                this.element.find(".ui-undock").remove();
                this._renderDockingLink(this.options.dockText, this.options.dockTitle, "ui-dock");
            }
        },

        /**
         * Renders the actual link with specific text and titles.
         * @param text of link
         * @param title to display when hovering
         * @param dockClass css class of docking link.
         * @private
         */
        _renderDockingLink: function(text, title, dockClass) {
            var link = $("<a class='aui-button aui-button-subtle' href='#'/>")
                    .addClass(dockClass)
                    .append($("<span class='icon'/>").text(text))
                    .attr("title", title);

            this.dockTipsy = new JIRA.Issues.Tipsy({ el: link });

            this._getContents().find(this.options.toggleTarget).append(link);
        },

        /**
         * Renders the correct undock or dock link at the bottom of sidebar
         */
        renderDockState: function () {
            if (this.isDocked) {
                this._renderUnDock();
            } else {
                this._renderDock();
            }
        },

        /**
         * Enables undocked mode by appending element to the body and applying all the correct events.
         *
         * @param {Boolean} isExpanded - is the sidebar currently expanded
         * @private
         */
        _enableUndockedMode: function (isExpanded) {
            this.element.addClass(this.CLASS_NAMES.popout);
            if (!this.isUndocked()) {
                this._getPlaceholder().insertBefore(this.element);
                this.element.addClass(this.CLASS_NAMES.detached).addClass(this.CLASS_NAMES.collapsed).appendTo("body");
            }
            this.updateOffsets();
            this._bindUnDockedEvents(isExpanded);

            JIRA.bind(AJS.InlineLayer.EVENTS.show, this._handleDropdown);
        },

        /**
         * Returns placeholder, which holds the realestate, as our element is fixed positioned when in undocked mode.
         * @return {jQuery}
         * @private
         */
        _getPlaceholder: function () {
            if (!this.placeholder) {
                this.placeholder = $("<div class='navigator-sidebar collapsed' />");
            }
            return this.placeholder;
        },

        toggle: function () {
            //if not in a collapsed or expanded state
            if (!this.isExpanding() && !this.isCollapsing()) {
                if (this.isDocked) {
                    this.undock(false);
                } else {
                    this.dock(false);
                }
            }
        },

        /**
         * Undocks sidebar
         */
        undock: function (hasTransition) {
            if (!this.isUndocked()) {
                this.isDocked = false;
                if (this.dockTipsy) {
                    this.dockTipsy.remove();
                    this.dockTipsy = null;
                }
                this._persistState();
                this._getPlaceholder().insertBefore(this.element);
                this.element.addClass(this._getUndockedClasses() + " " + this.CLASS_NAMES.expanded).appendTo("body");
                if (hasTransition !== false && this.useTransitions) {
                    this._getPlaceholder().width(this.expandedWidth).animate({width: this.options.collapsedWidth}, 200);
                } else {
                    this._getPlaceholder().width(this.options.collapsedWidth);
                }
                this.updateOffsets(this.expandedWidth);
                this.collapse(hasTransition, _.bind(function () {
                    this._enableUndockedMode(false);
                }, this));

            }
        },

        /**
         * Docks sidebar
         */
        dock: function (hasTransition) {
            if (this.isUndocked()) {
                this.isDocked = true;
                if (this.dockTipsy) {
                    this.dockTipsy.remove();
                    this.dockTipsy = null;
                }
                this._unbindUnDockedEvents();
                this._persistState();
                if (hasTransition !== false && this.useTransitions) {
                    this._getPlaceholder().animate({width: this.expandedWidth}, 200, _.bind(this._dockingComplete, this));
                } else {
                    this._dockingComplete();
                }
            }
        },

        /**
         * Tasks to be completed when the docking process is complete.
         * @private
         */
        _dockingComplete: function() {
            this.element.removeClass(this._getUndockedClasses());
            this.element.removeClass(this._getUndockedStates());
            this.element.css({height: "", width: "", top: ""}).insertBefore(this._getPlaceholder());
            this._getPlaceholder().remove();
            this.options.renderExpanded(this.element);
            this._setupHandle();
            this._renderUnDock();
            JIRA.Issues.triggerHorizontalResize();
        },

        /**
         * Wraps the contents of the sidebar in a div. We use this to fade in the contents
         * @return {*}
         * @private
         */
        _getContents: function () {
            if (!this.element.find(".ui-sidebar-content").size()) {
                this.element.wrapInner("<div class='ui-sidebar-content' />");
            }
            return this.element.find(".ui-sidebar-content");
        },

        /**
         * Handles the transition to expanded
         * @private
         */
        expand: function (animate) {
            if (this.isCollapsed()) {
                this.updateOffsets();
                if (animate !== false && this.useTransitions) {
                    this._setUndockedState(this.CLASS_NAMES.expanding);
                    this.element.animate({width: this.expandedWidth}, 150, _.bind(function() {
                        this._setUndockedState(this.CLASS_NAMES.expanded);
                        this.options.renderExpanded(this.element);
                        this._renderDock();
                        this._getContents().css("opacity", 0).animate({opacity: 1}, 200, _.bind(this._expandingComplete, this));
                    }, this));
                } else {
                    this.element.css("width", this.expandedWidth);
                    this.options.renderExpanded(this.element);
                    this._renderDock();
                    this._expandingComplete();
                }
            } else if (this.isCollapsing()) {
                this.activityAfterTransition = "expand";
            } else if (this.isExpanding()) {
                this.activityAfterTransition = null;
            }
        },

        /**
         * Executed after the filter panel has finished expanding.
         * @private
         */
        _expandingComplete: function() {
            JIRA.Issues.triggerHorizontalResize();
            this._bindUnDockedEvents(true);
            this._setUndockedState(this.CLASS_NAMES.expanded);
            if (this.activityAfterTransition === "collapse") {
                this.activityAfterTransition = null;
                this.collapse(true);
            }
        },

        /**
         * Handles the transition to collapsed
         * @private
         */
        collapse: function (animate, callback) {
            if (this.isExpanded()) {
                if (animate !== false && this.useTransitions) {
                    this._setUndockedState(this.CLASS_NAMES.collapsing);
                    this._getContents().animate({opacity: 0}, 150, _.bind(function() {
                        this.options.renderCollapsed(this.element);
                        this.element.width(this.expandedWidth);
                        this.element.animate({width: this.options.collapsedWidth}, 150, _.bind(function () {
                            this._collapsingComplete(callback);
                        }, this));
                    }, this));
                } else {
                    this.options.renderCollapsed(this.element);
                    this.element.width("");
                    this._collapsingComplete(callback);
                }
            } else if (this.isExpanding()) {
                this.activityAfterTransition = "collapse";
            } else if (this.isCollapsing()) {
              this.activityAfterTransition = null;
            }
        },

        /**
         * This is executed after collapsing has completed.
         * @private
         */
        _collapsingComplete: function(callback) {
            this._setUndockedState(this.CLASS_NAMES.collapsed);
            JIRA.Issues.triggerHorizontalResize();
            this._bindUnDockedEvents(false);
            if (this.activityAfterTransition === "expand") {
                this.activityAfterTransition = null;
                this.expand(true);
            }
            if (typeof callback === "function") {
                callback();
            }
        },

        isCollapsed: function() {
            return this.element.hasClass(this.CLASS_NAMES.collapsed);
        },

        isCollapsing: function() {
            return this.element.hasClass(this.CLASS_NAMES.collapsing);
        },

        isExpanded: function() {
            return this.element.hasClass(this.CLASS_NAMES.expanded);
        },

        isExpanding: function() {
            return this.element.hasClass(this.CLASS_NAMES.expanding);
        }
    });

}(jQuery));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/HtmlCatchExceptions.js' */
(function($) {
    "use strict";

    var catchExceptions = function(fn) {
        return function(html) {
            try {
                fn.apply(this, arguments);
            } catch (e) {
                /*eslint-disable no-console */
                if (console && console.error && typeof html === 'string') {
                    console.error('Error while evaluating HTML: ' + e.message + ', in: ', html);
                }
                /*eslint-enable no-console */
            }
            return this;
        };
    };

    $.fn.htmlCatchExceptions = catchExceptions($.fn.html);
    $.fn.appendCatchExceptions = catchExceptions($.fn.append);
    $.fn.prependCatchExceptions = catchExceptions($.fn.prepend);

    $.catchExceptions = function(html) {
        // Done this way because $(html) doesn't evaluate scripts until elements are added to the document
        return $('<div>').htmlCatchExceptions(html).children();
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/mixin/SingleSelect.js' */
define("jira/issues/mixin/singleselect", function() {
    "use strict";

    /**
     * Mixin that provides single selection on a collection.
     * Requires that the object being mixed into provides "getSelected" and "setSelected" methods. These can be created by having a "selected" attribute or otherwise.
     */
    return {

        /**
         * collection: item in selection
         */
        properties: ["collection"],

        /**
         * Selects the model with the given id. No validation is done; if the id is invalid, this.selected will be undefined.
         * @param id if of model to select.
         */
        selectById: function(id) {
            this.setSelected(this.getCollection().get(id));
        },

        /**
         * Selects the model and the given index.
         * @param index index of model to select
         */
        selectAt: function(index) {
            this.setSelected(this.getCollection().at(index));
        },

        /**
         * Clears selection
         */
        clearSelection: function() {
            this.setSelected();
        },

        /**
         * Selects the next element, or the first if none is selected.
         */
        next: function() {
            var selected = this.getSelected();
            var col = this.getCollection();

            if (!selected) {
                if (col.length > 0) {
                    this.setSelected(col.first());
                }
            }
            else {
                var index = col.indexOf(selected);
                var nextIndex = (index + 1) % col.length;
                this.setSelected(col.at(nextIndex));
            }
        },

        /**
         * Selects the previous element, or the last if none is selected.
         */
        prev: function() {
            var selected = this.getSelected();
            var col = this.getCollection();

            if (!selected) {
                if (col.length > 0) {
                    this.setSelected(col.last());
                }
            }
            else {
                var index = col.indexOf(selected);
                var nextIndex = (index + col.length - 1) % col.length;
                this.setSelected(col.at(nextIndex));
            }
        }
    };

});


// There was no amd-wrapper.js created for 'mixin', as it made little sense to have an amd-wrapper.js for only this file.
AJS.namespace("JIRA.Issues.Mixin.SingleSelect", null, require("jira/issues/mixin/singleselect"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/DefaultMessageOptions.js' */
(function(){
    "use strict";
    
    AJS.namespace('JIRA.Issues.getDefaultMessageOptions', window, function() {
        return {
            closeable: true,
            timeout: 5
        };
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/SessionTimedOutDialog.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Issues.SessionTimedOutDialog");
    JIRA.Issues.SessionTimedOutDialog = {

        dialogHasShown: false,

        whiteList: [
            "/secure/Search!Jql.jspa",
            "/secure/SearchRendererEdit!Default.jspa",
            "/rest/issueNav/1/issueTable",
            "/rest/issueNav/latest",
            "/rest/api/2/filter"
        ],

        onRequestResponse: function(e, resp, opts) {

            if (!this.dialogHasShown && this.urlIsInWhiteList(opts.url)) {
                var currentUserName = JIRA.Issues.LoginUtils.loggedInUserName();
                var responseUserName = resp.getResponseHeader("X-AUSERNAME");

                if (this.userHasChanged(currentUserName, responseUserName)) {
                    this.dialogHasShown = true;
                    var dialog = new JIRA.FormDialog({
                        content: AJS.$(JIRA.Templates.Issues.Util.anonymousErrorDialog({
                            modifierKey: AJS.Navigator.modifierKey(),
                            redirect: window.location.href.substring(window.location.href.indexOf(AJS.contextPath()) + AJS.contextPath().length)
                        }))
                    });
                    dialog.show();
                }
            }
        },

        userHasChanged: function(currentUserName, responseUserName) {
            // User is anonymous and page has loaded in that state
            // Or possibly the user logged in and out elsewhere ~ however this is a bit edgecasey.
            if (currentUserName === "" && responseUserName === "anonymous") {
                return false;
            }

            // User loaded the page as anonymous and logged in elsewhere
            if (currentUserName === "" && responseUserName && responseUserName !== "anonymous" && responseUserName !== "") {
                return false;
            }

            // User was previously logged in and now their username is now anonymous (session timed out).
            if (currentUserName !== "" && responseUserName === "anonymous") {
                return true;
            }

            return false;
        },

        urlIsInWhiteList: function(url) {
            for (var i = 0; i < this.whiteList.length; i++) {
                var whiteListUrl = this.whiteList[i];
                if (url.indexOf(whiteListUrl) > -1) {
                    return true;
                }
            }

            return false;
        }
    };

    (function($) {
        $(document).ajaxComplete(function(e, resp, opts) {
            JIRA.Issues.SessionTimedOutDialog.onRequestResponse(e, resp, opts);
        });
    })(AJS.$);
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/LoginUtils.js' */
(function(){
    "use strict";


    JIRA.Issues.LoginUtils = {

        /**
         * Returns true if the current user is logged in
         */
        isLoggedIn: function() {
            return !!this.loggedInUserName();
        },

        /**
         * Returns the name of the currently logged in user
         */
        loggedInUserName: function() {
            return AJS.Meta.get('remote-user');
        },

        /**
         * Returns the path of the current page, relative to the contextPath
         * eg if we are at http://localhost:2990/jira/issues/?jql=blah#pos, returns /issues?jql=blah#pos
         */
        currentContextRelativePath: function() {
            var loc = this._getWindowLocation();
            var start = loc.protocol + "//" + loc.host + (AJS.contextPath() || '');
            var href = loc.href;
            if (href.indexOf(start) === 0) {
                return href.substr(start.length);
            }
            return href;
        },

        /**
         * Returns url to redirect to the current page (eg /login.jsp?os_destination=[encodedCurrentUrl]
         * @returns login url
         */
        redirectUrlToCurrent: function() {
            var url = this.currentContextRelativePath();
            return AJS.contextPath() + '/login.jsp?os_destination=' + encodeURIComponent(url);
        },

        /**
         * Returns url to redirect to (eg /login.jsp?os_destination=[encodedUrl]
         * @param url url to redirect to after user has logged in
         * @returns login url
         */
        redirectUrl: function(url) {
            return AJS.contextPath() + '/login.jsp?os_destination=' + encodeURIComponent(url);
        },

        /**
         * Returns window.location; provided to make mocking out easier
         */
        _getWindowLocation: function() {
            return window.location;
        }
    };

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/search/cache/IssueCacheManager.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.Cache.IssueCacheManager");

    /**
     * Updates a <tt>ViewIssueData</tt> issue cache in response to changes in a <tt>SearchResults</tt> instance.
     * <p/>
     * This includes removing deleted issues from the cache and pre-fetching issues that are likely to be requested.
     */
    JIRA.Issues.Cache.IssueCacheManager = JIRA.Issues.BaseEvented.extend({
        /**
         * @param {object} options
         * @param {JIRA.Issues.SearchResults} options.searchResults The application's <tt>SearchResults</tt> instance.
         * @param {JIRA.Components.IssueViewer.Legacy.ViewIssueData} options.viewIssueData The application's <tt>ViewIssueData</tt> instance.
         */
        initialize: function(options) {
            this.searchResults = options.searchResults;
            this.viewIssueData = options.viewIssueData;

            this.searchResults.bind("issueDeleted", this._onIssueDeleted, this);
            this.searchResults.bind("nextIssueSelected", this._onNextIssueSelected, this);
            this.searchResults.bind("prevIssueSelected", this._onPrevIssueSelected, this);

            this._prefetchCandidate = null;
        },

        /**
         * Triggers pre-fetching of issues that this IssueCacheManager sees fit to pre-fetch. Calling this method is
         * essentially a hint to the IssueCacheManager that now is a good time to fetch things from the server.
         */
        prefetchIssues: function() {
            if (this._prefetchCandidate && this._prefetchCandidate.key) {
                this._prefetchIssue(this._prefetchCandidate.key);
                this._prefetchCandidate = null;
            }
        },

        scheduleIssueToBePrefetched: function(issue) {
            this._prefetchCandidate = issue;
        },

        /**
         * Remove an issue from the cache in response to its deletion.
         *
         * @param {object} issue
         * @param {number} issue.id The issue's ID.
         * @param {string} issue.key The issue's key.
         * @private
         */
        _onIssueDeleted: function(issue) {
            this.viewIssueData.remove(issue.key);
        },

        /**
         * Handles a SearchResults "nextIssueSelected" event.
         *
         * @param event the event
         * @param event.selected the currently selected issue in the search results
         * @param event.next the next issue in the search results
         */
        _onNextIssueSelected: function(event) {
            // mark the issue just after the selected one as a candidate for pre-fetching
            this._prefetchCandidate = event.nextNextIssue;
        },

        /**
         * Handles a SearchResults "prevIssueSelected" event.
         *
         * @param event the event
         * @param event.selected the currently selected issue in the search results
         * @param event.next the next issue in the search results
         */
        _onPrevIssueSelected: function(event) {
            // mark the issue just previous to the selected one as a candidate for pre-fetching
            this._prefetchCandidate = event.prevPrevIssue;
        },

        /**
         * Pre-fetches an issue by getting it from the cache.
         */
        _prefetchIssue: function(issueKey) {
            if (!JIRA.Issues.DarkFeatures.NO_PREFETCH.enabled()) {
                this.viewIssueData.get(issueKey, false, {prefetch: true});
            }
        }
    });
})();
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/search/issue/SimpleIssue.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.SimpleIssue");

    JIRA.Issues.SimpleIssue = JIRA.Issues.BaseModel.extend({
        properties: ["id", "key"],
        defaults: {
            id: null,
            key: null
        },
        hasIssue: function() {
            return !!this.getId();
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/search/issue/FullScreenIssue.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.FullScreenIssue");

    JIRA.Issues.FullScreenIssue = JIRA.Issues.BaseView.extend({

        namedEvents: ["issueHidden"],

        initialize: function(options) {
            _.extend(this, options);
            _.bindAll(this,
                "onLoadComplete",
                "showError");

            if (this.issueContainer.hasClass("hidden")) {
                this.issueContainer.detach();
                this.issueContainer.removeClass("hidden");
            }

            if (this.searchContainer.hasClass("hidden")) {
                this.searchContainer.detach();
                this.searchContainer.removeClass("hidden");
            }
        },

        bindSearchService: function(searchService) {
            this.listenTo(searchService, {
                "issueUpdated": function(issueId, entity, reason) {
                    if (reason.action !== "inlineEdit" && reason.action !== "rowUpdate") {
                        return this.updateIssue(reason);
                    }
                },
                "selectedIssueChanged": function(selectedIssue) {
                    if (selectedIssue.hasIssue()) {
                        JIRA.Issues.Application.execute("issueEditor:abortPending");
                        //TODO Why do we need to debounce this?
                        //JIRA.Issues.Utils.debounce(this, "_loadIssue", issue);
                        this.show({
                            id: selectedIssue.getId(),
                            key: selectedIssue.getKey(),
                            pager: searchService.getPager()
                        });
                        this.updatePager(searchService.getPager());
                    } else {
                        if (this.isVisible()) {
                            this.hide();
                            JIRA.trace("jira.returned.to.search");
                            JIRA.trace("jira.psycho.returned.to.search");
                            JIRA.Issues.Application.execute("analytics:trigger", 'kickass.returntosearch');
                        }
                        //TODO Why the full $navigatorContent is marked as pending?
                        //this.$navigatorContent.removeClass("pending");
                    }
                }
            });
        },

        deactivate: function() {
            this.stopListening();
            if (this.active) {
                if (this.stalker) {
                    this.stalker.unstalk();
                }
                JIRA.Issues.Application.off("issueEditor:loadComplete", this.onLoadComplete);
                JIRA.Issues.Application.off("issueEditor:loadError", this.showError);
                JIRA.Issues.Application.execute("issueEditor:abortPending");
                this.active = false;
            }
        },

        activate: function() {
            if (!this.active) {
                JIRA.Issues.Application.on("issueEditor:loadComplete", this.onLoadComplete);
                JIRA.Issues.Application.on("issueEditor:loadError", this.showError);
                this.active = true;
            }
        },

        onLoadComplete: function(model, props) {
            this.stalker = AJS.$(".js-stalker", this.issueContainer).stalker();
            this._makeIssueVisible();
            if (props.isNewIssue) {
                this._scrollToTop();
            }
        },

        _makeIssueVisible: function() {
            JIRA.Issues.Application.execute("issueEditor:beforeShow");
            this._setBodyClasses({
                error: false,
                issue: true,
                search: true
            });

            if (!this.isVisible()) {
                this.issueContainer.insertBefore(this.searchContainer);
                this.searchContainer.detach();

                JIRA.trace("jira.psycho.issue.refreshed", {id: JIRA.Issues.Application.request("issueEditor:getIssueId")});
                JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [this.issueContainer, JIRA.CONTENT_ADDED_REASON.pageLoad]);
            }
        },

        /**
         * Refresh the visible issue in response to an issue update.
         *
         * @param {object} issueUpdate An issue update object (see <tt>JIRA.Issues.Utils.getUpdateCommandForDialog</tt>).
         * @return {jQuery.Deferred} A deferred that is resolved after the issue has been refreshed.
         */
        updateIssue: function(issueUpdate) {
            var deferred;
            var isVisibleIssue;

            isVisibleIssue = issueUpdate.key === JIRA.Issues.Application.request("issueEditor:getIssueKey");

            if (this.isVisible()) {
                deferred = JIRA.Issues.Application.request("issueEditor:refreshIssue", issueUpdate);
                deferred.done(function() {
                    if (!isVisibleIssue && issueUpdate.message) {
                        JIRA.Issues.showNotification(issueUpdate.message, issueUpdate.key);
                    }
                });
            } else {
                deferred = new jQuery.Deferred().resolve().promise();
            }

            return deferred;
        },

        /**
         * Show error message for loading issue
         */
        showError: function() {
            this._setBodyClasses({
                error: true,
                issue: false,
                search: false
            });
        },

        /**
         * @return {boolean} whether an issue is visible.
         */
        isVisible: function() {
            return this.issueContainer.closest("body").length > 0;
        },

        /**
         * Scroll to the top of the window.
         *
         * @private
         */
        _scrollToTop: function() {
            AJS.$(window).scrollTop(0);
        },

        _setBodyClasses: function(options) {
            AJS.$("body")
                .toggleClass("page-type-message", options.error)
                .toggleClass("navigator-issue-only", options.issue)
                .toggleClass("page-type-navigator", options.search);
        },

        hide: function() {
            this._setBodyClasses({
                error: false,
                issue: false,
                search: true
            });

            if (this.isVisible()) {
                this.searchContainer.insertBefore(this.issueContainer);
                this.issueContainer.detach();
                this.trigger("issueHidden");
            }
        },

        updatePager: function(pager) {
            JIRA.Issues.Application.execute("pager:update", pager);
        },

        /**
         * Load and show an issue.
         *
         * @param {object} issue The issue to show.
         * @param {number} issue.id The issue's ID.
         * @param {string} issue.key The issue's key.
         * @return {jQuery.Deferred} A deferred that is resolved when the issue is visible.
         */
        show: function(issue) {
            this.activate();
            JIRA.Issues.Application.execute("issueEditor:setContainer", this.issueContainer);
            return JIRA.Issues.Application.request("issueEditor:loadIssue", issue).always(_.bind(function() {
                AJS.$(".js-stalker", this.issueContainer).stalker();

                this.updatePager(issue.pager);
                // now is a good time to pre-fetch anything that needs to be pre-fetched
                if (this.issueCacheManager) {
                    this.issueCacheManager.prefetchIssues();
                }
            }, this));
        },

        isLoading: function() {
            return JIRA.Issues.Application.request("issueEditor:isCurrentlyLoading");
        },

        registerIssueCacheManager: function(issueCacheManager) {
            this.issueCacheManager = issueCacheManager;
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/Resize.js' */
/**
 * A vertical resize event is triggered when the page changes in such a way that elements may need to resize themselves
 * vertically (e.g. an element is added/removed, or an element's height changes).
 */
(function () {
    "use strict";

    var horizontalEventName = "horizontalResize";
    var verticalEventName = "verticalResize";

    JIRA.Issues.offHorizontalResize = function (block) {
        AJS.$(document).off(horizontalEventName, block);
    };

    JIRA.Issues.onHorizontalResize = function (block) {
        AJS.$(document).on(horizontalEventName, block);
    };

    JIRA.Issues.triggerHorizontalResize = _.throttle(function () {
        AJS.$(document).trigger(horizontalEventName);
    }, 100);

    JIRA.Issues.offVerticalResize = function (block) {
        AJS.$(document).off(verticalEventName, block);
    };

    JIRA.Issues.onVerticalResize = function (block) {
        AJS.$(document).on(verticalEventName, block);
    };

    JIRA.Issues.triggerVerticalResize = _.throttle(function () {
        AJS.$(document).trigger(verticalEventName);
    }, 100);

    jQuery(window).resize(JIRA.Issues.triggerVerticalResize);
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:common', location = 'content/js/util/QueryStringParser.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Issues.QueryStringParser");

    // Ruthlessly plundered from parseUri.js. Arrrrr me hearties!
    JIRA.Issues.QueryStringParser = {
        parser: /(?:^|&)([^&=]*)=?([^&]*)/g,

        parse: function(queryString) {
            if (!queryString && queryString !== 0) {
                return {};
            }
            queryString = "" + queryString;
            if ("?" === queryString.charAt(0)) {
                queryString = queryString.substring(1);
            }
            var params = {};
            queryString.replace(this.parser, function ($0, $1, $2) {
                var v = decodeURIComponent(($2 || "").replace(/\+/g, " "));
                params[decodeURIComponent($1)] = v;
            });
            return params;
        }
    };

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/orderby.soy' */
// This file was automatically generated from orderby.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.OrderBy.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.OrderBy == 'undefined') { JIRA.Templates.OrderBy = {}; }


JIRA.Templates.OrderBy.orderBy = function(opt_data, opt_ignored) {
  return ((opt_data.sortBy && opt_data.sortBy.fieldId) ? '<a class="order-by ' + ((opt_data.sortBy.order == 'ASC') ? 'ascending' : 'descending') + '" data-field-id="' + soy.$$escapeHtml(opt_data.sortBy.fieldId) + '" data-direction="' + soy.$$escapeHtml(opt_data.sortBy.order) + '" href="#" title="' + soy.$$escapeHtml(AJS.format("Order by {0}",opt_data.sortBy.fieldName)) + '"><span>' + soy.$$escapeHtml(AJS.format("Order by {0}",opt_data.sortBy.fieldName)) + '</span><span class="aui-icon aui-icon-small aui-iconfont-' + ((opt_data.sortBy.order == 'ASC') ? 'up' : 'down') + '"></span></a>' : '<a class="order-by" title="' + soy.$$escapeHtml("Order by") + '"><span>' + soy.$$escapeHtml("Order by") + '</span></a>') + '<a class="order-options" title="' + soy.$$escapeHtml("Select the field that issues are ordered by.") + '">' + soy.$$escapeHtml("Select the field that issues are ordered by.") + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.OrderBy.orderBy.soyTemplateName = 'JIRA.Templates.OrderBy.orderBy';
}


JIRA.Templates.OrderBy.orderByOptions = function(opt_data, opt_ignored) {
  var output = '<select id="order-by-options" multiple="multiple" class="hidden"><optgroup data-footer-text="' + soy.$$escapeHtml(opt_data.footer) + '">';
  var optionList41 = opt_data.options;
  var optionListLen41 = optionList41.length;
  for (var optionIndex41 = 0; optionIndex41 < optionListLen41; optionIndex41++) {
    var optionData41 = optionList41[optionIndex41];
    output += '<option title="' + soy.$$escapeHtml(optionData41.fieldName) + '" value="' + soy.$$escapeHtml(optionData41.fieldId) + '" data-meta="' + soy.$$escapeHtml(optionData41.meta) + '">' + soy.$$escapeHtml(optionData41.fieldName) + '</option>';
  }
  output += '</optgroup></select>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.OrderBy.orderByOptions.soyTemplateName = 'JIRA.Templates.OrderBy.orderByOptions';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/OrderByModel.js' */
define("jira/components/orderby/orderbymodel", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var jQuery = require("jquery");
    var contextPath = AJS.contextPath();

    /**
     * Model for order by dropdown & toggle
     *
     * @type JIRA.Issues.OrderByModel
     */
    return Brace.Model.extend({

        namedEvents: ["sort"],
        namedAttributes: ["sortBy", "jql"],

        initialize: function() {
            this.on("change:jql", this.updateSelectedSort, this);
        },

        /**
         * Whenever we change jql get the data we need to display the description of the order (the ASC/DEC toggle)
         */
        updateSelectedSort: function() {
            jQuery.ajax({
                type: "POST",
                url: contextPath + "/rest/orderbycomponent/latest/orderByOptions/primary",
                data: JSON.stringify({jql: this.getJql()}),
                contentType: 'application/json',
                success: _.bind(function(res) {
                    this.setSortBy(res);
                }, this)
            });
        },

        /**
         * Toggles sort jql between DESC/ASC
         */
        toggleSort: function() {
            this.setJql(this.getSortBy().toggleJql);
            this.triggerSort(this.getJql());
        },

        /**
         * Sets updated jql and publishes event
         * @param jql
         */
        doSort: function(jql) {
            this.setJql(jql);
            this.triggerSort(this.getJql());
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/OrderByView.js' */
define("jira/components/orderby/orderbyview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var jQuery = require("jquery");
    var Events = require("jira/util/events");
    var OrderByEventTypes = require("jira/components/orderby/eventtypes");
    var OrderByTemplates = require("jira/components/orderby/templates");
    var OrderByDropDownView = require("jira/components/orderby/orderbydropdownview");

    /**
     * The order by view that's shown over the list of issues in split view.
     *
     * @type JIRA.Issues.OrderByView
     */
    return Brace.View.extend({

        template: OrderByTemplates.orderBy,

        events: {
            "click a.order-by": "_onClickOrderBy",
            "click a.order-options": "_toggleShowDropDown"
        },

        initialize: function() {
            // Whenever the sort jql changes then we re-render
            this.model.on("change:sortBy", this.render, this);
        },

        /**
         * Renders this view base on the SearchResults' 'sortBy' property.
         *
         * @return {JIRA.Issues.OrderByView}
         */
        render: function() {
            this.$el.html(this.template(this.model.toJSON()));
            return this;
        },

        deactivate: function() {
            // make sure we cleanup events when we switch to list view
            if (this.orderByDropDown) {
                this.orderByDropDown.deactivate();
            }
            this.undelegateEvents();
        },

        /**
         * Toggles sort between ASC/DESC
         * @param e
         */
        _onClickOrderBy: function(e) {
            var event = new jQuery.Event(OrderByEventTypes.ISSUE_TABLE_REORDER);
            Events.trigger(event);
            if (!event.isDefaultPrevented()) {
                var fieldId = jQuery(e.currentTarget).data('field-id');
                if (fieldId) {
                    this.model.toggleSort();
                }
            }
            e.preventDefault();
        },
        /**
         * Hiding/Showing of sparkler
         */
        _toggleShowDropDown: function(e) {
            if (!this.orderByDropDown) {
                // lazy create
                this.orderByDropDown = new OrderByDropDownView({
                    model: this.model,
                    offsetTarget: this.$('a.order-by'),
                    onHideCallback: _.bind(function() {
                        this.orderByDropDown = null;
                    }, this)
                });
            }
            this.orderByDropDown.toggle();
            e.preventDefault();
        }

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/OrderByDropDownView.js' */
define("jira/components/orderby/orderbydropdownview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var jQuery = require("jquery");
    var Events = require("jira/util/events");
    var OrderByEventTypes = require("jira/components/orderby/eventtypes");
    var OrderByTemplates = require("jira/components/orderby/templates");
    var InlineLayer = require('jira/ajs/layer/inline-layer');
    var CheckboxMultiSelect = require("jira/ajs/select/checkbox-multi-select");
    var SelectSuggestHandler = require('jira/ajs/select/suggestions/select-suggest-handler');
    var GroupDescriptor = require("jira/ajs/list/group-descriptor");
    var ItemDescriptor = require("jira/ajs/list/item-descriptor");
    var BaseView = require("jira/issues/baseview");
    var Tipsy = require("jira/issues/tipsy");
    var contextPath = AJS.contextPath();

    /**
     * A pop-up where we display the new sort options.
     *
     * @type {JIRA.Issues.OrderByDropDownView}
     */
    return Brace.View.extend({
        /**
         * Creates a new OrderByDropDownView.
         *
         * @param {object} options
         * @param {JIRA.Issues.SearchModule} options.search the SearchModule
         * @param {Element} options.offsetTarget the element that the drop-down will be positioned under
         */
        initialize: function(options) {
            _.bindAll(this, '_onDropdownHidden', '_onDropdownShown');
            this.offsetTarget = options.offsetTarget;
            this._onHideCallback = options.onHideCallback;
            this._pending = null;
            this._inlineLayer = null;
        },

        /**
         * Hides this OrderByDropDownView and cancels any pending AJAX requests.
         */
        deactivate: function() {
            if (this._inlineLayer) {
                this._inlineLayer.hide();
            }
            BaseView.prototype.deactivate.apply(this, arguments);
        },

        /**
         * Toggles the visibility of this OrderByDropDownView, cancelling any pending AJAX requests when appropriate.
         */
        toggle: function() {
            // depending on whether the InlineLayer is visible or not we either
            // cancel pending requests or kick off new ones.
            if (!this._inlineLayer) {
                this._pending = jQuery.ajax(this._ajaxDefaults());
                this._inlineLayer = this._createInlineLayer(this._pending);
                this._inlineLayer.bind(InlineLayer.EVENTS.show, this._onDropdownShown);
                this._inlineLayer.bind(InlineLayer.EVENTS.hide, this._onDropdownHidden);
                this._inlineLayer.show();
            } else {
                this._inlineLayer.hide();
            }
        },

        /**
         * Creates the drop-down InlineLayer with the single select inside of it.
         *
         * @param deferred
         * @return {InlineLayer}
         * @private
         */
        _createInlineLayer: function(deferred) {
            var renderSelectAndAddTipsy = _.bind(function(data) {
                this._deferredAddTipsyToFooter(data);
                return this._renderInitialContent(data);
            }, this);

            var inlineLayer = new InlineLayer({
                offsetTarget: this.offsetTarget,
                content: function() {
                    return deferred.pipe(renderSelectAndAddTipsy);
                },
                width: 218
            });

            if (this._onHideCallback) {
                inlineLayer.bind(InlineLayer.EVENTS.hide, this._onHideCallback);
            }

            return inlineLayer;
        },

        /**
         * Enhances the order by single select to use a sparkler instead of a plain old HTML select list.
         *
         * @param {InlineLayer} layer the layer that contains the select
         * @private
         */
        _initSingleSelect: function(layer) {
            var orderBySelect = layer.find('select');

            // we are using a sparkler as if it were a single select here. to do this we
            // programatically hide the sparkler whenever the user clicks one of the options.
            orderBySelect.bind("selected", _.bind(this._onFieldSelected, this));

            this.selectControl = new CheckboxMultiSelect({
                element: orderBySelect,
                itemAttrDisplayed: "label",
                suggestionsHandler: SelectSuggestHandler,
                ajaxOptions: this._ajaxDefaults({
                    data: _.bind(function(query) {
                        return JSON.stringify(this._ajaxOptionsData(query));
                    }, this),
                    query: true, // keep going back to the sever for each keystroke
                    minQueryLength: 0,
                    formatResponse: _.bind(function(response) {
                        this._removeTipsy();

                        var sortFields = new GroupDescriptor();

                        // add each returned field
                        _.each(response.fields, function(option) {
                            sortFields.addItem(new ItemDescriptor({
                                title: option.fieldName,
                                value: option.fieldId,
                                label: option.fieldName,
                                meta: {sortJql: option.sortJql}
                            }));
                        });

                        // add a footer showing how many more fields there are
                        var footerText = this._getFooterText(response);
                        if (footerText) {
                            sortFields.footerText(footerText);
                            this._deferredAddTipsyToFooter(response);
                        }

                        // we only have 1 group
                        return [sortFields];
                    }, this)
                })
            });

            // focus the 'Search' area in the multi-select after rendering it
            var orderByInput = layer.find('#order-by-options-input');
            orderByInput.focus();
        },

        /**
         * Returns the default AJAX options for requesting suggestions.
         *
         * @param {object} ajaxOpts additional options that override the defaults
         */
        _ajaxDefaults: function(ajaxOpts) {

            var defaults = {
                url: contextPath + "/rest/orderbycomponent/latest/orderByOptions",
                type: "POST",
                contentType: 'application/json',
                data: JSON.stringify(this._ajaxOptionsData())
            };

            return _.extend(defaults, ajaxOpts);
        },

        /**
         * Returns the additional data to send back in the options request.
         *
         * @param {string} query the query
         * @return {Object} data to send
         * @private
         */
        _ajaxOptionsData: function(query) {
            var jql = this.model.getJql();
            var sortBy = this.model.getSortBy();
            return {
                query: query,
                jql: jql ? jql : undefined,
                sortBy: sortBy ? sortBy.fieldId : undefined
            };
        },

        /**
         * Renders the initial content for the InlineLayer.
         *
         * @param orderByOptions the options returned from the server
         * @return {jQuery} a div with the initial content
         * @private
         */
        _renderInitialContent: function(orderByOptions) {
            // the 'meta' needs to be stringified for inclusion in the select
            var optionsWithMeta = _.map(orderByOptions.fields, function(field) {
                return _.extend({}, field, {
                    meta: JSON.stringify({sortJql: field.sortJql})
                });
            });

            return jQuery('<div></div>')
                .addClass('order-dropdown')
                .html(OrderByTemplates.orderByOptions({
                    options: optionsWithMeta,
                    footer: this._getFooterText(orderByOptions)
                }));
        },

        /**
         * Initialises the single select control after the data has been inserted into the DOM.
         *
         * @param e
         * @param layer
         * @param id
         *
         * @private
         */
        _onDropdownShown: function(e, layer) {
            this._initSingleSelect(layer);
        },

        /**
         * Cleans up after the drop-down when it gets hidden. This includes removing the drop-down from the DOM.
         *
         * @param e
         * @param {InlineLayer} layer the layer
         * @param id
         * @private
         */
        _onDropdownHidden: function() {
            this._removeTipsy();

            // remove element
            jQuery('div.order-dropdown').remove();
            this._inlineLayer = null;
        },

        /**
         * Hides the drop-down and sorts by the selected field
         */
        _onFieldSelected: function(e, descriptor) {
            // frother made me do this. it seems we can't just hide the InlineLayer because it is still trying to do things
            // *after* this callback has run and will fail if we've hidden it. so we defer.
            var event = new jQuery.Event(OrderByEventTypes.ISSUE_TABLE_REORDER);
            Events.trigger(event);
            if (!event.isDefaultPrevented()) {
                _.defer(_.bind(function() {
                    // handling for bug in QueryableDropdownSelect - it incorrectly fires a request on enter key.
                    if (this.selectControl.outstandingRequest) {
                        this.selectControl.outstandingRequest.reject();
                    }
                    InlineLayer.current.hide();
                    // sort using the provided sort JQL
                    var meta = descriptor.meta();
                    this.model.doSort(meta.sortJql);
                }, this));
            }
        },

        /**
         * Returns the footer string to render in the dropdown, or undefined. If there are more fields to show than were
         * returned, the footer will read along the lines of "23 more fields not shown".
         *
         * @param {object} orderByOptions
         * @param {number} orderByOptions.maxResults the maximum number of returned fields
         * @param {number} orderByOptions.matchesCount the number of matched fields
         * @return {string}
         * @private
         */
        _getFooterText: function(orderByOptions) {
            if (typeof orderByOptions.matchesCount === 'number' && typeof orderByOptions.maxResults === 'number') {
                var notShown = orderByOptions.matchesCount - orderByOptions.maxResults;
                if (notShown > 0) {
                    return AJS.format("{0} more fields...", notShown);
                }
            }

            return "";
        },

        /**
         * Adds a tipsy to the footer telling users how to find fields that are not in the list. The actual adding of the
         * tipsy is deferred.
         *
         * @param {object} orderByOptions
         * @param {number} orderByOptions.maxResults the maximum number of returned fields
         * @param {number} orderByOptions.matchesCount the number of matched fields
         * @return {*}
         * @private
         */
        _deferredAddTipsyToFooter: function(orderByOptions) {
            if (this._inlineLayer) {
                var matched = orderByOptions.matchesCount;
                var shown = Math.min(orderByOptions.matchesCount, orderByOptions.maxResults);
                var tipsyText = AJS.format("Showing {0} of {1} matching fields. Find more fields by typing in the search box.", shown, matched);

                var instance = this;
                _.defer(function() {
                    instance._tipsyTrigger = new Tipsy({
                        el: instance._inlineLayer.$layer.find('.aui-list-section-footer'),
                        tipsy: {
                            title: function() {
                                return tipsyText;
                            },
                            className: "tipsy-front"
                        }
                    });
                });
            }
        },

        /**
         * Removes the footer tipsy.
         *
         * @return {*}
         * @private
         */
        _removeTipsy: function() {
            if (this._tipsyTrigger) {
                this._tipsyTrigger.hide();
                this._tipsyTrigger = null;
            }
        }

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/OrderBy.js' */
define("jira/components/orderby", ["require"], function(require) {
    "use strict";

    var OrderByView = require("jira/components/orderby/orderbyview");
    var OrderByModel = require("jira/components/orderby/orderbymodel");

    return {

        create: function(options) {

            var model;
            var view;

            options = options || {};

            model = new OrderByModel({
                sortBy: options.sortBy,
                jql: options.jql
            });
            view = new OrderByView({model: model});

            // publish public api
            return {
                onSort: function() {
                    model.onSort.apply(model, arguments);
                    return this;
                },
                offSort: function(method) {
                    model.off("sort", method);
                    return this;
                },
                render: function() {
                    view.render();
                    return this;
                },
                setElement: function(el) {
                    view.setElement(el);
                    return this;
                },
                setJql: function(jql) {
                    model.setJql(jql);
                    return this;
                },
                setSortBy: function(options) {
                    model.setSortBy(options);
                    return this;
                }
            };
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/eventtypes.js' */
define("jira/components/orderby/eventtypes", [], function(){
    "use strict";

    return {
        ISSUE_TABLE_REORDER: "issueTableReorder"
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/components/orderby/templates", function() {
    "use strict";

    return JIRA.Templates.OrderBy;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed. Later, we can restore the
 * global reference if needed (see ../js/namespace.js)
 */
AJS.namespace("JIRA.Templates.OrderBy", null, require("jira/components/orderby/templates"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/namespace.js' */
AJS.namespace("JIRA.Components.OrderBy", null, require("jira/components/orderby"));
AJS.namespace("JIRA.Issues.OrderByDropDownView", null, require("jira/components/orderby/orderbydropdownview"));
AJS.namespace("JIRA.Issues.OrderByView", null, require("jira/components/orderby/orderbyview"));
AJS.namespace("JIRA.Issues.OrderByModel", null, require("jira/components/orderby/orderbymodel"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnPicker.soy' */
// This file was automatically generated from ColumnPicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Dialogs.ColumnPicker.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Dialogs == 'undefined') { JIRA.Templates.Dialogs = {}; }
if (typeof JIRA.Templates.Dialogs.ColumnPicker == 'undefined') { JIRA.Templates.Dialogs.ColumnPicker = {}; }


JIRA.Templates.Dialogs.ColumnPicker.popup = function(opt_data, opt_ignored) {
  var output = '<div><form action="#" method="post"  class="aui top-label column-picker"><div class="check-list-top-panel"><h3>' + soy.$$escapeHtml("Columns") + '</h3>';
  if (opt_data.columns.length > 1) {
    output += '<p class="aui-buttons">';
    var columnList9 = opt_data.columns;
    var columnListLen9 = columnList9.length;
    for (var columnIndex9 = 0; columnIndex9 < columnListLen9; columnIndex9++) {
      var columnData9 = columnList9[columnIndex9];
      output += '<button type="button" class="config-chooser aui-button ' + ((columnData9.isActive) ? ' active' : '') + '" id="columns-chooser-' + soy.$$escapeHtml(columnData9.name) + '" data-value="' + soy.$$escapeHtml(columnData9.name) + '"' + ((columnData9.isDisabled) ? 'aria-disabled="true"' : '') + '>' + soy.$$escapeHtml(columnData9.description) + '</button>';
    }
    output += '</p>';
  }
  output += '</div>';
  var columnList28 = opt_data.columns;
  var columnListLen28 = columnList28.length;
  for (var columnIndex28 = 0; columnIndex28 < columnListLen28; columnIndex28++) {
    var columnData28 = columnList28[columnIndex28];
    output += '<div class="' + soy.$$escapeHtml(columnData28.name) + '-column-sparkler hidden"></div>';
  }
  output += ((! opt_data.isAutoUpdate) ? '<div class="button-panel"><input accesskey="' + soy.$$escapeHtml("s") + '" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to submit this form","s",opt_data.modifierKey)) + '" class="aui-button submit" type="submit" value="' + soy.$$escapeHtml("Done") + '"/> <a accesskey="' + soy.$$escapeHtml("`") + '" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to cancel","`",opt_data.modifierKey)) + '" class="aui-button aui-button-link close-dialog" href="javascript:">' + soy.$$escapeHtml("Cancel") + '</a></div>' : '') + '</form></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.ColumnPicker.popup.soyTemplateName = 'JIRA.Templates.Dialogs.ColumnPicker.popup';
}


JIRA.Templates.Dialogs.ColumnPicker.trigger = function(opt_data, opt_ignored) {
  return '<button class="aui-button aui-button-subtle column-picker-trigger" title="' + soy.$$escapeHtml("Columns") + '">' + soy.$$escapeHtml("Columns") + '</button>';
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.ColumnPicker.trigger.soyTemplateName = 'JIRA.Templates.Dialogs.ColumnPicker.trigger';
}


JIRA.Templates.Dialogs.ColumnPicker.restoreDefaultsLink = function(opt_data, opt_ignored) {
  return '<button class="aui-button aui-button-link restore-defaults">' + soy.$$escapeHtml(opt_data.linkText) + '</button>';
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.ColumnPicker.restoreDefaultsLink.soyTemplateName = 'JIRA.Templates.Dialogs.ColumnPicker.restoreDefaultsLink';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnPickerModel.js' */
define("jira/components/columnpicker/model", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var contextPath = window.AJS.contextPath();
    var jQuery = require("jquery");

    return Brace.Model.extend({

        namedAttributes: [
        /** The source of the column configuration, e.g. "user", "filter", "explicit" */
            "columnConfig",
            "savedColumnConfig",
            "search",
            "availableColumns",
            "autoUpdate"
        ],

        namedEvents: [
            "columnsSync",
            "changeColumnConfigDisabled",
            "destroyColumnConfig"
        ],

        allColumnsUrl: contextPath + '/rest/gadget/1.0/availableColumns',

        shouldRefreshSearchOnActivation: function() {
            return this.getCurrentColumnConfig().shouldRefreshSearchOnActivation();
        },

        shouldCloseOnActivation: function() {
            return this.getCurrentColumnConfig().shouldCloseOnActivation();
        },

        shouldLoadDefaultsOnActivation: function() {
            return this.getCurrentColumnConfig().shouldLoadDefaultsOnActivation();
        },

        shouldRevertOnHide: function() {
            return this.getCurrentColumnConfig().shouldRevertOnHide();
        },

        loadDefaultColumns: function() {
            this.getCurrentColumnConfig().loadDefaultColumns();
        },

        initialize: function() {
            this.columnsData = {};
        },

        refreshSearchWithColumns: function(columnConfigModel) {
            columnConfigModel = columnConfigModel || this.getCurrentColumnConfig();
            this.triggerColumnsSync(columnConfigModel.getName(), columnConfigModel.getColumns());
        },

        fetchAvailableColumnsIfNeeded: function() {
            if (!this.has("availableColumns")) {
                jQuery.ajax(this.allColumnsUrl).done(_.bind(function(response) {
                    this.setAvailableColumns(response.availableColumns);
                }, this));
            }
        },

        getCurrentColumnConfig: function(name) {
            if (!name) {
                name = this.getColumnConfig();
            }
            return this.columnsData[name];
        },

        revertColumnConfig: function() {
            if (this.shouldRevertOnHide() && this.getSavedColumnConfig() !== this.getColumnConfig()) {
                //HACK
                //BackboneJS does not update the 'previousAttributes' if the change is silent. That means
                //the next time we change columnConfig (non-silent change), we will get the wrong value.
                //See https://extranet.atlassian.com/x/Cwq_fw
                this._previousAttributes.columnConfig = this.getSavedColumnConfig();
                this.setColumnConfig(this.getSavedColumnConfig(), {silent: true});
            }
        },

        setCurrentColumnConfig: function(columnConfig) {
            this.setColumnConfig(columnConfig);
            this.setSavedColumnConfig(columnConfig);
        },

        syncColumns: function(newColumnConfigName, columns) {
            _.each(this.columnsData, function(columnConfigModel) {
                if (columnConfigModel.getName() === newColumnConfigName) {
                    columnConfigModel.setColumns(columns);
                    columnConfigModel.setSavedColumns(columns);
                }
            });
        },

        /**
         * Save a list of columns in the current ColumnConfig.
         *
         * This method will save the list of columns in the provided order. In other words,
         * the previous order is deleted.
         *
         * @param {Array.string} cols Columns to save
         */
        saveColumns: function(cols) {
            this.getCurrentColumnConfig().setColumns(cols);
            this.getCurrentColumnConfig().save();
            this.getCurrentColumnConfig().triggerColumnsSync();
        },

        addColumnProvider: function(id, provider) {
            this.columnsData[id] = provider;

            provider.on("columnsSync sync destroy", _.bind(function() {
                this.refreshSearchWithColumns(provider);
            }, this));

            provider.on("change:isDisabled", _.bind(function(model, isDisabled) {
                this.triggerChangeColumnConfigDisabled(model, isDisabled);
            }, this));

            provider.on("destroy", _.bind(function(model) {
                this.triggerDestroyColumnConfig(model);
            }, this));
        }
    });

});
AJS.namespace("JIRA.Issues.ColumnPickerModel", null, require("jira/components/columnpicker/model"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnConfigModel.js' */
define("jira/components/columnpicker/columnconfigmodel", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var jQuery = require("jquery");

    var ColumnConfigModel = Brace.Model.extend({

        namedAttributes: [
            "name",
            "columns",
            "autoUpdate",
            "savedColumns",
            "description",
            "previousColumns",
            "actionBarText",
            "isActive"
        ],

        namedEvents: [
            "columnsSync"
        ],

        defaults: {
            actionBarText: "Restore Defaults",
            isActive: false
        },

        idAttribute: "name",

        initialize: function(attributes, options) {
            _.extend(this, options);
        },

        /**
         * Get the defaults columns, parsing the response from defaultColumns().
         * The promise can be resolved with the list of columns (Array.string) or
         * rejected with a null value
         *
         * @returns {jQuery.Promise}
         */
        getDefaultColumns: function() {
            var deferred = new jQuery.Deferred();

            this.defaultColumns().done(_.bind(function(response) {
                var parsedResponse = this.parse(response);
                if (parsedResponse && parsedResponse.columns) {
                    deferred.resolve(parsedResponse.columns);
                } else {
                    deferred.reject(null);
                }
            }, this));

            return deferred.promise();
        },

        /**
         * Parses the REST response to extract our model values.
         *
         * @param {Object} response REST response
         */
        parse: function(response) {
            if (!response) {
                return {};
            }

            return {
                columns: _.compact(_.pluck(response, "value"))
            };
        },

        /**
         * Checks if the column config is disabled.
         *
         * For example, "filter" column config is disabled if there is no active filter.
         *
         * By default, this method returns false (i.e. all column config are enabled). It can be
         * overridden when creating this model
         *
         * @returns {boolean}
         */
        isDisabled: function() {
            return false;
        },

        /**
         * Checks if the column config edition is disabled.
         *
         * For example, "filter" column config edition is disabled if the user does not own the filter.
         *
         * By default, this method returns false (i.e. all column config edit are enabled). It can be
         * overridden when creating this model
         *
         * @returns {boolean}
         */
        isEditDisabled: function() {
            return false;
        },

        /**
         * Returns a promise that will resolve with a list of defaults columns.
         *
         * This method will be used if the columnConfig contains no columns. By default,
         * the returned promise resolves immediately to an empty array.
         *
         * This method can be overridden when constructing this model
         *
         * @returns {jQuery.Promise}
         */
        defaultColumns: function() {
            var deferred = new jQuery.Deferred();
            deferred.resolve([]);
            return deferred.promise();
        },

        /**
         * Sorts a list of columns preserving the original order, using the following pattern:
         *    - Columns already present will keep their order
         *    - New columns will be append at the end
         *
         * Example:
         *    - Current columns ["a", "b", "c"]
         *    - New columns ["c", "d", "a"]
         *
         *    - Result ["a", "c", "d"]
         *
         * @param {Array.string} currentColumns Columns already present in the model
         * @param {Array.string} newColumns New columns to sort
         * @returns {Array.string} Sorted columns
         * @private
         */
        _sortColumnsUsingOriginalOrder: function(currentColumns, newColumns) {
            return _.intersection(currentColumns, newColumns).concat(_.difference(newColumns, currentColumns));
        },

        /**
         * Sets an unsorted list of columns in the model.
         *
         * This method will store the new list of columns, preserving the order of the previous column list.
         *
         * @param {Array.<string>} columns Columns to update the model with
         */
        setUnsortedColumns: function(columns) {
            columns = this._sortColumnsUsingOriginalOrder(this.getColumns(), columns);
            //TODO Check if this can be moved to backbone's previous() functionality
            this.setPreviousColumns(this.getColumns(), {silent: true});
            this.setColumns(columns);
        },

        /**
         * Creates a JSON representation for this model.
         *
         * This method will be used by Backbone when saving a model. We don't want to save the entire model, just
         * the columns, so the output only contains that attribute.
         *
         * @returns {{columns: Array.<string>}}
         */
        toJSON: function() {
            return {
                columns: this.getColumns()
            };
        },

        revertUnsavedColumns: function(opts) {
            if (this.getSavedColumns() !== this.getColumns()) {
                this.setColumns(this.getSavedColumns(), opts);
            }
        },

        loadDefaultColumns: function() {
            this.getDefaultColumns().done(_.bind(function(columns) {
                this.setColumns(columns);
            }, this));
        },

        shouldRefreshSearchOnActivation: function() {
            return true;
        },

        shouldCloseOnActivation: function() {
            return true;
        },

        shouldLoadDefaultsOnActivation: function() {
            return false;
        },

        shouldRevertOnHide: function() {
            return true;
        }
    });

    ColumnConfigModel.create = function(name, description, overriddenMethods, autoUpdate) {
        return new ColumnConfigModel({
            autoUpdate: autoUpdate,
            name: name,
            description: description
        }, overriddenMethods);
    };

    return ColumnConfigModel;
});
AJS.namespace("JIRA.Issues.ColumnConfigModel", null, require("jira/components/columnpicker/columnconfigmodel"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnPickerSuggestHandler.js' */
define("jira/components/columnpicker/suggesthandler", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var GroupDescriptor = require("jira/ajs/list/group-descriptor");
    var jQuery = require("jquery");
    var SelectSuggestHandler = require('jira/ajs/select/suggestions/select-suggest-handler');
    var SuggestHandler = require("jira/ajs/select/suggestions/suggest-helper");
    var Templates = window.JIRA.Templates.Dialogs.ColumnPicker;

    return SelectSuggestHandler.extend({

        /**
         * Creates a actionBar item that contains a link. This link is usually used
         * to restore the defaults items in the sparkler
         *
         * @param {string} [text] Text to render inside the link
         *
         * @return {jQuery} LI element that contains the link
         */
        createActionBar: function(text) {
            //If there are no text, create nothing
            if (!text) {
                return null;
            }

            var $element = jQuery(Templates.restoreDefaultsLink({
                linkText: text
            }));

            $element.click(function(ev) {
                if (jQuery(ev.target).attr("aria-disabled") !== "true") {
                    $element.trigger("actionclick");
                }
                ev.preventDefault();
            });

            return jQuery("<li class='check-list-group-actions'></li>").append($element);
        },

        /**
         * Formats descriptors for display in checkbox multiselect
         *
         * @param descriptors
         * @return {Array} formatted descriptors
         */
        formatSuggestions: function(descriptors, query) {
            var selectedItems = SuggestHandler.removeDuplicates(this.model.getDisplayableSelectedDescriptors());
            var selectedGroup = new GroupDescriptor({
                styleClass: "selected-group",
                items: selectedItems
            });
            descriptors.splice(0, 0, selectedGroup);

            //Add the actionBar to the first group with items, so it is rendered as the first item in the scroll list
            //If there are selected elements, it will be the selectedItems group
            //If not, it will be the uneslectedItems group.
            var firstGroupWithItems = _.find(descriptors, function(group) {
                return group.items().length;
            });
            if (firstGroupWithItems) {
                firstGroupWithItems.actionBarHtml(this.createActionBar(this.options.actionBar));
            }

            if (query.length > 0) {
                descriptors = SuggestHandler.removeDuplicates(descriptors);
                // Extract all items from the descriptors and sort them by label.
                var items = SuggestHandler.extractItems(descriptors).sort(function(a, b) {
                    a = a.label().toLowerCase();
                    b = b.label().toLowerCase();
                    return a.localeCompare(b);
                });
                descriptors = [new GroupDescriptor({items: items})];
            }
            return descriptors;
        }
    });

});
AJS.namespace("JIRA.Issues.ColumnPickerSuggestHandler", null, require("jira/components/columnpicker/suggesthandler"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnPickerSparklerView.js' */
define("jira/components/columnpicker/sparklerview", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var AJSTemplates = window.AJS.Templates;
    var Brace = require("jira/components/libs/brace");
    var CheckboxMultiSelect = require("jira/ajs/select/checkbox-multi-select");
    var ColumnPickerSuggestHandler = require("jira/components/columnpicker/suggesthandler");
    var GroupDescriptor = require("jira/ajs/list/group-descriptor");
    var ItemDescriptor = require("jira/ajs/list/item-descriptor");
    var Message = require("aui/message");
    var jQuery = require("jquery");

    return Brace.View.extend(/* @lends JIRA.Issues.ColumnPickerSparklerView.prototype */{

        /**
         * This object wraps a Sparkler. It is used by the ColumnPicker to render sparklers for select columns
         * (it will render one sparkler per column layout).
         *
         * @constructs
         * @param {Object} config Configuration object for this object
         * @param {jQuery} config.el Element where the sparkler should be rendered
         * @param {ColumnConfigModel} config.model Model used for this view
         * @param {number} [config.maxResults=25] Max number of items to display
         */
        initialize: function(config) {
            //Don't use || to get the default value, it will fail with 0
            this._maxResults = (typeof config.maxResults === "number") ? config.maxResults : this.MAX_DISPLAYED_ITEMS;
            this._autoUpdate = !!config.autoUpdate;
            this.$el.scrollLock('.aui-list-scroll');
            if (!this._autoUpdate) {
                this.model.on("change:columns", _.bind(this._setSelectedColumns, this));
            }
        },

        /**
         * Default for max displayed columns
         * @type {Number}
         * @default
         * @private
         * @constant
         */
        MAX_DISPLAYED_ITEMS: 25,

        /**
         * Stores the actual AJS.CheckboxMultiSelect object that represents the sparkler
         * @type {AJS.CheckboxMultiSelect}
         * @private
         */
        _sparkler: null,

        activate: function() {
            this.model.setIsActive(true);
        },

        deactivate: function() {
            this.model.setIsActive(false);
        },

        /**
         * Hides the sparkler
         */
        hide: function() {
            this.model.revertUnsavedColumns({silent: true});

            this.$el.addClass("hidden");

            //Clear the sparkler search field
            var input = this.$el.find("input[id *= column-sparkler-input]");
            input.val('');
        },

        /**
         * Shows the sparkler
         */
        show: function() {
            this.$el.removeClass("hidden");

            //Set the selected columns
            this._setSelectedColumns();

            //Focus the sparkler input
            var input = this.$el.find("input[id *= column-sparkler-input]");
            if (!input.is(":disabled")) {
                input.focus();
            }
        },

        addMessage: function(message) {
            if (this.$el.find(".aui-message." + message.type).length === 0) {
                Message[message.type](this.$el, {
                    body: message.content,
                    closeable: false,
                    insert: "prepend",
                    id: message.id
                });
            }
        },

        /**
         * Disables the sparkler whenever the edit is disabled in the model
         *
         * @private
         */
        _disableEditIfNeeded: function() {
            if (this.model.isEditDisabled()) {
                this._disableEdit();
            } else {
                this._enableEdit();
            }
        },

        /**
         * Shows the EditDisabled message
         *
         * @private
         */
        _showEditDisabledMessage: function() {
            this.addMessage({
                content: "You cannot update the columns for a filter owned by another user.",
                type: "warning",
                id: this.model.getName() + '-edit-disabled-message'
            });
        },

        /**
         * Destroys the EditDisabled message
         *
         * @private
         */
        _hideEditDisabledMessage: function() {
            this.$el.find("#" + this.model.getName() + '-edit-disabled-message').remove();
        },

        /**
         * Disables the sparkler interactions.
         *
         * This method is used when the user does not have permission to change the columns.
         *
         * @private
         */
        _disableEdit: function() {
            //Disable the search input
            this._sparkler.disable();

            //Disable the checkboxes
            this.$el.find("input[type='checkbox']").attr("disabled", "disabled");  //Disable checkboxes
            this.$el.find(".check-list-item").addClass("disabled");                //Disable labels
            this.$el.find(".no-suggestions").addClass("disabled");                 //Disable "more" message

            //Disable the action bar
            this.$el.find(".restore-defaults").attr("aria-disabled", "true");

            //Show reason to user
            this._showEditDisabledMessage();
        },

        /**
         * Enables the sparkler interactions.
         *
         * This method is used when the user have permission to change the columns.
         *
         * @private
         */
        _enableEdit: function() {
            //Enable the search input
            this._sparkler.enable();

            //Enable the checkboxes
            this.$el.find("input[type='checkbox']").removeAttr("disabled");  //Enable checkboxes
            this.$el.find(".check-list-item").removeClass("disabled");       //Enable labels
            this.$el.find(".no-suggestions").removeClass("disabled");        //Enable "more" message

            //Enable the action bar
            this.$el.find(".restore-defaults").removeAttr("aria-disabled");

            //Remove editDisabled message
            this._hideEditDisabledMessage();
        },

        /**
         * Creates the internal sparkler
         *
         * @param {Array.<{label: string, value: string}>} items Items to include in the sparkler
         */
        createSparklerControl: function(items) {
            //Make sure we destroy the actual sparkler.
            //This should not happen unless some event is being fired twice
            if (this._sparkler) {
                this._sparkler.remove();
            }

            var selectElement = this._buildQueryableSelect(items);
            this.$el.append(selectElement);

            //Create the sparkler control
            this._sparkler = new CheckboxMultiSelect({
                element: selectElement,
                maxInlineResultsDisplayed: this._maxResults,
                suggestionsHandler: ColumnPickerSuggestHandler,
                actionBar: this.model.getActionBarText()
            });

            //Set the selected columns
            this._setSelectedColumns();

            if (this._autoUpdate) {
                selectElement.bind("selected", _.bind(this.saveColumns, this));
                selectElement.bind("unselect", _.bind(this.saveColumns, this));
            }

            this._sparkler.$field.focus();

            // Intercept column reset and use our own method
            this.$el.on("actionclick", _.bind(function(ev) {
                ev.preventDefault();
                this.model.unset("columns");
                this.model.destroy();
            }, this));

            this.model.on("change:editDisabled", _.bind(this._disableEditIfNeeded, this));
        },

        /**
         * Saves the sparkler's columns in our model and persists them
         */
        saveColumns: function() {
            this.model.setUnsortedColumns(this._sparkler.model.getSelectedValues());
            this.model.save(null, {wait: false});
        },

        /**
         * Sets the selected items in the sparkler
         * @private
         */
        _setSelectedColumns: function() {
            var selectedColumns = this.model.getColumns();
            var sparkler = this._sparkler;

            //If the sparkler has already been built, and we hae selectedColumns...
            if (sparkler && selectedColumns && selectedColumns.length) {
                _.each(sparkler.model.getDisplayableUnSelectedDescriptors(), function(descriptor) {
                    if (_.contains(selectedColumns, descriptor.value())) {
                        sparkler.selectItem(descriptor);
                    }
                });
                _.each(sparkler.model.getDisplayableSelectedDescriptors(), function(descriptor) {
                    if (!_.contains(selectedColumns, descriptor.value())) {
                        sparkler.unselectItem(descriptor);
                    }
                });

                sparkler.render();
                this._disableEditIfNeeded();
            }
        },

        /**
         * Builds the queryableSelect with all the available items
         *
         * @param {Array.<{label: string, value: string}>} columns Columns to include in the sparkler
         * @returns {jQuery} A select element containing all the options
         * @private
         */
        _buildQueryableSelect: function(columns) {
            var instance = this;
            var availableItems = _.map(columns, function(column) {
                return new ItemDescriptor(_.extend(column, {
                    title: column.label
                }));
            });

            return jQuery(AJSTemplates.queryableSelect({
                id: instance.model.getName() + "-column-sparkler",
                descriptors: [
                    new GroupDescriptor({
                        items: availableItems
                    })
                ]
            }));
        }
    });
});
AJS.namespace("JIRA.Issues.ColumnPickerSparklerView", null, require("jira/components/columnpicker/sparklerview"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnPickerView.js' */
define("jira/components/columnpicker/view", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var InlineDialog = require("aui/inline-dialog");
    var Brace = require("jira/components/libs/brace");
    var ColumnPickerSparklerView = require("jira/components/columnpicker/sparklerview");
    var jQuery = require("jquery");
    var Templates = window.JIRA.Templates.Dialogs.ColumnPicker;
    var Meta = require('jira/util/data/meta');

    var modifierKey = Meta.get("keyboard-accesskey-modifier");

    return Brace.View.extend(/** @lends JIRA.Issues.ColumnPickerView.prototype */{
        /**
         * @classdesc
         * This view contains the column picker trigger, the dialog and one subview ({@link JIRA.Issues.ColumnPickerSparklerView})
         * per each column config. Its job is to open/close the dialog, display buttons to select the column config, and
         * display the corresponding subview based on those buttons.  It also handles the 'Save' and 'Cancel' buttons at
         * the bottom of the dialog.
         *
         * The model of this view is {@link JIRA.Issues.columnPickerModel}
         *
         * @constructs
         * @extends Brace.View
         * @param {Object} options
         * @param {JIRA.Issues.columnPickerModel} options.columnPickerModel Model to use in this view
         */
        initialize: function(options) {
            _.extend(this, options);
            _.bindAll(this,
                "_generateInlineDialogContent",
                "_onDOMCloseDialogClick",
                "_onDOMConfigChooserClick",
                "_onDOMDialogHide",
                "_onDOMFormSubmit",
                "_onDOMTriggerClick",
                "_onModelChangeAvailableColumns",
                "_onModelChangeColumnConfig",
                "_onModelChangeColumnConfigDisabled",
                "_onModelDestroyColumnConfig");

            /**
             * Stores all the subviews handled by this view, indexed by name
             * @type {Object.<string, JIRA.Issues.ColumnPickerSparklerView>}
             */
            this.subViews = {};

        },

        /**
         * Stores the inline dialog used by this view. Populated by {@link JIRA.Issues.ColumnPickerView#render}
         * @type {AJS.InlineDialog}
         */
        dialog: null,

        /**
         * Stores a reference to the active subview. Populated by {@link JIRA.Issues.ColumnPickerView#_activateNewSubView}
         * @type {JIRA.Issues.ColumnPickerSparklerView}
         */
        activeSubview: null,

        /**
         * Handles the click event on config chooser
         *
         * This method sets the columnConfig in our model and closes the dialog
         *
         * @param ev (jQuery.Event)
         * @private
         */
        _onDOMConfigChooserClick: function(ev) {
            var $target = jQuery(ev.target);

            // If the button is disabled, do nothing
            if ($target.attr("aria-disabled")) {
                return;
            }

            this.columnPickerModel.setColumnConfig($target.data("value") || "user");
        },

        /**
         * Activate a new subview. Each column config has a different logic, so all the decisions are delegated
         * to the columnConfig models.
         *
         * @param {JIRA.Issues.ColumnPickerSparklerView} subview View being activated
         * @private
         */
        _activateNewSubView: function(subview) {
            subview.activate();

            if (this.columnPickerModel.shouldCloseOnActivation()) {
                this.dialog.hide();
            } else {
                this.activeSubview = subview;
                this.activeSubview.show();
                this.adjustHeight();
            }

            if (this.columnPickerModel.shouldRefreshSearchOnActivation()) {
                this.columnPickerModel.refreshSearchWithColumns();
            }

            if (this.columnPickerModel.shouldLoadDefaultsOnActivation()) {
                this.columnPickerModel.loadDefaultColumns();
            }
        },

        /**
         * Handles the form submit event
         *
         * This method saves the columns in the active columnConfig and closes the dialog
         *
         * @param ev (jQuery.Event)
         * @private
         */
        _onDOMFormSubmit: function(ev) {
            // Stops the form submission
            ev.preventDefault();

            this.activeSubview.saveColumns();
            this.dialog.hide();
        },

        /**
         * Handles click event on the close dialog link
         *
         * This method hides the dialog
         * @param ev (jQuery.Event)
         * @private
         */
        _onDOMCloseDialogClick: function() {
            this.dialog.hide();
        },

        /**
         * Handles the click on the dialog trigger
         *
         * @param ev (jQuery.Event)
         * @private
         */
        _onDOMTriggerClick: function() {
            //Display the dialog
            this.dialog.show();

            // Display the active sparkler
            this.activeSubview = this.subViews[this.columnPickerModel.getCurrentColumnConfig().getName()];
            this.activeSubview.show();
            this._activateConfigChooserButton(this.columnPickerModel.getCurrentColumnConfig().getName());

            // Send request to get the available columns
            this.columnPickerModel.fetchAvailableColumnsIfNeeded();
        },

        _activateConfigChooserButton: function(newButtonName) {
            this.dialog.find(".config-chooser.active").removeClass("active");
            this.dialog.find("#columns-chooser-" + newButtonName).addClass("active");
        },

        /**
         * Handles the close event on the InlineDialog
         *
         * @param ev (jQuery.Event)
         * @private
         */
        _onDOMDialogHide: function() {
            this.columnPickerModel.revertColumnConfig();
            this.activeSubview.hide();
        },

        /**
         * Handler for change:columnConfig
         *
         * @param {JIRA.Issues.columnPickerModel} columnPickerModel Model that has changed
         * @param {string} columnConfig New value for columnConfig
         * @private
         */
        _onModelChangeColumnConfig: function(columnPickerModel, columnConfig) {
            var newSubView = this.subViews[columnConfig];
            this._activateConfigChooserButton(newSubView.model.getName());

            var oldSubView = this.subViews[columnPickerModel.previous("columnConfig")];
            if (oldSubView !== newSubView) {
                oldSubView.hide();
                oldSubView.deactivate();
                this._activateNewSubView(newSubView);
            }
        },

        /**
         * Handler for change:availableColumns
         *
         * @param {JIRA.Issues.columnPickerModel} columnPickerModel Model that has changed
         * @param {Array.<{label: string, value: string}>} availableColumns New value for availableColumns
         * @private
         */
        _onModelChangeAvailableColumns: function(columnPickerModel, availableColumns) {
            _.each(this.subViews, function(columnPickerView) {
                columnPickerView.createSparklerControl(availableColumns);
            });
        },

        /**
         * Handler for destroy
         * @private
         */
        _onModelDestroyColumnConfig: function() {
            this.dialog.hide();
        },

        /**
         * Handler for change:isDisabled
         *
         * @param {JIRA.Issues.ColumnConfigModel} model Model that has changed
         * @param {boolean} isDisabled New value for isDisabled
         * @private
         */
        _onModelChangeColumnConfigDisabled: function(model, isDisabled) {
            var button = this.dialog.find("#columns-chooser-" + model.getName());
            if (isDisabled) {
                button.attr("aria-disabled", true);
            } else {
                button.removeAttr("aria-disabled");
            }
        },

        /**
         * Renders the trigger and the dialog
         */
        render: function() {
            if (!this.$trigger) {
                this.$trigger = jQuery(Templates.trigger());
            }
            this.$el.append(this.$trigger);
            this.$trigger.click(this._onDOMTriggerClick);

            this._renderInlineDialog();
        },

        /**
         * Adjust the height of the dialog based on window height
         *
         * @returns {Boolean}
         * @private
         */
        adjustHeight: function() {
            if (InlineDialog.current && InlineDialog.current.id === "column-picker-dialog" && this.activeSubview) {
                var scrollList = jQuery(this.activeSubview.el).find(".aui-list-scroll");
                //Maximum available height = ((window height - trigger y position) - dialog bottom padding)
                var maxDialogHeight = ((window.innerHeight - this.$trigger.offset().top) - 90);
                //Delta = max available height - actual height
                var heightDelta = maxDialogHeight - this.dialog.height();
                //Desired scroll list height = actual height + Delta
                //Height confined to: 80 pixel < Scroll list height < 270 pixel
                var scrollListHeight = Math.max(Math.min(scrollList.height() + heightDelta, 270), 80);
                scrollList.css("height", scrollListHeight);
                return true;
            }
            return false;
        },

        /**
         * Generates the dialog's content
         *
         * @param {jQuery} $content The div element that will contain the custom content
         * @param {jQuery} $trigger The element of your dialog trigger
         * @param {Function} done Callback to run when the content is ready to be displayed
         * @private
         */
        _generateInlineDialogContent: function($content, $trigger, done) {
            if (!this.dialogContent) {
                // Injects the template into the dialog
                $content.html(Templates.popup({
                    modifierKey: modifierKey,
                    isAutoUpdate: this.columnPickerModel.getAutoUpdate(),
                    columns: _.map(this.columnPickerModel.columnsData, _.bind(function(col) {
                        return {
                            name: col.getName(),
                            description: col.getDescription(),
                            selected: false,
                            isDisabled: col.isDisabled(),
                            isActive: this.columnPickerModel.getCurrentColumnConfig() === col
                        };
                    }, this))
                }));

                // Bind DOM handlers
                $content.find(".config-chooser").click(this._onDOMConfigChooserClick);
                $content.find("form").submit(this._onDOMFormSubmit);
                $content.find(".close-dialog").click(this._onDOMCloseDialogClick);

                // Avoid dialog being closed on click
                $content.click(function(e) {
                    e.stopPropagation();
                });

                // Create the sparklers
                this._createSubViews($content);

                this.dialogContent = $content.children();
            } else {
                $content.append(this.dialogContent);
            }

            done();
        },

        /**
         * Renders the InlineDialog
         *
         * @private
         */
        _renderInlineDialog: function() {
            // If the dialog has been already rendered, do nothing
            if (this.dialog) {
                return;
            }

            // Build the dialog
            this.dialog = new InlineDialog(
                this.$trigger,
                "column-picker-dialog",
                this._generateInlineDialogContent,
                {
                    offsetY: 15,
                    addActiveClass: true,
                    hideDelay: null,
                    noBind: true,
                    initCallback: _.bind(function() {
                        //This is called when the inline dialog has finished rendering
                        //Using a timeout to adjust the height because when this is called, the column picker
                        //has not been completely rendered into the page yet
                        var instance = this;
                        var timeoutAdjust = function() {
                            if (!instance.adjustHeight()) {
                                //noinspection DynamicallyGeneratedCodeJS
                                setTimeout(timeoutAdjust, 100);
                            }
                        };
                        timeoutAdjust();
                    }, this),
                    hideCallback: this._onDOMDialogHide
                }
            );
        },

        /**
         * Creates the sparklers subViews
         *
         * @param {jQuery} $content
         * @private
         */
        _createSubViews: function($content) {
            _.each(this.columnPickerModel.columnsData, _.bind(function(columnConfigModel) {
                this.subViews[columnConfigModel.getName()] = new ColumnPickerSparklerView({
                    el: $content.find("." + columnConfigModel.getName() + "-column-sparkler"),
                    model: columnConfigModel,
                    autoUpdate: this.columnPickerModel.getAutoUpdate()
                });
            }, this));

            //Create sparkler controls if/when we have the available columns
            if (this.columnPickerModel.has("availableColumns")) {
                this._onModelChangeAvailableColumns(this.columnPickerModel, this.columnPickerModel.getAvailableColumns());
            }
            this.columnPickerModel.on("change:availableColumns", this._onModelChangeAvailableColumns);

            //Bind model events
            this.columnPickerModel.on("change:columnConfig", this._onModelChangeColumnConfig);
            this.columnPickerModel.onChangeColumnConfigDisabled(this._onModelChangeColumnConfigDisabled);
            this.columnPickerModel.onDestroyColumnConfig(this._onModelDestroyColumnConfig);
        }

    });

});
AJS.namespace("JIRA.Issues.ColumnPickerView", null, require("jira/components/columnpicker/view"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnPicker.js' */
define("jira/components/columnpicker", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var ColumnConfigModel = require("jira/components/columnpicker/columnconfigmodel");
    var ColumnPickerModel = require("jira/components/columnpicker/model");
    var ColumnPickerView = require("jira/components/columnpicker/view");

    /**
     * A module that controls the column picker model and the column picker view in a single interface.
     */
    var ColumnPicker = Brace.Model.extend({

        initialize: function(attr, options) {

            this.columnPickerModel = new ColumnPickerModel({autoUpdate: options.autoUpdate});
            this.columnPickerView = new ColumnPickerView({columnPickerModel: this.columnPickerModel});

            _.each(options.providers, _.bind(function(descriptor) {
                if (descriptor instanceof ColumnConfigModel) {
                    this.columnPickerModel.addColumnProvider(descriptor.getName(), descriptor);
                } else {
                    this.columnPickerModel.addColumnProvider(descriptor.id, this._createProviderModel(descriptor));
                    if (descriptor.columns) {
                        this.columnPickerModel.syncColumns(descriptor.id, descriptor.columns);
                    }
                }
            }, this));

            this.setCurrentColumnConfig(options.providers[0].id);
            if (options.el) {
                this.columnPickerView.setElement(options.el).render();
            }
        },

        _createProviderModel: function(descriptor) {
            return ColumnConfigModel.create(descriptor.id, descriptor.label,
                _.omit(descriptor, "id", "label", "columns"));
        },

        getCurrentColumnConfig: function() {
            return this.columnPickerModel.getCurrentColumnConfig();
        },

        setElement: function($el) {
            this.columnPickerView.setElement($el);
            return this;
        },
        render: function() {
            this.columnPickerView.render();
            return this;
        },
        clearFilterConfiguration: function() {
            this.columnPickerModel.clearFilterConfiguration();
            return this;
        },
        adjustHeight: function() {
            this.columnPickerView.adjustHeight();
            return this;
        },
        setCurrentColumnConfig: function(name) {
            this.columnPickerModel.setCurrentColumnConfig(name);
            return this;
        },
        saveColumns: function(cols) {
            this.columnPickerModel.saveColumns(cols);
            return this;
        },
        syncColumns: function(name, columns) {
            this.columnPickerModel.syncColumns(name, columns);
            return this;
        },
        getColumnConfig: function() {
            this.columnPickerModel.getColumnConfig();
        },
        onColumnsSync: function(func, ctx) {
            this.columnPickerModel.onColumnsSync(func, ctx);
            return this;
        },
        on: function(evt, func, ctx) {
            this.columnPickerModel.on(evt, func, ctx);
            return this;
        },
        off: function(evt, func) {
            this.columnPickerModel.off(evt, func);
            return this;
        }

    });

    ColumnPicker.create = function(options) {
        return new ColumnPicker(null, options);
    };
    return ColumnPicker;
});
AJS.namespace("JIRA.Components.ColumnPicker", null, require("jira/components/columnpicker"));
;
;
/* module-key = 'com.atlassian.plugins.browser.metrics.browser-metrics-plugin:api', location = 'probe.js' */
;(function() {
var util_window, is_supported, event_stream, api_addReporter, api_delegateTo, api_end, util_table, util_document, util_element_hound, util_element_wolf, api_start_is_ready_supported, util_is_dom_content_loaded_done, api_start, api_subscribe, index;
util_window = function () {
  return window;
}();
is_supported = function (window) {
  /**
   * Feature detection for whether mandatory browser features are supported.
   */
  // required for .start() and .end() timing
  // http://caniuse.com/#search=performance.now
  return !!(window.performance && window.performance.now);
}(util_window);
event_stream = [];
api_addReporter = function (eventStream) {
  /**
   * Add a custom reporter to contribute to transition reports.
   *
   * @param {Reporter} reporter
   * @example
   *     api.addReporter(function dateReporter(transition) {
   *         return {
   *             date: Date.now()
   *         };
   *     });
   */
  return function addReporter(reporter) {
    // "addReporter" API has highest priority, so we use .unshift() rather than .push()
    eventStream.unshift({ addReporter: reporter });
  };
}(event_stream);
api_delegateTo = function (eventStream) {
  /**
   * Yield control to another object, giving it all events captured thus far, and all events in the future.
   * @param {function} subscriber
   */
  return function delegateTo(subscriber) {
    while (eventStream.length) {
      subscriber(eventStream.splice(0, 1)[0]);
    }
    eventStream.unshift = subscriber;
    eventStream.push = subscriber;
  };
}(event_stream);
api_end = function (eventStream, window) {
  /**
   * Finish timing and report the results.
   *
   * @param {String} options.key A key that identifies the page that has now finished loading. It must match the
   *     key provided to `start`.
   * @returns {undefined}
   * @example
   *     api.end({key: "jira.issue.view"});
   */
  return function end(options) {
    eventStream.push({
      end: {
        key: options.key,
        timestamp: window.performance.now()
      }
    });
  };
}(event_stream, util_window);
util_table = function () {
  /**
   * A multi-dimensional map that supports multiple values per key.
   * @constructor
   */
  function Table() {
    this._ = {};
  }
  /**
   * Recursive iteration over all keys and values. Function argument explanation:
   * {function} args[0] callback Called with arguments: values, key, higherKey, moreHigherKey,...
   * {Object} args[1] items to iterate
   * {string} args[2..n] keys from bottom to top
   *
   * @param {Array} args
   * @returns {undefined}
   */
  var _forEachRecursive = function (args) {
    var callback = args[0];
    var items = args[1];
    // at 1st level it's -> this;
    if (items instanceof Table) {
      if (args.length >= 3) {
        Object.keys(items._).forEach(function (key) {
          _forEachRecursive([
            callback,
            items._[key],
            key
          ].concat(args.slice(2)));
        });
      } else {
        Object.keys(items._).forEach(function (key) {
          _forEachRecursive([
            callback,
            items._[key],
            key
          ]);
        });
      }
    } else if (Array.isArray(items)) {
      callback.apply(null, [items].concat(args.slice(2)));
    }
  };
  /**
   * Iterate over all keys and values.
   * @param {function} callback Called with two arguments: values, key
   * @returns {undefined}
   */
  Table.prototype.forEach = function (callback) {
    _forEachRecursive([
      callback,
      this
    ]);
  };
  /**
   * Adds an object to a multi-dimension table. Head arguments are keys in order of deepness,
   * 1st goes highest key (e.g.: row key) and the one before last is the deepest level key (e.g.: column key).
   * Last argument considered as a value.
   *
   * @param arguments array of keys from top to bottom, ending with value (e.g.: [0] > rowKey, [1] > columnKey, [2] > value)
   */
  Table.prototype.add = function () {
    // selector, hasNone, callback
    var obj = this;
    // current level row
    var prev = null;
    // previous argument/key
    var cur = null;
    // current func argument/key/value
    for (var i = 0; i < arguments.length; i++) {
      cur = arguments[i];
      // then "obj" is an Array and "cur" is a value
      if (i === arguments.length - 1 && Array.isArray(obj)) {
        obj.push(cur);
        break;  // creating new level of table
      } else if (i < arguments.length - 2 && !obj._.hasOwnProperty(cur)) {
        obj._[cur] = new Table();  // {_: {}, length: 0}
                                   // considered as last level, we need to create an Array for values if not exists
      } else if (i === arguments.length - 2 && !obj._.hasOwnProperty(cur)) {
        obj._[cur] = [];
      }
      obj = obj._[cur];
      // this is an Array if i === arguments.length - 2
      prev = cur;
    }
  };
  /**
   *
   * @param visited an Array of tupples of "table key" > "object under that key" (root key is always null)
   * @param keyToRemove a key on the table structure which needs to be removed
   */
  var _cleanUpRecursive = function (visited, keyToRemove) {
    if (visited.length === 0) {
      return;
    }
    var tuple = visited.pop();
    var key = tuple[0];
    var obj = tuple[1];
    if (key === keyToRemove) {
      _cleanUpRecursive(visited, key);
    } else if (obj._.hasOwnProperty(keyToRemove)) {
      delete obj._[keyToRemove];
    }
    if (Object.keys(obj).length === 0) {
      _cleanUpRecursive(visited, key);
    }
  };
  /**
   * Remove an object under a key.
   * @param arguments array of keys from top to bottom, ending with value (e.g.: [0] > rowKey, [1] > columnKey, [2] > value)
   * @returns {boolean} true if an item was removed
   */
  Table.prototype.remove = function () {
    // e.g.: rowKey, columnKey, value
    var index;
    // index of the Array element that is about to be removed
    var mutated = false;
    // true if Table was changed, i.e. element was removed
    var key = null;
    // current level key
    var obj = this;
    // current level row
    // Visited elements - Array of tuples, root key is always null (e.g.: [aKey1, {_: { aKey2 : Table/Array }, length: 1}]
    var visited = [[
        key,
        obj
      ]];
    var cur = null;
    // current func argument
    for (var i = 0; i < arguments.length; i++) {
      cur = arguments[i];
      // then "obj" is Array and "cur" is an entry in this Array.
      if (Array.isArray(obj)) {
        index = obj.indexOf(cur);
        if (index > -1) {
          obj.splice(index, 1);
          if (obj.length === 0 && visited.length > 1) {
            _cleanUpRecursive(visited, key);  // cleaning all upper levels if they are empty as well
          }
          mutated = true;
        }
      } else if (obj._.hasOwnProperty(cur)) {
        // When only some key is specified, _all_ values under that key are removed.
        if (i === arguments.length - 1) {
          delete obj._[cur];
          // if we want correct reduce, we need to count all inner keys being removed
          if (Object.keys(obj).length === 0 && visited.length > 1) {
            _cleanUpRecursive(visited, key);  // cleaning all upper levels if they are empty either
          }
          mutated = true;
        }
        key = cur;
        obj = obj._[cur];
        visited.push([
          key,
          obj
        ]);  // at the previous to last index step obj is an Array
      } else {
        break;
      }
    }
    return mutated;
  };
  /**
   * Get objects under a key.
   * @returns {Array}
   * @param key under which sought-for element stored
   */
  Table.prototype.get = function (key) {
    if (this._.hasOwnProperty(key)) {
      return this._[key];
    }
    return [];
  };
  return Table;
}();
util_document = function (window) {
  return window.document;
}(util_window);
util_element_hound = function (Table, window, document) {
  var MutationObserver = window.MutationObserver;
  var observer;
  var observing = false;
  var Promise = window.Promise;
  var targets;
  // MutationObserver -- Required for determining whether selectors are satisfied in the DOM;
  // Promise -- Required for combining multiple conditions together.
  if (!(MutationObserver && Promise)) {
    return;
  }
  // A table of selector -> [hasNone -> [callbacks, ...], ... ] of things to find.
  targets = new Table();
  function isNothing(obj) {
    return !obj || obj == null || obj === 'null' || obj === 'undefined';
  }
  /**
   * Add a target to watch for, ensuring the MutationObserver is enabled.
   * @param {string} selector
   * @param {string} hasNone
   * @param {function} callback
   */
  function addTarget(selector, hasNone, callback) {
    if (!observing) {
      observer.observe(document, {
        attributes: true,
        childList: true,
        subtree: true
      });
      observing = true;
    }
    targets.add(selector, hasNone, callback);
  }
  /**
   * Find candidate elements that satisfy the "selector predicate".
   * @param selector
   * @param hasNone
   * @returns {boolean}
   */
  function satisfies(selector, hasNone) {
    var candidates = document.querySelectorAll(selector);
    return candidates.length && (isNothing(hasNone) || Array.prototype.every.call(candidates, function (element) {
      return !element.querySelector(hasNone);
    }));
  }
  // A MutationObserver so we know when the DOM changes.
  observer = new MutationObserver(function (mutations) {
    // 1. Gather list of elements that satisfy the "selector" predicate
    // 2. For each of those "candidate" elements, check if it satisfies the "hasNone" predicate.
    targets.forEach(function (callbacks, hasNone, selector) {
      if (satisfies(selector, hasNone)) {
        callbacks.forEach(function (callback) {
          callback();
        });
        targets.remove(selector, hasNone);
      }
    });
  });
  /**
   * @typedef {Promise} ElementHound
   * @property {function} dismiss When called, dismissed the hound.
   */
  /**
   * Find some elements!
   *
   * @param {string|string[]} selectors One ore more CSS selectors that must all match elements of interest.
   * @param {string|string[]} hasNones If not null, selectors only match elements that do not have descendants matching
   *     this selector.
   * @returns {ElementHound}
   * @constructor
   */
  function ElementHound(selectors, hasNones) {
    var dismiss;
    // Normalise selectors to an array.
    if (!selectors.forEach) {
      selectors = [selectors];
    }
    // Join all "hasNones" into one big comma separated selector
    if (!isNothing(hasNones) && Array.isArray(hasNones)) {
      hasNones = hasNones.join(',');
    }
    /**
     * @type {ElementHound}
     */
    var result = new Promise(function (resolve, reject) {
      var requirementPromises = [];
      var requirementCleanups = [];
      selectors.forEach(function (selector) {
        var promise;
        var cleanup;
        if (!satisfies(selector, hasNones)) {
          promise = new Promise(function (resolve) {
            addTarget(selector, hasNones, resolve);
            cleanup = function () {
              targets.remove(selector, hasNones, resolve);
            };
            requirementCleanups.push(cleanup);
          });
          requirementPromises.push(promise);
        }
      });
      // Clean-up after ourselves, to reduce the work done by the mutation observer.
      function cleanup() {
        requirementCleanups.forEach(function (requirementCleanup) {
          requirementCleanup();
        });
      }
      Promise.all(requirementPromises).then(cleanup).then(resolve, reject);
      dismiss = function () {
        cleanup();
        reject();
      };
    });
    // Allow the caller to explicitly dismiss the hound. This allows the caller to say
    // they don't care about the result any more, and allows us to stop looking for it.
    result.dismiss = dismiss;
    return result;
  }
  return ElementHound;
}(util_table, util_window, util_document);
util_element_wolf = function (Table, window, document) {
  var MutationObserver = window.MutationObserver;
  var observer;
  var observing = false;
  var Promise = window.Promise;
  var targets;
  // MutationObserver -- Required for determining whether selectors are satisfied in the DOM;
  // Promise -- Required for combining multiple conditions together.
  if (!(MutationObserver && Promise)) {
    return;
  }
  // A map of selector->[callback] of things to find.
  targets = new Table();
  /**
   * Add a target to watch for, ensuring the MutationObserver is enabled.
   * @param {string} selector
   * @param {function} callback
   */
  function addTarget(selector, callback) {
    if (!observing) {
      observer.observe(document, {
        attributes: true,
        childList: true,
        subtree: true
      });
      observing = true;
    }
    targets.add(selector, callback);
  }
  // A MutationObserver so we know when the DOM changes.
  observer = new MutationObserver(function (mutations) {
    targets.forEach(function (callbacks, selector) {
      if (!document.querySelector(selector)) {
        callbacks.forEach(function (callback) {
          callback();
        });
        targets.remove(selector);
      }
    });
  });
  /**
   * @typedef {Promise} ElementWolf
   * @property {function} dismiss When called, dismisses the wolf.
   */
  /**
   * Find some elements!
   *
   * @param {string|string[]} selectors One ore more CSS selectors that must all match elements of interest.
   * @returns {ElementWolf}
   * @constructor
   */
  function ElementWolf(selectors) {
    var dismiss;
    // Normalise selectors to an array.
    if (!selectors.forEach) {
      selectors = [selectors];
    }
    /**
     * @type {ElementWolf}
     */
    var result = new Promise(function (resolve, reject) {
      var requirementPromises = [];
      var requirementCleanups = [];
      selectors.forEach(function (selector) {
        var promise;
        var cleanup;
        if (document.querySelector(selector)) {
          promise = new Promise(function (resolve) {
            addTarget(selector, resolve);
            cleanup = function () {
              targets.remove(selector, resolve);
            };
          });
          requirementPromises.push(promise);
          requirementCleanups.push(cleanup);
        }
      });
      // Clean-up after ourselves, to reduce the work done by the mutation observer.
      function cleanup() {
        requirementCleanups.forEach(function (requirementCleanup) {
          requirementCleanup();
        });
      }
      Promise.all(requirementPromises).then(cleanup).then(resolve, reject);
      dismiss = function () {
        cleanup();
        reject();
      };
    });
    // Allow the caller to explicitly dismiss the hound. This allows the caller to say
    // they don't care about the result any more, and allows us to stop looking for it.
    result.dismiss = dismiss;
    return result;
  }
  return ElementWolf;
}(util_table, util_window, util_document);
api_start_is_ready_supported = function (ElementHound, ElementWolf) {
  /**
   * Feature detection for whether the .api({ready: …}) API option is supported.
   */
  return !!(ElementHound && ElementWolf);
}(util_element_hound, util_element_wolf);
util_is_dom_content_loaded_done = function (document, window) {
  var done = false;
  document.addEventListener('DOMContentLoaded', function () {
    // setTimeout matters here because the purpose of this module is to let know when all the DOMContentLoaded
    // event handlers have run. In order to know that, it would have to run after all the other handlers have run.
    // Hence we're using setTimeout to wait until the next tick. We know for certain that on the next tick all
    // the handlers have been executed due to JavaScript being single threaded.
    window.setTimeout(function () {
      done = true;
    });
  });
  /**
   * Return true if the DOMContentLoaded event handlers have been called.
   * @returns {boolean}
   */
  function isDOMContentLoadedDone() {
    return done;
  }
  return isDOMContentLoadedDone;
}(util_document, util_window);
api_start = function (end, isReadySupported, eventStream, ElementHound, ElementWolf, isDOMContentLoadedDone, window) {
  var Promise = window.Promise;
  var executeOnceOnStart = [];
  /**
   * In the .start() API, there are multiple short-hand versions of the 'ready' value that can be used. In the
   * interest of sanity, this function normalises them all to the most complex form.
   *
   * @param {string|string[]|{selector: string, requireUpdate: boolean, hasNone?: string|null}} conditions
   * @param {boolean} defaultRequireUpdate When a ready condition is a string (i.e. selector only), use this value for
   *     requireUpdate.
   * @returns {Array<{selector: string, requireUpdate: boolean, hasNone?: string|null}>}
   */
  function normalisedReady(conditions, defaultRequireUpdate) {
    if (!Array.isArray(conditions)) {
      conditions = [conditions];
    }
    return conditions.map(function (c) {
      return typeof c === 'string' ? {
        selector: c,
        requireUpdate: defaultRequireUpdate,
        hasNone: null
      } : c;
    });
  }
  /**
   * Combine all the ready conditions into a single promise.
   *
   * @param {{selector: string, requireUpdate: boolean, hasNone?: string|null}[]} conditions
   * @returns {Promise} a promise that is resolved when all conditions are satisfied
   */
  function combinedReady(conditions) {
    var combined;
    combined = conditions.map(function (condition) {
      var precondition;
      if (condition.requireUpdate) {
        precondition = new ElementWolf(condition.selector);
        // In case another transition happens _before_ we can finish.
        executeOnceOnStart.push(function () {
          precondition.dismiss();
        });
      } else {
        precondition = Promise.resolve();
      }
      return precondition.then(function () {
        var hound = new ElementHound(condition.selector, condition.hasNone);
        // In case another transition happens _before_ we can finish.
        executeOnceOnStart.push(function () {
          hound.dismiss();
        });
        return hound;
      });
    });
    return Promise.all(combined);
  }
  /**
   * Start measuring the duration of a transition.
   *
   * @param {String} options.key A key that identifies the page where the user is headed.
   * @param {boolean} [options.isInitial] If specified, indicates whether the transition should be treated as a
   *     "full page load" (initial). If not specified, this will be determined automatically based on whether or not
   *     DOMContentLoaded has fired.
   * @param {number} [options.threshold=1000] Declares the target (in milliseconds) duration for the navigation. The
   *     performance of the navigation is considered *good* if it completes within this threshold.
   * @param {String|String[]|{selector: string, requireUpdate: boolean}[]} [options.ready] A CSS selector that matches
   *     one or more DOM elements. When the selector matches something in the DOM, the page is considered "ready" for
   *     the user.
   *
   *     For non-initial page loads, if the selector _immediately_ matches one or more elements in the DOM, it will
   *     first wait a matching element to be removed, and then wait for a DOM mutation to expose a matching element.
   *     This behaviour can be turned off (i.e. don't require an element to be removed first) via the
   *     `requireUpdate=false` option.
   * @returns {undefined}
   * @example
   *     api.start({key: "jira.issue.view"});
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         threshold: 1000
   *     });
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         ready: ".issue-main-content",
   *         threshold: 1000
   *     });
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         ready: [
   *             ".issue-main-content",
   *             {selector: ".issue-main-content", hasNone: ".loading"},
   *             ".another-required-thing"
   *         ],
   *         threshold: 1000
   *     });
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         ready: [
   *             {selector: ".issue-main-content", requireUpdate: false, hasNone: ".aui-loading, .loading"},
   *             ".another-required-thing"
   *         ],
   *         threshold: 1000
   *     });
   */
  return function start(options) {
    var conditions;
    var isInitial = 'isInitial' in options ? options.isInitial : isDOMContentLoadedDone() === false;
    var threshold = 'threshold' in options ? options.threshold : 1000;
    eventStream.push({
      start: {
        key: options.key,
        isInitial: isInitial,
        threshold: threshold,
        timestamp: isInitial ? 0 : window.performance.now()
      }
    });
    executeOnceOnStart.forEach(function (callback) {
      callback();
    });
    // Empty the array of callbacks now that we've called them.
    executeOnceOnStart.splice(0, executeOnceOnStart.length);
    if (options.ready && isReadySupported) {
      conditions = normalisedReady(options.ready, /*defaultRequireUpdate=*/
      !isInitial);
      combinedReady(conditions).then(function () {
        end({ key: options.key });
      });
    }
  };
}(api_end, api_start_is_ready_supported, event_stream, util_element_hound, util_element_wolf, util_is_dom_content_loaded_done, util_window);
api_subscribe = function (eventStream) {
  /**
   * Add a subscriber that's interested in reports.
   */
  return function subscribe(subscriber) {
    eventStream.push({ subscribe: subscriber });
  };
}(event_stream);
index = function (isSupported, addReporter, delegateTo, end, start, subscribe) {
  var noop = function () {
  };
  return {
    start: isSupported ? start : noop,
    end: isSupported ? end : noop,
    addReporter: isSupported ? addReporter : noop,
    delegateTo: isSupported ? delegateTo : noop,
    subscribe: isSupported ? subscribe : noop
  };
}(is_supported, api_addReporter, api_delegateTo, api_end, api_start, api_subscribe);
window['browser-metrics'] = index;
if (window.define) {
  window.define('internal/browser-metrics', function () {
    return index;
  });
}
}());;
;
/* module-key = 'com.atlassian.plugins.browser.metrics.browser-metrics-plugin:api', location = 'internal/browser-metrics-aa-beacon.js' */
define("internal/browser-metrics-aa-beacon",function(){var n={};return n=function(n){function e(n,e){Object.keys(e).forEach(function(r){n[r]=e[r]})}var r=[],t=[];return n.addUrlCleaner=function(n){t.push(n)},n.cleanUrl=function(n){return t.reduce(function(e,r){var t=r(n);return t.length>e.length?t:e},"")},n.addReportMarshaller=function(n){r.push(n)},n.beacon=function(n){var t={};r.forEach(function(r){var a=r(n);"object"==typeof a&&e(t,a)});var a={name:"browser.metrics.navigation",properties:t};AJS.EventQueue.push(a)},n}(n)});;
;
/* module-key = 'com.atlassian.plugins.browser.metrics.browser-metrics-plugin:api', location = 'loader.js' */
;(function() {
var lib_window = {}, lib_wrm = {}, loader = {};
lib_window = function (exports) {
  var w = window;
  return w;
}(lib_window);
lib_wrm = function (exports, window) {
  var wrm = window.WRM;
  return wrm;
}(lib_wrm, lib_window);
loader = function (exports, window, WRM) {
  var contribInstallers = 0;
  var contribInstalls = 0;
  var collectorInstaller = null;
  function tryInstallCollector() {
    if (contribInstallers === contribInstalls && collectorInstaller) {
      collectorInstaller();
      collectorInstaller = null;
    }
  }
  var api = {
    install: function (installer) {
      contribInstallers += 1;
      installer(function () {
        contribInstalls += 1;
        tryInstallCollector();
      });
    }
  };
  window['browser-metrics-plugin'] = api;
  WRM.require(['wrc!browser-metrics-plugin.contrib'], function () {
    window.require(['internal/browser-metrics-plugin/collector'], function (collector) {
      collectorInstaller = function () {
        collector.install();
      };
      tryInstallCollector();
    });
  });
  return exports;
}(loader, lib_window, lib_wrm);
}());;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:metrics', location = 'content/js/util/metrics.js' */
define('jira/issues/navigator/metrics', ['internal/browser-metrics'], function (metrics) {
    "use strict";

    return {
        notifyIssueView: function () {
            metrics.start({
                key: "jira.issue.view",
                ready: [
                    {selector: "#key-val", requireUpdate: false},
                    ".issue-body-content"
                ]
            });
        },

        notifyIssueNavList: function () {
            metrics.start({
                key: "jira.issue.nav-list",
                ready: [
                    {selector: ".navigator-content", requireUpdate: false},
                    "#issuetable, .error, .no-results-hint, #errorPageContainer"
                ]
            });
        }
    };
});
;
;
/* module-key = 'jira.webresources:searchers', location = '/includes/jira/searchers/datePicker.soy' */
// This file was automatically generated from datePicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.DateSearcher.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.DateSearcher == 'undefined') { JIRA.Templates.DateSearcher = {}; }


JIRA.Templates.DateSearcher.dateMeasurement = function(opt_data, opt_ignored) {
  return '<select class="js-measurement"><option value="m">' + soy.$$escapeHtml("minutes") + '</option><option value="h">' + soy.$$escapeHtml("hours") + '</option><option value="d">' + soy.$$escapeHtml("days") + '</option><option value="w">' + soy.$$escapeHtml("weeks") + '</option></select>';
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.dateMeasurement.soyTemplateName = 'JIRA.Templates.DateSearcher.dateMeasurement';
}


JIRA.Templates.DateSearcher.renderWithinTheLast = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("Within the last {0} {1}",opt_data.inputField,opt_data.dateMeasurementField));
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.renderWithinTheLast.soyTemplateName = 'JIRA.Templates.DateSearcher.renderWithinTheLast';
}


JIRA.Templates.DateSearcher.withinTheLast = function(opt_data, opt_ignored) {
  return '<input type="radio" class="js-dp-type-toggle" id="withinTheLastRadio"/>' + JIRA.Templates.DateSearcher.renderWithinTheLast({inputField: '<input class="js-val" type="text" maxlength="15" />', dateMeasurementField: '' + JIRA.Templates.DateSearcher.dateMeasurement(null)});
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.withinTheLast.soyTemplateName = 'JIRA.Templates.DateSearcher.withinTheLast';
}


JIRA.Templates.DateSearcher.nowOverdue = function(opt_data, opt_ignored) {
  return '<label><input type="radio" class="js-dp-type-toggle" />' + soy.$$escapeHtml("Now overdue") + '</label>';
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.nowOverdue.soyTemplateName = 'JIRA.Templates.DateSearcher.nowOverdue';
}


JIRA.Templates.DateSearcher.renderMoreThan = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("More than {0} {1} ago",opt_data.inputField,opt_data.dateMeasurementField));
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.renderMoreThan.soyTemplateName = 'JIRA.Templates.DateSearcher.renderMoreThan';
}


JIRA.Templates.DateSearcher.moreThan = function(opt_data, opt_ignored) {
  return '<input type="radio" tabIndex="-1" class="js-dp-type-toggle" id="moreThanRadio"/>' + JIRA.Templates.DateSearcher.renderMoreThan({inputField: '<input class="js-val" type="text" maxlength="15" />', dateMeasurementField: '' + JIRA.Templates.DateSearcher.dateMeasurement(null)});
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.moreThan.soyTemplateName = 'JIRA.Templates.DateSearcher.moreThan';
}


JIRA.Templates.DateSearcher.renderDueMoreThan = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("More than {0} {1} overdue",opt_data.inputField,opt_data.dateMeasurementField));
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.renderDueMoreThan.soyTemplateName = 'JIRA.Templates.DateSearcher.renderDueMoreThan';
}


JIRA.Templates.DateSearcher.dueMoreThan = function(opt_data, opt_ignored) {
  return '<input type="radio" tabIndex="-1" class="js-dp-type-toggle" id="moreThanRadio"/>' + JIRA.Templates.DateSearcher.renderDueMoreThan({inputField: '<input class="js-val" type="text" maxlength="15" />', dateMeasurementField: '' + JIRA.Templates.DateSearcher.dateMeasurement(null)});
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.dueMoreThan.soyTemplateName = 'JIRA.Templates.DateSearcher.dueMoreThan';
}


JIRA.Templates.DateSearcher.renderDueInNext = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("Due in next {0} {1} {2} overdue",opt_data.inputField,opt_data.dateMeasurementField,opt_data.clauseField));
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.renderDueInNext.soyTemplateName = 'JIRA.Templates.DateSearcher.renderDueInNext';
}


JIRA.Templates.DateSearcher.dueInNext = function(opt_data, opt_ignored) {
  return '<input type="radio" tabIndex="-1" class="js-dp-type-toggle" id="dueInNextRadio"/>' + JIRA.Templates.DateSearcher.renderDueInNext({inputField: '<input class="js-val" maxlength="15" type="text" />', dateMeasurementField: '' + JIRA.Templates.DateSearcher.dateMeasurement(null), clauseField: '<select class="js-clause"><option value="orIs">' + soy.$$escapeHtml("or is") + '</option><option value="andNot">' + soy.$$escapeHtml("and not") + '</option></select>'});
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.dueInNext.soyTemplateName = 'JIRA.Templates.DateSearcher.dueInNext';
}


JIRA.Templates.DateSearcher.renderDateBetween = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("Between {0} and {1}",opt_data.startField,opt_data.endField));
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.renderDateBetween.soyTemplateName = 'JIRA.Templates.DateSearcher.renderDateBetween';
}


JIRA.Templates.DateSearcher.dateBetween = function(opt_data, opt_ignored) {
  return '<input type="radio" tabIndex="-1" class="js-dp-type-toggle" id="dateBetweenRadio"/>' + JIRA.Templates.DateSearcher.renderDateBetween({startField: '<input class="js-start-date" maxlength="15" placeholder="11-Jan-2012" type="text" /><span class="js-start-date-trigger aui-icon aui-icon-small aui-iconfont-calendar">' + soy.$$escapeHtml("Select a date") + '</span>', endField: '<input class="js-end-date" maxlength="12" placeholder="30-Jan-2012" type="text" /><span class="js-end-date-trigger aui-icon aui-icon-small aui-iconfont-calendar">' + soy.$$escapeHtml("Select a date") + '</span>'});
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.dateBetween.soyTemplateName = 'JIRA.Templates.DateSearcher.dateBetween';
}


JIRA.Templates.DateSearcher.renderInRange = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("In range {0} to {1}",opt_data.startInput,opt_data.endInput));
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.renderInRange.soyTemplateName = 'JIRA.Templates.DateSearcher.renderInRange';
}


JIRA.Templates.DateSearcher.inRange = function(opt_data, opt_ignored) {
  return '<input type="radio" tabIndex="-1" maxlength="15" class="js-dp-type-toggle" id="inRangeRadio"/>' + JIRA.Templates.DateSearcher.renderInRange({startInput: '<input class="js-start-range" placeholder="-3w 4d 12h" type="text" />', endInput: '<input class="js-end-range" maxlength="15" placeholder="3w 4d 12h" type="text" />'});
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.inRange.soyTemplateName = 'JIRA.Templates.DateSearcher.inRange';
}
;
;
/* module-key = 'jira.webresources:searchers', location = '/includes/jira/searchers/DateSearcher.js' */
(function ($) {
    /**
     * https://jira.atlassian.com/browse/JRA-30741
     *
     * List of class definitions used by the date searcher, which we don't want to
     * 'labelfy'
     *
     * @type {Array}
     * @private
     */
    var _excludeList = ["js-dp-type-toggle", "js-val", "js-measurement", "js-clause",
                        "js-start-date", "js-end-date", "js-start-range", "js-end-range"];

    /**
     * https://jira.atlassian.com/browse/JRA-30741
     *
     * This function 'labelfy' raw html string.
     * The purpose of this is to automatically select the radio element when a labelfied element is clicked.
     *
     * This should only labelfy text element. Any non-text element, such as a dropdown list/text field should
     * be handled through javascript instead of abusing the label tag
     *
     * @param content {String} Raw html string of the field
     * @param radioKey {String} ID string of the radio element that will be selected when a labelfied element is clicked
     * @return {String} Raw html string that has been labelfied
     * @private
     */
    var _labelfyContent = function (content, radioKey) {
        var $content = jQuery("<div></div>").html(content).contents();
        var transformed = [];

        $content.each(function(index, element) {
            var $element = jQuery(element);
            var value = jQuery("<div/>").html(element).html();

            if (!_.contains(_excludeList, $element.attr("class"))) {
                /*
                 This is to ensure white spaces coming from the template are correctly displayed in html
                 */
                value = value.replace(/^\s+|\s+$/g, '&nbsp;');
                transformed.push( "<label for='" + radioKey + "'>" + value + "</label>");
            } else {
                transformed.push(value);
            }
        });

        return transformed.join("");
    };

    /**
     * This function takes the labelfied raw html and attach handlers to non-text element, such that
     * clicking on them will automatically select the radio element.
     *
     * Why don't we just inline the label element and put everything inside it you say?
     * Well, in the ideal world, there should only be one language, everybody should use chrome and the cake is NOT a lie.
     * But unfortunately, interactions between non-text elements inside a label tag behaves different
     * between browsers. In firefox, dropdown list and text field immediately lose their focus when you click on them,
     * and who knows what might happen in IE.
     *
     * See https://jira.atlassian.com/browse/JRA-30741
     *
     * @param data
     * @return {*}
     * @private
     */
    var _generateSearcherAndBindHandler = function(data) {
        var radioKey = data.radioKey + "Radio";
        var outputContent = data.$el.html(_labelfyContent(data.rawTemplate, radioKey));
        outputContent.find(":not(.js-dp-type-toggle):not(select):input").mousedown(function() {
            /*
             WHAT? why are you clicking on the label?
             3 characters: IE8
             Clicking on radio button doesn't work in IE8 because it doesn't unselect other radio buttons

             When using 'input', Firefox also matches the <select> elements, so we need to add a special clause for that
             */
            var $label = outputContent.find("label");
            if ($label.length > 0) {
                $label[0].click();
            }
        });
        return outputContent;
    };

    var NowOverdue = Backbone.View.extend({
        className: "field-group",
        attributes: {"data-date-type" : "nowOverdue"},
        template: JIRA.Templates.DateSearcher.nowOverdue,
        getValues: function () {
            return {to: 0};
        },
        updateFromValues: function (values) {
            if (!values.from && values.to === "0") {
                return true;
            }
        },
        render: function () {
            return this.$el.html(this.template());
        }
    });


    var WithinTheLast = Backbone.View.extend({
        className: "field-group",
        attributes: {"data-date-type" : "withinTheLast"},
        template: JIRA.Templates.DateSearcher.withinTheLast,
        getValues: function () {
            var val = this.$(".js-val").val();
            if (val) {
                return {
                    from: "-" + val + this.$el.find(".js-measurement").val()
                };
            }
        },
        updateFromValues: function (values) {
            if (!values.to && values.from && values.from.charAt(0) === "-") {
                // gets the character that represents the measurement
                var vals = this.model.parseRelativeStr(values.from);
                this.$(".js-val").val(vals.val.slice(1));
                if (vals.measurement) {
                    this.$(".js-measurement").val(vals.measurement);
                }
                return true;
            }
        },
        render: function (verb) {
            return _generateSearcherAndBindHandler({
                $el: this.$el,
                rawTemplate: this.template(),
                radioKey: this.attributes["data-date-type"]
            });
        }
    });


    var MoreThan = Backbone.View.extend({
        className: "field-group",
        attributes: {"data-date-type" : "moreThan"},
        template: JIRA.Templates.DateSearcher.moreThan,
        getValues: function () {
            var val = this.$(".js-val").val();
            if (val) {
                return {
                    to: "-" + val + this.$el.find(".js-measurement").val()
                };
            }
        },
        updateFromValues: function (values) {
            if (!values.from && values.to && values.to.charAt(0) === "-") {
                // gets the character that represents the measurement
                var vals = this.model.parseRelativeStr(values.to);
                this.$(".js-val").val(vals.val.slice(1));
                if (vals.measurement) {
                    this.$(".js-measurement").val(vals.measurement);
                }
                return true;
            }
        },
        render: function (verb) {
            return _generateSearcherAndBindHandler({
                $el: this.$el,
                rawTemplate: this.template(),
                radioKey: this.attributes["data-date-type"]
            });
        }
    });

    var DueMoreThan = MoreThan.extend({
        className: "field-group",
        template: JIRA.Templates.DateSearcher.dueMoreThan
    });

    var DueInNext = Backbone.View.extend({
        className: "field-group",
        attributes: {"data-date-type" : "dueInNext"},
        template: JIRA.Templates.DateSearcher.dueInNext,
        getValues: function () {
            var val = this.$el.find(".js-val").val();
            if (val) {
                return {
                    from: this.$el.find(".js-clause").val() === "andNot" ?  "0" : null,
                    to: val + this.$(".js-measurement").val()
                };
            }
        },
        updateFromValues: function (values) {
            if ((!values.from || values.from === "0") && values.to) {
                // gets the character that represents the measurement
                var vals = this.model.parseRelativeStr(values.to);
                var clause = values.from  === "0" ? "andNot" : "orIs";
                this.$(".js-val").val(vals.val);
                this.$(".js-clause").val(clause);
                if (vals.measurement) {
                    this.$(".js-measurement").val(vals.measurement);
                }
                return true;
            }
        },
        render: function () {
            return _generateSearcherAndBindHandler({
                $el: this.$el,
                rawTemplate: this.template(),
                radioKey: this.attributes["data-date-type"]
            });
        }
    });

    var DatesBetween = Backbone.View.extend({
        className: "field-group",
        attributes: {"data-date-type" : "dateBetween"},
        template: JIRA.Templates.DateSearcher.dateBetween,
        getValues: function () {
            return {
                startDate: this.$el.find(".js-start-date").val(),
                endDate: this.$el.find(".js-end-date").val()
            };
        },
        updateFromValues: function (values) {
            if (values.startDate || values.endDate) {
                this.$el.find(".js-start-date").val(values.startDate);
                this.$el.find(".js-end-date").val(values.endDate);
                return true;
            }
        },
        bindCalendar: function (inputClass, triggerClass) {
            var trigger = this.$el.find("." + triggerClass)[0];
            var input = this.$el.find("." + inputClass)[0];
            var calendarParams = _.extend({}, this.model.calendarConfig, {
                inputField: input,
                button: trigger
            });
            Calendar.setup(calendarParams);
        },
        render: function () {
            _generateSearcherAndBindHandler({
                $el: this.$el,
                rawTemplate: this.template(),
                radioKey: this.attributes["data-date-type"]
            });
            this.bindCalendar("js-end-date", "js-end-date-trigger");
            this.bindCalendar("js-start-date", "js-start-date-trigger");
            return this.$el;
        }
    });

    var InRange = Backbone.View.extend({
        className: "field-group",
        attributes: {"data-date-type" : "inRange"},
        template: JIRA.Templates.DateSearcher.inRange,
        getValues: function () {
            return {
                from: this.$el.find(".js-start-range").val(),
                to: this.$el.find(".js-end-range").val()
            };
        },
        updateFromValues: function (values) {
            if (values.from || values.to) {
                this.$el.find(".js-start-range").val(values.from);
                this.$el.find(".js-end-range").val(values.to);
                return true;
            }
        },
        render: function () {
            return _generateSearcherAndBindHandler({
                $el: this.$el,
                rawTemplate: this.template(),
                radioKey: this.attributes["data-date-type"]
            });
        }
    });


    /**
     * This model is a wrapper around 4 hidden input fields. The values of these fields is what actually gets sent to the
     * server.
     * @class
     * @extends external:"Backbone.Model"
     * @private
     */
    var DateSeacherModel = Backbone.Model.extend({

        /**
         * @constructs
         */
        initialize: function (options) {
            this.from$El = options.$el.find(".js-date-picker-from").hide();
            this.to$El = options.$el.find(".js-date-picker-to").hide();
            this.startDate$El = options.$el.find(".js-date-picker-start-date").hide();
            this.endDate$El = options.$el.find(".js-date-picker-end-date").hide();
            this.errors = JIRA.parseOptionsFromFieldset(options.$el.find('fieldset.js-date-picker-errors'));
            this.calendarConfig = JIRA.parseOptionsFromFieldset(options.$el.find('fieldset.datepicker-params'));
        },

        parseRelativeStr: function (str) {
            var measurement = str.slice(str.length-1);
            var val = str.slice(0, str.length-1);
            return {
                val: val,
                measurement: measurement
            };
        },

        update: function (updateParams) {
            this.clear();
            if (updateParams) {
                if (typeof updateParams.from !== "undefined") {
                    this.from$El.val(updateParams.from);
                }
                if (typeof updateParams.to !== "undefined") {
                    this.to$El.val(updateParams.to);
                }
                if (typeof updateParams.startDate !== "undefined") {
                    this.startDate$El.val(updateParams.startDate);
                }
                if (typeof updateParams.endDate !== "undefined") {
                    this.endDate$El.val(updateParams.endDate);
                }
            }
        },

        toJSON: function () {
            return {
                from: this.from$El.val(),
                to: this.to$El.val(),
                startDate: this.startDate$El.val(),
                endDate: this.endDate$El.val(),
                errors: this.errors
            };
        },

        /**
         * Clears all the hidden input values
         */
        clear: function () {
            this.from$El.val("");
            this.to$El.val("");
            this.startDate$El.val("");
            this.endDate$El.val("");
        }
    });

    /**
     * Renders the date searcher ui.
     * @class JIRA.DateSearcher
     * @extends external:"Backbone.View"
     */
    JIRA.DateSearcher = Backbone.View.extend({

        /**
         * @param {Object} options
         * @param {jQuery} options.el - Container element
         * @param {jQuery} options.dateTypes - Container element
         * @constructs
         */
        initialize: function (options) {
            var instance = this;
            this.verb = options.verb;
            this.model = new DateSeacherModel({$el: this.$el});
            this.setElement($("<div />").addClass("js-picker-ui").appendTo(this.$el));
            this.views = [];

            /*
             * JRADEV-17691: IE10 doesn't implement the input event very well it incorrectly fires when you have placeholder text and you tab to it.
             * So in the case of IE10 we use a keydown and keyup to compare the values to validate input instead.
             */
            var useInputEvent = !jQuery.browser.msie || parseInt(jQuery.browser.version, 10) < 10;

            _.each(options.dateTypes, function (dateType) {
                var view = new dateType({model: instance.model});
                instance.views.push(view);

                if (useInputEvent) {
                    view.$el.delegate(":text", "input", function () {
                        instance.update(view);
                    });
                } else {
                    view.$el.delegate(":text", "keydown", function () {
                        var $this = jQuery(this);
                        var currentVal = $this.val();
                        $this.one("keyup", function () {
                            if ($this.val() !== currentVal) {
                                instance.update(view);
                            }
                        });
                    });
                    // for copy and paste
                    view.$el.delegate(":text", "change", function () {
                        instance.update(view);
                    });
                }

                view.$el.delegate(":radio,select,input", "change", function () {
                    instance.update(view);
                }).delegate(".aui-iconfont-calendar", "click", function () {
                    instance.update(view);
                });
            });
        },

        update: function (selectedView, error) {
            this.model.update(selectedView.getValues());
            _.each(this.views, function (view) {
                if (view === selectedView) {
                    view.$(":radio").prop("checked", true);
                } else {
                    view.$(":radio").prop("checked", false);
                }
            });
        },

        render: function () {
            var instance = this;
            var values = this.model.toJSON();
            _.each(this.views, function (view) {
                instance.$el.append(view.render(instance.verb));
            });

            $.each(this.views, function (i, view) {
                if (this.updateFromValues(values)) {
                    instance.update(this);
                    if (values.errors) {
                        $.each(values.errors, function (i, error) {
                            $("<div />").addClass("error").text(error).appendTo(view.$el);
                            return false;
                        });
                    }
                    return false;
                }
            });

            // kickass default focuses first field. We don't want this unless we have nothing selected
            window.setTimeout(function () {
                instance.$el.find(":radio:checked").focus();
            }, 30);
        }
    });

    /**
     * @static
     * @param {HTMLElement} el
     * @returns {JIRA.DateSearcher}
     */
    JIRA.DateSearcher.createDueDateSearcher = function (el) {
        return new JIRA.DateSearcher({
            el: el,
            dateTypes: [NowOverdue, DueMoreThan, DueInNext, DatesBetween, InRange]
        }).render();
    };

    /**
     * @static
     * @param {HTMLElement} el
     * @returns {JIRA.DateSearcher}
     */
    JIRA.DateSearcher.createResolvedDateSearcher = function (el) {
        return new JIRA.DateSearcher({
            el: el,
            dateTypes: [WithinTheLast, MoreThan, DatesBetween, InRange]
        }).render();
    };

    /**
     * @static
     * @param {HTMLElement} el
     * @returns {JIRA.DateSearcher}
     */
    JIRA.DateSearcher.createCreatedDateSearcher = function (el) {
        return new JIRA.DateSearcher({
            el: el,
            dateTypes: [WithinTheLast, MoreThan, DatesBetween, InRange]
        }).render();
    };

    /**
     * @static
     * @param {HTMLElement} el
     * @returns {JIRA.DateSearcher}
     */
    JIRA.DateSearcher.createUpdatedDateSearcher = function (el) {
        return new JIRA.DateSearcher({
            el: el,
            dateTypes: [WithinTheLast, MoreThan, DatesBetween, InRange]
        }).render();
    };

    /**
     * @static
     * @param {HTMLElement} el
     * @returns {JIRA.DateSearcher}
     */
    JIRA.DateSearcher.createCustomDateSearcher = function (el) {
        return new JIRA.DateSearcher({
            el: el,
            dateTypes: [WithinTheLast, MoreThan, DatesBetween, InRange]
        }).render();
    };

})(AJS.$);


;
;
/* module-key = 'jira.webresources:searchers', location = '/includes/jira/searchers/initDateSearchers.js' */
jQuery(function () {

    function initDueDateSearcher($ctx) {
        $ctx.find(".js-duedate-searcher").each(function () {
            JIRA.DateSearcher.createDueDateSearcher(this);
        });
    }

    function initResolvedDateSearcher($ctx) {
        $ctx.find(".js-resolutiondate-searcher").each(function () {
            JIRA.DateSearcher.createResolvedDateSearcher(this);
        });
    }

    function initCreatedDateSearcher($ctx) {
        $ctx.find(".js-created-searcher").each(function () {
            JIRA.DateSearcher.createCreatedDateSearcher(this);
        });
    }

    function initUpdatedDateSearcher($ctx) {
        $ctx.find(".js-updated-searcher").each(function () {
            JIRA.DateSearcher.createUpdatedDateSearcher(this);
        });
    }

    function initCustomFieldDateSearcher($ctx) {
        $ctx.find(".js-customdate-searcher").each(function () {
            JIRA.DateSearcher.createCustomDateSearcher(this);
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason === JIRA.CONTENT_ADDED_REASON.criteriaPanelRefreshed) {
            initDueDateSearcher(context);
            initResolvedDateSearcher(context);
            initCreatedDateSearcher(context);
            initUpdatedDateSearcher(context);
            initCustomFieldDateSearcher(context);
        }
    });
});


;
;
/* module-key = 'jira.webresources:searchers', location = '/includes/jira/searchers/initSparklers.js' */
define('jira/searchers/element/sparkler', [
    'jira/ajs/select/checkbox-multi-select',
    'jira/skate'
], function (CheckboxMultiSelect, skate) {

    return skate("js-default-checkboxmultiselect", {
        type: skate.type.CLASSNAME,
        created: function checkboxMultiSelectCreated(element) {
            new CheckboxMultiSelect({
                element: element
            });
        }
    });
});

define('jira/searchers/element/status-lozenge-sparkler', [
    'jira/ajs/select/checkbox-multi-select-status-lozenge',
    'jira/skate'
], function (CheckboxMultiSelectStatusLozenge, skate) {

    return skate("js-default-checkboxmultiselectstatuslozenge", {
        type: skate.type.CLASSNAME,
        created: function checkboxMultiSelectCreated(element) {
            new CheckboxMultiSelectStatusLozenge({
                element: element
            });
        }
    });
});

define("jira/searchers/element/label-sparkler", [
    'jira/ajs/select/checkbox-multi-select',
    'jira/ajs/list/group-descriptor',
    'jira/ajs/list/item-descriptor',
    'jira/skate',
    'jquery',
    'underscore',
    'wrm/context-path'
], function(
    CheckboxMultiSelect,
    GroupDescriptor,
    ItemDescriptor,
    skate,
    $,
    _,
    contextPath
) {

    return skate("js-label-checkboxmultiselect", {
        type: skate.type.CLASSNAME,
        created: function checkboxMultiSeletCreated(element) {
            var cms = new CheckboxMultiSelect({
                element: element,
                ajaxOptions: {
                    url: contextPath() + "/rest/api/1.0/labels/suggest",
                    query: true,
                    minQueryLength: 0,
                    formatResponse: function (response) {
                        var selectedValues = cms.model.getSelectedValues();
                        return [new GroupDescriptor({
                            items: _.map(_.sortBy(_.reject(response.suggestions, function (suggestion) {
                                return _.contains(selectedValues, suggestion.label);
                            }), "label"), function (suggestion) {
                                return new ItemDescriptor({
                                    highlighted: true,
                                    html: suggestion.html,
                                    label: suggestion.label,
                                    value: suggestion.label,
                                    title: suggestion.label
                                });
                            })
                        })];
                    }
                }
            });
        }
    });
});

// Invoke immediately
require([
    "jira/searchers/element/sparkler",
    "jira/searchers/element/status-lozenge-sparkler",
    "jira/searchers/element/label-sparkler"
]);
;
;
/* module-key = 'jira.webresources:searchers', location = '/includes/jira/searchers/initUserSparkler.js' */
define('jira/searchers/user-utils', [
    'jira/ajs/list/group-descriptor',
    'jira/ajs/list/item-descriptor',
    'underscore',
    'wrm/context-path'
], function(
    GroupDescriptor,
    ItemDescriptor,
    _,
    contextPath
) {

    // Creates group/item descriptors from an AJAX response.
    function _formatUserGroupResponse(response) {
        var users = _formatUserResponse(response.users, true);
        var groups = _formatGroupResponse(response.groups, true);
        var items = [].concat(users).concat(groups);
        return [new GroupDescriptor({items: items})];
    }

    function _formatUserResponse(response, prefix) {
        return _.map(response.users, function (item) {
            return new ItemDescriptor({
                highlighted: true,
                html: item.html,
                icon: item.avatarUrl,
                label: item.displayName,
                value: (prefix ? "user:" : "") + item.name
            });
        });
    }

    function _formatGroupResponse(response, prefix) {
        return _.map(response.groups, function (item) {
            return new ItemDescriptor({
                highlighted: true,
                html: item.html,
                icon: contextPath() + "/images/icons/icon_groups_16.png",
                label: item.name,
                value: (prefix ? "group:" : "") + item.name
            });
        });
    }

    return {
        formatGroupResponse: _formatGroupResponse,
        formatUserResponse: _formatUserResponse,
        formatUserGroupResponse: _formatUserGroupResponse
    };
});

define('jira/searchers/elements/user-group-sparkler', [
    'jira/ajs/select/checkbox-multi-select',
    'jira/data/parse-options-from-fieldset',
    'jira/searchers/user-utils',
    'jira/skate',
    'jquery',
    'wrm/context-path'
], function(
    CheckboxMultiSelect,
    parseOptionsFromFieldset,
    utils,
    skate,
    $,
    contextPath
) {

    return skate("js-usergroup-checkboxmultiselect", {
        type: skate.type.CLASSNAME,
        created: function usergroupSparklerCreated(element) {
            var ajaxData = {};
            // grab additional parameters from fieldset
            $(element).siblings(".user-group-searcher-params").each(function () {
                ajaxData = parseOptionsFromFieldset($(this));
            });
            ajaxData.showAvatar = true;
            new CheckboxMultiSelect({
                element: element,
                maxInlineResultsDisplayed: 10,
                content: "mixed",
                ajaxOptions: {
                    url: contextPath() + "/rest/api/latest/groupuserpicker",
                    data: ajaxData,
                    query: true,
                    formatResponse: utils.formatUserGroupResponse
                }
            });
        }
    });
});

define('jira/searchers/elements/user-sparkler', [
    'jira/ajs/select/checkbox-multi-select',
    'jira/searchers/user-utils',
    'jira/skate',
    'wrm/context-path'
], function(
    CheckboxMultiSelect,
    utils,
    skate,
    contextPath
) {

    return skate("js-user-checkboxmultiselect", {
        type: skate.type.CLASSNAME,
        created: function userSparklerCreated(element) {
            new CheckboxMultiSelect({
                element: element,
                maxInlineResultsDisplayed: 5,
                content: "mixed",
                ajaxOptions: {
                    url: contextPath() + "/rest/api/latest/user/picker",
                    data: {
                        showAvatar: true
                    },
                    query: true,
                    formatResponse: function (items) {
                        return utils.formatUserResponse(items, false);
                    }
                }
            });
        }
    });
});

define('jira/searchers/elements/group-sparkler', [
    'jira/ajs/select/checkbox-multi-select',
    'jira/searchers/user-utils',
    'jira/skate',
    'wrm/context-path'
], function(
    CheckboxMultiSelect,
    utils,
    skate,
    contextPath
) {

    return skate("js-group-checkboxmultiselect", {
        type: skate.type.CLASSNAME,
        created: function groupSparklerCreated(element) {
            new CheckboxMultiSelect({
                element: element,
                maxInlineResultsDisplayed: 5,
                content: "mixed",
                ajaxOptions: {
                    url: contextPath() + "/rest/api/latest/groups/picker",
                    data: {
                        showAvatar: true
                    },
                    query: true,
                    formatResponse: function (items) {
                        return utils.formatGroupResponse(items, false);
                    }
                }
            });
        }
    });
});

// Invoke immediately
require([
    'jira/searchers/elements/group-sparkler',
    'jira/searchers/elements/user-sparkler',
    'jira/searchers/elements/user-group-sparkler'
]);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:latest-search-store', location = 'search/LatestSearchStore.js' */
define("jira/components/search/latestStorage",
    ["jquery",
     "jira/data/local-storage"
    ],
    function(jQuery, LocalStorage) {
        "use strict";

        var LATEST_SEARCH_KEY = "jira.issue.navigator.latest.search";

        return {
            get: function () {
                try {
                    var storedLatestSearch = LocalStorage.getItem(LATEST_SEARCH_KEY);

                    if (storedLatestSearch) {
                        var latestSearch = jQuery.parseJSON(storedLatestSearch);
                        if (latestSearch.jql || latestSearch.filter) {
                            return latestSearch;
                        }
                    }
                } catch (e) {
                    return {};
                }
            },

            /**
             * @param search.jql
             * @param search.filter
             */
            save: function (search) {
                try {
                    LocalStorage.setItem(LATEST_SEARCH_KEY, JSON.stringify(search));
                } catch (ignored) {}

            }
        };
});
AJS.namespace("JIRA.Issues.LatestSearch", null, require("jira/components/search/latestStorage"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common-mess', location = 'content/js/search/SearchPageModule.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.SearchPageModule");

    JIRA.Issues.SearchPageModule = JIRA.Issues.BaseModel.extend({

        namedEvents: ["changeFilterProps"],

        properties: [
            "currentLayout",
            "layouts",
            "filter",
            "jql",
            "searchId"
        ],

        defaults: function() {
            return {
                filter: null,
                jql: null
            };
        },

        initialize: function(attributes, options) {
            _.extend(this, options);

            this.registerColumnPicker();

            // This is here instead of in defaults, because we use the defaults
            // to reset this module's state (filter and jql) but we don't want to
            // reset the layouts.
            this.setLayouts({});

            this.registerLayout("list-view", {
                label: "List View",
                iconClass: 'aui-iconfont-view-table',
                View: JIRA.Issues.FullScreenLayout
            });

            this.registerLayout("split-view", {
                label: "Detail View",
                iconClass: 'aui-iconfont-view-list',
                View: require('jira/issues/views/details')
            });

            this._onFilterChanged();
            this.on("change:filter", this._onFilterChanged, this);
            JIRA.Issues.Application.on("issueEditor:close", this.returnToSearch, this);

            JIRA.Issues.Application.on("issueEditor:loadComplete", function(model, props) {
                if (!this.standalone && !props.reason) {
                    this.searchResults.selectIssueById(model.getId(), {reason: "issueLoaded"});
                    this.searchResults.updateIssueById({
                        id: model.getId(),
                        action: "rowUpdate"
                    }, {filter: this.getFilter()});
                     //Replace URL if issue key has changed
                    if (model.getKey()) {
                        JIRA.Issues.Application.execute("navigation:updateState", {selectedIssueKey: model.getKey()},
                                {replace: true, reason: "issuekey-changed"});
                    }
                }
            }, this);

            JIRA.Issues.Application.on("issueEditor:saveSuccess", function(props) {
                this.searchResults.updateIssueById({
                    id: props.issueId,
                    action: "inlineEdit"
                }, {filter: this.getFilter()});
            }, this);

            JIRA.Issues.Application.on("navigation:stateChanged", this.onStateChanged, this);
        },

        registerColumnPicker: function() {
            this.columnConfig = JIRA.Issues.ColumnPicker.create({search: this});
        },


        getInactiveLayouts: function() {
            var layouts = [];
            _.each(this.getLayouts(), function(layout, key) {
                if (key !== JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey()) {
                    layouts.push(layout);
                }
            }, this);
            return layouts;
        },

        getActiveLayout: function() {
            return this.getLayouts()[JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey()];
        },

        /**
         * Change the page layout.
         * <p/>
         * No-op if the requested layout is already selected.
         *
         * @param {string} key The key of the layout to change to.
         * @param {object} [options]
         * @param {boolean} [options.ajax=true] Whether to POST the user's preferred layout to the server.
         * @param {boolean} [options.render=true] Whether to render the new layout.
         */
        changeLayout: function(key, options) {
            var layout = this.getLayout(key);
            var newLayout;
            var previousLayout = this.getCurrentLayout();

            JIRA.Issues.changingLayout = true;

            // JRADEV-20786 - Scroll to top of page before changing layouts.
            jQuery("body, html").scrollTop(0);

            options = _.defaults({}, options, {
                ajax: true,
                render: true
            });

            if (layout) {
                // If the requested layout is already selected, do nothing.
                if (previousLayout instanceof layout.View) {
                    return;
                }

                if (previousLayout && previousLayout.close) {
                    previousLayout.close();
                    // now unselect the selected issue. the assumption here is that we are switching to
                    // a mode that does not have an issue selected by default (i.e. list view).
                    this.searchResults.unselectIssue({replace: true});
                }

                JIRA.Issues.LayoutPreferenceManager.setPreferredLayoutKey(key, options);

                newLayout = new layout.View({
                    fullScreenIssue: this.fullScreenIssue,
                    issueContainer: this.issueContainer,
                    issueCacheManager: this.issueCacheManager,
                    search: this.search,
                    searchContainer: this.searchContainer,
                    searchHeaderModule: this.searchHeaderModule,
                    columnConfig: this.columnConfig,
                    searchPageModule: this
                });

                newLayout.on("close", function() {
                    this.searchContainer.find('.navigator-content').addClass("pending");
                }, this);

                newLayout.on("render", function() {
                    this.searchContainer.find('.navigator-content').removeClass("pending");
                    JIRA.trigger(JIRA.Events.LAYOUT_RENDERED, [key]);
                }, this);

                if (options.render) newLayout.render();
                this.setCurrentLayout(newLayout);

                this.standalone = false;
            }
        },

        /**
         * Create an instance of the user's preferred layout and set it as the current layout.
         */
        createLayout: function() {
            if (!this.getCurrentLayout()) {
                this.changeLayout(JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey(), {render: false});
                this.fullScreenIssue.deactivate();
            }
        },

        _onFilterChanged: function() {
            var previousFilter = this.previous('filter');
            if (previousFilter) {
                previousFilter.off('change', this.triggerChangeFilterProps, this);
            }

            var currentFilter = this.getFilter();
            if (currentFilter) {
                currentFilter.on('change', this.triggerChangeFilterProps, this);
            }
        },

        /**
         * @param {string} key A layout key.
         * @return {object|null} The layout associated with <tt>key</tt> or <tt>null</tt>.
         */
        getLayout: function(key) {
            return this.getLayouts()[key] || null;
        },

        /**
         * @return {object} an array of all registered layouts, sorted by label.
         */
        getSortedLayouts: function() {
            return _.sortBy(this.getLayouts(), "label");
        },

        /**
         * Associate a layout class with a key.
         *
         * @param {string} key A key used to identify the layout. If the key isn't unique, the old layout is overridden.
         * @param {object} layout The layout class to be associated with <tt>key</tt>; its constructor, not an instance.
         */
        registerLayout: function(key, layout) {
            layout.id = key;
            this.getLayouts()[key] = layout;
        },

        /**
         * Get jql but make sure that any requests to get jql have completed.
         * @return {jQuery.Deferred}
         */
        getJqlDeferred: function() {
            var deferred = new jQuery.Deferred();
            var instance = this;
            // I am adding a settimeout to fix the following case and avoid similar ones in the future.
            // I open a searcher, make some changes. Clicking the "Save" button to update the filter, I want to
            // get the jql after the searcher have made their request to the server. Unfortunately because the click
            // event of the "Save" button happens before the searchers make their request, we need to delay a tad.
            _.defer(function() {
                instance.queryModule.searchersReady().always(function() {
                    // Similar senario as the one above except in this case the request has returned but the jql hasn't been set.
                    _.defer(function() {
                        deferred.resolve(instance.getEffectiveJql());
                    });
                });
            });
            return deferred.promise();
        },

        registerIssueSearchManager: function(searchManger) {
            this.issueSearchManager = searchManger;
        },

        registerIssueCacheManager: function(issueCacheManager) {
            this.issueCacheManager = issueCacheManager;
        },

        registerQueryModule: function(queryModule) {
            this.queryModule = queryModule;
            this.queryModule.onJqlChanged(this.queryModuleSearchRequested, this);
            this.queryModule.onJqlError(this.disableLayoutSwitcher, this);
            this.queryModule.onJqlSuccess(this.enableLayoutSwitcher, this);
            this.queryModule.onVerticalResize(JIRA.Issues.triggerVerticalResize);
            this.queryModule.onQueryTooComplexSwitchToAdvanced(function() {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.queryTooComplexSwitchToAdvanced");
            });
            this.queryModule.onBasicModeCriteriaCountWhenSearching(function(data) {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.basicModeCriteriaCountWhenSearching", data);
            });
            this.queryModule.onChangedPreferredSearchMode(function(mode) {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.switchto" + mode);
            });
            this.queryModule.onSearchChanged(_.bind(function(ev){
                var state = this.getState();
                var inputJql = ev.newJql;
                var filterJql = state.filterJql;
                var searchJql = state.jql;

                var isEditedFilter;
                var isPendingSearch;
                if (searchJql === null) {
                    // The current search is just the filter search, but the search box has a different JQL
                    isEditedFilter = filterJql !== inputJql;
                    isPendingSearch = filterJql !== inputJql;
                } else {
                    // The current search is different from the filter search or from the search box
                    isEditedFilter = filterJql !== searchJql || searchJql !== inputJql;
                    isPendingSearch = searchJql !== inputJql;
                }
                this.filterModule.updateFilterHeader({
                    isEdited: isEditedFilter,
                    isPendingSearch: isPendingSearch
                });

            }, this));            
            JIRA.Shifter.register(new JIRA.Issues.SearchShifter({
                isBasicMode: _.bind(this.queryModule.isBasicMode, this.queryModule),
                isFullScreenIssue: _.bind(this.isFullScreenIssueVisible, this),
                searcherCollection: this.queryModule.getSearcherCollection()
            }));
        },

        disableLayoutSwitcher: function() {
            if (this.layoutSwitcher) {
                this.layoutSwitcher.disableLayoutSwitcher();
            }
        },

        enableLayoutSwitcher: function() {
            if (this.layoutSwitcher) {
                this.layoutSwitcher.enableLayoutSwitcher();
            }
        },


        registerLayoutSwitcher: function(layoutSwitcher) {
            this.layoutSwitcher = layoutSwitcher;
        },

        registerFilterModule: function(newFilterModule) {
            if (this.filterModule) {
                this.filterModule.off('filterRemoved');
                this.filterModule.off('filterSelected');
            }

            this.filterModule = newFilterModule;
            this.filterModule.on('filterRemoved', function(props) {
                var currentFilter = this.getFilter();
                if (currentFilter && props.filterId === currentFilter.getId()) {
                    this.resetToBlank();
                }
            }, this);

            this.filterModule.on('filterSelected', function(props) {
                this.resetToFilter(props.filterId);
            }, this);
        },

        registerSearch: function(search) {
            this.search = search;
            this.searchResults = this.search.getResults();
            this.searchResults.on("change:resultsId", this._handleSearchResultsChange, this);
            this.searchResults.onStartIndexChange(this._handleSearchResultsChange, this);
            this.searchResults.onSelectedIssueChange(this._handleSearchResultsChange, this);

            var columnConfig = this.columnConfig;

            //TODO This event must be fired before searchResults.on*Change events in order to work
            //Make sure that is a design feature and not a coincidence
            this.on("change:filter", function() {
                //When switch to another filter, clear the columns
                columnConfig.clearFilterConfiguration();
            });

            this.searchResults.onColumnsChange(function(searchResults) {
                var configName = searchResults.getColumnConfig();
                if (configName) { //There is no columnConfig on empty search
                    columnConfig.syncColumns(configName, searchResults.getColumns());
                }
            });

            this.searchResults.onColumnConfigChange(function(searchResults) {
                var configName = searchResults.getColumnConfig();
                if (configName) { //There is no columnConfig on empty search
                    columnConfig.setCurrentColumnConfig(configName);
                    //When the columnConfig changes, always set the columns
                    columnConfig.syncColumns(configName, searchResults.getColumns());
                }
            });

            columnConfig.onColumnsSync(function(columnConfigName) {
                search.stableUpdate({
                    columnConfig: columnConfigName
                });
            });

            this.searchResults.onSelectedIssueChange(_.bind(function(issue) {
                if (!issue.hasIssue()) {
                    JIRA.Issues.Application.execute("issueEditor:removeIssueMetadata");
                }
            }, this));
        },

        _handleSearchResultsChange: function(model, options) {
            options = _.defaults({}, options, {reason: 'search-results-change'});
            JIRA.Issues.Application.execute('navigation:navigate', this.searchResults.getState(), options);
        },

        registerSearchHeaderModule: function(searchHeaderModule) {
            this.searchHeaderModule = searchHeaderModule;
        },

        registerFullScreenIssue: function(fullScreenIssue) {
            this.fullScreenIssue = fullScreenIssue;
            this.fullScreenIssue.bindIssueHidden(function() {
                JIRA.Issues.Application.execute("issueEditor:dismiss");

                this.updateWindowTitle(this.getFilter());
                JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [this.searchContainer, JIRA.CONTENT_ADDED_REASON.returnToSearch]);
            }, this);
        },

        /**
         * @param {element} options.issueContainer The element in which issues are to be rendered.
         * @param {element} options.searchContainer The element in which search results are to be rendered.
         */
        registerViewContainers: function(options) {
            this.issueContainer = options.issueContainer;
            this.searchContainer = options.searchContainer;
        },

        prevIssue: function() {
            if (!this.standalone && this.getCurrentLayoutKey() === "split-view") {
                require('jira/issues/views/details/metrics').start();
            }

            if (this._overlayIsVisible()) {
                return false;
            }
            if (JIRA.Issues.Application.request("issueEditor:canDismissComment") && !this.standalone) {
                this.getCurrentLayout().prevIssue();
                return true;
            }

            return false;
        },

        nextIssue: function() {
            if (!this.standalone && this.getCurrentLayoutKey() === "split-view") {
                require('jira/issues/views/details/metrics').start();
            }

            if (this._overlayIsVisible()) {
                return false;
            }
            if (JIRA.Issues.Application.request("issueEditor:canDismissComment") && !this.standalone) {
                this.getCurrentLayout().nextIssue();
                return true;
            }

            return false;
        },

        /**
         * Is there an issue currently being loaded
         * @return Boolean
         */
        isCurrentlyLoadingIssue: function() {
            if (this.fullScreenIssue.isVisible()) {
                return this.fullScreenIssue.isLoading();
            } else {
                return this.getCurrentLayout().isLoading();
            }

        },

        _overlayIsVisible: function() {
            return AJS.$(".aui-blanket").filter(":visible").length > 0;
        },

        /**
         * Retrieve the ID of the selected issue.
         * <p/>
         * If issue search is visible, the ID of the currently highlighted issue is
         * returned; if we're viewing an issue, its ID is returned.
         *
         * @param {AJS.Dialog} [dialog] The dialog requesting this information.
         * @return {number} The ID of the currently selected issue.
         */
        getEffectiveIssueId: function() {
            return this.getEffectiveIssue().getId();
        },

        /**
         * Update the UI in response to an issue update.
         *
         * @param {object} issueUpdate An issue update object (see <tt>JIRA.Issues.Utils.getUpdateCommandForDialog</tt>).
         * @return {jQuery.Deferred} A deferred that is resolved when the refresh completes.
         */
        updateIssue: function(issueUpdate) {
            var isDelete = issueUpdate.action === JIRA.Issues.Actions.DELETE;
            var isFullScreen = this.fullScreenIssue.isVisible();

            if (isDelete) {
                return this._deleteIssue(issueUpdate);
            } else if (isFullScreen) {
                return this.fullScreenIssue.updateIssue(issueUpdate).done(_.bind(function() {
                    // If it's not a standalone issue, then we also need to update the search results.
                    //
                    // Things break if these requests are made in parallel, so force them to be serial.
                    if (!this.standalone) {
                        this.searchResults.updateIssue(issueUpdate, {
                            showMessage: false,
                            filter: this.getFilter()
                        });
                    }
                }, this));
            } else {
                return this.searchResults.updateIssue(issueUpdate, {filter: this.getFilter()});
            }
        },

        /**
         * Update the UI in response to issue deletion.
         *
         * @param {object} issueUpdate An issue update object (see <tt>JIRA.Issues.Utils.getUpdateCommandForDialog</tt>).
         * @return {jQuery.Deferred} A deferred that is resolved when the update completes.
         * @private
         */
        _deleteIssue: function(issueUpdate) {
            var isFullScreen = this.fullScreenIssue.isVisible();
            var isVisibleIssue = issueUpdate.key === JIRA.Issues.Application.request("issueEditor:getIssueKey");

            if (!isFullScreen) {
                return this.searchResults.updateIssue(issueUpdate);
            } else if (!isVisibleIssue) {
                return this.fullScreenIssue.updateIssue(issueUpdate);
            } else if (this.standalone) {
                this.resetToBlank();
                JIRA.Issues.showNotification(issueUpdate.message, issueUpdate.key);
                return new jQuery.Deferred().resolve().promise();
            } else {
                this.returnToSearch();
                return this.searchResults.updateIssue(issueUpdate);
            }
        },

        /**
         * Retrieve the key of the selected issue.
         * <p/>
         * If issue search is visible, the key of the currently highlighted issue is
         * returned; if we're viewing an issue, its key is returned.
         *
         * @return {number} The key of the currently selected issue.
         */
        getEffectiveIssueKey: function() {
            return this.getEffectiveIssue().getKey();
        },

        getEffectiveIssue: function() {
            var hasHighlightedIssue = this.searchResults.hasHighlightedIssue();
            var hasSelectedIssue = this.searchResults.hasSelectedIssue();
            var issueModuleIssue;

            issueModuleIssue = new JIRA.Issues.SimpleIssue({
                id: JIRA.Issues.Application.request("issueEditor:getIssueId"),
                key: JIRA.Issues.Application.request("issueEditor:getIssueKey")
            });

            if (this.standalone) {
                return issueModuleIssue;
            } else if (hasSelectedIssue) {
                return this.searchResults.getSelectedIssue();
            } else if (hasHighlightedIssue) {
                return this.searchResults.getHighlightedIssue();
            } else {
                return issueModuleIssue;
            }
        },

        isHighlightedIssueAccessible: function() {
            return this.search.getResults().isHighlightedIssueAccessible();
        },

        /**
         * Show issue search and change the URL to match model state.
         * <p/>
         * If returning from a stand-alone issue, reset to a blank search.
         */
        returnToSearch: function() {
            if (this.standalone) {
                this.resetToBlank();
                JIRA.trace("jira.returned.to.search");
            } else if (this.fullScreenIssue.isVisible()) {
                require('jira/issues/navigator/metrics').notifyIssueNavList();

                this.searchResults.unselectIssue();
                JIRA.Issues.Application.execute("issueEditor:beforeHide");
                // TODO: defensive check, incase issue-nav-components is a lower version than expected. Can remove after
                // soaking for bit on ondemand.
                if (this.queryModule.refreshLayout) {
                    this.queryModule.refreshLayout();
                }
            } else {
                JIRA.trace("jira.returned.to.search");
            }
            jQuery.event.trigger("updateOffsets.popout");
        },

        toggleFilterPanel: function() {
            return this.filterModule.toggleFilterPanel();
        },

        issueTableSortRequested: function(jql, startIndex) {
            this.update({jql: jql, startIndex: startIndex});
        },

        issueTableSearchError: function(response) {
            if (response.status !== 0) {
                // if we haven't aborted the request
                this.filterModule.filtersComponent.markFilterHeaderAsInvalid();
                var errors;
                try {
                    errors = JSON.parse(response.responseText);
                } catch (error) {
                    errors = {errorMessages: ["Error occurred communicating with the server. Please reload the page and try again."]};
                }
                this.queryModule.onSearchError(errors);
            }
        },

        issueTableSearchSuccess: function(data) {
            this.update({
                startIndex: data.startIndex
            });
            this.queryModule.onSearchSuccess(data.warnings);
        },

        issueTableStableUpdate: function(startIndex) {
            this.update({startIndex: startIndex});
        },

        /**
         * Prompt the user to confirm navigation if there are any dirty forms.
         *
         * @param {object} [options]
         * @param {function} [options.confirm=window.confirm] Show a confirmation dialog.
         * @param {boolean} [options.ignoreDirtiness=false] Whether to ignore dirty forms.
         * @return {boolean} whether the user confirmed navigation.
         */
        confirmNavigation: function(options) {
            options = _.defaults({}, options, {
                // Why can't we use bind or apply, I hear you ask? IE8, that's why.
                confirm: function(message) {
                    /*eslint-disable no-alert*/
                    return window.confirm(message);
                    /*eslint-enable no-alert*/
                },
                ignoreDirtiness: false
            });

            var message = JIRA.DirtyForm.getDirtyWarning() || JIRA.Issue.getDirtyCommentWarning();
            return !!options.ignoreDirtiness || message === undefined || options.confirm(message);
        },

        /**
         * @return {boolean} whether a full screen issue is visible.
         */
        isFullScreenIssueVisible: function() {
            return this.fullScreenIssue && this.fullScreenIssue.isVisible();
        },

        /**
         * @returns {boolean} whether the current layout is the Split View.
         */
        isSplitViewLayout: function() {
            return this.getCurrentLayoutKey() === "split-view";
        },

        /**
         * @returns {boolean} whether the current layout is the List View.
         */
        isListViewLayout: function() {
            return this.getCurrentLayoutKey() === "list-view";
        },

        isIssueVisible: function() {
            var layoutKey = JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey();

            if (this.isFullScreenIssueVisible()) {
                return true;
            } else if (layoutKey === "list-view") {
                return this.fullScreenIssue.isVisible();
            } else if (layoutKey === "split-view") {
                // Issue is always visible in split view AS LONG AS there are results
                return this.search.getResults().hasIssues();
            }
            return false;
        },

        queryModuleSearchRequested: function(jql) {
            this.update({
                jql: jql,
                startIndex: 0,
                selectedIssueKey: null,
                searchId: _.uniqueId()
            });
        },

        filterModuleSaved: function(filterModel) {
            this.reset({filter: filterModel.getId(), filterJql: filterModel.getJql()});
        },

        discardFilterChanges: function() {
            this.update({
                jql: null,
                selectedIssueKey: null
            }, true);
        },

        getState: function() {
            var filter = this.getFilter();

            var state = {
                filter: filter && filter.getId(),
                filterJql: filter && filter.getJql(),
                jql: this.getJql()
            };

            if (this.standalone) {
                state.selectedIssueKey = JIRA.Issues.Application.request("issueEditor:getIssueKey");
            } else {
                _.extend(state, this.search.getResults().getState());
            }

            return state;
        },

        _doSearch: function(options) {
            options = options || {};
            var searchOptions = {};
            var searchPromise;
            var filter = this.getFilter();
            searchOptions.startIndex = options.startIndex;
            if (filter) {
                searchOptions.filterId = filter.getId();
            }

            if (options.columnConfig) {
                searchOptions.columnConfig = options.columnConfig;
            }

            searchOptions.jql = this.getEffectiveJql();
            searchPromise = this.issueSearchManager.search(searchOptions);

            searchPromise.done(_.bind(function(results) {
                if (this.fullScreenIssue.isVisible() && !AJS.Meta.get('serverRenderedViewIssue')) {
                    JIRA.Issues.Application.execute("issueEditor:beforeHide");
                }
                this.searchResults.resetFromSearch(_.extend(options, results.issueTable));
                this.queryModule.onSearchSuccess(results.warnings);
                jQuery.event.trigger("updateOffsets.popout");
            }, this)).fail(_.bind(function(xhr) {
                if (xhr.statusText !== "abort") {
                    if (xhr.status === 400 && options.selectedIssueKey) {
                        this.reset({selectedIssueKey: options.selectedIssueKey}, {replace: true});
                    } else {
                        this.searchResults.resetFromSearch(_.extend(_.pick(options, "selectedIssueKey"), this.searchResults.defaults));
                        this.issueTableSearchError(xhr);
                    }
                }
            }, this));

            return searchPromise;
        },

        updateWindowTitle: function(model) {
            if (this.isFullScreenIssueVisible()) {
                return;
            }

            var filter = model;
            var navigatorTitle = AJS.format('{0} - {1}', "Issue Navigator", JIRA.Settings.ApplicationTitle.get());

            if (filter && filter.getIsValid()) {
                document.title = "[" + filter.getName() + "] " + navigatorTitle;
            } else {
                document.title = navigatorTitle;
            }
        },

        _applyState: function(state, isReset, options) {
            options = options || {};
            var prevState = this.toJSON();
            this.set(_.extend({}, this.defaults(), _.pick(state, this.properties)));

            this.updateWindowTitle(this.getFilter());

            if (isReset) {
                var jql = (state.filter && state.jql == null) ? state.filter.getJql() : state.jql;
                this.queryModule.resetToQuery(jql, {focusQuery: options.isNewSearch}).always(_.bind(function() {
                    // Hide the query view for invalid filters.
                    this.queryModule.setVisible(!state.filter || state.filter.getIsValid());
                }, this));
            }

            var searchPromise;
            if (this.shouldPerformNewSearch(prevState, this.toJSON())) {
                searchPromise = this._doSearch(state);
            } else {
                searchPromise = new jQuery.Deferred().resolve();
                if (_.indexOf(['search-results-change', 'update-filter-jql', 'issuekey-changed'], options.reason) === -1) {
                    if ("selectedIssueKey" in state) {
                        this.searchResults.selectIssueByKey(state.selectedIssueKey);
                    }
                    // If an issue is selected, its position in the results determines the page and we can ignore startIndex.
                    if ("startIndex" in state && !state.selectedIssueKey) {
                        this.searchResults.goToPage(state.startIndex);
                    }
                }
            }

            this.trigger('searching', {searchPromise: searchPromise});

            //keep filterJql in the Navigation Module state
            if (state.filter && state.filter.getJql() !== state.filterJql) {
                JIRA.Issues.Application.execute('navigation:updateState', {
                    filterJql: state.filter.getJql()
                }, {replace: true, reason: 'update-filter-jql'});
            }
        },

        /**
         * Determines if we would need to perform a new (unstable) search if
         * <tt>SearchPageModule</tt> was to be updated with the given attributes.
         *
         * @return {boolean} whether we should perform a new search.
         */
        shouldPerformNewSearch: function(prevState, newState) {
            var prevFilterId = prevState.filter && prevState.filter.getId();
            var filterId = newState.filter && newState.filter.getId();
            var filterChanged = prevFilterId !== filterId;
            var jqlChanged = newState.jql !== prevState.jql;
            var searchIdChanged = newState.searchId !== prevState.searchId;
            return filterChanged || jqlChanged || searchIdChanged;
        },

        refreshSearch: function() {
            return this._doSearch(_.extend({}, this.getState(), {
                selectedIssueKey: undefined
            }));
        },

        onStateChanged: function(state, options) {
            options = _.defaults({}, options, { resetQuery: false, routerEvent: false });
            // we do not want to operate on provided state object internally, so let's make a copy
            var shallowStateCopy = _.clone(state);
            if (state.isStandaloneIssue()) {
                this.resetToStandaloneIssue(shallowStateCopy);
            } else if (options.routerEvent) { //special treatment for router events
                return this.applyState(shallowStateCopy, !this._isSearchStateEqual(shallowStateCopy), options);
            } else {
                return this.applyState(shallowStateCopy, options.resetQuery, options);
            }
        },

        /** @deprecated use JIRA.Issues.Application.execute("navigation:navigate") **/
        update: function(state, isReset, options) {
            JIRA.Issues.Application.execute("navigation:navigate", state, _.extend({}, options, {resetQuery: isReset}));
        },

        /** @deprecated use JIRA.Issues.Application.execute("navigation:navigate") **/
        reset: function(state, options) {
            state.searchId = _.uniqueId();
            JIRA.Issues.Application.execute("navigation:navigate", state, _.extend({}, options, {reset: true, resetQuery: true}));
        },

        _deactivateCurrentLayout: function() {
            var currentLayout = this.getCurrentLayout();
            if (currentLayout) {
                if (currentLayout.close) currentLayout.close();
                this.setCurrentLayout(null);
            }
        },

        resetToStandaloneIssue: function(state) {
            require('jira/issues/navigator/metrics').notifyIssueView();
            this._deactivateCurrentLayout();
            this.set(this.defaults());
            this.standalone = true;
            this.fullScreenIssue.show({
                key: state.selectedIssueKey,
                viewIssueQuery: state.viewIssueQuery
            });
        },

        applyState: function(state, isReset, options) {
            options = options || {};
            if (this.getFilter() instanceof JIRA.Components.Filters.Models.Filter && this.getFilter().getId() === state.filter) {
                state.filter = this.getFilter();
            }
            var filterRequest;
            var shouldFetchFilter = state.filter && !(state.filter instanceof JIRA.Components.Filters.Models.Filter);
            var systemFiltersRequest = this.initSystemFilters();

            if (JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey() === 'split-view') {
                if (options.fullPageLoad === true) {
                    require('jira/issues/views/details/metrics').startFromPageLoad();
                } else {
                    require('jira/issues/views/details/metrics').start();
                }
            } else if (JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey() === 'list-view') {
                if (state.selectedIssueKey) {
                    require('jira/issues/navigator/metrics').notifyIssueView();
                } else {
                    require('jira/issues/navigator/metrics').notifyIssueNavList();
                }
            }

            JIRA.Issues.Application.execute("issueEditor:abortPending");
            this.createLayout();

            if (shouldFetchFilter) {
                // Wait for the system filters request to finish as state.filter may refer to a system filter.
                filterRequest = new jQuery.Deferred();
                systemFiltersRequest.always(_.bind(function() {
                    this.filterModule.getFilterById(state.filter).always(function(filterModel) {
                        state.filter = filterModel;
                        filterRequest.resolve();
                    });
                }, this));
            }

            jQuery.when(filterRequest, systemFiltersRequest).always(_.bind(function() {
                this._applyState(state, isReset, options);
            }, this));
        },

        hasSelectedIssue: function() {
            return this.search.getResults().getSelectedIssue().getKey();
        },

        /**
         * Reset the application state to match a given filter.
         *
         * @param {number|JIRA.Components.Filters.Models.Filter} filter The (id of) the filter to reset to.
         */
        resetToFilter: function(filter) {
            //Selecting a filter should always attempt to use the filter columns by default
            //This will ensure request are being made with the specified behaviour above
            //Returning issue table request will contain the actual columns being used and
            //  the preference state will be updated accordingly

            this.reset({
                filter: filter,
                searchId: _.uniqueId()
            });

        },

        /**
         * Reset the query to jql=
         * A reset forces a new search to be performed even if there are no changes.
         */
        resetToBlank: function(options) {
            this.reset({jql: ""}, options);
        },

        /**
         * @return {boolean} whether the current search is dirty (a modified filter).
         */
        isDirty: function() {
            var filter = this.getFilter();
            return !!filter && filter.getJql() !== this.getEffectiveJql();
        },

        getSearchMode: function() {
            return this.queryModule.getSearchMode();
        },

        getActiveBasicModeSearchers: function() {
            return this.queryModule.getActiveBasicModeSearchers();
        },

        /**
         * Set the user's session search to a given filter.
         *
         * @param filterModel The filter.
         * @private
         */
        setSessionSearch: function(filterModel) {
            var DarkFeatures = require("jira/components/issueviewer/services/darkfeatures");
            var httpSessionEnabled = !DarkFeatures.HTTP_SESSIONS_DISABLED.enabled;

            if (httpSessionEnabled) {
                // We don't really care if this request fails; it just means that the
                // URL may unnecessarily include the JQL parameter.
                AJS.$.ajax({
                    data: {
                        filterId: filterModel.getId()
                    },
                    type: "PUT",
                    url: AJS.contextPath() + "/rest/issueNav/1/issueTable/sessionSearch/"
                });
            }

            var LatestSearchStore = require("jira/components/search/latestStorage");
            var search = {
                data: {
                    filter: filterModel.getId(),
                    jql: filterModel.getJql()
                }
            };
            LatestSearchStore.save(search);

        },

        openFocusShifter: function() {
            JIRA.Issues.FocusShifter.show();
        },

        /**
         * @param {Object} issueProps. Either id or key needs to be present.
         * @param issueProps.issueId
         * @param issueProps.issueKey
         */
        setAsInaccessible: function(issueProps) {
            this.issueTableModule.setAsInaccessible(issueProps);
        },

        /**
         * @param {Object|null} issueProps. If null/undefined, use currently selected issue.
         * @param issueProps.issueId
         * @param issueProps.issueKey
         */
        showInlineIssueLoadError: function() {
            var html = JIRA.Components.IssueViewer.Templates.Body.errorsLoading();
            JIRA.Messages.showErrorMsg(html, {closeable: true});
        },

        /**
         * In the case of no filter selected, simply gets the jql property.
         * When a filter is selected, will get the filter jql and any modifications.
         *
         * @return {string} the effective JQL.
         */
        getEffectiveJql: function() {
            var filter = this.getFilter();
            var jql = this.getJql();

            if (_.isString(jql)) {
                return jql;
            } else if (filter) {
                return filter.getJql() || "";
            } else {
                return "";
            }
        },

        /**
         * On standalone VI, system filters data will not be available on page load
         * Thus make calls to make sure it is loaded properly via ajax
         */
        initSystemFilters: function() {
            return this.filterModule.initSystemFilters();
        },

        addOwnerToSystemFilters: function(systemFilters) {
            var loggedInUser = AJS.Meta.get('remote-user');

            if (!loggedInUser) {
                return systemFilters;
            }

            var ownerDisplayName = AJS.Meta.get('remote-user-fullname');
            var avatarUrl = AJS.Meta.get('remote-user-avatar-url');

            return _.map(systemFilters, function(filter) {
                filter.ownerUserName = loggedInUser;
                filter.ownerDisplayName = ownerDisplayName;
                filter.avatarUrl = avatarUrl;
                return filter;
            });
        },

        handleLeft: function() {
            if (this._allowLeftRightNavigation()) {
                if (this.getCurrentLayout()) this.getCurrentLayout().handleLeft();
            }
        },

        handleRight: function() {
            if (this._allowLeftRightNavigation()) {
                if (this.getCurrentLayout()) this.getCurrentLayout().handleRight();
            }
        },

        handleUp: function() {
            if (!this._allowUpDownNavigation()) {
                return false;
            }

            // Allow arrow scrolling up if first issue is highlighted.
            if (this.searchResults.isFirstIssueHighlighted()) {
                return false;
            }

            return this.prevIssue();
        },

        handleDown: function() {
            if (!this._allowUpDownNavigation()) {
                return false;
            }

            return this.nextIssue();
        },

        _allowLeftRightNavigation: function() {
            return !AJS.keyboardShortcutsDisabled;
        },

        _allowUpDownNavigation: function() {
            if (AJS.keyboardShortcutsDisabled) {
                return false;
            }

            // Don't allow up/down navigation if dropdowns are open.
            if (AJS.InlineLayer.current || AJS.Dropdown.current || JIRA.Dialog.current || AJS.$(".aui-dropdown2:visible").length > 0) {
                return false;
            }

            return this.getCurrentLayout() && !this.getCurrentLayout().isIssueViewActive();
        },

        _isSearchStateEqual: function(state) {
            var searchParams = ["filter", "jql", "startIndex"];
            return _.isEqual(_.pick(state, searchParams), _.pick(this.getState(), searchParams));
        },

        /**
         * Remove all of the tipsies that are open.
         */
        removeOpenTipsies: JIRA.Issues.Tipsy.revalidate,

        getCurrentLayoutKey: function() {
            var currentLayout = this.getCurrentLayout();
            if (!currentLayout) return;


            var layoutDescriptions = this.getLayouts();
            var layoutDescription = _.find(layoutDescriptions, function(layoutDescription) {
                return currentLayout instanceof layoutDescription.View;
            });
            if (!layoutDescription) return;

            return layoutDescription.id;
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common-mess', location = 'content/js/search/IssueSearchManager.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.IssueSearchManager");

    /**
     * Handles the AJAX issue search requests, including both jql search and stable update.
     * For the very first search, this class will return the initial search data delivered with the page,
     * if available.
     *
     * Also keeps AsyncData of issueKeys within the search.
     */
    JIRA.Issues.IssueSearchManager = JIRA.Issues.BaseEvented.extend({
        namedEvents: [
            // Triggered before executing a search.
            "beforeSearch",

            // Triggered when a search request fails.
            "searchError"
        ],

        /**
         * @param {object} options
         * @param {object} options.initialIssueTableState The issue table's initial state.
         */
        initialize: function(options) {
            _.extend(this, options);
            this.issueKeys = new JIRA.Components.IssueViewer.Legacy.AsyncData();
        },

        /**
         * @return {boolean} whether the next search request will return the initial search without making an AJAX request.
         */
        hasInitialSearch: function() {
            return !!this.initialIssueTableState;
        },

        /**
         * Execute a new search, generating a new set of stable issue IDs.
         *
         * @param {object} data
         * @param {number} [data.filterId] The ID of the search filter.
         * @param {string} data.jql The search JQL.
         * @param {number} [data.startIndex=0] The index of the first result to return.
         * @param {boolean} [data.columnConfig] The request columns to be used. Either user, filter, system or explicit.
         * @return {jQuery.Promise} a promise that is resolved when the search completes.
         */
        search: function(data) {
            var deferred;
            var traceKey;

            data = _.extend({}, data);

            if (_.isNumber(data.startIndex) === false) {
                data.startIndex = 0;
            }

            // We don't want to have more than one request in flight for results. This can cause unexpected results.
            if (this.activeResultsReq) {
                // If it is the same as the request we are currently waiting for we can just ignore.
                if (JSON.stringify(this.activeRequestData) === JSON.stringify(data)) {
                    return new jQuery.Deferred().reject().promise();
                } else {
                    // Otherwise we will abort and issue a new request.
                    this.activeResultsReq.abort();
                }
            }

            this.activeRequestData = data;
            this.triggerBeforeSearch();

            // Initial issue search state is included in the page to avoid making an AJAX request.
            if (this.hasInitialSearch()) {
                deferred = new jQuery.Deferred().resolve(this.initialIssueTableState);
                traceKey = "jira.search.finished.initial";
                this.initialIssueTableState = null;
                this.initialIssueIds = null;
            } else {
                deferred = this.activeResultsReq = this._doSearch(data);
                traceKey = "jira.search.finished.secondary";
            }

            deferred.always(_.bind(function() {
                this.activeResultsReq = null;
                this.activeRequestData = null;
                JIRA.trace(traceKey);
            }, this));

            deferred.done(_.bind(this._updateIssueKeysOnSearchSuccess, this));

            deferred.fail(_.bind(function() {
                this.issueKeys.reset();
                this.triggerSearchError();
                _.defer(JIRA.trace, "jira.search.finished");
            }, this));

            return deferred.pipe(function(data) {
                if (data.issueTable) {
                    // Only IssueSearchManager uses these.
                    delete data.issueTable.issueKeys;
                }

                return data;
            }).promise();
        },

        /**
         * Construct a request for issue table information.
         * <p/>
         * Fails fast if the given data is invalid (e.g. invalid filter ID) and
         * doesn't actually make an AJAX request; just returns a rejected deferred.
         *
         * @param data The data to use in the request.
         * @return {jQuery.Deferred} a deferred response.
         */
        _doSearch: function(data) {
            // If the filter ID is invalid, fail. We really should move this logic
            // into IssueTableResource, but that's a slightly more risky change.
            var isInteger = /^-?\d+$/;
            if (data.filterId && !isInteger.test(data.filterId)) {
                var response = {
                    status: 400,
                    responseText: JSON.stringify({
                        errors: ["Invalid filter id. Filter id must be a number."]
                    })
                };

                return new jQuery.Deferred().reject(response).promise();
            }

            return jQuery.ajax({
                type: "POST",
                url: AJS.contextPath() + "/rest/issueNav/1/issueTable",
                headers: JIRA.Issues.XsrfTokenHeader,
                data: _.extend(data, {
                    layoutKey: JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey()
                })
            });
        },

        _updateIssueKeysOnSearchSuccess: function(searchResult) {
            var issueKeyMapping;
            var issueIds = searchResult.issueTable.issueIds;
            var issueKeys = searchResult.issueTable.issueKeys;

            if (issueIds && issueKeys) {
                issueKeyMapping = {};
                _.each(issueIds, function(issueId, index) {
                    issueKeyMapping[issueId] = {
                        value: issueKeys[index],
                        error: false
                    };
                });
                this.issueKeys.reset(issueKeyMapping);
            } else {
                // Stable search is off, resort to extracting keys for current page only from the table html
                issueKeyMapping = JIRA.Issues.IssueSearchManager._extractIssueKeysFromTable(searchResult.issueTable.table);
                this.issueKeys.reset(issueKeyMapping);
            }
        },

        /**
         * Retrieve issue table information for the issues matching the given IDs.
         *
         * @param {number[]} ids The issue IDs.
         * @return {jQuery.Deferred} A deferred that is resolved when the request completes.
         */
        getRowsForIds: function(ids, searchOptions) {
            if (!ids.length) {
                // Don't need to make a request, respond with an empty results set
                return new jQuery.Deferred().resolve({}).promise();
            }

            var request = jQuery.ajax({
                data: _.extend({
                    id: ids,
                    layoutKey: JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey()
                }, searchOptions),
                type: "POST",
                headers: JIRA.Issues.XsrfTokenHeader,
                url: AJS.contextPath() + "/rest/issueNav/1/issueTable/stable"
            });

            request.fail(_.bind(function() {
                this.triggerSearchError();
            }, this));

            return request.pipe(function(data) {
                return data.issueTable;
            }).done(_.bind(function(data) {
                this.issueKeys.setMultiple(JIRA.Issues.IssueSearchManager._extractIssueKeysFromTable(data.table, ids));
                _.defer(JIRA.trace, "jira.search.finished");
            }, this)).promise();
        },

        setAsInaccessible: function(id) {
            return this.issueKeys.setError(id);
        }

    }, {

        // Returns id->key map information from issue table html.
        // @param issueTableHtml - table html for the current page
        // @param issueIds - optional. If supplied, inaccessible rows will have an entry in the map (mapping to null).
        _extractIssueKeysFromTable: function(issueTableHtml, issueIds) {
            var map = {};
            AJS.$(issueTableHtml).find('.issuerow').each(function(i) {
                var $row = AJS.$(this);
                var id = issueIds ? issueIds[i] : $row.attr('rel');
                var key = $row.data('issuekey') || null;
                if (id) {
                    map[id] = key ? {value: key, error: false} : {error: true};
                }
            });
            return map;
        }

    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common-mess', location = 'content/js/search/SearchResults.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Issues.SearchResults");

    JIRA.Issues.SearchResults = JIRA.Issues.BaseModel.extend({

        defaults: {
            issueIds: [],
            selectedIssue: new JIRA.Issues.SimpleIssue(),
            highlightedIssue: new JIRA.Issues.SimpleIssue(),
            total: 0
        },

        properties: [
            "columnSortJql",
            "highlightedIssue",
            "issueIds", // only present in stable search
            "issueIdsForPage",
            "jiraHasIssues",
            "pageSize",
            "resultsId",
            "selectedIssue",
            "startIndex",
            "sortBy",
            "columns",
            "table",
            "total",
            "initialPayload",
            "columnConfig"
        ],

        namedEvents: [
            "prevIssueSelected",
            "nextIssueSelected",

            "issueUpdated",
            "issueDeleted",

            "issueDoesNotExist",

            "stableUpdate"
        ],

        initialize: function(attr, options) {
            JIRA.Issues.ModelUtils.makeTransactional(this, "resetFromSearch", "selectNextIssue", "selectPrevIssue");
            this.issueUpdateCallbacks = [];
            this._issueSearchManager = options.issueSearchManager;
            this._initialSelectedIssue = options.initialSelectedIssue;
            this._columnConfig = options.columnConfig;
        },

        /**
         * Returns the startIndex for a given page.s
         *
         * @param {Number} page the page number (0 based)
         * @return {number} the startIndex
         */
        getStartIndexForPage: function(page) {
            return page * this.getPageSize();
        },

        hasIssue: function(id) {
            return _.indexOf(this.getIssueIds(), id) !== -1;
        },

        getPager: function() {
            if (this.hasIssue(this.getSelectedIssue().getId())) {
                var issueIds = this.getIssueIds();
                var selectedId = this.getSelectedIssue().getId();
                var position = _.indexOf(issueIds, selectedId);
                var resultCount = this.getTotal();
                var stableSearchLimit = issueIds.length;
                var pager = {
                    position: JIRA.NumberFormatter.format(position + 1),
                    resultCount: JIRA.NumberFormatter.format(resultCount)
                };
                if (position > 0) {
                    var prevIssueId = this._getPrevIssueId(selectedId);
                    if (prevIssueId) {
                        pager.previousIssue = {
                            id: prevIssueId,
                            key: this._getIssueKeyForId(prevIssueId)
                        };
                    }
                }
                if (position < resultCount - 1 && position < stableSearchLimit - 1) {
                    var nextIssueId = this._getNextIssueId(selectedId);
                    if (nextIssueId) {
                        pager.nextIssue = {
                            id: nextIssueId,
                            key: this._getIssueKeyForId(nextIssueId)
                        };
                    }
                }
                return pager;
            }
        },

        /**
         * Returns the number of pages in this SearchResults.
         *
         * @return {Number} the number of pages
         */
        getNumberOfPages: function() {
            return this._getPageNumberForStartIndex(this.getDisplayableTotal() - 1);
        },

        /**
         * Remove an issue from the search results.
         * <p/>
         * The highlighted issue is updated accordingly.
         *
         * @param {number} id The ID of the issue to remove.
         */
        removeIssue: function(id) {
            id = parseInt(id, 10);

            var isFirstIssue = this.getIssueIds()[0] === id;
            var isHighlighted = this.getHighlightedIssue().getId() === id;
            var isLastIssue = _.last(this.getIssueIds()) === id;

            if (isHighlighted) {
                if (!isLastIssue) {
                    this.highlightNextIssue({replace: true});
                } else if (!isFirstIssue) {
                    this.highlightPrevIssue({replace: true});
                }
            }

            this.setIssueIds(_.without(this.getIssueIds(), id));
            this.setTotal(this.getTotal() - 1);
            this.triggerIssueDeleted({
                id: id,
                key: this._getIssueKeyForId(id)
            });
        },

        isFirstIssueHighlighted: function() {
            if (!this.hasHighlightedIssue()) {
                return false;
            }

            return this.getHighlightedIssue().getId() === this.getIssueIds()[0];
        },

        updateIssueById: function(issueUpdateObject, options) {
            return this.updateIssue(issueUpdateObject, options);
        },

        /**
         * Update the search results in response to an issue update.
         *
         * @param {object} issueUpdate An issue update object (see <tt>JIRA.Issues.Utils.getUpdateCommandForDialog</tt>).
         * @param {object} [options]
         * @param {boolean} [options.showMessage=true] Whether a success message should be shown.
         * @param {JIRA.Components.Filters.Models.Filter} [options.filter=null] Filter, in which context issues should be shown.
         * @return {jQuery.Deferred} A deferred that is resolved when the update completes.
         */
        updateIssue: function(issueUpdate, options) {
            var isDelete = issueUpdate.action === JIRA.Issues.Actions.DELETE;
            var issueID = issueUpdate.id;
            var promises = [];

            options = _.defaults({}, options, {
                showMessage: true,
                filter: null
            });

            if (isDelete) {
                this.removeIssue(issueID);
                if (options.showMessage) this._notifyOfIssueUpdate(issueUpdate);
                return new jQuery.Deferred().resolve().promise();
            } else {
                return this.getResultForId(issueID, options.filter).done(_.bind(function(entity) {
                    _.each(this.issueUpdateCallbacks, function(callback) {
                        var result = callback.handler.call(callback.ctx || window, issueID, entity, issueUpdate);
                        if (result && result.promise) {
                            promises.push(result);
                        }
                    });

                    $.when(promises).done(_.bind(function() {
                        if (options.showMessage) this._notifyOfIssueUpdate(issueUpdate);
                    }, this));
                }, this));
            }
        },

        _notifyOfIssueUpdate: function(issueUpdate) {
            if (issueUpdate.message) JIRA.Issues.showNotification(issueUpdate.message, issueUpdate.key);
            JIRA.trace("jira.search.stable.update");
        },

        getResultForId: function(id, filter) {
            var options = {columnConfig: this._columnConfig.columnPickerModel.getColumnConfig()};

            //if used filter is system filter we don't want to get results based off him
            if (filter && !filter.getIsSystem()) {
                options = _.extend({filterId: filter.getId()}, options);
            }
            return this._issueSearchManager.getRowsForIds([id], options);
        },

        isHighlightedIssueAccessible: function() {
            if (!this.hasHighlightedIssue()) {
                return null;
            }
            return !this._issueSearchManager.issueKeys.hasError(this.getHighlightedIssue().getId());
        },

        getDisplayableTotal: function() {
            return this.getIssueIds().length;
        },

        selectIssueByKey: function(key, options) {
            if (!key) {
                this.unselectIssue();
                return;
            }

            var id = this._getIssueIdForKey(key);

            if (!id || id === -1) {
                this._unhighlightIssue();

                this.getSelectedIssue().set({
                    id: -1,
                    key: key
                });

                this.triggerIssueDoesNotExist();
            } else {
                this._selectExistingIssueById(id, options);
            }
        },

        _unhighlightIssue: function() {
            this.getHighlightedIssue().set({
                id: null,
                key: null
            });
        },

        selectFirstInPage: function(options) {
            this.selectIssueById(this.getIssueIds()[this.getStartIndex()], options);
        },

        getPrevPageStartIndex: function() {
            var target = (this.getStartIndex() || 0) - this.getPageSize();
            return (target < 0) ? null : target;
        },

        getNextPageStartIndex: function() {
            var target = this.getPositionOfLastIssueInPage();
            return (target >= this.getDisplayableTotal()) ? null : target;
        },

        /**
         * Returns the position in the search results of the last issue on the current page (e.g. if the page size is
         * 5 and we are on the first page this returns 5).
         *
         * @return {Number}
         */
        getPositionOfLastIssueInPage: function() {
            var startIndex = this.getStartIndex();
            var pageSize = this._pageSize();

            return Math.min(startIndex + pageSize, this.getDisplayableTotal());
        },

        highlightFirstInPage: function() {
            this.highlightIssueById(this.getIssueIds()[this.getStartIndex()]);
        },

        selectIssueById: function(id, options) {
            if (!id) {
                this.unselectIssue();
            } else {
                this._selectExistingIssueById(id, options);
            }
        },

        _selectExistingIssueById: function(id, options) {
            if (id !== this.getSelectedIssue().getId() && JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                id = id ? parseInt(id, 10) : null;
                this.getSelectedIssue().set({
                    id: id,
                    key: id ? this._getIssueKeyForId(id) : null
                }, options);
                this.highlightIssueById(id);
            }
        },

        /**
         * Sets the issue with the given id as the highlighted issue and updates the startIndex accordingly (such that
         * the startIndex is equal to the offset of the first issue of the page that contains the highlighted issue).
         *
         * @param {number} id The ID of the issue to highlight.
         * @param {object} [options]
         * @param {boolean} [options.replace=false] Whether highlighting the issue should be a "replace" operation.
         */
        highlightIssueById: function(id, options) {
            options = _.defaults({}, options, {
                replace: false
            });

            if (id && id !== this.getHighlightedIssue().getId()) {
                id = id ? parseInt(id, 10) : null;
                this.getHighlightedIssue().set({
                    id: id,
                    key: id ? this._getIssueKeyForId(id) : null
                }, options);
                if (id) {
                    this.setStartIndex(this._getStartIndexForIssueId(id));
                }
            }
        },

        getState: function() {
            return {
                selectedIssueKey: this.getSelectedIssue().getKey(),
                startIndex: this.getStartIndex()
            };
        },

        /**
         * Resets this SearchResults using new search data. This effectively wipes any existing state and replaces it
         * with the passed-in state.
         *
         * Calling this method generates a new <code>resultsId</code>, which triggers a "newPayload" event.
         *
         * @param state
         */
        resetFromSearch: function(state) {
            state.resultsId = _.uniqueId();
            this.getSelectedIssue().set({id: null, key: null});
            this.set({sortBy: null});
            this.set("startIndex", state.startIndex, {silent: true});
            this.set(_.pick(state, this.properties));
            if (typeof state.selectedIssueKey === 'string') {
                this.selectIssueByKey(state.selectedIssueKey);
            } else {
                if (this.hasIssues()) {
                    this.highlightFirstInPage();
                } else {
                    this.getHighlightedIssue().set({id: null, key: null});
                }
            }
        },

        hasIssues: function() {
            return !!this.getIssueIds().length;
        },

        isIssueOnPage: function(id) {
            return _.indexOf(this.getPageIssueIds(), id) !== -1;
        },

        isFirstIssueSelected: function() {
            if (this.hasIssue(this.getSelectedIssue().getId())) {
                var issueIds = this.getIssueIds();
                var selectedId = this.getSelectedIssue().getId();
                var position = _.indexOf(issueIds, selectedId);
                return position === 0;
            }

            return false;
        },

        /**
         * @param options
         * @param options.filterId
         * @param options.columnConfig
         */
        getResultsForPage: function(options) {
            _.extend(options, {columnConfig: this._columnConfig.columnPickerModel.getColumnConfig()});

            if (this.getTable()) {
                var result = this.getTable();
                this.setTable(null, {silent: true}); //do not trigger a new search
                _.defer(function() {
                    JIRA.trace("jira.search.finished");
                });
                return new $.Deferred().resolve(result).promise();
            }
            return this.getResultsForIds(this.getPageIssueIds(), options);
        },

        /**
         * @param ids
         * @param options
         * @param options.filterId
         * @param options.columnConfig
         */
        getResultsForIds: function(ids, options) {
            var instance = this;
            var deferred = new $.Deferred();
            this._issueSearchManager.getRowsForIds(ids, options)
                .done(function(result) {
                    //HACK - The REST endpoint for splitview always returns columnConfig="user", which is very
                    //wrong. We can update the columnConfig only for listview, as that REST endpoint is the one
                    //returning the good values.
                    var isSplitViewResponse = _.isArray(result.table);
                    if (!isSplitViewResponse) {
                        instance.setColumnConfig(result.columnConfig);
                        instance.setColumns(result.columns);
                        instance.setColumnSortJql(result.columnSortJql);
                    }
                    deferred.resolve(result.table);
                }).fail(deferred.reject)
                .always(function() {
                    _.defer(function() {
                        JIRA.trace("jira.search.finished");
                    });
                });
            return deferred;
        },

        applyState: function(state) {
            this.set(_.pick(state, this.properties));
        },

        unselectIssue: function(options) {
            var selectedIssue = this.getSelectedIssue();
            if (selectedIssue.getId() && JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                selectedIssue.set({
                    id: null,
                    key: null
                }, options);
            }
        },

        hasSelectedIssue: function() {
            return !!this.getSelectedIssue().getId();
        },

        hasHighlightedIssue: function() {
            return !!this.getHighlightedIssue().getId();
        },

        getPageIssueIds: function() {
            var startIndex = this.getStartIndex();
            var pageSize = this._pageSize();

            var issueIds = this.getIssueIds();
            return issueIds ? issueIds.slice(startIndex, Math.min(startIndex + pageSize, issueIds.length)) : [];
        },

        getPageIssues: function() {
            // return ids and keys
            return _.map(this.getPageIssueIds(), function(id) {
                return {id: id, key: this._getIssueKeyForId(id)};
            }, this);
        },

        getPageNumber: function() {
            return Math.floor(this.getStartIndex() / this._pageSize());
        },

        /**
         * Returns the position of the given issue id on the page (0-based).
         *
         * @param issueId
         * @return {number}
         */
        getPositionOfIssueInPage: function(issueId) {
            return this.getPositionOfIssueInSearchResults(issueId) % this._pageSize();
        },

        /**
         * Returns the position of the given issue in the stable search results (0-based).
         *
         * @param issueId
         * @return {*}
         */
        getPositionOfIssueInSearchResults: function(issueId) {
            return _.indexOf(this.getIssueIds(), issueId);
        },

        /**
         * (Async) Selects the next issue in the search results if possible. Clients can register a callback using
         * onSelectedIssueChange() to subscribe to selected issue change events, or alternatively use the promise
         * that this method returns.
         *
         * @return {jQuery.Promise} a promise with the id of the selected issue if successful
         */
        selectNextIssue: function(options) {
            if (!this.hasSelectedIssue()) {
                return new $.Deferred().reject().promise();
            }

            var nextId = this._getNextIssueId(this.getSelectedIssue().getId());
            this._triggerNextIssueSelectedEvent(nextId);

            return this._selectIssue(nextId, options);
        },

        /**
         * (Async) Selects the previous issue in the search results if possible. Clients can register a callback using
         * onSelectedIssueChange() to subscribe to selected issue change events, or alternatively use the promise
         * that this method returns.
         *
         * @return {jQuery.Promise} a promise with the id of the selected issue if successful
         */
        selectPrevIssue: function(options) {
            if (!this.hasSelectedIssue()) {
                return new $.Deferred().reject().promise();
            }

            var prevId = this._getPrevIssueId(this.getSelectedIssue().getId());
            this._triggerPrevIssueSelectedEvent(prevId);

            return this._selectIssue(prevId, options);
        },

        _selectIssue: function(issueId, options) {
            this.selectIssueById(issueId, options);
            return new $.Deferred().resolve(issueId).promise();
        },

        /**
         * (Async) Highlights the previous issue in the search results if possible. Clients can register a callback using
         * onHighlightedIssueChange() to subscribe to selected issue highlighted events, or alternatively use the
         * promise that this method returns.
         *
         * @param {object} [options]
         * @param {boolean} [options.replace=false] Whether highlighting the issue should be a "replace" operation.
         * @return {jQuery.Promise} a promise with the id of the highlighted issue if successful
         */
        highlightNextIssue: function(options) {
            if (!this.hasHighlightedIssue()) {
                return new $.Deferred().reject().promise();
            }

            // this is always synchronous in stable search but it is async when we are going across page boundaries
            // in dynamic search (we need to get the set of issues in the next page at this point)
            var nextId = this._getNextIssueId(this.getHighlightedIssue().getId());
            this.highlightIssueById(nextId, options);

            return new $.Deferred().resolve(nextId).promise();
        },

        /**
         * (Async) Highlights the next issue in the search results if possible. Clients can register a callback using
         * onHighlightedIssueChange() to subscribe to selected issue highlighted events, or alternatively use the
         * promise that this method returns.
         *
         * @param {object} [options]
         * @param {boolean} [options.replace=false] Whether highlighting the issue should be a "replace" operation.
         * @return {jQuery.Promise} a promise with the id of the highlighted issue if successful
         */
        highlightPrevIssue: function(options) {
            if (!this.hasHighlightedIssue()) {
                return new $.Deferred().reject().promise();
            }

            // this is always synchronous in stable search but it is async when we are going across page boundaries
            // in dynamic search (we need to get the set of issues in the next page at this point)
            var prevId = this._getPrevIssueId(this.getHighlightedIssue().getId());
            this.highlightIssueById(prevId, options);

            return new $.Deferred().resolve(prevId).promise();
        },

        /**
         * Show the page starting at <tt>startIndex</tt>.
         * <p/>
         * This method is asynchronous.
         *
         * @param {number} startIndex The index of the first issue on the page.
         * @param {object} [options]
         * @param {boolean} [options.replace=false] Whether showing the page should be a "replace" operation.
         * @return {jQuery.Deferred} A deferred that will be resolved with the ID of the newly highlighted issue.
         */
        goToPage: function(startIndex, options) {
            options = _.defaults({}, options, {
                replace: false
            });

            if (startIndex === null || startIndex === this.getStartIndex()) {
                return new $.Deferred().resolve().promise();
            }

            // Highlighting an issue updates the startIndex to ensure it is on the current page.
            var ID = this.getIssueIds()[startIndex];
            this.highlightIssueById(ID, options);

            return new $.Deferred().resolve(ID).promise();
        },

        onHighlightedIssueChange: function(callback, context) {
            this.getHighlightedIssue().on("change", callback, context);
        },

        offHighlightedIssueChange: function(callback, context) {
            this.getHighlightedIssue().off("change", callback, context);
        },

        onSelectedIssueChange: function(callback, context) {
            this.getSelectedIssue().on("change", callback, context);
        },

        offSelectedIssueChange: function(callback, context) {
            this.getSelectedIssue().off("change", callback, context);
        },

        onColumnConfigChange: function(callback, context) {
            this.on("change:columnConfig", callback, context);
        },

        offColumnConfigChange: function(callback, context) {
            this.off("change:columnConfig", callback, context);
        },

        onColumnsChange: function(callback, context) {
            this.on("change:columns", callback, context);
        },

        offColumnsChange: function(callback, context) {
            this.off("change:columns", callback, context);
        },

        onStartIndexChange: function(callback, context) {
            this.on("change:startIndex", callback, context);
        },

        onNewIssueIds: function(callback, context) {
            this.on("change:issueIds", callback, context);
        },

        offNewIssueIds: function(callback, context) {
            this.off("change:issueIds", callback, context);
        },

        offStartIndexChange: function(callback, context) {
            this.off("change:startIndex", callback, context);
        },

        onNewPayload: function(func, context) {
            this.on("change:resultsId", func, context);
        },

        offNewPayload: function(func, context) {
            this.off("change:resultsId", func, context);
        },

        onIssueUpdated: function(func, ctx) {
            this.issueUpdateCallbacks.push({
                handler: func,
                ctx: ctx
            });
        },

        offIssueUpdated: function(func) {
            var filteredCallbacks = [];
            this.issueUpdateCallbacks = _.each(this.issueUpdateCallbacks, function(callback) {
                if (callback.handler !== func) {
                    filteredCallbacks.push(callback);
                }
            });
            this.issueUpdateCallbacks = filteredCallbacks;
        },

        _getNextIssueId: function(id) {
            var issueIds = this.getIssueIds();
            return issueIds[Math.min(_.indexOf(issueIds, id) + 1, this.getDisplayableTotal() - 1)];
        },

        getNextIssueForId: function(id) {
            var nextId = this._getNextIssueId(id);
            return {id: nextId, key: this._getIssueKeyForId(nextId)};
        },

        getNextIssueForSelectedIssue: function() {
            return this.getNextIssueForId(this.getSelectedIssue().getId());
        },

        _getPrevIssueId: function(id) {
            var issueIds = this.getIssueIds();
            return issueIds[Math.max(0, _.indexOf(this.getIssueIds(), id) - 1)];
        },

        /**
         * Calculate the start index that should be used to show a particular issue.
         * <p/>
         * Returns 0 if the issue isn't present in the search results.
         *
         * @param {number} id The issue's ID.
         * @return {number} The start index.
         * @private
         */
        _getStartIndexForIssueId: function(id) {
            var issueIndex = _.indexOf(this.getIssueIds(), id);
            var pageSize = this._pageSize();

            return Math.max(0, Math.floor(issueIndex / pageSize) * pageSize);
        },

        _getIssueIdForKey: function(key) {
            // this only happens if the selected issue is not in the search results (i.e. when the user
            // navigates to the selected issue directly but has a search context).
            if (this._initialSelectedIssue && key === this._initialSelectedIssue.key) {
                return this._initialSelectedIssue.id;
            }

            return this._getIssueKeysToIds()[key];
        },

        _getIssueKeyForId: function(id) {
            // this only happens if the selected issue is not in the search results (i.e. when the user
            // navigates to the selected issue directly but has a search context).
            if (this._initialSelectedIssue && id === this._initialSelectedIssue.id) {
                return this._initialSelectedIssue.key;
            }

            return this._getIssueIdsToKeys()[id];
        },

        _getIssueIdsToKeys: function() {
            return this._issueSearchManager.issueKeys.getAllCached();
        },

        _getIssueKeysToIds: function() {
            var obj = {};
            var idsToKeys = this._issueSearchManager.issueKeys.getAllCached();
            _.each(idsToKeys, function(value, name) {
                obj[value] = name;
            });

            return obj;
        },

        /**
         * Returns a 0-based page number.
         *
         * @param startIndex the start index
         * @return {Number} a 0-based page number.
         * @private
         */
        _getPageNumberForStartIndex: function(startIndex) {
            return Math.floor(startIndex / this._pageSize());
        },

        /**
         * Returns the page size used for the search.
         *
         * @return {Number} the page size
         * @private
         */
        _pageSize: function() {
            return this.getPageSize();
        },

        _triggerPrevIssueSelectedEvent: function(prevId) {
            if (prevId !== this.getSelectedIssue().getId()) {
                var prevPrevId = this._getPrevIssueId(prevId);

                this.trigger("prevIssueSelected", {
                    prevIssue: {id: prevId, key: this._getIssueKeyForId(prevId)},
                    prevPrevIssue: {id: prevPrevId, key: this._getIssueKeyForId(prevPrevId)}
                });
            }
        },

        _triggerNextIssueSelectedEvent: function(nextId) {
            if (nextId !== this.getSelectedIssue().getId()) {
                var nextNextId = this._getNextIssueId(nextId);

                this.trigger("nextIssueSelected", {
                    nextIssue: {id: nextId, key: this._getIssueKeyForId(nextId)},
                    nextNextIssue: {id: nextNextId, key: this._getIssueKeyForId(nextNextId)}
                });
            }
        }
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common-mess', location = 'content/js/search/SearchModule.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.SearchModule");

    JIRA.Issues.SearchModule = JIRA.Issues.BaseEvented.extend({
        initialize: function(options) {
            this._issueSearchManager = options.issueSearchManager;
            this._searchPageModule = options.searchPageModule;
            this._searchResults = new JIRA.Issues.SearchResults(null, {
                issueSearchManager: this._issueSearchManager,
                initialSelectedIssue: options.initialSelectedIssue,
                columnConfig: this._searchPageModule.columnConfig
            });

            // TF-447 - Refactoring step to remove nested dependencies on SearchModule.
            JIRA.Issues.Application.reqres.setHandler("issueNav:currentSearchRequest", this.getCurrentSearchRequest, this);

            JIRA.Issues.Application.commands.setHandler("issueNav:refreshSearch", this.refresh, this);
        },

        /**
         * Sorts this search using the specified JQL or fieldId.
         *
         * @param {object} sortOptions
         * @param {string} sortOptions.fieldId
         * @param {string} sortOptions.jql
         */
        doSort: function(jql) {
            if (jql) {
                this._searchPageModule.update({
                    jql: jql,
                    startIndex: null,
                    selectedIssueKey: null
                }, true);
            }
        },

        getFilterId: function() {
            var filter = this._searchPageModule.getFilter();
            return filter && filter.getId();
        },

        getJql: function() {
            return this._searchPageModule.getJql();
        },

        getEffectiveJql: function() {
            return this._searchPageModule.getEffectiveJql();
        },

        getResults: function() {
            return this._searchResults;
        },

        getState: function() {
            return this._searchPageModule.getState();
        },

        getCurrentSearchRequest: function() {
            return {
                jql: this.getJql(),
                filterId: this.getFilterId()
            };
        },

        /**
         * @param {object} [state=this._searchPageModule.getState()] The state to inspect.
         * @return {boolean} Whether <tt>state</tt> describes a state where a stand alone issue is visible.
         */
        isStandAloneIssue: function(state) {
            state = state || this._searchPageModule.getState();
            return !!state.selectedIssueKey && !_.isString(state.jql) && !state.filter;
        },

        /**
         * Register a callback to be executed before a search is performed.
         *
         * @param {function} callback The callback to execute.
         * @param {object} context The context in which to execute.
         */
        onBeforeSearch: function(callback, context) {
            this._issueSearchManager.bindBeforeSearch(callback, context);
        },

        /**
         * Remove a before search callback.
         *
         * @param {function} callback The callback to remove.
         * @param {object} context The callback's context.
         */
        offBeforeSearch: function(callback, context) {
            this._issueSearchManager.unbindBeforeSearch(callback, context);
        },

        /**
         * Register a callback to be executed when a search fails.
         *
         * @param {function} callback The callback to execute.
         * @param {object} context The context in which to execute.
         */
        onSearchError: function(callback, context) {
            this._issueSearchManager.bindSearchError(callback, context);
        },

        /**
         * Remove a search error callback.
         *
         * @param {function} callback The callback to remove.
         * @param {object} context The callback's context.
         */
        offSearchError: function(callback, context) {
            this._issueSearchManager.unbindSearchError(callback, context);
        },

        refresh: function() {
            return this._searchPageModule.refreshSearch();
        },

        /**
         * Triggers the StableUpdate event. It will force a new
         * search
         *
         * @param {Object} [opts] Config object with custom options
         */
        stableUpdate: function(opts) {
            this._searchResults.triggerStableUpdate(_.extend({
                force: true
            }, opts));
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common-mess', location = 'content/js/search/EmptyResultsView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.EmptyResultsView");

    JIRA.Issues.EmptyResultsView = JIRA.Issues.BaseView.extend({

        initialize: function(options) {
            this.searchResults = options.searchResults;
        },

        render: function() {
            var message;
            var hint;
            var cssClass;
            var linkType;
            var createIssuePerm = JIRA.Issues.UserParms.get().createIssue;

            if (!JIRA.Issues.LoginUtils.isLoggedIn()) {
                message = "No issues were found to match your search";
                hint = "Try \u003ca\u003elogging in\u003c/a\u003e to see more results";
                cssClass = "not-logged-in-message";
                linkType = 'login';
            } else if (this.searchResults.getJiraHasIssues() === false) {
                message = "No issues have been created (yet)";
                hint = createIssuePerm ? "Be the first to \u003ca\u003ecreate an issue\u003c/a\u003e" : null;
                cssClass = "empty-results-message";
                linkType = 'create';
            } else {
                message = "No issues were found to match your search";
                hint = createIssuePerm ?
                    "Try modifying your search criteria or \u003ca\u003ecreating a new issue\u003c/a\u003e" :
                    "Try modifying your search criteria";
                cssClass = "no-results-message";
                linkType = 'create';
            }

            this.$el.addClass("empty-results");
            this.$el.html(JIRA.Templates.IssueNavTable.noResults({
                message: message,
                hint: hint,
                cssClass: cssClass
            }));

            // Make links within the hint work
            var $links = this.$('.no-results-hint a');
            switch (linkType) {
                case 'create':
                    $links.addClass('create-issue').attr('href', AJS.contextPath() + "/secure/CreateIssue!default.jspa");
                    break;
                case 'login':
                    $links.attr('href', JIRA.Issues.LoginUtils.redirectUrlToCurrent()).addClass('login-link');
                    break;
            }

            _.defer(jQuery.event.trigger, 'updateOffsets.popout');
            _.defer(JIRA.trace, 'jira.search.finished');
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:navigation', location = 'content/js/util/URLSerializer.js' */
(function () {
    "use strict";

    var BASE_BROWSE = "browse/";
    var BASE_ISSUES = "issues/";

    var returnAsIs = function(x) {
        return x;
    };

    var returnAsNumber = function(x) {
        if (typeof x === 'string') {
            return parseInt(x, 10);
        }

        return x;
    };

    /**
     * An object describing the state of the issue navigator.
     *
     * @typedef {object} JIRA.Issues.URLSerializer.state
     * @property {string} selectedIssueKey
     * @property {(string|null)} filterJql
     * @property {(string|null)} filter
     * @property {(string|null)} jql
     * @property {number} startIndex
     */

    /**
     * (De)serializes page state to URLs.
     */
    JIRA.Issues.URLSerializer = {
        /**
         * Construct a URL representation of a state object.
         *
         * @param {JIRA.Issues.URLSerializer.state} state The state object.
         * @return {string} A URL representation of <tt>state</tt>.
         */
        getURLFromState: function (state) {
            state = state || {};

            var query = [];
            var base;

            if (state.selectedIssueKey) {
                base = BASE_BROWSE + state.selectedIssueKey;
            } else {
                base = BASE_ISSUES;
            }
            if (state.filter != null) {
                query.push('filter=' + state.filter);
            }

            if (state.jql != null && (state.filterJql == null || state.jql !== state.filterJql)) {
                query.push('jql=' + encodeURIComponent(state.jql));
            }
            if (state.startIndex && !state.selectedIssueKey) {
                query.push('startIndex=' + state.startIndex);
            }
            return base + (query.length ? '?' + query.join('&') : "");
        },

        /**
         * Extract state from a URL.
         *
         * @param {string} URL The URL.
         * @return {JIRA.Issues.URLSerializer.state} The state object.
         */
        getStateFromURL: function (URL) {
            var parameters = {};
            var path = URL.split("?")[0];
            var queryString;
            var state;

            state = {
                filter: null,
                jql: null,
                selectedIssueKey: null,
                startIndex: 0
            };

            if (URL.indexOf(BASE_BROWSE) === 0) {
                state.selectedIssueKey = path.split("/")[1];
            }

            if (URL.indexOf("?") !== -1) {
                queryString = URL.substr(URL.indexOf("?"));
                parameters = JIRA.Issues.QueryStringParser.parse(queryString);

                //Need to keep a record of these and pass them along down to view issue
                //so that the correct element can be scrolled into view.
                //These can be trashed afterward with no side effect.
                var viewIssueQuery = _.pick(parameters, 'focusedCommentId', 'attachmentSortBy', 'attachmentOrder', 'attachmentViewMode');
                if (!_.isEmpty(viewIssueQuery)) {
                    state.viewIssueQuery = viewIssueQuery;
                }
            }

            // return convert the parameters using the conversion functions before returning
            return _.inject(this.PARAMETER_TRANSFORM, function (state, convertFn, key) {
                var value = parameters[key];
                if (value !== undefined) {
                    // apply conversion and override the defaults
                    state[key] = convertFn(value);
                }

                return state;
            }, _.extend(state));
        },

        /**
         * Parameters that are stored in the query string (with an optional conversion/transformation function).
         */
        PARAMETER_TRANSFORM: {
            "filter": returnAsIs,
            "jql": returnAsIs,
            "startIndex": returnAsNumber
        }
    };
})();
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:navigation', location = 'content/js/modules/navigation/State.js' */
define('jira/issues/modules/navigation/state',
[
    'underscore'
],
function(
    _
) {
    "use strict";

    /**
     * An object representing  application state.
     * @property {number} filter - ID of the filter
     * @property {string} selectedIssueKey - key of the selected issue
     * @property {string} jql - JQL of the search
     * @property {string} filterJql - JQL of the filter
     * @property {number} startIndex - 0-based index of the first issue visible in search results
     * @property {string} viewIssueQuery - a query parameters for the view issue page
     * @property {number} searchId - unique search id
     * @constructor
     *
     * @param {Object} state - an object containing initial state parameters
     */
    var State = function State(state) {
        this.filter = null;
        this.jql = null;
        if (state) {
            _.extend(this, state.toJSON());
        }
    };

    _.extend(State.prototype,
    /** @lends State.prototype */
    {
        /**
         * Construct an URL representation
         *
         * @returns {string} URL representation of state
         */
        toUrl: function toUrl() {
            return JIRA.Issues.URLSerializer.getURLFromState(this);
        },
        /**
         * Does this state represent standalone issue (View Issue page)
         *
         * @returns {boolean}
         */
        isStandaloneIssue: function isStandaloneIssue() {
            return Boolean(this.selectedIssueKey) && !_.isString(this.jql) && !this.filter;
        },
        /**
         * Convert URL to state object
         *
         * @param {string} url - URL from which the state will be derived
         * @returns {State} state object
         */
        getStateFromUrl: function getStateFromUrl(url) {
            return JIRA.Issues.URLSerializer.getStateFromURL(url);
        }
    });

    return State;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:navigation', location = 'content/js/modules/navigation/NavigationController.js' */
define('jira/issues/modules/navigation/controller',
[
    'jira/issues/modules/navigation/state',
    'jira/components/libs/marionette-1.4.1/controller',
    'jquery',
    'underscore',
    'jira/components/issueviewer/services/darkfeatures'
],
function(
    State,
    Controller,
    jQuery,
    _,
    DarkFeatures
) {
    "use strict";

    /**
     * An object describing navigation parameters. Every property, unless noted, is passed with the stateChanged event.
     *
     * @typedef {Object} NavigationOptions
     * @property {boolean} reset - should the state be reseted before performing the navigation
     * @property {boolean} forceRefresh - should the stateChanged event be fired even when state does not change.
     * @property {boolean} fullPageLoad - is the state change a full page load navigation,
     *                                  meaning that it was the first navigation handled by controller
     * @property {boolean} routerEvent - is the navigation event coming from the router, meaning that it is a first
     *                                  application navigation, or it comes from browser history
     * @property {boolean} replace - should the URL in the address bar be replaced
     * @property {String} reason - reason for changing application state
     */

    /**
     * Controller responsible for maintaining and modifying application state. Every state change will result in
     * stateChanged event being triggered.
     *
     * @class
     * @extends Marionette.Controller
     * @fires stateChanged
     */
    return Controller.extend({
        /**
         * @constructs
         * @param {Object} options - Configuration of the controller.
         * @param {boolean} [options.isFullPageLoad=true] - should the controller consider first navigation a full
         * page load. It will include this information in stateChanged event.
         * @param {State} [options.model] - the State object that the controller will use for storing state.
         */
        initialize: function initialize(options) {
            options = _.defaults(options, {isFullPageLoad: true});
            this.state = options.model || new State();
            this.isFullPageLoad = options.isFullPageLoad;
            this.eventQueue = [];
        },
        /**
         * Reset to blank state
         */
        reset: function reset() {
            this.state = new State();
        },
        /**
         * Process the application navigation to provided state.
         * It will check if navigation is possible and update application state accordingly.
         *
         * @param {Object} state - object containing state properties
         * @param {NavigationOptions} options - contains navigation properties
         */
        navigate: function navigate(state, options) {
            if (JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                this.updateState(state, options);
            }
        },
        /**
         * Process the application navigation to provided URL.
         *
         * @param {String} url - URL to which the navigation will be performed
         * @param {NavigationOptions} options - contains navigation properties
         * @param {Object} override - object containing state properties that will get overwritten in the state derived from the URL
         */
        navigateToUrl: function navigate(url, options, override) {
            override = override || {};
            var state = _.extend(this.state.getStateFromUrl(url), override);
            this.navigate(state, options);
        },
        /**
         * Update the application state to the one provided.
         *
         * @param {Object} state - object containing state properties
         * @param {NavigationOptions} options - contains navigation properties
         */
        updateState: function updateState(state, options) {
            options = options || {};

            var previousState = _.pick(this.state, _.keys(this.state));

            if (options.reset) {
                this.reset();
            }
            _.extend(this.state, state);

            // intercept states that would cause the full screen issue viewer to be called and just go to the URL instead
            // This spot was picked for multiple reasons:
            // - It has to happen after the state has been updated so state.toUrl() will give the correct results
            // - It has to happen before any handlers of stateChanged had a chance to mess with browser history or
            //   execute actions that are not necessary anymore
            if (DarkFeatures.REDIRECT_FROM_GLOBAL_TO_PROJECT.enabled() && (
                this.state.isStandaloneIssue()
                ||
                (JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey() === 'list-view' && this.state.selectedIssueKey))) {
                this._redirectToUrl(JIRA.Issues.IssueNavRouter.getBackboneRoot() + this.state.toUrl());
                return;
            }

            if (!_.isEqual(previousState, _.pick(this.state, _.keys(this.state))) || options.forceRefresh) {
                this._triggerStateChangedEvent(options);
            }
        },
        _triggerStateChangedEvent: function _triggerStateChangedEvent(options) {
            if (this.isFullPageLoad) {
                _.extend(options, {fullPageLoad: true});
                this.isFullPageLoad = false;
            }
            options = _.omit(options, 'forceRefresh');
            this.eventQueue.push({state: _.clone(this.state), options: options});
            this._processEvents();
        },
        _processEvents: function _processEvents() {
            /**
             * Application state change event
             *
             * @event stateChanged
             * @property {State} state - state that controller navigated to
             * @property {NavigationOptions} options - array of options that describe state change
             */
            if (!this.processingEvent) {
                this.processingEvent = true;
                var event = this.eventQueue.shift();
                this.trigger('stateChanged', event.state, event.options);
                this.processingEvent = false;
                if (this.eventQueue.length) {
                    this._processEvents();
                }
            }
        },
        _redirectToUrl: function _redirectToUrl(url) {
            window.location.assign(url);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:navigation', location = 'content/js/modules/navigation/NavigationAppModule.js' */
define('jira/issues/modules/navigation/module',
[
    'jira/issues/modules/navigation/controller',
    'jira/components/libs/marionette-1.4.1/appmodule'
],
function(
    NavigationController,
    AppModule
) {
    "use strict";

    return AppModule.extend({
        name: "navigation",
        create: function create() {
            return new NavigationController();
        },
        commands: {
            'reset': true,
            'updateState': true,
            'navigate': true,
            'navigateToUrl': true
        },
        events: [
            'stateChanged'
        ]
    });
});
;
;
/* module-key = 'com.atlassian.plugin.jslibs:uri-1.14.1', location = 'libs/uri/1.14.1/uri-1.14.1.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
    define('atlassian/libs/uri-1.14.1', function() {
        var env = {};
        factory.call(env);
        return env.URI.noConflict();
    });
})(function(){
/////// End of Atlassian modification ///////

    /*!
     * URI.js - Mutating URLs
     *
     * Version: 1.14.1
     *
     * Author: Rodney Rehm
     * Web: http://medialize.github.io/URI.js/
     *
     * Licensed under
     *   MIT License http://www.opensource.org/licenses/mit-license
     *   GPL v3 http://opensource.org/licenses/GPL-3.0
     *
     */
    (function (root, factory) {
        'use strict';
        // https://github.com/umdjs/umd/blob/master/returnExports.js

        /////////// Modified by Atlassian ///////////
        //if (typeof exports === 'object') {
        //    // Node
        //    module.exports = factory(require('./punycode'), require('./IPv6'), require('./SecondLevelDomains'));
        //} else if (typeof define === 'function' && define.amd) {
        //    // AMD. Register as an anonymous module.
        //    define(['./punycode', './IPv6', './SecondLevelDomains'], factory);
        //} else {
        //    // Browser globals (root is window)
        //    root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
        //}
        // Bypassing in-library AMD
        root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
        /////// End of Atlassian modification ///////

    }(this, function (punycode, IPv6, SLD, root) {
        'use strict';
        /*global location, escape, unescape */
        // FIXME: v2.0.0 renamce non-camelCase properties to uppercase
        /*jshint camelcase: false */

        // save current URI variable, if any
        var _URI = root && root.URI;

        function URI(url, base) {
            // Allow instantiation without the 'new' keyword
            if (!(this instanceof URI)) {
                return new URI(url, base);
            }

            if (url === undefined) {
                if (typeof location !== 'undefined') {
                    url = location.href + '';
                } else {
                    url = '';
                }
            }

            this.href(url);

            // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor
            if (base !== undefined) {
                return this.absoluteTo(base);
            }

            return this;
        }

        URI.version = '1.14.1';

        var p = URI.prototype;
        var hasOwn = Object.prototype.hasOwnProperty;

        function escapeRegEx(string) {
            // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963
            return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
        }

        function getType(value) {
            // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value
            if (value === undefined) {
                return 'Undefined';
            }

            return String(Object.prototype.toString.call(value)).slice(8, -1);
        }

        function isArray(obj) {
            return getType(obj) === 'Array';
        }

        function filterArrayValues(data, value) {
            var lookup = {};
            var i, length;

            if (isArray(value)) {
                for (i = 0, length = value.length; i < length; i++) {
                    lookup[value[i]] = true;
                }
            } else {
                lookup[value] = true;
            }

            for (i = 0, length = data.length; i < length; i++) {
                if (lookup[data[i]] !== undefined) {
                    data.splice(i, 1);
                    length--;
                    i--;
                }
            }

            return data;
        }

        function arrayContains(list, value) {
            var i, length;

            // value may be string, number, array, regexp
            if (isArray(value)) {
                // Note: this can be optimized to O(n) (instead of current O(m * n))
                for (i = 0, length = value.length; i < length; i++) {
                    if (!arrayContains(list, value[i])) {
                        return false;
                    }
                }

                return true;
            }

            var _type = getType(value);
            for (i = 0, length = list.length; i < length; i++) {
                if (_type === 'RegExp') {
                    if (typeof list[i] === 'string' && list[i].match(value)) {
                        return true;
                    }
                } else if (list[i] === value) {
                    return true;
                }
            }

            return false;
        }

        function arraysEqual(one, two) {
            if (!isArray(one) || !isArray(two)) {
                return false;
            }

            // arrays can't be equal if they have different amount of content
            if (one.length !== two.length) {
                return false;
            }

            one.sort();
            two.sort();

            for (var i = 0, l = one.length; i < l; i++) {
                if (one[i] !== two[i]) {
                    return false;
                }
            }

            return true;
        }

        URI._parts = function() {
            return {
                protocol: null,
                username: null,
                password: null,
                hostname: null,
                urn: null,
                port: null,
                path: null,
                query: null,
                fragment: null,
                // state
                duplicateQueryParameters: URI.duplicateQueryParameters,
                escapeQuerySpace: URI.escapeQuerySpace
            };
        };
        // state: allow duplicate query parameters (a=1&a=1)
        URI.duplicateQueryParameters = false;
        // state: replaces + with %20 (space in query strings)
        URI.escapeQuerySpace = true;
        // static properties
        URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
        URI.idn_expression = /[^a-z0-9\.-]/i;
        URI.punycode_expression = /(xn--)/i;
        // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?
        URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
        // credits to Rich Brown
        // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096
        // specification: http://www.ietf.org/rfc/rfc4291.txt
        URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
        // expression used is "gruber revised" (@gruber v2) determined to be the
        // best solution in a regex-golf we did a couple of ages ago at
        // * http://mathiasbynens.be/demo/url-regex
        // * http://rodneyrehm.de/t/url-regex.html
        URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
        URI.findUri = {
            // valid "scheme://" or "www."
            start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
            // everything up to the next whitespace
            end: /[\s\r\n]|$/,
            // trim trailing punctuation captured by end RegExp
            trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/
        };
        // http://www.iana.org/assignments/uri-schemes.html
        // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports
        URI.defaultPorts = {
            http: '80',
            https: '443',
            ftp: '21',
            gopher: '70',
            ws: '80',
            wss: '443'
        };
        // allowed hostname characters according to RFC 3986
        // ALPHA DIGIT "-" "." "_" "~" "!" "$" "&" "'" "(" ")" "*" "+" "," ";" "=" %encoded
        // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . -
        URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/;
        // map DOM Elements to their URI attribute
        URI.domAttributes = {
            'a': 'href',
            'blockquote': 'cite',
            'link': 'href',
            'base': 'href',
            'script': 'src',
            'form': 'action',
            'img': 'src',
            'area': 'href',
            'iframe': 'src',
            'embed': 'src',
            'source': 'src',
            'track': 'src',
            'input': 'src', // but only if type="image"
            'audio': 'src',
            'video': 'src'
        };
        URI.getDomAttribute = function(node) {
            if (!node || !node.nodeName) {
                return undefined;
            }

            var nodeName = node.nodeName.toLowerCase();
            // <input> should only expose src for type="image"
            if (nodeName === 'input' && node.type !== 'image') {
                return undefined;
            }

            return URI.domAttributes[nodeName];
        };

        function escapeForDumbFirefox36(value) {
            // https://github.com/medialize/URI.js/issues/91
            return escape(value);
        }

        // encoding / decoding according to RFC3986
        function strictEncodeURIComponent(string) {
            // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent
            return encodeURIComponent(string)
                .replace(/[!'()*]/g, escapeForDumbFirefox36)
                .replace(/\*/g, '%2A');
        }
        URI.encode = strictEncodeURIComponent;
        URI.decode = decodeURIComponent;
        URI.iso8859 = function() {
            URI.encode = escape;
            URI.decode = unescape;
        };
        URI.unicode = function() {
            URI.encode = strictEncodeURIComponent;
            URI.decode = decodeURIComponent;
        };
        URI.characters = {
            pathname: {
                encode: {
                    // RFC3986 2.1: For consistency, URI producers and normalizers should
                    // use uppercase hexadecimal digits for all percent-encodings.
                    expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
                    map: {
                        // -._~!'()*
                        '%24': '$',
                        '%26': '&',
                        '%2B': '+',
                        '%2C': ',',
                        '%3B': ';',
                        '%3D': '=',
                        '%3A': ':',
                        '%40': '@'
                    }
                },
                decode: {
                    expression: /[\/\?#]/g,
                    map: {
                        '/': '%2F',
                        '?': '%3F',
                        '#': '%23'
                    }
                }
            },
            reserved: {
                encode: {
                    // RFC3986 2.1: For consistency, URI producers and normalizers should
                    // use uppercase hexadecimal digits for all percent-encodings.
                    expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
                    map: {
                        // gen-delims
                        '%3A': ':',
                        '%2F': '/',
                        '%3F': '?',
                        '%23': '#',
                        '%5B': '[',
                        '%5D': ']',
                        '%40': '@',
                        // sub-delims
                        '%21': '!',
                        '%24': '$',
                        '%26': '&',
                        '%27': '\'',
                        '%28': '(',
                        '%29': ')',
                        '%2A': '*',
                        '%2B': '+',
                        '%2C': ',',
                        '%3B': ';',
                        '%3D': '='
                    }
                }
            }
        };
        URI.encodeQuery = function(string, escapeQuerySpace) {
            var escaped = URI.encode(string + '');
            if (escapeQuerySpace === undefined) {
                escapeQuerySpace = URI.escapeQuerySpace;
            }

            return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
        };
        URI.decodeQuery = function(string, escapeQuerySpace) {
            string += '';
            if (escapeQuerySpace === undefined) {
                escapeQuerySpace = URI.escapeQuerySpace;
            }

            try {
                return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
            } catch(e) {
                // we're not going to mess with weird encodings,
                // give up and return the undecoded original string
                // see https://github.com/medialize/URI.js/issues/87
                // see https://github.com/medialize/URI.js/issues/92
                return string;
            }
        };
        URI.recodePath = function(string) {
            var segments = (string + '').split('/');
            for (var i = 0, length = segments.length; i < length; i++) {
                segments[i] = URI.encodePathSegment(URI.decode(segments[i]));
            }

            return segments.join('/');
        };
        URI.decodePath = function(string) {
            var segments = (string + '').split('/');
            for (var i = 0, length = segments.length; i < length; i++) {
                segments[i] = URI.decodePathSegment(segments[i]);
            }

            return segments.join('/');
        };
        // generate encode/decode path functions
        var _parts = {'encode':'encode', 'decode':'decode'};
        var _part;
        var generateAccessor = function(_group, _part) {
            return function(string) {
                try {
                    return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
                        return URI.characters[_group][_part].map[c];
                    });
                } catch (e) {
                    // we're not going to mess with weird encodings,
                    // give up and return the undecoded original string
                    // see https://github.com/medialize/URI.js/issues/87
                    // see https://github.com/medialize/URI.js/issues/92
                    return string;
                }
            };
        };

        for (_part in _parts) {
            URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
        }

        URI.encodeReserved = generateAccessor('reserved', 'encode');

        URI.parse = function(string, parts) {
            var pos;
            if (!parts) {
                parts = {};
            }
            // [protocol"://"[username[":"password]"@"]hostname[":"port]"/"?][path]["?"querystring]["#"fragment]

            // extract fragment
            pos = string.indexOf('#');
            if (pos > -1) {
                // escaping?
                parts.fragment = string.substring(pos + 1) || null;
                string = string.substring(0, pos);
            }

            // extract query
            pos = string.indexOf('?');
            if (pos > -1) {
                // escaping?
                parts.query = string.substring(pos + 1) || null;
                string = string.substring(0, pos);
            }

            // extract protocol
            if (string.substring(0, 2) === '//') {
                // relative-scheme
                parts.protocol = null;
                string = string.substring(2);
                // extract "user:pass@host:port"
                string = URI.parseAuthority(string, parts);
            } else {
                pos = string.indexOf(':');
                if (pos > -1) {
                    parts.protocol = string.substring(0, pos) || null;
                    if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
                        // : may be within the path
                        parts.protocol = undefined;
                    } else if (string.substring(pos + 1, pos + 3) === '//') {
                        string = string.substring(pos + 3);

                        // extract "user:pass@host:port"
                        string = URI.parseAuthority(string, parts);
                    } else {
                        string = string.substring(pos + 1);
                        parts.urn = true;
                    }
                }
            }

            // what's left must be the path
            parts.path = string;

            // and we're done
            return parts;
        };
        URI.parseHost = function(string, parts) {
            // extract host:port
            var pos = string.indexOf('/');
            var bracketPos;
            var t;

            if (pos === -1) {
                pos = string.length;
            }

            if (string.charAt(0) === '[') {
                // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6
                // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts
                // IPv6+port in the format [2001:db8::1]:80 (for the time being)
                bracketPos = string.indexOf(']');
                parts.hostname = string.substring(1, bracketPos) || null;
                parts.port = string.substring(bracketPos + 2, pos) || null;
                if (parts.port === '/') {
                    parts.port = null;
                }
            } else if (string.indexOf(':') !== string.lastIndexOf(':')) {
                // IPv6 host contains multiple colons - but no port
                // this notation is actually not allowed by RFC 3986, but we're a liberal parser
                parts.hostname = string.substring(0, pos) || null;
                parts.port = null;
            } else {
                t = string.substring(0, pos).split(':');
                parts.hostname = t[0] || null;
                parts.port = t[1] || null;
            }

            if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
                pos++;
                string = '/' + string;
            }

            return string.substring(pos) || '/';
        };
        URI.parseAuthority = function(string, parts) {
            string = URI.parseUserinfo(string, parts);
            return URI.parseHost(string, parts);
        };
        URI.parseUserinfo = function(string, parts) {
            // extract username:password
            var firstSlash = string.indexOf('/');
            var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
            var t;

            // authority@ must come before /path
            if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
                t = string.substring(0, pos).split(':');
                parts.username = t[0] ? URI.decode(t[0]) : null;
                t.shift();
                parts.password = t[0] ? URI.decode(t.join(':')) : null;
                string = string.substring(pos + 1);
            } else {
                parts.username = null;
                parts.password = null;
            }

            return string;
        };
        URI.parseQuery = function(string, escapeQuerySpace) {
            if (!string) {
                return {};
            }

            // throw out the funky business - "?"[name"="value"&"]+
            string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');

            if (!string) {
                return {};
            }

            var items = {};
            var splits = string.split('&');
            var length = splits.length;
            var v, name, value;

            for (var i = 0; i < length; i++) {
                v = splits[i].split('=');
                name = URI.decodeQuery(v.shift(), escapeQuerySpace);
                // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
                value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;

                if (hasOwn.call(items, name)) {
                    if (typeof items[name] === 'string') {
                        items[name] = [items[name]];
                    }

                    items[name].push(value);
                } else {
                    items[name] = value;
                }
            }

            return items;
        };

        URI.build = function(parts) {
            var t = '';

            if (parts.protocol) {
                t += parts.protocol + ':';
            }

            if (!parts.urn && (t || parts.hostname)) {
                t += '//';
            }

            t += (URI.buildAuthority(parts) || '');

            if (typeof parts.path === 'string') {
                if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {
                    t += '/';
                }

                t += parts.path;
            }

            if (typeof parts.query === 'string' && parts.query) {
                t += '?' + parts.query;
            }

            if (typeof parts.fragment === 'string' && parts.fragment) {
                t += '#' + parts.fragment;
            }
            return t;
        };
        URI.buildHost = function(parts) {
            var t = '';

            if (!parts.hostname) {
                return '';
            } else if (URI.ip6_expression.test(parts.hostname)) {
                t += '[' + parts.hostname + ']';
            } else {
                t += parts.hostname;
            }

            if (parts.port) {
                t += ':' + parts.port;
            }

            return t;
        };
        URI.buildAuthority = function(parts) {
            return URI.buildUserinfo(parts) + URI.buildHost(parts);
        };
        URI.buildUserinfo = function(parts) {
            var t = '';

            if (parts.username) {
                t += URI.encode(parts.username);

                if (parts.password) {
                    t += ':' + URI.encode(parts.password);
                }

                t += '@';
            }

            return t;
        };
        URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
            // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html
            // being »-._~!$&'()*+,;=:@/?« %HEX and alnum are allowed
            // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!
            // URI.js treats the query string as being application/x-www-form-urlencoded
            // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type

            var t = '';
            var unique, key, i, length;
            for (key in data) {
                if (hasOwn.call(data, key) && key) {
                    if (isArray(data[key])) {
                        unique = {};
                        for (i = 0, length = data[key].length; i < length; i++) {
                            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
                                t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
                                if (duplicateQueryParameters !== true) {
                                    unique[data[key][i] + ''] = true;
                                }
                            }
                        }
                    } else if (data[key] !== undefined) {
                        t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
                    }
                }
            }

            return t.substring(1);
        };
        URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
            // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded
            // don't append "=" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization
            return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
        };

        URI.addQuery = function(data, name, value) {
            if (typeof name === 'object') {
                for (var key in name) {
                    if (hasOwn.call(name, key)) {
                        URI.addQuery(data, key, name[key]);
                    }
                }
            } else if (typeof name === 'string') {
                if (data[name] === undefined) {
                    data[name] = value;
                    return;
                } else if (typeof data[name] === 'string') {
                    data[name] = [data[name]];
                }

                if (!isArray(value)) {
                    value = [value];
                }

                data[name] = (data[name] || []).concat(value);
            } else {
                throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
            }
        };
        URI.removeQuery = function(data, name, value) {
            var i, length, key;

            if (isArray(name)) {
                for (i = 0, length = name.length; i < length; i++) {
                    data[name[i]] = undefined;
                }
            } else if (typeof name === 'object') {
                for (key in name) {
                    if (hasOwn.call(name, key)) {
                        URI.removeQuery(data, key, name[key]);
                    }
                }
            } else if (typeof name === 'string') {
                if (value !== undefined) {
                    if (data[name] === value) {
                        data[name] = undefined;
                    } else if (isArray(data[name])) {
                        data[name] = filterArrayValues(data[name], value);
                    }
                } else {
                    data[name] = undefined;
                }
            } else {
                throw new TypeError('URI.addQuery() accepts an object, string as the first parameter');
            }
        };
        URI.hasQuery = function(data, name, value, withinArray) {
            if (typeof name === 'object') {
                for (var key in name) {
                    if (hasOwn.call(name, key)) {
                        if (!URI.hasQuery(data, key, name[key])) {
                            return false;
                        }
                    }
                }

                return true;
            } else if (typeof name !== 'string') {
                throw new TypeError('URI.hasQuery() accepts an object, string as the name parameter');
            }

            switch (getType(value)) {
                case 'Undefined':
                    // true if exists (but may be empty)
                    return name in data; // data[name] !== undefined;

                case 'Boolean':
                    // true if exists and non-empty
                    var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
                    return value === _booly;

                case 'Function':
                    // allow complex comparison
                    return !!value(data[name], name, data);

                case 'Array':
                    if (!isArray(data[name])) {
                        return false;
                    }

                    var op = withinArray ? arrayContains : arraysEqual;
                    return op(data[name], value);

                case 'RegExp':
                    if (!isArray(data[name])) {
                        return Boolean(data[name] && data[name].match(value));
                    }

                    if (!withinArray) {
                        return false;
                    }

                    return arrayContains(data[name], value);

                case 'Number':
                    value = String(value);
                /* falls through */
                case 'String':
                    if (!isArray(data[name])) {
                        return data[name] === value;
                    }

                    if (!withinArray) {
                        return false;
                    }

                    return arrayContains(data[name], value);

                default:
                    throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
            }
        };


        URI.commonPath = function(one, two) {
            var length = Math.min(one.length, two.length);
            var pos;

            // find first non-matching character
            for (pos = 0; pos < length; pos++) {
                if (one.charAt(pos) !== two.charAt(pos)) {
                    pos--;
                    break;
                }
            }

            if (pos < 1) {
                return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
            }

            // revert to last /
            if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
                pos = one.substring(0, pos).lastIndexOf('/');
            }

            return one.substring(0, pos + 1);
        };

        URI.withinString = function(string, callback, options) {
            options || (options = {});
            var _start = options.start || URI.findUri.start;
            var _end = options.end || URI.findUri.end;
            var _trim = options.trim || URI.findUri.trim;
            var _attributeOpen = /[a-z0-9-]=["']?$/i;

            _start.lastIndex = 0;
            while (true) {
                var match = _start.exec(string);
                if (!match) {
                    break;
                }

                var start = match.index;
                if (options.ignoreHtml) {
                    // attribut(e=["']?$)
                    var attributeOpen = string.slice(Math.max(start - 3, 0), start);
                    if (attributeOpen && _attributeOpen.test(attributeOpen)) {
                        continue;
                    }
                }

                var end = start + string.slice(start).search(_end);
                var slice = string.slice(start, end).replace(_trim, '');
                if (options.ignore && options.ignore.test(slice)) {
                    continue;
                }

                end = start + slice.length;
                var result = callback(slice, start, end, string);
                string = string.slice(0, start) + result + string.slice(end);
                _start.lastIndex = start + result.length;
            }

            _start.lastIndex = 0;
            return string;
        };

        URI.ensureValidHostname = function(v) {
            // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)
            // they are not part of DNS and therefore ignored by URI.js

            if (v.match(URI.invalid_hostname_characters)) {
                // test punycode
                if (!punycode) {
                    throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-] and Punycode.js is not available');
                }

                if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
                    throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
                }
            }
        };

        // noConflict
        URI.noConflict = function(removeAll) {
            if (removeAll) {
                var unconflicted = {
                    URI: this.noConflict()
                };

                if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
                    unconflicted.URITemplate = root.URITemplate.noConflict();
                }

                if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
                    unconflicted.IPv6 = root.IPv6.noConflict();
                }

                if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
                    unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
                }

                return unconflicted;
            } else if (root.URI === this) {
                root.URI = _URI;
            }

            return this;
        };

        p.build = function(deferBuild) {
            if (deferBuild === true) {
                this._deferred_build = true;
            } else if (deferBuild === undefined || this._deferred_build) {
                this._string = URI.build(this._parts);
                this._deferred_build = false;
            }

            return this;
        };

        p.clone = function() {
            return new URI(this);
        };

        p.valueOf = p.toString = function() {
            return this.build(false)._string;
        };


        function generateSimpleAccessor(_part){
            return function(v, build) {
                if (v === undefined) {
                    return this._parts[_part] || '';
                } else {
                    this._parts[_part] = v || null;
                    this.build(!build);
                    return this;
                }
            };
        }

        function generatePrefixAccessor(_part, _key){
            return function(v, build) {
                if (v === undefined) {
                    return this._parts[_part] || '';
                } else {
                    if (v !== null) {
                        v = v + '';
                        if (v.charAt(0) === _key) {
                            v = v.substring(1);
                        }
                    }

                    this._parts[_part] = v;
                    this.build(!build);
                    return this;
                }
            };
        }

        p.protocol = generateSimpleAccessor('protocol');
        p.username = generateSimpleAccessor('username');
        p.password = generateSimpleAccessor('password');
        p.hostname = generateSimpleAccessor('hostname');
        p.port = generateSimpleAccessor('port');
        p.query = generatePrefixAccessor('query', '?');
        p.fragment = generatePrefixAccessor('fragment', '#');

        p.search = function(v, build) {
            var t = this.query(v, build);
            return typeof t === 'string' && t.length ? ('?' + t) : t;
        };
        p.hash = function(v, build) {
            var t = this.fragment(v, build);
            return typeof t === 'string' && t.length ? ('#' + t) : t;
        };

        p.pathname = function(v, build) {
            if (v === undefined || v === true) {
                var res = this._parts.path || (this._parts.hostname ? '/' : '');
                return v ? URI.decodePath(res) : res;
            } else {
                this._parts.path = v ? URI.recodePath(v) : '/';
                this.build(!build);
                return this;
            }
        };
        p.path = p.pathname;
        p.href = function(href, build) {
            var key;

            if (href === undefined) {
                return this.toString();
            }

            this._string = '';
            this._parts = URI._parts();

            var _URI = href instanceof URI;
            var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
            if (href.nodeName) {
                var attribute = URI.getDomAttribute(href);
                href = href[attribute] || '';
                _object = false;
            }

            // window.location is reported to be an object, but it's not the sort
            // of object we're looking for:
            // * location.protocol ends with a colon
            // * location.query != object.search
            // * location.hash != object.fragment
            // simply serializing the unknown object should do the trick
            // (for location, not for everything...)
            if (!_URI && _object && href.pathname !== undefined) {
                href = href.toString();
            }

            if (typeof href === 'string' || href instanceof String) {
                this._parts = URI.parse(String(href), this._parts);
            } else if (_URI || _object) {
                var src = _URI ? href._parts : href;
                for (key in src) {
                    if (hasOwn.call(this._parts, key)) {
                        this._parts[key] = src[key];
                    }
                }
            } else {
                throw new TypeError('invalid input');
            }

            this.build(!build);
            return this;
        };

        // identification accessors
        p.is = function(what) {
            var ip = false;
            var ip4 = false;
            var ip6 = false;
            var name = false;
            var sld = false;
            var idn = false;
            var punycode = false;
            var relative = !this._parts.urn;

            if (this._parts.hostname) {
                relative = false;
                ip4 = URI.ip4_expression.test(this._parts.hostname);
                ip6 = URI.ip6_expression.test(this._parts.hostname);
                ip = ip4 || ip6;
                name = !ip;
                sld = name && SLD && SLD.has(this._parts.hostname);
                idn = name && URI.idn_expression.test(this._parts.hostname);
                punycode = name && URI.punycode_expression.test(this._parts.hostname);
            }

            switch (what.toLowerCase()) {
                case 'relative':
                    return relative;

                case 'absolute':
                    return !relative;

                // hostname identification
                case 'domain':
                case 'name':
                    return name;

                case 'sld':
                    return sld;

                case 'ip':
                    return ip;

                case 'ip4':
                case 'ipv4':
                case 'inet4':
                    return ip4;

                case 'ip6':
                case 'ipv6':
                case 'inet6':
                    return ip6;

                case 'idn':
                    return idn;

                case 'url':
                    return !this._parts.urn;

                case 'urn':
                    return !!this._parts.urn;

                case 'punycode':
                    return punycode;
            }

            return null;
        };

        // component specific input validation
        var _protocol = p.protocol;
        var _port = p.port;
        var _hostname = p.hostname;

        p.protocol = function(v, build) {
            if (v !== undefined) {
                if (v) {
                    // accept trailing ://
                    v = v.replace(/:(\/\/)?$/, '');

                    if (!v.match(URI.protocol_expression)) {
                        throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
                    }
                }
            }
            return _protocol.call(this, v, build);
        };
        p.scheme = p.protocol;
        p.port = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v !== undefined) {
                if (v === 0) {
                    v = null;
                }

                if (v) {
                    v += '';
                    if (v.charAt(0) === ':') {
                        v = v.substring(1);
                    }

                    if (v.match(/[^0-9]/)) {
                        throw new TypeError('Port "' + v + '" contains characters other than [0-9]');
                    }
                }
            }
            return _port.call(this, v, build);
        };
        p.hostname = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v !== undefined) {
                var x = {};
                URI.parseHost(v, x);
                v = x.hostname;
            }
            return _hostname.call(this, v, build);
        };

        // compound accessors
        p.host = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined) {
                return this._parts.hostname ? URI.buildHost(this._parts) : '';
            } else {
                URI.parseHost(v, this._parts);
                this.build(!build);
                return this;
            }
        };
        p.authority = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined) {
                return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
            } else {
                URI.parseAuthority(v, this._parts);
                this.build(!build);
                return this;
            }
        };
        p.userinfo = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined) {
                if (!this._parts.username) {
                    return '';
                }

                var t = URI.buildUserinfo(this._parts);
                return t.substring(0, t.length -1);
            } else {
                if (v[v.length-1] !== '@') {
                    v += '@';
                }

                URI.parseUserinfo(v, this._parts);
                this.build(!build);
                return this;
            }
        };
        p.resource = function(v, build) {
            var parts;

            if (v === undefined) {
                return this.path() + this.search() + this.hash();
            }

            parts = URI.parse(v);
            this._parts.path = parts.path;
            this._parts.query = parts.query;
            this._parts.fragment = parts.fragment;
            this.build(!build);
            return this;
        };

        // fraction accessors
        p.subdomain = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            // convenience, return "www" from "www.example.org"
            if (v === undefined) {
                if (!this._parts.hostname || this.is('IP')) {
                    return '';
                }

                // grab domain and add another segment
                var end = this._parts.hostname.length - this.domain().length - 1;
                return this._parts.hostname.substring(0, end) || '';
            } else {
                var e = this._parts.hostname.length - this.domain().length;
                var sub = this._parts.hostname.substring(0, e);
                var replace = new RegExp('^' + escapeRegEx(sub));

                if (v && v.charAt(v.length - 1) !== '.') {
                    v += '.';
                }

                if (v) {
                    URI.ensureValidHostname(v);
                }

                this._parts.hostname = this._parts.hostname.replace(replace, v);
                this.build(!build);
                return this;
            }
        };
        p.domain = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (typeof v === 'boolean') {
                build = v;
                v = undefined;
            }

            // convenience, return "example.org" from "www.example.org"
            if (v === undefined) {
                if (!this._parts.hostname || this.is('IP')) {
                    return '';
                }

                // if hostname consists of 1 or 2 segments, it must be the domain
                var t = this._parts.hostname.match(/\./g);
                if (t && t.length < 2) {
                    return this._parts.hostname;
                }

                // grab tld and add another segment
                var end = this._parts.hostname.length - this.tld(build).length - 1;
                end = this._parts.hostname.lastIndexOf('.', end -1) + 1;
                return this._parts.hostname.substring(end) || '';
            } else {
                if (!v) {
                    throw new TypeError('cannot set domain empty');
                }

                URI.ensureValidHostname(v);

                if (!this._parts.hostname || this.is('IP')) {
                    this._parts.hostname = v;
                } else {
                    var replace = new RegExp(escapeRegEx(this.domain()) + '$');
                    this._parts.hostname = this._parts.hostname.replace(replace, v);
                }

                this.build(!build);
                return this;
            }
        };
        p.tld = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (typeof v === 'boolean') {
                build = v;
                v = undefined;
            }

            // return "org" from "www.example.org"
            if (v === undefined) {
                if (!this._parts.hostname || this.is('IP')) {
                    return '';
                }

                var pos = this._parts.hostname.lastIndexOf('.');
                var tld = this._parts.hostname.substring(pos + 1);

                if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
                    return SLD.get(this._parts.hostname) || tld;
                }

                return tld;
            } else {
                var replace;

                if (!v) {
                    throw new TypeError('cannot set TLD empty');
                } else if (v.match(/[^a-zA-Z0-9-]/)) {
                    if (SLD && SLD.is(v)) {
                        replace = new RegExp(escapeRegEx(this.tld()) + '$');
                        this._parts.hostname = this._parts.hostname.replace(replace, v);
                    } else {
                        throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
                    }
                } else if (!this._parts.hostname || this.is('IP')) {
                    throw new ReferenceError('cannot set TLD on non-domain host');
                } else {
                    replace = new RegExp(escapeRegEx(this.tld()) + '$');
                    this._parts.hostname = this._parts.hostname.replace(replace, v);
                }

                this.build(!build);
                return this;
            }
        };
        p.directory = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined || v === true) {
                if (!this._parts.path && !this._parts.hostname) {
                    return '';
                }

                if (this._parts.path === '/') {
                    return '/';
                }

                var end = this._parts.path.length - this.filename().length - 1;
                var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');

                return v ? URI.decodePath(res) : res;

            } else {
                var e = this._parts.path.length - this.filename().length;
                var directory = this._parts.path.substring(0, e);
                var replace = new RegExp('^' + escapeRegEx(directory));

                // fully qualifier directories begin with a slash
                if (!this.is('relative')) {
                    if (!v) {
                        v = '/';
                    }

                    if (v.charAt(0) !== '/') {
                        v = '/' + v;
                    }
                }

                // directories always end with a slash
                if (v && v.charAt(v.length - 1) !== '/') {
                    v += '/';
                }

                v = URI.recodePath(v);
                this._parts.path = this._parts.path.replace(replace, v);
                this.build(!build);
                return this;
            }
        };
        p.filename = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined || v === true) {
                if (!this._parts.path || this._parts.path === '/') {
                    return '';
                }

                var pos = this._parts.path.lastIndexOf('/');
                var res = this._parts.path.substring(pos+1);

                return v ? URI.decodePathSegment(res) : res;
            } else {
                var mutatedDirectory = false;

                if (v.charAt(0) === '/') {
                    v = v.substring(1);
                }

                if (v.match(/\.?\//)) {
                    mutatedDirectory = true;
                }

                var replace = new RegExp(escapeRegEx(this.filename()) + '$');
                v = URI.recodePath(v);
                this._parts.path = this._parts.path.replace(replace, v);

                if (mutatedDirectory) {
                    this.normalizePath(build);
                } else {
                    this.build(!build);
                }

                return this;
            }
        };
        p.suffix = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined || v === true) {
                if (!this._parts.path || this._parts.path === '/') {
                    return '';
                }

                var filename = this.filename();
                var pos = filename.lastIndexOf('.');
                var s, res;

                if (pos === -1) {
                    return '';
                }

                // suffix may only contain alnum characters (yup, I made this up.)
                s = filename.substring(pos+1);
                res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
                return v ? URI.decodePathSegment(res) : res;
            } else {
                if (v.charAt(0) === '.') {
                    v = v.substring(1);
                }

                var suffix = this.suffix();
                var replace;

                if (!suffix) {
                    if (!v) {
                        return this;
                    }

                    this._parts.path += '.' + URI.recodePath(v);
                } else if (!v) {
                    replace = new RegExp(escapeRegEx('.' + suffix) + '$');
                } else {
                    replace = new RegExp(escapeRegEx(suffix) + '$');
                }

                if (replace) {
                    v = URI.recodePath(v);
                    this._parts.path = this._parts.path.replace(replace, v);
                }

                this.build(!build);
                return this;
            }
        };
        p.segment = function(segment, v, build) {
            var separator = this._parts.urn ? ':' : '/';
            var path = this.path();
            var absolute = path.substring(0, 1) === '/';
            var segments = path.split(separator);

            if (segment !== undefined && typeof segment !== 'number') {
                build = v;
                v = segment;
                segment = undefined;
            }

            if (segment !== undefined && typeof segment !== 'number') {
                throw new Error('Bad segment "' + segment + '", must be 0-based integer');
            }

            if (absolute) {
                segments.shift();
            }

            if (segment < 0) {
                // allow negative indexes to address from the end
                segment = Math.max(segments.length + segment, 0);
            }

            if (v === undefined) {
                /*jshint laxbreak: true */
                return segment === undefined
                    ? segments
                    : segments[segment];
                /*jshint laxbreak: false */
            } else if (segment === null || segments[segment] === undefined) {
                if (isArray(v)) {
                    segments = [];
                    // collapse empty elements within array
                    for (var i=0, l=v.length; i < l; i++) {
                        if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {
                            continue;
                        }

                        if (segments.length && !segments[segments.length -1].length) {
                            segments.pop();
                        }

                        segments.push(v[i]);
                    }
                } else if (v || typeof v === 'string') {
                    if (segments[segments.length -1] === '') {
                        // empty trailing elements have to be overwritten
                        // to prevent results such as /foo//bar
                        segments[segments.length -1] = v;
                    } else {
                        segments.push(v);
                    }
                }
            } else {
                if (v) {
                    segments[segment] = v;
                } else {
                    segments.splice(segment, 1);
                }
            }

            if (absolute) {
                segments.unshift('');
            }

            return this.path(segments.join(separator), build);
        };
        p.segmentCoded = function(segment, v, build) {
            var segments, i, l;

            if (typeof segment !== 'number') {
                build = v;
                v = segment;
                segment = undefined;
            }

            if (v === undefined) {
                segments = this.segment(segment, v, build);
                if (!isArray(segments)) {
                    segments = segments !== undefined ? URI.decode(segments) : undefined;
                } else {
                    for (i = 0, l = segments.length; i < l; i++) {
                        segments[i] = URI.decode(segments[i]);
                    }
                }

                return segments;
            }

            if (!isArray(v)) {
                v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
            } else {
                for (i = 0, l = v.length; i < l; i++) {
                    v[i] = URI.decode(v[i]);
                }
            }

            return this.segment(segment, v, build);
        };

        // mutating query string
        var q = p.query;
        p.query = function(v, build) {
            if (v === true) {
                return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            } else if (typeof v === 'function') {
                var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                var result = v.call(this, data);
                this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
                this.build(!build);
                return this;
            } else if (v !== undefined && typeof v !== 'string') {
                this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
                this.build(!build);
                return this;
            } else {
                return q.call(this, v, build);
            }
        };
        p.setQuery = function(name, value, build) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);

            if (typeof name === 'string' || name instanceof String) {
                data[name] = value !== undefined ? value : null;
            } else if (typeof name === 'object') {
                for (var key in name) {
                    if (hasOwn.call(name, key)) {
                        data[key] = name[key];
                    }
                }
            } else {
                throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
            }

            this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            if (typeof name !== 'string') {
                build = value;
            }

            this.build(!build);
            return this;
        };
        p.addQuery = function(name, value, build) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            URI.addQuery(data, name, value === undefined ? null : value);
            this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            if (typeof name !== 'string') {
                build = value;
            }

            this.build(!build);
            return this;
        };
        p.removeQuery = function(name, value, build) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            URI.removeQuery(data, name, value);
            this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            if (typeof name !== 'string') {
                build = value;
            }

            this.build(!build);
            return this;
        };
        p.hasQuery = function(name, value, withinArray) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return URI.hasQuery(data, name, value, withinArray);
        };
        p.setSearch = p.setQuery;
        p.addSearch = p.addQuery;
        p.removeSearch = p.removeQuery;
        p.hasSearch = p.hasQuery;

        // sanitizing URLs
        p.normalize = function() {
            if (this._parts.urn) {
                return this
                    .normalizeProtocol(false)
                    .normalizeQuery(false)
                    .normalizeFragment(false)
                    .build();
            }

            return this
                .normalizeProtocol(false)
                .normalizeHostname(false)
                .normalizePort(false)
                .normalizePath(false)
                .normalizeQuery(false)
                .normalizeFragment(false)
                .build();
        };
        p.normalizeProtocol = function(build) {
            if (typeof this._parts.protocol === 'string') {
                this._parts.protocol = this._parts.protocol.toLowerCase();
                this.build(!build);
            }

            return this;
        };
        p.normalizeHostname = function(build) {
            if (this._parts.hostname) {
                if (this.is('IDN') && punycode) {
                    this._parts.hostname = punycode.toASCII(this._parts.hostname);
                } else if (this.is('IPv6') && IPv6) {
                    this._parts.hostname = IPv6.best(this._parts.hostname);
                }

                this._parts.hostname = this._parts.hostname.toLowerCase();
                this.build(!build);
            }

            return this;
        };
        p.normalizePort = function(build) {
            // remove port of it's the protocol's default
            if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
                this._parts.port = null;
                this.build(!build);
            }

            return this;
        };
        p.normalizePath = function(build) {
            if (this._parts.urn) {
                return this;
            }

            if (!this._parts.path || this._parts.path === '/') {
                return this;
            }

            var _was_relative;
            var _path = this._parts.path;
            var _leadingParents = '';
            var _parent, _pos;

            // handle relative paths
            if (_path.charAt(0) !== '/') {
                _was_relative = true;
                _path = '/' + _path;
            }

            // resolve simples
            _path = _path
                .replace(/(\/(\.\/)+)|(\/\.$)/g, '/')
                .replace(/\/{2,}/g, '/');

            // remember leading parents
            if (_was_relative) {
                _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
                if (_leadingParents) {
                    _leadingParents = _leadingParents[0];
                }
            }

            // resolve parents
            while (true) {
                _parent = _path.indexOf('/..');
                if (_parent === -1) {
                    // no more ../ to resolve
                    break;
                } else if (_parent === 0) {
                    // top level cannot be relative, skip it
                    _path = _path.substring(3);
                    continue;
                }

                _pos = _path.substring(0, _parent).lastIndexOf('/');
                if (_pos === -1) {
                    _pos = _parent;
                }
                _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
            }

            // revert to relative
            if (_was_relative && this.is('relative')) {
                _path = _leadingParents + _path.substring(1);
            }

            _path = URI.recodePath(_path);
            this._parts.path = _path;
            this.build(!build);
            return this;
        };
        p.normalizePathname = p.normalizePath;
        p.normalizeQuery = function(build) {
            if (typeof this._parts.query === 'string') {
                if (!this._parts.query.length) {
                    this._parts.query = null;
                } else {
                    this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
                }

                this.build(!build);
            }

            return this;
        };
        p.normalizeFragment = function(build) {
            if (!this._parts.fragment) {
                this._parts.fragment = null;
                this.build(!build);
            }

            return this;
        };
        p.normalizeSearch = p.normalizeQuery;
        p.normalizeHash = p.normalizeFragment;

        p.iso8859 = function() {
            // expect unicode input, iso8859 output
            var e = URI.encode;
            var d = URI.decode;

            URI.encode = escape;
            URI.decode = decodeURIComponent;
            this.normalize();
            URI.encode = e;
            URI.decode = d;
            return this;
        };

        p.unicode = function() {
            // expect iso8859 input, unicode output
            var e = URI.encode;
            var d = URI.decode;

            URI.encode = strictEncodeURIComponent;
            URI.decode = unescape;
            this.normalize();
            URI.encode = e;
            URI.decode = d;
            return this;
        };

        p.readable = function() {
            var uri = this.clone();
            // removing username, password, because they shouldn't be displayed according to RFC 3986
            uri.username('').password('').normalize();
            var t = '';
            if (uri._parts.protocol) {
                t += uri._parts.protocol + '://';
            }

            if (uri._parts.hostname) {
                if (uri.is('punycode') && punycode) {
                    t += punycode.toUnicode(uri._parts.hostname);
                    if (uri._parts.port) {
                        t += ':' + uri._parts.port;
                    }
                } else {
                    t += uri.host();
                }
            }

            if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
                t += '/';
            }

            t += uri.path(true);
            if (uri._parts.query) {
                var q = '';
                for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {
                    var kv = (qp[i] || '').split('=');
                    q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)
                            .replace(/&/g, '%26');

                    if (kv[1] !== undefined) {
                        q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)
                                .replace(/&/g, '%26');
                    }
                }
                t += '?' + q.substring(1);
            }

            t += URI.decodeQuery(uri.hash(), true);
            return t;
        };

        // resolving relative and absolute URLs
        p.absoluteTo = function(base) {
            var resolved = this.clone();
            var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
            var basedir, i, p;

            if (this._parts.urn) {
                throw new Error('URNs do not have any generally defined hierarchical components');
            }

            if (!(base instanceof URI)) {
                base = new URI(base);
            }

            if (!resolved._parts.protocol) {
                resolved._parts.protocol = base._parts.protocol;
            }

            if (this._parts.hostname) {
                return resolved;
            }

            for (i = 0; (p = properties[i]); i++) {
                resolved._parts[p] = base._parts[p];
            }

            if (!resolved._parts.path) {
                resolved._parts.path = base._parts.path;
                if (!resolved._parts.query) {
                    resolved._parts.query = base._parts.query;
                }
            } else if (resolved._parts.path.substring(-2) === '..') {
                resolved._parts.path += '/';
            }

            if (resolved.path().charAt(0) !== '/') {
                basedir = base.directory();
                resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
                resolved.normalizePath();
            }

            resolved.build();
            return resolved;
        };
        p.relativeTo = function(base) {
            var relative = this.clone().normalize();
            var relativeParts, baseParts, common, relativePath, basePath;

            if (relative._parts.urn) {
                throw new Error('URNs do not have any generally defined hierarchical components');
            }

            base = new URI(base).normalize();
            relativeParts = relative._parts;
            baseParts = base._parts;
            relativePath = relative.path();
            basePath = base.path();

            if (relativePath.charAt(0) !== '/') {
                throw new Error('URI is already relative');
            }

            if (basePath.charAt(0) !== '/') {
                throw new Error('Cannot calculate a URI relative to another relative URI');
            }

            if (relativeParts.protocol === baseParts.protocol) {
                relativeParts.protocol = null;
            }

            if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
                return relative.build();
            }

            if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
                return relative.build();
            }

            if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
                relativeParts.hostname = null;
                relativeParts.port = null;
            } else {
                return relative.build();
            }

            if (relativePath === basePath) {
                relativeParts.path = '';
                return relative.build();
            }

            // determine common sub path
            common = URI.commonPath(relative.path(), base.path());

            // If the paths have nothing in common, return a relative URL with the absolute path.
            if (!common) {
                return relative.build();
            }

            var parents = baseParts.path
                .substring(common.length)
                .replace(/[^\/]*$/, '')
                .replace(/.*?\//g, '../');

            relativeParts.path = parents + relativeParts.path.substring(common.length);

            return relative.build();
        };

        // comparing URIs
        p.equals = function(uri) {
            var one = this.clone();
            var two = new URI(uri);
            var one_map = {};
            var two_map = {};
            var checked = {};
            var one_query, two_query, key;

            one.normalize();
            two.normalize();

            // exact match
            if (one.toString() === two.toString()) {
                return true;
            }

            // extract query string
            one_query = one.query();
            two_query = two.query();
            one.query('');
            two.query('');

            // definitely not equal if not even non-query parts match
            if (one.toString() !== two.toString()) {
                return false;
            }

            // query parameters have the same length, even if they're permuted
            if (one_query.length !== two_query.length) {
                return false;
            }

            one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
            two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);

            for (key in one_map) {
                if (hasOwn.call(one_map, key)) {
                    if (!isArray(one_map[key])) {
                        if (one_map[key] !== two_map[key]) {
                            return false;
                        }
                    } else if (!arraysEqual(one_map[key], two_map[key])) {
                        return false;
                    }

                    checked[key] = true;
                }
            }

            for (key in two_map) {
                if (hasOwn.call(two_map, key)) {
                    if (!checked[key]) {
                        // two contains a parameter not present in one
                        return false;
                    }
                }
            }

            return true;
        };

        // state
        p.duplicateQueryParameters = function(v) {
            this._parts.duplicateQueryParameters = !!v;
            return this;
        };

        p.escapeQuerySpace = function(v) {
            this._parts.escapeQuerySpace = !!v;
            return this;
        };

        return URI;
    }));
/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:uri', location = 'libs/uri.js' */
define("jira/components/libs/uri", [
    "atlassian/libs/uri-1.14.1"
], function(
    URI
) {
    "use strict";

    return URI;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:browser', location = 'util/Browser.js' */
define("jira/components/util/browser", function () {
    "use strict";

    return {
        locationReload: function(forceGet) {
            window.location.reload(forceGet);
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/entities/PanelModel.js' */
define("jira/components/issueviewer/entities/panel", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var Events = require('jira/util/events');
    var Types = require('jira/components/issueviewer/eventtypes');

    /**
     * @class JIRA.Components.IssueViewer.Models.Panel
     *
     * Model for a panel, used by PanelsView
     *
     * @extends JIRA.Issues.Brace.Model
     */
    return Brace.Model.extend({

        namedAttributes: [
        /**
         * Contains information about the panel
         * @type {Object}
         */
            "entity",

        /**
         * Prevent panel from being updated
         * @type {boolean}
         */
            "updateLocked"
        ],

        /**
         * @constructor
         *
         * Initializes this model
         */
        initialize: function() {
            // Allowing panels to opt out of refreshing (for example a comment might be half written, we don't want to replace it.)
            Events.bind(Types.LOCK_PANEL_REFRESHING, _.bind(function(e, id) {
                if (id === this.getEntity().id) {
                    this.set("updateLocked", true);
                }
            }, this));
            Events.bind(Types.UNLOCK_PANEL_REFRESHING, _.bind(function(e, id) {
                if (id === this.getEntity().id) {
                    this.set("updateLocked", false);
                }
            }, this));
        },

        /**
         * Updates panel entity from new data
         *
         * @param {Object} entity
         * @param {Object} fieldsInProgress
         * @param {Object} fieldsSaved
         */
        update: function(entity, fieldsInProgress, fieldsSaved) {
            if (!this.getUpdateLocked()) {
                this.set("entity", entity);
                this.trigger("updated", fieldsInProgress, fieldsSaved);
            }
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/entities/PanelsCollection.js' */
define("jira/components/issueviewer/entities/panels", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var Panel = require("jira/components/issueviewer/entities/panel");

    /**
     * @class JIRA.Components.IssueViewer.Collections.Panels
     *
     * Collection of panels, rendered by PanelsView
     *
     * @extend JIRA.Issues.Brace.Collections
     */
    return Brace.Collection.extend({

        model: Panel,

        /**
         * Update this collection of panels with new data
         *
         * @param {Object} data Array of entities, each entity represents a panel
         * @param {Object} options
         * @param {string[]} options.fieldsInProgress List of fields that are in progress
         * @param {string[]} options.fieldsSaved List of fields that we just saved
         */
        update: function(data, options) {
            // For each panel already present in this collection, check if it is still present in data.
            // If not, remove it from the collection.
            this.each(function(panel) {
                var panelId = panel.id;
                var panelPresentInPanelEntities = _.any(data, function(panel) {
                    return panel.id === panelId;
                });
                if (!panelPresentInPanelEntities) {
                    this.remove(panel);
                }
            }, this);

            // For each ponel in data, check if there is already present in the collection. If it is, update it
            // with the new data. If not, add it to the collection.
            _.each(data, function(entity, index) {
                var panel = this.get(entity.id);
                if (panel) {
                    panel.update(entity, options.fieldsInProgress, options.fieldsSaved);
                } else {
                    this.add({id: entity.id, entity: entity}, {at: index});
                }
            }, this);
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/entities/PanelsGroupModel.js' */
define("jira/components/issueviewer/entities/panelsgroup", ["require"], function(require){
    "use strict";

    var Brace = require("jira/components/libs/brace");
    var Panels = require("jira/components/issueviewer/entities/panels");

    /**
     * @class JIRA.Components.IssueViewer.Models.PanelsGroup
     *
     * This model contain groups of panels. It is used by BodyView to represent the left panels, right panels
     * and info panels.
     *
     * @extends JIRA.Issues.Brace.Model
     */
    return Brace.Model.extend({

        namedAttributes: [
        /**
         * Panels on the left side
         * @type JIRA.Components.IssueViewer.Collections.Panels
         */
            "leftPanels",

        /**
         * Panels on the right side
         * @type JIRA.Components.IssueViewer.Collections.Panels
         */
            "rightPanels",

        /**
         * Panels in the middle of the view
         * @type JIRA.Components.IssueViewer.Collections.Panels
         */
            "infoPanels"
        ],

        defaults: function() {
            //This needs to be a function because otherwise the IssuePanelsCollection instances
            //will be shared among all instances of IssuePanelsGroupModel
            return {
                leftPanels: new Panels([]),
                rightPanels: new Panels([]),
                infoPanels: new Panels([])
            };
        },

        /**
         * Updates all the panel models with new data. Creates new ones that don't exist yet.
         *
         * @param {Object} data
         * @param {Object[]} data.leftPanels  Panels for the left group
         * @param {Object[]} data.rightPanels Panels for the right group
         * @param {Object[]} data.infoPanels  Panels for the info group
         * @param {Object} options
         */
        update: function(data, options) {
            //TODO options is here only to carry the value of 'fieldsInProgress' and 'fieldsSaved' to IssuePanelView.
            //It is a long journey through lot of layers, we should find another way to do it.

            this.get("leftPanels").update(data.leftPanels, options);
            this.get("rightPanels").update(data.rightPanels, options);
            this.get("infoPanels").update(data.infoPanels, options);
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/entities/IssueModel.js' */
define("jira/components/issueviewer/entities/issue", ["require"], function(require){
    "use strict";

    var Brace = require("jira/components/libs/brace");
    var PanelsGroup = require("jira/components/issueviewer/entities/panelsgroup");

    /**
     * @class JIRA.Components.IssueViewer.Models.Issue
     *
     * Model for the IssueView. It represents an issue, although most of the important fields
     * are inside the 'entity' object, not in a property of this model.
     *
     * @extends JIRA.Issues.Brace.Model
     */
     return Brace.Model.extend({

        namedEvents: [
        /**
         * @event updated
         * Triggered when the view issue model is updated with data from server. This is the main event
         * used by the related views to known when they should refresh the rendered data.
         */
            "updated"
        ],

        namedAttributes: [
        /**
         * Contains information about the issue, including summary and issue operations
         * @type {Object}
         */
            "entity",

        /**
         * Issue id
         * @type {number}
         */
            "id",

        /**
         * Issue key
         * @type {string}
         */
            "key",

        /**
         * Representing web panels for this issue
         * @type {JIRA.Components.IssueViewer.Models.PanelsGroup}
         */
            "panels"
        ],

        /**
         * Default values for this model
         * @returns {Object} Object with default data
         */
        defaults: function() {
            return {
                entity: {},
                panels: new PanelsGroup()
            };
        },

        /**
         * Updates entity and panels with new data
         *
         * @param {Object} data
         * @param {Object} options
         * @param {string[]} [options.fieldsSaved]      The update may come as the result of a save. This array includes the ids of any fields that may have been saved before hand.
         * @param {string[]} [options.fieldsInProgress] Array of fields that are still in edit mode or still saving.
         * @param {boolean}  [options.initialize]       Parameter indicating if it is the first time the update has been called.
         * @param {Object}   [options.changed]          Changed data since last update
         * @param {boolean}  [options.mergeIntoCurrent] Parameter indicating if the data should be merged into current data
         *
         * //TODO initialize, changed and mergeIntoCurrent are used only by IssueHeaderView. Seems this could be simplified.
         */
        update: function(data, options) {
            var updated = false;

            // If we have new data about the issue, update the entity
            if (data.issue) {
                this.updateFromEntity(data.issue);
                updated = true;
            }

            // If we have new data about the panels, update them
            if (data.panels) {
                this.getPanels().update(data.panels, options);
                updated = true;
            }

            // If something has been updated, trigger the "updated" event so our views
            // can render the new content
            if (updated) {
                this.trigger("updated", options);
            }
        },

        /**
         * Clears this model, restoring the defaults.
         *
         * //TODO This should be moved to a higher class, it is a very common operation (that should be already
         * provided by backbone)
         */
        resetToDefault: function() {
            this.clear();
            this.set(this.defaults());
        },

        /**
         * Update our fields based on a new entity
         *
         * @param {Object} entity Object containing the issue information
         */
        updateFromEntity: function(entity) {
            this.set({
                id: entity.id,
                key: entity.key,
                entity: entity
            });
        },

        /**
         * Check if the provided id matches the current issue
         *
         * @param {string|number} issueId ID to check
         * @returns {boolean}
         */
        isCurrentIssue: function(issueId) {
            return this.get("id") === issueId;
        },

        /**
         * Check if this model contains an issue
         *
         * @returns {boolean}
         */
        hasIssue: function() {
            return this.has("id");
        },

        /**
         * Updates the model with a new issueQuery
         *
         * @param {string} query New query
         */
        updateIssueQuery: function(query) {
            if (!this.hasIssue()) return;
            this.getEntity().viewIssueQuery = query;
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/views/issue/IssuePanelView.js' */
define("jira/components/issueviewer/views/issuepanel", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Events = require('jira/util/events');
    var IssueFieldUtil = require("jira/components/issueviewer/legacy/issuefieldutil");
    var jQuery = require("jquery");
    var MarionetteItemView = require('jira/components/libs/marionette-1.4.1/itemview');
    var Reasons = require('jira/util/events/reasons');
    var Templates = require("jira/components/issueviewer/templates");
    var Types = require('jira/components/issueviewer/eventtypes');

    /**
     * @class JIRA.Components.IssueViewer.Views.IssuePanel
     *
     * View for rendering a panel
     *
     * @extends JIRA.Marionette.ItemView
     */
    return MarionetteItemView.extend({

        template: Templates.Body.issuePanel,

        modelEvents: {
            "updated": "update"
        },

        /**
         * Update this view with the new data from our model
         *
         * If edits are in progress will replace only elements that have been saved
         * If no edits are in progress will replace entire panel.
         *
         * @param {string[]} fieldsInProgress IDs for fields that are still in progress
         * @param {string[]} fieldsSaved IDs for fields that we just saved
         */
        update: function(fieldsInProgress, fieldsSaved) {
            var $new = this.renderTemplate();
            var $existing = this.$el;
            var instance = this;

            // TODO: validate if the below ie8 check is still necessary (NEXT-382)
            // Replacing panel content can be VERY expensive in ie8 (sometimes 7 seconds) so we only want to update
            // if the content has changed
            // NOTE: We check for the existence of an iframe, which indicates an Atlassian Connect panel. We always refresh
            // an AC panel.
            if ($existing.find('iframe').length === 0 && $new.text() === $existing.text()) {
                return;
            }

            // Check if there is a field in progress inside this panel
            function hasFieldInProgress() {
                return _.any(fieldsInProgress, function(id) {
                    return $existing.find(IssueFieldUtil.getFieldSelector(id)).length === 1;
                });
            }

            // Replace the whole panel
            function replacePanel() {
                var panelHadFocus = $existing.find(document.activeElement).length > 0;

                // For unknown reason, jQuery's replaceWith does not work for IE8 in some cases.
                // I suspect it is related to the fact both this.$el and updatedDom.$el are a collection of *two* elements
                // This quick hack (that mostly mimics the replaceWith() implementation) works.
                var isIe8 = !!jQuery.browser.msie && jQuery.browser.version <= 8;
                if (!isIe8) {
                    $existing.replaceWith($new);
                } else {
                    var next = $existing[0].nextSibling;
                    var parent = $existing[0].parentNode;
                    $existing.remove();

                    if (next) {
                        jQuery(next).before($new);
                    } else {
                        jQuery(parent).append($new);
                    }
                }

                if (panelHadFocus) {
                    instance.trigger("replacedFocusedPanel");
                }
                instance.setElement($new);
            }

            // Trigger the internal and JIRA events related to this view
            function triggerEvents(updatedElements) {
                var modelId = instance.model.id;
                var $el = instance.$el;

                instance.trigger("panelRendered", modelId, $el);
                Events.trigger(Types.PANEL_REFRESHED, [modelId, $el, $existing]);
                _.each(updatedElements, function(updatedElement) {
                    Events.trigger(Types.NEW_CONTENT_ADDED, [updatedElement, Reasons.panelRefreshed]);
                });
            }

            if (!hasFieldInProgress()) {
                //If no field is in progress, just replace the whole panel
                replacePanel();
                triggerEvents([instance.$el]);
            } else {
                var updates = [];
                _.each(fieldsSaved, function(id) {
                    var $toReplace = $existing.find(IssueFieldUtil.getFieldSelector(id));
                    if ($toReplace.length === 1) {
                        var $replaceWith = $new.find(IssueFieldUtil.getFieldSelector(id));
                        if ($replaceWith.length === 1) {
                            // The field has been saved and we need to display the new value, replace it
                            $toReplace.replaceWith($replaceWith);
                            updates.push($replaceWith);
                        } else {
                            // Remove field if it's not present in the new panel
                            // Assumes the field's container in the panel - may not work properly with plugin panels.
                            // TODO: add a class to the container to find it more reliably.
                            $toReplace.closest('li, dl').remove();
                        }
                    }
                });
                triggerEvents(updates);
            }

            this.bindUIElements();
        },

        /**
         * Handler for render events, things to do after the template has been rendered
         */
        onRender: function() {
            // Discard the root element created by Backbone
            this.setElement(this.$el.children());

            // If we have a style class, apply it
            var styleClass = this.model.getEntity().styleClass;
            if (styleClass) {
                this.$el.addClass(styleClass);
            }

            Events.trigger(Types.NEW_CONTENT_ADDED, [this.$el, Reasons.panelRefreshed]);
        },

        /**
         * Extract the data from the model in the format needed by the template
         *
         * @returns {Object} Data to be rendered by the template
         */
        serializeData: function() {
            return this.model.getEntity();
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/views/issue/IssuePanelsView.js' */
define("jira/components/issueviewer/views/issuepanels", ["require"], function(require){
    "use strict";

    var MarionetteCollectionView = require('jira/components/libs/marionette-1.4.1/collectionview');
    var IssuePanel = require("jira/components/issueviewer/views/issuepanel");
    var PanelModel = require("jira/components/issueviewer/entities/panel");
    var escapeCssIdSelector = require("jira/components/util/jquery/escapecssidselector");

    /**
     * @class JIRA.Components.IssueViewer.Views.IssuePanels
     *
     * This view is used to render a collection of panels
     *
     * @extends Marionette.CollectionView
     */
    return MarionetteCollectionView.extend({

        itemView: IssuePanel,

        /**
         * Flag to known if we are updating from the DOM or rendering from a template.
         */
        _updatingFromDom: false,

        /**
         * Override Marionette's appendHtml to not ignore the index (why the default implementation ignores a documented
         * parameter?)
         *
         * See https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.collectionview.md#collectionviews-appendhtml
         *
         * @param {JIRA.Components.IssueViewer.Views.IssuePanels} collectionView This view
         * @param {JIRA.Components.IssueViewer.Views.IssuePanel} itemView View being added
         * @param {number} index Position of the itemView
         */
        appendHtml: function(collectionView, itemView, index) {
            var children = collectionView.$el.children();
            var childrenLength = children.length;

            if (index <= 0) {
                // If we want to insert the element at the beginning, just prepend it.
                collectionView.$el.prepend(itemView.$el);
            } else if (!childrenLength || index >= childrenLength) {
                // If the collection has no children, or the desired position is bigger than the number of children,
                // append it to the end
                collectionView.$el.append(itemView.$el);
            } else {
                // Insert the child at the requested index
                itemView.$el.insertBefore(children.eq(index));
            }
        },

        /**
         * Update this view with a pre-rendered markup
         */
        applyToDom: function() {
            var instance = this;

            // We need to use this flag to prevent renderItemView() and buildItemView() to destroy
            // the existing markup
            this._updatingFromDom = true;

            // For each rendered module, capture the ID and add an item to our model, so upcoming updates
            // can address the right panel
            this.$el.children().filter('.module').each(function() {
                var id = this.id;
                if (id === "addcomment") {
                    // The id in the DOM is different to the entityId
                    id = "addcommentmodule";
                }
                instance.collection.add(new PanelModel({
                    id: id,
                    entity: {id: id}
                }));
            });

            this._updatingFromDom = false;
        },

        /**
         * Renders the item view.
         *
         * Overrides Marionette's implementation to avoid rendering the item if we are updating from the DOM
         */
        renderItemView: function() {
            if (!this._updatingFromDom) {
                MarionetteCollectionView.prototype.renderItemView.apply(this, arguments);
            }
        },

        /**
         * Creates the view instance used to render the item.
         *
         * Overrides Marionette's implementation to use the pre-rendered DOM element if we are updating from the DOM.
         *
         * @param {JIRA.Components.IssueViewer.Models.Panel} item Model used by the item view
         * @returns {JIRA.Components.IssueViewer.Views.IssuePanel}
         */
        buildItemView: function(item) {
            var view = MarionetteCollectionView.prototype.buildItemView.apply(this, arguments);
            if (this._updatingFromDom) {
                view.setElement(this.$el.find(escapeCssIdSelector(item.id)));
            }
            return view;
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/views/issue/IssueBodyView.js' */
define("jira/components/issueviewer/views/issuebody", ["require"], function(require){
    "use strict";

    var MarionetteLayout = require('jira/components/libs/marionette-1.4.1/layout');
    var MarionetteLinkRegion = require("jira/components/libs/marionette-1.4.1/linkregion");
    var Templates = require("jira/components/issueviewer/templates");

    /**
     * @class JIRA.Components.IssueViewer.Views.IssueBody
     *
     * View used to render the body of an issue. It uses the model JIRA.Components.IssueViewer.Models.Issue.
     * This view is just a container for panels, it does not render any data by itself.
     *
     * @extend JIRA.Marionette.Layout
     */
     return MarionetteLayout.extend({
        tagName: "div",

        className: "issue-body-content",

        regions: {
            leftPanels: {
                selector: ".issue-main-column",
                regionType: MarionetteLinkRegion
            },
            rightPanels: {
                selector: ".issue-side-column",
                regionType: MarionetteLinkRegion
            },
            infoPanels: {
                selector: ".issue-body",
                regionType: MarionetteLinkRegion
            }
        },

        template: Templates.Body.issueBody
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/views/issue/IssueOpsbarView.js' */
define("jira/components/issueviewer/views/issueopsbar", ["require", "jira/components/issueviewer/analytics/issueopsbar"], function(require, Analytics){
    "use strict";

    var MarionetteItemView = require('jira/components/libs/marionette-1.4.1/itemview');
    var Templates = require("jira/components/issueviewer/templates");
    var Tipsy = require("jira/issues/tipsy");

    /**
     * @class JIRA.Components.IssueViewer.Views.IssueOpsbar
     *
     * This view renders the operations bar of an issue (i.e. the buttons and dropdowns in the header)
     *
     * @extends JIRA.Marionette.ItemView
     */
     return MarionetteItemView.extend({

        template: Templates.Header.opsbar,

        ui: {
            shareButton: ".viewissue-share",
            exportButton: "#viewissue-export",
            loginButton: "#ops-login-lnk",
            commentButton: "#comment-issue"
        },

        /**
         * Extract the data from the model in the format needed by the template
         *
         * @returns {Object} Data to be rendered by the template
         */
        serializeData: function() {
            return {issue: this.model.getEntity()};
        },

        /**
         * Handler for applyToDom event, things to do after $el has been loaded from the DOM
         */
        onApplyToDom: function() {
            this.onRender();
        },

        /**
         * Handler for render event, things to do after the template has been rendered
         */
        onRender: function() {
            //TODO Why do we need to mess with the DOM here? Can we move these changes to the template?

            new Analytics(this);

            // Hide the login button
            this.ui.loginButton.hide();

            // Ensure the comment button does not display the add comment dialog
            this.ui.commentButton.addClass("inline-comment");

            // Add the tipsy to the share button
            new Tipsy({
                el: this.ui.shareButton,
                showCondition: ":not(.active)"
            });

            // Add the tipsy to the export button
            new Tipsy({
                el: this.ui.exportButton,
                showCondition: ":not(.active)",
                tipsy: {
                    gravity: "ne"
                }
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/views/issue/IssueHeaderView.js' */
define("jira/components/issueviewer/views/issueheader", ["require"], function(require){
    "use strict";

    var MarionetteLayout = require('jira/components/libs/marionette-1.4.1/layout');
    var Templates = require("jira/components/issueviewer/templates");
    var DarkFeatures = require("jira/components/issueviewer/services/darkfeatures");
    var _ = require("jira/components/libs/underscore");
    var IssueOpsbar = require("jira/components/issueviewer/views/issueopsbar");
    var Events = require('jira/util/events');
    var Types = require('jira/components/issueviewer/eventtypes');
    var Meta = require("jira/util/data/meta");
    var Reasons = require('jira/util/events/reasons');

    /**
     * @class JIRA.Components.IssueViewer.Views.IssueHeader
     *
     * View for rendering the header of an issue. It renders key, summary, breadcrumbs... plus the opsbar and pager as
     * regions
     *
     * @extends JIRA.Marionette.Layout
     */
     return MarionetteLayout.extend({
        className: "issue-header js-stalker",

        id: "stalker",

        tagName: "header",

        template: Templates.Header.issueHeader,

        modelEvents: {
            "updated": "update"
        },

        regions: {
            opsbar: ".command-bar",
            pager: "#issue-header-pager"
        },

        /**
         * Extract the data from the model in the format needed by the template
         *
         * @returns {Object} Data to be rendered by the template
         */
        serializeData: function() {
            return {
                issue: this.model.getEntity(),
                hasProjectShortcut: DarkFeatures.PROJECT_SHORTCUTS.enabled()
            };
        },

        /**
         * Update this view with new data
         *
         * @param options
         */
        update: function(options) {
            if (options.initialize) {
                this._updateWindowTitle();
            } else {
                var editingSummary = _.include(options.fieldsInProgress, "summary");
                if (editingSummary) {
                    this.renderOpsBar();
                } else {
                    this.render();
                }
            }
            this.trigger("updated");
        },

        /**
         * Handler for applyToDom event, things to do after $el has been loaded from the DOM
         */
        onApplyToDom: function() {
            var view = new IssueOpsbar({model: this.model});
            // Since ops bar already is in the dom, we should use the current dom data as the view's element
            view.setElement(this.opsbar.el);
            this.opsbar.attachView(view);
            this.opsbar.currentView.applyToDom();
        },

        /**
         * Handler for render event, things to do after the template has been rendered
         */
        onRender: function() {
            this.renderOpsBar();
            this._updateWindowTitle();
            this.trigger("panelRendered", "header", this.$el);
        },

        /**
         * Render the operations bar
         *
         * //TODO This composition should be done by the IssueController
         */
        renderOpsBar: function() {
            this.opsbar.show(new IssueOpsbar({model: this.model}));
            //TODO This event should be thrown by the IssueController
            Events.trigger(Types.NEW_CONTENT_ADDED, [this.$el, Reasons.panelRefreshed]);
        },

        /**
         * Updates the window title to contain information about the issue
         *
         * @private
         */
        _updateWindowTitle: function() {
            var entity = this.model.getEntity();
            var key = entity.key;
            var summary = entity.summary;
            var appTitle = Meta.get("app-title");

            if (appTitle && summary && key) {
                document.title = "[" + key + "] " + summary + " - " + appTitle;
            }
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/views/issue/IssueView.js' */
define("jira/components/issueviewer/views/issue", ["require"], function(require){
    "use strict";

    var MarionetteLayout = require('jira/components/libs/marionette-1.4.1/layout');
    var Templates = require("jira/components/issueviewer/templates");
    var ReplaceRegion = require('jira/components/libs/marionette-1.4.1/replaceregion');
    var Actions = require("jira/components/issueviewer/actions");
    var Events = require('jira/util/events');
    var Types = require('jira/components/issueviewer/eventtypes');
    var Reasons = require('jira/util/events/reasons');
    var jQuery = require("jquery");

    /**
     * @class JIRA.Components.IssueViewer.Views.Issue
     *
     * Main view for rendering an issue
     *
     * @extends JIRA.Marionette.Layout
     */
    return MarionetteLayout.extend({
        template: Templates.layout,

        className: "issue-container",

        regions: {
            header: {
                selector: ".issue-header-container",
                regionType: ReplaceRegion
            },
            body: {
                selector: ".issue-body-container",
                regionType: ReplaceRegion
            }
        },

        modelEvents: {
            "updated": "update"
        },

        /**
         * Show the loading indication
         */
        showLoading: function() {
            this.$el.addClass("loading");
        },

        /**
         * Hide the loading indication
         */
        hideLoading: function() {
            this.$el.removeClass("loading");
        },

        /**
         * Focus a comment
         *
         * @param {string} commentId Comment to focus
         */
        focusComment: function(commentId) {
            this.$("#activitymodule .focused").removeClass("focused");
            this.$("#comment-" + commentId).addClass("focused");
            this.$(".js-stalker").trigger("refresh");
        },

        /**
         * Update this view with the data form the model
         *
         * @param props
         */
        update: function(props) {
            // Only render this view if this is the initial view.
            if (props.initialize) {
                this.render();
            }

            // If a comment has been edited, focus it
            if (props.reason && props.reason.action === Actions.EDIT_COMMENT) {
                this.focusComment(props.reason.meta.commentId);
            }

            this._bringViewIssueElementIntoView();
        },

        /**
         * Remove the view
         *
         * Override Backbone's method, as we don't want to remove the container from the view.
         *
         * @returns {*}
         */
        remove: function() {
            this.stopListening();
            this.$el.empty();
            return this;
        },

        /**
         * Handler for render events, things to do after the template has been rendered
         */
        onRender: function() {
            // $el could have been modified outside this view, we need to restore the className
            this.$el.addClass(this.className);
            this.$el.attr("tabindex", "-1");
            this._bringViewIssueElementIntoView();

            Events.trigger(Types.NEW_CONTENT_ADDED, [this.$el, Reasons.pageLoad]);
            if (Types.REFRESH_TOGGLE_BLOCKS) {
                Events.trigger(Types.REFRESH_TOGGLE_BLOCKS, [this.model.getId()]);
            }
        },

        onApplyToDom: function() {
            this._bringViewIssueElementIntoView();
        },

        /**
         * Bring some parts of the issue into view (eg: scrolls to focused comment)
         *
         * @private
         */
        _bringViewIssueElementIntoView: function() {
            var viewIssueQuery = this.model.get("entity").viewIssueQuery;
            if (viewIssueQuery) {
                var elementSelector;
                if (viewIssueQuery.focusedCommentId) {
                    elementSelector = "#comment-" + viewIssueQuery.focusedCommentId;
                } else if (viewIssueQuery.attachmentSortBy || viewIssueQuery.attachmentOrder || viewIssueQuery.attachmentViewMode) {
                    elementSelector = "#attachmentmodule";
                }

                if (elementSelector) {
                    jQuery(elementSelector).scrollIntoView({
                        marginBottom: 200,
                        marginTop: 200
                    });
                }
            }
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/views/error/ErrorView.js' */
define("jira/components/issueviewer/views/error", ["require"], function(require){
    "use strict";

    var MarionetteLayout = require('jira/components/libs/marionette-1.4.1/layout');

    /**
     * @class JIRA.Components.IssueViewer.Views.Error
     * Abstract class for all error views
     *
     * @extends JIRA.Marionette.Layout
     * @abstract
     *
     * //TODO Review ReturnToSearch functionality, some WD tests are failing
     */
    return MarionetteLayout.extend({

        className: "issue-container",

        regions: {
            pager: "#issue-header-pager"
        },

        /**
         * Remove the view
         *
         * Override Backbone's method, as we don't want to remove the container from the view.
         *
         * @return {JIRA.Components.IssueViewer.Views.Error} this
         */
        remove: function() {
            this.stopListening();
            this.$el.empty();
            return this;
        },

        /**
         * Handler for render event
         */
        onRender: function() {
            // $el has been modified outside this view, we need to restore the className
            this.$el.addClass(this.className);
            this.$el.attr("tabindex", "-1");
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/views/error/ErrorGenericView.js' */
define("jira/components/issueviewer/views/errorgeneric", ["require"], function(require){
    "use strict";

    var GenericError = require("jira/components/issueviewer/views/error");
    var Templates = require("jira/components/issueviewer/templates");
    var Browser = require("jira/components/util/browser");

    /**
     * @class JIRA.Components.IssueViewer.Views.ErrorGeneric
     * Renders a generic error
     *
     * @extends JIRA.Components.IssueViewer.Views.Error
     */
    return GenericError.extend({
        template: Templates.Error.Generic,
        events: {
            "click #issue-error-reload-button": function() {
                Browser.locationReload();
            }
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/views/error/ErrorNotFoundView.js' */
define("jira/components/issueviewer/views/errornotfound", ["require"], function(require){
    "use strict";

    var GenericError = require("jira/components/issueviewer/views/error");
    var Templates = require("jira/components/issueviewer/templates");
    var _ = require("jira/components/libs/underscore");

    /**
     * @class JIRA.Components.IssueViewer.Views.ErrorNotFound
     * Renders the error for a NotFound issue
     *
     * @extends JIRA.Components.IssueViewer.Views.Error
     */
    return GenericError.extend({
        template: Templates.Error.DoesNotExist,

        /**
         * Initializes this view
         *
         * @param options
         * @param {boolean|function} [options.showReturnToSearchOnError=false] Whether the error views should display a 'Return to Search' link
         */
        initialize: function(options) {
            options = options || {};
            this.showReturnToSearchOnError = options.showReturnToSearchOnError;
        },

        triggers: {
            "click #return-to-search": "returnToSearch"
        },

        serializeData: function() {
            var showReturnToSearchOnError = this.showReturnToSearchOnError;
            if (_.isFunction(showReturnToSearchOnError)) {
                showReturnToSearchOnError = showReturnToSearchOnError();
            }

            return {
                hideReturnToSearch: !showReturnToSearchOnError
            };
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/controllers/IssueController.js' */
define("jira/components/issueviewer/controllers/issue", ["require"], function(require){
    "use strict";

    var CommentForm = JIRA.Issue.CommentForm;
    var IssueBody = require("jira/components/issueviewer/views/issuebody");
    var IssueHeader = require("jira/components/issueviewer/views/issueheader");
    var IssuePanels = require("jira/components/issueviewer/views/issuepanels");
    var IssueView = require("jira/components/issueviewer/views/issue");
    var MarionetteController = require("jira/components/libs/marionette-1.4.1/controller");

    /**
     * @class JIRA.Components.IssueViewer.Controllers.Issue
     *
     * Controller for the issue viewer
     *
     * This controller is a mediator for JIRA.Components.IssueViewer.Views.Issue. It is responsible of creating the view,
     * updating the view from a pre-rendered DOM and rendering the view. It also creates all the subviews and composes
     * the layout.
     *
     * @extends Marionette.Controller
     */
    return MarionetteController.extend({
        /**
         * @event replacedFocusedPanel
         * Triggered when the view has rendered a panel that has the focus
         */

        /**
         * @event panelRendered
         * Triggered when the view has rendered a panel
         * @param {string} panelId ID of the panel
         * @param {jQuery} $ctx The new panel element
         */

        /**
         * @constructor
         * @param {Object} options
         * @param {JIRA.Components.IssueViewer.Models.Issue} options.model Model used by this view
         */
        initialize: function(options) {
            this.model = options.model;
        },

        /**
         * Creates the main view and all the subviews
         *
         * @private
         */
        _createViews: function() {
            this.view = this._createMainView();
            this.bodyView = this._createBodyView();
            this.headerView = this._createHeaderView();
            this.leftPanelsView = this._createPanelsView(this.model.getPanels().getLeftPanels());
            this.rightPanelsView = this._createPanelsView(this.model.getPanels().getRightPanels());
            this.infoPanelsView = this._createPanelsView(this.model.getPanels().getInfoPanels());
        },

        /**
         * Creates the main view. It is just a container for HeaderView and BodyView
         *
         * @returns {JIRA.Components.IssueViewer.Views.Issue}
         * @private
         */
        _createMainView: function() {
            return new IssueView({
                model: this.model,
                el: this.$el
            });
        },

        /**
         * Creates the view for rendering the body of the issue. It is just a collection of panels
         *
         * @returns {JIRA.Components.IssueViewer.Views.IssueBody}
         * @private
         */
        _createBodyView: function() {
            return new IssueBody({
                model: this.model
            });
        },

        /**
         * Creates the view for rendering the header. It includes regions for the opsbar and the pager
         *
         * @returns {JIRA.Components.IssueViewer.Views.IssueHeader}
         * @private
         */
        _createHeaderView: function() {
            var view = new IssueHeader({
                model: this.model
            });
            this.listenAndRethrow(view, "panelRendered");

            this.listenTo(view, "updated", function() {
                this.trigger("render", {pager: this.view.$(this.headerView.pager.el)}, {issueId: this.model.getId()});
            });

            return view;
        },

        /**
         * Creates the view for the panels. This view renders a collection of panels. The BodyView contains three
         * views of this kind: left panels, right panels and info panels.
         *
         * @param {JIRA.Components.IssueViewer.Collections.Panels} collection Collection of panels to render
         * @returns {JIRA.Components.IssueViewer.Views.IssuePanels}
         * @private
         */
        _createPanelsView: function(collection) {
            var view = new IssuePanels({
                collection: collection
            });
            this.listenTo(view, "itemview:replacedFocusedPanel", function() {
                this.trigger("replacedFocusedPanel");
            });
            this.listenTo(view, "itemview:panelRendered", function(view, panelId, $ctx) {
                this.trigger("panelRendered", panelId, $ctx);
            });
            return view;
        },

        /**
         * Creates the view and composes the layout
         */
        createView: function() {
            this._createViews();

            // When main view is rendered, inject all the subviews
            // We need to wait until the main view is rendered because otherwise the regions are not defined
            this.listenTo(this.view, "render", function() {
                this.view.header.show(this.headerView);
                this.view.body.show(this.bodyView);

                this.bodyView.leftPanels.show(this.leftPanelsView);
                this.bodyView.rightPanels.show(this.rightPanelsView);
                this.bodyView.infoPanels.show(this.infoPanelsView);

                this.trigger("render", {pager: this.view.$(this.headerView.pager.el)}, {
                    loadedFromDom: false,
                    issueId: this.model.getId()
                });
            });
        },

        /**
         * Creates the view using a server-rendered markup
         */
        createViewFromDom: function() {
            this._createViews();

            // When the view is loaded from the dom, inject all the subviews and update them from the DOM
            this.listenTo(this.view, "applyToDom", function() {
                /**
                 * Helper method to inject a region and update it from the DOM.
                 * Maybe we can move it to JIRA.Marionette.Layout
                 *
                 * @param {Marionette.Region} region Region where the view should be inserted
                 * @param {Backbone.View} view View to render in the region
                 * @param {jQuery} el DOMElement that contains the pre-rendered markup for the view
                 * @ignore
                 */
                function updateRegionFromDom(region, view, el) {
                    view.setElement(el);
                    view.applyToDom();
                    region.attachView(view);
                }

                // The pre-rendered markup has not the same selector than the region.
                updateRegionFromDom(this.view.body, this.bodyView, this.view.$el.find(".issue-body-content"));
                updateRegionFromDom(this.view.body, this.headerView, this.view.$el.find("#stalker"));

                updateRegionFromDom(this.bodyView.leftPanels, this.leftPanelsView, this.bodyView.$el.find(this.bodyView.leftPanels.el));
                updateRegionFromDom(this.bodyView.rightPanels, this.rightPanelsView, this.bodyView.$el.find(this.bodyView.rightPanels.el));
                updateRegionFromDom(this.bodyView.infoPanels, this.infoPanelsView, this.bodyView.$el.find(this.bodyView.infoPanels.el));

                this.trigger("render", {pager: this.view.$(this.headerView.pager.el)}, {
                    loadedFromDom: true,
                    issueId: this.model.getId()
                });
            });
        },

        /**
         * Changes the element where the view should be rendered
         *
         * @param {jQuery} element Container for the view
         */
        setElement: function(element) {
            this.$el = element;
            if (this.view) {
                this.view.setElement(element);
            }
        },

        /**
         * Loads a view from server-rendered markup
         *
         * @param {Object} issueEntity
         */
        applyToDom: function(issueEntity) {
            issueEntity.id = +issueEntity.id; // Ensure value grabbed from DOM is converted into a number
            this.model.updateFromEntity(issueEntity);
            this.createViewFromDom();
            this.view.applyToDom();
        },

        /**
         * Displays the view
         */
        show: function() {
            if (!this.view) {
                this.createView();
                this.view.render();
            } else {
                this.trigger("render", {pager: this.view.$(this.headerView.pager.el)}, {
                    loadedFromDom: false,
                    issueId: this.model.getId()
                });
            }
            this.view.hideLoading();

        },

        /**
         * Closes the view
         */
        close: function() {
            if (this.view) {
                this.view.close();
            }
            this.hideLoading();
            delete this.view;
        },

        /**
         * Hides the loading spinner
         */
        hideLoading: function() {
            if (this.view) {
                this.view.hideLoading();
            }
        },

        /**
         * Shows the loading spinner
         */
        showLoading: function() {
            if (this.view) {
                this.view.showLoading();
            }
        },

        /**
         * Shows a dirty form warning if the comment field has been modified.
         *
         * @return {boolean} If user has opted to dismiss comment or not.
         */
        canDismissComment: function() {
            var dirtyMessage;
            var commentForm = CommentForm;
            if (!commentForm.getForm().data("dismissed")) {
                dirtyMessage = commentForm.handleBrowseAway();
                if (dirtyMessage) {
                  /*eslint-disable no-alert*/
                  if (!confirm(dirtyMessage)) {
                  /*eslint-enable no-alert*/
                    commentForm.focus();
                        return false;
                    } else {
                        commentForm.getForm().data("dismissed", true);
                    }
                }
            }
            return true;
        },

        applyResponsiveDesign: function() {
            if (!this.$el) return;

            var width = this.$el.width();
            this.$el.toggleClass("skinny", width < 900);
            this.$el.toggleClass("very-skinny", width < 600);
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/controllers/ErrorController.js' */
define("jira/components/issueviewer/controllers/error", ["require"], function(require){
    "use strict";

    var ErrorGeneric = require("jira/components/issueviewer/views/errorgeneric");
    var ErrorNotFound = require("jira/components/issueviewer/views/errornotfound");
    var MarionetteController = require("jira/components/libs/marionette-1.4.1/controller");
    var Utils = require("jira/components/issueviewer/utils");

    /**
     * @class JIRA.Components.IssueViewer.Controllers.Error
     *
     * Controller for the error pages
     *
     * @extends Marionette.Controller
     */
    return MarionetteController.extend({
        /**
         * @event before:render
         * Fired before rendering an error
         */

        /**
         * @event render
         * Fired after rendering an error
         */

        /**
         * @constructor
         * @param {Object} options
         * @param {string} options.contextPath ContextPath used to access the REST resources
         * @param {boolean|function} [options.showReturnToSearchOnError=false] Whether the error views should display a 'Return to Search' link
         */
        initialize: function(options) {
            this.contextPath = options.contextPath;
            this.showReturnToSearchOnError = options.showReturnToSearchOnError;
        },

        /**
         * Renders an error
         *
         * @param {string} type Error type, valid values are: "auth", "forbidden", "notfound" or "generic"
         * @param {string} issueKey IssueKey, used in the message of "auth" error
         */
        render: function(type, issueKey) {
            switch (type) {
                case "auth":
                    this._renderErrorAuth(issueKey);
                    break;

                case "forbidden":
                case "notfound":
                    this._renderErrorView(new ErrorNotFound({
                        showReturnToSearchOnError: this.showReturnToSearchOnError
                    }));
                    break;

                case "generic":
                /* falls through */
                default:
                    this._renderErrorView(new ErrorGeneric());
                    break;
            }
        },

        /**
         * Loads a view from server-rendered markup
         *
         * @param {string} type Error type, valid values are: "auth", "forbidden", "notfound" or "generic"
         * @param {string} issueKey IssueKey, used in the message of "auth" error
         */
        applyToDom: function(type, issueKey) {
            switch (type) {
                case "auth":
                    this._renderErrorAuth(issueKey);
                    break;

                case "forbidden":
                case "notfound":
                    this._renderErrorViewFromDom(new ErrorNotFound({
                        showReturnToSearchOnError: this.showReturnToSearchOnError
                    }));
                    break;

                case "generic":
                /* falls through */
                default:
                    this._renderErrorViewFromDom(new ErrorGeneric());
                    break;
            }
        },

        /**
         * Closes and deletes the view
         */
        close: function() {
            if (this.view) {
                this.view.close();
                delete this.view;
            }
        },

        /**
         * Changes the element where the view should be rendered
         *
         * @param {jQuery} element
         */
        setElement: function(element) {
            this._$el = element;
            if (this.view) {
                this.view.setElement(element);
            }
        },

        /**
         * Renders an authentication error. There is no view for this case, we just redirect the user to the login page
         *
         * @param {string} issueKey Issue key that raised the error
         * @private
         */
        _renderErrorAuth: function(issueKey) {
            // Redirect to the login page; will destroy stable search. This isn't ideal, but redirecting to
            // /browse/JRA-123 (as we were previously) results in a redirect loop in IE as we redirect to /i...
            var URL = this.contextPath + "/login.jsp?os_destination=" + encodeURIComponent("/browse/" + issueKey);
            window.location.replace(URL);
        },

        /**
         * Renders an error view.
         *
         * @param {JIRA.Components.IssueViewer.Views.Error} view View that needs to be rendered
         * @private
         */
        _renderErrorView: function(view) {
            this.trigger("before:render");

            Utils.hideDropdown();

            this.view = view;
            this.view.setElement(this._$el);
            this.view.render();
            this.listenAndRethrow(this.view, "returnToSearch");

            this.trigger("render", {
                pager: this.view.$(this.view.pager.el),
                isError: true
            }, {
                loadedFromDom: false,
                issueId: null
            });
        },

        /**
         * Renders an error view.
         *
         * @param {JIRA.Components.IssueViewer.Views.Error} view View that needs to be rendered
         * @private
         */
        _renderErrorViewFromDom: function(view) {
            this.trigger("before:render");

            Utils.hideDropdown();

            this.view = view;
            this.view.setElement(this._$el);
            this.view.applyToDom();
            this.listenAndRethrow(this.view, "returnToSearch");

            this.trigger("render", {
                pager: this.view.$(this.view.pager.el),
                isError: true
            }, {
                loadedFromDom: true,
                issueId: null
            });
        },

        isRendered: function() {
            return Boolean(this.view);
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/services/IssueLoaderService.js' */
define("jira/components/issueviewer/services/issueloader", ["require"], function(require){
    "use strict";

    var MarionetteController = require("jira/components/libs/marionette-1.4.1/controller");
    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var IssueFieldUtil = require("jira/components/issueviewer/legacy/issuefieldutil");

    /**
     * @class JIRA.Components.IssueViewer.Services.IssueLoader
     *
     * This service is responsible from loading data for an issue.
     *
     * @extends Marionette.Controller
     */
    return MarionetteController.extend({
        /**
         * @event issueLoaded
         * Fired when an issue has been loaded or updated
         * @param {Object} data
         * @param {Object} meta
         * @param {Object} options
         */

        /**
         * @event error
         * Fired when there is an error loading or updating the issue
         * @param {string} reason Type of error: "auth", "forbidden", "notfound" or "generic"
         * @param {Object} options
         */

        /**
         * @constructor
         */
        initialize: function() {
            this._promiseManager = new jQuery.RecurringPromise();

            this._updatingPromise = this._promiseManager.sub();
            this._updatingPromise
                .done(_.bind(this._onUpdatingDone, this))
                .fail(_.bind(this._onUpdatingError, this));

            this._loadingPromise = this._promiseManager.sub();
            this._loadingPromise
                .done(_.bind(this._onLoadingDone, this))
                .fail(_.bind(this._onLoadingError, this));
        },

        /**
         * Cancel all pending requests for our promises
         */
        cancel: function() {
            this._promiseManager.reset();
        },

        /**
         * Updates an issue
         *
         * @param {Object} options
         * @param {JIRA.Components.IssueViewer.Legacy.ViewIssueData} options.viewIssueData
         * @param {Object} options.issueEntity Issue entity to update
         * @param {boolean} options.mergeIntoCurrent whether the update should just merge into the current issue
         */
        update: function(options) {
            var issueEntity = options.issueEntity;
            var mergeIntoCurrent = options.mergeIntoCurrent;
            var viewIssueData = options.viewIssueData;
            var detailView = !!options.detailView;

            // Add the updating task to the recurring promise
            var deferred = new jQuery.Deferred();
            var recurrantControl;

            function genPromiseWrapper(taskKey) {
                return function() {
                    return {
                        taskKey: taskKey,
                        data: arguments,
                        startIssueLoad: new Date()
                    };
                };
            }

            recurrantControl = this._updatingPromise.add(viewIssueData.get(issueEntity.key, true, {
                issueEntity: issueEntity,
                loadingDeferred: deferred,
                mergeIntoCurrent: mergeIntoCurrent,
                startIssueLoad: new Date(),
                detailView: detailView // JRA-36659: keep track of whether we are in detail view
            }).pipe(genPromiseWrapper("issue"), genPromiseWrapper("issue")));

            recurrantControl.fail(function() {
                deferred.reject.apply(deferred, arguments);
            });

            return deferred.promise();
        },

        /**
         * Loads an issue
         *
         * @param {Object} options
         * @param {JIRA.Components.IssueViewer.Legacy.ViewIssueData} options.viewIssueData
         * @param {Object} options.issueEntity Issue entity to update

         * @returns {jQuery.Promise}
         */
        load: function(options) {
            var issueEntity = options.issueEntity;
            var viewIssueData = options.viewIssueData;
            var detailView = !!issueEntity.detailView;

            this._currentlyLoading = true;

            // Add the loading task to the recurring promise
            var deferred = new jQuery.Deferred();

            this._loadingPromise.add(viewIssueData.get(issueEntity.key, false, {
                issueEntity: issueEntity,
                loadFields: false,
                loadingDeferred: deferred,
                startIssueLoad: new Date(),
                detailView: detailView // JRA-36659: keep track of whether we are in detail view
            }));

            return deferred.promise();
        },

        /**
         * Checks if there is a loading in progress
         * @returns {boolean} Whether there is a loading operation in progress
         */
        isLoading: function() {
            return this._currentlyLoading;
        },

        /**
         * Handler for loading:done, when an issue has been loaded
         *
         * @param {Object} data
         * @param {Object} meta
         * @param {Object} options
         * @private
         */
        _onLoadingDone: function(data, meta, options) {
            // Massage data
            var issueEntity = options.issueEntity;
            issueEntity.id = data.issue.id;
            issueEntity.key = data.issue.key;
            if (!data.pager) {
                data.pager = issueEntity.pager;
            }
            IssueFieldUtil.transformFieldHtml(data);

            // Mark request as loaded
            this._currentlyLoading = false;

            // Compute loading time
            meta.loadDuration = new Date() - options.startIssueLoad;

            // Trigger our main event
            this.trigger("issueLoaded", data, meta, options);

            // Resolve the main promise
            options.loadingDeferred.resolve(data, meta, options);
        },

        /**
         * Handler for updating:done, when an issue has been updated.
         *
         * This method does virtually nothing, just call _onLoadingDone with meta.isUpdate=true
         *
         * @param {Object[]} args
         * @private
         */
        _onUpdatingDone: function(args) {
            var meta = args.data[1];
            if (meta) {
                meta.isUpdate = true;
            }
            this._onLoadingDone.apply(this, args.data);
        },

        /**
         * Handler for loading:reject, when there are errors loading an issue
         *
         * @param {Object} data
         * @param {Object} meta
         * @param {Object} options
         * @private
         */
        _onLoadingError: function(data, meta, options) {
            // Extract some data
            var issueEntity = options.issueEntity;
            var props = {
                issueId: issueEntity.id,
                issueKey: issueEntity.key,
                response: data
            };

            // Mark request as loaded
            this._currentlyLoading = false;

            // Trigger our main event and resolve the promise
            var reason;
            switch (data.status) {
                case 401:
                    reason = "auth";
                    break;
                case 403:
                    reason = "forbidden";
                    break;
                case 404:
                    reason = "notfound";
                    break;
                default:
                    reason = "generic";
                    break;
            }

            this.trigger("error", reason, props);
            options.loadingDeferred.reject();
        },

        /**
         * Handler for updating:reject, when there are errors updating an issue
         *
         * This method does virtually nothing, just call _onLoadingError with the right params
         *
         * @param {Object[]} args
         * @private
         */
        _onUpdatingError: function(args) {
            this._onLoadingError.apply(this, args.data);
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/services/MetadataService.js' */
define("jira/components/issueviewer/services/metadataservice", ["require"], function(require){
    "use strict";

    var Meta = require("jira/util/data/meta");
    var _ = require("jira/components/libs/underscore");

    /**
     * @class JIRA.Components.IssueViewer.Services.Metadata
     *
     * This service is responsible from adding/removing metadata about an issue
     *
     * @extends Marionette.Controller
     */
    return {
        /**
         * Removes all the issue meta data such as issue key from AJS.Meta
         *
         * @param {JIRA.Components.IssueViewer.Models.Issue} model Model used to extract the values to remove
         */
        removeIssueMetadata: function(model) {
            var issueEntity = model.getEntity();
            if (issueEntity.metadata) {
                _.each(issueEntity.metadata, function(value, key) {
                    Meta.set(key, null);
                });
            } else if (Meta.get("issue-key")) {
                Meta.set("issue-key", null);
            }
        },

        /**
         * Add all the issue meta data such as issue key into AJS.Meta
         *
         * @param {JIRA.Components.IssueViewer.Models.Issue} model Model used to extract the values to add
         */
        addIssueMetadata: function(model) {
            var issueEntity = model.getEntity();
            _.each(issueEntity.metadata, function(value, key) {
                Meta.set(key, value);
            });
        }
    };

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/services/DarkFeatures.js' */
define("jira/components/issueviewer/services/darkfeatures", ["require"], function(require){
    "use strict";

    var Class = require("jira/lib/class");
    var DarkFeatures = require("jira/ajs/dark-features");

    /**
     * Holds the dark feature switches that affect how the KA app works.
     */
    return (function() {
        var Feature = Class.extend({
            /**
             * Creates a new Feature object for the given feature key.
             *
             * @param featureKey {String} the name of the feature
             * @param featureOffKey {String} the name of the feature that negates the behaviour of featureKey.
             */
            init: function(featureKey, featureOffKey) {
                this.featureKey = featureKey;
                this.featureOffKey = featureOffKey;
            },

            /**
             * Returns true if this Feature is enabled.
             * If there is a featureOffKey present, that feature is evaluated and negated.
             *
             * @return {Boolean}
             */
            enabled: function() {
                return !this.featureOffKey ?
                    DarkFeatures.isEnabled(this.featureKey) :
                    DarkFeatures.isEnabled(this.featureKey) && !DarkFeatures.isEnabled(this.featureOffKey);
            }
        });

        return {
            /**
             * If enabled, kills issue prefetching.
             */
            NO_PREFETCH: new Feature("ka.NO_PREFETCH"),

            /**
             * If enabled, project's avatar will display a popup on click
             */
            PROJECT_SHORTCUTS: new Feature("rotp.project.shortcuts"),

            /**
             * If enabled, requests to the Global Issue Navigator are redirected to the Project Issue Navigator.
             */
            REDIRECT_FROM_GLOBAL_TO_PROJECT: new Feature("ka.REDIRECT_FROM_GLOBAL_TO_PROJECT", "ka.REDIRECT_FROM_GLOBAL_TO_PROJECT_OFF"),

            /**
             * If enabled, the current search is not stored in JIRA sessions, and is only stored locally. This is not
             * intended to be turned on in production on a per-rack basis or similar. Instead we plan to use it for
             * testing and maybe only have it on in production for a week or two before removing the code entirely.
             */
            HTTP_SESSIONS_DISABLED: new Feature("ka.HTTP_SESSIONS_DISABLED")
        };
    })();

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/services/LinksCapturer.js' */
define("jira/components/issueviewer/linkscapturer", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Events = require('jira/util/events');
    var InlineLayer = require('jira/ajs/layer/inline-layer');
    var jQuery = require("jquery");
    var MarionetteController = require("jira/components/libs/marionette-1.4.1/controller");
    var Messages = require("jira/message");
    var SmartAjax = require("jira/ajs/ajax/smart-ajax");
    var URI = require('jira/components/libs/uri');

    return MarionetteController.extend({
        initialize: function() {
            _.bindAll(this,
                "_onRefineViewEvents",
                "_offRefineViewEvents",
                "_handleReviewViewEvents"
            );
        },

        capture: function(el) {
            if (el === this.el) return;

            this.el = el;
            this.linksToOtherIssues();
            this.linksToReorderSubtasks();
            this.viewOptionsForCurrentIssue();
        },

        linksToOtherIssues: function() {
            jQuery(this.el).on("simpleClick", "a.issue-link[data-issue-key]", _.bind(function (e) {
                e.preventDefault();
                var issueKey = jQuery(e.target).closest("a").data("issue-key");
                this.trigger("linkToIssue", {
                    issueKey: issueKey
                });
            }, this));
        },

        linksToReorderSubtasks: function() {
            // Enhance Attachment options links
            jQuery(this.el).on("simpleClick", ".subtask-reorder a", _.bind(function(e) {
                if (!e.target.href) return;

                e.preventDefault();

                jQuery.ajax({
                    type: "GET",
                    data: {
                        disableRedirect: true
                    },
                    url: e.target.href
                }).done(_.bind(function() {
                    this.trigger("reorderSubtasks");
                }, this)).fail(function(xhr) {
                    Messages.showErrorMsg(SmartAjax.buildSimpleErrorContent(xhr), {
                        closeable: true
                    });
                });
            }, this));
        },

        _handleReviewViewEvents: function (e) {
            var target = e.currentTarget;
            jQuery(target).parents('ul').find('a.aui-checked').removeClass('aui-checked');
            jQuery(target).addClass('aui-checked');

            var query = new URI(target.href).query(true);
            var preventableEvent = this.triggerPreventable("refineViewer", {
                query: query
            });

            if (preventableEvent.isPrevented) {
                e.preventDefault();
            }
        },

        _onRefineViewEvents: function(event, layer) {
            jQuery(layer).on("simpleClick",
                [
                    "#attachment-sorting-options a",
                    "#attachment-sorting-order-options a",
                    "#attachment-view-mode-options a",
                    "#subtasks-show-all",
                    "#subtasks-show-open"
                ].join(','),
                this._handleReviewViewEvents
            );
        },

        _offRefineViewEvents: function(event, layer) {
            jQuery(layer).off("simpleClick",
                [
                    "#attachment-sorting-options a",
                    "#attachment-sorting-order-options a",
                    "#attachment-view-mode-options a",
                    "#subtasks-show-all",
                    "#subtasks-show-open"
                ].join(','),
                this._handleReviewViewEvents
            );
        },

        viewOptionsForCurrentIssue: function() {
            Events.bind(InlineLayer.EVENTS.show, this._onRefineViewEvents);
            Events.bind(InlineLayer.EVENTS.hide, this._offRefineViewEvents);
        },

        destroy: function() {
            Events.unbind(InlineLayer.EVENTS.show, this._onRefineViewEvents);
            Events.unbind(InlineLayer.EVENTS.hide, this._offRefineViewEvents);

        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/legacy/IssueEventBus.js' */
define("jira/components/issueviewer/legacy/issueeventbus", ["require"], function(require){
    "use strict";

    var Brace = require("jira/components/libs/brace");

    return Brace.Model.extend({

        namedAttributes: ["issueId"],

        namedEvents: [
            /*
             * Triggered when a user saves a field on the view issue screen. Should cause state to be saved
             * on the server.
             */
            "save",
            /*
             * Triggered when a save successfully returns from the server.
             */
            "saveSuccess",
            /**
             * Triggered when save request has been issued to server
             */
            "savingStarted",
            /*
             * Triggered when a save failed on the server.
             */
            "saveError",
            /*
             * Issue panels will fire this event when they've finished rendering after an update.
             */
            "panelRendered",
            /**
             * The issue panel that previously had focus was replaced.
             */
            "replacedFocusedPanel",
            /**
             * Field has been submitted by user.
             */
            "fieldSubmitted",
            /*
             * Fires when an issue view is closed or we go back to search.
             */
            "dismiss",
            /**
            * Triggered when the issue view needs to be refreshed.
            */
            "refreshIssue",
            /**
            * Triggered when the issue view has finished refreshing
            */
            "issueRefreshed",
            /**
            * Triggers views/models to update from a pre-existing DOM.
            */
            "updateFromDom",
            /**
            * Lets interested objects know to update status color
            */
            "updateStatusColor",
            /**
            * Triggered when a key is pressed whilst holding the tab key.
            */
            "quickEditKeyPressed",
            /**
            * Opens the focus shifter.
            */
            "openFocusShifter"
        ]

    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/legacy/AsyncData.js' */
define("jira/components/issueviewer/legacy/asyncdata", ["require"], function(require){
    "use strict";

    var Brace = require("jira/components/libs/brace");
    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");

    return Brace.Evented.extend({

        namedEvents: ["change"],

        /**
         * @param options
         * @param {Boolean} options.disableCache A flag to indicate whether to cache the data
         */
        initialize: function(options) {
            this.data = {};
            this.pendings = {};
            this.accessIndex = 0;

            if (options) {
                this.disableCache = options.disableCache;
                this.maxCacheSize = options.maxCacheSize;
            }
        },

        /**
         * Get item from the cache if possible, otherwise fetch it.
         *
         * If forceFetch is true, always fetch the latest data and override any pending request.
         *
         * If the fetch succeeds, updates the item and metadata in cache.
         * If the fetch fails, the last successful value is kept (null if there is no previous success),
         * and metadata is updated to indicate an error.
         *
         * @return {jQuery.Promise} resolves when fetch() succeeds or fails, and cache has been updated.
         */
        get: function(id, forceFetch, options) {
            var deferred = new jQuery.Deferred();
            var data = this.disableCache ? {} : this.data; // Keep a reference to the data object at the time the get() is called

            var resolveWith = _.bind(function(meta, additionalMeta) {
                var changedData = this._set(data, id, _.defaults(meta, {accessIndex: this.accessIndex++}), true, options);

                // combinedMeta is what is passed to the deferred callbacks
                var combinedMeta = _.defaults({changed: changedData}, additionalMeta, data[id]);
                if (options && options.mergeIntoCurrent) {
                    combinedMeta.mergeIntoCurrent = true;
                }

                if (data[id] && !data[id].error) {
                    deferred.resolve(data[id].value, combinedMeta, options);
                } else {
                    deferred.reject(data[id] && data[id].value, combinedMeta, options);
                }
            }, this);

            var resolveAfterFetch = _.bind(function(initialLoad) {
                var fetchPromise = this.fetch(id, options);

                this.setPending(id, fetchPromise, function(value) {
                    resolveWith({
                        value: value,
                        error: false,
                        updated: new Date()
                    }, {initialLoad: initialLoad});
                }, function(value) {
                    var meta = {
                        error: true,
                        updated: new Date()
                    };
                    if (value !== undefined) {
                        meta.value = value;
                    }
                    resolveWith(meta, {
                        initialLoad: initialLoad,
                        error: true
                    });
                });
            }, this);

            var resolveFromCache = function() {
                resolveWith({}, {fromCache: true});
            };

            var resolveAfterPending = _.bind(function() {
                this.pendings[id].always(_.bind(resolveWith, this, {}, {
                    // resolveAfterPending is used to resolve deferreds that have piggy-backed onto a fetch() call that's
                    // already in progress (i.e. a "pending"). therefore, the correct thing is to resolve the deferred with
                    // meta.initialLoad=true, since it is also getting the data returned from the initial cache load.
                    initialLoad: true
                }));
            }, this);

            // if caching is disabled then always fetch.
            if (forceFetch || this.disableCache) {
                resolveAfterFetch(false);
            } else if (this.hasCached(id)) {
                resolveFromCache();
            } else if (this.hasPending(id)) {
                resolveAfterPending();
            } else {
                resolveAfterFetch(true);
            }

            return deferred.promise();
        },

        setPending: function(id, task, doneCallback, failCallback) {
            if (this.hasPending(id)) {
                this.pendings[id].update(task);
            } else {
                this.pendings[id] = new jQuery.ConcurrentDeferred(task);
            }
            return this.pendings[id].done(function(value) {
                doneCallback(value);
            }).fail(function(value) {
                failCallback(value);
            });
        },

        /**
         * Get id by value
         *
         * @return {String|null} id of the value. Can be null to indicate not found.
         */
        getIdByValue: function(value) {
            var id;
            for (id in this.data) {
                if (this.data[id].value === value) {
                    return id;
                }
            }
            return null;
        },

        /**
         * Retrieves item as stored in the cache, with attached metadata.
         * @return {
         *     value: value
         *     updated: {Date},
         *     accessIndex: {Number},
         *     error: {Boolean}
         * }
         */
        getMeta: function(id) {
            return this.data[id] || {};
        },

        getAllCached: function() {
            var obj = {};
            _.each(this.data, function(value, id) {
                obj[id] = value.value;
            });
            return obj;
        },

        /**
         * @return {Boolean} whether or not a value/error for the given id is already in the cache
         */
        hasCached: function(id) {
            var meta = this.getMeta(id);
            return meta.value !== undefined || meta.error === true;
        },

        /**
         * @return {Boolean} whether or not the given id has an error set on it
         */
        hasError: function(id) {
            var meta = this.getMeta(id);
            return meta.error === true;
        },

        /**
         * @return {Boolean} whether or not a request is currently in progress for the given id
         */
        hasPending: function(id) {
            var pending = this.pendings[id];
            return pending ? pending.isPending() : false;
        },

        /**
         * Sets a value in the cache.
         * Triggers a change event if the value or the error state has changed.
         *
         * @return {Boolean} whether the value changed
         */
        set: function(id, value) {
            return this._set(this.data, id, {
                value: value,
                updated: new Date()
            }, true);
        },

        /**
         * Remove item from the cache
         * @param id
         * @return {Boolean} whether an item was removed
         */
        remove: function(id) {
            if (this.data[id]) {
                delete this.data[id];
                this.triggerChange();
                return true;
            }
            return false;
        },

        /**
         * Sets the error flag and optionally the value for the given item in the cache
         * Triggers a change event if the error state has changed.
         *
         * @param id
         * @param {Object|null} value - optionally change the value at the same time
         *
         * @return {Boolean} whether the error state or value changed
         */
        setError: function(id, value) {
            var meta = {
                error: true,
                updated: new Date()
            };
            if (value !== undefined) {
                meta.value = value;
            }
            return this._set(this.data, id, meta, true);
        },

        /**
         * Sets multiple values at once, triggering at most one change event
         * @param {Object} map of id:meta, where:
         *     id: {String} id
         *     meta: {Object} meta, containing at least one of:
         *         value: {Object}
         *         error: {Object}
         * @return {Boolean} whether any value changed
         */
        setMultiple: function(map) {
            var updated = new Date();
            var changed = false;
            _.each(map, _.bind(function(meta, id) {
                meta = _.pick(meta, 'value', 'error');
                meta.updated = updated;
                if (this._set(this.data, id, meta, false)) {
                    changed = true;
                }
            }, this));
            if (changed) {
                this.triggerChange();
            }
            return changed;
        },

        /**
         * Resets the cached data. Optionally, ids and values can be passed in to set initial values.
         */
        reset: function(map) {
            this.data = {};
            this.pendings = {};
            this.accessIndex = 0;
            if (map) {
                this.setMultiple(map);
            } else {
                this.triggerChange();
            }
        },

        /**
         * @param {Object} data
         * @param {String} id
         * @param {Object} metaValues
         * @param {Boolean} triggerChange - trigger change event if:
         *    - value or error is changed, AND
         *    - data === this.data
         * @return {Boolean} whether the value changed
         *
         * Note: Why are we passing in `data` and not just using `this.data`?
         *  - get() is asynchronous, so by the time it resolves, reset() may have been called
         *  - reset() replaces `this.data` with a new object
         *  - when get() resolves it shouldn't add its results to the new `data`,
         *    but it should have access to the `data` at the time it was initiated.
         */
        _set: function(data, id, metaValues, triggerChange, options) {
            if (this.disableCache && data === this.data) {
                data = {}; // Don't modify the cache
            }

            var item = data[id] ? _.clone(data[id]) : {};

            var changedData = this.mergeFetchedAndCached(item, metaValues, options ? options : {}, data[id]);

            if (triggerChange && (!data[id] || changedData || data[id].error !== item.error) && data === this.data) {
                this.triggerChange();
            }

            if (!data[id] && this.maxCacheSize && _.keys(data).length === this.maxCacheSize) {
                if (metaValues.accessIndex) {
                    this._dropItem(data);
                    data[id] = item;
                }
            } else {
                data[id] = item;
            }

            return changedData;
        },

        _dropItem: function(data) {
            // Drop the least-recently accessed item
            var leastRecentKey = null;
            for (var key in data) {
                if (!data[key].accessIndex) {
                    leastRecentKey = key;
                    break;
                } else if (leastRecentKey === null || data[key].accessIndex < data[leastRecentKey].accessIndex) {
                    leastRecentKey = key;
                }
            }
            if (leastRecentKey !== null) {
                delete data[leastRecentKey];
            }
        },

        /**
         * Override to specify fetch behaviour.
         * @return {jQuery.Promise}
         */
        fetch: function(id) {
            var meta = this.getMeta(id);
            var deferred = new jQuery.Deferred();
            if (!this.hasCached(id) || meta.error) {
                deferred.reject(meta.value);
            } else {
                deferred.resolve(meta.value);
            }
            return deferred.promise();
        },

        mergeFetchedAndCached: function(toResolve, fetched, options, inCache) {
            _.extend(toResolve, fetched);

            return !inCache || inCache.value !== toResolve.value || inCache.error !== toResolve.error;
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/legacy/ViewIssueData.js' */
define("jira/components/issueviewer/legacy/viewissuedata", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var AsyncData = require("jira/components/issueviewer/legacy/asyncdata");
    var DarkFeatures = require("jira/components/issueviewer/services/darkfeatures");
    var Meta = require("jira/util/data/meta");
    var jQuery = require("jquery");
    var contextPath = window.AJS.contextPath();

    return AsyncData.extend({
        initialize: function(options) {
            AsyncData.prototype.initialize.call(this, _.defaults(options || {}, {
                disableCache: DarkFeatures.NO_PREFETCH.enabled(),
                maxCacheSize: Meta.get('viewissue-max-cache-size')
            }));
        },

        /**
         * @param {String} key The key of the issue
         */
        fetch: function(key, options) {
            var data = {
                issueKey: key,
                decorator: "none",
                prefetch: !!options.prefetch
            };

            // JRA-36659: keep track of whether we are in detail view - if we are we won't update the current project
            data.shouldUpdateCurrentProject = !options.detailView;

            if (options.mergeIntoCurrent) {
                if (this.data && this.data[key] && this.data[key].value && this.data[key].value.issue) {
                    data.lastReadTime = this.data[key].value.readTime;

                    data.fields = [];
                    _.each(this.data[key].value.fields, function(field) {
                        data.fields.push(field.id + ":" + field.contentId);
                    });

                    data.issue = ["summary:" + this.data[key].value.issue.summaryContentId];

                    data.links = [];
                    var collectGroupLinks = function(group) {
                        _.each(group.links, function(link) {
                            data.links.push(link.id + ":" + link.contentId);
                        });
                        _.each(group.groups, function(nestedGroup) {
                            collectGroupLinks(nestedGroup);
                        });
                    };
                    _.each(this.data[key].value.issue.operations.linkGroups, function(group) {
                        collectGroupLinks(group);
                    });

                    data.panels = [];
                    var instance = this;
                    var collectPanels = function(location) {
                        _.each(instance.data[key].value.panels[location], function(panel) {
                            data.panels.push(panel.completeKey + ":" + panel.contentId);
                        });
                    };
                    collectPanels("leftPanels");
                    collectPanels("rightPanels");
                    collectPanels("infoPanels");
                }
            }

            if ("loadFields" in options) {
                data.loadFields = options.loadFields;
            }

            if (options.issueEntity) {
                _.defaults(data, options.issueEntity.viewIssueQuery);
            }

            var jqXhr = jQuery.ajax({
                url: contextPath + "/secure/AjaxIssueAction!default.jspa",
                headers: {'X-SITEMESH-OFF': true},
                data: data,
                type: options.mergeIntoCurrent ? "POST" : "GET"
            });
            var deferred = jqXhr.pipe(function(data) {
                return data;
            }, function(xhr) {
                return _.pick(xhr, 'status', 'responseText', 'statusText');
            });
            deferred.abort = function() {
                jqXhr.abort.apply(jqXhr, arguments);
            };
            return deferred;
        },

        mergeFetchedAndCached: function(cachedData, fetchedData, options) {
            if (this._skipMerging(cachedData, fetchedData, options)) {
                _.extend(cachedData, fetchedData);

                return null;
            }

            // Copy all properties except "value".
            _.each(_.pairs(fetchedData), function(pair) {
                if (pair[0] !== "value") {
                    cachedData[pair[0]] = pair[1];
                }
            });

            var fetched = fetchedData.value;

            // Merge values.
            var fieldsKeysToRemove = [];
            var panelKeysToRemove = [];
            var linkKeysToRemove = [];
            _.each(fetched.removedContentIds, function(keys, category) {
                var keysToRemove;
                if (category === "fields") {
                    keysToRemove = fieldsKeysToRemove;
                } else if (category === "panels") {
                    keysToRemove = panelKeysToRemove;
                } else if (category === "links") {
                    keysToRemove = linkKeysToRemove;
                }

                if (keysToRemove) {
                    _.each(keys, function(key) {
                        keysToRemove.push(key);
                    });
                }
            });

            var fetchedFields = fetched.fields;
            var fetchedLinkGroups = fetched.issue.operations.linkGroups;
            var fetchedPanels = fetched.panels;
            var fetchedSummary = fetched.issue.summary;

            if (this._nothingChanged(fieldsKeysToRemove, panelKeysToRemove, linkKeysToRemove,
                    fetchedFields, fetchedPanels, fetchedLinkGroups, fetchedSummary)) {

                return null;
            }

            var changedData = {updated: {}, added: {}, deleted: {}};
            var cached = cachedData.value;
            var comparator = this._comparator;

            if (fieldsKeysToRemove.length > 0 || fetchedFields.length > 0) {
                this._mergeFields(fetchedFields, cached, changedData, fieldsKeysToRemove);
            }
            if (panelKeysToRemove.length > 0 || fetchedPanels.leftPanels.length > 0 || fetchedPanels.rightPanels.length > 0 || fetchedPanels.infoPanels.length > 0) {
                this._mergePanels(fetchedPanels, cached, changedData, panelKeysToRemove, comparator);
            }
            if (linkKeysToRemove.length > 0 || fetchedLinkGroups.length > 0) {
                this._mergeLinks(fetchedLinkGroups, cached, changedData, linkKeysToRemove, comparator);
            }
            if (fetchedSummary) {
                this._mergeSummary(fetched, cached, changedData);
            }

            return changedData;
        },

        _skipMerging: function(cachedData, fetchedData, options) {
            return _.isEmpty(cachedData) || !options.mergeIntoCurrent || !cachedData.value || !cachedData.value.issue ||
                fetchedData.error === true;
        },

        _nothingChanged: function(fieldsKeysToRemove, panelKeysToRemove, linkKeysToRemove,
                                  fetchedFields, fetchedPanels, fetchedLinkGroups, fetchedSummary) {
            return fieldsKeysToRemove.length === 0 && panelKeysToRemove.length === 0 && linkKeysToRemove.length === 0 &&
                fetchedFields.length === 0 && fetchedLinkGroups.length === 0 &&
                fetchedPanels.leftPanels.length === 0 && fetchedPanels.rightPanels.length === 0 && fetchedPanels.infoPanels.length === 0 && !fetchedSummary;
        },

        _mergeFields: function(fetchedFields, cached, changedData, keysToRemove) {
            changedData.added.fields = [];
            changedData.updated.fields = [];
            changedData.deleted.fields = [];

            _.each(fetchedFields, function(fetchedField) {
                var existing = _.find(cached.fields, function(cachedField) {
                    return cachedField.id === fetchedField.id;
                });
                if (existing) {
                    changedData.updated.fields.push(fetchedField.id);
                } else {
                    changedData.added.fields.push(fetchedField.id);
                }
            });

            var newFields = fetchedFields;

            _.each(cached.fields, function(oldField) {
                if (_.contains(keysToRemove, oldField.id)) {
                    changedData.deleted.fields.push(oldField.id);
                } else if (!_.contains(changedData.updated.fields, oldField.id)) {
                    newFields.push(oldField);
                }
            });

            cached.fields = newFields;
        },

        _mergeSummary: function(fetched, cached, changedData) {
            changedData.updated.issue = ["summary"];

            cached.issue.summary = fetched.issue.summary;
            cached.issue.summaryContentId = fetched.issue.summaryContentId;
        },

        _mergePanels: function(fetchedPanels, cached, changedData, keysToRemove, comparator) {
            changedData.added.panels = {};
            changedData.updated.panels = {};
            changedData.deleted.panels = {};

            var storePanels = function(location) {
                changedData.added.panels[location] = [];
                changedData.updated.panels[location] = [];
                changedData.deleted.panels[location] = [];

                _.each(fetchedPanels[location], function(fetchedPanel) {
                    var existing = _.find(cached.panels[location], function(cachedPanel) {
                        return cachedPanel.id === fetchedPanel.id;
                    });
                    if (existing) {
                        changedData.updated.panels[location].push(fetchedPanel.id);
                    } else {
                        changedData.added.panels[location].push(fetchedPanel.id);
                    }
                });

                var newPanels = fetchedPanels[location];

                _.each(cached.panels[location], function(oldPanel) {
                    if (_.contains(keysToRemove, oldPanel.completeKey)) {
                        changedData.deleted.panels[location].push(oldPanel.id);
                    } else if (!_.contains(changedData.updated.panels[location], oldPanel.id)) {
                        newPanels.push(oldPanel);
                    }
                });

                newPanels.sort(comparator);

                cached.panels[location] = newPanels;
            };

            storePanels("leftPanels");
            storePanels("rightPanels");
            storePanels("infoPanels");
        },

        _mergeLinks: function(fetchedLinkGroups, cached, changedData, keysToRemove, comparator) {
            changedData.added.groups = {};
            changedData.updated.groups = {};
            changedData.deleted.groups = {};

            var newLinkGroups = [];

            this._mergeOperationsLinks(fetchedLinkGroups, cached, newLinkGroups, changedData, keysToRemove, comparator);
            this._mergeToolsLinks(fetchedLinkGroups, cached, newLinkGroups, changedData, keysToRemove, comparator);

            cached.issue.operations.linkGroups = newLinkGroups;
        },

        _mergeOperationsLinks: function(fetchedLinkGroups, cached, newLinkGroups, changedData, keysToRemove, comparator) {
            changedData.added.groups["view.issue.opsbar"] = [];
            changedData.updated.groups["view.issue.opsbar"] = [];
            changedData.deleted.groups["view.issue.opsbar"] = [];

            var operationsGroupContainer = _.find(cached.issue.operations.linkGroups, function(group) {
                return "view.issue.opsbar" === group.id;
            });
            var fetchedOperationsGroupContainer = _.find(fetchedLinkGroups, function(group) {
                return "view.issue.opsbar" === group.id;
            });

            var fetchedLinkMapping = {};
            var fetchedLinkToGroupIdMapping = {};
            if (fetchedOperationsGroupContainer) {
                _.each(fetchedOperationsGroupContainer.groups, function(fetchedOperationsGroup) {
                    var existingGroup = _.find(operationsGroupContainer.groups, function(group) {
                        return fetchedOperationsGroup.id === group.id;
                    });
                    if (existingGroup) {
                        changedData.updated.groups["view.issue.opsbar"].push(fetchedOperationsGroup.id);
                    } else {
                        changedData.added.groups["view.issue.opsbar"].push(fetchedOperationsGroup.id);
                    }

                    _.each(fetchedOperationsGroup.links, function(link) {
                        fetchedLinkMapping[link.id] = link;
                        fetchedLinkToGroupIdMapping[link.id] = fetchedOperationsGroup.id;
                    });

                    if (fetchedOperationsGroup.groups && fetchedOperationsGroup.groups.length > 0) {
                        var dropdown = fetchedOperationsGroup.groups[0];

                        _.each(dropdown.groups, function(dropdownGroup) {
                            _.each(dropdownGroup.links, function(link) {
                                fetchedLinkMapping[link.id] = link;
                                fetchedLinkToGroupIdMapping[link.id] = dropdownGroup.id;
                            });
                        });
                    }
                });
            }

            if (operationsGroupContainer) {
                var newOperationsGroups = [];

                if (fetchedOperationsGroupContainer) {
                    _.each(fetchedOperationsGroupContainer.groups, function(fetchedOperationsGroup) {
                        if (_.contains(changedData.added.groups["view.issue.opsbar"], fetchedOperationsGroup.id)) {
                            // There was no such group but now it was fetched.
                            newOperationsGroups.push(fetchedOperationsGroup);
                        }
                    });
                }

                _.each(operationsGroupContainer.groups, function(operationsGroup) {
                    var newGroupLinks = [];

                    var fetchedOperationsGroup = null;
                    if (fetchedOperationsGroupContainer) {
                        fetchedOperationsGroup = _.find(fetchedOperationsGroupContainer.groups, function(group) {
                            return operationsGroup.id === group.id;
                        });

                        if (fetchedOperationsGroup) {
                            _.each(fetchedOperationsGroup.links, function(fetchedLink) {
                                var existingLink = _.find(operationsGroup.links, function(link) {
                                    return fetchedLink.id === link.id;
                                });
                                if (!existingLink) {
                                    // There was no such link but now it was fetched.
                                    newGroupLinks.push(fetchedLink);
                                }
                            });
                        }
                    }

                    var groupUpdated = false;

                    var checkLinks = function(group, newLinks) {
                        _.each(group.links, function(link) {
                            var fetchedGroupId = fetchedLinkToGroupIdMapping[link.id];
                            if (fetchedGroupId && fetchedGroupId !== group.id) {
                                // Link moved from another group.
                                groupUpdated = true;
                            } else if (fetchedLinkMapping[link.id]) {
                                newLinks.push(fetchedLinkMapping[link.id]);
                            } else if (!_.contains(keysToRemove, link.id)) {
                                newLinks.push(link);
                            } else {
                                // Existing link got deleted.
                                groupUpdated = true;
                            }
                        });
                    };

                    checkLinks(operationsGroup, newGroupLinks);

                    newGroupLinks.sort(comparator);
                    operationsGroup.links = newGroupLinks;

                    var fetchedDropdown = null;
                    if (fetchedOperationsGroup && fetchedOperationsGroup.groups && fetchedOperationsGroup.groups.length > 0) {
                        fetchedDropdown = fetchedOperationsGroup.groups[0];
                    }

                    var dropdown = null;
                    if (operationsGroup.groups && operationsGroup.groups.length > 0) {
                        dropdown = operationsGroup.groups[0];

                        var newDropdownGroups = [];

                        if (fetchedDropdown) {
                            _.each(fetchedDropdown.groups, function(fetchedDropdownGroup) {
                                var existingDropdownGroup = _.find(dropdown.groups, function(group) {
                                    return fetchedDropdownGroup.id === group.id;
                                });
                                if (!existingDropdownGroup) {
                                    // There was no such dropdown group but now it was fetched.
                                    newDropdownGroups.push(fetchedDropdownGroup);
                                }
                            });
                        }

                        _.each(dropdown.groups, function(dropdownGroup) {
                            var newSectionLinks = [];

                            if (fetchedDropdown) {
                                var fetchedDropdownGroup = _.find(fetchedDropdown.groups, function(fetchedDropdownGroup) {
                                    return fetchedDropdownGroup.id === dropdownGroup.id;
                                });
                                if (fetchedDropdownGroup) {
                                    _.each(fetchedDropdownGroup.links, function(fetchedLink) {
                                        var existingDropdownLink = _.find(dropdownGroup.links, function(link) {
                                            return fetchedLink.id === link.id;
                                        });
                                        if (!existingDropdownLink) {
                                            // There was no such dropdown link but now it was fetched.
                                            newSectionLinks.push(fetchedLink);
                                        }
                                    });
                                }
                            }

                            checkLinks(dropdownGroup, newSectionLinks);

                            if (newSectionLinks.length > 0) {
                                newSectionLinks.sort(comparator);
                                dropdownGroup.links = newSectionLinks;
                                newDropdownGroups.push(dropdownGroup);
                            }
                        });

                        if (newDropdownGroups.length > 0) {
                            newDropdownGroups.sort(comparator);
                            dropdown.groups = newDropdownGroups;
                        } else {
                            dropdown = null;
                            groupUpdated = true;
                        }
                    } else if (fetchedDropdown) {
                        // There was no dropdown but now it was fetched.
                        dropdown = fetchedOperationsGroup.groups[0];
                    }

                    operationsGroup.groups = [];
                    if (dropdown) {
                        operationsGroup.groups[0] = dropdown;
                    }

                    if (newGroupLinks.length > 0 || dropdown) {
                        newOperationsGroups.push(operationsGroup);

                        if (groupUpdated && !_.contains(changedData.updated.groups["view.issue.opsbar"], operationsGroup.id)) {
                            changedData.updated.groups["view.issue.opsbar"].push(operationsGroup.id);
                        }
                    } else {
                        changedData.deleted.groups["view.issue.opsbar"].push(operationsGroup.id);
                    }
                });

                if (newOperationsGroups.length > 0) {
                    newOperationsGroups.sort(comparator);
                    operationsGroupContainer.groups = newOperationsGroups;
                    newLinkGroups.push(operationsGroupContainer);
                }
            } else if (fetchedOperationsGroupContainer) {
                // There was no container in the cache but now it was fetched.
                newLinkGroups.push(fetchedOperationsGroupContainer);
            }

            changedData.added.groups["view.issue.opsbar"].sort();
            changedData.deleted.groups["view.issue.opsbar"].sort();
            changedData.updated.groups["view.issue.opsbar"].sort();
        },

        _mergeToolsLinks: function(fetchedLinkGroups, cached, newLinkGroups, changedData, keysToRemove, comparator) {
            changedData.updated.groups["jira.issue.tools"] = false;

            var toolsGroupContainer = _.find(cached.issue.operations.linkGroups, function(group) {
                return "jira.issue.tools" === group.id;
            });
            var fetchedToolsGroupContainer = _.find(fetchedLinkGroups, function(group) {
                return "jira.issue.tools" === group.id;
            });

            var fetchedLinkMapping = {};
            if (fetchedToolsGroupContainer) {
                // There must be just one tools top-level group.
                changedData.updated.groups["jira.issue.tools"] = true;

                _.each(fetchedToolsGroupContainer.links, function(link) {
                    fetchedLinkMapping[link.id] = link;
                });

                if (fetchedToolsGroupContainer.groups && fetchedToolsGroupContainer.groups.length > 0) {
                    _.each(fetchedToolsGroupContainer.groups[0].links, function(link) {
                        fetchedLinkMapping[link.id] = link;
                    });
                }
            }

            if (toolsGroupContainer) {
                var newToolsLinks = [];

                if (fetchedToolsGroupContainer) {
                    _.each(fetchedToolsGroupContainer.links, function(fetchedLink) {
                        var existingLink = _.find(toolsGroupContainer.links, function(link) {
                            return fetchedLink.id === link.id;
                        });
                        if (!existingLink) {
                            // There was no such link but now it was fetched.
                            newToolsLinks.push(fetchedLink);
                        }
                    });
                }

                _.each(toolsGroupContainer.links, function(link) {
                    if (fetchedLinkMapping[link.id]) {
                        newToolsLinks.push(fetchedLinkMapping[link.id]);
                    } else if (!_.contains(keysToRemove, link.id)) {
                        newToolsLinks.push(link);
                    }
                });

                newToolsLinks.sort(comparator);
                toolsGroupContainer.links = newToolsLinks;

                var fetchedViewGroup = null;
                if (fetchedToolsGroupContainer && fetchedToolsGroupContainer.groups && fetchedToolsGroupContainer.groups.length > 0) {
                    fetchedViewGroup = fetchedToolsGroupContainer.groups[0];
                }

                if (toolsGroupContainer.groups && toolsGroupContainer.groups.length > 0) {
                    var viewGroup = toolsGroupContainer.groups[0];

                    var newViewLinks = [];

                    if (fetchedViewGroup) {
                        _.each(fetchedViewGroup.links, function(fetchedLink) {
                            var existingLink = _.find(viewGroup.links, function(link) {
                                return fetchedLink.id === link.id;
                            });
                            if (!existingLink) {
                                // There was no such link but now it was fetched.
                                newViewLinks.push(fetchedLink);
                            }
                        });
                    }

                    _.each(viewGroup.links, function(link) {
                        if (fetchedLinkMapping[link.id]) {
                            newViewLinks.push(fetchedLinkMapping[link.id]);
                        } else if (!_.contains(keysToRemove, link.id)) {
                            newViewLinks.push(link);
                        }
                    });

                    toolsGroupContainer.groups = [];
                    if (newViewLinks.length > 0) {
                        newViewLinks.sort(comparator);
                        viewGroup.links = newViewLinks;
                        toolsGroupContainer.groups[0] = viewGroup;
                    }
                } else if (fetchedViewGroup) {
                    // There was no view group in the cache but now it was fetched.
                    toolsGroupContainer.groups = [fetchedViewGroup];
                }

                newLinkGroups.push(toolsGroupContainer);
            } else if (fetchedToolsGroupContainer) {
                // There was no container in the cache but now it was fetched.
                newLinkGroups.push(fetchedToolsGroupContainer);
            }
        },

        _comparator: function(objOne, objTwo) {
            if (objOne.weight && objTwo.weight) {
                if (objOne.weight > objTwo.weight) {
                    return 1;
                }
                if (objOne.weight < objTwo.weight) {
                    return -1;
                }
                return 0;
            }

            if (objOne.weight && !objTwo.weight) {
                return 1;
            }
            if (!objOne.weight && objTwo.weight) {
                return -1;
            }

            return 0;
        },

        updateIssue: function(key, data) {
            var cached = this.getMeta(key);
            if (cached && cached.value) {
                cached.value.fields = data.fields || {};
            }
        }

    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/legacy/IssueFieldUtil.js' */
define("jira/components/issueviewer/legacy/issuefieldutil", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");

    var issueFieldUtil = {

        getFieldSelector: function(id) {
            if (id === "issuetype") {
                return "#type-val";
            } else if (id === "fixVersions") {
                return "#fixfor-val";
            } else if (id === "summary") {
                return "#summary-val";
            } else if (id === "labels") {
                return "#wrap-labels .value";
            } else if (id === "duedate") {
                return "#due-date";
            } else {
                return "#" + id + "-val";
            }
        },

        matchesFieldSelector: function(id) {
            return jQuery(issueFieldUtil.getFieldSelector(id)).length === 1;
        },

        /**
         * Parses raw response into an object our IssueFieldCollection can consume.
         * In the case of field htmls we strip away labels.
         *
         * @param {Object} resp - raw response from server
         */
        transformFieldHtml: function(resp) {
            resp.fields = _.map(resp.fields, function(field) {

                var $html = jQuery("<div />").htmlCatchExceptions(field.editHtml);

                // Crappy but our edit html includes the label or legend (in case of multi radio/checkbox fields). But we only want the input(s)
                if ($html.find("input.radio,input.checkbox").length !== 0) {
                    $html.find("legend").eq(0).remove();
                } else {
                    $html.find("label").eq(0).remove();
                }

                return {
                    id: field.id,
                    label: field.label,
                    editHtml: $html.html(),
                    required: field.required,
                    contentId: field.contentId
                };
            });

            return resp;
        },

        /**
         * Returns the accessKey modifiers required for this browser.
         * @return String The accessKey modifiers.
         */
        getAccessKeyModifier: function() {
            var homeLinkTitle = jQuery("#home_link_drop").attr("title");
            var re = /\(([\w\+]+)\+\w\)/i;

            if (re.test(homeLinkTitle)) {
                return re.exec(homeLinkTitle)[1];
            } else {
                return "Alt";
            }
        }
    };

    return issueFieldUtil;

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/Utils.js' */
define("jira/components/issueviewer/utils", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var InlineDialog = AJS.InlineDialog;
    var InlineLayer = require('jira/ajs/layer/inline-layer');
    var IntroDialog = JIRA.Issues.IntroDialog;
    var jQuery = require("jquery");

    return {
        /**
         * Hides the Fancybox overlay that we use for image attachments, viewing a workflow, etc.
         */
        hideLightbox: function() {
            jQuery.fancybox.close();
        },

        /**
         * Hides any visible drop down on the page
         */
        hideDropdown: function() {
            //HACK: Having a whitelist of dialogs that should not be closed is a maintenance nightmare,
            //but a better solution will involve refactoring AJS.InlineDialog and possibly a change of its
            //architecture/API. Related to JRADEV-21760
            if (InlineDialog.current &&
                (!IntroDialog || _.contains(IntroDialog.dialogs, InlineDialog.current)) &&
                InlineDialog.current.id !== "column-picker-dialog"
            ) {
                InlineDialog.current.hide();
            }
            if (InlineLayer.current) {
                var $trigger = InlineLayer.current.options.offsetTarget();
                if ($trigger instanceof jQuery) {
                    if (!$trigger.is(":visible")) {
                        InlineLayer.current.hide();
                    }
                }

            }
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/actions.js' */
define("jira/components/issueviewer/actions", function(){
    "use strict";

    var Actions = JIRA.Issues.Actions || {};
    Actions.EDIT_COMMENT = "editComment";
    return Actions;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/eventtypes.js' */
define("jira/components/issueviewer/eventtypes", ["require"], function(require){
    "use strict";

    var Types = require('jira/util/events/types');
    Types.ISSUE_REFRESHED = "issueRefreshed";
    Types.PANEL_REFRESHED = "panelRefreshed";
    return Types;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/analytics/IssueOpsbar.js' */
define("jira/components/issueviewer/analytics/issueopsbar", ["require", "jquery", "jira/viewissue/analytics-utils"], function (require, $, AnalyticsUtils) {
    "use strict";

    var Analytics = function (opsbarView) {
        this.issueId = opsbarView.model.get('id');
        this.$el = opsbarView.$el;

        this.bindEventsToOpsbar();
    };

    Analytics.prototype.triggerEvent = function (data) {
        AJS.trigger('analyticsEvent', {
            name: "kickass.opsbar.operation",
            data: data
        });
    };

    Analytics.prototype._getParamsButtonMain = function (event, $link, idx) {
        return _.extend(this._getParamsCommon(event), {
            issueId: this.issueId,
            id: $link.attr('id'),
            idx: idx
        });
    };

    Analytics.prototype._getParamsButtonSubmenu = function (event, $sublink, subIdx, $parentLink, parentIdx) {
        return _.extend(this._getParamsCommon(event), {
            issueId: this.issueId,
            id: $sublink.attr('id'),
            idx: subIdx,
            parentId: $parentLink.attr('id'),
            parentIdx: parentIdx
        });
    };

    Analytics.prototype._getParamsCommon = function () {
        return {
            context: AnalyticsUtils.context()
        };
    };

    Analytics.prototype.bindEventsToOpsbar = function () {
        var links = this.$el.find('div.ops-menus li.toolbar-item');

        links.each(function (i, li) {
            var $li = $(li);

            if ($li.hasClass('toolbar-dropdown')) {
                var $linkTrigger = $li.find('a.toolbar-trigger');
                $linkTrigger.click(function (e) {
                    this.triggerEvent(this._getParamsButtonMain(e, $linkTrigger, i));
                }.bind(this));

                var $submenuLinks = $li.find('.aui-list a');
                $submenuLinks.each(function (j, sublink) {
                    var $sublink = $(sublink);
                    $sublink.click(function (e) {
                        this.triggerEvent(this._getParamsButtonSubmenu(e, $sublink, j, $linkTrigger, i));
                    }.bind(this));
                }.bind(this));
            } else {
                var $link = $li.find('a');
                $link.click(function (e) {
                    this.triggerEvent(this._getParamsButtonMain(e, $link, i));
                }.bind(this));
            }
        }.bind(this));
    };

    return Analytics;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/IssueViewer.js' */
define("jira/components/issueviewer", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Actions = require("jira/components/issueviewer/actions");
    var DarkFeatures = require("jira/components/issueviewer/services/darkfeatures");
    var ErrorController = require("jira/components/issueviewer/controllers/error");
    var Events = require('jira/util/events');
    var IssueController = require("jira/components/issueviewer/controllers/issue");
    var IssueEventBus = require("jira/components/issueviewer/legacy/issueeventbus");
    var IssueLoader = require("jira/components/issueviewer/services/issueloader");
    var IssueModel = require("jira/components/issueviewer/entities/issue");
    var jQuery = require("jquery");
    var LinksCapturer = require("jira/components/issueviewer/linkscapturer");
    var MarionetteController = require('jira/components/libs/marionette-1.4.1/controller');
    var Meta = require("jira/util/data/meta");
    var MetadataService = require("jira/components/issueviewer/services/metadataservice");
    var Trace = window.JIRA;
    var Types = require('jira/components/issueviewer/eventtypes');
    var Utils = require("jira/components/issueviewer/utils");
    var ViewIssueData = require("jira/components/issueviewer/legacy/viewissuedata");

    var contextPath = window.AJS.contextPath();

    var trace = function() {
        Trace.trace.apply(Trace, arguments);
    };

    /**
     * @class JIRA.Components.IssueViewer
     *
     * This module provides the IssueViewer. It will load an issue, update it and render the UI to view the issue
     *
     * @extends JIRA.Marionette.Controller
     */
    return MarionetteController.extend({
        namedEvents: [
        /**
         * @event loadComplete
         * Triggered when an issue has loaded successfully.
         *
         * @param {JIRA.Components.IssueViewer.Models.Issue} model Model with the issue we have loaded
         * @param {Object} options
         * @param {boolean} options.isNewIssue Wheter the loaded issue is a new issue
         */
            "loadComplete",

        /**
         * @event loadError
         * Triggered when there is an error when loading an issue.
         *
         * @param {Object} options
         */
            "loadError",

        /**
         * @event close
         * We should close to issue view in response to some action.
         */
            "close",

        /**
         * @event replacedFocusedPanel
         * Triggered when the view has rendered a panel that has the focus
         * //TODO This seems to be too specific, why others needs to know about this?
         */
            "replacedFocusedPanel",

        /**
         * @event linkToIssue
         * When a user clicks on a link to an issue
         */
            "linkToIssue"
        ],

        /**
         * @constructor
         * Initialize this module and all the services/controllers
         *
         * //TODO When this module is transformed into a Marionette.Module, this should be onStart()
         *
         * @param {Object} options
         * @param {boolean|function} [options.showReturnToSearchOnError=false] Whether the error views should display a 'Return to Search' link
         */
        initialize: function(options) {
            options = options || {};

            this.model = new IssueModel();
            this.eventBus = new IssueEventBus();
            this.viewIssueData = new ViewIssueData();

            // Services
            this._buildIssueLoader();
            this._buildLinksCapturer();

            // Controllers
            this._buildErrorController({
                showReturnToSearchOnError: options.showReturnToSearchOnError
            });
            this._buildIssueController();

            Events.bind(Types.REFRESH_ISSUE_PAGE, _.bind(function(e, issueId, options) {
                if (this.model.isCurrentIssue(issueId)) {
                    this.refreshIssue(options);
                }
            }, this));
        },

        /**
         * Builds the issueLoader service and listens for its events
         *
         * @private
         */
        _buildIssueLoader: function() {
            this.issueLoader = new IssueLoader();

            this.listenTo(this.issueLoader, "error", function(reason, props) {
                this.trigger("loadError", props);
                this.errorController.render(reason, props.issueKey);
                this.removeIssueMetadata();

                // Traces
                trace("jira.issue.refreshed", {id: props.issueId});

                // JIRA Events
                Events.trigger(Types.ISSUE_REFRESHED, [props.issueId]);
            });

            this.listenTo(this.issueLoader, "issueLoaded", this._onIssueLoaded);
        },

        _buildLinksCapturer: function() {
            this.linksCapturer = new LinksCapturer();
            this.listenTo(this.linksCapturer, {
                "linkToIssue": function(options){
                    this.trigger("linkToIssue", options);
                },
                "refineViewer": function(event) {
                    this.trigger("refineViewer", event);
                },
                "reorderSubtasks": function() {
                    this.issueController.showLoading();
                    this.refreshIssue({
                        reason: Actions.UPDATE
                    }).always(_.bind(function(){
                        this.issueController.hideLoading();
                    }, this));
                }
            });
        },

        /**
         * Builds the ErrorController
         *
         * @param {Object} options
         * @param {boolean|function} [options.showReturnToSearchOnError=false] Whether the error views should display a 'Return to Search' link
         * @private
         */
        _buildErrorController: function(options) {
            options = options || {};

            this.errorController = new ErrorController({
                contextPath: contextPath,
                showReturnToSearchOnError: options.showReturnToSearchOnError
            });

            this.listenTo(this.errorController, "before:render", function() {
                this.issueController.close();
            });

            this.listenTo(this.errorController, "returnToSearch", function() {
                this.trigger("close");
            });

            this.listenAndRethrow(this.errorController, "render");
        },

        /**
         * Builds the Issue controller, the main controller for viewing issues
         * @private
         */
        _buildIssueController: function() {
            this.issueController = new IssueController({
                model: this.model
            });
            this.listenTo(this.issueController, "render", function(regions, options) {
                Utils.hideDropdown();
                this.errorController.close();
                this.trigger("render", regions, options);

                trace("jira.psycho.issue.refreshed", {id: this.model.getId()});
            });
            this.listenAndRethrow(this.issueController, "replacedFocusedPanel");
            this.listenTo(this.issueController, "panelRendered", function(panel, $ctx) {
                this.eventBus.triggerPanelRendered(panel, $ctx);
            });
            this.listenTo(this.issueController, "close", function() {
                Utils.hideDropdown();
            });
        },

        /**
         * Update our model with new data
         *
         * @param {Object} data
         * @param {Object} options
         */
        _updateModel: function(data, options) {
            this.model.update(data, options);
        },

        /**
         * Handler for issueLoaded, when an issue has been loaded by IssueLoader service
         *
         * @param {Object} data
         * @param {Object} meta
         * @param {Object} options
         * @private
         */
        _onIssueLoaded: function(data, meta, options) {
            //TODO Why issueEntity is not loaded from data?
            var isPrefetchEnabled = !DarkFeatures.NO_PREFETCH.enabled();
            var issueEntity = options.issueEntity;
            // TODO options.initialize, meta.mergeIntoCurrent and meta.isUpdate seems to represent the same thing
            //      Investigate if all of them are in use and are actually necessary
            var initialize = !meta.mergeIntoCurrent && options.initialize !== false;
            var isNewIssue = !this.model.isCurrentIssue(issueEntity.id);
            var detailView = !!issueEntity.detailView;

            // Clear previous model and errors if this is not an update or is the initial render
            if (!meta.isUpdate || initialize) {
                this.model.resetToDefault();
                this.errorController.close();
            }

            // Update the model with the new data
            this._updateModel(data, {
                initialize: initialize,
                changed: meta.changed,
                mergeIntoCurrent: meta.mergeIntoCurrent
            });

            // Clear previous render if this is not an update or is the initial render
            if (!meta.isUpdate || initialize) {
                this.issueController.close();
            }
            // Display the controller
            this.issueController.show();

            // Refresh the issue if it is loaded from the cache
            if (isPrefetchEnabled && meta.fromCache) {
                this.refreshIssue(issueEntity, {
                    fromCache: true,
                    mergeIntoCurrent: !meta.error, // If we previously showed error then load everything instead of merging.
                    detailView: detailView  // JRA-36659: keep track of whether we are in detail view
                });
            }

            // Save issue metadata
            MetadataService.addIssueMetadata(this.model);

            //TODO This should be moved to issueController. Also, issueEntity has no business with bringToFocus
            if (issueEntity.bringToFocus) {
                issueEntity.bringToFocus();
            }

            this.trigger("loadComplete", this.model, {
                isNewIssue: isNewIssue,
                issueId: issueEntity.id,
                issueKey: issueEntity.key,
                duration: meta.loadDuration,
                loadReason: meta.fromCache ? 'issues-cache-refresh' : undefined,
                fromCache: meta.fromCache
            });

            // Traces
            var traceData = {id: issueEntity.id};
            if (meta.fromCache) {
                trace('jira.issue.loadFromCache', traceData);
            } else {
                trace('jira.issue.loadFromServer', traceData);
            }
            trace("jira.issue.refreshed", traceData);

            // JIRA Events
            Events.trigger(Types.ISSUE_REFRESHED, [issueEntity.id]);
        },

        /**
         * Cancels any pending load so that their handlers aren't called
         */
        abortPending: function() {
            this.issueLoader.cancel();
        },

        /**
         * Shows a dirty form warning if the comment field has been modified.
         *
         * @returns {boolean}
         */
        canDismissComment: function() {
            return this.issueController.canDismissComment();
        },

        /**
         * Clean up before hiding an issue (hide UI widgets, remove metadata, etc.).
         */
        beforeHide: function() {
            Utils.hideLightbox();
            Utils.hideDropdown();
            this.abortPending();
            this.removeIssueMetadata();
        },

        /**
         * Prepare for an issue to be shown.
         */
        beforeShow: function() {
            MetadataService.addIssueMetadata(this.model);
        },

        /**
         * @return {null|number} the current issue's ID or null if no valid issue is selected.
         */
        getIssueId: function() {
            return this.model.getEntity().id || null;
        },

        /**
         * @return {null|string} the current issue's key or null if no valid issue is selected.
         */
        getIssueKey: function() {
            return this.model.getEntity().key || null;
        },

        /**
         * Loads an issue already rendered by the server.
         *
         * @param {Object} issueEntity
         */
        _loadIssueFromDom: function(issueEntity) {
            // Many places in KickAss use the presence of an issue ID / key to determine if an issue is selected. We
            // can't extract either from an error message, so pass a dud ID to make it look like an issue is selected.
            if (!issueEntity.id || issueEntity.id === -1) {
                this.errorController.applyToDom("notfound", issueEntity.key);
                this.trigger("loadError");
            } else {
                this.issueController.applyToDom({
                    id: issueEntity.id || -1,
                    key: issueEntity.key,
                    viewIssueQuery: issueEntity.viewIssueQuery
                });
            }

            // After initial load, the server rendered view issue page will be the same as
            // regular ajax view issue page. Thus removing the meta so it can resume
            // to work regularly.
            Meta.set("serverRenderedViewIssue", null);

            var traceData = {id: this.getIssueId()};
            //TODO These traces should be inside IssueController, as it has more knowledge about when the issue is loaded
            trace("jira.issue.refreshed", traceData);
        },

        /**
         * Load an issue and show it in the container.
         *
         * @param {Object} issueEntity
         * @param {number} issueEntity.id The issue's ID.
         * @param {string} issueEntity.key The issue's key.
         * @param {string} [issueEntity.viewIssueQuery] The query string that was provided
         *
         * @returns {jQuery.Promise}
         */
        loadIssue: function(issueEntity) {
            var issueKey = jQuery("#key-val");
            var isServerRendered = Meta.get("serverRenderedViewIssue");

            if (isServerRendered) {
                issueEntity.id = issueKey.attr("rel") || -1;
                this._loadIssueFromDom(issueEntity);
                return new jQuery.Deferred().resolve().promise();
            } else {
                if (!this.canDismissComment() || !issueEntity.key) {
                    return new jQuery.Deferred().reject();
                }

                this.issueController.showLoading();
                return this.issueLoader.load({
                    issueEntity: issueEntity,
                    viewIssueData: this.viewIssueData
                });
            }
        },

        /**
         * Refresh the content of the issue, by merging changes from the server.
         *
         * The returned promise is:
         * - resolved when the selected issue is refreshed, or if there is no selected issue
         * - rejected *only* when refreshing the selected issue fails
         *
         * @param {boolean} [options.mergeIntoCurrent] Whether the refresh should merge the retrieved data into the current model
         * @param {function} [options.complete] a function to call after the update has finished
         * @returns {jQuery.Promise}
         */
        refreshIssue: function(options) {
            var promise;
            options = _.defaults({}, options, {
                mergeIntoCurrent: true
            });

            if (this.model.hasIssue()) {
                promise = this.issueLoader.update({
                    viewIssueData: this.viewIssueData,
                    issueEntity: this.model.getEntity(),
                    mergeIntoCurrent: options.mergeIntoCurrent,
                    detailView: options.detailView // JRA-36659: keep track of whether we are in detail view
                });

                if (options.complete) {
                    promise = promise.done(options.complete).fail(options.complete);
                }

                this.issueController.showLoading();
            } else {
                promise = new jQuery.Deferred().resolve().promise();
            }

            return promise;
        },

        /**
         * Remove the issue metadata
         */
        removeIssueMetadata: function() {
            MetadataService.removeIssueMetadata(this.model);
        },

        /**
         * Set the container that the issue should be rendered into.
         *
         * @param {jQuery} container The container the issue should be rendered into.
         */
        setContainer: function(container) {
            this.linksCapturer.capture(container);
            this.errorController.setElement(container);
            this.issueController.setElement(container);
        },

        /**
         * Returns a deferred that is resolved once issue has loaded.
         * Or straight away if you there are no issue loading in progress.
         *
         * @return {boolean}
         */
        isCurrentlyLoading: function() {
            return this.issueLoader.isLoading();
        },

        /**
         * Updates the current issue with a new ViewIssueQuery
         *
         * @param query {Object} New query to use for the request
         */
        updateIssueWithQuery: function(query) {
            this.model.updateIssueQuery(query);
            this.issueLoader.update({
                viewIssueData: this.viewIssueData,
                issueEntity: this.model.getEntity(),
                mergeIntoCurrent: true
            });
        },

        /**
         * Closes the IssueViewer, cleaning the model and closing all the views
         */
        dismiss: function() {
            this.model.resetToDefault();
            this.errorController.close();
            this.issueController.close();
            this.linksCapturer.destroy();
        },

        close: function() {
            if (this.canDismissComment()) {
                this.dismiss();
                this.trigger("close");
            }
        },

        applyResponsiveDesign: function() {
            this.issueController.applyResponsiveDesign();
        },

        isShowingError: function() {
            return this.errorController.isRendered();
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/IssueViewerAppModule.js' */
define("jira/components/issueviewer/appmodule", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var IssueViewer = require("jira/components/issueviewer");
    var MariontteAppModule = require("jira/components/libs/marionette-1.4.1/appmodule");

    return MariontteAppModule.extend({
        name: "issueViewer",
        generateMasterRequest: true,

        create: function(options) {
            options = _.defaults({}, options, {
                showReturnToSearchOnError: function() {
                    return false;
                }
            });

            return new IssueViewer({
                showReturnToSearchOnError: options.showReturnToSearchOnError
            });
        },

        commands: function() {
            return {
                abortPending: true,
                beforeHide: true,
                beforeShow: true,
                removeIssueMetadata: true,
                updateIssueWithQuery: true,
                close: true,
                setContainer: true,
                dismiss: true
            };
        },

        requests: function() {
            return {
                loadIssue: true,
                canDismissComment: true,
                getIssueId: true,
                getIssueKey: true,
                refreshIssue: true,
                isCurrentlyLoading: true
            };
        },

        events: function() {
            return [
                "loadComplete",
                "loadError",
                "close",
                "render",
                "replacedFocusedPanel",
                "linkToIssue",
                "refineViewer"
            ];
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/templates/Issue.soy' */
// This file was automatically generated from Issue.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.IssueViewer.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.IssueViewer == 'undefined') { JIRA.Components.IssueViewer = {}; }
if (typeof JIRA.Components.IssueViewer.Templates == 'undefined') { JIRA.Components.IssueViewer.Templates = {}; }


JIRA.Components.IssueViewer.Templates.layout = function(opt_data, opt_ignored) {
  return '<div id="issue-content" class="issue-edit-form"><div class="issue-header-container"></div><div class="issue-body-container"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.layout.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.layout';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/templates/IssueHeader.soy' */
// This file was automatically generated from IssueHeader.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.IssueViewer.Templates.Header.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.IssueViewer == 'undefined') { JIRA.Components.IssueViewer = {}; }
if (typeof JIRA.Components.IssueViewer.Templates == 'undefined') { JIRA.Components.IssueViewer.Templates = {}; }
if (typeof JIRA.Components.IssueViewer.Templates.Header == 'undefined') { JIRA.Components.IssueViewer.Templates.Header = {}; }


JIRA.Components.IssueViewer.Templates.Header.opsbar = function(opt_data, opt_ignored) {
  var output = '<div class="ops-cont"><div class="ops-menus aui-toolbar">';
  if (opt_data.issue.operations) {
    var linkGroupList6 = opt_data.issue.operations.linkGroups;
    var linkGroupListLen6 = linkGroupList6.length;
    for (var linkGroupIndex6 = 0; linkGroupIndex6 < linkGroupListLen6; linkGroupIndex6++) {
      var linkGroupData6 = linkGroupList6[linkGroupIndex6];
      if (linkGroupData6.id && linkGroupData6.id == 'view.issue.opsbar') {
        output += '<div class="toolbar-split toolbar-split-left">';
        var subGroupList10 = linkGroupData6.groups;
        var subGroupListLen10 = subGroupList10.length;
        for (var subGroupIndex10 = 0; subGroupIndex10 < subGroupListLen10; subGroupIndex10++) {
          var subGroupData10 = subGroupList10[subGroupIndex10];
          output += JIRA.Components.IssueViewer.Templates.Header.linkGroup({group: subGroupData10, parentGroup: linkGroupData6});
        }
        output += '</div>';
      } else if (linkGroupData6.id && linkGroupData6.id == 'jira.issue.tools') {
        output += '<div class="toolbar-split toolbar-split-right">' + JIRA.Components.IssueViewer.Templates.Header.linkGroup({group: linkGroupData6}) + '</div>';
      }
    }
  }
  output += '</div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Header.opsbar.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Header.opsbar';
}


JIRA.Components.IssueViewer.Templates.Header.legacyIssueHeader = function(opt_data, opt_ignored) {
  return '<div class="issue-header-content"><div id="issue-header-pager">' + ((opt_data.pager) ? JIRA.Components.IssueViewer.Templates.Header.pager(opt_data.pager) : '') + '</div><div id="heading-avatar"><img id="project-avatar" alt="" class="project-avatar-48" height="48" src="' + soy.$$escapeHtml(opt_data.issue.project.avatarUrls['48x48']) + '" width="48"></div><ul class="breadcrumbs"><li><a id="project-name-val" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.issue.project.key) + '">' + soy.$$escapeHtml(opt_data.issue.project.name) + '</a> </li>' + ((opt_data.issue.parent && opt_data.issue.parent.id) ? '<li><a class="issue-link" data-issue-key="' + soy.$$escapeHtml(opt_data.issue.parent.key) + '" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.issue.parent.key) + '" id="parent_issue_summary" title="' + soy.$$escapeHtml(opt_data.issue.parent.summary) + '">' + soy.$$escapeHtml(opt_data.issue.parent.key) + ' ' + soy.$$escapeHtml(opt_data.issue.parent.summary) + '</a> </li>' : '') + '<li><a class="issue-link" data-issue-key="' + soy.$$escapeHtml(opt_data.issue.key) + '" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.issue.key) + '" id="key-val" rel="' + soy.$$escapeHtml(opt_data.issue.id) + '">' + soy.$$escapeHtml(opt_data.issue.key) + '</a></li></ul><h1 id="summary-val">' + soy.$$escapeHtml(opt_data.issue.summary) + '</h1><div class="command-bar">' + ((opt_data.serverRenderedViewIssue) ? JIRA.Components.IssueViewer.Templates.Header.opsbar(opt_data) : '') + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Header.legacyIssueHeader.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Header.legacyIssueHeader';
}


JIRA.Components.IssueViewer.Templates.Header.issueHeader = function(opt_data, opt_ignored) {
  return '<div class="issue-header-content">' + aui.page.pageHeader({content: '' + ((opt_data.issue.project) ? aui.page.pageHeaderImage({content: '' + JIRA.Templates.Headers.projectAvatar({id: '' + soy.$$escapeHtml(opt_data.issue.project.id), projectKey: '' + soy.$$escapeHtml(opt_data.issue.project.key), projectName: '' + soy.$$escapeHtml(opt_data.issue.project.name), avatarUrl: '' + soy.$$escapeHtml(opt_data.issue.project.avatarUrls['48x48']), avatarAlt: '' + soy.$$escapeHtml(opt_data.issue.project.name), isSystemAvatar: opt_data.issue.project.systemAvatar, hasProjectShortcut: opt_data.hasProjectShortcut})}) + aui.page.pageHeaderMain({content: '<ol class="aui-nav aui-nav-breadcrumbs"><li><a id="project-name-val" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.issue.project.key) + '">' + soy.$$escapeHtml(opt_data.issue.project.name) + '</a></li>' + ((opt_data.issue.parent && opt_data.issue.parent.id) ? '<li><a class="issue-link" data-issue-key="' + soy.$$escapeHtml(opt_data.issue.parent.key) + '" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.issue.parent.key) + '" id="parent_issue_summary" title="' + soy.$$escapeHtml(opt_data.issue.parent.summary) + '">' + soy.$$escapeHtml(opt_data.issue.parent.key) + ' ' + soy.$$escapeHtml(opt_data.issue.parent.summary) + '</a></li>' : '') + '<li><a class="issue-link" data-issue-key="' + soy.$$escapeHtml(opt_data.issue.key) + '" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.issue.key) + '" id="key-val" rel="' + soy.$$escapeHtml(opt_data.issue.id) + '">' + soy.$$escapeHtml(opt_data.issue.key) + '</a></li></ol><h1 id="summary-val">' + soy.$$escapeHtml(opt_data.issue.summary) + '</h1>'}) : '') + aui.page.pageHeaderActions({content: '<div id="issue-header-pager">' + ((opt_data.pager) ? JIRA.Components.IssueViewer.Templates.Header.pager(opt_data.pager) : '') + '</div>'})}) + '<div class="command-bar">' + ((opt_data.serverRenderedViewIssue) ? JIRA.Components.IssueViewer.Templates.Header.opsbar(opt_data) : '') + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Header.issueHeader.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Header.issueHeader';
}


JIRA.Components.IssueViewer.Templates.Header.linkGroup = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.group.header && opt_data.group.header.label) {
    output += (opt_data.group.links.length > 0 || opt_data.group.groups.length > 0) ? JIRA.Components.IssueViewer.Templates.Header.dropdownLink(opt_data.group) : '';
  } else {
    output += '<ul ' + ((opt_data.group.id) ? 'id="opsbar-' + soy.$$escapeHtml(opt_data.group.id) + '" ' : '') + 'class="toolbar-group pluggable-ops">';
    var linkList155 = opt_data.group.links;
    var linkListLen155 = linkList155.length;
    for (var linkIndex155 = 0; linkIndex155 < linkListLen155; linkIndex155++) {
      var linkData155 = linkList155[linkIndex155];
      output += JIRA.Components.IssueViewer.Templates.Header.toolbarItem({link: linkData155});
    }
    if (opt_data.group.groups.length == 1 && opt_data.group.groups[0].links.length == 0 && opt_data.group.groups[0].groups.length == 1 && opt_data.group.groups[0].groups[0].links.length == 1) {
      output += JIRA.Components.IssueViewer.Templates.Header.toolbarItem({link: opt_data.group.groups[0].groups[0].links[0]});
    } else {
      var subGroupList164 = opt_data.group.groups;
      var subGroupListLen164 = subGroupList164.length;
      for (var subGroupIndex164 = 0; subGroupIndex164 < subGroupListLen164; subGroupIndex164++) {
        var subGroupData164 = subGroupList164[subGroupIndex164];
        output += JIRA.Components.IssueViewer.Templates.Header.linkGroup({group: subGroupData164});
      }
    }
    output += '</ul>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Header.linkGroup.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Header.linkGroup';
}


JIRA.Components.IssueViewer.Templates.Header.dropdownLink = function(opt_data, opt_ignored) {
  var output = '<li class="toolbar-item toolbar-dropdown"><div><a href="#" ' + ((opt_data.header.id) ? ' id="' + soy.$$escapeHtml(opt_data.header.id) + '"' : '') + JIRA.Components.IssueViewer.Templates.Header.titleAttr({title: opt_data.header.title, label: opt_data.header.label}) + ' data-hide-on-scroll=".split-view .issue-container" data-contain-to-window="true" class="toolbar-trigger ' + ((opt_data.links.length > 0 || opt_data.groups.length > 0) ? ' js-default-dropdown' : '') + ((opt_data.header.styleClass) ? ' ' + soy.$$escapeHtml(opt_data.header.styleClass) : '') + '" >' + ((opt_data.header.iconClass) ? '<span class="icon ' + soy.$$escapeHtml(opt_data.header.iconClass) + '"></span> ' : '') + '<span class="dropdown-text">' + soy.$$truncate(soy.$$escapeHtml(opt_data.header.label), 25, true) + '</span><span class="icon drop-menu"></span></a><div class="aui-list hidden">';
  if (opt_data.links.length > 0) {
    output += '<ul class="aui-list-section aui-first' + ((opt_data.groups.length == 0) ? ' aui-last' : '') + '">';
    var linkList204 = opt_data.links;
    var linkListLen204 = linkList204.length;
    for (var linkIndex204 = 0; linkIndex204 < linkListLen204; linkIndex204++) {
      var linkData204 = linkList204[linkIndex204];
      output += JIRA.Components.IssueViewer.Templates.Header.dropdownItem(linkData204);
    }
    output += '</ul>';
  }
  var groupList208 = opt_data.groups;
  var groupListLen208 = groupList208.length;
  for (var groupIndex208 = 0; groupIndex208 < groupListLen208; groupIndex208++) {
    var groupData208 = groupList208[groupIndex208];
    output += '<ul class="aui-list-section' + ((opt_data.links.length == 0 && groupIndex208 == 0) ? ' aui-first' : '') + ((groupIndex208 == groupListLen208 - 1) ? ' aui-last' : '') + '">';
    var linkList217 = groupData208.links;
    var linkListLen217 = linkList217.length;
    for (var linkIndex217 = 0; linkIndex217 < linkListLen217; linkIndex217++) {
      var linkData217 = linkList217[linkIndex217];
      output += JIRA.Components.IssueViewer.Templates.Header.dropdownItem(linkData217);
    }
    output += '</ul>';
  }
  output += '</div></div></li>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Header.dropdownLink.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Header.dropdownLink';
}


JIRA.Components.IssueViewer.Templates.Header.dropdownItem = function(opt_data, opt_ignored) {
  return '<li class="aui-list-item"><a  href="' + ((opt_data.href) ? soy.$$escapeHtml(opt_data.href) : '#') + '" class="aui-list-item-link' + ((opt_data.styleClass) ? ' ' + soy.$$escapeHtml(opt_data.styleClass) : '') + '"' + JIRA.Components.IssueViewer.Templates.Header.titleAttr(opt_data) + ((opt_data.id) ? 'id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + '><span class="trigger-label">' + soy.$$truncate(soy.$$escapeHtml(opt_data.label), 25, true) + '</span></a></li>';
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Header.dropdownItem.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Header.dropdownItem';
}


JIRA.Components.IssueViewer.Templates.Header.toolbarItem = function(opt_data, opt_ignored) {
  return '<li class="toolbar-item"><a id="' + soy.$$escapeHtml(opt_data.link.id) + '"' + JIRA.Components.IssueViewer.Templates.Header.titleAttr({title: opt_data.link.title, label: opt_data.link.label}) + 'class="toolbar-trigger' + ((opt_data.link.styleClass) ? ' ' + soy.$$escapeHtml(opt_data.link.styleClass) : '') + '" href="' + ((opt_data.link.href) ? soy.$$escapeHtml(opt_data.link.href) : '#') + '">' + ((opt_data.link.iconClass) ? '<span class="icon ' + soy.$$escapeHtml(opt_data.link.iconClass) + '"></span> <span class="trigger-label">' + soy.$$truncate(soy.$$escapeHtml(opt_data.link.label), 25, true) + '</span>' : '<span class="trigger-label">' + soy.$$truncate(soy.$$escapeHtml(opt_data.link.label), 25, true) + '</span>') + '</a></li>';
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Header.toolbarItem.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Header.toolbarItem';
}


JIRA.Components.IssueViewer.Templates.Header.titleAttr = function(opt_data, opt_ignored) {
  return '' + ((opt_data.title) ? 'title="' + soy.$$escapeHtml(opt_data.title) + '"' : (opt_data.label && opt_data.label.length && opt_data.label.length > 25) ? 'title="' + soy.$$escapeHtml(opt_data.label) + '"' : '');
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Header.titleAttr.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Header.titleAttr';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/templates/IssueBody.soy' */
// This file was automatically generated from IssueBody.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.IssueViewer.Templates.Body.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.IssueViewer == 'undefined') { JIRA.Components.IssueViewer = {}; }
if (typeof JIRA.Components.IssueViewer.Templates == 'undefined') { JIRA.Components.IssueViewer.Templates = {}; }
if (typeof JIRA.Components.IssueViewer.Templates.Body == 'undefined') { JIRA.Components.IssueViewer.Templates.Body = {}; }


JIRA.Components.IssueViewer.Templates.Body.issueBody = function(opt_data, opt_ignored) {
  return '' + JIRA.Components.IssueViewer.Templates.Body.issueBodyWithPanels({panels: false, serverRenderedViewIssue: false});
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Body.issueBody.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Body.issueBody';
}


JIRA.Components.IssueViewer.Templates.Body.issueBodyWithPanels = function(opt_data, opt_ignored) {
  var output = '<div class="aui-group issue-body"><div class="aui-item issue-main-column">';
  if (opt_data.serverRenderedViewIssue) {
    var panelList10 = opt_data.panels.leftPanels;
    var panelListLen10 = panelList10.length;
    for (var panelIndex10 = 0; panelIndex10 < panelListLen10; panelIndex10++) {
      var panelData10 = panelList10[panelIndex10];
      output += JIRA.Components.IssueViewer.Templates.Body.issuePanel(panelData10);
    }
  }
  output += '</div><div id="viewissuesidebar" class="aui-item issue-side-column">';
  if (opt_data.serverRenderedViewIssue) {
    var panelList16 = opt_data.panels.rightPanels;
    var panelListLen16 = panelList16.length;
    for (var panelIndex16 = 0; panelIndex16 < panelListLen16; panelIndex16++) {
      var panelData16 = panelList16[panelIndex16];
      output += JIRA.Components.IssueViewer.Templates.Body.issuePanel(panelData16);
    }
  }
  output += '</div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Body.issueBodyWithPanels.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Body.issueBodyWithPanels';
}


JIRA.Components.IssueViewer.Templates.Body.issuePanel = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.renderHeader) {
    output += '<div id=' + soy.$$escapeHtml(opt_data.id) + ' class="module toggle-wrap"><div id="' + soy.$$escapeHtml(opt_data.id) + '_heading" class="mod-header"><ul class="ops">';
    var linkList28 = opt_data.headerLinks.links;
    var linkListLen28 = linkList28.length;
    for (var linkIndex28 = 0; linkIndex28 < linkListLen28; linkIndex28++) {
      var linkData28 = linkList28[linkIndex28];
      output += '<li>' + JIRA.Components.IssueViewer.Templates.Body.simpleLink({link: linkData28}) + '</li>';
    }
    if (opt_data.headerLinks.groups.length > 0) {
      output += '<li class="drop"><div class="aui-dd-parent"><a href="#" class="icon drop-menu js-default-dropdown" title="' + soy.$$escapeHtml("Options") + '"><span>' + soy.$$escapeHtml("Options") + '</span></a><div class="aui-dropdown-content aui-list">';
      var groupList41 = opt_data.headerLinks.groups;
      var groupListLen41 = groupList41.length;
      for (var groupIndex41 = 0; groupIndex41 < groupListLen41; groupIndex41++) {
        var groupData41 = groupList41[groupIndex41];
        output += ((groupData41.header && groupData41.header.label) ? '<h5>' + soy.$$escapeHtml(groupData41.header.label) + '</h5>' : '') + '<ul ' + ((groupData41.header && groupData41.header.id) ? 'id="' + soy.$$escapeHtml(groupData41.header.id) + '"' : '') + 'class="aui-list-section' + ((groupData41.header && groupData41.header.styleClass) ? ' ' + soy.$$escapeHtml(groupData41.header.styleClass) : '') + ((groupIndex41 == 0) ? ' aui-first' : '') + ((groupIndex41 == groupListLen41 - 1) ? ' aui-last' : '') + '">';
        var linkList65 = groupData41.links;
        var linkListLen65 = linkList65.length;
        for (var linkIndex65 = 0; linkIndex65 < linkListLen65; linkIndex65++) {
          var linkData65 = linkList65[linkIndex65];
          output += '<li class="aui-list-item">' + JIRA.Components.IssueViewer.Templates.Body.simpleLink({link: linkData65, additionalStyleClass: 'aui-list-item-link'}) + '</li>';
        }
        output += '</ul>';
      }
      output += '</div></div></li>';
    }
    output += '</ul>';
    if (opt_data.subpanelHtmls.length > 0) {
      output += '<div class="mod-header-panels">';
      var subPanelList79 = opt_data.subpanelHtmls;
      var subPanelListLen79 = subPanelList79.length;
      for (var subPanelIndex79 = 0; subPanelIndex79 < subPanelListLen79; subPanelIndex79++) {
        var subPanelData79 = subPanelList79[subPanelIndex79];
        output += '<div class="mod-header-panel">' + soy.$$filterNoAutoescape(subPanelData79) + '</div>';
      }
      output += '</div>';
    }
    output += '<h2 class="toggle-title">' + soy.$$escapeHtml(opt_data.label) + '</h2></div><div class="mod-content">' + soy.$$filterNoAutoescape(opt_data.html) + '</div></div>';
  } else {
    output += soy.$$filterNoAutoescape(opt_data.html);
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Body.issuePanel.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Body.issuePanel';
}


JIRA.Components.IssueViewer.Templates.Body.errorsLoading = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  var output = '' + ((opt_data.isTimeout) ? soy.$$escapeHtml("The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.") : soy.$$escapeHtml("There were errors loading the issue."));
  if (opt_data.errorMessages) {
    output += '<ul>';
    var msgList104 = opt_data.errorMessages;
    var msgListLen104 = msgList104.length;
    for (var msgIndex104 = 0; msgIndex104 < msgListLen104; msgIndex104++) {
      var msgData104 = msgList104[msgIndex104];
      output += '<li>' + soy.$$escapeHtml(msgData104) + '</li>';
    }
    output += '</ul>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Body.errorsLoading.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Body.errorsLoading';
}


JIRA.Components.IssueViewer.Templates.Body.focusShifter = function(opt_data, opt_ignored) {
  return '<div class="aui-message closeable" id="focus-shifter"><label><span>' + soy.$$escapeHtml("viewissue.focusshifter") + '</span><div id="focus-shifter-content"></div></label><span class="aui-icon icon-close"></span></div>';
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Body.focusShifter.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Body.focusShifter';
}


JIRA.Components.IssueViewer.Templates.Body.simpleLink = function(opt_data, opt_ignored) {
  return '<a' + ((opt_data.link.id) ? ' id="' + soy.$$escapeHtml(opt_data.link.id) + '"' : '') + 'href="' + ((opt_data.link.href) ? soy.$$escapeHtml(opt_data.link.href) : '#') + '"' + ((opt_data.link.styleClass || opt_data.additionalStyleClass) ? 'class="' + soy.$$escapeHtml(opt_data.link.styleClass) + ((opt_data.additionalStyleClass) ? ' ' + soy.$$escapeHtml(opt_data.additionalStyleClass) : '') + '"' : '') + ((opt_data.link.title) ? 'title="' + soy.$$escapeHtml(opt_data.link.title) + '"' : '') + '><span>' + soy.$$escapeHtml(opt_data.link.label) + '</span></a>';
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Body.simpleLink.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Body.simpleLink';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/templates/IssueError.soy' */
// This file was automatically generated from IssueError.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.IssueViewer.Templates.Error.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.IssueViewer == 'undefined') { JIRA.Components.IssueViewer = {}; }
if (typeof JIRA.Components.IssueViewer.Templates == 'undefined') { JIRA.Components.IssueViewer.Templates = {}; }
if (typeof JIRA.Components.IssueViewer.Templates.Error == 'undefined') { JIRA.Components.IssueViewer.Templates.Error = {}; }


JIRA.Components.IssueViewer.Templates.Error.NoPermission = function(opt_data, opt_ignored) {
  return '' + JIRA.Components.IssueViewer.Templates.Error.Generic(null);
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Error.NoPermission.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Error.NoPermission';
}


JIRA.Components.IssueViewer.Templates.Error.DoesNotExist = function(opt_data, opt_ignored) {
  return '' + JIRA.Components.IssueViewer.Templates.Error.fancyViewIssueError({title: "This issue can\x27t be viewed", body: "The issue you\x27re trying to view can\x27t be displayed.", bodyAfter: "It may have been deleted or you don\x27t have permission to view it right now.", error: 'canNotBeViewed', showReloadButton: false});
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Error.DoesNotExist.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Error.DoesNotExist';
}


JIRA.Components.IssueViewer.Templates.Error.Generic = function(opt_data, opt_ignored) {
  return '' + JIRA.Components.IssueViewer.Templates.Error.fancyViewIssueError({title: "This issue can\x27t be displayed right now", body: "It could be for a variety of reasons, like a network or application error.", bodyAfter: "Try reloading the page.", error: 'genericError', showReloadButton: true});
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Error.Generic.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Error.Generic';
}


JIRA.Components.IssueViewer.Templates.Error.fancyViewIssueError = function(opt_data, opt_ignored) {
  return '' + JIRA.Components.IssueViewer.Templates.Error.baseViewIssueError({header: '<header class="aui-page-header"><div class="aui-page-header-inner"><div class="aui-page-header-actions"><div id="issue-header-pager"></div></div></div></header>', body: '<div class="issue-error"><span class="error-image error-image-' + soy.$$escapeHtml(opt_data.error) + '"></span><h1>' + soy.$$escapeHtml(opt_data.title) + '</h1><p>' + soy.$$escapeHtml(opt_data.body) + '<br />' + soy.$$escapeHtml(opt_data.bodyAfter) + '</p>' + ((opt_data.showReloadButton) ? '<p><button id="issue-error-reload-button" class="aui-button aui-button-primary">Reload</button></p>' : '') + '</div>'});
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Error.fancyViewIssueError.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Error.fancyViewIssueError';
}


JIRA.Components.IssueViewer.Templates.Error.viewIssueError = function(opt_data, opt_ignored) {
  return '' + JIRA.Components.IssueViewer.Templates.Error.baseViewIssueError({header: '<header class="aui-page-header"><div class="aui-page-header-inner"><div class="aui-page-header-main"><h1>' + soy.$$escapeHtml(opt_data.title) + '</h1></div><div class="aui-page-header-actions"><div id="issue-header-pager"></div></div></div></header>', body: '<div class="aui-message ' + soy.$$escapeHtml(opt_data.error) + '"><span class="aui-icon icon-' + soy.$$escapeHtml(opt_data.error) + '"></span><p>' + soy.$$escapeHtml(opt_data.body) + '</p><p>' + soy.$$escapeHtml("If you think this message is wrong, please contact your") + ' <a href="' + soy.$$escapeHtml("/jira") + '/secure/ContactAdministrators!default.jspa">' + soy.$$escapeHtml("JIRA administrators") + '</a>.</p>' + ((opt_data.returnToSearch) ? '<p><a id="return-to-search" class="push-state" href="' + soy.$$escapeHtml("/jira") + '/issues/" title="' + soy.$$escapeHtml("Return to search") + '">' + soy.$$escapeHtml("Return to search") + '</a></p>' : '') + '</div>'});
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Error.viewIssueError.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Error.viewIssueError';
}


JIRA.Components.IssueViewer.Templates.Error.baseViewIssueError = function(opt_data, opt_ignored) {
  return '<div id="issue-content"><header class="issue-header issue-error-header"><div class="issue-header-content">' + soy.$$filterNoAutoescape(opt_data.header) + '</div></header><div class="issue-body-content issue-error-content">' + soy.$$filterNoAutoescape(opt_data.body) + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Components.IssueViewer.Templates.Error.baseViewIssueError.soyTemplateName = 'JIRA.Components.IssueViewer.Templates.Error.baseViewIssueError';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/templates/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/components/issueviewer/templates", function() {
    "use strict";

    return JIRA.Components.IssueViewer.Templates;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed. Later, we can restore the
 * global reference if needed (see ../js/namespace.js)
 */
AJS.namespace("JIRA.Components.IssueViewer.Templates", null, require("jira/components/issueviewer/templates"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueviewer', location = 'issueviewer/js/namespace.js' */
AJS.namespace("JIRA.Components.IssueViewer", null, require("jira/components/issueviewer"));
AJS.namespace("JIRA.Components.IssueViewer.AppModule", null, require("jira/components/issueviewer/appmodule"));
AJS.namespace("JIRA.Components.IssueViewer.Utils", null, require("jira/components/issueviewer/utils"));

AJS.namespace("JIRA.Components.IssueViewer.Controllers.Error", null, require("jira/components/issueviewer/controllers/error"));
AJS.namespace("JIRA.Components.IssueViewer.Controllers.Issue", null, require("jira/components/issueviewer/controllers/issue"));

AJS.namespace("JIRA.Components.IssueViewer.Models.Issue", null, require("jira/components/issueviewer/entities/issue"));
AJS.namespace("JIRA.Components.IssueViewer.Models.Panel", null, require("jira/components/issueviewer/entities/panel"));
AJS.namespace("JIRA.Components.IssueViewer.Collections.Panels", null, require("jira/components/issueviewer/entities/panels"));
AJS.namespace("JIRA.Components.IssueViewer.Models.PanelsGroup", null, require("jira/components/issueviewer/entities/panelsgroup"));

AJS.namespace("JIRA.Components.IssueViewer.Legacy.AsyncData", null, require("jira/components/issueviewer/legacy/asyncdata"));
AJS.namespace("JIRA.Components.IssueViewer.Legacy.IssueEventBus", null, require("jira/components/issueviewer/legacy/issueeventbus"));
AJS.namespace("JIRA.Components.IssueViewer.Legacy.IssueFieldUtil", null, require("jira/components/issueviewer/legacy/issuefieldutil"));
AJS.namespace("JIRA.Components.IssueViewer.Legacy.ViewIssueData", null, require("jira/components/issueviewer/legacy/viewissuedata"));

AJS.namespace("JIRA.Components.IssueViewer.Services.DarkFeatures", null, require("jira/components/issueviewer/services/darkfeatures"));
AJS.namespace("JIRA.Components.IssueViewer.Services.IssueLoader", null, require("jira/components/issueviewer/services/issueloader"));
AJS.namespace("JIRA.Components.IssueViewer.Services.Metadata", null, require("jira/components/issueviewer/services/metadataservice"));

AJS.namespace("JIRA.Components.IssueViewer.Views.ErrorGeneric", null, require("jira/components/issueviewer/views/errorgeneric"));
AJS.namespace("JIRA.Components.IssueViewer.Views.ErrorNotFound", null, require("jira/components/issueviewer/views/errornotfound"));
AJS.namespace("JIRA.Components.IssueViewer.Views.Error", null, require("jira/components/issueviewer/views/error"));
AJS.namespace("JIRA.Components.IssueViewer.Views.IssueBody", null, require("jira/components/issueviewer/views/issuebody"));
AJS.namespace("JIRA.Components.IssueViewer.Views.IssueHeader", null, require("jira/components/issueviewer/views/issueheader"));
AJS.namespace("JIRA.Components.IssueViewer.Views.IssueOpsbar", null, require("jira/components/issueviewer/views/issueopsbar"));
AJS.namespace("JIRA.Components.IssueViewer.Views.IssuePanels", null, require("jira/components/issueviewer/views/issuepanels"));
AJS.namespace("JIRA.Components.IssueViewer.Views.IssuePanel", null, require("jira/components/issueviewer/views/issuepanel"));
AJS.namespace("JIRA.Components.IssueViewer.Views.Issue", null, require("jira/components/issueviewer/views/issue"));

//Re-export the templates, because they were removed from the global namespace
//when we exported "JIRA.Components.IssueViewer" at the beginning of this file.
AJS.namespace("JIRA.Components.IssueViewer.Templates", null, require("jira/components/issueviewer/templates"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/IssueEditor.js' */
define("jira/components/issueeditor", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var DarkFeatures = require("jira/components/issueviewer/services/darkfeatures");
    var EditIssueController = require("jira/components/issueeditor/controllers/editissue");
    var Events = require('jira/util/events');
    var EventTypes = require("jira/components/issueeditor/eventtypes");
    var FieldsController = require("jira/components/issueeditor/controllers/fields");
    var FieldsLoader = require("jira/components/issueeditor/services/fieldsloader");
    var IssueSaver = require("jira/components/issueeditor/services/issuesaver");
    var IssueViewer = require("jira/components/issueviewer");
    var Meta = require("jira/util/data/meta");
    var ModalFieldView = require("jira/components/issueeditor/views/modalfield");
    var SaveErrorView = require("jira/components/issueeditor/views/saveerror");
    var SaveInProgressManager = require("jira/components/issueeditor/services/saveinprogressmanager");
    var Trace = window.JIRA;
    var UnloadInterceptor = require("jira/components/issueeditor/services/unloadinterceptor");

    var contextPath = window.AJS.contextPath();

    var trace = function() {
        Trace.trace.apply(Trace, arguments);
    };

    /**
     * A module that handles loading and showing issues in a given container.
     */
    return IssueViewer.extend({
        namedEvents: [
            /*
             Triggered when an issue has loaded successfully.
             */
            "loadComplete",

            /*
             Triggered when there is an error when loading an issue.
             */
            "loadError",

            /*
             We should return to issue search in response to some action.
             */
            "returnToSearch",

        /**
         * Triggered when inline edit is successful
         * .. {number} the issue id
         */
            "saveSuccess",

            "saveError",

            "editField",

            "editFieldCancel",

        /**
         * Field has been submitted by user.
         */
            "fieldSubmitted",

        /**
         * The issue panel that previously had focus was replaced.
         */
            "replacedFocusedPanel"
        ],

        /**
         * @constructor
         * Initialize this module and all the services/controllers
         *
         * //TODO When this module is transformed into a Marionette.Module, this should be onStart()
         *
         * @param {Object} options
         * @param {boolean|function} [options.showReturnToSearchOnError=false] Whether the error views should display a 'Return to Search' link
         */
        initialize: function(options) {
            IssueViewer.prototype.initialize.call(this, options);

            // Services
            this._buildFieldsLoader();
            this._buildIssueSaver();

            // Controllers
            this._buildEditIssueController();
            this._buildFieldsController();

            // Other services
            this._handleUnload();

            this.listenAndRethrow(this.eventBus, "fieldSubmitted");
        },

        _buildFieldsLoader: function() {
            this.fieldsLoader = new FieldsLoader({
                contextPath: contextPath
            });

            this.listenTo(this.fieldsLoader, "fieldsLoaded", function(result) {
                this.viewIssueData.updateIssue(result.issueKey, result);

                // Ensure issueID is a number, otherwise some checks might fail
                result.issueId = Number(result.issueId);

                var editable = result.fields && result.fields.length;
                if (editable) {
                    this.editIssueController.update(result);
                } else {
                    this.editIssueController.reset();
                }

                trace("jira.issue.fields.loaded", {id: result.issueId});
            });

            this.listenTo(this.fieldsLoader, "fieldsError", function(result) {
                this.fieldsController.showError(result.errorCollection, result.isTimeout);
                trace("jira.issue.fields.loaded", {id: result.issueId});
            });
        },

        _buildIssueSaver: function() {
            this.saveInProgressManager = new SaveInProgressManager();

            this.issueSaver = new IssueSaver({
                saveInProgressManager: this.saveInProgressManager,
                model: this.model
            });

            this.listenTo(this.issueSaver, "error", function(options) {
                var issueId = options.issueId;
                var attemptedSavedIds = options.attemptedSavedIds;
                var response = options.response;
                var duration = options.duration;

                // Show a global error if the issue is no longer visible.
                if (!this.model.isCurrentIssue(issueId)) {
                    this._showSaveError({
                        issueId: issueId,
                        issueKey: options.issueKey,
                        response: response
                    });
                    return;
                }

                this.eventBus.triggerSaveError(issueId, attemptedSavedIds, response);

                // if no longer editable, reload our model
                var isEditable = response && response.fields && response.fields.length;
                if (!isEditable && response) {
                    this.editIssueController.reset();
                    this.model.update(response, {
                        fieldsSaved: [],
                        fieldsInProgress: []
                    });
                }

                this.trigger("saveError", {
                    issueId: issueId,
                    duration: duration,
                    deferred: false
                });

                trace("jira.issue.refreshed", {id: issueId});
            });

            this.listenTo(this.issueSaver, "saveStarted", function(issueId, savedFieldIds) {
                this.eventBus.triggerSavingStarted(savedFieldIds);
            });

            this.listenTo(this.issueSaver, "save", function(options) {
                var issueId = options.issueId;
                var issueKey = options.issueKey;
                var savedFieldIds = options.savedFieldIds;
                var savedFieldTypes = options.savedFieldTypes;
                var response = options.response;
                var shouldSkipSaveIssueSuccessHandler = options.shouldSkipSaveIssueSuccessHandler;
                var duration = options.duration;

                if (this.model.isCurrentIssue(issueId) && !shouldSkipSaveIssueSuccessHandler) {
                    this.eventBus.triggerSaveSuccess(issueId, issueKey, savedFieldIds, response);

                    // Updating view issue cache with the new data we get back from a successful save.
                    this.viewIssueData.set(issueKey, response);

                    // Update the model with the new data, including the list of fields still in progress
                    this.model.update(response, {
                        fieldsSaved: savedFieldIds,
                        fieldsInProgress: this.editIssueController.getEditsInProgress()
                    });

                    trace("jira.psycho.issue.refreshed", {id: issueId});

                    // Don't check for the meta value if the page is standalone view issue page
                    // because it doesn't exist
                    var editable = response.fields && response.fields.length;
                    if (editable) {
                        this.editIssueController.update({
                            fields: response.fields,
                            issueId: issueId,
                            issueKey: issueKey
                        }, {
                            editable: true,
                            editIssueController: this.editIssueController,
                            issueModel: this.model,
                            issueId: issueId,
                            fieldsSaved: savedFieldIds,
                            initialize: false,
                            fieldsInProgress: this.editIssueController.getEditsInProgress()
                        });
                    }

                    trace("jira.issue.refreshed", {id: issueId});
                }
                this.trigger("saveSuccess", {
                    issueId: issueId,
                    issueKey: issueKey,
                    savedFieldIds: savedFieldIds,
                    savedFieldTypes: savedFieldTypes,
                    duration: duration
                });
            });
        },

        _buildEditIssueController: function() {
            this.editIssueController = new EditIssueController({
                issueEventBus: this.eventBus
            });
            this.listenTo(this.editIssueController, "save", function(issueId, issueKey, toSaveIds, params, ajaxProperties, toSaveTypes) {
                //Make sure we don't skip the SaveIssueHandler
                //While the save request is being processed, this handler will be set to being skipped if the ViewIssue
                //module has been closed
                this.issueSaver.setSkipSaveIssueSuccessHandler(false);
                this.issueSaver.save(issueId, issueKey, toSaveIds, params, ajaxProperties, toSaveTypes);
            });
            this.listenAndRethrow(this.editIssueController, "editField");
            this.listenAndRethrow(this.editIssueController, "editFieldCancel");
        },

        _buildFieldsController: function() {
            this.fieldsController = new FieldsController();
        },

        _onIssueLoaded: function(data, meta, options) {
            if (data.issue.isEditable) {
                // If this issue is NOT from the cache and this is NOT an update, request the fields from the server
                var isPrefetchEnabled = !DarkFeatures.NO_PREFETCH.enabled();
                if (isPrefetchEnabled && !meta.error && !meta.fromCache) {
                    this.fieldsLoader.load({
                        viewIssueData: this.viewIssueData,
                        issueEntity: options.issueEntity
                    });
                }
            }

            var initialize = !meta.mergeIntoCurrent && options.initialize !== false;
            if (!meta.isUpdate || initialize) {
                this.editIssueController.reset();
            }
            IssueViewer.prototype._onIssueLoaded.call(this, data, meta, options);

            // If we have fields data, update it
            // This needs to be done after calling the original onIssueLoaded, as that method can reset
            // the editIssue controller
            if (data.fields) {
                this.editIssueController.update({
                    fields: data.fields,
                    issueId: data.issue.id,
                    issueKey: data.issue.key
                });
                trace("jira.issue.fields.loaded", {id: data.issue.id});
            }
        },

        _handleUnload: function() {
            var unloadHandler = _.bind(function() {
                var result;
                if (this.editIssueController.getDirtyEditsInProgress().length > 0) {
                    result = "You are still editing this page. Are you sure you want to leave?";
                }
                return result;
            }, this);
            this.unloadInterceptor = new UnloadInterceptor();

            this.unloadInterceptor.addAfterEvent(unloadHandler);
            this.on("destroy", function() {
                this.unloadInterceptor.removeAfterEvent(unloadHandler);
            });
        },

        _updateModel: function(data, options) {
            // Update editIssueController when whe update the model
            var editable = data.fields && data.fields.length;
            if (editable) {
                this.editIssueController.update(data.fields, {
                    fieldsInProgress: this.editIssueController.getEditsInProgress(),
                    changed: options.changed
                });
            }

            options = _.extend({}, options, {
                fieldsInProgress: this.editIssueController.getEditsInProgress()
            });
            IssueViewer.prototype._updateModel.call(this, data, options);
        },

        _loadIssueFromDom: function(issueEntity) {
            if (Meta.get("server-view-issue-is-editable")) {
                // Edit Issue Controller
                this.editIssueController.setIssueId(issueEntity.id);
                this.editIssueController.setIssueKey(issueEntity.key);

                this.fieldsLoader.load({
                    viewIssueData: this.viewIssueData,
                    issueEntity: issueEntity
                });
                Meta.set("server-view-issue-is-editable", null);
            }
            IssueViewer.prototype._loadIssueFromDom.call(this, issueEntity);
        },

        /**
         * Initiate the editing of a field.
         *
         * @param {JIRA.Components.IssueEditor.Models.Field} field The field to edit.
         */
        editField: function(field) {
            if (!field.isEditable()) return;

            var issue = this.model.getEntity();
            // Defer determining whether the field is present until
            // after the save completes; it may be removed by the save.
            var execute = _.bind(function() {
                if (field.matchesFieldSelector()) {
                    field.edit();
                } else {
                    new ModalFieldView({
                        issueEventBus: this.eventBus,
                        model: field,
                        issue: issue
                    }).show();
                }
            }, this);

            if (!field.getSaving()) {
                execute();
            } else {
                Events.one(EventTypes.ISSUE_REFRESHED, function() {
                    execute();
                });
            }
        },

        /**
         * Cancels any pending load so that their handlers aren't called
         */
        abortPending: function() {
            this.fieldsLoader.cancel();
            IssueViewer.prototype.abortPending.call(this);
        },

        /**
         * Clean up before hiding an issue (hide UI widgets, remove metadata, etc.).
         */
        beforeHide: function() {
            this.issueSaver.setSkipSaveIssueSuccessHandler(true);
            IssueViewer.prototype.beforeHide.call(this);
        },

        /**
         * Set the container that the issue should be rendered into.
         *
         * @param {element} container The container the issue should be rendered into.
         */
        setContainer: function(container) {
            this.editIssueController.setIssueViewContext(container);
            IssueViewer.prototype.setContainer.call(this, container);
        },

        dismiss: function() {
            this.editIssueController.reset();
            IssueViewer.prototype.dismiss.call(this);
        },

        getFields: function() {
            return this.editIssueController.getFields();
        },

        hasSavesInProgress: function() {
            return this.saveInProgressManager.hasSavesInProgress();
        },

        /**
         * Create and show a `SaveError`.
         *
         * @param {object} options
         * @param {string} options.issueId The ID of the issue that failed to save.
         * @param {string} options.issueKey The key of the issue that failed to save.
         * @param {object} options.response An `IssueSaverService` response.
         * @private
         */
        _showSaveError: function(options) {
            var saveError;
            var stopListening;

            saveError = new SaveErrorView(options).render();
            stopListening = _.partial(this.stopListening, saveError);

            this.listenTo(saveError, {
                close: stopListening,
                issueLinkClick: function(issueData) {
                    // Poor man preventable event
                    var ev = {
                        isPrevented: false,
                        preventDefault: function(){ this.isPrevented = true; },
                        isDefaultPrevented: function(){ return this.isPrevented === true; },
                        issueData: issueData
                    };
                    this.trigger("linkInErrorMessage", ev);

                    if (!ev.isDefaultPrevented()) {
                        this.loadIssue(issueData);
                    }
                }
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/IssueEditorAppModule.js' */
define("jira/components/issueeditor/appmodule", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var IssueEditor = require("jira/components/issueeditor");
    var IssueViewerAppModule = require("jira/components/issueviewer/appmodule");

    return IssueViewerAppModule.extend({
        name: "issueEditor",
        generateMasterRequest: true,

        create: function(options) {
            options = _.defaults({}, options, {
                showReturnToSearchOnError: function() {
                    return false;
                }
            });

            return new IssueEditor({
                showReturnToSearchOnError: options.showReturnToSearchOnError
            });
        },

        commands: function(module) {
            var viewerCommands = IssueViewerAppModule.prototype.commands.call(this, module);
            return _.extend(viewerCommands, {
                "editField": true
            });
        },

        requests: function(module) {
            var viewerRequests = IssueViewerAppModule.prototype.requests.call(this, module);
            return _.extend(viewerRequests, {
                "fields": function() {
                    return module.getFields();
                },
                "hasSavesInProgress": true
            });
        },

        events: function(module) {
            var viewerEvents = IssueViewerAppModule.prototype.events.call(this, module);

            return viewerEvents.concat([
                "saveSuccess",
                "saveError",
                "editField",
                "editFieldCancel",
                "fieldSubmitted"
            ]);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/NoInlineAppModule.js' */
define("jira/components/issueeditor/noinlineappmodule", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var IssueViewerAppModule = require("jira/components/issueviewer/appmodule");

    return IssueViewerAppModule.extend({
        name: "issueEditor",

        requests: function(module) {
            var viewerRequests = IssueViewerAppModule.prototype.requests.call(this, module);
            return _.extend(viewerRequests, {
                "fields": function() {
                    return [];
                },
                "hasSavesInProgress": function() {
                    return false;
                }
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/templates/Fields.soy' */
// This file was automatically generated from Fields.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueEditor.Fields.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueEditor == 'undefined') { JIRA.Templates.IssueEditor = {}; }
if (typeof JIRA.Templates.IssueEditor.Fields == 'undefined') { JIRA.Templates.IssueEditor.Fields = {}; }


JIRA.Templates.IssueEditor.Fields.saveErrorMessage = function(opt_data, opt_ignored) {
  var output = '';
  var issueLink__soy3 = '<a class="issue" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.issueKey) + '">' + soy.$$escapeHtml(opt_data.issueKey) + '</a>';
  output += soy.$$filterNoAutoescape(AJS.format("Saving of \x3cstrong\x3e{0}\x3c/strong\x3e failed!",issueLink__soy3));
  if (opt_data.errors.length > 0) {
    output += '<ul>';
    var messageList16 = opt_data.errors;
    var messageListLen16 = messageList16.length;
    for (var messageIndex16 = 0; messageIndex16 < messageListLen16; messageIndex16++) {
      var messageData16 = messageList16[messageIndex16];
      output += '<li>' + soy.$$escapeHtml(messageData16) + '</li>';
    }
    output += '</ul>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueEditor.Fields.saveErrorMessage.soyTemplateName = 'JIRA.Templates.IssueEditor.Fields.saveErrorMessage';
}


JIRA.Templates.IssueEditor.Fields.field = function(opt_data, opt_ignored) {
  return '<form id="' + soy.$$escapeHtml(opt_data.issue.id) + '-form" class="ajs-dirty-warning-exempt aui" action= "#"><div class="inline-edit-fields">' + soy.$$filterNoAutoescape(opt_data.issue.editHtml) + '</div><span class="overlay-icon throbber" /><div class="save-options"><button type="submit" class="aui-button submit" accessKey="' + soy.$$escapeHtml("s") + '" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to submit this form","s",opt_data.accessKey)) + '"><span class="aui-icon aui-icon-small aui-iconfont-success">' + soy.$$escapeHtml("Save") + '</span></button><button type="cancel" class="aui-button cancel" accessKey="' + soy.$$escapeHtml("`") + '" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to cancel","`",opt_data.accessKey)) + '"><span class="aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Cancel") + '</span></button></div></form>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueEditor.Fields.field.soyTemplateName = 'JIRA.Templates.IssueEditor.Fields.field';
}


JIRA.Templates.IssueEditor.Fields.modalField = function(opt_data, opt_ignored) {
  return '<div class="aui-dialog-content"><h2 class="dialog-title">' + soy.$$escapeHtml(AJS.format("Edit {0} for {1}",opt_data.field.label,opt_data.issue.key)) + '</h2><form action="" class="aui" method="post"><div class="form-body">' + soy.$$filterNoAutoescape(opt_data.field.editHtml) + '</div><div class="buttons-container form-footer"><div class="buttons"><input class="button" type="submit" value="' + soy.$$escapeHtml("Submit") + '"/><a class="cancel" href="#">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueEditor.Fields.modalField.soyTemplateName = 'JIRA.Templates.IssueEditor.Fields.modalField';
}


JIRA.Templates.IssueEditor.Fields.modalFieldGeneralErrors = function(opt_data, opt_ignored) {
  var output = '<div class="error">';
  if (opt_data.messages.length == 1) {
    output += soy.$$escapeHtml(opt_data.messages[0]);
  } else if (opt_data.messages.length > 0) {
    output += '<ul>';
    var messageList59 = opt_data.messages;
    var messageListLen59 = messageList59.length;
    for (var messageIndex59 = 0; messageIndex59 < messageListLen59; messageIndex59++) {
      var messageData59 = messageList59[messageIndex59];
      output += '<li>' + soy.$$escapeHtml(messageData59) + '</li>';
    }
    output += '</ul>';
  }
  output += '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueEditor.Fields.modalFieldGeneralErrors.soyTemplateName = 'JIRA.Templates.IssueEditor.Fields.modalFieldGeneralErrors';
}


JIRA.Templates.IssueEditor.Fields.errorsLoading = function(opt_data, opt_ignored) {
  var output = '' + ((opt_data.isTimeout) ? soy.$$escapeHtml("The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.") : soy.$$escapeHtml("There were errors loading the issue."));
  if (opt_data.errorMessages) {
    output += '<ul>';
    var msgList75 = opt_data.errorMessages;
    var msgListLen75 = msgList75.length;
    for (var msgIndex75 = 0; msgIndex75 < msgListLen75; msgIndex75++) {
      var msgData75 = msgList75[msgIndex75];
      output += '<li>' + soy.$$escapeHtml(msgData75) + '</li>';
    }
    output += '</ul>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueEditor.Fields.errorsLoading.soyTemplateName = 'JIRA.Templates.IssueEditor.Fields.errorsLoading';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/templates/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/components/issueeditor/templates", function() {
    "use strict";

    return JIRA.Templates.IssueEditor.Fields;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed. Later, we can restore the
 * global reference if needed (see ../js/namespace.js)
 */
AJS.namespace("JIRA.Templates.IssueEditor.Fields", null, require("jira/components/issueeditor/templates"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/entities/FieldModel.js' */
define("jira/components/issueeditor/entities/field", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var Events = require('jira/util/events');
    var IssueFieldUtil = require("jira/components/issueviewer/legacy/issuefieldutil");
    var jQuery = require("jquery");
    var skate = require("jira/skate");
    var Templates = require("jira/components/issueeditor/templates");
    var Types = require("jira/components/issueeditor/eventtypes");

    return Brace.Model.extend({
        namedEvents: [
        /**
         * Triggered when editing is started. Lets the field view know to switch to use editHTML
         */
            "editingStarted",

        /**
         * Triggered when editing is desired but the field is already in edit mode.
         */
            "focusRequested",
        /**
         * Triggered when editing is cancelled. Lets the field view know to switch to use viewHTML
         */
            "editingCancelled",
        /**
         * Triggered when a save is required. This lets the JIRA.Components.IssueEditor.Controllers.EditIssue know to trigger a save
         */
            "save",
        /**
         * Triggered when an kind of save error has occurred (including server/validation errors).
         * This lets the field view know to hide loading indicator.
         */
            "saveError",

        /**
         * Triggered when saving started
         */
            "savingStarted",

        /**
         * Triggered when save has been completed. Successful or not. Lets the field view know to give indication to user.
         */
            "saveComplete",

        /**
         * Triggered when save has been successful. Lets the field view know to give indication to user.
         */
            "saveSuccess",
        /**
         * Triggered when we need to update the [params] property with the serialized value of the edit html
         */
            "updateRequired",
        /**
         * Triggered when there is a validation error on the server
         */
            "validationError",
        /**
         * Triggered when edit permissions are revoked
         */
            "modelDestroyed"
        ],

        namedAttributes: [
        /**
         * Field id
         * @type String
         */
            "id",

        /**
         * serialized input field parameters retrieved from server (ie editHtml).
         * @type object
         */
            "initParams",
        /**
         * Serialized input field parameters that the user has changed.
         * @type object
         */
            "params",
        /**
         * Html to displayed when editing this field
         * @type String
         */
            "editHtml",
        /**
         * Html to displayed when viewing this field
         * @type String
         */
            "viewHtml",
        /**
         * Is this field required
         * @type Boolean
         */
            "required",
        /**
         * The key the field type (complete key) for custom fields (for system fields this value is undefined).
         * The value is set upon initialisation of the view.
         * @type String
         */
            "fieldType",

        /**
         * True if the field should be displayed in edit mode
         * @type Boolean
         */
            "editing",
        /**
         * True if the field is currently being saved
         * @type Boolean
         */
            "saving",
        /**
         * Validation errors returned from server on attempted save
         * @type Object
         */
            "error",
        /**
         * Human readable localised name.
         * @type String
         */
            "label",
        /**
         * Current field content identifier token..
         * @type String
         */
            "contentId"
        ],

        /**
         * @constructor
         */
        initialize: function() {
            if (this.collection) {
                var instance = this;
                this.collection.on("reset", function() {
                    instance.triggerModelDestroyed();
                });
            }
            this.on("change:viewHtml", function() {
                var $previous = this.previous("viewHtml");
                if ($previous) {
                    // We may have view html with event handlers still attached. As we use detach instead of remove.
                    // This can cause memory leaks unless we destroy properly
                    jQuery.cleanData($previous);
                }
            });
            this.onModelDestroyed(function() {
                var $view = this.getViewHtml();
                if ($view) {
                    // We may have view html with event handlers still attached. As we use detach instead of remove.
                    // This can cause memory leaks unless we destroy properly
                    jQuery.cleanData($view);
                }
            });
        },

        /**
         * Handling for when the field is trying to be programmatically switched out of edit mode.
         *
         * @see JIRA.Components.IssueEditor.Collections.Fields._handleEditingStarted to see how this works
         */
        blurEdit: function() {
            if (this.getEditing()) {
                if (this.isDirty() || this.hasValidationError()) {
                    this.save();
                } else {
                    this.cancelEdit();
                }
            }
        },

        /**
         * Sets validation error
         * @param {String} editHtml - The new edit html for the field
         * @param {String}  error - Error Message
         */
        setValidationError: function(errorHtml, error, focus) {
            this.setSaving(false);
            this.setError(error);
            //other fields shouldn't care about this field showing a validation error
            this.edit({ignoreBlur: true});
            this.triggerSaveError();
            this.triggerValidationError(errorHtml, focus);
        },

        /**
         * Lets everyone know we have an error
         */
        handleSaveError: function() {
            this.setSaving(false);
            this.triggerSaveError();
        },

        /**
         * Cancels edit. Will switch view out of edit mode
         */
        cancelEdit: function(reason) {
            if (!this.cancelLocked) {
                var event = new jQuery.Event(Types.BEFORE_INLINE_EDIT_CANCEL);
                Events.trigger(event, [this.getId(), this.getFieldType(), reason]);
                if (!event.isDefaultPrevented()) {
                    this.cancelLocked = true;
                    if (this.getEditing() || this.getSaving()) {
                        this.setEditing(false);
                        this.setSaving(false);
                        this.unset("params");
                        this.unset("initParams");
                        this.triggerEditingCancelled();
                        this.unset("viewHtml");
                    }
                    delete this.cancelLocked;
                }
            }
        },

        /**
         * Starts editing. Will switch view into edit mode.
         * @param {Object} props
         * ... {Boolean} ignoreBlur - Usually we trigger a save or cancel on the an other fields in edit mode when we
         * start editing another field. This flag prevents that. This is useful to avoid focus theft by an in-flight error.
         */
        edit: function(props) {
            if (!this.getEditing()) {
                this.setEditing(true);
                this.triggerEditingStarted(this, props);
            } else if (!props || !props.ignoreBlur) {
                this.triggerFocusRequested(this, props);
            }
        },

        /**
         * Gets the current serialized value of the field(s)
         * @return {Object}
         */
        getCurrentParams: function() {
            this.triggerUpdateRequired();
            var params = {};
            // TODO: only return this.getParams() when we can change quick edit endpoint to not require *all* values
            if (this.getParams()) {
                params = this.getParams();
            }
            else if (this.getInitParams()) {
                params = this.getInitParams();
            }
            else {
                var $el = jQuery('<div />').html(this.getEditHtml());
                this.setInitParams(this._serializeObject($el));
                params = this.getInitParams();
            }
            var fp = {};
            _.each(params, function(value, key) {
                fp[key] = value;
            });
            return fp;
        },

        /**
         * Looks to see if the edit html actually has a field the user can edit. For example if we have not components
         * configured for a project there will be no field to edit so the field is not editable.
         *
         * @return {Boolean}
         */
        isEditable: function() {
            if (this.getEditHtml()) {
                // TODO: JRADEV-9709: replace with flag that comes back from quick edit
                return jQuery(this.getEditHtml()).find("textarea, :text,:radio,:checkbox, select").length !== 0;
            }
            return false;
        },

        /**
         * Do we have a validation error
         * @return {Boolean}
         */
        hasValidationError: function() {
            return !!this.getError();
        },

        /**
         * Popluates element with editHTML. Stores the $el's html as the view html, so that if we cancelEdit we can
         * restore it.
         *
         * @param {jQuery} $el
         */
        switchElToEdit: function($el) {
            if (!this.getViewHtml()) {
                this.setViewHtml($el.contents());
            }

            $el.contents().detach();

            $el.html(Templates.field({
                issue: this.toJSON(),
                accessKey: IssueFieldUtil.getAccessKeyModifier()
            }));
            // Attempt to force web component (skate) mutations
            $el.each(function() {
                skate.init(this);
            });

            if (!this.getInitParams()) {
                this.setInitParams(this._serializeObject($el));
            }
            this.setEditing(true);
        },

        /**
         * Serializes fields of el into params property
         * @param {jQuery} $el
         */
        update: function($el) {
            if (this.getEditing()) {
                this.setParams(this._serializeObject($el));
            }
        },

        handleSaveSuccess: function() {
            this.setSaving(false);
            this.setEditing(false);
            this.unset("viewHtml");
            this.unset("initParams");
            this.setError(null);
            this.triggerSaveSuccess();
        },

        handleSaveStarted: function() {
            this.setSaving(true);
            this.triggerSavingStarted();
        },

        /**
         * Initiates a save. This lets the JIRA.Components.IssueEditor.Controllers.EditIssue know to trigger a save.
         */
        save: function() {
            if (!this.getSaving()) {
                // Get the view to update model with serialized form field
                this.triggerUpdateRequired();
                this.triggerSave(this);
            }
        },

        /**
         * Has the field been modified
         * @return {Boolean}
         */
        isDirty: function() {
            this.triggerUpdateRequired();
            // Get the view to update model with serialized form field
            return this._isDirty(this.getCurrentParams());
        },

        /**
         * Has the field been modified
         * @return {Boolean}
         */
        _isDirty: function(params) {
            return JSON.stringify(params) !== JSON.stringify(this.getInitParams());
        },

        matchesFieldSelector: function() {
            return IssueFieldUtil.matchesFieldSelector(this.id);
        },

        /**
         * Serialize the inputs in an element to an object.
         *
         * The object's keys are the inputs' names, its values their values.
         *
         * @param {element} element A DOM element.
         * @private
         * @returns {Object} An object representation of `element`'s inputs.
         */
        _serializeObject: function(element) {
            var data = {};

            var dataArray = jQuery(element).find(":input").serializeArray();

            jQuery.each(dataArray, function() {
                if (data[this.name]) {
                    if (!data[this.name].push) {
                        data[this.name] = [data[this.name]];
                    }
                    data[this.name].push(this.value || '');
                } else {
                    data[this.name] = this.value || '';
                }
            });

            return data;
        }
    }, {
        /**
         * @param {FieldModel} fieldModel The FieldModel to test.
         * @return A boolean indicating whether fieldModel is editable.
         */
        IS_EDITABLE: function(fieldModel) {
            return fieldModel.isEditable();
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/entities/FieldCollection.js' */
define("jira/components/issueeditor/entities/fields", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var FieldModel = require("jira/components/issueeditor/entities/field");

    return Brace.Collection.extend({
        model: FieldModel,

        initialize: function() {
            this.on("editingStarted", this._handleEditingStarted, this);
        },

        _handleEditingStarted: function(editModel, props) {
            props = props || {};
            if (props.ignoreBlur) {
                return;
            }
            // Let any field in edit mode know we want to edit another
            this.each(function(model) {
                if (editModel !== model && model.getEditing()) {
                    model.blurEdit();
                }
            });
        },

        update: function(data, props) {
            var instance = this;

            if (props && props.changed) {
                var changedData = props.changed;
                var updatedFields = changedData.updated ? changedData.updated.fields : [];
                var addedFields = changedData.added ? changedData.added.fields : [];

                _.each(data, function(modelData) {
                    if (_.contains(updatedFields, modelData.id)) {
                        var existingModel = instance.get(modelData.id);

                        if (existingModel) {
                            // JRADEV-11518 Don't update the model's editHtml if it's an error,
                            // since it will override the 'real' editHtml
                            if (existingModel.hasValidationError()) {
                                delete modelData.editHtml;
                            }
                            existingModel.set(modelData, {silent: true});
                            instance.trigger("updated", existingModel);
                        } else {
                            instance.add(modelData);
                        }
                    } else if (_.contains(addedFields, modelData.id)) {
                        instance.add(modelData);
                    }
                });
            } else {
                _.each(data, function(modelData) {
                    var existingModel = instance.get(modelData.id);
                    if (existingModel) {
                        // JRADEV-11518 Don't update the model's editHtml if it's an error,
                        // since it will override the 'real' editHtml
                        if (existingModel.hasValidationError()) {
                            delete modelData.editHtml;
                        }
                        existingModel.set(modelData, {silent: true});
                        instance.trigger("updated", existingModel);
                    } else {
                        instance.add(modelData);
                    }
                });
            }
        },

        cancelEdit: function() {
            this.each(function(model) {
                model.cancelEdit();
            });
        },

        isDirty: function() {
            return this.any(function(item) {
                return item.isDirty();
            });
        },
        getDirtyFields: function() {
            return this.filter(function(item) {
                return item.isDirty();
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/views/FieldView.js' */
define("jira/components/issueeditor/views/field", ["require"], function(require){
    "use strict";

    var CancelReason = require("jira/components/issueeditor/cancelreasons");
    var Events = require('jira/util/events');
    var IssueFieldUtil = require("jira/components/issueviewer/legacy/issuefieldutil");
    var jQuery = require("jquery");
    var MarionetteItemView = require('jira/components/libs/marionette-1.4.1/itemview');
    var Reasons = require('jira/util/events/reasons');
    var Templates = require("jira/components/issueeditor/templates");
    var Types = require("jira/components/issueeditor/eventtypes");

    /**
     * Handles the saving, editing and canceling of an Issue Field.
     */
    return MarionetteItemView.extend({

        events: {
            "click .cancel": "onClickCancel",
            "keyup": "onKeyCancel",
            "click .submit": "onSubmit",
            "click": "onEdit",
            "mousedown": "saveSelectedText",
            "submit form": "onSubmit",
            'keydown select[multiple="multiple"]': "_enterToSubmitMultiSelect",
            'keypress select': "_enterToSubmitSelect",
            "beforeBlurInput *": "_preventBlurByEsc"
        },

        initialize: function(options) {

            this.model.on("validationError", this.handleValidationError, this);
            this.model.on("editingStarted", this.switchToEdit, this);
            this.model.on("focusRequested", this.focus, this);
            this.model.on("editingCancelled", this.switchToRead, this);
            this.model.on("saveError", this.handleSaveError, this);
            this.model.on("updateRequired", this.updateModel, this);
            this.model.on("savingStarted", this.handleSavingStarted, this);
            this.model.on("modelDestroyed", this.destroy, this);

            this.decorate();

            this.issueEventBus = options.issueEventBus;
            this.issueEventBus.on("panelRendered", this.handlePanelRendered, this);

            this.model.setFieldType(this.$el.data('fieldtypecompletekey'));

            this._editDelay = 0;

            var instance = this;

            Events.bind(Types.INLINE_EDIT_BLURRED, function(e, fieldId) {
                if (fieldId === instance.model.getId()) {
                    instance._onPossibleBlur();
                }
            });

            Events.bind(Types.INLINE_EDIT_REQUESTED, function(e, fieldId) {
                if (fieldId !== instance.model.getId() && instance._editDelay !== 0) {
                    clearTimeout(instance._editDelay);
                    instance._editDelay = 0;
                }
            });
        },

        /**
         *  Unbinds events for collection
         */
        destroy: function() {
            // all model handlers are unbound as a result of the collection being reset. We just need to handle the event bus
            this.issueEventBus.off("panelRendered", this.handlePanelRendered);
        },

        /**
         * Wraps the display value of a field to offer :hover edit prompts.
         */
        decorate: function() {
            if (this.model.isEditable() && !this.model.getEditing()) {
                this.$el.addClass("editable-field inactive");
                this.$el.append('<span class="overlay-icon aui-icon aui-icon-small aui-iconfont-edit" />');
                this._addToolTip();
            }
        },

        /**
         * Returns field's edit elements, i.e. excluding save options and throbber
         */
        getEditElements: function() {
            return this.$el.find(".inline-edit-fields");
        },

        /**
         * Adds an edit prompting tooltip to the issue field value.
         */
        _addToolTip: function() {
            this.$el.attr("title", "Click to edit");
            // override the tooltip on anchors without
            jQuery("a:not([title])", this.$el).attr("title", "Follow link");
        },

        _removeToolTip: function() {
            this.$el.removeAttr("title");
        },

        _stealAccessKeys: function() {
            jQuery("[accessKey='" + "s" + "']").attr("accessKey", "_s");
            jQuery("[accessKey='" + "`" + "']").attr("accessKey", "_x");
        },

        _returnAccessKeys: function() {
            jQuery("[accessKey=_s]").attr("accessKey", "s");
            jQuery("[accessKey=_x]").attr("accessKey", "`");
        },

        _handleEditingStarted: function(focus) {
            var $fieldTools = this.$el.find('.field-tools');

            Events.trigger(Types.NEW_CONTENT_ADDED, [this.$el, Reasons.inlineEditStarted]);
            Events.trigger(Types.INLINE_EDIT_STARTED, [this.model.getId(), this.model.getFieldType(), this.getEditElements(), this.$el]);

            // Resize textareas, if any, to the right size
            this.$el.find(".textarea")
                .css("height", Math.max(this._originalHeight, 60))
                // 100 is roughly enough space, plus a bit more, for a heading (in the case of description),
                // a wrapped field label (for example Assignee if the window is narrow enough), and the save/cancel controls
                .expandOnInput(window.innerHeight - jQuery('#stalker').height() - 100);

            if (focus) {
                this.$el.find(":input:visible:first").focus();
            }
            if (!this.$el.find(".error").size()) {
                this.$el.find("select.aui-ss-select").each(function() {
                    var $this = jQuery(this);
                    if ($this.data("static-suggestions")) {
                        $this.trigger("showSuggestions");
                    }
                });
            }
            this.$el.find('.save-options').attr('tabindex', 1).prepend($fieldTools);
        },

        handleValidationError: function(errorHtml, focus) {
            this.$el.html(Templates.field({
                issue: {
                    id: this.model.id,
                    editHtml: errorHtml
                },
                accessKey: IssueFieldUtil.getAccessKeyModifier()
            }));
            this.$el.find(".error").addClass("inline-edit-error").attr("data-field", this.model.id);
            this._handleEditingStarted(focus);
        },

        handlePanelRendered: function(panel, $ctx) {
            var $newEl = jQuery(IssueFieldUtil.getFieldSelector(this.model.id), $ctx);
            if ($newEl.length === 1) {
                this.$el = $newEl;
                this.el = this.$el[0];
                this.decorate();
                this.delegateEvents();
            }
        },

        /**
         * Called in the event of a save error.
         *
         * Ensures the view is in edit mode so the error can be rectified.
         */
        handleSaveError: function() {
            this.$el.find(":input").removeAttr("disabled").trigger("enable");
            this.$el.removeClass("saving saving-" + this.model.id);
        },

        /**
         * The view is put into saving mode and any input is disabled to prevent changes whilst the save request is in flight.
         */
        handleSavingStarted: function() {
            this.$el.find(":input").attr("disabled", "disabled").trigger("disable");
            this.$el.addClass("saving saving-" + this.model.id);
        },

        updateModel: function() {
            this.model.update(this.$el);
        },

        /**
         * Reveals the Issue Field View's element.
         *
         * Reveal the element in the following situations (or a combination of them) by triggering.
         *  - Scrolled off screen.
         *  - Scrolled behind the stalker.
         *  - Toggle open a closed twixie container which contains the field.
         *  - Select an unselected tab of containing the field.
         *  - Toggle open a closed twixie container containing a closed tab which contains the element.
         *
         * This is done by:
         *  - Using scrollIntoView to eagerly reveal the position of the element on the screen.
         *  - Triggering a reveal event on the element which is subscribed to by parent elements to reveal if necessary.
         *
         *  Additional marginTop is given to scrollIntoView to ensure the field itself and it's label element are in view.
         *  i.e. Assignee and Reporter have stacked labels in certain situations.
         */
        reveal: function() {
            var padding = 40;
            this.$el.scrollIntoView({
                direction: "y",
                marginBottom: padding,
                marginTop: jQuery("#stalker").outerHeight(true) + padding
            });
            this.$el.trigger("reveal");
        },

        focus: function() {
            this.reveal();
            // Ensure the field being focused is not disabled (throws an error in IE8)
            this.$el.find(":input").removeAttr("disabled");

            // Don't focus if a modal dialog is present. Note: this doesn't affect
            // ModalIssueFieldView as it doesn't use IssueFieldView.
            if (jQuery(".aui-blanket").length === 0) {
                var $element = this.$el.find(":input:visible:first");
                $element.focus();
                if (!this.$el.hasClass("field-ignore-highlight")) {
                    $element.select();
                }
            }
        },

        /**
         * Transitions the view into the edit state.
         */
        switchToEdit: function() {
            this.trigger("editField", {fieldId: this.model.getId()});
            this._stealAccessKeys();
            this._removeToolTip();
            this.$el.removeClass("inactive saving").addClass("active");
            this._originalHeight = this.$el.height();
            this.model.switchElToEdit(this.$el);
            // NOTE:
            // This order is important! The INLINE_EDIT_STARTED event *must* be dispatched before the
            // edited field is focused, otherwise no INLINE_EDIT_FOCUSED event will be dispatched.
            this._handleEditingStarted();
            this.focus();
        },

        /**
         * Transitions the view into the view state.
         */
        switchToRead: function() {
            this.trigger("editFieldCancel", {fieldId: this.model.getId()});
            this._addToolTip();
            this.$el.addClass("inactive").removeClass("active");
            this.$el.html(this.model.getViewHtml());
            this.$el.closest("form").unbind("submit", this.onSubmit);
            this._returnAccessKeys();
        },

        /**
         * Cancels editing when an escape key is encountered
         * @param e {Event}
         */
        onKeyCancel: function(e) {
            if (e.keyCode === 27) {
                this.model.cancelEdit(CancelReason.escPressed);
                e.preventDefault();
            }
        },

        /**
         * Cancels editing when cancel button is clicked.
         * @param e {Event}
         */
        onClickCancel: function(e) {
            this.model.cancelEdit();
            e.preventDefault();
        },

        onSubmit: function(e) {
            var event = new jQuery.Event("before-submit");
            this.$el.find("form").trigger(event);
            if (!event.isDefaultPrevented()) {
                this.$el.find(':focus').blur(); // JRADEV-10807 Make sure no inputs are capturing events while a save is in progress

                this.issueEventBus.triggerFieldSubmitted();

                // Note: Even though the above blur() will trigger a save on its own,
                // the blur handler checks this.model.getSaving() to ensure we don't
                // fire duplicate save requests.
                this.model.save();
                this._returnAccessKeys();
            }
            e.preventDefault();

        },

        onEdit: function(event) {
            var iconWasClicked = jQuery(event.target).is(".overlay-icon.aui-iconfont-edit");
            var isEditable = jQuery(event.target).closest("a, .uneditable").length === 0 && this.$el.hasClass("inactive");
            var noTextSelected = this._getCurrentlySelectedText() === "" && !this._previouslySelectedText;
            var shouldEnterEditMode = isEditable && (iconWasClicked || noTextSelected);

            if (this._editDelay !== 0) {

                // A click event was received while a pending inline edit request was
                // in progress. Cancel this request, since the user is double-clicking
                // or triple-clicking instead.

                clearTimeout(this._editDelay);
                this._editDelay = 0;

            } else if (shouldEnterEditMode) {

                Events.trigger(Types.INLINE_EDIT_REQUESTED, [this.model.getId()]);

                var self = this;

                if (iconWasClicked) {

                    // If this click event occurred directly on the pencil icon, enter
                    // inline edit mode straight away.
                    //
                    // We handle this event on the document to allow event listeners
                    // registered on ancestors to have the opportunity to preventDefault()
                    // and thus cancel inline edit.

                    jQuery(document).one("click", function(event) {
                        if (!event.isDefaultPrevented()) {
                            self.model.edit();
                        }
                    });

                } else {

                    // If this click occurs somewhere else on the field besides the pencil
                    // icon, wait briefly to allow the user the opportunity to double-click.
                    // Double-clicks will abort the pending transition to inline edit mode.

                    this._editDelay = setTimeout(function() {
                        if (!event.isDefaultPrevented() && self.$el.hasClass("inactive") && self._getCurrentlySelectedText() === "") {
                            self.model.edit();
                        }
                        self._editDelay = 0;
                    }, 250);
                }
            }
        },

        /**
         * Either the field inputs have blurred, or the save options have blurred,
         * but we need to check if both are blurred
         */
        _onPossibleBlur: function() {
            if (this.model.getSaving()) {
                // Saving is already in progress. No need to trigger save-on-blur.
                return;
            }
            if (jQuery(".aui-blanket").length > 0) {
                // A modal dialog interrupted; don't try to save. This doesn't
                // affect ModalIssueFieldView as it doesn't use IssueFieldView.
                return;
            }
            this.model.blurEdit();
        },

        /**
         * Prevent AUI's default handler from blurring inputs when pressing the Esc key, since we handle this ourselves in onCancel.
         * This stops the field from being blurred by pressing Esc when the calendar dropdown is shown.
         */
        _preventBlurByEsc: function(e) {
            e.preventDefault();
        },

        /**
         * @private
         * @return {string}
         */
        _getCurrentlySelectedText: function() {
            if (jQuery(document.activeElement).is(":input")) {
                // Text selections inside form elements are not considered.
                return "";
            }
            if (document.selection && document.selection.createRange) {
                return document.selection.createRange().text || "";
            }
            if (window.getSelection) {
                return window.getSelection().toString();
            }
            return "";
        },

        /**
         * JRA-30597 Cause Enter key on <select>s to submit the form (save inline edit).
         *
         * Chrome does this by itself but not Firefox or IE.
         */
        _enterToSubmitSelect: function(e) {
            if (!e.isDefaultPrevented()) {
                if (e.which === 13) {
                    e.preventDefault(); // Chrome already submits on Enter key
                    jQuery(e.target).closest('form').submit();
                }
            }
        },

        /**
         * JRA-30597 Cause Enter key on <select multiple="multiple">s to blur the <select>, causing a save-on-blur.
         *
         * This is necessary because if multiple options are selected, pressing enter will unselect all of them and select only
         * one option. This is confusing for users who expect enter to preserve their current selection and submit the inline edit.
         */
        _enterToSubmitMultiSelect: function(e) {
            if (!e.isDefaultPrevented()) {
                if (e.which === 13) {
                    jQuery(e.target).blur();
                }
            }
        },

        /**
         * Text selection is cleared after mousedown; this method stores it in an
         * instance variable so we can determine in onEdit if selection was cleared.
         */
        saveSelectedText: function() {
            this._previouslySelectedText = this._getCurrentlySelectedText();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/views/ModalFieldView.js' */
define("jira/components/issueeditor/views/modalfield", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Events = require('jira/util/events');
    var FormDialog = require('jira/dialog/form-dialog');
    var MarionetteItemView = require('jira/components/libs/marionette-1.4.1/itemview');
    var Templates = require("jira/components/issueeditor/templates");

    /**
     * A modal dialog for editing the value of a field.
     *
     * @param {JIRA.Components.IssueViewer.Legacy.IssueEventBus} options.issueEventBus
     * @param {JIRA.Components.IssueEditor.Models.Field} options.model The field to edit.
     * @param {{id: string, key: string}} options.issue The issue on which the field will be edited
     */
    return MarionetteItemView.extend({
        errorsTemplate: Templates.modalFieldGeneralErrors,
        template: Templates.modalField,

        initialize: function(options) {
            _.bindAll(this,
                "_onHide",
                "_onSubmit",
                "_remove",
                "_showGeneralError",
                "_showValidationError",
                "_updateModel");

            // Use JIRA.bind to avoid a jQuery bug.
            Events.bind("Dialog.hide", this._onHide);

            this.issueEventBus = options.issueEventBus;
            this.issueEventBus.on("saveError", this._showGeneralError);

            this.model.onSaveSuccess(this._remove);
            this.model.onUpdateRequired(this._updateModel);
            this.model.onValidationError(this._showValidationError);
        },

        /**
         * Prepare the dialog for editing.
         *
         * To be called after a request completes.
         *
         * @private
         */
        _enable: function() {
            var dialog = this._getDialog();
            dialog.hideFooterLoadingIndicator();

            var $el = dialog.$popup;
            $el.find(":input").removeAttr("disabled").trigger("enable");
            $el.find(":input:first").focus().select();
            $el.find(":submit").removeAttr("disabled");
        },

        _getDialog: function() {
            if (!this._dialog) {
                this._dialog = new FormDialog({
                    id: "modal-field-view",
                    submitHandler: this._onSubmit,
                    content: _.bind(function(callback) {
                        callback(this.template({
                            field: this.model.toJSON(),
                            issue: this.options.issue
                        }));
                    }, this)
                });

                // Attach the field's ID to the dialog so ViewIssueController can
                // determine whether a deferred error needs to be shown or not.
                this._dialog.get$popup().data("field-id", this.model.getId());
            }

            return this._dialog;
        },

        _onHide: function(e, $popup) {
            if ($popup === this._getDialog().get$popup()) {
                this._remove();
            }
        },

        /**
         * Attempts to save the IssueFieldModel.
         *
         * @private
         */
        _onSubmit: function(e, ready) {
            e.preventDefault();
            this.model.save();
            ready();

            var dialog = this._getDialog();
            dialog.showFooterLoadingIndicator();
            dialog.$popup.find(":input").attr("disabled", "disabled")
                .trigger("disable");
        },

        close: function() {
            this._remove();
        },

        /**
         * Destroy the dialog and unbind all event handlers.
         *
         * @private
         */
        _remove: function() {
            var dialog = this._getDialog();
            if (dialog.get$popup().is(":visible")) {
                dialog.hide();
            }

            dialog.destroy();
            this.model.cancelEdit();

            Events.unbind("Dialog.hide", this._onHide);
            this.issueEventBus.off("saveError", this._showGeneralError);
            this.model.off("saveSuccess", this._remove);
            this.model.off("updateRequired", this._updateModel);
            this.model.off("validationError", this._showValidationError);
        },

        /**
         * Show the view.
         */
        show: function() {
            this.model.edit();
            this._getDialog().show();
        },

        /**
         * Show a "general" (non-field-specific) error if necessary.
         *
         * @param issueId The ID of the issue we tried to save.
         * @param fieldIds The IDs of the fields we tried to save.
         * @param response The HTTP response that was returned.
         * @private
         */
        _showGeneralError: function(issueId, fieldIds, response) {
            // We're responding to a general error, so re-enable the controls.
            this._enable();

            var $el = this._getDialog().$popup;

            var errors = response && response.errorCollection;
            if (errors) {
                var hasFieldErrors = !_.isEmpty(errors.errors);
                var hasGeneralErrors = !_.isEmpty(errors.errorMessages);

                if (!hasFieldErrors && hasGeneralErrors) {
                    $el.find(".form-body").append(this.errorsTemplate({
                        messages: errors.errorMessages
                    }));
                }
            }
        },

        /**
         * Show a validation error.
         *
         * @param editHtml The field's edit HTML (including the validation error).
         * @private
         */
        _showValidationError: function(editHtml) {
            this._enable();
            this._getDialog().$popup.find(".form-body").html(editHtml);
        },

        /**
         * Update the model with the user's input.
         *
         * @private
         */
        _updateModel: function() {
            this.model.update(this._getDialog().$popup);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/views/LoadingError.js' */
define("jira/components/issueeditor/views/loadingerror", ["require"], function(require){
    "use strict";

    var MarionetteItemView = require('jira/components/libs/marionette-1.4.1/itemview');
    var Messages = require('jira/message');
    var Templates = require("jira/components/issueeditor/templates");

    return MarionetteItemView.extend({
        template: Templates.errorsLoading,

        initialize: function(errorMessages, isTimeout) {
            this.errorMessages = errorMessages;
            this.isTimeout = isTimeout;
        },

        serializeData: function() {
            return {
                errorMessages: this.errorMessages,
                isTimeout: this.isTimeout
            };
        },

        onRender: function() {
            this.setElement(Messages.showErrorMsg(this.$el.html(), {
                closeable: true,
                timeout: 0
            }));
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/views/SaveError.js' */
define("jira/components/issueeditor/views/saveerror", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var MarionetteItemView = require('jira/components/libs/marionette-1.4.1/itemview');
    var Messages = require('jira/message');
    var Templates = require("jira/components/issueeditor/templates");

    /**
     * A global "saving failed" message.
     */
    return MarionetteItemView.extend({
        events: {
            "simpleClick .issue": "onIssueLinkClick"
        },

        template: Templates.saveErrorMessage,

        /**
         * Extract error messages from the `IssueSaverService` response.
         *
         * @private
         * @returns {string[]} The error messages in `this.options.response`.
         */
        getErrorMessages: function() {
            var errorCollection;
            var errors = [];

            errorCollection = this.options.response.errorCollection;
            if (errorCollection) {
                errors = errorCollection.errorMessages.concat(_.values(errorCollection.errors));
            }

            return errors;
        },

        /**
         * Close the view and trigger an "issueLinkClick" event.
         *
         * @param {jQuery.Event} e A jQuery click event.
         * @private
         */
        onIssueLinkClick: function(e) {
            var options;

            options = {
                id: this.options.issueId,
                key: this.options.issueKey
            };

            e.preventDefault();
            this.trigger("issueLinkClick", options);
            this.close();
        },

        onRender: function() {
            this.setElement(Messages.showErrorMsg(this.$el.html(), {
                closeable: true,
                timeout: 0
            }));
        },

        serializeData: function() {
            return {
                errors: this.getErrorMessages(),
                issueKey: this.options.issueKey
            };
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/controllers/EditIssueController.js' */
define("jira/components/issueeditor/controllers/editissue", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var FieldsCollection = require("jira/components/issueeditor/entities/fields");
    var FieldView = require("jira/components/issueeditor/views/field");
    var IssueFieldUtil = require("jira/components/issueviewer/legacy/issuefieldutil");
    var jQuery = require("jquery");
    var Messages = require("jira/message");
    var Templates = require("jira/components/issueeditor/templates");

    /**
     * Controls edits for the currently viewed issue.
     * Note: the actual saving of edits  is done by the JIRA.Components.IssueEditor.Services.SaveInProgressManager
     */
    return Brace.Model.extend({

        namedAttributes: [
        /**
         * @type number
         */
            "issueId",

        /**
         * Issue Key
         * @type string
         */
            "issueKey",

        /**
         * jQuery element that contains the view issue html
         * @type jQuery
         */
            "issueViewContext",

        /**
         * Collection of JIRA.Components.IssueEditor.Models.Field
         * @type JIRA.Components.IssueEditor.Collections.Fields
         */
            "fields",

        /**
         * @type JIRA.Components.IssueViewer.Legacy.IssueEventBus
         */
            "issueEventBus"
        ],

        namedEvents: [
        /**
         * @event save
         * Fired when the fields are ready to be saved. The actual save action is performed by other objects
         * listening to this event (SaveInProgressManager).
         *
         * @param {number} issueId The ID of the issue being saved
         * @param {string} issueKey The Key of the issue being saved
         * @param {string[]} toSaveIds List of fields ids being saved
         * @param {object} params
         * @param {object} ajaxProperties
         */
            "save",

        /**
         * @event editField
         * Fired when the user is editing a field
         * @param {object} options
         * @param {string} options.fieldId Id of the field being saved
         */
            "editField",

        /**
         * @event editFieldCancel
         * Fired when the user is canceling field edit
         * @param {object} options
         * @param {string} options.fieldId Id of the field being edited
         */
            "editFieldCancel"
        ],

        /**
         * @constructor
         */
        initialize: function() {

            _.bindAll(this,
                "_handleSaveError",
                "_handleSaveSuccess",
                "_handleSavingStarted",
                "cancelUneditedFields",
                "createFieldView",
                "handleFieldUpdate",
                "save");

            this.set({
                fields: new FieldsCollection()
            }, {silent: true});

            this.getFields()
                .bind("add", this.createFieldView)
                .bind("updated", this.handleFieldUpdate)
                .bind("save", this.save);

            this.getIssueEventBus().onSavingStarted(this._handleSavingStarted);
            this.getIssueEventBus().onSaveSuccess(this._handleSaveSuccess);
            this.getIssueEventBus().onSaveError(this._handleSaveError);
            this.getIssueEventBus().onSave(this.save);
            this.getIssueEventBus().onSave(this.cancelUneditedFields);
        },

        _saveById: function(id) {
            var model = this.getFields().get(id);
            if (model) {
                model.blurEdit();
            }
        },

        /**
         * Handles case where the JIRA.Components.IssueEditor.Services.SaveInProgressManager returns server/validation errors for issue.
         *
         * @param {Number} issueId
         * @param {Array} attemptedSavedIds
         * @param {Object} response
         * ... {Array} errorMessages
         * ... {Object} errors - Validation errors
         */
        _handleSaveError: function(issueId, attemptedSavedIds, response) {
            var instance = this;
            if (response) {
                this.applyErrors(response);
            } else {
                _.each(attemptedSavedIds, function(id) {
                    var model = instance.getFields().get(id);
                    if (model) {
                        model.handleSaveError();
                    }
                });
            }
        },

        /**
         * Lets all the models know that saving has started
         *
         * @param savingIds
         * @private
         */
        _handleSavingStarted: function(savingIds) {
            this.getFields().each(function(model) {
                if (_.include(savingIds, model.id)) {
                    model.handleSaveStarted();
                }
            });
        },

        /*
         * Handles the situation where a field becomes visible but doesn't have a
         * view associated with it, meaning it's not possible to inline-edit it.
         *
         * @param {Object} fieldModel The field model that was updated.
         */
        handleFieldUpdate: function(fieldModel) {
            // If a view has been created for the field, its trigger element (or
            // one of its descendants) will have the "editable-field" class.
            var trigger = jQuery(IssueFieldUtil.getFieldSelector(fieldModel.id));
            if (!trigger.hasClass("editable-field")) {
                this.createFieldView(fieldModel);
            }
        },

        /**
         * Applies an error collection to the current issue page. Useful when restoring an issues state after navigating away.
         *
         * @param errorCollection
         */
        applyErrors: function(lastEditData, focusFirst) {
            var errorCollection = lastEditData.errorCollection;
            if (errorCollection && errorCollection.errors) {
                this.getFields().each(function(model) {
                    if (errorCollection.errors[model.id]) {
                        var updatedField = _.find(lastEditData.fields, function(field) {
                            return field.id === model.id;
                        });
                        if (updatedField) {
                            model.setValidationError(updatedField.editHtml, errorCollection.errors[model.id], focusFirst);
                            focusFirst = false;
                        }
                    }
                });
            }

            // In the case of error messages we pin up a global error message
            if (errorCollection.errorMessages && errorCollection.errorMessages.length) {
                var html = Templates.saveErrorMessage({
                    errors: errorCollection.errorMessages,
                    issueKey: this.getIssueKey()
                });
                Messages.showErrorMsg(html, {
                    closeable: true
                });
            }
        },

        /**
         * Removes all field models and edital views
         */
        reset: function() {
            this.getFields().reset();
        },

        /**
         * Cancels any edit is progress
         */
        cancelEdit: function() {
            this.getFields().each(function(model) {
                model.cancelEdit();
            });
        },

        /**
         * Handles case where the JIRA.Components.IssueEditor.Services.SaveInProgressManager saves successfully for issue
         *
         * @param {Number} issueId
         * @param {Array} savedFieldIds - Ids for successfully saved fields
         */
        _handleSaveSuccess: function(issueId, issueKey, savedFieldIds) {
            var savedFieldModels = this.getFields().filter(function(fieldModel) {
                return _.indexOf(savedFieldIds, fieldModel.id) >= 0;
            });
            _.each(savedFieldModels, function(model) {
                model.handleSaveSuccess();
            });
        },

        /**
         * Gets the ids of fields in edit mode that need to be saved
         *
         * @return Array<String>
         */
        getDirtyEditsInProgress: function() {
            return _.pluck(this.getFields().filter(function(model) {
                return model.getEditing() && model.isDirty();
            }), "id");
        },

        /**
         * Gets the ids of fields in edit mode
         *
         * @return Array<String>
         */
        getEditsInProgress: function() {
            return _.pluck(this.getFields().filter(function(model) {
                return model.getEditing();
            }), "id");
        },

        /**
         * Saves all the fields that are currently in edit mode with dirty (changed) values.
         * Note: The actual save is delegated to the JIRA.Components.IssueEditor.Services.SaveInProgressManager
         *
         * @param model
         * @param ajaxProperties
         */
        save: function(model, ajaxProperties) {

            var params = {};
            var toSaveIds = [];
            var toSaveFieldTypes = [];

            var toSave = [model];
            if (!model) {
                toSave = this.getFields().filter(function(model) {
                    return !model.getSaving() && model.getEditing() && model.isDirty();
                });
            } else if (!model.getEditing() || model.getSaving()) {
                return;
            }

            _.each(toSave, function(model) {
                toSaveIds.push(model.getId());
                toSaveFieldTypes.push(model.getFieldType() || '');
                _.extend(params, model.getCurrentParams());
            });

            if (toSaveIds.length > 0) {
                this.triggerSave(this.getIssueId(), this.getIssueKey(), toSaveIds, params, ajaxProperties, toSaveFieldTypes);
            }
        },

        /**
         * Cancels any fields which are not dirty (have not been edited) and have no validation errors.
         */
        cancelUneditedFields: function() {
            this.getFields().each(function(model) {
                if (model.getEditing() && !model.isDirty() && !model.hasValidationError()) {
                    model.cancelEdit();
                }
            });
        },

        /**
         * Updates the data of this controller
         *
         * @param {Object}   data
         * @param {number}   [data.issueId]
         * @param {string}   [data.issueKey]
         * @param {Object[]} [data.fields]
         */
        update: function(data, props) {
            if (data.fields) {
                if (props && props.fieldsInProgress) {
                    _.each(data.fields, function(fieldData) {
                        if (_.contains(props.fieldsInProgress, fieldData.id)) {
                            fieldData.editing = true;
                        }
                    });
                }
                this.getFields().update(data.fields, props);
            }

            if (data.issueId) {
                this.setIssueId(data.issueId);
            }

            if (data.issueKey) {
                this.setIssueKey(data.issueKey);
            }
        },

        /**
         * Creates fields view
         *
         * @param {JIRA.Components.IssueEditor.Models.Field} fieldModel
         */
        createFieldView: function(fieldModel) {
            var editableFieldTrigger = jQuery(IssueFieldUtil.getFieldSelector(fieldModel.id), this.getIssueViewContext());
            if (editableFieldTrigger.length === 1) {
                var field = new FieldView({
                    model: fieldModel,
                    el: editableFieldTrigger,
                    issueEventBus: this.getIssueEventBus()
                });

                var getParams = function(parameters) {
                    var params = {
                        issueId: this.getIssueId(),
                        issueKey: this.getIssueKey(),
                        fieldId: fieldModel.getId(),
                        fieldType: fieldModel.attributes.fieldType
                    };
                    parameters = _.extend(params, parameters);
                    return parameters;
                }.bind(this);

                field.on("editField", _.bind(function(parameters) {
                    this.trigger("editField", getParams(parameters));
                }, this));

                field.on("editFieldCancel", _.bind(function(parameters) {
                    this.trigger("editFieldCancel", getParams(parameters));
                }, this));
            }
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/controllers/FieldsController.js' */
define("jira/components/issueeditor/controllers/fields", ["require"], function(require){
    "use strict";

    var LoadingErrorView = require("jira/components/issueeditor/views/loadingerror");
    var MarionetteController = require('jira/components/libs/marionette-1.4.1/controller');

    /**
     * @class JIRA.Components.IssueEditor.Controllers.Fields
     * @extends Marionette.Controller
     *
     * Controller for the fields of an issue. This class does not render the fields but the errors when loading/saving
     * fields
     */

    return MarionetteController.extend({
        showError: function(errorCollection, isTimeout) {
            if (errorCollection || isTimeout) {
                // Close previous view, if any
                this.close();

                // Let others know we are rendering, Marionette style
                this.triggerMethod("before:render");

                this.view = new LoadingErrorView(errorCollection, isTimeout);
                this.view.render();

                // Listen for view events
                this.listenTo(this.view, "close", this.close);

                // Let others know we have rendered our view, Marionette style
                this.triggerMethod("render");
            }
        },

        /**
         * Closes and deletes the view
         */
        close: function() {
            if (this.view) {
                this.view.close();
                this.stopListening(this.view);
                delete this.view;
            }
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/services/FieldsLoaderService.js' */
define("jira/components/issueeditor/services/fieldsloader", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var IssueFieldUtil = require("jira/components/issueviewer/legacy/issuefieldutil");
    var jQuery = require("jquery");
    var MarionetteController = require('jira/components/libs/marionette-1.4.1/controller');

    /**
     * @class JIRA.Components.IssueEditor.Services.FieldsLoader
     * @extends Marionette.Controller
     *
     * Service responsible for loading the fields of an issue
     */
    return MarionetteController.extend({
        /**
         * Initialise this service
         *
         * @constructor
         * @param {object} options Options
         * @param {string} options.contextPath ContextPath used in this JIRA installation (e.g. "/jira")
         */
        initialize: function(options) {
            this.recurringPromise = new jQuery.RecurringPromise().sub();
            this.recurringPromise
                .done(_.bind(function(args) {
                    this.trigger("fieldsLoaded", args);
                }, this))
                .fail(_.bind(function(args) {
                    this.trigger("fieldsError", args);
                }, this));

            this.contextPath = options.contextPath;
        },

        /**
         * Load the fields for an issue
         *
         * @param options
         */
        load: function(options) {
            var task = this._buildUpdateTask(options);
            this.recurringPromise.add(task);
        },

        /**
         * Cancel the any ongoing requests
         */
        cancel: function() {
            this.recurringPromise.reset();
        },

        /**
         * Gets the edit fields data from server, including edit html, if it is required etc.
         *
         * @param {number} issueId ID of the issue to load
         * @param {string} issueKey Key of the issue to load
         */
        _getFieldsData: function(issueId, issueKey) {
            var jqXhr = jQuery.ajax({
                url: this.contextPath + "/secure/AjaxIssueEditAction!default.jspa?decorator=none",
                headers: {'X-SITEMESH-OFF': true},
                data: {issueId: issueId}
            });

            var deferred = jqXhr.pipe(
                function(data) {
                    var resp = IssueFieldUtil.transformFieldHtml(data);
                    return {
                        issueId: issueId,
                        issueKey: issueKey,
                        fields: resp.fields
                    };
                },
                function(xhr) {
                    var errorCollection = {};
                    var fatalError;

                    switch (xhr.status) {
                        case 400:
                            fatalError = false;
                            try {
                                var response = JSON.parse(xhr.responseText) || {};
                                errorCollection = response.errorCollection;
                            } catch (e) {}
                            break;

                        case 401:
                            fatalError = false;
                            errorCollection = null;
                            break;

                        default:
                            fatalError = true;
                            errorCollection = {};
                            break;
                    }

                    return {
                        issueId: issueId,
                        fields: null,
                        errorCollection: errorCollection,
                        isTimeout: "timeout" === xhr.statusText,
                        fatalError: fatalError
                    };
                }
            );

            deferred.abort = function() {
                jqXhr.abort.apply(jqXhr, arguments);
            };

            return deferred;
        },

        /**
         * Builds the update task
         * @param options
         * @returns {jQuery.Promise}
         * @private
         */
        _buildUpdateTask: function(options) {
            var viewIssueData = options.viewIssueData;
            var issueEntity = options.issueEntity;

            var deferred = new jQuery.Deferred();

            viewIssueData.setPending(
                issueEntity.id,
                this._getFieldsData(issueEntity.id, issueEntity.key),
                function(result) {
                    deferred.resolve(result);
                },
                function(result) {
                    if (result.fatalError) {
                        deferred.reject(result);
                    } else {
                        deferred.resolve(result);
                    }
                }
            );

            return deferred.promise();

        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/services/IssueSaverService.js' */
define("jira/components/issueeditor/services/issuesaver", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var IssueFieldUtil = require("jira/components/issueviewer/legacy/issuefieldutil");
    var MarionetteController = require('jira/components/libs/marionette-1.4.1/controller');

    /**
     * @class JIRA.Components.IssueEditor.Services.IssueSaver
     * @extends Marionette.Controller
     *
     * Service responsible for saving an issue
     *
     * This is just a wrapper for saveInProgressManager, we should refactor it and join these two services
     */
    return MarionetteController.extend({
        /**
         * Initialize the service
         *
         * @constructor
         * @param {object} options
         * @param {JIRA.Components.IssueEditor.Services.SaveInProgressManager} object.saveInProgressManager
         * @param {JIRA.Modules.IssueViewer.Models.Issue} object.model
         */
        initialize: function(options) {
            this.saveInProgressManager = options.saveInProgressManager;
            this.model = options.model;

            // TODO: flaky. Assumes that requests will always come back in the order in which they were started.
            // This is ok as are refactoring save & reload to be in the same request, which will make this much easier.
            this._saveStarted = [];

            this.saveInProgressManager.onSavingStarted(_.bind(function(issueId, savedFieldIds) {
                this._saveStarted.push((new Date()).getTime());
                this.trigger("saveStarted", issueId, savedFieldIds);
            }, this));

            this.saveInProgressManager.onSaveSuccess(_.bind(function(issueId, issueKey, savedFieldIds, response, savedFieldTypes) {
                if (response && response.fields) {
                    IssueFieldUtil.transformFieldHtml(response);
                }
                this.trigger("save", {
                    issueId: issueId,
                    issueKey: issueKey,
                    savedFieldIds: savedFieldIds,
                    savedFieldTypes: savedFieldTypes,
                    response: response,
                    shouldSkipSaveIssueSuccessHandler: this._shouldSkipSaveIssueSuccessHandler,
                    duration: (new Date()).getTime() - this._saveStarted.shift()
                });
            }, this));

            this.saveInProgressManager.onSaveError(_.bind(function(issueId, issueKey, attemptedSavedIds, response) {
                if (response && response.fields) {
                    IssueFieldUtil.transformFieldHtml(response);
                }

                this.trigger("error", {
                    issueId: issueId,
                    issueKey: issueKey,
                    attemptedSavedIds: attemptedSavedIds,
                    response: response,
                    duration: (new Date()).getTime() - this._saveStarted.shift()
                });
            }, this));
        },

        /**
         * Skip the next SaveIssueSuccess request
         * @param skipHandler {Boolean} True to skip the handler
         */
        setSkipSaveIssueSuccessHandler: function(skipHandler) {
            this._shouldSkipSaveIssueSuccessHandler = skipHandler;
        },

        /**
         * Saves an issue
         * @param issueId
         * @param issueKey
         * @param toSaveIds
         * @param params
         * @param ajaxProperties
         */
        save: function(issueId, issueKey, toSaveIds, params, ajaxProperties, toSaveFieldTypes) {
            this.saveInProgressManager.saveIssue(issueId, issueKey, toSaveIds, params, ajaxProperties, toSaveFieldTypes);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/services/SaveInProgressManager.js' */
/* global atl_token */
define("jira/components/issueeditor/services/saveinprogressmanager", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var contextPath = window.AJS.contextPath();
    var Events = require('jira/util/events');
    var IssueFieldUtil = require("jira/components/issueviewer/legacy/issuefieldutil");
    var JIRAFormDialog = require('jira/dialog/form-dialog');
    var jQuery = require("jquery");
    var Messages = require('jira/message');
    var SmartAjax = require('jira/ajs/ajax/smart-ajax');
    var EventTypes = require("jira/components/issueeditor/eventtypes");

    return Brace.Model.extend({

        namedAttributes: [
            "savesInProgress"
        ],

        namedEvents: ["beforeSaving", "savingStarted", "saveSuccess", "saveError"],

        initialize: function() {
            this.setSavesInProgress([]);

        },

        saveIssue: function(issueId, issueKey, fieldsToSave, data, ajaxProperties, typeOfFieldsToSave) {
            this.triggerBeforeSaving();

            var instance = this;
            var saveInProgress;
            var allParams;

            allParams = _.extend(data, {
                issueId: issueId,
                /*eslint-disable camelcase*/
                atl_token: atl_token(),
                /*eslint-enable camelcase*/
                singleFieldEdit: true,
                fieldsToForcePresent: fieldsToSave
            });

            var ajaxOpts = _.extend({
                type: "POST",
                url: contextPath + "/secure/AjaxIssueAction.jspa?decorator=none",
                headers: {'X-SITEMESH-OFF': true},
                error: function(xhr) {
                    instance._handleSaveError(issueId, issueKey, fieldsToSave, xhr);
                },
                success: function(resp, statusText, xhr, smartAjaxResult) {
                    var responseData = smartAjaxResult.data;
                    // Was the response HTML?
                    if (typeof responseData === "string") {
                        instance._handleHtmlResponse(issueId, issueKey, fieldsToSave, responseData, typeOfFieldsToSave);
                    } else {
                        IssueFieldUtil.transformFieldHtml(responseData);
                        instance.triggerSaveSuccess(issueId, issueKey, fieldsToSave, responseData, typeOfFieldsToSave);
                    }
                },
                complete: function() {
                    instance.removeSaveInProgress(saveInProgress);
                    Events.trigger(EventTypes.INLINE_EDIT_SAVE_COMPLETE);
                },
                data: allParams
            }, ajaxProperties);

            saveInProgress = SmartAjax.makeRequest(ajaxOpts);
            this.addSaveInProgress(saveInProgress);
            this.triggerSavingStarted(issueId, fieldsToSave, data);

        },

        hasSavesInProgress: function() {
            return this.getSavesInProgress().length > 0;
        },

        removeSaveInProgress: function(saveInProgress) {
            this.setSavesInProgress(_.without(this.getSavesInProgress(), saveInProgress));
        },

        addSaveInProgress: function(saveInProgress) {
            var savesInProgress = this.getSavesInProgress();
            savesInProgress.push(saveInProgress);
            this.setSavesInProgress(savesInProgress);
        },

        _handleHtmlResponse: function(issueId, issueKey, fieldsToSave, responseData, typeOfFieldsToSave) {
            var instance = this;
            var responseBody = jQuery(AJS.extractBodyFromResponse(responseData));
            var updatedXSRFToken = responseBody.find("#atl_token").val();

            // If we've received an XSRF token error, an updated token will be in the response.
            if (updatedXSRFToken) {
                jQuery("#atlassian-token").attr("content", updatedXSRFToken);
            }

            var dialog = new JIRAFormDialog({
                offsetTarget: "body",
                content: responseBody
            });

            this.triggerSaveError(issueId, issueKey, fieldsToSave);

            // If clicking the XSRF dialog's "Retry" button worked, continue.
            dialog._handleServerSuccess = function(xsrfResponseData) {
                dialog.hide();
                var data = instance._parseResponse(xsrfResponseData);
                if (data) {
                    IssueFieldUtil.transformFieldHtml(data);
                    instance.triggerSaveSuccess(issueId, issueKey, fieldsToSave, data, typeOfFieldsToSave);
                }
            };

            // If clicking the XSRF dialog's "Retry" button didn't work, trigger a save error
            dialog._handleServerError = function(xhr) {
                dialog.hide();
                var data = instance._parseResponse(xhr.responseText);
                if (data) {
                    IssueFieldUtil.transformFieldHtml(data);
                    instance.triggerSaveError(issueId, issueKey, fieldsToSave, data);
                }
            };

            dialog.show();
        },

        _handleSaveError: function(issueId, issueKey, fieldsToSave, xhr) {
            var data = this._parseResponse(xhr.responseText);
            if (data) {
                IssueFieldUtil.transformFieldHtml(data);
                this.triggerSaveError(issueId, issueKey, fieldsToSave, data);
            }
        },

        /**
         * Attempts to parse raw response to JSON. If parsing fails, shows a global error message and returns null
         * @param responseText raw http response data
         */
        _parseResponse: function(responseText) {
            try {
                return JSON.parse(responseText);
            } catch (e) {
                // parse JSON failed
                this._showFatalErrorMessage();
                return null;
            }
        },

        _showFatalErrorMessage: function() {
            // TODO: would be nice to extract this error from smartAjax and make it uniform in JIRA
            var msg = '<p>' + "Communications Breakdown" + '</p>' +
                '<p>' + "Close this dialog and press refresh in your browser" + '</p>';
            Messages.showErrorMsg(msg, {
                closeable: true
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/services/UnloadInterceptor.js' */
define("jira/components/issueeditor/services/unloadinterceptor", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var MarionetteController = require('jira/components/libs/marionette-1.4.1/controller');

    // Why not just use jQuery I hear you say?? Well it doesn't work for IE!
    // JRADEV-11612
    return MarionetteController.extend({
        initialize: function() {
            this._afterEventHandlers = [];
            this.originalBeforeUnload = window.onbeforeunload;
            window.onbeforeunload = _.bind(this.onBeforeUnload, this);
        },

        addAfterEvent: function(handler) {
            this._afterEventHandlers.push(handler);
        },

        removeAfterEvent: function(handler) {
            this._afterEventHandlers = _.without(this._afterEventHandlers, handler);
        },

        onBeforeUnload: function() {
            var result;
            var args = arguments;

            // Run the original handler (if present)
            if (_.isFunction(this.originalBeforeUnload)) {
                result = this.originalBeforeUnload.apply(window, args);
            }

            // If the original handler returned a truty value, don't process the afterEventHandlers
            if (!result) {
                result = _.reduce(this._afterEventHandlers, function(memo, value) {
                    // If the previous handler returned anything, skip the rest of handlers
                    if (memo) return memo;
                    return value.apply(window, args);
                }, result);
            }

            return result;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/InlineEditUtils.js' */
define("jira/components/issueeditor/inlineeditutils", ["require"], function(require){
    "use strict";

    var Events = require('jira/util/events');
    var EventTypes = require("jira/components/issueeditor/eventtypes");

    /**
     * The time required to wait between blur and focus
     */
    var InlineEditUtils = {};

    InlineEditUtils.BLUR_FOCUS_TIMEOUT = 50;

    InlineEditUtils.BlurTriggers = {
        Default: function(fieldId, $container) {

            // Include save buttons
            $container = $container.nextAll(".save-options").andSelf();

            var focusables = ':input, a[href], [tabindex]';
            var timeout;
            var containerHasFocus = hasFocus($container);
            var eventsMap = {
                focus: function() {
                    if (!containerHasFocus) {
                        containerHasFocus = true;
                        Events.trigger(EventTypes.INLINE_EDIT_FOCUSED, [fieldId]);
                    }
                },
                blur: function() {
                    if (timeout) clearTimeout(timeout);
                    timeout = setTimeout(triggerIfBlurred, InlineEditUtils.BLUR_FOCUS_TIMEOUT);
                }
            };

            // Make container focusable
            $container.attr('tabindex', 1)
                // Bind to container
                .bind(eventsMap)
                // Bind to focusable elements in container
                .delegate(focusables, eventsMap);

            function triggerIfBlurred() {
                if (!hasFocus($container)) {
                    containerHasFocus = false;
                    Events.trigger(EventTypes.INLINE_EDIT_BLURRED, [fieldId]);
                }
            }
        }
    };

    function hasFocus($container) {
        var activeElement = document.activeElement;
        return $container.find(activeElement).length > 0 || $container.filter(activeElement).length > 0;
    }

    InlineEditUtils.BlurTriggerMapping = {
        system: {
            "summary": InlineEditUtils.BlurTriggers.Default,
            "priority": InlineEditUtils.BlurTriggers.Default,
            "issuetype": InlineEditUtils.BlurTriggers.Default,
            "components": InlineEditUtils.BlurTriggers.Default,
            "versions": InlineEditUtils.BlurTriggers.Default,
            "fixVersions": InlineEditUtils.BlurTriggers.Default,
            "assignee": InlineEditUtils.BlurTriggers.Default,
            "reporter": InlineEditUtils.BlurTriggers.Default,
            "environment": InlineEditUtils.BlurTriggers.Default,
            "description": InlineEditUtils.BlurTriggers.Default,
            "labels": InlineEditUtils.BlurTriggers.Default,
            "duedate": InlineEditUtils.BlurTriggers.Default
        },
        custom: {
            "com.atlassian.jira.plugin.system.customfieldtypes:cascadingselect": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:datepicker": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:datetime": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:float": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:grouppicker": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:labels": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:multigrouppicker": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:multiselect": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:multiversion": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:project": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:select": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:textarea": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:textfield": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:url": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:userpicker": InlineEditUtils.BlurTriggers.Default,
            "com.atlassian.jira.plugin.system.customfieldtypes:version": InlineEditUtils.BlurTriggers.Default
        }
    };

    Events.bind(EventTypes.INLINE_EDIT_STARTED, function(e, fieldId, fieldType, $container) {
        var blurTrigger;
        if (fieldType) {
            blurTrigger = InlineEditUtils.BlurTriggerMapping.custom[fieldType];
            if (!blurTrigger) {
                // in 5.1, we told devs to put the "short" key into the custom mapping, not the complete key
                // if we can't find the complete key, try the short key
                var shortKey = fieldType.replace(/.+:(.+)/, "$1"); // extract after the colon
                blurTrigger = InlineEditUtils.BlurTriggerMapping.custom[shortKey];
            }
        } else {
            blurTrigger = InlineEditUtils.BlurTriggerMapping.system[fieldId];
        }

        if (blurTrigger) {
            blurTrigger(fieldId, $container);
        }
    });

    return InlineEditUtils;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/eventtypes.js' */
define("jira/components/issueeditor/eventtypes", ["require"], function(require){
    "use strict";

    var Types = require('jira/components/issueviewer/eventtypes');
    Types.INLINE_EDIT_SAVE_COMPLETE = "inlineEditSaveComplete";
    Types.INLINE_EDIT_STARTED = "inlineEditStarted";
    Types.BEFORE_INLINE_EDIT_CANCEL = "inlineEditCancelled";
    Types.INLINE_EDIT_BLURRED = "inlineEditBlurred";
    Types.INLINE_EDIT_FOCUSED = "inlineEditFocused";
    Types.INLINE_EDIT_REQUESTED = "inlineEditRequested";
    Types.LOCK_PANEL_REFRESHING = "lockPanelRefreshing";
    Types.UNLOCK_PANEL_REFRESHING = "unlockPanelRefreshing";
    Types.REFRESH_ISSUE_PAGE = "refreshIssuePage";
    return Types;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/cancelreasons.js' */
define("jira/components/issueeditor/cancelreasons", function(){
    "use strict";

    // Reasons for cancelling edit
    return {
        escPressed: "escPressed"
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:issueeditor', location = 'issueeditor/js/namespace.js' */
AJS.namespace("JIRA.Components.IssueEditor", null, require("jira/components/issueeditor"));
AJS.namespace("JIRA.Components.IssueEditor.AppModule", null, require("jira/components/issueeditor/appmodule"));
AJS.namespace("JIRA.Components.IssueEditor.NoInlineAppModule", null, require("jira/components/issueeditor/noinlineappmodule"));

AJS.namespace("JIRA.Components.IssueEditor.Controllers.EditIssue", null, require("jira/components/issueeditor/controllers/editissue"));
AJS.namespace("JIRA.Components.IssueEditor.Controllers.Fields", null, require("jira/components/issueeditor/controllers/fields"));

AJS.namespace("JIRA.Components.IssueEditor.Collections.Fields", null, require("jira/components/issueeditor/entities/fields"));
AJS.namespace("JIRA.Components.IssueEditor.Models.Field", null, require("jira/components/issueeditor/entities/field"));

AJS.namespace("JIRA.Components.IssueEditor.Services.FieldsLoader", null, require("jira/components/issueeditor/services/fieldsloader"));
AJS.namespace("JIRA.Components.IssueEditor.Services.IssueSaver", null, require("jira/components/issueeditor/services/issuesaver"));
AJS.namespace("JIRA.Components.IssueEditor.Services.SaveInProgressManager", null, require("jira/components/issueeditor/services/saveinprogressmanager"));
AJS.namespace("JIRA.Components.IssueEditor.Services.UnloadInterceptor", null, require("jira/components/issueeditor/services/unloadinterceptor"));

AJS.namespace("JIRA.Components.IssueEditor.Views.FieldView", null, require("jira/components/issueeditor/views/field"));
AJS.namespace("JIRA.Components.IssueEditor.Views.LoadingError", null, require("jira/components/issueeditor/views/loadingerror"));
AJS.namespace("JIRA.Components.IssueEditor.Views.ModalFieldView", null, require("jira/components/issueeditor/views/modalfield"));
AJS.namespace("JIRA.Components.IssueEditor.Views.SaveError", null, require("jira/components/issueeditor/views/saveerror"));

AJS.namespace("JIRA.Components.IssueEditor.InlineEditUtils", null, require("jira/components/issueeditor/inlineeditutils"));
AJS.namespace("JIRA.Issues.InlineEdit.BlurTriggers", null, require("jira/components/issueeditor/inlineeditutils").BlurTriggers);
AJS.namespace("JIRA.Issues.InlineEdit.BlurTriggerMapping", null, require("jira/components/issueeditor/inlineeditutils").BlurTriggerMapping);
AJS.namespace("JIRA.Issues.CANCEL_REASON", null, require("jira/components/issueeditor/cancelreasons"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:pager', location = 'content/js/modules/pager/PagerTemplate.soy' */
// This file was automatically generated from PagerTemplate.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ViewIssue.Header.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ViewIssue == 'undefined') { JIRA.Templates.ViewIssue = {}; }
if (typeof JIRA.Templates.ViewIssue.Header == 'undefined') { JIRA.Templates.ViewIssue.Header = {}; }


JIRA.Templates.ViewIssue.Header.pager = function(opt_data, opt_ignored) {
  return '<ul class="ajax ops page-navigation"><li class="previous">' + ((opt_data.previousIssue && opt_data.position != 1) ? '<a data-id="' + soy.$$escapeHtml(opt_data.previousIssue.id) + '" data-key="' + soy.$$escapeHtml(opt_data.previousIssue.key) + '" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.previousIssue.key) + '" id="previous-issue" rel="' + soy.$$escapeHtml(opt_data.previousIssue.key) + '" title="' + soy.$$escapeHtml("Previous Issue") + ' \'' + soy.$$escapeHtml(opt_data.previousIssue.key) + '\'"><span class="icon icon-page-prev"><span>' + soy.$$escapeHtml("Previous Issue") + ' \'' + soy.$$escapeHtml(opt_data.previousIssue.key) + '\'</span></span></a>' : (opt_data.position && opt_data.resultCount) ? '<span class="icon icon-page-prev-deactivated" title="' + soy.$$escapeHtml("Not available - this is the first issue") + '"></span>' : '') + '</li><li class="showing">' + ((opt_data.position && opt_data.resultCount) ? soy.$$escapeHtml(AJS.format("{0} of {1}",opt_data.position,opt_data.resultCount)) : '') + '</li><li class="next">' + ((opt_data.nextIssue && opt_data.position != opt_data.resultCount) ? '<a data-id="' + soy.$$escapeHtml(opt_data.nextIssue.id) + '" data-key="' + soy.$$escapeHtml(opt_data.nextIssue.key) + '" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.nextIssue.key) + '" id="next-issue" rel="' + soy.$$escapeHtml(opt_data.nextIssue.key) + '" title="' + soy.$$escapeHtml("Next Issue") + ' \'' + soy.$$escapeHtml(opt_data.nextIssue.key) + '\'"><span class="icon icon-page-next"><span>' + soy.$$escapeHtml("Next Issue") + ' \'' + soy.$$escapeHtml(opt_data.nextIssue.key) + '\'</span></span></a>' : (opt_data.position && opt_data.resultCount) ? '<span class="icon icon-page-next-deactivated" title="' + soy.$$escapeHtml("Not available - this is the last issue") + '"></span>' : '') + '</li>' + ((opt_data.isError || opt_data.hasSearchLink) ? '<li class="return"><a id="return-to-search" href="' + soy.$$escapeHtml("/jira") + '/issues/" title="' + soy.$$escapeHtml("Return to search") + '">' + soy.$$escapeHtml("Return to search") + '</a></li>' : '') + '</ul>';
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.Header.pager.soyTemplateName = 'JIRA.Templates.ViewIssue.Header.pager';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:pager', location = 'content/js/modules/pager/Pager.js' */
define("jira/issues/modules/pager", ["require"], function(require) {
    "use strict";

    var PagerModel = require("jira/issues/modules/pager/model");
    var PagerController = require("jira/issues/modules/pager/controller");

    return function(callbacks) {
        var pagerModel;
        var pagerController;

        this.initialize = function() {
            pagerModel = new PagerModel();
        };

        this.update = function(data) {
            if (data) {
                pagerModel.update(data);
            } else if (pagerModel.get('isError') !== true) {
                pagerModel.clear();
            }
        };

        this.show = function(container, element) {
            if (!pagerController) {
                pagerController = new PagerController({
                    model: pagerModel
                });
                pagerController.on("goBack", callbacks.goBack);
                pagerController.on("nextItem", callbacks.nextItem);
                pagerController.on("previousItem", callbacks.previousItem);
            }
            pagerController.show(container, element);
        };

        this.close = function() {
            if (pagerController) {
                pagerController.close();
            }
            pagerController = null;
            pagerModel.clear();
        };
    };

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:pager', location = 'content/js/modules/pager/PagerModel.js' */
define("jira/issues/modules/pager/model", ["require"], function(require) {
    "use strict";

    var BaseModel = require("jira/issues/basemodel");

    return BaseModel.extend({
        properties: [
            "nextIssue",
            "previousIssue",
            "position",
            "resultCount",
            "hasSearchLink",
            "isError"
        ],

        update: function(properties) {
            // TODO Refactor this, as isSplitView is not a concern for this module
            properties.hasSearchLink = !properties.isSplitView;
            delete properties.isSplitView;
            this.set(properties);
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:pager', location = 'content/js/modules/pager/PagerView.js' */
define("jira/issues/modules/pager/view", ["require"], function(require) {
    "use strict";

    var jQuery = require("jquery");
    var MarionetteItemView = require("jira/components/libs/marionette-1.4.1/itemview");
    var PagerTemplates = require("jira/issues/modules/pager/templates");

    return MarionetteItemView.extend({
        template: function(data) {
            return PagerTemplates.pager(data || {});
        },

        events: {
            "simpleClick #return-to-search": "_onReturnToSearchClick"
        },

        triggers: {
            "simpleClick #next-issue": "nextItem",
            "simpleClick #previous-issue": "previousItem"
        },

        ui: {
            nextIssue: "#next-issue",
            previousIssue: "#previous-issue",
            returnToSearch: "#return-to-search"
        },

        modelEvents: {
            "change": "render"
        },

        onRender: function() {
            if (AJS.activeShortcuts) {
                if (AJS.activeShortcuts.j) { AJS.activeShortcuts.j._addShortcutTitle(this.$el.find(this.ui.nextIssue));}
                if (AJS.activeShortcuts.k) { AJS.activeShortcuts.k._addShortcutTitle(this.$el.find(this.ui.previousIssue));}
                if (AJS.activeShortcuts.u) { AJS.activeShortcuts.u._addShortcutTitle(this.$el.find(this.ui.returnToSearch));}
            }
        },

        _onReturnToSearchClick: function (e) {
            e.preventDefault();
            this.trigger("goBack");

            //IE8 and IE9 do not return focus back to the body after pressing the Return to Search link
            //Thus any subsequent shortcut operations will not work because the focus is wrong
            //This is to return focus back to body
            jQuery("body").focus();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:pager', location = 'content/js/modules/pager/PagerController.js' */
define("jira/issues/modules/pager/controller", ["require"], function(require){
    "use strict";

    var MarionetteController = require('jira/components/libs/marionette-1.4.1/controller');
    var PagerView = require("jira/issues/modules/pager/view");

    /**
     * Pager controller
     */
    return MarionetteController.extend({
        /**
         * Initialize this controller.
         *
         * @param {Object} options Configuration object
         * @param {Backbone.Model} options.model Model used for the view
         */
        initialize: function(options) {
            this.model = options.model;
        },

        /**
         * Returns the instance for the view (and creates it if needed)
         *
         * @returns {JIRA.Components.Pager.View}
         */
        getView: function(container) {
            if (!this.pagerView) {
                this.pagerView = new PagerView({
                    model: this.model,
                    el: container
                });
                this.listenTo(this.pagerView, "close", this.destroyView);
                this.listenAndRethrow(this.pagerView, ["goBack", "nextItem", "previousItem"]);
            } else if (container) {
                this.pagerView.setElement(container);
            }
            return this.pagerView;
        },

        /**
         * Display the view inside a region or an element.
         *
         * @param {Marionette.Region|jQuery} container Container where the view should be rendered
         */
        show: function(container) {
            var view = this.getView(container.pager);
            this.model.set('isError', container.isError);
            view.render();
        },

        /**
         * When the controller is closed, also close the view
         */
        onClose: function(){
            this.pagerView.close();
        },

        /**
         * Unreference the view
         */
        destroyView: function() {
            delete this.pagerView;
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:pager', location = 'content/js/modules/pager/PagerAppModule.js' */
define("jira/issues/modules/pager/appmodule", ["require"], function(require) {
    "use strict";

    var Pager = require("jira/issues/modules/pager");
    var IssuesAPI = JIRA.Issues.Api;

    return function(PagerModule, app) {
        var pager = new Pager({
            nextItem: function() {
                //TODO Refactor to app commands
                IssuesAPI.nextIssue();
            },
            previousItem: function() {
                //TODO Refactor to app commands
                IssuesAPI.prevIssue();
            },
            goBack: function() {
                app.execute("returnToSearch");
            }
        });

        app.addInitializer(function() {
            pager.initialize();
            app.commands.setHandlers({
                "pager:update": pager.update,
                "pager:render": pager.show,
                "pager:close": pager.close
            });
        });
    };

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:pager', location = 'content/js/modules/pager/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/issues/modules/pager/templates", function() {
    "use strict";

    return JIRA.Templates.ViewIssue.Header;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed. Later, we can restore the
 * global reference if needed (see ../js/namespace.js)
 */
AJS.namespace("JIRA.Templates.ViewIssue.Header", null, require("jira/issues/modules/pager/templates"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:pager', location = 'content/js/modules/pager/namespace.js' */
AJS.namespace("JIRA.Components.Pager", null, require("jira/issues/modules/pager"));
AJS.namespace("JIRA.Components.Pager.AppModule", null, require("jira/issues/modules/pager/appmodule"));
AJS.namespace("JIRA.Components.Pager.Controller", null, require("jira/issues/modules/pager/controller"));
AJS.namespace("JIRA.Components.Pager.Model", null, require("jira/issues/modules/pager/model"));
AJS.namespace("JIRA.Components.Pager.View", null, require("jira/issues/modules/pager/view"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-application', location = 'content/js/Application.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Issues.Application");

    JIRA.Issues.Application = new JIRA.Marionette.Application();

    JIRA.Issues.Application.addInitializer(function() {
        this.module("JIRA.Components.Pager", JIRA.Components.Pager.AppModule);

        if (AJS.Meta.get("is-inline-edit-enabled") !== false) {
            this.module("JIRA.Components.IssueEditor", new JIRA.Components.IssueEditor.AppModule().definition);
        } else {
            this.module("JIRA.Components.IssueEditor", new JIRA.Components.IssueEditor.NoInlineAppModule().definition);
        }

        this.module("JIRA.Components.Analytics", new JIRA.Components.Analytics.AppModule().definition);
        JIRA.Issues.AnalyticsLoader.init();

        var NavigationModule = require('jira/issues/modules/navigation/module');
        this.module("JIRA.Components.Navigation", new NavigationModule().definition);
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-utils', location = 'content/js/search/Notifications.js' */
(function() {
    "use strict";

    JIRA.Issues.showNotification = function() {

        var NOTIFICATIONS = {
            "thanks_issue_updated": "{0} has been updated.",
            "thanks_issue_transitioned": "{0} has been updated.",
            "thanks_issue_assigned": "{0} has been assigned.",
            "thanks_issue_commented": "{0} has been updated with your comment.",
            "thanks_issue_worklogged": "Work has been logged on {0}.",
            "thanks_issue_voted": "Your vote on {0} has been updated.",
            "thanks_issue_watched": "Your watcher status on {0} has been updated.",
            "thanks_issue_moved": "{0} has been moved.",
            "thanks_issue_linked": "The links on {0} have been updated.",
            "thanks_issue_cloned": "{0} has been cloned.",
            "thanks_issue_labelled": "The labels on {0} have been updated.",
            "thanks_issue_deleted": "{0} has been deleted.",
            "thanks_issue_attached": "The file(s) have been attached to {0}."
        };

        return function(key, issueKey) {

            var msgText;

            if (!key) {
                key = "thanks_issue_updated";
            }
            msgText = NOTIFICATIONS[key];

            if (msgText && issueKey) {
                msgText = AJS.format(msgText, issueKey);
            }

            JIRA.Messages.showSuccessMsg(msgText || key, {
                closeable: true
            });
        };

    }();
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-utils', location = 'content/js/search/IssueNavRouter.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.IssueNavRouter");

    JIRA.Issues.IssueNavRouter = JIRA.Issues.BaseRouter.extend({

        initialize: function(options) {
            _.extend(this, options);
            _.bindAll(this,
                "_restoreSessionSearch",
                "_route");

            this.route(/^(.*?)([\?]{1}.*)?$/, this._route);
            this.route(/^(issues\/)?$/, this._restoreSessionSearch);

            // backbone-query-parameters supports clever decoding of values into arrays, but we don't want this.
            delete Backbone.Router.arrayValueSplit;

            // listen to changes of state
            this.listenTo(JIRA.Issues.Application, 'navigation:stateChanged', this.onStateChanged);
        },

        /**
         * Overwrite JIRA.Issues.BaseRouter, now it fires an event each time the URL changes
         */
        navigate: function() {
            JIRA.Issues.Tipsy.revalidate();
            this.trigger("navigate");
            JIRA.Issues.BaseRouter.prototype.navigate.apply(this, arguments);
        },

        onStateChanged: function onStateChanged(state, options) {
            //state changed - perform navigation to keep url up to date
            options = options || {};
            var navigateOptions = {
                trigger: false,
                replace: options.replace || false
            };
            this._setStatePermalink(state);
            this.navigate(state.toUrl(), navigateOptions);
        },

        /**
         * Navigate to a new state.
         *
         * @param {JIRA.Issues.URLSerializer.state} state
         * @deprecated use JIRA.Issues.Application.execute("navigation:navigate") instead
         */
        pushState: function(state) {
            this._setStatePermalink(state);
            this.navigate(JIRA.Issues.URLSerializer.getURLFromState(state), {trigger: false});
        },

        /**
         * @deprecated use JIRA.Issues.Application.execute("navigation:navigate", {replace: true}) instead
         */
        replaceState: function(state) {
            this._setStatePermalink(state);
            this.navigate(JIRA.Issues.URLSerializer.getURLFromState(state), {trigger: false, replace: true});
        },

        _restoreSessionSearch: function() {
            var sessionSearch = this.initialSessionSearchState;
            JIRA.Issues.Application.execute('navigation:updateState', sessionSearch, {replace: true, reset: true, resetQuery: true});
        },

        /**
         * The "catch-all" route that distinguishes search and issue fragments.
         *
         * @param {string} path The path component of the URL (relative to the root)
         * @param {object} query The decoded querystring params
         * @private
         */
        _route: function(path, query) {
            // Re-encode back to a full fragment, since we do our own parsing in NavigationController
            var fragment = this.toFragment(path, query);

            if (JIRA.Issues.ignorePopState) {
                // Workaround for Chrome bug firing a null popstate event on page load.
                // Backbone should fix this!
                // @see http://code.google.com/p/chromium/issues/detail?id=63040
                // @see also JRADEV-14804
                return;
            }

            var jqlFromServer = AJS.Meta.get('jql');
            if (jqlFromServer != null) {
                AJS.Meta.set('jql', null);
            }
            var navigateOptions = {checkPermission: true, replace: true, reset: true, routerEvent: true};
            JIRA.Issues.Application.execute('navigation:navigateToUrl', fragment, navigateOptions,
                    jqlFromServer != null ? {jql: jqlFromServer} : undefined);
        },
        /**
         * Set the permalink for a given state into AJS.Meta to be rendered by the share plugin
         */
        _setStatePermalink: function(state) {
            var viewIssueState = _.pick(state, "selectedIssueKey");
            var baseUrl = AJS.Meta.get("jira-base-url");
            if (!_.isEmpty(viewIssueState)) {
                AJS.Meta.set("viewissue-permlink",
                    baseUrl + "/" + JIRA.Issues.URLSerializer.getURLFromState(viewIssueState)
                );
            }
            var issueNavState = _.omit(state, "selectedIssueKey");
            if (!_.isEmpty(issueNavState)) {
                AJS.Meta.set("issuenav-permlink",
                    baseUrl + "/" + JIRA.Issues.URLSerializer.getURLFromState(issueNavState)
                );
            }
        }
    }, {
        /**
         * @return The backbone history root that should be used for the current browser.
         */
        getBackboneRoot: function() {
            return AJS.contextPath() + "/";
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-utils', location = 'content/js/search/IssueNavCreator.js' */
(function(require) {
    "use strict";

    var $ = require("jquery");
    var Events = require("jira/util/events");
    var Metrics = require("jira/issues/navigator/metrics");

    // export some events
    JIRA.Events.LAYOUT_RENDERED = "layoutRendered";

    AJS.namespace("JIRA.Issues.ViewIssueCreator");

    JIRA.Issues.ViewIssueCreator.create = function create($el, options) {

        this.$issueContainer = $(".issue-container");
        this.$searchContainer = $(".navigator-container");

        this.fullScreenIssue = new JIRA.Issues.FullScreenIssue({
            issueContainer: this.$issueContainer,
            searchContainer: this.$searchContainer
        });

        // Router
        this.issueNavRouter = new JIRA.Issues.IssueNavRouter({
            initialSessionSearchState: options.initialSessionSearchState
        });

        JIRA.Issues.enhanceLinks.toIssueNav();
        JIRA.Issues.enhanceLinks.toIssue();
        JIRA.Issues.enhanceLinks.withPushState({});

        JIRA.Issues.Application.on("issueEditor:linkToIssue", function(event) {
            Metrics.notifyIssueView();
            JIRA.Issues.Application.execute('navigation:navigate', {
                selectedIssueKey: event.issueKey
            }, {reset: true});
        });

        // Initialize event bubbling
        JIRA.Issues.Application.on("issueEditor:saveSuccess", function(props) {
            Events.trigger(JIRA.Events.ISSUE_REFRESHED, [props.issueId]);
        });
        JIRA.Issues.Application.on("issueEditor:saveError", function(props) {
            if (!props.deferred) {
                Events.trigger(JIRA.Events.ISSUE_REFRESHED, [props.issueId]);
            }
        });
        JIRA.Issues.Application.on("issueEditor:render", function(regions) {
            JIRA.Issues.Application.execute("pager:render", regions);
        });

        // Patch the APIs
        JIRA.Issues.IssueAPI.override();

        JIRA.Issues.IssueNavigatorAPI.override();

        /**
         * Used to defer the showing of issue dialogs until all promises are resolved.
         * We use this to ensure the dialog we are opening has the correct data.
         * If we are inline editing the summary then open the edit dialog, we want to be sure that the summary has been
         * updated on the server first, otherwise we will be showing stale data in the edit dialog.
         */
        JIRA.Dialogs.BeforeShowIssueDialogHandler.add(JIRA.Issues.Api.waitForSavesToComplete);
        return this;
    };
}(window.require));

(function(require) {
    "use strict";

    var $ = require("jquery");
    var _ = require("underscore");
    var Meta = require("jira/util/data/meta");
    var Events = require("jira/util/events");

    AJS.namespace("JIRA.Issues.IssueNavCreator");

    JIRA.Issues.IssueNavCreator.create = function($el, options) {
        options = _.defaults(options, {standaloneIssue: false});
        var viewIssueComponents = options.viewIssueComponents || JIRA.Issues.ViewIssueCreator.create($el, options);

        this.fullScreenIssue = viewIssueComponents.fullScreenIssue;

        var searchPageModule = this.searchPageModule = new JIRA.Issues.SearchPageModule({}, {
            initialIssueTableState: options.initialIssueTableStatea
        });

        searchPageModule.registerViewContainers({
            issueContainer: viewIssueComponents.$issueContainer,
            searchContainer: viewIssueComponents.$searchContainer
        });

        // Initialise Modules

        var searchHeaderModule = this.searchHeaderModule = new JIRA.Issues.SearchHeaderModule({
            searchPageModule: searchPageModule
        });

        var filterModule = new JIRA.Issues.FilterModule({
            searchPageModule: searchPageModule,
            systemFilters: searchPageModule.addOwnerToSystemFilters(options.systemFilters)
        });

        // TODO TF-693 - FullScreenIssue have detached this element, so we reach inside to get a reference
        var $queryForm = this.fullScreenIssue.searchContainer.find("form.navigator-search");
        var queryModule = JIRA.Components.Query.create({
            el: $queryForm,
            searchers: options.initialSearcherCollectionState,
            preferredSearchMode: Meta.get("user.search.mode"),
            layoutSwitcher: true,
            autocompleteEnabled: Meta.getBoolean("autocomplete-enabled"),
            basicAutoUpdate: Meta.getBoolean("hasCriteriaAutoUpdate")
        });


        Events.bind(JIRA.Events.ISSUE_TABLE_REORDER, function(e) {
            if (!JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                e.preventDefault();
            }
        });

        this.layoutSwitcherView = new JIRA.Issues.LayoutSwitcherView({
            searchPageModule: searchPageModule
        });
        // TODO TF-693 - FullScreenIssue have detached this element, so we reach inside to get a reference
        var $layoutSwitcherToggle = this.fullScreenIssue.searchContainer.find("#layout-switcher-toggle");
        this.layoutSwitcherView.setElement($layoutSwitcherToggle).render();

        var issueModule = JIRA.Issues.Application.request("issueEditor");

        JIRA.Issues.Application.on("issueEditor:refineViewer", function(event) {
            event.preventDefault();
            JIRA.Issues.Application.execute("issueEditor:updateIssueWithQuery", event.query);
        });
        JIRA.Issues.Application.commands.setHandler("returnToSearch", function() {
            JIRA.Issues.Application.execute("issueEditor:close");
        });

        JIRA.Issues.FocusShifter.init();

        var viewIssueData = issueModule.viewIssueData;

        var issueSearchManager = new JIRA.Issues.IssueSearchManager({
            initialIssueTableState: options.initialIssueTableState,
            initialIssueIds: options.initialIssueIds
        });

        var searchModule = new JIRA.Issues.SearchModule({
            searchPageModule: searchPageModule,
            queryModule: queryModule,
            issueSearchManager: issueSearchManager,
            initialSelectedIssue: options.initialSelectedIssue
        });

        var issueCacheManager = new JIRA.Issues.Cache.IssueCacheManager({
            searchResults: searchModule.getResults(),
            viewIssueData: viewIssueData
        });

        this.fullScreenIssue.registerIssueCacheManager(issueCacheManager);

        // TODO TF-693 - FullScreenIssue will detach these elements, so get a reference now before they're not discoverable.
        var issueNavToolsElement = this.fullScreenIssue.searchContainer.find(".saved-search-selector");
        // TODO TF-693 - Try to prevent FullScreenIssue from hacking and mutilating the DOM so much...

        // Register Modules
        searchPageModule.registerSearch(searchModule);
        searchPageModule.registerSearchHeaderModule(searchHeaderModule);
        searchPageModule.registerFilterModule(filterModule);
        searchPageModule.registerQueryModule(queryModule);

        searchPageModule.registerFullScreenIssue(viewIssueComponents.fullScreenIssue);

        searchPageModule.registerIssueSearchManager(issueSearchManager);
        searchPageModule.registerIssueCacheManager(issueCacheManager);
        searchPageModule.registerLayoutSwitcher(this.layoutSwitcherView);

        searchHeaderModule.registerSearch(searchModule);
        searchHeaderModule.createToolsView(issueNavToolsElement);

        if (options.standaloneIssue) {
            //Make sure that SPM knows that we are viewing standalone issue without resetting what is already rendered
            searchPageModule.standalone = true;
        }
        // Overrides

        JIRA.Issues.enhanceLinks.registerSearchPageModule(searchPageModule);

        JIRA.Issues.dialogCleaner(viewIssueComponents.issueNavRouter);

        JIRA.Issues.Api.initialize({
            searchPageModule: searchPageModule
        });

        JIRA.Issues.overrideIssueDialogs({
            getIssueId: _.bind(searchPageModule.getEffectiveIssueId, searchPageModule),
            isNavigator: true,
            updateIssue: function(dialog) {
                var issueUpdate = JIRA.Issues.Utils.getUpdateCommandForDialog(dialog);
                return searchPageModule.updateIssue(issueUpdate);
            }
        });

        // Keyboard shortcuts ?

        $(document).keydown(function(e) {
            var dialogIsVisible = $("div.aui-blanket").length > 0;
            var wasSupportedKey = (e.which === $.ui.keyCode.ENTER || e.which === $.ui.keyCode.LEFT ||
                e.which === $.ui.keyCode.UP || e.which === $.ui.keyCode.RIGHT || e.which === $.ui.keyCode.DOWN);

            if (!dialogIsVisible && wasSupportedKey) {
                var target = $(e.target);
                var targetIsValid = target.is(":not(:input)");

                if (target == null || targetIsValid) {
                    if (e.which === $.ui.keyCode.ENTER) {
                        if (target == null || target.is(":not(a)")) {
                            JIRA.Issues.Api.viewSelectedIssue();
                        }
                    } else if (e.which === $.ui.keyCode.LEFT) {
                        searchPageModule.handleLeft();
                    } else if (e.which === $.ui.keyCode.RIGHT) {
                        searchPageModule.handleRight();
                    } else if (e.which === $.ui.keyCode.UP) {
                        if (searchPageModule.handleUp()) {
                            e.preventDefault();
                        }
                    } else if (e.which === $.ui.keyCode.DOWN) {
                        if (searchPageModule.handleDown()) {
                            e.preventDefault();
                        }
                    }
                }
            }
        });

        // Not such a crash hot idea; should remove it.
        this.searchResults = searchModule.getResults();

        // Create the on change bindings for updating the login link.
        this.searchPageModule.on("change", changeLoginUrl);
        this.searchResults.on("change", changeLoginUrl);
        this.searchResults.getSelectedIssue().on("change", changeLoginUrl);

        return this;
    };

    //Change the login url to the current state.
    function changeLoginUrl() {
        var url = JIRA.Issues.LoginUtils.redirectUrlToCurrent();
        $('.login-link').attr('href', url);
    }
}(window.require));

(function(require) {
    "use strict";

    var $ = require("jquery");
    var Messages = require("jira/message");

    AJS.namespace("JIRA.Issues.GlobalIssueNavCreator");

    JIRA.Issues.GlobalIssueNavCreator.create = function($el, options) {

        // Construct base issue navigator
        var issuenav = JIRA.Issues.IssueNavCreator.create($el, options);

        // Create filter modules' views

        var filterModule = issuenav.searchPageModule.filterModule; // HACK: I'm reaching inside the issuenav because the filter module is depended on by base behaviour of the whole thing.
        // TODO TF-693 - FullScreenIssue have detached these elements, so we reach inside to get a reference
        var $filterPanelEl = issuenav.fullScreenIssue.searchContainer.find(".navigator-sidebar");
        var $filterHeaderEl = issuenav.fullScreenIssue.searchContainer.find("#search-header-view");

        filterModule.createView({
            $filterPanelEl: $filterPanelEl
        });
        filterModule.filtersComponent.showFilterHeader({
            el: $filterHeaderEl,
            model: issuenav.searchPageModule.getFilter(),
            isEdited: issuenav.searchPageModule.isDirty()
        });

        // Find the quickSearch message (if any) and convert it to a JIRA.Message
        var quickSearchMessaage = $("#quicksearch-message");
        if (quickSearchMessaage.length) {
            var $container = Messages.showWarningMsg(quickSearchMessaage.find("p").html(), {
                closeable: true
            });
            $("a", $container).click(function() {
                $container.remove();
            });
        }

        return issuenav;
    };
    /**
    * Read all the initial data in the DOM
    *
    * If the ColumnConfigState has been sent from the server we want to take the HTML from the table
    * and pop it onto its table property.
    *
    * This prevents us from having to populate the HTML twice in the dom. Once in the HTML and another time in the
    * JSON. It also prevents us needing to ensure there are no XSS vulnerabilities in the JSON HTML string.
    */
    JIRA.Issues.GlobalIssueNavCreator.readInitialData = function readInitialData() {
        var data = {};
        var $navigatorContent = $(".navigator-content");

        data.initialIssueTableState = $navigatorContent.data("issue-table-model-state");
        if (data.initialIssueTableState && !data.initialIssueTableState.table) {
            var wrapper = $("<div></div>").append($navigatorContent.children().clone());
            data.initialIssueTableState.issueTable.table = wrapper.html();
        }

        data.initialIssueIds = AJS.$('#stableSearchIds').data('ids');
        data.initialSelectedIssue = $navigatorContent.data("selected-issue");

        // jQuery.parseJSON gracefully returns null given an empty string.
        // Would be even nicer if the json was placed in a data- attribute, which jQuery will automatically parse with .data().
        data.initialSearcherCollectionState = $.parseJSON($("#criteriaJson").text());

        var DarkFeatures = require("jira/components/issueviewer/services/darkfeatures");
        var httpSessionDisabled = DarkFeatures.HTTP_SESSIONS_DISABLED.enabled;

        if (httpSessionDisabled) {

            var LatestSearchStore = require("jira/components/search/latestStorage");
            var latestSearch = LatestSearchStore.get();

            if (latestSearch && (latestSearch.jql || latestSearch.filter)) {
                data.initialSessionSearchState = latestSearch;
            }

            if (!data.initialSessionSearchState) {
                // We use the backup from the server. Despite the name, this doesn't actually look at the session any more
                // but rather uses a fallback filter definition from the server for a user's default filter. Particularly
                // useful when someone first uses JIRA.
                data.initialSessionSearchState = $navigatorContent.data("session-search-state");
            }
        } else {
            data.initialSessionSearchState = $navigatorContent.data("session-search-state");
        }
        data.systemFilters = $.parseJSON($("#systemFiltersJson").text());

        return data;
    };

})(window.require);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:viewissue', location = 'content/js/viewissue/util/FocusShifterService.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Issues.FocusShifter");

    JIRA.Issues.FocusShifter.init = function() {
        return JIRA.Shifter.register(function() {
            var suggestions;
            if (JIRA.Issues.Api.issueIsVisible && !JIRA.Issues.Api.issueIsVisible()) {
                suggestions = [];
            } else {
                var fields = JIRA.Issues.Api.getFieldsOnSelectedIssue();
                suggestions = fields ? JIRA.Issues.FocusShifter.getSuggestions(fields) : [];
            }

            return {
                id: 'edit-fields',
                name: "Edit Fields",
                context: JIRA.Issue.getIssueKey(),
                weight: 100,
                getSuggestions: function() {
                    return new jQuery.Deferred().resolve(suggestions);
                },
                onSelection: function(fieldId) {
                    JIRA.Issues.Api.editFieldOnSelectedIssue(fieldId);
                }
            };
        });
    };

    JIRA.Issues.FocusShifter.show = function() {
        // TODO show the shifter with the correct group already selected
        JIRA.Shifter.show();
    };

    JIRA.Issues.FocusShifter.getSuggestions = function(fields) {
        return _
            .chain(fields.models)
            .filter(JIRA.Components.IssueEditor.Models.Field.IS_EDITABLE)
            .filter(function(field) {
                return field.id !== 'comment';
            })
            .map(function(field) {
                return {
                    label: field.getLabel(),
                    value: field.id
                };
            })
            .value();
    };
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:viewissue', location = 'content/js/viewissue/util/Overrides.js' */
(function(){
    "use strict";

    /**
     * As we do not do full page pops now, we wait for issue refresh instead of page reload
     */
    JIRA.Messages.showMsgOnReload = function (msg, options) {
        JIRA.one(JIRA.Events.ISSUE_REFRESHED, function () {
            options.type = JIRA.Messages.Types[options.type];
            JIRA.Messages.showMsg(msg, options);
        });
    };
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:viewissue', location = 'content/templates/util.soy' */
// This file was automatically generated from util.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Issues.Util.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Issues == 'undefined') { JIRA.Templates.Issues = {}; }
if (typeof JIRA.Templates.Issues.Util == 'undefined') { JIRA.Templates.Issues.Util = {}; }


JIRA.Templates.Issues.Util.simpleLink = function(opt_data, opt_ignored) {
  return '<a' + ((opt_data.link.id) ? ' id="' + soy.$$escapeHtml(opt_data.link.id) + '"' : '') + 'href="' + ((opt_data.link.href) ? soy.$$escapeHtml(opt_data.link.href) : '#') + '"' + ((opt_data.link.styleClass || opt_data.additionalStyleClass) ? 'class="' + soy.$$escapeHtml(opt_data.link.styleClass) + ((opt_data.additionalStyleClass) ? ' ' + soy.$$escapeHtml(opt_data.additionalStyleClass) : '') + '"' : '') + ((opt_data.link.title) ? 'title="' + soy.$$escapeHtml(opt_data.link.title) + '"' : '') + '><span>' + soy.$$escapeHtml(opt_data.link.label) + '</span></a>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.Util.simpleLink.soyTemplateName = 'JIRA.Templates.Issues.Util.simpleLink';
}


JIRA.Templates.Issues.Util.issueAnchor = function(opt_data, opt_ignored) {
  return '<a class="issue-key" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.issueKey) + '"> ' + soy.$$escapeHtml(opt_data.issueKey) + ' </a>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.Util.issueAnchor.soyTemplateName = 'JIRA.Templates.Issues.Util.issueAnchor';
}


JIRA.Templates.Issues.Util.anonymousErrorDialog = function(opt_data, opt_ignored) {
  return '<div class="aui-dialog-content"><div class="form-body"><h2 class="dialog-title">' + soy.$$escapeHtml("Session Expired") + '</h2>' + JIRA.Templates.Issues.ComponentUtil.auiMessage({typeClass: 'warning', messages: ["It looks like your session has timed out, or you have been logged out of JIRA. You will need to log back in to continue."]}) + '</div><div class="buttons-container form-footer"><div class="buttons"><a accesskey="' + soy.$$escapeHtml("s") + '" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to submit this form","s",opt_data.modifierKey)) + '" class="aui-button submit" href="' + soy.$$escapeHtml("/jira") + '/login.jsp?os_destination=' + soy.$$escapeHtml(opt_data.redirect) + '">' + soy.$$escapeHtml("Log in again") + '</a><a accesskey="' + soy.$$escapeHtml("`") + '" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to cancel","`",opt_data.modifierKey)) + '" class="aui-button aui-button-link cancel">' + soy.$$escapeHtml("Ignore") + '</a></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.Util.anonymousErrorDialog.soyTemplateName = 'JIRA.Templates.Issues.Util.anonymousErrorDialog';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:viewissue', location = 'content/js/viewissue/IssueNavLoader.js' */
define('jira/issues/viewissue/issuenavloader', [
    'jquery',
    'jira/util/browser'
],
function(
    jQuery,
    Browser
) {
    "use strict";

    /**
     * Utility object for fetching issue search resources. It will handle application state changes (i.e it will remember
     * last state change and repeat it when issue search components are initialized). In case of problems with loading
     * issue search components it will perform a full page reload to given URL.
     */
    return {
        /**
         * Number of ms that IssueNavLoader will wait for initilizing issue search components until it will perform a
         * full page reload.
         *
         * @const
         * @type {Number}
         * @default
         */
        SPA_NAVIGATION_TIMEOUT: 6 * 1000,
        /**
         * Last state that application navigated to.
         *
         * @type {State}
         */
        stateChange: undefined,
        /**
         * Initialize IssueNavLoader.
         *
         * @param {Object} issueNavOptions - parameters that will be passed to IssueNavCreator
         */
        initialize: function initialize(issueNavOptions) {
            this.issueNavOptions = issueNavOptions;
        },
        /**
         * Asynchronously download issue search resources
         *
         * @returns {jQuery.Deferred} promise, that is resolved when web resources are downloaded
         */
        requireIssueNav: function requireIssueNav() {
            var deferred = new jQuery.Deferred();

            WRM.require(['wrc!com.atlassian.jira.jira-issue-nav-plugin:issuenav'], function () {
                deferred.resolve();
            });

            return deferred.promise();
        },
        /**
         * Load issue search components. Any application state change that will happen during loading will be repeated
         * after issue search is initialized, or after certain timeout, will be loaded as a full page reload.
         *
         * @returns {jQuery.Deferred} promise, that is resolved when issue nav is initialized and all previous state changes performed.
         */
        loadIssueNav: function loadIssueNav() {
            JIRA.Issues.Application.on('navigation:stateChanged', this._onStateChanged, this);
            return this.requireIssueNav()
                    .then(function() {
                        JIRA.Issues.GlobalIssueNavCreator.create(jQuery(document), this.issueNavOptions);
                    }.bind(this))
                    .then(this._onIssueNavInitialized.bind(this));
        },
        _onIssueNavInitialized: function onIssueNavInitialized() {
            if (this.stateChange) {
                JIRA.Issues.Application.execute('navigation:updateState', this.stateChange,
                        {replace: true, reset: true, forceRefresh: true});
                this.stateChange = undefined;
            }
            JIRA.Issues.Application.off('navigation:stateChanged', this._onStateChanged);
        },
        _onStateChanged: function _onStateChanged(state) {
            this.stateChange = state; //keep only the last one
            this._triggerNavigationAnalyticsEvent();
            setTimeout(function () {
                //if we haven't navigated yet, let's do a full page reload
                if (this.stateChange) {
                    JIRA.Issues.Application.execute("analytics:trigger", "kickass.viewIssueNavigationPageReload", {
                        navigationTimeout: this.SPA_NAVIGATION_TIMEOUT
                    });
                    var url = AJS.contextPath() + "/" + this.stateChange.toUrl();

                    Browser.reloadViaWindowLocation(url);
                }
            }.bind(this), this.SPA_NAVIGATION_TIMEOUT);
        },
        _triggerNavigationAnalyticsEvent: function _triggerNavigationAnalyticsEvent() {
            var eventTime;
            eventTime = parseInt(window.performance.now() - window.performance.timing.loadEventEnd + window.performance.timing.navigationStart);
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.viewIssueNavigationRequested", {
                navigationTime: eventTime
            });
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/IssueTable.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueTable");
    JIRA.Components.IssueTable = JIRA.Marionette.Controller.extend({

        initialize: function(options) {
            this.issueTableView = new JIRA.Issues.IssueTableView({
                columnConfig: options.columnConfig
            });
            this._createSearchService(options);
            this._createTableController(options);

            JIRA.Issues.Application.on("issueEditor:loadError", this._handleIssueLoadError, this);
        },

        _createSearchService: function(options) {
            this.searchService = options.searchService;
            this.listenTo(this.searchService, {
                "before:search": function() {
                    this.issueTableController.showPending();
                },
                "search": function(table, searchResults) {
                    this.latestResults = {
                        table: table,
                        sortOptions: searchResults.getSortBy(),
                        totalDisplayableIssues: searchResults.getDisplayableTotal(),
                        startIndex: searchResults.getStartIndex(),
                        pageSize: searchResults.getPageSize(),
                        pageNumber: searchResults.getPageNumber(),
                        numberOfPages: searchResults.getNumberOfPages(),
                        totalIssues: searchResults.getTotal(),
                        currentSearch: JIRA.Issues.Application.request("issueNav:currentSearchRequest"),
                        jiraHasIssues: searchResults.getJiraHasIssues(),
                        hasIssues: searchResults.hasIssues()
                    };
                    this.show();
                    this.highlightIssue(searchResults.getHighlightedIssue().id, false);
                },
                "error:search": function() {
                    this.issueTableController.showErrorMessage();
                },
                "issueUpdated": function(issueId, entity) {
                    this.issueTableController.updateIssue(issueId, entity.table);
                },
                "issueHighlighted": function(issueId) {
                    this.issueTableController.highlightIssue(issueId);
                },
                "selectedIssueChanged": function(selectedIssue, highlightedIssue) {
                    if (!selectedIssue.hasIssue()) {
                        this.issueTableController.highlightIssue(highlightedIssue.id);
                    }
                }

            });
        },

        _createTableController: function(options) {
            var columnConfig = options.columnConfig;
            var el = options.el;

            this.issueTableController = new JIRA.Components.IssueTable.Controllers.IssueTable({
                el: el
            });
            this.listenTo(this.issueTableController, {
                "goToPage": function(startIndex) {
                    this.searchService.goToPage(startIndex);
                },
                "columnsChanged": function(cols) {
                    columnConfig.saveColumns(cols);
                },
                "highlightIssue": function(issueId) {
                    this.trigger("highlightIssue", issueId);
                },
                "sort": function(fieldId) {
                    this.searchService.sort(fieldId);
                },
                "refresh": function() {
                    this.searchService.runCurrentSearch();
                },
                "renderTable": function($el) {
                    JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [$el, JIRA.CONTENT_ADDED_REASON.issueTableRefreshed]);
                    JIRA.trace("jira.search.stable.update");
                },
                "renderEmpty": function($el) {
                    JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [$el, JIRA.CONTENT_ADDED_REASON.issueTableRefreshed]);
                    JIRA.trace("jira.search.stable.update");
                },
                "issueRowUpdated": function($newRow) {
                    JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [$newRow, JIRA.CONTENT_ADDED_REASON.issueTableRowRefreshed]);
                    // even though we've only replaced one row, a search has occurred at this point. all our
                    // WebDriver tests expect this trace after modifying issues from the issue nav
                    JIRA.trace('jira.search.finished');
                }
            });
        },

        show: function() {
            if (!this.latestResults) {
                this.searchService.updateExitingResults();
            } else {
                this.issueTableController.show(this.latestResults);
                this.trigger("render");
                this.issueTableView._onSearchDone(this.issueTableController.view.$el);
            }
        },

        close: function() {
            this.issueTableController.close();
            this.stopListening(this.searchService);
            JIRA.Issues.Application.off("issueEditor:loadError", this._handleIssueLoadError, this);
            delete this.issueTableController;
            delete this.searchService;
        },

        handleIssueInaccessible: function(issueId) {
            this.issueTableController.markIssueAsInaccessible(issueId);
        },

        /**
         * Highlight an issue in the table.
         *
         * @param {number} issueId The ID of the issue to highlight.
         * @param {boolean} [focus=true] Whether the highlighted issue should have the focus
         */
        highlightIssue: function(issueId, focus) {
            this.issueTableController.highlightIssue(issueId, focus);
        },

        _handleIssueLoadError: function(entity) {
            // If the issue has been deleted, update its row in the table.
            if (entity.response.status === 404) {
                this.issueTableController.markIssueAsInaccessible(entity.issueId);
            }
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/templates/issuenav-results.soy' */
// This file was automatically generated from issuenav-results.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNav.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNav == 'undefined') { JIRA.Templates.IssueNav = {}; }


JIRA.Templates.IssueNav.resultsCount = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.IssueNav.resultsCountHelper({start: '<span class="results-count-start">' + soy.$$escapeHtml(opt_data.start) + '</span>', end: '<span class="results-count-end">' + soy.$$escapeHtml(opt_data.end) + '</span>', total: '<span class="results-count-total results-count-link">' + soy.$$escapeHtml(opt_data.total) + '</span>'});
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.resultsCount.soyTemplateName = 'JIRA.Templates.IssueNav.resultsCount';
}


JIRA.Templates.IssueNav.resultsCountHelper = function(opt_data, opt_ignored) {
  return '<span class="results-count-text">' + soy.$$filterNoAutoescape(AJS.format("{0}\x26ndash;{1} of {2}",opt_data.start,opt_data.end,opt_data.total)) + '</span>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.resultsCountHelper.soyTemplateName = 'JIRA.Templates.IssueNav.resultsCountHelper';
}


JIRA.Templates.IssueNav.endOfStableMessage = function(opt_data, opt_ignored) {
  return '<p>' + soy.$$escapeHtml("Too many search results to display. Refine your search criteria and try again.") + '</p>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.endOfStableMessage.soyTemplateName = 'JIRA.Templates.IssueNav.endOfStableMessage';
}


JIRA.Templates.IssueNav.refreshResults = function(opt_data, opt_ignored) {
  return '<a href="#" class="refresh-table" title="' + soy.$$escapeHtml("Refresh results") + '"><span class="aui-icon aui-icon-small aui-iconfont-refresh-small">' + soy.$$escapeHtml("Refresh results") + '</span></a>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.refreshResults.soyTemplateName = 'JIRA.Templates.IssueNav.refreshResults';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/templates/issuenav-pagination.soy' */
// This file was automatically generated from issuenav-pagination.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavTable.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavTable == 'undefined') { JIRA.Templates.IssueNavTable = {}; }


JIRA.Templates.IssueNavTable.pagination = function(opt_data, opt_ignored) {
  var output = '<div class="pagination" data-displayable-total="' + soy.$$escapeHtml(opt_data.displayableTotal) + '">';
  var MAX_PAGES_DISPLAYED__soy6 = 5;
  var lastPage__soy7 = Math.floor((opt_data.displayableTotal - 1) / opt_data.pageSize);
  var pageNumber__soy8 = Math.floor(opt_data.startIndex / opt_data.pageSize);
  var urlFragment__soy9 = soy.$$escapeHtml("/jira") + '/' + soy.$$filterNoAutoescape(opt_data.searchQuery) + '&startIndex=';
  var prevStartIndex__soy15 = opt_data.startIndex - opt_data.pageSize;
  output += ((prevStartIndex__soy15 >= 0) ? '<a href="' + soy.$$escapeHtml(urlFragment__soy9) + soy.$$escapeHtml(prevStartIndex__soy15) + '" data-start-index="' + soy.$$escapeHtml(prevStartIndex__soy15) + '" class="icon icon-previous" title="' + soy.$$escapeHtml(AJS.format("Go to page {0} of {1}",pageNumber__soy8,lastPage__soy7 + 1)) + '"><span>&lt;&lt; ' + soy.$$escapeHtml("Previous") + '</span></a>' : '') + JIRA.Templates.IssueNavTable.numberLinksLogicBranch({startPage: pageNumber__soy8 - Math.floor(MAX_PAGES_DISPLAYED__soy6 / 2), endPage: pageNumber__soy8 + Math.floor(MAX_PAGES_DISPLAYED__soy6 / 2), lastPage: lastPage__soy7, urlFragment: urlFragment__soy9, currentPage: pageNumber__soy8 + 1, maxPagesDisplayed: MAX_PAGES_DISPLAYED__soy6, pageSize: opt_data.pageSize, displayableTotal: opt_data.displayableTotal});
  var nextStartIndex__soy37 = Math.min(opt_data.startIndex + opt_data.pageSize, opt_data.displayableTotal);
  output += ((nextStartIndex__soy37 < opt_data.displayableTotal) ? '<a href="' + soy.$$escapeHtml(urlFragment__soy9) + soy.$$escapeHtml(nextStartIndex__soy37) + '" data-start-index="' + soy.$$escapeHtml(nextStartIndex__soy37) + '" class="icon icon-next" title="' + soy.$$escapeHtml(AJS.format("Go to page {0} of {1}",pageNumber__soy8 + 2,lastPage__soy7 + 1)) + '"><span>' + soy.$$escapeHtml("Next") + ' &gt;&gt;</span></a>' : '') + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.pagination.soyTemplateName = 'JIRA.Templates.IssueNavTable.pagination';
}


JIRA.Templates.IssueNavTable.numberLinksLogicBranch = function(opt_data, opt_ignored) {
  return '' + ((opt_data.lastPage < opt_data.maxPagesDisplayed) ? JIRA.Templates.IssueNavTable.numberLinks(soy.$$augmentMap(opt_data, {startPage: 0, endPage: opt_data.lastPage})) : (opt_data.startPage < 0) ? JIRA.Templates.IssueNavTable.numberLinks(soy.$$augmentMap(opt_data, {startPage: 0, endPage: opt_data.endPage - opt_data.startPage})) : (opt_data.endPage > opt_data.lastPage) ? JIRA.Templates.IssueNavTable.numberLinks(soy.$$augmentMap(opt_data, {startPage: opt_data.startPage - (opt_data.endPage - opt_data.lastPage), endPage: opt_data.lastPage})) : JIRA.Templates.IssueNavTable.numberLinks(opt_data));
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.numberLinksLogicBranch.soyTemplateName = 'JIRA.Templates.IssueNavTable.numberLinksLogicBranch';
}


JIRA.Templates.IssueNavTable.numberLinks = function(opt_data, opt_ignored) {
  var output = '';
  var size__soy72 = opt_data.endPage - opt_data.startPage + 1;
  if (size__soy72 > 1) {
    var iLimit75 = Math.round(size__soy72);
    for (var i75 = 0; i75 < iLimit75; i75++) {
      var pageIndex__soy76 = i75 + opt_data.startPage;
      var pageNumber__soy77 = pageIndex__soy76 + 1;
      var pageStartIndex__soy78 = pageIndex__soy76 * opt_data.pageSize;
      var pageEndIndex__soy79 = Math.min(pageStartIndex__soy78 + opt_data.pageSize, opt_data.displayableTotal);
      var pageBoundaries__soy80 = '' + soy.$$escapeHtml(AJS.format("Issues {0} - {1}",pageStartIndex__soy78 + 1,pageEndIndex__soy79));
      output += ' ' + ((pageNumber__soy77 == opt_data.currentPage) ? '<strong title="' + soy.$$escapeHtml(pageBoundaries__soy80) + '">' + soy.$$escapeHtml(pageNumber__soy77) + '</strong>' : '<a href="' + soy.$$escapeHtml(opt_data.urlFragment) + soy.$$escapeHtml(pageStartIndex__soy78) + '" data-page="' + soy.$$escapeHtml(pageNumber__soy77) + '" data-start-index="' + soy.$$escapeHtml(pageStartIndex__soy78) + '" title="' + soy.$$escapeHtml(pageBoundaries__soy80) + '">' + soy.$$escapeHtml(pageNumber__soy77) + '</a>');
    }
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.numberLinks.soyTemplateName = 'JIRA.Templates.IssueNavTable.numberLinks';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/templates/issuenav-table.soy' */
// This file was automatically generated from issuenav-table.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavTable.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavTable == 'undefined') { JIRA.Templates.IssueNavTable = {}; }


JIRA.Templates.IssueNavTable.structure = function(opt_data, opt_ignored) {
  return '<div class="list-view"><div class="aui-group aui-group-split issue-table-info-bar"><div class="aui-item"><div class="results-count-top"></div><div class="refresh-table-top"></div></div><div class="aui-item"><div class="column-picker-trigger-container"></div></div></div><div class="issue-table-container"></div><div class="end-of-stable-message"></div><div class="aui-group aui-group-split count-pagination"><div class="aui-item"><div class="results-count-bottom"></div><div class="refresh-table-bottom"></div></div><div class="aui-item"><div class="pagination"></div></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.structure.soyTemplateName = 'JIRA.Templates.IssueNavTable.structure';
}


JIRA.Templates.IssueNavTable.noResults = function(opt_data, opt_ignored) {
  return '<div class="jira-adbox jira-adbox-medium no-results ' + soy.$$escapeHtml(opt_data.cssClass) + '"><h3>' + soy.$$filterNoAutoescape(opt_data.message) + '</h3>' + ((opt_data.hint) ? '<p class="no-results-hint">' + soy.$$filterNoAutoescape(opt_data.hint) + '</p>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.noResults.soyTemplateName = 'JIRA.Templates.IssueNavTable.noResults';
}


JIRA.Templates.IssueNavTable.listOptions = function(opt_data, opt_ignored) {
  var output = '<div class="aui-list">';
  var groupList20 = opt_data.groups;
  var groupListLen20 = groupList20.length;
  for (var groupIndex20 = 0; groupIndex20 < groupListLen20; groupIndex20++) {
    var groupData20 = groupList20[groupIndex20];
    output += ((groupData20.label) ? '<h5>' + soy.$$escapeHtml(groupData20.label) + '</h5>' : '') + '<ul ' + ((groupData20.id) ? 'id="' + soy.$$escapeHtml(groupData20.id) + '"' : '') + ' class="aui-list-section' + ((groupIndex20 == 0) ? ' aui-first' : '') + ((groupIndex20 == groupListLen20 - 1) ? ' aui-last' : '') + '">';
    var itemList40 = groupData20.items;
    var itemListLen40 = itemList40.length;
    for (var itemIndex40 = 0; itemIndex40 < itemListLen40; itemIndex40++) {
      var itemData40 = itemList40[itemIndex40];
      output += '<li class="aui-list-item"><a class="aui-list-item-link" ' + ((itemData40.id) ? 'id="' + soy.$$escapeHtml(itemData40.id) + '"' : '') + ' ' + ((itemData40.rel) ? 'rel="' + soy.$$escapeHtml(itemData40.rel) + '"' : '') + ' href="' + ((! itemData40.relativeLink) ? soy.$$escapeHtml("/jira") : '') + soy.$$escapeHtml(itemData40.link) + '" ' + ((itemData40.title) ? 'title="' + soy.$$escapeHtml(itemData40.title) + '"' : '') + '>' + soy.$$escapeHtml(itemData40.label) + '</a></li>';
    }
    output += '</ul>';
  }
  output += '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.listOptions.soyTemplateName = 'JIRA.Templates.IssueNavTable.listOptions';
}


JIRA.Templates.IssueNavTable.views = function(opt_data, opt_ignored) {
  return '' + ((opt_data.sections.issue && opt_data.sections.issue.length > 0) ? '<div class="issue-panel aui-dropdown2-section">' + JIRA.Templates.IssueNavTable.listOptions({groups: opt_data.sections.issue}) + '</div>' : '') + ((opt_data.sections.filter && opt_data.sections.filter.length > 0) ? '<div class="filter-panel aui-dropdown2-section">' + JIRA.Templates.IssueNavTable.listOptions({groups: opt_data.sections.filter}) + '</div>' : '');
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.views.soyTemplateName = 'JIRA.Templates.IssueNavTable.views';
}


JIRA.Templates.IssueNavTable.tools = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.IssueNavTable.listOptions(opt_data);
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.tools.soyTemplateName = 'JIRA.Templates.IssueNavTable.tools';
}


JIRA.Templates.IssueNavTable.inaccessibleIssueRow = function(opt_data, opt_ignored) {
  return '<tr class="issuerow inaccessible-issue" rel="' + soy.$$escapeHtml(opt_data.issueID) + '"><td class="nav" colspan="' + soy.$$escapeHtml(opt_data.columnCount) + '">' + soy.$$escapeHtml("This issue can no longer be opened") + '</td></tr>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.inaccessibleIssueRow.soyTemplateName = 'JIRA.Templates.IssueNavTable.inaccessibleIssueRow';
}


JIRA.Templates.IssueNavTable.headerSortIcon = function(opt_data, opt_ignored) {
  return '<span class="aui-icon aui-icon-small aui-iconfont-' + ((opt_data.order == 'ASC') ? 'up' : 'down') + ' issuetable-header-sort-icon"></span>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.headerSortIcon.soyTemplateName = 'JIRA.Templates.IssueNavTable.headerSortIcon';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/EmptyResults.js' */
(function() {
    "use strict";
    AJS.namespace("JIRA.Components.IssueTable.Views.EmptyResults");

    /**
     * @class JIRA.Components.IssueTable.Views.EmptyResults
     *
     * Renders a message that tells the user there are no issues, with an optional link to create an issue
     *
     * @extends JIRA.Marionette.ItemView
     *
     * @param {object} options Options
     * @param {boolean} options.jiraHasIssues Whether there are issues created in this JIRA instance
     */
    JIRA.Components.IssueTable.Views.EmptyResults = JIRA.Marionette.ItemView.extend({
        template: JIRA.Templates.IssueNavTable.noResults,

        serializeData: function() {
            var message;
            var hint;
            var cssClass;
            var createIssuePerm = JIRA.Issues.UserParms.get().createIssue;

            if (!JIRA.Issues.LoginUtils.isLoggedIn()) {
                message = "No issues were found to match your search";
                hint = "Try \u003ca\u003elogging in\u003c/a\u003e to see more results";
                cssClass = "not-logged-in-message";
            } else if (this.options.jiraHasIssues === false) {
                message = "No issues have been created (yet)";
                hint = createIssuePerm ? "Be the first to \u003ca\u003ecreate an issue\u003c/a\u003e" : null;
                cssClass = "empty-results-message";
            } else {
                message = "No issues were found to match your search";
                hint = createIssuePerm ?
                    "Try modifying your search criteria or \u003ca\u003ecreating a new issue\u003c/a\u003e" :
                    "Try modifying your search criteria";
                cssClass = "no-results-message";
            }

            return {
                message: message,
                hint: hint,
                cssClass: cssClass
            };
        },

        onRender: function() {
            this.$el.addClass("empty-results");

            var $links = this.$('.no-results-hint a');
            if (!JIRA.Issues.LoginUtils.isLoggedIn()) {
                $links.attr('href', JIRA.Issues.LoginUtils.redirectUrlToCurrent()).addClass('login-link');
            } else {
                $links.addClass('create-issue').attr('href', AJS.contextPath() + "/secure/CreateIssue!default.jspa");
            }

            this.hidePending();
        },

        showPending: function() {
            this.$el.addClass('pending');
        },

        hidePending: function() {
            this.$el.removeClass("pending");
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/EndOfStableMessage.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueNavigator.Views.EndOfStableMessage");

    /**
     * @class JIRA.Components.IssueTable.Views.EndOfStableMessage
     *
     * Renders the end of stable message.
     *
     * @extends JIRA.Marionette.ItemView
     *
     * //TODO: This logic for deciding to show this message or not, can be moved to the controller.
     *
     * @param {object} options Options
     * @param {number} options.total Number of issues in this search
     * @param {number} options.displayableTotal Number of issues than can be displayed in a stable search
     * @param {number} options.pageNumber Number of the current page
     * @param {number} options.numberOfPages Total number of pages in the search results
     */
    JIRA.Components.IssueNavigator.Views.EndOfStableMessage = JIRA.Marionette.ItemView.extend({
        className: "end-of-stable-message",

        serializeData: function() {
            return this.options;
        },

        getTemplate: function() {
            return (this.shouldRender) ? JIRA.Templates.IssueNav.endOfStableMessage : jQuery.noop;
        },

        onBeforeRender: function() {
            this.shouldRender = this._hasMoreIssues() && this._onLastPage();
        },

        onRender: function() {
            if (this.shouldRender) {
                this.$el.addClass("visible");
            } else {
                this.$el.removeClass("visible");
            }
        },

        _hasMoreIssues: function() {
            return (this.options.total - this.options.displayableTotal) !== 0;
        },

        _onLastPage: function() {
            return this.options.pageNumber === this.options.numberOfPages;
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/IssueTable.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueTable.Views.IssueTable");

    /**
     * @class JIRA.Components.IssueTable.Views.IssueTable
     *
     * A table of issues.
     *
     * @extends JIRA.Marionette.ItemView
     */
    JIRA.Components.IssueTable.Views.IssueTable = JIRA.Marionette.ItemView.extend({

        /**
         * @event columnsChanged
         * When the order of the columns has changed
         */

        /**
         * @event highlightIssue
         * When the user wants to highlight an issue
         */

        /**
         * @event sort
         * When the user clicks on the column's header
         */

        events: {
            "blur .hidden-link": function(e) {
                jQuery(e.target).attr("tabIndex", -1);
            },
            "click tr.issuerow": function(e) {
                var row = jQuery(e.target).closest(".issuerow");
                var issueId = Number(row.attr("rel"));
                this.trigger("highlightIssue", issueId);
            },
            "click .sortable": function(e) {
                e.preventDefault();
                this.trigger("sort", jQuery(e.currentTarget).data("id"));
            }
        },

        inaccessibleIssueRowTemplate: JIRA.Templates.IssueNavTable.inaccessibleIssueRow,

        /**
         *
         * @param {object} options Configuration object
         * @param {jQuery} options.resultsTable Server-side rendered table with the results
         * @param {Object} [options.sortOptions] State of the current sort options
         * @param {string} options.sortOptions.fieldId ID of the field used for sorting the results
         * @param {string} options.sortOptions.order Direction used for the sorting ("DESC", "ASC")
         */
        initialize: function(options) {
            this.resultsTable = options.resultsTable;
            this.sortOptions = options.sortOptions || {};
        },

        /**
         * Render the table of issues.
         *
         * @returns {JIRA.Components.IssueTable.Views.IssueTable} <tt>this</tt>
         */
        render: function() {
            this.triggerMethod("before:render", this);
            var table = jQuery(this.resultsTable)[0];
            this.$el.empty().append(table);
            this.triggerMethod("render", this);
            return this;
        },

        onRender: function() {
            this._decorateTableHeaderWithSortOptions();
            this._addDraggable();
            this._removeEmptyTextNodes();
        },

        onClose: function() {
            this._removeDraggable();
        },

        /**
         * Adds header decorations for sorted column.
         */
        _decorateTableHeaderWithSortOptions: function() {
            var $sortableColumns = this.$el.find('.rowHeader .sortable');
            $sortableColumns.each(function() {
                this.onclick = null;
            });

            var sortOptions = this.sortOptions;
            if (sortOptions.fieldId) {

                // Locate the element which should be decorated
                var $sortEl = $sortableColumns.filter(function() {
                    return this.getAttribute("data-id") === sortOptions.fieldId;
                });

                // If the sorting element is not already decorated
                if ($sortEl.size() && !$sortEl.hasClass("descending") && !$sortEl.hasClass("ascending")) {

                    // Clean any header with sort-related classes
                    $sortableColumns
                        .removeClass("descending ascending active")
                        .addClass("colHeaderLink");

                    // Remove any sort icons
                    $sortableColumns.find(".issuetable-header-sort-icon").remove();

                    // Decorate the element as sorted
                    var direction = sortOptions.order === "DESC" ? "descending" : "ascending";
                    $sortEl.removeClass('colHeaderLink').addClass('active ' + direction);
                    $sortEl.append(JIRA.Templates.IssueNavTable.headerSortIcon({
                        order: sortOptions.order
                    }));
                }
            }
        },

        _addDraggable: function() {
            this.$("#issuetable").dragtable({
                maxMovingRows: 1,
                containment: 'body',
                axis: false,
                revert: false,
                clickDelay: 250,
                tolerance: "intersect",
                dragaccept: ":not(.headerrow-actions)",
                persistState: _.bind(this._saveColumns, this)
            });
        },

        _removeDraggable: function() {
            this.$("#issuetable").dragtable("destroy");
        },

        /**
         * Fix the issue table element so it displays correctly in IE9.
         *
         * Cells can become misaligned in IE9 if the table's markup contains whitespace.
         * Only affects IE9. IE10 and IE11 are okay.
         */
        _removeEmptyTextNodes: function() {
            this.$el.find("table, tbody, thead, tr").contents().filter(function() {
                return this.nodeType === 3; // Node.TEXT_NODE
            }).remove();
        },

        _saveColumns: function() {
            var cols = [];
            this.$("#issuetable").find('th').each(function() {
                var id = jQuery(this).data('id');
                if (_.isNotBlank(id)) {
                    cols.push(id);
                }
            });
            this.trigger("columnsChanged", cols);
        },

        /**
         * Highlight an issue and scroll it into view.
         *
         * Triggers a "highlightIssue" event, passing the issue's ID.
         *
         * @param {number} issueId The ID of the issue to highlight.
         * @param {boolean} [focus=true] Whether the highlighted issue should have the focus
         */
        highlightIssue: function(issueId, focus) {
            var newRow = this._getIssueRow(issueId);
            var oldRow = this.$(".focused");

            oldRow.removeClass("focused");
            newRow.addClass("focused");

            if (newRow.length && newRow.closest(document.body).length) {
                // Focus the row so you can tab through its links.
                if (focus !== false) {
                    newRow.find(".hidden-link").removeAttr("tabIndex").focus();
                }
                newRow.scrollIntoView({marginBottom: 50});
            }
        },

        /**
         * Gets the row element that represents a particular issue
         *
         * @param {number} issueId ID of the issue to look for
         * @param {jQuery} [container=this.$el] Table that contain the issue's row
         * @returns {jQuery} The row element
         */
        _getIssueRow: function(issueId, container) {
            container = container || this.$el;
            return container.find(".issuerow").filter(function() {
                return parseInt(this.getAttribute("rel"), 10) === issueId;
            });
        },

        /**
         * Replaces an inaccessible issue in the table with a message.
         *
         * @param {number} issueId ID of the issue to replace
         */
        markIssueAsInaccessible: function(issueId) {
            this._getIssueRow(issueId).replaceWith(this.inaccessibleIssueRowTemplate({
                columnCount: this.$el.find("thead > tr > th").length,
                issueID: issueId
            }));
        },

        /**
         * Updates an issue in the table with a new row and highlights it.
         *
         * @param {number} issueId ID of the issue to update
         * @param {jQuery} newTable Server rendered table with the new data
         */
        updateIssue: function(issueId, newTable) {
            var $newRow = this._getIssueRow(issueId, jQuery(newTable));
            this._getIssueRow(issueId).replaceWith($newRow);

            this.highlightIssue(issueId);
            this.trigger("issueRowUpdated", $newRow);
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/IssueTableLayout.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueTable.Views.IssueTableLayout");

    JIRA.Components.IssueTable.Views.IssueTableLayout = JIRA.Marionette.Layout.extend({
        template: JIRA.Templates.IssueNavTable.structure,

        regions: {
            pagination: {
                selector: ".pagination",
                regionType: JIRA.Marionette.ReplaceRegion
            },
            table: ".issue-table-container",
            resultsCountTop: {
                selector: ".results-count-top",
                regionType: JIRA.Marionette.ReplaceRegion
            },
            refreshResultsTop: {
                selector: ".refresh-table-top",
                regionType: JIRA.Marionette.ReplaceRegion
            },
            resultsCountBottom: {
                selector: ".results-count-bottom",
                regionType: JIRA.Marionette.ReplaceRegion
            },
            refreshResultsBottom: {
                selector: ".refresh-table-bottom",
                regionType: JIRA.Marionette.ReplaceRegion
            },
            endOfStableMessage: {
                selector: ".end-of-stable-message",
                regionType: JIRA.Marionette.ReplaceRegion
            }
        },

        onRender: function() {
            this.hidePending();
        },

        showPending: function() {
            this.$el.addClass('pending');
        },

        hidePending: function() {
            this.$el.removeClass("pending");
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/Pagination.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueNavigator.Views.Pagination");

    /**
     * @class JIRA.Components.IssueNavigator.Views.Pagination
     *
     * This view renders a set of pagination links
     *
     * @extends JIRA.Marionette.ItemView
     *
     * @param {object} options Options
     * @param {string} options.currentSearch Search that produced these search results
     * @param {string} [options.currentSearch.jql] JQL that produced these search results
     * @param {string} [options.currentSearch.filterId] ID of the filter used for this search
     * @param {number} options.pageSize Size of each page
     * @param {number} options.startIndex Index of first issue displayed in the table
     * @param {number} options.total Number of issues in this search
     */
    JIRA.Components.IssueNavigator.Views.Pagination = JIRA.Marionette.ItemView.extend({
        template: JIRA.Templates.IssueNavTable.pagination,

        events: {
            /**
             * @event goToPage
             * When the user clicks in a pagination link
             */
            "simpleClick a[data-start-index]": function(e) {
                e.preventDefault();
                var val = e.target.getAttribute("data-start-index");
                this.trigger("goToPage", parseInt(val, 10));
            }
        },

        serializeData: function() {
            return {
                startIndex: this.options.startIndex,
                pageSize: this.options.pageSize,
                searchQuery: this._getPagingUri(),
                displayableTotal: this.options.total
            };
        },

        onRender: function() {
            this.unwrapTemplate();
        },

        /**
         * Construct a URL for an issue table pagination link.
         *
         * @return {string} the URL.
         */
        _getPagingUri: function() {
            return JIRA.Issues.URLSerializer.getURLFromState({
                selectedIssueKey: null,
                jql: this.options.currentSearch.jql,
                filter: this.options.currentSearch.filterId
            });
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/RefreshResults.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueNavigator.Views.RefreshResults");

    /**
     * @class JIRA.Components.IssueNavigator.Views.RefreshResults
     *
     * This view renders a 'refresh' button.
     *
     * @extends JIRA.Marionette.ItemView
     */
    JIRA.Components.IssueNavigator.Views.RefreshResults = JIRA.Marionette.ItemView.extend({
        template: JIRA.Templates.IssueNav.refreshResults,
        triggers: {
            /**
             * @event refresh
             * When the user clicks the refresh button
             */
            "click": "refresh"
        },

        onRender: function() {
            this.unwrapTemplate();
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/ResultsCount.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueNavigator.Views.ResultsCount");

    /**
     * @class JIRA.Components.IssueNavigator.Views.ResultsCount
     *
     * This view renders the count of results in a search (e.g "1-20 of 42")
     *
     * @extends JIRA.Marionette.ItemView
     *
     * @param {object} options Options
     * @param {number} options.total Number of issues in this search
     * @param {number} options.startIndex Index of first issue displayed in the table
     * @param {number} options.pageSize Size of each page
     */
    JIRA.Components.IssueNavigator.Views.ResultsCount = JIRA.Marionette.ItemView.extend({
        template: JIRA.Templates.IssueNav.resultsCount,

        serializeData: function() {
            var total = this.options.total;
            var start = this.options.startIndex + 1;
            var end = this.options.startIndex + this.options.pageSize;
            return {
                start: start,
                end: Math.min(end, total),
                total: total
            };
        },

        onRender: function() {
            this.unwrapTemplate();
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/controllers/IssueTable.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Components.IssueTable.Controllers.IssueTable");

    /**
     * @class JIRA.Components.IssueTable.Controllers.IssueTable
     *
     * Controller for the IssueTable
     *
     * @extends JIRA.Marionette.Controller
     */
    JIRA.Components.IssueTable.Controllers.IssueTable = JIRA.Marionette.Controller.extend({
        /**
         * @event columnsChanged
         * When the order of the columns has changed
         */

        /**
         * @event goToPage
         * When the user wants to load another page by clicking on the pager
         */

        /**
         * @event highlightIssue
         * When an issue has been highlighted.
         */

        /**
         * @event issueRowUpdated
         * When a issue in the table has been updated with new information
         */

        /**
         * @event refresh
         * When the user wants to refresh the search by clicking on the 'refresh' icon
         */

        /**
         * @event renderTable
         * When the table with results and the associated internal views have been rendered
         */

        /**
         * @event sort
         * When the results has been sorted by clicking on a column's header
         */

        /**
         * @param {Object} options Initialization options
         * @param {Element} options.el Element where the table should be rendered
         */
        initialize: function (options) {
            this.$el = jQuery(options.el);
        },

        /**
         * @returns {JIRA.Components.IssueTable.Views.IssueTableLayout}
         */
        _createMainView: function () {
            return new JIRA.Components.IssueTable.Views.IssueTableLayout();
        },

        /**
         * @param {jQuery} resultsTable Server-side rendered table with the results
         * @param {Object} sortOptions State of the current sort options
         * @param {string} sortOptions.fieldId ID of the field used for sorting the results
         * @param {string} sortOptions.order Direction used for the sorting ("DESC", "ASC")
         * @returns {JIRA.Components.IssueTable.Views.IssueTable}
         */
        _createTableView: function (resultsTable, sortOptions) {
            var table = new JIRA.Components.IssueTable.Views.IssueTable({
                resultsTable: resultsTable,
                sortOptions: sortOptions
            });
            this.listenAndRethrow(table, "columnsChanged");
            this.listenAndRethrow(table, "highlightIssue");
            this.listenAndRethrow(table, "issueRowUpdated");
            this.listenAndRethrow(table, "sort");
            return table;
        },

        /**
         * @param {object} data Data to use in this view
         * @param {number} data.total Number of issues in this search
         * @param {number} data.startIndex Index of first issue displayed in the table
         * @param {number} data.pageSize Size of each page
         * @returns {JIRA.Components.IssueNavigator.Views.ResultsCount}
         * @private
         */
        _createResultsCount: function (data) {
            return new JIRA.Components.IssueNavigator.Views.ResultsCount(data);
        },

        /**
         * @param {object} data Data to use in this view
         * @param {number} data.total Number of issues in this search
         * @param {number} data.startIndex Index of first issue displayed in the table
         * @param {number} data.pageSize Size of each page
         * @param {string} data.currentSearch JQL that produced this search results
         * @returns {JIRA.Components.IssueNavigator.Views.Pagination}
         * @private
         */
        _createPagination: function (data) {
            var pagination = new JIRA.Components.IssueNavigator.Views.Pagination(data);
            this.listenAndRethrow(pagination, "goToPage");
            return pagination;
        },

        /**
         * @returns {JIRA.Components.IssueNavigator.Views.RefreshResults}
         */
        _createRefreshResults: function () {
            var refreshResults = new JIRA.Components.IssueNavigator.Views.RefreshResults();
            this.listenAndRethrow(refreshResults, "refresh");
            return refreshResults;
        },

        /**
         * @param {object} data Data to use in this view
         * @param {number} data.total Number of issues in this search
         * @param {number} data.displayableTotal Number of issues than can be displayed in a stable search
         * @param {number} data.pageNumber Number of the current page
         * @param {number} data.numberOfPages Total number of pages in the search results
         * @returns {JIRA.Components.IssueNavigator.Views.EndOfStableMessage}
         */
        _createEndOfStableMessage: function (data) {
            return new JIRA.Components.IssueNavigator.Views.EndOfStableMessage(data);
        },

        /**
         * @param {object} data Data to use in this view
         * @param {boolean} data.jiraHasIssues Whether there are issues created in this JIRA instance
         * @returns {JIRA.Components.IssueTable.Views.EmptyResults}
         */
        _createEmptyResultsView: function (data) {
            return new JIRA.Components.IssueTable.Views.EmptyResults(data);
        },

        _layoutIsRendered: function () {
            return this.view && this.view instanceof JIRA.Components.IssueTable.Views.IssueTableLayout;
        },

        close: function () {
            if (this.view) {
                this.view.close();
                delete this.view;
            }
        },

        /**
         * @param {object} options Options
         * @param {jQuery} options.table Server-side rendered table with the results
         * @param {Object} options.sortOptions State of the current sort options
         * @param {string} options.sortOptions.fieldId ID of the field used for sorting the results
         * @param {string} options.sortOptions.order Direction used for the sorting ("DESC", "ASC")
         * @param {number} options.totalIssues Number of issues in this search
         * @param {number} options.displayableTotal Number of issues than can be displayed in a stable search
         * @param {number} options.pageNumber Number of the current page
         * @param {number} options.numberOfPages Total number of pages in the search results
         * @param {number} options.startIndex Index of first issue displayed in the table
         * @param {number} options.pageSize Size of each page
         * @param {string} options.currentSearch JQL that produced this search results
         * @param {boolean} options.jiraHasIssues Whether there are issues created in this JIRA instance
         * @param {boolean} options.hasIssues Whether there search result has issues
         */
        show: function (options) {
            if (options.hasIssues) {
                this._showTable(options);
            } else {
                this._showEmptyResults(options);
            }
        },

        /**
         * @param {object} options Options
         * @param {boolean} options.jiraHasIssues Whether there are issues created in this JIRA instance
         */
        showErrorMessage: function (options) {
            this._showEmptyResults(options);
        },

        /**
         * Puts the view in the pending state (i.e. dims the table). This method also temporarily disables
         * the column reordering feature.
         */
        showPending: function () {
            if (this.view) {
                this.view.showPending();
                if (this._layoutIsRendered()) {
                    this.view.table.currentView._removeDraggable();
                }
            }
        },

        /**
         * @param {object} options Options
         * @param {jQuery} options.table Server-side rendered table with the results
         * @param {Object} options.sortOptions State of the current sort options
         * @param {string} options.sortOptions.fieldId ID of the field used for sorting the results
         * @param {string} options.sortOptions.order Direction used for the sorting ("DESC", "ASC")
         * @param {number} options.totalIssues Number of issues in this search
         * @param {number} options.totalDisplayableIssues Number of issues than can be displayed in a stable search
         * @param {number} options.pageNumber Number of the current page
         * @param {number} options.numberOfPages Total number of pages in the search results
         * @param {number} options.startIndex Index of first issue displayed in the table
         * @param {number} options.pageSize Size of each page
         * @param {string} options.currentSearch JQL that produced this search results
         */
        _showTable: function (options) {
            options = options || {};

            this.close();
            this.view = this._createMainView();
            var table = this._createTableView(options.table, options.sortOptions);
            var resultsCountTop = this._createResultsCount({
                total: options.totalIssues,
                startIndex: options.startIndex,
                pageSize: options.pageSize
            });
            var resultsCountBottom = this._createResultsCount({
                total: options.totalIssues,
                startIndex: options.startIndex,
                pageSize: options.pageSize
            });
            var pagination = this._createPagination({
                startIndex: options.startIndex,
                pageSize: options.pageSize,
                total: options.totalIssues,
                currentSearch: options.currentSearch
            });
            var endOfStableMessage = this._createEndOfStableMessage({
                total: options.totalIssues,
                displayableTotal: options.totalDisplayableIssues,
                pageNumber: options.pageNumber,
                numberOfPages: options.numberOfPages
            });

            this.listenTo(this.view, {
                "render": function () {
                    this.view.table.show(table);
                    this.view.resultsCountTop.show(resultsCountTop);
                    this.view.resultsCountBottom.show(resultsCountBottom);
                    this.view.pagination.show(pagination);
                    this.view.refreshResultsTop.show(this._createRefreshResults());
                    this.view.refreshResultsBottom.show(this._createRefreshResults());
                    this.view.endOfStableMessage.show(endOfStableMessage);
                }
            });

            this.view.render();
            this.$el.empty().append(this.view.$el);
            this.trigger("renderTable", this.$el);
        },

        /**
         * @param {object} options Options
         * @param {boolean} options.jiraHasIssues Whether there are issues created in this JIRA instance
         */
        _showEmptyResults: function (options) {
            this.close();
            this.view = this._createEmptyResultsView(options);
            this.view.render();
            this.$el.empty().append(this.view.$el);
            this.trigger("renderEmpty", this.$el);
        },

        /**
         * Highlight an issue in the table.
         *
         * @param {number} issueId The ID of the issue to highlight.
         * @param {boolean} [focus=true] Whether the highlighted issue should have the focus
         */
        highlightIssue: function (issueId, focus) {
            if (this._layoutIsRendered()) {
                this.view.table.currentView.highlightIssue(issueId, focus);
            }
        },

        /**
         * Marks an issue as inaccessible
         *
         * @param {number} issueId ID of the issue to mark
         */
        markIssueAsInaccessible: function (issueId) {
            if (this._layoutIsRendered()) {
                this.view.table.currentView.markIssueAsInaccessible(issueId);
            }
        },

        /**
         * Updates an issue in the table with a new row
         *
         * @param {number} issueId ID of the issue to update
         * @param {jQuery} newTable Server rendered table with the new data
         */
        updateIssue: function (issueId, newTable) {
            if (this._layoutIsRendered()) {
                this.view.table.currentView.updateIssue(issueId, newTable);
            }
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/search/Search.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.SearchService");

    /**
     * @class JIRA.Components.SearchService
     *
     * This service encapsulates all the search related stuff
     *
     * @extends JIRA.Marionette.Controller
     */
    JIRA.Components.SearchService = JIRA.Marionette.Controller.extend({
        /**
         * @event issueUpdated
         * When an issue has been updated
         */

        /**
         * @event search
         * When an new search has been done
         */

        /**
         * @event before:search
         * Before doing a new search
         */

        /**
         * @event error:search
         * When a new search has been done but it thrown an error
         */

        /**
         * @event issueHighlighted
         * When an issue has been marked as highlighted in the internal model
         */

        /**
         * @event selectedIssueChanged
         * When an issue has been marked as selected in the internal model
         */

        /**
         * @param {Object} options
         * @param {JIRA.Issues.SearchModule} options.searchModule
         * @param {JIRA.Issues.SearchResults} options.searchResults
         * @param {JIRA.Issues.ColumnConfigModel} options.columnConfig
         */
        initialize: function(options) {
            this.searchModule = options.searchModule;
            this.searchResults = options.searchResults;
            this.columnConfig = options.columnConfig;

            _.bindAll(this, "_onIssueUpdated", "_onHighlightedIssueChange", "_onSelectedIssueChange", "_onBeforeSearch");

            this.listenTo(this.searchResults, "change:resultsId change:startIndex stableUpdate issueDeleted", function() {
                this._doSearch();
            });

            // These are *not* regular Backbone events, we can't use listenTo.
            this.searchResults.onIssueUpdated(this._onIssueUpdated);
            this.searchResults.onHighlightedIssueChange(this._onHighlightedIssueChange);
            this.searchResults.onSelectedIssueChange(this._onSelectedIssueChange);

            this.searchModule.onBeforeSearch(this._onBeforeSearch);
        },

        _onSelectedIssueChange: function(issue) {
            this.trigger("selectedIssueChanged", issue, this.searchResults.getHighlightedIssue());
        },

        _onIssueUpdated: function(issueId, entity, reason) {
            this.trigger("issueUpdated", issueId, entity, reason);
        },

        _onHighlightedIssueChange: function(issue) {
            this.trigger("issueHighlighted", issue.getId());
        },

        _onBeforeSearch: function() {
            this.trigger("before:search");
        },

        close: function() {
            this.stopListening();
            this.searchResults.offIssueUpdated(this._onIssueUpdated);
            this.searchResults.offHighlightedIssueChange(this._onHighlightedIssueChange);
        },

        /**
         * Asks the SearchResults object to do a new search with the parameters already contained
         * in the SearchModule
         * @private
         */
        _doSearch: function() {
            this.searchInProgress = true;

            var filterId = this.searchModule.getFilterId();
            var isSystemFilter = filterId < 0;
            filterId = (isSystemFilter || _.isNull(filterId)) ? undefined : filterId;

            var LatestSearchStore = require("jira/components/search/latestStorage");
            var search = {
                filter: filterId,
                jql: this.searchModule.getEffectiveJql()
            };
            LatestSearchStore.save(search);

            this.searchResults.getResultsForPage({
                jql: this.searchModule.getEffectiveJql(),
                filterId: filterId
            })
                .always(_.bind(function() {
                    this.searchInProgress = false;
                }, this))
                .done(_.bind(function(table) {
                    if (!this.searchResults.hasHighlightedIssue()) {
                        this.searchResults.highlightFirstInPage();
                    }
                    this.trigger("search", table, this.searchResults);
                }, this))
                .fail(_.bind(function() {
                    this.trigger("error:search");
                }, this));
        },

        /**
         * Loads a page of the current search results. This code expects the issue position,
         * not the page number. Example: using a pageSize of 25, passing startIndex=50 will load the
         * issues #50 to #74.
         *
         * This method will do nothing if a search is already in progress
         *
         * @param {number} startIndex Position of the issue in the page
         */
        goToPage: function(startIndex) {
            if (this.searchInProgress) return;
            this._onBeforeSearch();
            this.searchResults.goToPage(startIndex);
        },

        /**
         * Sorts the current search results by a field.
         *
         * This method will do nothing if a search is already in progress
         *
         * @param {string} fieldId ID of the field to sort by
         */
        sort: function(fieldId) {
            if (this.searchInProgress) return;

            var allSorts = this.searchModule.getResults().getColumnSortJql();
            var sortJql = allSorts[fieldId];
            if (sortJql) {
                this.searchModule.doSort(sortJql);
            }
        },

        /**
         * Re-runs the current search.
         *
         * This method will do nothing if a search is already in progress
         */
        runCurrentSearch: function() {
            if (this.searchInProgress) return;

            if (JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.issueTableRefresh");
                this.searchModule.refresh();
            }
        },

        /**
         * This method updates the existing set of results (aka Stable Search). It does not re-run the search again, so the
         * list of Issues will remain the same.
         *
         * This method will do nothing if a search is already in progress.
         */
        updateExitingResults: function() {
            if (this.searchInProgress) return;

            if (JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.issueTableRefresh");
                this._doSearch();
            }
        },

        highlightIssue: function(issueId) {
            this.searchResults.highlightIssueById(issueId);
        },

        getPager: function() {
            return this.searchResults.getPager();
        },

        selectNextIssue: function() {
            this.searchResults.highlightNextIssue();
            if (this.searchResults.hasSelectedIssue()) {
                require('jira/issues/navigator/metrics').notifyIssueView();
                this.searchResults.selectNextIssue();
            }
        },

        selectPreviousIssue: function () {
            this.searchResults.highlightPrevIssue();
            if (this.searchResults.hasSelectedIssue()) {
                require('jira/issues/navigator/metrics').notifyIssueView();
                this.searchResults.selectPrevIssue();
            }
        },

        unselectIssue: function() {
            this.searchResults.unselectIssue();
        },

        hasSelectedIssue: function() {
            return this.searchResults.hasSelectedIssue();
        },

        getHighlightedIssue: function() {
            return this.searchResults.getHighlightedIssue().id;
        }

    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-searchheader', location = 'content/templates/issuenav-searchheader.soy' */
// This file was automatically generated from issuenav-searchheader.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavSearchHeader.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavSearchHeader == 'undefined') { JIRA.Templates.IssueNavSearchHeader = {}; }


JIRA.Templates.IssueNavSearchHeader.layoutSwitcher = function(opt_data, opt_ignored) {
  var output = '<div class="aui-buttons"><button id="layout-switcher-button" class="aui-button aui-button-light drop-arrow js-default-dropdown" type="button"><span class="aui-icon aui-icon-small ' + soy.$$escapeHtmlAttribute(opt_data.activeLayout.iconClass) + '"></span></button><div class="aui-list hidden"><h5>' + soy.$$escapeHtml("Views") + '</h5><ul class="aui-list-section aui-first aui-last">';
  var layoutList8 = opt_data.layouts;
  var layoutListLen8 = layoutList8.length;
  for (var layoutIndex8 = 0; layoutIndex8 < layoutListLen8; layoutIndex8++) {
    var layoutData8 = layoutList8[layoutIndex8];
    output += '<li class="aui-list-item layout-switcher-item"><a href="#" class="aui-list-item-link" data-layout-key="' + soy.$$escapeHtmlAttribute(layoutData8.id) + '"><span class="aui-icon aui-icon-small ' + ((opt_data.activeLayout.id == layoutData8.id) ? 'aui-iconfont-success' : '') + '"></span>' + soy.$$escapeHtml(layoutData8.label) + '</a>';
  }
  output += '</ul></div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavSearchHeader.layoutSwitcher.soyTemplateName = 'JIRA.Templates.IssueNavSearchHeader.layoutSwitcher';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-searchheader', location = 'content/js/search/searchheader/LayoutSwitcherView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.LayoutSwitcherView");

    /**
     * The layout switcher control.
     */
    JIRA.Issues.LayoutSwitcherView = JIRA.Issues.BaseView.extend({
        template: JIRA.Templates.IssueNavSearchHeader.layoutSwitcher,

        /**
         * @param {object} options
         * @param {JIRA.Issues.SearchPageModule} options.searchPageModule
         */
        initialize: function(options) {
            _.bindAll(this, "_onLayoutSwitchClick");

            this.searchPageModule = options.searchPageModule;
            this.searchPageModule.on("change:currentLayout", this.render, this);
        },

        /**
         * @return {JIRA.Issues.LayoutSwitcherView} <tt>this</tt>
         */
        render: function() {
            this.$el.html(this.template({
                layouts: this.searchPageModule.getSortedLayouts(),
                activeLayout: this.searchPageModule.getActiveLayout()
            }));

            this._addLayoutSwitcherTooltip();

            // We can't use delegate events as the dropdown is appended to the body.
            this.$el.find(".aui-list-item-link").click(this._onLayoutSwitchClick);
            JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [this.$el, JIRA.CONTENT_ADDED_REASON.layoutSwitcherReady]);
            return this;
        },

        /**
         * @returns {JIRA.Issues.LayoutSwitcherView} <tt>this</tt>
         */
        enableLayoutSwitcher: function() {
            this.$el.find("#layout-switcher-button").removeClass("disabled").removeAttr('disabled');
            return this;
        },

        /**
         * @returns {JIRA.Issues.LayoutSwitcherView} <tt>this</tt>
         */
        disableLayoutSwitcher: function() {
            this.$el.find("#layout-switcher-button").addClass("disabled").attr('disabled', '');
            return this;
        },

        createHelptipForSwitchingToDetailView: function(weight) {
            var tip;
            if (this._shouldShowIntro() && this.$el.is(":visible")) {
                tip = new AJS.HelpTip({
                    id: "split-view-intro",
                    title: "Choose how you view issues",
                    url: AJS.Meta.get('issue-search-help-url'),
                    bodyHtml: "Switch between the details and list views to suit your preference.",
                    anchor: ".view-selector button",
                    isSequence: true,
                    weight: weight
                });
            }
            return tip;
        },

        _shouldShowIntro: function() {
            return this.searchPageModule.search.getResults().hasIssues();
        },

        /**
         * Adds a tooltip to the layout switcher button
         * @private
         */
        _addLayoutSwitcherTooltip: function() {
            function getTooltipMessage() {
                // If there is no shortcut for this action, just display the regular text. (i.e. without the 'Type X' part)
                var shortcut = AJS.KeyboardShortcut.getKeyboardShortcutKeys('switch.search.layouts');
                if (shortcut) {
                    return AJS.format("Change view (Type \'\'{0}\'\')", AJS.KeyboardShortcut.getKeyboardShortcutKeys('switch.search.layouts'));
                } else {
                    return "Change view";
                }
            }

            new JIRA.Issues.Tipsy({
                el: this.$el.find("#layout-switcher-button"),
                showCondition: ":not(.active)",
                tipsy: {
                    title: getTooltipMessage,
                    gravity: 'ne'
                }
            });
        },

        /**
         * Tell the <tt>SearchPageModule</tt> to change layout.
         * <p/>
         * Called when a layout button is clicked.
         *
         * @param {object} e The click event.
         * @param {object} [options] Options used in tests.
         *
         * @private
         */
        _onLayoutSwitchClick: function(e, options) {
            if (JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                // HACK: Hover intent has a strange bug that when we click the layout switcher it triggers a mouseleave event on the filters panel
                // To get around this, we disable it whilst we are transitioning to new layout.
                var layoutKey = AJS.$(e.target).closest("[data-layout-key]").data("layout-key");
                e.preventDefault();

                if (layoutKey === 'split-view') {
                    require('jira/issues/views/details/metrics').start();
                } else if (layoutKey === 'list-view') {
                    require('jira/issues/navigator/metrics').notifyIssueNavList();
                }

                this.searchPageModule.changeLayout(layoutKey, options);
            }
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-searchheader', location = 'content/js/search/searchheader/SearchHeaderModule.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.SearchHeaderModule");

    /**
     * Interface to the search header
     */
    JIRA.Issues.SearchHeaderModule = JIRA.Issues.BaseEvented.extend({

        initialize: function(options) {
            this._searchPageModule = options.searchPageModule;
        },

        registerSearch: function(search) {
            this._search = search;
        },

        createToolsView: function($toolsEl) {
            new JIRA.Issues.IssueTableHeaderOperationsView({
                el: $toolsEl,
                search: this._search,
                searchPageModule: this._searchPageModule
            });
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/Filters.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters");

    /**
     * @class JIRA.Components.Filters
     *
     * This class is the main entry point for the Filters component.
     *
     * @extends JIRA.Marionette.Controller
     */
    JIRA.Components.Filters = JIRA.Marionette.Controller.extend({

        initialize: function(options) {
            this._initializeDialogController();
            this.searchPageModule = options.searchPageModule;

            this._initializeCollections(options);
            this._initializeSystemFiltersController();
            this._initializeFavouriteFiltersController();
            this._initializeFilterHeaderController();
        },

        _initializeCollections: function(options) {
            this.systemFiltersCollection = new JIRA.Components.Filters.Collections.SystemFilters(options.systemFilters);

            this.favouriteFiltersCollection = new JIRA.Components.Filters.Collections.FavouriteFilters([]);
            this.listenTo(this.favouriteFiltersCollection, {
                "change:favourite": function (filterModel, isFavourite) {
                    if (!isFavourite) {
                        this.favouriteFiltersCollection.remove(filterModel);
                    }
                },
                "remove": function(filterModel) {
                    this.trigger('filterUnfavourited', { filterId: filterModel.getId() });
                }
            });
        },

        _initializeDialogController: function() {
            this.dialogController = new JIRA.Components.Filters.Controllers.Dialog();

            this.listenTo(this.dialogController, "delete:success", function(filterModel) {
                this.favouriteFiltersCollection.remove(filterModel);
                // trigger a specific event when the filter is deleted, as this should update the search results page
                this.trigger('filterRemoved', { filterId: filterModel.getId() });

                JIRA.Messages.showSuccessMsg(
                    AJS.format("The filter \u003cstrong\u003e{0}\u003c/strong\u003e has been deleted.", AJS.escapeHtml(filterModel.getName())),
                    JIRA.Issues.getDefaultMessageOptions()
                );

                JIRA.trace("jira.filter.saved");
            });

            this.listenTo(this.dialogController, "delete:error", function() {
                JIRA.trace("jira.filter.saved");
            });

            this.listenTo(this.dialogController, "rename:success", function(filterModel) {
                JIRA.Messages.showSuccessMsg(
                    AJS.format("The filter \u003cstrong\u003e{0}\u003c/strong\u003e has been renamed.", AJS.escapeHtml(filterModel.getName())),
                    JIRA.Issues.getDefaultMessageOptions()
                );

                JIRA.trace("jira.filter.saved");
            });

            this.listenTo(this.dialogController, "rename:error", function() {
                JIRA.trace("jira.filter.saved");
            });

            this.listenTo(this.dialogController, "copy:success", function(newFilterModel) {
                this.trigger("newFilter", newFilterModel);
                this._addFavouriteFilter(newFilterModel);
                JIRA.trace("jira.filter.saved");
            }, this);

            this.listenTo(this.dialogController, "copy:error", function() {
                JIRA.trace("jira.filter.saved");
            });

            this.listenTo(this.dialogController, "saveas:success", function(newFilterModel) {
                this.trigger("newFilter", newFilterModel);
                this._addFavouriteFilter(newFilterModel);
                JIRA.trace("jira.filter.saved");
            }, this);

            this.listenTo(this.dialogController, "saveas:error", function() {
                JIRA.trace("jira.filter.saved");
            });

        },

        _initializeSystemFiltersController: function() {
            this.systemFiltersController = new JIRA.Components.Filters.Controllers.List({
                collection: this.systemFiltersCollection,
                className: "system-filters",
                errorMessage: "Failed to retrieve system filters from server.",
                loadingMessage: "Loading system filters...",
                emptyMessage: "There are no system filters.",
                loginMessage: AJS.format("You must be {0}logged in{1} to view system filters.", '<a class="login-link" href="' + JIRA.Issues.LoginUtils.redirectUrlToCurrent() + '">', '</a>')
            });

            this.systemFiltersController.on("selectFilter", function (filterModel) {
                this.headerController.closeDetails();
                this.trigger("filterSelected", filterModel.id);
            }, this);
        },

        _initializeFavouriteFiltersController: function() {
            this.favouriteFiltersController = new JIRA.Components.Filters.Controllers.ListWithActions({
                collection: this.favouriteFiltersCollection,
                className: "favourite-filters",
                title: "Favourite Filters",
                errorMessage: "Failed to retrieve favourite filters from server.",
                loadingMessage: "Loading favourite filters...",
                emptyMessage: "You don\'t have any favourite filters.",
                loginMessage: AJS.format("You must be {0}logged in{1} to view favourite filters.", '<a class="login-link" href="' + JIRA.Issues.LoginUtils.redirectUrlToCurrent() + '">', '</a>')
            });
            this.favouriteFiltersController.on("selectFilter", function(filterModel) {
                this.headerController.closeDetails();
                this.trigger("filterSelected", filterModel.id);
            }, this);
            this.favouriteFiltersController.on("deleteFilter", function(filterModel) {
                this.showDeleteDialog(filterModel.id);
            }, this);
            this.favouriteFiltersController.on("renameFilter", function(filterModel) {
                this.showRenameDialog(filterModel.id);
            }, this);
            this.favouriteFiltersController.on("copyFilter", function(filterModel) {
                this.showCopyDialog(filterModel.id);
            }, this);
            this.favouriteFiltersController.on("unfavouriteFilter", function(filterModel) {
                filterModel.saveFavourite(false);
            }, this);
            this.favouriteFiltersController.on("list:render", function() {
                this.trigger("list:render");
                JIRA.trace("jira.filter.favourites.render");
            }, this);
        },

        _initializeFilterHeaderController: function() {
            this.headerController = new JIRA.Components.Filters.Controllers.Header();

            this.listenTo(this.headerController, "saveAs", function(filterModel) {
                this.showSaveAsDialog(filterModel);
            });

            this.listenTo(this.headerController, "save", function(filterModel) {
                var filterName = AJS.escapeHtml(filterModel.getName());

                filterModel.saveFilter(this.searchPageModule.getEffectiveJql())
                    .done(_.bind(function() {
                        JIRA.Messages.showSuccessMsg(
                            AJS.format("The filter \u003cstrong\u003e{0}\u003c/strong\u003e has been successfully saved.", filterName),
                            JIRA.Issues.getDefaultMessageOptions()
                        );

                        this.trigger("savedFilter", filterModel);
                    }, this))
                    .fail(function() {
                        JIRA.Messages.showErrorMsg(
                            AJS.format("The filter \u003cstrong\u003e{0}\u003c/strong\u003e could not be saved.", filterName),
                            JIRA.Issues.getDefaultMessageOptions()
                        );
                    });
            });

            this.listenTo(this.headerController, "discard", function() {
                this.trigger("filterDiscarded");
            });

            this.listenTo(this.headerController, "favourite", function(filterModel) {
                filterModel = this._addFavouriteFilter(filterModel);
                this.highlightFilter(filterModel);
                this.trigger("fitlerFavourited", filterModel);
            });
        },

        _addFavouriteFilter: function(filterModel) {
            var isFavourite = !!filterModel.getFavourite();
            var isInFavouriteCollection = !!this.favouriteFiltersCollection.get(filterModel.getId());

            if ( isFavourite && !isInFavouriteCollection) {
                this.favouriteFiltersCollection.add(filterModel);
            }

            return this.favouriteFiltersCollection.get(filterModel.getId());
        },

        getFilterByIdFromExistingCollections: function(filterId) {
            return this.systemFiltersCollection.get(filterId) || this.favouriteFiltersCollection.get(filterId);
        },
        
        getFilterById: function (filterId) {
            var filter = this.getFilterByIdFromExistingCollections(filterId);
            var deferred = new jQuery.Deferred();

            if (filter) {
                deferred.resolve(filter);
            } else {
                var model = new JIRA.Components.Filters.Models.Filter({ id: filterId });
                model.fetch({
                    success: _.bind(function() {
                        if (model.getFavourite()) {
                            this.favouriteFiltersCollection.add(model, {merge: true});

                            // We need to return the model in the collection, because 'add' will only merge the attributes,
                            // not the 'cid'. The 'cid' is used to identify the views associated with this model.
                            deferred.resolve(this.favouriteFiltersCollection.get(model.id));
                        } else if (model.getIsSystem()) {
                            this.systemFiltersCollection.add(model, {merge: true});
                            deferred.resolve(this.systemFiltersCollection.get(model.id));
                        } else {
                            deferred.resolve(model);
                        }
                    }, this),
                    error: function() {
                        model.setIsValid(false);
                        deferred.reject.apply(this, arguments);
                    }
                });
            }

            return deferred.promise();
        },

        showDeleteDialog: function(filterId) {
            this.getFilterById(filterId).done(_.bind(function(filterModel) {
                this.dialogController.showDeleteDialog(filterModel);
            }, this));
        },

        showRenameDialog: function(filterId) {
            this.getFilterById(filterId).done(_.bind(function(filterModel) {
                this.dialogController.showRenameDialog(filterModel);
            }, this));
        },

        showCopyDialog: function(filterId) {
            this.getFilterById(filterId).done(_.bind(function(filterModel) {
                this.dialogController.showCopyDialog(filterModel);
            }, this));
        },

        showSaveAsDialog: function(filterModel) {
            this.searchPageModule.getJqlDeferred()
                .done(_.bind(function(jql) {
                    this.dialogController.showSaveAsDialog(filterModel, jql);
                }, this));
        },

        showSystemFilters: function(el) {
            this.systemFiltersController.show(el);
        },

        showFavouriteFilters: function(el){
            this.favouriteFiltersController.show(el);
        },

        showFilterHeader: function(options) {
            this.headerController.show({
                el: options.el,
                model: options.model,
                isEdited: options.isEdited,
                isDirty: options.isDirty
            });
        },

        updateFilterHeader: function(options) {
            this.headerController.update({
                model: options.model,
                isEdited: options.isEdited || false,
                isDirty: options.isDirty || false
            });
        },

        highlightFilter: function(filterModel) {
            this.systemFiltersController.highlightFilter(filterModel);
            this.favouriteFiltersController.highlightFilter(filterModel);
        },

        markFilterHeaderAsInvalid: function() {
            this.headerController.markAsInvalid();
        },

        fetchSystemFilters: function() {
            return this.systemFiltersCollection.fetch();
        },

        fetchFavouriteFilters: function() {
            return this.favouriteFiltersCollection.fetch({reset: true});
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/entities/Filter.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Models.Filter");

    /**
     * @class JIRA.Components.Filters.Models.Filter
     *
     * Represents a saved (normally favourite) filter, also known as a "Saved Search".
     *
     * @extends JIRA.Issues.Brace.Model
     */
    JIRA.Components.Filters.Models.Filter = JIRA.Issues.Brace.Model.extend({

        namedAttributes: [
            "id",
            "name",
            "description",
            "jql",
            "favourite",
            "isSystem",
            "sharePermissions",
            "subscriptions",
            "ownerUserName",
            "ownerDisplayName",
            "avatarUrl",
            "requiresLogin",
            "isValid"
        ],

        defaults: {
            isSystem: false,
            isValid: true
        },

        urlRoot: AJS.contextPath() + "/rest/api/2/filter/",

        getOwner: function () {
            return this.getOwnerDisplayName() || this.getOwnerUserName();
        },

        isFavouriteFilter: function () {
            return !this.getIsSystem() && !!this.getFavourite();
        },

        url: function() {
            return this.urlRoot + encodeURIComponent(this.id) + "?expand=subscriptions[-5:]";
        },

        isMyFilter: function () {
            return !this.getIsSystem() && this.getOwnerUserName() === JIRA.Issues.LoginUtils.loggedInUserName();
        },

        parse: function(response) {
            // Reverse the subscriptions so they're sorted newest to oldest.
            if (response.subscriptions && response.subscriptions.items) {
                response.subscriptions.items.reverse();
            }

            return {
                id: response.id,
                name: response.name,
                description: response.description,
                jql: response.jql,
                isSystem: response.isSystem,
                favourite: response.favourite,
                sharePermissions: response.sharePermissions || [],
                subscriptions: response.subscriptions,
                ownerUserName: response.owner && response.owner.name,
                ownerDisplayName: response.owner && response.owner.displayName,
                avatarUrl: response.owner && response.owner.avatarUrls['48x48'],
                requiresLogin: response.requiresLogin
            };
        },

        /**
         * Not all the subscriptions are retrieved from the server. This function
         * returns the number of un-retrieved subscriptions for the filter.
         */
        getNumberOfAdditionalSubscriptions: function() {
            var subs = this.getSubscriptions();
            return subs.size > subs.items.length ? subs.size - subs.items.length : 0;
        },

        saveFavourite: function(isFavourite) {
            var instance = this;
            var prevState = this.getFavourite();

            // Optimistically set favourite status
            this.setFavourite(isFavourite);

            // Abort previous pending request
            if (this.pendingRequest) {
                this.pendingRequest.abort();
            }

            this.pendingRequest = JIRA.SmartAjax.makeRequest({
                // This is v1 of the REST API. TODO: add the ability to set favourite to REST API v2
                url: AJS.contextPath() + '/rest/api/1.0/filters/' + encodeURIComponent(this.getId()) + '/favourite',
                type: isFavourite ? 'PUT' : 'DELETE'
            }).done(function(data) {
                var faveState = AJS.$(data).text().match(/favourite state: (\w+)/)[1] === 'true';
                delete instance.pendingRequest;
                instance.setFavourite(faveState);
            }).fail(function() {
                instance.setFavourite(prevState);
            });

            return this.pendingRequest;
        },

        saveFilter: function(newJql) {

            // Abort previous pending request
            if (this.pendingRequest) {
                this.pendingRequest.abort();
            }

            var json = this.toJSON();
            var data = {
                id: json.id,
                name: json.name,
                jql: newJql,
                favourite: json.favourite
            };

            var instance = this;
            this.pendingRequest = JIRA.SmartAjax.makeRequest({
                url: this.url(),
                type: 'PUT',
                contentType: "application/json",
                data: JSON.stringify(data)
            }).done(function(filterData) {
                instance.set(instance.parse(filterData));
            }).then(function() {
                delete instance.pendingRequest;
                JIRA.trace("jira.filter.saved");
            });

            return this.pendingRequest;
        },

        toJSON: function() {
            var json = JIRA.Issues.BaseModel.prototype.toJSON.apply(this);
            _.extend(json, {
                requiresLoginForUser: this._requiresLoginForUser(this.getRequiresLogin()),
                navUrl: this._constructNavUrl(this.getId(), this.getRequiresLogin())
            });
            return json;
        },

        _requiresLoginForUser: function(requiresLogin) {
            return !JIRA.Issues.LoginUtils.isLoggedIn() && requiresLogin;
        },

        _constructNavUrl: function(filterId, requiresLogin) {
            var navUrl = '/issues/?filter=' + filterId;
            // Set url to redirect to login if user is not logged in
            if (this._requiresLoginForUser(requiresLogin)) {
                return JIRA.Issues.LoginUtils.redirectUrl(navUrl);
            }
            else {
                return AJS.contextPath() + navUrl;
            }
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/entities/Filters.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Collections.Filters");

    /**
     * @class JIRA.Components.Filters.Collections.Filters
     *
     * A collection of FilterModel objects.
     *
     * @extends Backbone.Collection
     */
    JIRA.Components.Filters.Collections.Filters = JIRA.Issues.Brace.Collection.extend({

        model: JIRA.Components.Filters.Models.Filter,

        fetch: function () {
            var promise = JIRA.Issues.Brace.Collection.prototype.fetch.apply(this, arguments);

            promise.done(_.bind(function () {
                this.fetchState = "fetched";
                this.trigger("change:fetchState", this.fetchState);
            }, this));

            promise.fail(_.bind(function () {
                this.fetchState = "error";
                this.trigger("change:fetchState", this.fetchState);
            }, this));

            return promise;
        },

        initialize: function(models, options) {
            options = options || {};
            this.fetchState = options.fetchState;
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/entities/SystemFilters.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Collections.SystemFilters");

    /**
     * @class JIRA.Components.Filters.Collections.SystemFilters
     *
     * A collection of FilterModel objects.
     *
     * @extends JIRA.Components.Filters.Collections.Filters
     */
    JIRA.Components.Filters.Collections.SystemFilters = JIRA.Components.Filters.Collections.Filters.extend({

        _setFetchState: function(state) {
            var isNewSate = state !== this.fetchState;

            this.fetchState = state;
            if (isNewSate) {
                this.trigger("change:fetchState", this.fetchState);
            }
        },

        url: AJS.contextPath() + "/rest/issueNav/latest/systemFilters",

        fetch: function() {
            if (this.length > 0) {
                this._setFetchState("fetched");
                return new jQuery.Deferred().resolve();
            }

            return JIRA.Components.Filters.Collections.Filters.prototype.fetch.apply(this, _.toArray(arguments));
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/entities/FavouriteFilters.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Collections.FavouriteFilters");

    /**
     * @class JIRA.Components.Filters.Collections.FavouriteFilters
     *
     * @extends JIRA.Components.Filters.Collections.Filters
     */
    JIRA.Components.Filters.Collections.FavouriteFilters = JIRA.Components.Filters.Collections.Filters.extend({
        url: AJS.contextPath() + "/rest/api/2/filter/favourite?expand=subscriptions[-5:]",

        comparator: function(filter1, filter2) {
            return filter1.getName().toLowerCase().localeCompare(filter2.getName().toLowerCase());
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/templates/actions.soy' */
// This file was automatically generated from actions.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.Filters.Templates.Actions.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.Filters == 'undefined') { JIRA.Components.Filters = {}; }
if (typeof JIRA.Components.Filters.Templates == 'undefined') { JIRA.Components.Filters.Templates = {}; }
if (typeof JIRA.Components.Filters.Templates.Actions == 'undefined') { JIRA.Components.Filters.Templates.Actions = {}; }


JIRA.Components.Filters.Templates.Actions.DropDown = function(opt_data, opt_ignored) {
  return '<div class="aui-list"><ul class="aui-list-section">' + ((opt_data.canEdit) ? '<li class="aui-list-item"><a href="" class="aui-list-item-link rename-filter" data-id="' + soy.$$escapeHtmlAttribute(opt_data.filter.id) + '">' + soy.$$escapeHtml("Rename") + '</a></li>' : '') + '<li class="aui-list-item"><a href="" class="aui-list-item-link copy-filter" data-id="' + soy.$$escapeHtmlAttribute(opt_data.filter.id) + '">' + soy.$$escapeHtml("Copy") + '</a></li></ul><ul class="aui-list-section' + ((! opt_data.canEdit) ? ' aui-last' : '') + '"><li class="aui-list-item"><a href="" class="aui-list-item-link unfavourite-filter" data-id="' + soy.$$escapeHtmlAttribute(opt_data.filter.id) + '">' + soy.$$escapeHtml("Remove from favourites") + '</a></li></ul>' + ((opt_data.canEdit) ? '<ul class="aui-list-section aui-last"><li class="aui-list-item"><a href="" class="aui-list-item-link delete-filter" data-id="' + soy.$$escapeHtmlAttribute(opt_data.filter.id) + '">' + soy.$$escapeHtml("Delete") + '</a></li></ul>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Actions.DropDown.soyTemplateName = 'JIRA.Components.Filters.Templates.Actions.DropDown';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/templates/dialogs.soy' */
// This file was automatically generated from dialogs.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.Filters.Templates.Dialogs.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.Filters == 'undefined') { JIRA.Components.Filters = {}; }
if (typeof JIRA.Components.Filters.Templates == 'undefined') { JIRA.Components.Filters.Templates = {}; }
if (typeof JIRA.Components.Filters.Templates.Dialogs == 'undefined') { JIRA.Components.Filters.Templates.Dialogs = {}; }


JIRA.Components.Filters.Templates.Dialogs.Rename = function(opt_data, opt_ignored) {
  return '<div class="aui-dialog-content"><form action="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/rest/api/2/filter/' + soy.$$escapeHtmlAttribute(opt_data.filter.id) + '" class="aui" id="rename-filter-form" method="put"><div class="aui-messages"></div><div class="form-body"><h2 class="dialog-title">' + soy.$$escapeHtml("Rename Filter") + ': ' + soy.$$escapeHtml(opt_data.filter.name) + '</h2><div class="field-group"><label for="filterName">' + soy.$$escapeHtml("Filter Name") + '<span class="aui-icon icon-required"><span class="content">Required</span></span></label><input type="text" id="filterName" name="name" value="' + soy.$$escapeHtmlAttribute(opt_data.filter.name) + '" class="text long-field"></div></div><div class="buttons-container form-footer"><div class="buttons"><input accesskey="' + soy.$$escapeHtmlAttribute("s") + '" title="' + soy.$$escapeHtmlAttribute(AJS.format("Press {1}+{0} to submit this form","s",opt_data.modifierKey)) + '" class="aui-button submit" type="submit" value="' + soy.$$escapeHtmlAttribute("Submit") + '" /><a accesskey="' + soy.$$escapeHtmlAttribute("`") + '" title="' + soy.$$escapeHtmlAttribute(AJS.format("Press {1}+{0} to cancel","`",opt_data.modifierKey)) + '" class="aui-button aui-button-link cancel" href="javascript:">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form></div>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Dialogs.Rename.soyTemplateName = 'JIRA.Components.Filters.Templates.Dialogs.Rename';
}


JIRA.Components.Filters.Templates.Dialogs.Save = function(opt_data, opt_ignored) {
  var output = '<div class="aui-dialog-content"><form action="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri(opt_data.contextPath)) + '/rest/api/2/filter/" class="aui" id="save-filter-form" method="post"><div class="aui-messages"></div><div class="form-body"><h2 class="dialog-title">' + soy.$$escapeHtml(opt_data.headerText) + '</h2>' + ((opt_data.copyFromAnotherUser) ? '<p class="form-description">' + ((opt_data.filterOwnerName) ? soy.$$escapeHtml(AJS.format("This filter was created by {0}. You can save a copy of this filter but you cannot modify the original.",opt_data.filterOwnerName)) : soy.$$escapeHtml("You can save a copy of this filter but you cannot modify the original.")) + '</p>' : '') + '<div class="field-group"><label for="filterName">' + soy.$$escapeHtml("Filter Name") + '<span class="aui-icon icon-required"><span class="content">Required</span></span></label><input type="text" id="filterName" name="name"' + ((opt_data.prefilledFilterName) ? ' value="' + soy.$$escapeHtmlAttribute(opt_data.prefilledFilterName) + '"' : '') + 'class="text long-field"><div class="description">' + soy.$$escapeHtml("Enter a name for this Filter") + '</div>';
  var fieldList54 = opt_data.hiddenFields;
  var fieldListLen54 = fieldList54.length;
  for (var fieldIndex54 = 0; fieldIndex54 < fieldListLen54; fieldIndex54++) {
    var fieldData54 = fieldList54[fieldIndex54];
    output += '<input type="hidden" name="' + soy.$$escapeHtmlAttribute(fieldData54.name) + '" value="' + ((fieldData54.value) ? soy.$$escapeHtmlAttribute(fieldData54.value) : '') + '" />';
  }
  output += '</div>' + ((opt_data.isDefaultShareScopeGlobal) ? '<div class="aui-message info shadowed"><p class="title"><span class="aui-icon icon-info"></span><strong>' + soy.$$escapeHtml("By default your filters are shared with everyone.") + '</strong></p><input type="checkbox" id="setSharingPrivate" class="checkbox"><label for="setSharingPrivate">' + soy.$$escapeHtml("My filters should be private by default.") + '</label></div>' : '') + '</div><div class="buttons-container form-footer"><div class="buttons"><input accesskey="' + soy.$$escapeHtmlAttribute("s") + '" title="' + soy.$$escapeHtmlAttribute(AJS.format("Press {1}+{0} to submit this form","s",opt_data.modifierKey)) + '" class="aui-button submit" type="submit" value="' + soy.$$escapeHtmlAttribute("Submit") + '" /><a accesskey="' + soy.$$escapeHtmlAttribute("`") + '" title="' + soy.$$escapeHtmlAttribute(AJS.format("Press {1}+{0} to cancel","`",opt_data.modifierKey)) + '" class="aui-button aui-button-link cancel" href="javascript:">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Dialogs.Save.soyTemplateName = 'JIRA.Components.Filters.Templates.Dialogs.Save';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/templates/list.soy' */
// This file was automatically generated from list.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.Filters.Templates.List.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.Filters == 'undefined') { JIRA.Components.Filters = {}; }
if (typeof JIRA.Components.Filters.Templates == 'undefined') { JIRA.Components.Filters.Templates = {}; }
if (typeof JIRA.Components.Filters.Templates.List == 'undefined') { JIRA.Components.Filters.Templates.List = {}; }


JIRA.Components.Filters.Templates.List.Module = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div class="filter-panel-section">' + ((opt_data.title) ? '<h4 class="filter-title">' + soy.$$escapeHtml(opt_data.title) + '</h4>' : '') + '<div class="filter-content" /></div>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.List.Module.soyTemplateName = 'JIRA.Components.Filters.Templates.List.Module';
}


JIRA.Components.Filters.Templates.List.Message = function(opt_data, opt_ignored) {
  return '<p class="filter-info ' + soy.$$escapeHtmlAttribute(opt_data.className) + '">' + soy.$$filterNoAutoescape(opt_data.text) + '</p>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.List.Message.soyTemplateName = 'JIRA.Components.Filters.Templates.List.Message';
}


JIRA.Components.Filters.Templates.List.List = function(opt_data, opt_ignored) {
  return '<ul class="saved-filter filter-list ' + soy.$$escapeHtmlAttribute(opt_data.className) + '"></ul>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.List.List.soyTemplateName = 'JIRA.Components.Filters.Templates.List.List';
}


JIRA.Components.Filters.Templates.List.Filter = function(opt_data, opt_ignored) {
  return '<li><a class="filter-link' + ((opt_data.requiresLoginForUser) ? ' requires-login' : '') + '" href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri(opt_data.navUrl)) + '" data-id="' + soy.$$escapeHtmlAttribute(opt_data.id) + '" title="' + soy.$$escapeHtmlAttribute(opt_data.name) + '">' + soy.$$escapeHtml(opt_data.name) + '</a>' + ((opt_data.useActions) ? '<a href="#" class="filter-actions" data-id="' + soy.$$escapeHtmlAttribute(opt_data.id) + '"><span>' + soy.$$escapeHtml("Filter Actions") + '</span></a>' : '') + '</li>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.List.Filter.soyTemplateName = 'JIRA.Components.Filters.Templates.List.Filter';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/templates/header.soy' */
// This file was automatically generated from header.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.Filters.Templates.Header.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.Filters == 'undefined') { JIRA.Components.Filters = {}; }
if (typeof JIRA.Components.Filters.Templates == 'undefined') { JIRA.Components.Filters.Templates = {}; }
if (typeof JIRA.Components.Filters.Templates.Header == 'undefined') { JIRA.Components.Filters.Templates.Header = {}; }


JIRA.Components.Filters.Templates.Header.Main = function(opt_data, opt_ignored) {
  var output = '<div class="header-section-primary"><h1 class="search-title" title="' + soy.$$escapeHtmlAttribute(opt_data.title) + '">' + soy.$$escapeHtml(opt_data.title) + '</h1><ul class="filter-operations">' + ((opt_data.primaryOps && opt_data.primaryOps.length) ? '<li class="filter-edited-item"><span>' + soy.$$escapeHtml("Edited") + '</span></li>' : '');
  if (opt_data.primaryButton) {
    output += '<li>' + ((opt_data.primaryOps && opt_data.primaryOps.length) ? '<div class="aui-buttons">' : '') + '<button class="aui-button aui-button-light ' + soy.$$escapeHtmlAttribute(opt_data.primaryButton.styleClass) + '">' + soy.$$escapeHtml(opt_data.primaryButton.label) + '</button>';
    if (opt_data.primaryOps && opt_data.primaryOps.length) {
      output += '<button class="aui-button aui-button-light aui-dropdown2-trigger js-edited-trigger" aria-owns="js-edited-content" aria-haspopup="true" data-container=".aui-buttons"></button></div><div id="js-edited-content" class="aui-dropdown2 aui-style-default"><ul>';
      var opList27 = opt_data.primaryOps;
      var opListLen27 = opList27.length;
      for (var opIndex27 = 0; opIndex27 < opListLen27; opIndex27++) {
        var opData27 = opList27[opIndex27];
        output += '<li><a href="' + ((opData27.href) ? soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri(opData27.href)) : '#') + '" ' + ((opData27.styleClass) ? 'class="' + soy.$$escapeHtmlAttribute(opData27.styleClass) + '"' : '') + '>' + soy.$$escapeHtml(opData27.label) + '</a></li>';
      }
      output += '</ul></div>';
    }
    output += '</li>';
  }
  if (opt_data.owner) {
    var opList48 = opt_data.secondaryOps;
    var opListLen48 = opList48.length;
    for (var opIndex48 = 0; opIndex48 < opListLen48; opIndex48++) {
      var opData48 = opList48[opIndex48];
      output += '<li><a href="' + ((opData48.href) ? soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri(opData48.href)) : '#') + '" ' + ((opData48.title) ? 'title="' + soy.$$escapeHtmlAttribute(opData48.title) + '"' : '') + ' class="' + soy.$$escapeHtmlAttribute(opData48.styleClass) + '">' + ((opData48.label) ? soy.$$escapeHtml(opData48.label) : '') + '</a></li>';
    }
  }
  output += '</ul></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Header.Main.soyTemplateName = 'JIRA.Components.Filters.Templates.Header.Main';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/templates/details.soy' */
// This file was automatically generated from details.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.Filters.Templates.Details.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.Filters == 'undefined') { JIRA.Components.Filters = {}; }
if (typeof JIRA.Components.Filters.Templates == 'undefined') { JIRA.Components.Filters.Templates = {}; }
if (typeof JIRA.Components.Filters.Templates.Details == 'undefined') { JIRA.Components.Filters.Templates.Details = {}; }


JIRA.Components.Filters.Templates.Details.Main = function(opt_data, opt_ignored) {
  return '' + JIRA.Components.Filters.Templates.Details.Description(opt_data) + JIRA.Components.Filters.Templates.Details.Permissions(opt_data) + ((opt_data.userIsLoggedIn) ? JIRA.Components.Filters.Templates.Details.Subscriptions(opt_data) : '');
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.Main.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.Main';
}


JIRA.Components.Filters.Templates.Details.Description = function(opt_data, opt_ignored) {
  return '<div class="filter-details-section sub-section">' + ((opt_data.owner) ? JIRA.Components.Filters.Templates.Details.Owner(opt_data) : '') + ((opt_data.filter.description) ? '<p class="filter-name">' + soy.$$escapeHtml(opt_data.filter.description) + ((opt_data.permissions.userHasEditPermission) ? ' <a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/secure/EditFilter!default.jspa?filterId=' + soy.$$escapeUri(opt_data.filter.id) + '">(' + soy.$$escapeHtml("Edit") + ')</a>' : '') + '</p>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.Description.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.Description';
}


JIRA.Components.Filters.Templates.Details.Permissions = function(opt_data, opt_ignored) {
  var output = '<div class="filter-details-section sub-section"><h4 class="section-header">' + soy.$$escapeHtml("Permissions") + '</h4>';
  if (opt_data.sharePermissions && opt_data.sharePermissions.length > 0) {
    output += '<p>' + soy.$$escapeHtml("This filter is visible to:") + '</p><ul class="shared-filters">';
    var shareList49 = opt_data.sharePermissions;
    var shareListLen49 = shareList49.length;
    for (var shareIndex49 = 0; shareIndex49 < shareListLen49; shareIndex49++) {
      var shareData49 = shareList49[shareIndex49];
      output += JIRA.Components.Filters.Templates.Details.SharePermissionItem({type: shareData49.type, project: '' + ((shareData49.project) ? '<a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/browse/' + soy.$$escapeHtml(shareData49.project.key) + '">' + soy.$$escapeHtml(shareData49.project.name) + '</a>' : ''), projectRole: '' + ((shareData49.role) ? soy.$$escapeHtml(shareData49.role.name) : ''), group: '' + ((shareData49.group) ? soy.$$escapeHtml(shareData49.group.name) : '')});
    }
    output += '</ul>';
  } else {
    output += '<p>' + soy.$$escapeHtml("This filter is only visible to you.") + '</p>';
  }
  output += ((opt_data.permissions.userHasEditSharingPermission) ? '<p><a class="edit-permissions" href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/secure/EditFilter!default.jspa?filterId=' + soy.$$escapeUri(opt_data.filter.id) + '">' + soy.$$escapeHtml("Edit permissions") + '</a></p>' : '') + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.Permissions.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.Permissions';
}


JIRA.Components.Filters.Templates.Details.Subscriptions = function(opt_data, opt_ignored) {
  return '<div class="filter-details-section full-section"><h4>' + soy.$$escapeHtml("Subscriptions") + '</h4>' + ((opt_data.subscriptions.items.length) ? '<p>' + soy.$$escapeHtml("This filter has the following subscriptions:") + '</p>' + JIRA.Components.Filters.Templates.Details.SubscriptionList(opt_data) : '<p>' + soy.$$escapeHtml("This filter has no subscriptions.") + '</p>') + '<ul class="manage-links"><li><a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/secure/EditSubscription!default.jspa?filterId=' + soy.$$escapeUri(opt_data.filter.id) + '&returnUrl=' + soy.$$escapeUri(opt_data.returnUrl) + '">' + soy.$$escapeHtml("New subscription") + '</a></li>' + ((opt_data.subscriptions.items.length) ? '<li><a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/secure/ViewSubscriptions.jspa?filterId=' + soy.$$escapeUri(opt_data.filter.id) + '">' + soy.$$escapeHtml("Manage subscriptions") + '</a></li>' : '') + '</ul></div>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.Subscriptions.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.Subscriptions';
}


JIRA.Components.Filters.Templates.Details.SharePermissionItem = function(opt_data, opt_ignored) {
  return '' + ((opt_data.type == 'global') ? '<li>' + soy.$$escapeHtml("Everyone") + '</li>' : (opt_data.type == 'group') ? '<li>' + soy.$$filterNoAutoescape(AJS.format("{0}Group{1}: {2}",'<strong>','</strong>',opt_data.group)) + '</li>' : (opt_data.projectRole) ? '<li>' + soy.$$filterNoAutoescape(AJS.format("{0}Project{1}: {2} {3}Role{4}: {5}",'<strong>','</strong>',opt_data.project,'<strong>','</strong>',opt_data.projectRole)) + '</li>' : '<li>' + soy.$$filterNoAutoescape(AJS.format("{0}Project{1}: {2}",'<strong>','</strong>',opt_data.project)) + '</li>');
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.SharePermissionItem.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.SharePermissionItem';
}


JIRA.Components.Filters.Templates.Details.SubscriptionList = function(opt_data, opt_ignored) {
  var output = '<ul>';
  var subList150 = opt_data.filter.subscriptions.items;
  var subListLen150 = subList150.length;
  for (var subIndex150 = 0; subIndex150 < subListLen150; subIndex150++) {
    var subData150 = subList150[subIndex150];
    output += (subData150.group) ? '<li>' + soy.$$escapeHtml(subData150.group.name) + '</li>' : '<li>' + soy.$$escapeHtml(subData150.user.displayName) + '</li>';
  }
  output += ((opt_data.filter.subscriptions.additionalLength) ? '<li><a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/secure/ViewSubscriptions.jspa?filterId=' + soy.$$escapeUri(opt_data.filter.id) + '">' + soy.$$escapeHtml(AJS.format("{0} more",opt_data.filter.subscriptions.additionalLength)) + '</a></li>' : '') + '</ul>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.SubscriptionList.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.SubscriptionList';
}


JIRA.Components.Filters.Templates.Details.Owner = function(opt_data, opt_ignored) {
  var output = '<div class="search-owner">' + ((opt_data.avatarUrl) ? '<span class="aui-avatar aui-avatar-large search-owner-avatar"><span class="aui-avatar-inner"><img src="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri(opt_data.avatarUrl)) + '" /></span></span>' : '') + '<span class="search-owner-name">';
  var ownerLink__soy181 = '' + JIRA.Components.Filters.Templates.Details.OwnerLink(opt_data);
  output += soy.$$filterNoAutoescape(AJS.format("Owned by {0}",ownerLink__soy181)) + '</span></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.Owner.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.Owner';
}


JIRA.Components.Filters.Templates.Details.OwnerLink = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri(opt_data.ownerUrl)) + '" class="user-hover" rel="' + soy.$$escapeHtmlAttribute(opt_data.ownerUserName) + '">' + soy.$$escapeHtml(opt_data.owner) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.OwnerLink.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.OwnerLink';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/Actions.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.Actions");

    /**
     * @class JIRA.Components.Filters.Views.Actions
     *
     * Displays the actions dropdown for a filter
     *
     * @extends JIRA.Marionette.ItemView
     */
    JIRA.Components.Filters.Views.Actions = JIRA.Marionette.ItemView.extend({
        template: JIRA.Components.Filters.Templates.Actions.DropDown,

        triggers: {
            "click .rename-filter": "renameFilter",
            "click .copy-filter": "copyFilter",
            "click .unfavourite-filter": "unfavouriteFilter",
            "click .delete-filter": "deleteFilter"
        },

        /**
         * The view that was used as a trigger for the dropdown. Populated when this view is created.
         * @type {JIRA.Marionette.View}
         */
        triggerView: null,

        /**
         * Internal dropdown created with this view is rendered.
         * @type {AJS.Dropdown}
         */
        dropDown: null,

        /**
         * @param {Object} options Options
         * @param {JIRA.Components.Filters.Views.List.FilterWithActions} options.triggerView View that was used to trigger the dropDown
         */
        initialize: function(options) {
            this.triggerView = options.triggerView;
        },

        serializeData: function() {
            return {
                filter: this.model,
                canEdit: JIRA.Issues.LoginUtils.loggedInUserName() === this.model.getOwnerUserName()
            };
        },

        onBeforeRender: function() {
            this.dropDown = new AJS.Dropdown({
                alignment: AJS.LEFT,
                styleClass: "filter-actions-dropdown",
                content: _.bind(function() {
                    return this.$el;
                }, this),
                positioningController: new JIRA.Issues.WindowPositioning(),
                trigger: this.triggerView.getActionsTrigger()
            });

            // When the dropdown is hidden, close this view
            this.dropDown.bind("hideLayer", _.bind(this.close, this));
        },

        onRender: function() {
            this.dropDown.show();
            this._markFilterAsSelected();
        },

        onClose: function() {
            this.dropDown.hide();
            this.dropDown.layerController.placeholder().remove();
            this.dropDown = null;
            this._markFilterAsUnselected();
        },

        _markFilterAsSelected: function() {
            var trigger = this.triggerView.getActionsTrigger();
            trigger.find("span").addClass("active");
            trigger.closest("li").addClass("hover");
        },

        _markFilterAsUnselected: function() {
            var trigger = this.triggerView.getActionsTrigger();
            trigger.find("span").removeClass("active");
            trigger.closest("li").removeClass("hover");
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/dialogs/Copy.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.Dialogs.Copy");

    /**
     * @class JIRA.Components.Filters.Views.Dialogs.Copy
     *
     * @extends JIRA.Marionette.DialogView
     */
    JIRA.Components.Filters.Views.Dialogs.Copy = JIRA.Marionette.DialogView.extend({
        template: JIRA.Components.Filters.Templates.Dialogs.Save,

        id: "copy-filter-dialog",

        /**
         * Generate the options needed to display the form, in the format expected by JIRA.FormDialog.
         *
         * @returns {Object}
         */
        dialogOptions: function() {
            var instance = this;
            return {
                content: function(callback) {
                    // Make REST call to see if user shares filters by default
                    JIRA.SmartAjax.makeRequest({
                        url: AJS.contextPath() + '/rest/api/2/filter/defaultShareScope',
                        contentType: 'application/json'
                    }).done(function(data) {
                        callback(
                            instance.template(_.extend({
                                isDefaultShareScopeGlobal: data && data.scope === 'GLOBAL'
                            }, instance.serializeData()))
                        );
                    });
                }
            };
        },

        /**
         * Generate the data to be sent in the form request.
         *
         * @param {jQuery} form Form container.
         * @returns {Object} Data to be sent in the request.
         */
        formToRequestData: function(form) {
            return {
                name: form.find('[name=name]').val(),
                id: this.model.getId(),
                favourite: true
            };
        },

        /**
         * Generate the data needed by the template
         *
         * @returns {Object}
         */
        serializeData: function() {
            var model = this.model;
            return {
                headerText: "Copy Filter" + " : " + model.getName(),
                prefilledFilterName: AJS.format("Copy of {0}", model.getName()),
                modifierKey: AJS.Navigator.modifierKey(),
                contextPath: AJS.contextPath(),
                filter: model.toJSON(),
                copyFromAnotherUser: model.getOwnerUserName() !== AJS.Meta.get('remote-user'),
                filterOwnerName: model.getOwnerDisplayName(),
                hiddenFields: []
            };
        },

        /**
         * Method to run when the form has been submitted successfully.
         *
         * Changes the user sharing preference to 'PRIVATE' if needed.
         */
        onSubmitSuccess: function() {
            if (this.$el.find('#setSharingPrivate').prop('checked')) {
                JIRA.SmartAjax.makeRequest({
                    url: AJS.contextPath() + '/rest/api/2/filter/defaultShareScope',
                    type: 'PUT',
                    contentType: 'application/json',
                    processData: false,
                    data: JSON.stringify({scope: 'PRIVATE'})
                });
            }
        },

        /**
         * Method to run when the form has been submitted with errors
         */
        onSubmitError: function() {
            this.dialog.$form.find("#filterName").focus();
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/dialogs/Delete.js' */
define("jira/issues/components/filters/views/dialogs/delete", ["require"], function(require) {
    "use strict";

    var DialogUtil = require('jira/dialog/dialog-util');

    /**
     * @class JIRA.Components.Filters.Views.Dialogs.Delete
     *
     * @extends JIRA.Marionette.DialogView
     */
    JIRA.Components.Filters.Views.Dialogs.Delete = JIRA.Marionette.DialogView.extend({
        id: "delete-filter-dialog",

        serializeData: function () {
            var data = {
                modifierKey: AJS.Navigator.modifierKey()
            };

            if (this.model) {
                data.filter = this.model.toJSON();
            } else {
                data.filter = {subscriptions: {items: []}};
            }

            return data;
        },

        dialogOptions: function() {
            return {
                content: null, //override default behaviour of issuenav DialogView, which generates content using soy template
                url: AJS.contextPath() + "/secure/DeleteFilter!default.jspa?filterId=" + this.model.id,
                ajaxOptions: DialogUtil.getDefaultAjaxOptions,
                submitHandler: null, //fall back to FormDialog's original behaviour
                onUnSuccessfulSubmit: this._onSubmitError.bind(this),
                onSuccessfulSubmit: this._onSubmitSuccess.bind(this),
                onDialogFinished: function(){} //ensure that we do not do a page reload post form submission
            };
        }
    });
});
AJS.namespace("JIRA.Components.Filters.Views.Dialogs.Delete", null, require("jira/issues/components/filters/views/dialogs/delete"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/dialogs/Rename.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.Dialogs.Rename");

    /**
     * @class JIRA.Components.Filters.Views.Dialogs.Rename
     *
     * @extends JIRA.Marionette.DialogView
     */
    JIRA.Components.Filters.Views.Dialogs.Rename = JIRA.Marionette.DialogView.extend({
        template: JIRA.Components.Filters.Templates.Dialogs.Rename,

        id: "rename-filter-dialog",

        serializeData: function() {
            return {
                modifierKey: AJS.Navigator.modifierKey(),
                filter: this.model.toJSON()
            };
        },

        /**
         * Generate the data to be sent in the form request
         *
         * @param {jQuery} form Form container
         * @returns {Object} Data to be sent in the request
         */
        formToRequestData: function(form) {
            return {
                name: form.find('[name=name]').val(),
                id: this.model.getId(),
                favourite: true
            };
        },

        onSubmitError: function() {
            this.dialog.$form.find("#filterName").focus();
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/dialogs/SaveAs.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.Dialogs.SaveAs");

    /**
     * @class JIRA.Components.Filters.Views.Dialogs.SaveAs
     *
     * @extends JIRA.Marionette.DialogView
     */
    JIRA.Components.Filters.Views.Dialogs.SaveAs = JIRA.Marionette.DialogView.extend({
        template: JIRA.Components.Filters.Templates.Dialogs.Save,

        id: "save-filter-dialog",

        initialize: function(options) {
            this.jql = options.jql;
        },

        /**
         * Generate the options needed to display the form, in the format expected by JIRA.FormDialog
         *
         * @returns {Object}
         */
        dialogOptions: function() {
            var instance = this;
            return {
                content: function(callback) {
                    // Make REST call to see if user shares filters by default
                    JIRA.SmartAjax.makeRequest({
                        url: AJS.contextPath() + '/rest/api/2/filter/defaultShareScope',
                        contentType: 'application/json'
                    }).done(function(data) {
                        callback(
                            instance.template(_.extend({
                                isDefaultShareScopeGlobal: data && data.scope === 'GLOBAL'
                            }, instance.serializeData()))
                        );
                    });
                }
            };
        },

        /**
         * Generate the data to be sent in the form request
         *
         * @param {jQuery} form Form container
         * @returns {Object} Data to be sent in the request
         */
        formToRequestData: function(form) {
            var opts = {
                name: form.find('[name=name]').val(),
                jql: this.jql,
                favourite: true
            };

            // If we are Saving a new serach, this.model will be undefined
            if (this.model && !this.model.getIsSystem()) {
                opts.id = this.model.getId();
            }

            return opts;
        },

        /**
         * Generate the data needed by the template
         *
         * @returns {Object}
         */
        serializeData: function() {
            var data = {
                headerText: "Save Filter",
                modifierKey: AJS.Navigator.modifierKey(),
                contextPath: AJS.contextPath(),
                hiddenFields: []
            };

            // If we are Saving a new search, this.model will be undefined
            var model = this.model;
            if (model) {
                _.extend(data, {
                    filter: model ? model.toJSON() : {},
                    copyFromAnotherUser: model.getOwnerUserName() !== AJS.Meta.get('remote-user'),
                    filterOwnerName: model.getOwnerDisplayName()
                });
            }

            return data;
        },

        /**
         * Method to run when the form has been submitted successfully.
         *
         * Changes the user sharing preference to 'PRIVATE' if needed.
         */
        onSubmitSuccess: function() {
            if (this.$el.find('#setSharingPrivate').prop('checked')) {
                JIRA.SmartAjax.makeRequest({
                    url: AJS.contextPath() + '/rest/api/2/filter/defaultShareScope',
                    type: 'PUT',
                    contentType: 'application/json',
                    processData: false,
                    data: JSON.stringify({ scope: 'PRIVATE' })
                });
            }
        },

        /**
         * Method to run when the form has been submitted with errors
         */
        onSubmitError: function() {
            this.dialog.$form.find("#filterName").focus();
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/list/Filter.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.List.Filter");

    /**
     * @class JIRA.Components.Filters.Views.List.Filter
     *
     * Renders each individual item in the filter's list.
     *
     * @extends JIRA.Marionette.ItemView
     */
    JIRA.Components.Filters.Views.List.Filter = JIRA.Marionette.ItemView.extend({
        template: JIRA.Components.Filters.Templates.List.Filter,

        ui: {
            filterLink: ".filter-link"
        },

        triggers: {
            "simpleClick .filter-link:not(.requires-login)": "selectFilter"
        },

        modelEvents: {
            "change": "render"
        },

        onRender: function() {
            this.unwrapTemplate();
        },

        highlight: function() {
            this.ui.filterLink.addClass("active");
            this.ui.filterLink.scrollIntoView();
        },

        unhighlight: function() {
            this.ui.filterLink.removeClass("active");
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/list/FilterWithActions.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.List.FilterWithActions");

    /**
     * @class JIRA.Components.Filters.Views.List.FilterWithActions
     *
     * Renders each individual item in the filter's list, including a dropdown for the filter Actions
     *
     * @extends JIRA.Components.Filters.Views.List.Filter
     */
    JIRA.Components.Filters.Views.List.FilterWithActions = JIRA.Components.Filters.Views.List.Filter.extend({
        ui: _.extend({
            actionsTrigger: ".filter-actions"
        }, JIRA.Components.Filters.Views.List.Filter.prototype.ui),

        triggers: _.extend({
            "click .filter-actions": "openActions"
        }, JIRA.Components.Filters.Views.List.Filter.prototype.triggers),

        templateHelpers: {
            useActions: true
        },

        /**
         * Returns the trigger used to display the Actions dropdown
         *
         * @returns {jQuery}
         */
        getActionsTrigger: function() {
            return this.ui.actionsTrigger;
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/list/List.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.List.List");

    /**
     * @class JIRA.Components.Filters.Views.List.List
     *
     * Displays a list of filters
     *
     * @extends JIRA.Marionette.CompositeView
     */
    JIRA.Components.Filters.Views.List.List = JIRA.Marionette.CompositeView.extend({
        template: JIRA.Components.Filters.Templates.List.List,
        itemView: JIRA.Components.Filters.Views.List.Filter,
        itemViewContainer: ".filter-list",

        onRender: function() {
            this.unwrapTemplate();
        },

        templateHelpers: function() {
            return {
                className: this.className
            };
        },

        unhighlightAllFilters: function() {
            this.children.apply("unhighlight");
        },

        /**
         * Highlight a filter. If the model does not exist in the collection represented by this list,
         * this method does nothing.
         *
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model to highlight
         */
        highlightFilter: function(filterModel) {
            var itemView = this.children.findByModel(filterModel);
            if (itemView) {
                itemView.highlight();
            }
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/list/ListWithActions.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.List.ListWithActions");

    /**
     * @class JIRA.Components.Filters.Views.List.List
     *
     * Displays a list of filters
     *
     * @extends JIRA.Components.Filters.Views.List.List
     */
    JIRA.Components.Filters.Views.List.ListWithActions = JIRA.Components.Filters.Views.List.List.extend({
        itemView: JIRA.Components.Filters.Views.List.FilterWithActions,

        /**
         * Whether the items of the list should include the actions dropdown
         * @type {boolean}
         */
        useActions: false,

        /**
         * @param {Object} options Options
         * @param {boolean} [options.useActions=false] Whether the action's trigger should be displayed
         */
        initialize: function(options) {
            options = _.defaults({}, options, {
                useActions: false
            });

            this.useActions = options.useActions;
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/list/Message.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.List.Message");

    /**
     * @class JIRA.Components.Filters.Views.List.Message
     *
     * Displays a message
     *
     * @extends JIRA.Marionette.ItemView
     */
    JIRA.Components.Filters.Views.List.Message = JIRA.Marionette.ItemView.extend({
        template: JIRA.Components.Filters.Templates.List.Message,

        /**
         * Text to display in the message
         * @type {string}
         */
        text: "",

        /**
         * @param {Object} options Options
         * @param {string} options.text Text to display in the message.
         */
        initialize: function(options) {
            this.text = options.text;
        },

        onRender: function() {
            this.unwrapTemplate();
        },

        templateHelpers: function() {
            return {
                text: this.text,
                className: this.className
            };
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/list/Module.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.List.Module");

    /**
     * @class JIRA.Components.Filters.Views.List.Module
     *
     * Displays the main module for the list of filters. This view only renders the placeholder
     * for the other views (List, Empty or Error),  and an optional title
     *
     * @extends JIRA.Marionette.Layout
     */
    JIRA.Components.Filters.Views.List.Module = JIRA.Marionette.Layout.extend({
        template: JIRA.Components.Filters.Templates.List.Module,

        /**
         * Title to display in the message
         * @type {string}
         */
        title: "",

        regions: {
            content: ".filter-content"
        },

        /**
         * @param {Object} options Options
         * @param {string} [options.title] Title of the module. If not provided, the module will be rendered without title markup.
         */
        initialize: function(options) {
            options = _.defaults({}, options, {
                title: ""
            });
            this.title = options.title;
        },

        templateHelpers: function() {
            return {
                title: this.title
            };
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/Header.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.Header");

    /**
     * @class JIRA.Components.Filters.Controllers.Header
     *
     * @extends JIRA.Marionette.ItemView
     */
    JIRA.Components.Filters.Views.Header = JIRA.Marionette.ItemView.extend({
        operations: {
            save: {
                styleClass: "save-changes",
                label: "Save"
            },
            saveAs: {
                styleClass: "save-as-new-filter",
                label: "Save as"
            },
            discardChanges: {
                styleClass: "discard-filter-changes",
                label: "Discard changes"
            },
            details: {
                styleClass: "show-filter-details",
                title: "View information about this filter",
                label: "Details"
            },
            favouriteOn: {
                title: "Remove this filter from your Favourite Filters",
                label: "Remove this filter from your Favourite Filters",
                styleClass: "fav-link aui-icon aui-icon-small aui-iconfont-star"
            },
            favouriteOff: {
                title: "Add this filter to your Favourite Filters",
                label: "Add this filter to your Favourite Filters",
                styleClass: "fav-link aui-icon aui-icon-small aui-iconfont-unstar"
            }
        },

        template: JIRA.Components.Filters.Templates.Header.Main,

        ui: {
            filterFavouriteButton: ".fav-link",
            filterEditedLabel: ".filter-edited-item",
            saveButton: '.save-changes',
            saveAsButton: '.save-as-new-filter',
            detailsTrigger: '.show-filter-details',
            dropdownContent: '#js-edited-content'
        },

        triggers: {
            'click .fav-link': "toogleFavourite",
            "click .save-as-new-filter:not([aria-disabled=true])": {
                event: "saveAs",
                preventDefault: true,
                stopPropagation: false
            },
            "click .save-changes:not([aria-disabled=true])": {
                event: "save",
                preventDefault: true,
                stopPropagation: false
            },
            "click .discard-filter-changes": {
                event: "discard",
                preventDefault: true,
                stopPropagation: false
            }
        },

        events: {
            "click .show-filter-details": function() {
                this.trigger("details", this.ui.detailsTrigger);
            }
        },

        _generatePrimaryOperations: function() {
            var operations = [];

            if (this.isEdited && this.model.isMyFilter()) {
                operations.push(this.operations.save);
            }

            if (!this.isDirty && !!JIRA.Issues.LoginUtils.loggedInUserName()) {
                operations.push(this.operations.saveAs);
            }

            if (this.isEdited) {
                operations.push(this.operations.discardChanges);
            }

            return operations;
        },

        _generateSecondaryOperations: function() {
            var operations = [];

            if (!this.model.getIsSystem()) {
                operations.push(this.operations.details);
            }

            if (!!JIRA.Issues.LoginUtils.loggedInUserName() && !this.model.getIsSystem()) {
                var operation = this.model.isFavouriteFilter() ? this.operations.favouriteOn : this.operations.favouriteOff;
                operations.href = AJS.contextPath() + "/secure/EditFilter!default.jspa?filterId=" + this.model.id;
                operations.push(operation);
            }

            return operations;
        },

        serializeData: function() {
            if (!this.model) {
                return {
                    title: "Search",
                    primaryButton: this.operations.saveAs
                };
            }

            if (!this.model.getIsValid()) {
                return {
                    title: "Search"
                };
            }

            var primaryOperations = this._generatePrimaryOperations();
            var secondaryOperations = this._generateSecondaryOperations();

            var renderData = {
                title: this.model.getName(),
                primaryButton: primaryOperations.shift(),
                primaryOps: primaryOperations,
                secondaryOps: secondaryOperations
            };

            if (this.model.getOwner()) {
                _.extend(renderData, {
                    owner: this.model.getOwner() || "",
                    ownerUserName: this.model.getOwnerUserName() || "",
                    avatarUrl: this.model.getAvatarUrl(),
                    ownerUrl: AJS.contextPath() + '/secure/ViewProfile.jspa?name=' + encodeURIComponent(this.model.getOwnerUserName())
                });
            }

            return renderData;
        },

        render: function(options) {
            if (typeof options.model !== "undefined") {
                this.model = options.model;
            }
            this.isEdited = options.isEdited;
            this.isDirty = options.isDirty;
            return JIRA.Marionette.ItemView.prototype.render.call(this);
        },

        onRender: function() {
            this.ui.dropdownContent.on("aui-dropdown2-show", _.bind(function(e) {
                //HACK to use Backbone's event delegation on the dropdown content.
                //Backbone's 'delegateEvents()' works only on 'this.$el', so we need to set it before calling
                //the delegate method, and restore it afterwards to the real value.
                var viewEl = this.$el;
                this.$el = jQuery(e.target);
                this.delegateEvents();
                this.$el = viewEl;
            }, this));

            if (this.dirtyTipsy) {
                this.dirtyTipsy.remove();
                delete this.dirtyTipsy;
            }

            if (this.isDirty) {
                this.markAsInvalid();
            }
            new JIRA.Issues.Tipsy({el: this.ui.filterFavouriteButton});
        },

        markAsInvalid: function() {
            this.ui.saveButton.addClass("disabled");
            this.ui.saveButton.attr("aria-disabled", "true");

            this.dirtyTipsy = new JIRA.Issues.Tipsy({
                el: this.ui.saveButton,
                tipsy: {
                    delayIn: 0,
                    title: function() {
                        return "You need to run the search first before you can save your changes";
                    }
                }
            });
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/Details.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.Details");

    /**
     * @class JIRA.Components.Filters.Controllers.Details
     *
     * @extends JIRA.Marionette.InlineDialogView
     */
    JIRA.Components.Filters.Views.Details = JIRA.Marionette.InlineDialogView.extend({
        template: JIRA.Components.Filters.Templates.Details.Main,
        id: "filter-details-overlay",

        dialogOptions: {
            addActiveClass: true,
            hideDelay: 36e5,
            offsetX: -36,
            width: 400
        },

        initialize: function(options) {
            this.trigger = options.triggerEl;
        },

        serializeData: function() {
            var currentFilter = this.model;
            var shares = _.sortBy(currentFilter.getSharePermissions(), function(share) {
                var criteria = [share.type];
                if (share.group) criteria.push(share.group.name);
                if (share.project) criteria.push(share.project.name);
                if (share.role) criteria.push(share.role.name);
                return criteria;
            });
            var subscriptions = _.clone(currentFilter.getSubscriptions());
            var canEdit = JIRA.Issues.LoginUtils.loggedInUserName() === currentFilter.getOwnerUserName();

            subscriptions.additionalLength = currentFilter.getNumberOfAdditionalSubscriptions();

            var data = {
                filter: currentFilter.toJSON(),
                sharePermissions: shares,
                subscriptions: subscriptions,
                permissions: {
                    // The "Edit Permissions" link should be displayed whenever the user can actually change sharing permissions.
                    // This is possible even when they do not have "create shared objects" permission. @see JRADEV-14810
                    userHasEditSharingPermission: canEdit && (!!JIRA.Issues.UserParms.createSharedObjects() || shares.length > 0),
                    userHasEditPermission: canEdit
                },
                userIsLoggedIn: JIRA.Issues.LoginUtils.isLoggedIn(),
                returnUrl: window.location
            };

            if (currentFilter.getOwner()) {
                _.extend(data, {
                    owner: currentFilter.getOwner() || "",
                    ownerUserName: currentFilter.getOwnerUserName() || "",
                    avatarUrl: currentFilter.getAvatarUrl(),
                    ownerUrl: AJS.contextPath() + '/secure/ViewProfile.jspa?name=' + encodeURIComponent(currentFilter.getOwnerUserName())
                });
            }

            return data;
        },

        onRender: function() {
            // Hack to work around JIRA's LayerManager.js closing this dialog.
            this.dialog.bind("click", function(event) {
                event.stopPropagation();
            });
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/controllers/Dialog.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Controllers.Dialog");

    /**
     * @class JIRA.Components.Filters.Controllers.Dialog
     *
     * @extends JIRA.Marionette.Controller
     */
    JIRA.Components.Filters.Controllers.Dialog = JIRA.Marionette.Controller.extend({
        /**
         * @constructor
         */
        initialize: function() {
            this.activeView = null;
        },

        _closeActiveDialog: function() {
            if (this.activeView) {
                this.activeView.close();
                this.stopListening(this.activeView);
                this.activeView = null;
            }
        },

        /**
         * Shows a dialog .
         *
         * @param {JIRA.Marionette.DialogView} Constructor Class of the dialog.
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model of the filter related to the dialog (e.g. in the deleteDialog, this is the filter being deleted).
         * @param {Object} [options] Options
         * @param {Object} [options.viewOptions] Options passed to the view's Constructor
         * @param {Function} [options.onSuccess] Handler for the 'submit:success' event
         * @param {Function} [options.onError] Handler for the 'submit:error' event
         *
         * @private
         */
        _showDialog: function(Constructor, filterModel, options) {
            _.defaults(options, {
                viewOptions: {},
                onSuccess: jQuery.noop,
                onError: jQuery.noop
            });

            this._closeActiveDialog();

            this.activeView = new Constructor(_.extend({
                model: filterModel
            }, options.viewOptions));

            this.listenTo(this.activeView, 'submit:success', function(serverResponse) {
                options.onSuccess.call(this, serverResponse, filterModel);
            });
            this.listenTo(this.activeView, "submit:error", function() {
                options.onError.call(this, filterModel);
            });

            this.activeView.render();
        },

        /**
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model of the filter being deleted.
         */
        showDeleteDialog: function(filterModel) {
            this._showDialog(JIRA.Components.Filters.Views.Dialogs.Delete, filterModel, {
                onSuccess: function(serverResponse, filterModel) {
                    this.trigger('delete:success', filterModel);
                },
                onError: function(filterModel) {
                    this.trigger('delete:error', filterModel);
                }
            });
        },

        /**
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model of the filter being renamed.
         */
        showRenameDialog: function(filterModel) {
            this._showDialog(JIRA.Components.Filters.Views.Dialogs.Rename, filterModel, {
                onSuccess: function(serverResponse, filterModel) {
                    filterModel.set("name", serverResponse.name);
                    this.trigger('rename:success', filterModel);
                },
                onError: function(filterModel) {
                    this.trigger('rename:error', filterModel);
                }
            });
        },

        /**
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model of the filter being copied.
         */
        showCopyDialog: function(filterModel) {
            this._showDialog(JIRA.Components.Filters.Views.Dialogs.Copy, filterModel, {
                onSuccess: function(serverResponse) {
                    var newModel = new JIRA.Components.Filters.Models.Filter(serverResponse, {parse: true});
                    this.trigger('copy:success', newModel);
                },
                onError: function(filterModel) {
                    this.trigger('copy:error', filterModel);
                }
            });
        },

        /**
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model of  filter being saved.
         * @param {string} jql JQL of the filter being saved.
         */
        showSaveAsDialog: function(filterModel, jql) {
            this._showDialog(JIRA.Components.Filters.Views.Dialogs.SaveAs, filterModel, {
                viewOptions: {jql: jql},
                onSuccess: function(serverResponse) {
                    var newModel = new JIRA.Components.Filters.Models.Filter(serverResponse, {parse: true});
                    this.trigger('saveas:success', newModel);
                },
                onError: function(filterModel) {
                    this.trigger('saveas:error', filterModel);
                }
            });
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/controllers/List.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Controllers.List");

    /**
     * @class JIRA.Components.Filters.Controllers.List
     *
     * This controllers displays a list of filters
     *
     * @extends JIRA.Marionette.Controller
     */
    JIRA.Components.Filters.Controllers.List = JIRA.Marionette.Controller.extend({
        /**
         * Main view rendered by this controller
         * @type {JIRA.Components.Filters.Views.List.Module}
         */
        view: null,

        /**
         * @param {Object} options
         * @param {JIRA.Components.Filters.Collections.Filters} options.collection Collection of filters
         */
        initialize: function(options) {
            this.collection = options.collection;
            this.title = options.title;
            this.className = options.className;
            this.errorMessage = options.errorMessage;
            this.loadingMessage = options.loadingMessage;
            this.emptyMessage = options.emptyMessage;
            this.loginMessage = options.loginMessage;
        },

        /**
         * Displays the filter's list in the provided element
         *
         * @param {jQuery} el Container for the filter's list
         */
        show: function(el) {
            if (this.view) {
                this.close();
            }

            this.view = new JIRA.Components.Filters.Views.List.Module({
                el: el,
                title: this.title
            });
            this.view.render();

            this._showInternalView(this.collection.fetchState);
            this.listenTo(this.collection, "change:fetchState", this._showInternalView);
        },

        close: function() {
            if (this.view) {
                this.stopListening(this.collection, "change:fetchState", this._showRegion);
                this.stopListening(this.view);
                this.view.close();
                this.view = null;
            }
        },

        /**
         * Highlight a filter, unhighlights all the other filters
         *
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model to highlight
         */
        highlightFilter: function(filterModel) {
            if (this._listView) {
                this._listView.unhighlightAllFilters();
                if (filterModel) {
                    this._listView.highlightFilter(filterModel);
                }
            }
        },

        /**
         * Displays the internal view based on the state of the filter's collection.
         *
         * @param {string} fetchState Fetch state of the collection, valid values are "error", "fetched" or ""
         * @private
         */
        _showInternalView: function(fetchState) {
            switch (fetchState) {
                case "error":
                    this._showError();
                    break;
                case "fetched":
                    this._showList();
                    break;
                default:
                    this._showLoading();
                    break;
            }
        },

        _showLoading: function() {
            this.view.content.show(new JIRA.Components.Filters.Views.List.Message({
                className: this.className,
                text: this.loadingMessage
            }));
        },

        _showError: function() {
            this.view.content.show(new JIRA.Components.Filters.Views.List.Message({
                className: this.className,
                text: this.errorMessage
            }));
        },

        _showList: function() {
            var collection = this.collection;
            if (collection.length) {
                this._showListWithItems();
            } else {
                this._showEmptyList();
            }
        },

        _getListViewConstructor: function() {
            return JIRA.Components.Filters.Views.List.List;
        },

        _showListWithItems: function() {
            var ViewConstructor = this._getListViewConstructor();
            this._listView = new ViewConstructor({
                collection: this.collection,
                className: this.className
            });
            this.view.content.show(this._listView);
            this.trigger("render");

            // When we remove the last item from the collection, render the empty list
            this.listenTo(this.collection, "remove", function f() {
                if (!this.collection.length) {
                    this.stopListening(this.collection, "remove", f);
                    this._showEmptyList();
                }
            });

            this.listenTo(this._listView, "itemview:selectFilter", function(itemView, args) {
                this.trigger("selectFilter", args.model);
            });
            this.listenTo(this._listView, "itemview:render", function() {
                this.trigger("render");
            });

            this.triggerMethod("list:render", this._listView);
        },

        _showEmptyList: function() {
            if (JIRA.Issues.LoginUtils.isLoggedIn()) {
                this.view.content.show(new JIRA.Components.Filters.Views.List.Message({
                    className: this.className,
                    text: this.emptyMessage
                }));
            } else {
                this.view.content.show(new JIRA.Components.Filters.Views.List.Message({
                    className: this.className,
                    text: this.loginMessage
                }));
            }

            // When we add a new item to the collection, render the list with items
            this.listenToOnce(this.collection, "add", function() {
                this._showListWithItems();
            });
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/controllers/ListWithActions.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Controllers.ListWithActions");

    /**
     * @class JIRA.Components.Filters.Controllers.ListWithActions
     *
     * @extends JIRA.Components.Filters.Controllers.List
     */
    JIRA.Components.Filters.Controllers.ListWithActions = JIRA.Components.Filters.Controllers.List.extend({
        /**
         * Actions view (i.e. dropdown) associated to a filter
         * @type {JIRA.Components.Filters.Views.Actions}
         */
        actionsView: null,

        _getListViewConstructor: function() {
            return JIRA.Components.Filters.Views.List.ListWithActions;
        },

        close: function() {
            this._closeActions();
            JIRA.Components.Filters.Controllers.List.prototype.close.call(this);
        },

        highlightFilter: function(filterModel) {
            this._closeActions();
            JIRA.Components.Filters.Controllers.List.prototype.highlightFilter.call(this, filterModel);
        },

        /**
         * Displays the Actions view related to a filter.
         *
         * @param {JIRA.Components.Filters.Views.List.Filter} triggerView View that triggered the actions dropdown.
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Filter's model.
         * @private
         */
        _showActions: function(triggerView, filterModel) {
            var isActionsForFilterAlreadyOpen = (this.actionsView && this.actionsView.model === filterModel);
            this._closeActions();

            // If actions for this filter is already open, do not open it again
            if (!isActionsForFilterAlreadyOpen) {
                this.actionsView = new JIRA.Components.Filters.Views.Actions({
                    triggerView: triggerView,
                    model: filterModel
                });
                this.actionsView.render();

                this.listenTo(this.actionsView, "deleteFilter", function(args) {
                    this._closeActions();
                    this.trigger("deleteFilter", args.model);
                });

                this.listenTo(this.actionsView, "renameFilter", function(args) {
                    this._closeActions();
                    this.trigger("renameFilter", args.model);
                });

                this.listenTo(this.actionsView, "copyFilter", function(args) {
                    this._closeActions();
                    this.trigger("copyFilter", args.model);
                });

                this.listenTo(this.actionsView, "unfavouriteFilter", function(args) {
                    this._closeActions();
                    this.trigger("unfavouriteFilter", args.model);
                });
            }
        },

        _closeActions: function() {
            if (this.actionsView) {
                this.actionsView.close();
                this.stopListening(this.actionsView);
                this.actionsView = null;
            }
        },

        onListRender: function() {
            this.listenTo(this._listView, "itemview:selectFilter", function() {
                this._closeActions();
            });

            this.listenTo(this._listView, "itemview:openActions", function(itemView, args) {
                this._showActions(args.view, args.model);
            });
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/controllers/Header.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Controllers.Header");

    /**
     * @class JIRA.Components.Filters.Controllers.Header
     *
     * @extends JIRA.Marionette.Controller
     */
    JIRA.Components.Filters.Controllers.Header = JIRA.Marionette.Controller.extend({
        /**
         * @constructor
         */
        initialize: function() {
            this.view = null;
        },

        close: function() {
            if (this.view) {
                this.view.close();
                this.stopListening(this.view);
                this.view = null;
                this.trigger("close");
            }
        },

        closeDetails: function() {
            if (this.detailsView) {
                this.detailsView.close();
                this.stopListening(this.detailsView);
                this.detailsView = null;
            }
        },

        showDetails: function(triggerEl) {
            if (this.detailsView) {
                this.closeDetails();
            }

            this.detailsView = new JIRA.Components.Filters.Views.Details({
                model: this.model,
                triggerEl: triggerEl
            });
            this.listenTo(this.detailsView, "close", this.closeDetails);

            this.detailsView.render();
        },

        show: function(options) {
            if (this.view) {
                this.close();
            }

            this.view = new JIRA.Components.Filters.Views.Header({
                el: options.el
            });
            this.isInvalid = false;

            this.listenTo(this.view, {
                "saveAs": function(args) {
                    if (!JIRA.Issues.LoginUtils.isLoggedIn() || this.isInvalid) return;
                    this.trigger("saveAs", args.model);
                },
                "save": function(args) {
                    if (!JIRA.Issues.LoginUtils.isLoggedIn() || this.isInvalid) return;
                    this.trigger("save", args.model);
                },
                "discard": function() {
                    this.update({
                        isEdited: false,
                        isDirty: false
                    });
                    this.trigger("discard");
                },
                "details": function(triggerEl) {
                    this.showDetails(triggerEl);
                },
                "toogleFavourite": function(args) {
                    var model = args.model;

                    if (!model) return;

                    var currentlyFavourited = !!model.getFavourite();
                    model.saveFavourite(!currentlyFavourited);
                    // Need to add to the favourite filters collection if a filter has just been starred
                    if (!currentlyFavourited) {
                        this.trigger("favourite", model);
                    }
                },
                "close": this.close
            });

            this.update(options);
        },

        update: function(options) {
            if (!this.view) {
                return;
            }

            if (typeof options.model !== "undefined") {
                this.model = options.model;
            }

            this.isInvalid = false;

            this.view.render({
                model: this.model,
                isDirty: options.isDirty,
                isEdited: options.isEdited
            });

            this.model = options.model;
        },

        markAsInvalid: function() {
            if (this.view) {
                this.view.markAsInvalid();
            }
            this.isInvalid = true;
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-filter', location = 'content/templates/issuenav-filter.soy' */
// This file was automatically generated from issuenav-filter.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavFilter.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavFilter == 'undefined') { JIRA.Templates.IssueNavFilter = {}; }


JIRA.Templates.IssueNavFilter.collapsedFiltersPanel = function(opt_data, opt_ignored) {
  return '<a class="toggle-filter-panel" href="#" title="' + soy.$$escapeHtmlAttribute(AJS.format("Dock the filters panel ({0})",'[')) + '"></a>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavFilter.collapsedFiltersPanel.soyTemplateName = 'JIRA.Templates.IssueNavFilter.collapsedFiltersPanel';
}


JIRA.Templates.IssueNavFilter.filtersPanel = function(opt_data, opt_ignored) {
  return '<div class="filters-content"><h4 class="filter-title">' + soy.$$escapeHtml("Filters") + '</h4><ul class="filter-options"><li><a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/issues/?jql=" class="new-search aui-button aui-button-light" title="' + soy.$$escapeHtmlAttribute("Create a new search filter") + '">' + soy.$$escapeHtml("New filter") + '</a></li><li><a class="find-filters" href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/secure/ManageFilters.jspa?filterView=search">' + soy.$$escapeHtml("Find filters") + '</a></li></ul><div class="filter-panel-system-container"></div><div class="filter-panel-favourites-container"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavFilter.filtersPanel.soyTemplateName = 'JIRA.Templates.IssueNavFilter.filtersPanel';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-filter', location = 'content/js/search/filters/FilterPanelView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.FilterPanelView");

    /**
     * The collapsible filters panel.
     * <p/>
     * Lists system filters and the user's favourite filters.
     */
    JIRA.Issues.FilterPanelView = JIRA.Issues.BaseView.extend({
        events: {
            "simpleClick .system-filters a.filter-link:not(.requires-login)": "_onClickFilter",
            "simpleClick .new-search": "_onClickNewSearch",
            "click .ui-dock": "_onDockFilterPanelClick",
            "click .ui-undock": "_onUndockFilterPanelClick"
        },

        collapsedTemplate: JIRA.Templates.IssueNavFilter.collapsedFiltersPanel,

        template: JIRA.Templates.IssueNavFilter.filtersPanel,

        /**
         * @param {object} options
         */
        initialize: function(options) {

            _.bindAll(this, "adjustFavouriteFiltersHeight");
            if (options.easeOff) {
                this._adjustFavouriteFiltersHeight = _.debounce(this._adjustFavouriteFiltersHeight, options.easeOff);
            }
            JIRA.Issues.onVerticalResize(this.adjustFavouriteFiltersHeight);

            // Resolved when system and favourite filters are rendered
            this.panelReady = new jQuery.Deferred();

            JIRA.bind(JIRA.Events.LAYOUT_RENDERED, _.bind(function() {
                this._splitViewSidebarElement = AJS.$(".list-results-panel:first");
            }, this));
        },

        /**
         * Adjust the height of the favourite filters list.
         *
         * @private
         */
        adjustFavouriteFiltersHeight: function() {
            var feedbackLinkHeight = AJS.$(".jira-feedback-link-container.subtle-style").outerHeight(true);
            var feedbackLinkOffset = feedbackLinkHeight ? feedbackLinkHeight + 10 : 0;
            var filterList = this.$(".favourite-filters");
            var filterListTop = filterList.length && filterList.offset().top;
            var windowHeight = window.innerHeight;

            filterList.css("height", windowHeight - filterListTop - feedbackLinkOffset);
        },

        /**
         * When the dock filter link is clicked
         * @private
         */
        _onDockFilterPanelClick: function() {
            AJS.$('.navigator-container').removeClass('navigator-sidebar-collapsed');
        },

        /**
         * When the undock filter link is clicked.
         * @private
         */
        _onUndockFilterPanelClick: function() {
            AJS.$('.navigator-container').addClass('navigator-sidebar-collapsed');
        },

        toggleDockState: function() {
            this.$el.popoutSidebar("toggle");
        },

        _onClickFilter: function(e) {
            e.preventDefault();
            var filterId = jQuery(e.target).data("id");
            this.trigger("filterSelected", filterId);
        },

        _onClickNewSearch: function(e) {
            e.preventDefault();
            this.trigger("filterSelected", null);
        },

        render: function() {
            if (!this.model.isDocked()) {
                AJS.$('.navigator-container').addClass('navigator-sidebar-collapsed');
                this._renderCollapsed();
            } else {
                AJS.$('.navigator-container').removeClass('navigator-sidebar-collapsed');
                this._renderOpen();
            }

            var dockingShortcut = AJS.KeyboardShortcut.getKeyboardShortcutKeys('toggle.filter.panel');
            this.$el.popoutSidebar({
                isDocked: this.model.isDocked(),
                expandedWidth: this.model.getWidth(),
                renderExpanded: _.bind(this._renderOpen, this),
                renderCollapsed: _.bind(this._renderCollapsed, this),
                undockText: "Undock",
                undockTitle: AJS.format("Undock the filter panel so it is hidden when not being focused (Type \'\'{0}\'\')", dockingShortcut),
                dockText: "Dock",
                dockTitle: AJS.format("Dock the filter panel so you can always see the list of filters (Type \'\'{0}\'\')", dockingShortcut),
                toggleTarget: ".filter-title:first",
                persist: _.bind(function(isDocked, width) {
                    this.model.setDocked(isDocked);
                    this.model.setWidth(width);
                }, this),
                resize: _.bind(function() {
                    if (this._splitViewSidebarElement) this._splitViewSidebarElement.sidebar("updatePosition");
                }, this)
            });

            if (this.model.shouldShowDockIntro()) {
                this.$el.popoutSidebar("collapse", false);
            }

            if (this.model.isDocked()) {
                this.$el.popoutSidebar("renderDockState");
            }
            this._fireDockAnalytics();
            this.panelReady.resolve();

            return this.$el;
        },

        _fireDockAnalytics: function() {
            if (localStorage.getItem("dockStatesAnalyticsEnabled")) {
                var docked = this.model.isDocked();
                if (localStorage.getItem("dockStateAnalytic") !== "" + docked) {
                    localStorage.setItem("dockStateAnalytic", docked);
                    JIRA.Issues.Application.execute("analytics:trigger", "kickass.filters.docked", {
                        isDocked: this.model.isDocked()
                    });
                }
            }
        },

        /**
         * Render the collapsed filter panel.
         *
         * @return {JIRA.Issues.FilterPanelView} <tt>this</tt>
         * @private
         */
        _renderCollapsed: function() {
            var $feedback = jQuery(".jira-feedback-link-container.subtle-style").detach().addClass("left noborder");
            this.$el.addClass("collapsed").html(this.collapsedTemplate({isDocked: this.model.isDocked()}));
            this.trigger("renderCollapsed");
            JIRA.Issues.triggerHorizontalResize();
            $feedback.appendTo("body");
            return this;
        },

        /**
         * Render the open filter panel.
         *
         * @return {JIRA.Issues.FilterPanelView} <tt>this</tt>
         * @private
         */
        _renderOpen: function() {
            var $feedback = jQuery(".jira-feedback-link-container.subtle-style").detach().removeClass("left noborder");
            this.$el.removeClass("collapsed");

            this.$el.width(this.model.getWidth());
            this.$el.html(this.template({}));

            this.trigger("renderOpen");
            $feedback.appendTo(this.$el);

            JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [this.$el, JIRA.CONTENT_ADDED_REASON.filterPanelOpened]);
            JIRA.Issues.triggerHorizontalResize();
            return this;
        },

        _renderSelectedFilter: function() {
            //FIXME Disabled until both views are moved to FilterComponent
            //this.favouriteFiltersController.activateFilter(this.model.get("activeFilter"));
            //this.systemFilters.activateFilter(this.model.get("activeFilter"));
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-filter', location = 'content/js/search/filters/Browser.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.Browser");

    /** @deprecated */
    JIRA.Issues.Browser = {
        /** @deprecated since JIRA 6.3. Use window.innerWidth if you absolutely need to know. You shouldn't, though. */
        getWindowWidth: function() {
            return window.innerWidth;
        }
    };
}(AJS.$));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-filter', location = 'content/js/search/filters/FilterPanelModel.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.FilterPanelModel");

    var IS_DOCKED_STORAGE_KEY = "issues.sidebar.docked";
    var WIDTH_STORAGE_KEY = "issues.sidebar.width";

    /**
     * The state of the filters panel: favourite filter data, system filter data
     * .
     */
    JIRA.Issues.FilterPanelModel = JIRA.Issues.BaseModel.extend({
        properties: [
            "activeFilter"
        ],

        defaults: {
            "activeFilter": null
        },

        /**
         * @param {object} attributes
         * @param {object} options
         * @param {object[]} options.systemFilters
         */
        initialize: function(attributes, options) {
            _.extend(this, _.defaults(options, {
                storage: window.localStorage
            }));
        },

        setDocked: function(state) {
            this._getStorage().setItem("dockStatesAnalyticsEnabled", true);
            return this._getStorage().setItem(IS_DOCKED_STORAGE_KEY, state);
        },

        setWidth: function(width) {
            return this._getStorage().setItem(WIDTH_STORAGE_KEY, width);
        },

        getWidth: function() {
            var storedWidth = parseInt(this._getStorage().getItem(WIDTH_STORAGE_KEY), 10);
            return ((storedWidth > 0) ? storedWidth : 200);
        },


        _getStorage: function() {
            return this.storage || window.localStorage;
        },

        isDockedPrefGiven: function() {
            return this._getStorage().getItem(IS_DOCKED_STORAGE_KEY) !== null;
        },

        shouldShowDockIntro: function() {
            return !this.isDocked() && !this.isDockedPrefGiven();
        },

        isExpanded: function() {
            //Showing dock intro should collapse the filter panel
            return this.shouldShowDockIntro() ? false : this.isDocked();
        },

        /**
         *
         * @return {boolean}
         */
        isDocked: function() {
            var storage = this._getStorage();
            //dock the sidebar by default or if the user has chosen to do so.
            return storage.getItem(IS_DOCKED_STORAGE_KEY) == null || storage.getItem(IS_DOCKED_STORAGE_KEY) === "true";
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-filter', location = 'content/js/search/filters/FilterModule.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.FilterModule");

    /**
     * Interface to the filter system.
     */
    JIRA.Issues.FilterModule = JIRA.Issues.BaseEvented.extend({
        initialize: function(options) {
            this._searchPageModule = options.searchPageModule;

            this.filterPanelModel = options.filterPanelModel || new JIRA.Issues.FilterPanelModel({}, {
                searchPageModule: options.searchPageModule
            });

            this.filtersComponent = new JIRA.Components.Filters({
                systemFilters: options.systemFilters,
                searchPageModule: this._searchPageModule
            });

            this.filtersComponent.on("newFilter", function(newFilterModel) {
                this._searchPageModule.filterModuleSaved(newFilterModel);

                if (JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                    this._searchPageModule.setSessionSearch(newFilterModel);
                }
            }, this);

            this.filtersComponent.on("filterRemoved", function(args) {
                this.trigger("filterRemoved", args);
            }, this);

            this.filtersComponent.on("filterUnfavourited", function(args) {
                this.trigger("filterUnfavourited", args);
            }, this);

            this.filtersComponent.on("filterSelected", this._onFilterSelected, this);

            this.filtersComponent.on("filterDiscarded", function() {
                this._searchPageModule.discardFilterChanges();
            }, this);

            this.filtersComponent.on("savedFilter", function(filterModel) {
                this._searchPageModule.setSessionSearch(filterModel);
                this.filtersComponent.highlightFilter(filterModel);
            }, this);

            this.filtersComponent.on("list:render", function() {
                var currentFilter = this._searchPageModule.getFilter();
                if (currentFilter) {
                    var filterToActivateId = currentFilter.id;
                    var filterToActivate = this.filtersComponent.getFilterByIdFromExistingCollections(filterToActivateId);
                    this.filterPanelModel.set("activeFilter", filterToActivate);
                }
            }, this);

            this._searchPageModule.on('change changeFilterProps', function() {
                this.filtersComponent.updateFilterHeader({
                    model: this._searchPageModule.getFilter(),
                    isPendingSearch: false,
                    isEdited: this._searchPageModule.isDirty()
                });
            }, this);

            this.filtersComponent.fetchFavouriteFilters();

            this.filterPanelModel.bind("change:activeFilter", this._markFilterAsActive, this);
            this.filterPanelModel.set("activeFilter", this._searchPageModule.getFilter());
            this._searchPageModule.bind("change:filter", function(searchPageModule, newFilter) {
                this.filterPanelModel.set("activeFilter", newFilter);
            }, this);
        },

        canEditColumns: function() {
            var filter = this._searchPageModule.getFilter();
            return filter && filter.isMyFilter();
        },

        /**
         * Retrieve system filter information via AJAX.
         * <p/>
         * System filter information is not present on the stand alone view issue page.
         *
         * @return {jQuery.Deferred} a deferred that is resolved after system filter information has been retrieved.
         */
        initSystemFilters: function() {
            return this.filtersComponent.fetchSystemFilters();
        },

        /**
         * Finds the filter with the given id. Attempts to fetch from the server if it does not exist. Returns a promise.
         */
        getFilterById: function(filterId) {
            return this.filtersComponent.getFilterById(filterId);
        },

        /**
         * Creates a FilterPanelView and renders it into the provided elements
         * @param els - a map of elements
         */
        createView: function(els) {
            this.filterPanelView = new JIRA.Issues.FilterPanelView({
                el: els.$filterPanelEl,
                model: this.filterPanelModel,
                searchPageModule: this._searchPageModule,
                easeOff: (!!jQuery.browser.msie && jQuery.browser.version <= 8) ? 500 : 0
            });

            this.filterPanelView.on("renderOpen", function() {
                this.filtersComponent.showSystemFilters(this.filterPanelView.$el.find(".filter-panel-system-container"));
                this.filtersComponent.showFavouriteFilters(this.filterPanelView.$el.find(".filter-panel-favourites-container"));
                this._markFilterAsActive();
                this.filterPanelView.adjustFavouriteFiltersHeight();
            }, this);

            this.filterPanelView.on("filterSelected", this._onFilterSelected, this);

            this.filterPanelView.render();

            return this.filterPanelView;
        },

        _markFilterAsActive: function() {
            var activeFilter = this.filterPanelModel.get("activeFilter");
            this.filtersComponent.highlightFilter(activeFilter);
        },

        toggleFilterPanel: function() {
            this.filterPanelView.toggleDockState();
        },

        createHelptipForFilterPanelDocking: function(weight) {
            var tip;
            var filterPanelModel = this.filterPanelModel;
            var filterPanelView = this.filterPanelView;

            if (filterPanelModel.shouldShowDockIntro() && filterPanelView.$el.is(":visible")) {
                tip = new AJS.HelpTip({
                    id: "filters-dock-intro",
                    title: "Did you notice?",
                    bodyHtml: "You can dock the filter bar to always show your list of filters.",
                    anchor: ".ui-dock",
                    isSequence: true,
                    weight: weight,
                    callbacks: {
                        beforeShow: function() {
                            filterPanelView.$el.popoutSidebar("expand", false);
                        },
                        init: function() {
                            if (filterPanelView.$el.popoutSidebar("isUndocked")) {
                                filterPanelView.$el.popoutSidebar("unbindHoverIntent");
                            }
                        },
                        hide: function() {
                            if (filterPanelView.$el.popoutSidebar("isUndocked")) {
                                filterPanelView.$el.popoutSidebar("bindHoverIntent");
                                filterPanelView.$el.popoutSidebar("collapse");
                            }
                        }
                    }
                });
            }
            return tip;
        },

        _onFilterSelected: function(filterId) {
            if (filterId === null) {
                this._searchPageModule.resetToBlank({isNewSearch: true});
            } else {
                this._searchPageModule.resetToFilter(filterId);
            }
        },
        
        updateFilterHeader: function(options) {
            options = options || {};
            var isEdited = options.isEdited || false;
            var isPendingSearch = options.isPendingSearch || false;

            this.filtersComponent.updateFilterHeader({
                isEdited: isEdited,
                isDirty: isPendingSearch
            });
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-filter', location = 'content/js/search/util/WindowPositioning.js' */
(function() {
    "use strict";

    /**
     * An <tt>AJS.InlineLayer</tt> positioning controller that ensures the layer doesn't overflow the bottom of the window.
     */
    JIRA.Issues.WindowPositioning = AJS.InlineLayer.StandardPositioning.extend({
        /**
         * @param {object} offset The offset from which to calculate the overflow.
         * @return {Number} The amount by which the layer overflows the window.
         * @private
         */
        _calculateOverflow: function(offset) {
            var isFixed = this.layer().css("position") === "fixed";
            var layerBottom = offset.top + this.layer().outerHeight(true);
            var windowHeight = window.innerHeight;
            var windowScroll = jQuery(window).scrollTop();

            if (isFixed) {
                return Math.max(0, layerBottom - windowHeight);
            } else {
                return Math.max(0, layerBottom - windowScroll - windowHeight);
            }
        },

        left: function() {
            var offset = this._super();
            var overflow = this._calculateOverflow(offset);

            if (overflow > 0) {
                offset.left += this.offsetTarget().outerWidth();
                offset.top -= overflow;
            }

            return offset;
        },

        right: function() {
            var offset = this._super();
            var overflow = this._calculateOverflow(offset);

            if (overflow > 0) {
                offset.left -= this.offsetTarget().outerWidth();
                offset.top -= overflow;
            }

            return offset;
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common-templates', location = 'content/templates/issuenav.soy' */
// This file was automatically generated from issuenav.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNav.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNav == 'undefined') { JIRA.Templates.IssueNav = {}; }


JIRA.Templates.IssueNav.issueTable = function(opt_data, opt_ignored) {
  return '<thead><tr></tr></thead><tbody></tbody>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.issueTable.soyTemplateName = 'JIRA.Templates.IssueNav.issueTable';
}


JIRA.Templates.IssueNav.columnHeader_issuetype = function(opt_data, opt_ignored) {
  return '<th class="issue-type issue-icon-result persist-result"><div>' + soy.$$escapeHtml("T") + '</div></th>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.columnHeader_issuetype.soyTemplateName = 'JIRA.Templates.IssueNav.columnHeader_issuetype';
}


JIRA.Templates.IssueNav.column_issuetype = function(opt_data, opt_ignored) {
  return '<td class="issue-type issue-icon-result persist-result"><img src="' + soy.$$escapeHtml(opt_data.issue.fields.issuetype.iconUrl) + '" alt="' + soy.$$escapeHtml(opt_data.issue.fields.issuetype.name) + '" title="' + soy.$$escapeHtml(opt_data.issue.fields.issuetype.description) + '" align="absmiddle" border="0" height="16" width="16"></td>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.column_issuetype.soyTemplateName = 'JIRA.Templates.IssueNav.column_issuetype';
}


JIRA.Templates.IssueNav.columnHeader_keysummary = function(opt_data, opt_ignored) {
  return '<th class="issue-key persist-result"><div>' + soy.$$escapeHtml("Key") + '</div></th><th class="issue-summary issue-text-result persist-result"><div>' + soy.$$escapeHtml("Summary") + '</div></th>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.columnHeader_keysummary.soyTemplateName = 'JIRA.Templates.IssueNav.columnHeader_keysummary';
}


JIRA.Templates.IssueNav.column_keysummary = function(opt_data, opt_ignored) {
  return '<td class="issue-key-summary issue-text-result persist-result" colspan="2"><div><a href="' + soy.$$escapeHtml(opt_data.contextPath) + '/browse/' + soy.$$escapeHtml(opt_data.issue.key) + '" class="issue"><span class="secondary-text">' + soy.$$escapeHtml(opt_data.issue.key) + '</span>' + soy.$$escapeHtml(opt_data.issue.fields.summary) + '</a></div></td>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.column_keysummary.soyTemplateName = 'JIRA.Templates.IssueNav.column_keysummary';
}


JIRA.Templates.IssueNav.columnHeader_status = function(opt_data, opt_ignored) {
  return '<th class="issue-status"><div>' + soy.$$escapeHtml("Status") + '</div></th>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.columnHeader_status.soyTemplateName = 'JIRA.Templates.IssueNav.columnHeader_status';
}


JIRA.Templates.IssueNav.column_status = function(opt_data, opt_ignored) {
  return '<td class="issue-status"><div class="status-lozenge">' + soy.$$escapeHtml(opt_data.issue.fields.status.name) + '</div></td>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.column_status.soyTemplateName = 'JIRA.Templates.IssueNav.column_status';
}


JIRA.Templates.IssueNav.columnHeader_assignee = function(opt_data, opt_ignored) {
  return '<th class="issue-user"><div>' + soy.$$escapeHtml("Assignee") + '</div></th>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.columnHeader_assignee.soyTemplateName = 'JIRA.Templates.IssueNav.columnHeader_assignee';
}


JIRA.Templates.IssueNav.column_assignee = function(opt_data, opt_ignored) {
  return '<td class="issue-user">' + ((opt_data.issue.fields.assignee) ? '<img src="' + soy.$$escapeHtml(opt_data.issue.fields.assignee.avatarUrls['16x16']) + '" alt="' + soy.$$escapeHtml(opt_data.issue.fields.assignee.name) + '" height="16" width="16" /><a class="user-hover" rel="' + soy.$$escapeHtml(opt_data.issue.fields.assignee.name) + '" href="#">' + soy.$$escapeHtml(opt_data.issue.fields.assignee.displayName) + '</a>' : soy.$$escapeHtml("Unassigned")) + '</td>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.column_assignee.soyTemplateName = 'JIRA.Templates.IssueNav.column_assignee';
}


JIRA.Templates.IssueNav.columnHeader_updated = function(opt_data, opt_ignored) {
  return '<th class="issue-datetime"><div>' + soy.$$escapeHtml("Updated") + '</div></th>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.columnHeader_updated.soyTemplateName = 'JIRA.Templates.IssueNav.columnHeader_updated';
}


JIRA.Templates.IssueNav.column_updated = function(opt_data, opt_ignored) {
  return '<td class="issue-datetime"><time datetime="' + soy.$$escapeHtml(opt_data.issue.fields.updated) + '">' + soy.$$escapeHtml(opt_data.TMP_FORMATTED_DATE) + '</time></td>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.column_updated.soyTemplateName = 'JIRA.Templates.IssueNav.column_updated';
}


JIRA.Templates.IssueNav.columnHeader_resolution = function(opt_data, opt_ignored) {
  return '<th class="issue-resolution"><div>' + soy.$$escapeHtml("Resolution") + '</div></th>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.columnHeader_resolution.soyTemplateName = 'JIRA.Templates.IssueNav.columnHeader_resolution';
}


JIRA.Templates.IssueNav.column_resolution = function(opt_data, opt_ignored) {
  return '<td class="issue-resolution">' + ((opt_data.issue.fields.resolution) ? soy.$$escapeHtml(opt_data.issue.fields.resolution.name) : soy.$$escapeHtml("Unresolved")) + '</td>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.column_resolution.soyTemplateName = 'JIRA.Templates.IssueNav.column_resolution';
}


JIRA.Templates.IssueNav.issueResultsError = function(opt_data, opt_ignored) {
  return '<tr class="error"><td colspan="' + soy.$$escapeHtml(opt_data.columnCount) + '">' + soy.$$escapeHtml(opt_data.errorText) + '</td></tr>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.issueResultsError.soyTemplateName = 'JIRA.Templates.IssueNav.issueResultsError';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-table', location = 'content/js/components/table/ColumnPicker.js' */
(function(){
    "use strict";

    /**
     * A module that adds the issue nav specific logic to the generic column picker.
     */
    JIRA.Issues.ColumnPicker = JIRA.Components.ColumnPicker.extend({

        initialize: function (attr, options) {
            var providers = [this._getUserColumnProvider(), this._getFilterColumnProvider()];
            if (JIRA.isAdmin()) {
                providers.push(this._getSystemColumnProvider());
            }
            JIRA.Components.ColumnPicker.prototype.initialize.call(this, null, {
                providers: providers
            });
            this.search = options.search;
            this.search.on("change:filter", function() {
                var filterModel = this.filterColumn;
                var isEditDisabled = filterModel.isEditDisabled();
                var isColumnConfigDisabled = filterModel.isDisabled();
                filterModel.trigger("change:isDisabled", filterModel, isColumnConfigDisabled);
                filterModel.trigger("change:editDisabled", filterModel, isColumnConfigDisabled || isEditDisabled);
            }, this);
        },

        /**
         * Is the system filter column config in play.
         * @returns {boolean}
         */
        isSystemMode: function () {
          return this.columnPickerModel.getColumnConfig() === "system";
        },

        sanitizeColumnConfig: function(columnConfig) {
            columnConfig = columnConfig.toLowerCase();
            var shouldOverrideSystem = columnConfig === "system" && !this.isSystemMode();
            return shouldOverrideSystem ? "user" : columnConfig;
        },

        syncColumns: function(newColumnConfigName, columns) {
            newColumnConfigName = this.sanitizeColumnConfig(newColumnConfigName);
            return JIRA.Components.ColumnPicker.prototype.syncColumns.call(this, newColumnConfigName, columns);
        },

        clearFilterConfiguration: function() {
            this.filterColumn.unset('columns');
            this.filterColumn.unset('savedColumns');
        },

        setCurrentColumnConfig: function(columnConfig) {
            columnConfig = this.sanitizeColumnConfig(columnConfig);
            return JIRA.Components.ColumnPicker.prototype.setCurrentColumnConfig.call(this, columnConfig);
        },

        _getFilterColumnProvider: function() {
            var instance = this;
            this.filterColumn = JIRA.Issues.ColumnConfigModel.create(
                "filter",
                "Filter",
                {
                    url: function() {
                        return AJS.contextPath() + '/rest/api/2/filter/' + instance.search.getState().filter + '/columns';
                    },
                    isDisabled: function() {
                        return !instance.search.getFilter() || instance.search.getFilter().getIsSystem();
                    },
                    isEditDisabled: function() {
                        return !instance.search.filterModule.canEditColumns();
                    },
                    shouldRefreshSearchOnActivation: function() {
                        //If the filter has configured columns, refresh the search on activation
                        return this.has("savedColumns");
                    },
                    shouldCloseOnActivation: function() {
                        //If the filter has configured columns, close the column picker on activation
                        return this.has("savedColumns");
                    },
                    shouldLoadDefaultsOnActivation: function() {
                        //If the filter has not  configured columns, load the default columns
                        return !this.has("savedColumns");
                    },
                    defaultColumns: _.bind(function(){
                        //If a filter doesn't have columns, then it will use the user columns by default
                        //Need to retrieve the user columns and set that as the selected columns
                        if (this.userColumns.has("columns")) {
                            var deferred = new jQuery.Deferred();
                            deferred.resolve(_.map(this.userColumns.getColumns(), function(item){return {value: item};}));
                            return deferred.promise();
                        } else {
                            return jQuery.ajax(this.userColumns.url()).promise();
                        }
                    }, this)
                }
            );
            return this.filterColumn;
        },

        _getSystemColumnProvider: function() {
            //Adding a toggle for 'system' columns if user is an admin

            return JIRA.Issues.ColumnConfigModel.create(
                "system",
                "System",
                {
                    url: _.lambda(AJS.contextPath() + '/rest/api/2/settings/columns'),
                    defaultColumns: function(){
                        //Load columns from our REST endpoint
                        return jQuery.ajax(this.url()).promise();
                    },
                    shouldRefreshSearchOnActivation: function() {
                        //Always refresh the search on activation
                        return true;
                    },
                    shouldCloseOnActivation: function() {
                        //Never close the column picker on activation
                        return false;
                    },
                    shouldLoadDefaultsOnActivation: function() {
                        //Always load the default columns
                        return true;
                    },
                    shouldRevertOnHide: function() {
                        return false;
                    }
                }
            );
        },

        _getUserColumnProvider: function() {
            this.userColumns = JIRA.Issues.ColumnConfigModel.create("user",
                "My Defaults",
                {
                    url: _.lambda(AJS.contextPath() + '/rest/api/2/user/columns')
                }
            );
            return this.userColumns;
        }
    });

    JIRA.Issues.ColumnPicker.create = function (options) {
       return new JIRA.Issues.ColumnPicker(null, options);
    };
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-table', location = 'content/js/components/table/IssueTableView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.IssueTableView");

    /**
     * The issue table rendered in <tt>JIRA.Issues.FullScreenLayout</tt>.
     */
    JIRA.Issues.IssueTableView = JIRA.Issues.BaseView.extend({
        _closeSystemModeMessage: function() {
            if (this.currentMessage) {
                this.currentMessage.close();
                this.currentMessage = null;
            }
        },

        _showSystemModeMessage: function() {
            if (this.currentMessage) return; // Message already there, not need to display a new one

            var flag = require("jira/flag");
            var $msg = flag.showMsg('', "You are on System Mode. The column changes might affect all users. \u003ca href=# class=exit\u003eExit System Mode\u003c/a\u003e.", {
                type: 'warning',
                close: 'never'
            });

            AJS.$($msg).find(".exit").click(_.bind(function(e) {
                e.preventDefault();
                this.columnConfig.setCurrentColumnConfig("user");
                this._closeSystemModeMessage();
            }, this));

            this.currentMessage = $msg;
        },

        syncSystemModeMessage: function() {
            var isSystemMode = this.columnConfig.isSystemMode();
            if (isSystemMode) {
                this._showSystemModeMessage();
            } else {
                this._closeSystemModeMessage();
            }
        },

        /**
         * @param {object} options
         * @param {JIRA.Issues.SearchModule} options.search The application's <tt>JIRA.Issues.SearchModule</tt> instance.
         * @param {JIRA.Issues.SearchResults} options.searchResults The application's <tt>JIRA.Issues.SearchResults</tt> instance.
         */
        initialize: function(options) {
            this.columnConfig = options.columnConfig;
            this.columnConfig.on("change:columnConfig", this.syncSystemModeMessage, this);
            JIRA.Issues.onVerticalResize(_.bind(this.adjustColumnConfigHeight, this));
        },

        /**
         * Prepare to be removed, unbinding all event handlers, etc.
         */
        deactivate: function() {
            JIRA.Issues.offVerticalResize(this.adjustColumnConfigHeight);
        },

        /**
         * Render the issue table after a search completes.
         * <p/>
         * Called when an operation in <tt>searchPromise</tt> completes.
         *
         * @param {object} el The search payload.
         * @private
         */
        _onSearchDone: function(el) {
            this.columnConfig.setElement(el.find(".column-picker-trigger-container")).render();
        },

        adjustColumnConfigHeight: function() {
            this.columnConfig.adjustHeight();
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-table', location = 'content/js/components/table/HeaderOperationsView.js' */
(function(){
    "use strict";

    /**
     * Handles adding an ajax-backed dialog to the tools menu
     */
    JIRA.Issues.IssueTableHeaderOperationsView = JIRA.Issues.BaseView.extend({

        initialize: function(options) {
            _.bindAll(this,
                "_onSearchSuccess",
                "_updateFilterPageResources");

            _.extend(this, options);
            this.initTools();
            this.initViews();
            this.initShare();

            this._results = this.search.getResults();
            this._results.onNewPayload(this._onSearchSuccess);
        },

        initViews: function() {
            var searchPageModule = this.searchPageModule;
            searchPageModule.on("change", this._updateFilterPageResources);
            this._updateFilterPageResources();

            new JIRA.Issues.Tipsy({
                el: this.$el.find(".header-views"),
                showCondition: ":not(.active)"
            });

            var spinnerTimeout = this._spinnerTimeoutKeeper(".header-views");

            AJS.Dropdown.create({
                styleClass: 'header-views-menu aui-style-default',
                trigger: AJS.$(".header-views", this.$el),
                ajaxOptions: function() {
                    var data = {jql: searchPageModule.getEffectiveJql()};
                    var filter = searchPageModule.getFilter();

                    if (filter && !filter.getIsSystem()) {
                        data.filterId = filter.getId();
                        if (searchPageModule.isDirty()) {
                            data.jql = searchPageModule.getJql();
                            data.modified = true;
                        }
                    }
                    spinnerTimeout.start();

                    return {
                        url: AJS.contextPath() + "/rest/issueNav/1/issueNav/operations/views",
                        type: "POST",
                        headers: JIRA.Issues.XsrfTokenHeader,
                        data: data,
                        dataType: "json",
                        cache: false,
                        formatSuccess: function(data) {
                            spinnerTimeout.end();
                            return AJS.$(JIRA.Templates.IssueNavTable.views({
                                sections: data,
                                contextPath: AJS.contextPath()
                            }));
                        }
                    };
                }
            });
        },

        initTools: function () {
            var instance = this;
            var searchPageModule = this.searchPageModule;

            // override use-cols click to use user columns
            AJS.$("body").delegate("#use-cols", "click", function(e) {
                e.preventDefault();
                instance.searchPageModule.columnConfig.setCurrentColumnConfig("user");
                instance.searchPageModule.columnConfig.refreshSearchWithColumns();
            });

            // override use-filter-cols click to use filter columns
            AJS.$("body").delegate("#use-filter-cols", "click", function(e) {
                e.preventDefault();
                instance.searchPageModule.columnConfig.setCurrentColumnConfig("filter");
                instance.searchPageModule.columnConfig.refreshSearchWithColumns();
            });

            new JIRA.Issues.Tipsy({
                el: this.$el.find(".header-tools"),
                showCondition: ":not(.active)",
                tipsy: {
                    gravity: "ne"
                }
            });
            var spinnerTimeout = this._spinnerTimeoutKeeper(".header-tools");

            AJS.Dropdown.create({
                styleClass: 'header-tools-menu',
                trigger: AJS.$(".header-tools", instance.$el),
                ajaxOptions: function() {
                    var data;
                    var filter = searchPageModule.getFilter();

                    data = {
                        jql: searchPageModule.getEffectiveJql(),
                        searchResultsTotal: instance._results.getTotal(),
                        searchResultsPages: instance._results.getNumberOfPages(),
                        useColumns: instance.searchPageModule.columnConfig.getCurrentColumnConfig().getName() !== "user",
                        skipColumns: searchPageModule.getActiveLayout().id === "split-view" //Skip columns for split-view
                    };

                    if (filter && !filter.getIsSystem()) {
                        data.filterId = filter.getId();
                        if (searchPageModule.isDirty()) {
                            data.jql = searchPageModule.getJql();
                        }
                    }

                    spinnerTimeout.start();

                    return {
                        url: AJS.contextPath() + "/rest/issueNav/1/issueNav/operations/tools",
                        type: "POST",
                        headers: JIRA.Issues.XsrfTokenHeader,
                        data: data,
                        dataType: "json",
                        cache: false,
                        formatSuccess: function(data) {
                            spinnerTimeout.end();
                            if(data && data.length === 0) {
                                return AJS.$('<div class="menu-empty-content"></span>' + "No Available Option(s)" + '<div>');
                            } else {
                                return AJS.$(JIRA.Templates.IssueNavTable.tools({
                                    groups: data,
                                    contextPath: AJS.contextPath()
                                }));
                            }
                        }
                    };
                }
            });
        },

        initShare: function() {
            //Init the tipsy tooltip for the share button
            new JIRA.Issues.Tipsy({
                el: this.$el.find(".issuenav-share"),
                showCondition: ":not(.active)"
            });
        },

        _onSearchSuccess: function() {
            //JRADEV-18219 Only hide header-tools. header-views should always be visible, even for searches with 0 results
            AJS.$(".header-tools").toggleClass('hidden', this.search.getResults().getDisplayableTotal() === 0);
        },

        _updateFilterPageResources: function() {
            // These hidden input params are used by javascript in com.atlassian.jira.gadgets:searchrequestview-charts
            // to load custom dialogs for chart / dashboard view menu items
            // The '.operations-view-data .parameters' element updates AJS.params, which is a legacy bus for passing
            // variables around the page
            var $fieldset = this.$el.find('.operations-view-data > fieldset');
            var searchPageModule = this.searchPageModule;

            $fieldset.empty();

            if (searchPageModule.getFilter() && !searchPageModule.isDirty()) {
                AJS.$('<input type="hidden" id="filterId" />').val(searchPageModule.getFilter().getId()).appendTo($fieldset);
                AJS.$('<input type="hidden" id="jql" />').val("").appendTo($fieldset);
            }
            else {
                AJS.$('<input type="hidden" id="filterId" />').val("");
                AJS.$('<input type="hidden" id="jql" />').val(searchPageModule.getJql()).appendTo($fieldset);
            }

            // The gadgets and share plugins (possibly others) get the current
            // filter/JQL from this metadata. Both plugins ignore filter-jql if
            // filter-id is set, so we only set the latter for modified filters.
            var filter = searchPageModule.getFilter();
            var filterID = filter && filter.getId();

            if (filterID && !filter.getIsSystem() && !searchPageModule.isDirty()) {
                AJS.Meta.set("filter-id", filterID);
                AJS.Meta.set("filter-jql", undefined);
            } else {
                AJS.Meta.set("filter-id", undefined);
                AJS.Meta.set("filter-jql", searchPageModule.getEffectiveJql());
            }
        },

        /**
         * Utility timeout keeper container for starting and ending the spinner icon on dropdown menu
         */
        _spinnerTimeoutKeeper: function(element) {
            var spinnerTimeout;

            return {
                start: function() {
                    if (spinnerTimeout) {
                        spinnerTimeout = clearTimeout(spinnerTimeout);
                    }
                    spinnerTimeout = setTimeout(function() {
                        spinnerTimeout = undefined;
                        AJS.$(element).addClass("spinner");
                    }, 1000);
                },

                end: function() {
                    spinnerTimeout = clearTimeout(spinnerTimeout);
                    AJS.$(element).removeClass("spinner");
                }
            };
        }
    });
}());
;
;
/* module-key = 'jira.webresources:jqlautocomplete', location = '/includes/jira/autocomplete/JQLAutoComplete.js' */
define('jira/jql/jql-grammar', function() {
    "use strict";

    /** @exports jira/jql/jql-grammar */
    var grammar = {};

    /** @type {JqlObject[]} */
    grammar.jql_order_by = [
        {value: "ORDER BY", displayName: "ORDER BY"}
    ];
    /** @type {JqlObject[]} */
    grammar.jql_operators = [
        {value: "=", displayName: "="},
        {value: "!=", displayName: "!="},
        {value: "~", displayName: "~"},
        {value: "<=", displayName: "&lt;="},
        {value: ">=", displayName: "&gt;="},
        {value: ">", displayName: "&gt;"},
        {value: "<", displayName: "&lt;"},
        {value: "!~", displayName: "!~"},
        {value: "is not", displayName: "is not"},
        {value: "is", displayName: "is"},
        {value: "not in", displayName: "not in"},
        {value: "in", displayName: "in"},
        {value: "was", displayName: "was"},
        {value: "was not", displayName: "was not"},
        {value: "was in", displayName: "was in"},
        {value: "was not in", displayName: "was not in"},
        {value: "changed", displayName: "changed"}
    ];
    /** @type {JqlObject[]} */
    grammar.jql_logical_operators = [
        {value: "AND", displayName: "AND"},
        {value: "OR", displayName: "OR"}
    ];
    /** @type {JqlObject[]} */
    grammar.jql_logical_operators_and_order_by = grammar.jql_logical_operators.concat(grammar.jql_order_by);
    /** @type {JqlObject[]} */
    grammar.jql_order_by_direction = [
        {value: "ASC", displayName: "ASC"},
        {value: "DESC", displayName: "DESC"}
    ];
    /** @type {JqlObject[]} */
    grammar.empty_operand = [
        {value: "EMPTY", displayName: "EMPTY", types: ["java.lang.Object"]}
    ];
    /** @type {JqlObject[]} */
    grammar.jql_not_logical_operator = [
        {value: "NOT", displayName: "NOT"}
    ];
    /** @type {JqlObject[]} */
    grammar.jql_was_predicates = [
        {value: "AFTER", displayName: "AFTER", type: "java.util.Date", supportsList: "false"},
        {value: "BEFORE", displayName: "BEFORE", type: "java.util.Date", supportsList: "false"},
        {value: "BY", displayName: "BY", type: "com.atlassian.crowd.embedded.api.User", supportsList: "false", auto: "true"},
        {value: "DURING", displayName: "DURING", type: "java.util.Date", supportsList: "true"} ,
        {value: "ON", displayName: "ON", type: "java.util.Date", supportsList: "false"}
    ];
    /** @type {JqlObject[]} */
    grammar.jql_changed_predicates = grammar.jql_was_predicates.concat([
        {value: "FROM", displayName: "FROM", type: "java.lang.String", supportsList: "true", auto: "true"},
        {value: "TO", displayName: "TO", type: "java.lang.String", supportsList: "true", auto: "true"}
    ]);
    /** @type {JqlObject[]} */
    grammar.jql_was_predicates_and_order_by = grammar.jql_was_predicates.concat(grammar.jql_logical_operators_and_order_by);
    /** @type {JqlObject[]} */
    grammar.jql_was_predicates_and_logical_operators = grammar.jql_was_predicates.concat(grammar.jql_logical_operators);
    /** @type {JqlObject[]} */
    grammar.jql_changed_predicates_and_order_by = grammar.jql_changed_predicates.concat(grammar.jql_logical_operators_and_order_by);
    /** @type {JqlObject[]} */
    grammar.jql_changed_predicates_and_logical_operators = grammar.jql_changed_predicates.concat(grammar.jql_logical_operators);

    grammar.REGEXP_ANDS = /^AND\s/i;
    grammar.REGEXP_ORS = /^OR\s/i;
    grammar.REGEXP_NOTS = /^NOT\s/i;
    grammar.REGEXP_SNOT = /^\s+not/i;
    grammar.REGEXP_SIN = /^\s+in/i;
    grammar.REGEXP_SNOT_IN = /^\s+(not\s+in|not|in)/i;
    grammar.REGEXP_COMMA_DELIMITER = /^\s*,/;
    grammar.REGEXP_ASCENDING = /^\s+asc/i;
    grammar.REGEXP_DESCENDING = /^\s+desc/i;
    grammar.REGEXP_ORDER_BY = /^order\s+by/i;
    grammar.REGEXP_WHITESPACE = /^\s/;
    grammar.REGEXP_UNICODE = /^u[a-fA-F0-9]{4}/;
    grammar.REGEXP_FIELD_NAME = /^\s-\scf\[\d\d\d\d\d\]/;
    grammar.REGEXP_NEW_LINE = /[\r\n]/;
    grammar.REGEXP_NUMBER = /\d/;
    grammar.REGEXP_TOKEN_CHAR = /[^=!~<>(),\s&|\]]/;
    grammar.REGEXP_SPECIAL_CHAR = /[{}*\/%+$#@?;\][]/;
    grammar.REGEXP_SPACE_OR_ELSE = /[\s(]/;
    grammar.REGEXP_CHARS_TO_ESCAPE = /[^trn"'\\\s]/;
    grammar.REGEXP_NOTSTART = /^NO?$/i;
    grammar.REGEXP_INSTART = /^IN?$/i;
    grammar.REGEXP_PREDICATE = /^(after|before|by|during|from|on|to)/i;

    return grammar;
});

define('jira/autocomplete/jql-autocomplete', [
    'jira/autocomplete/autocomplete',
    'jira/jql/jql-grammar',
    'jira/jql/util',
    'jira/jql/operator-util',
    'jira/util/data/meta',
    'jira/util/objects',
    'jquery'
], function(
    AutoComplete,
    grammar,
    Util,
    OperatorUtil,
    Meta,
    Objects,
    jQuery
) {
    /*jshint bitwise:true, curly:true, eqeqeq:false, eqnull:true, forin:true, noarg:true, noempty:true, nonew:true, undef:true, indent:4, browser:true, jquery:true */

    /**
     * @typedef {Object} JqlObject
     * @property {String} value - raw string value for the JQL piece.
     * @property {String} displayName - essentially the HTML escaped equivalent of the {@link JqlObject#value}.
     */

    /**
     * @typedef {JqlObject} JqlFunctionName
     * @property isList - "true" or "false"
     * @property {String[]} types - Java class(es) this function object can be type cast to (or was cast from?)
     */

    /**
     * @typedef {JqlObject} JqlFieldName
     * @property {String} cfid - typically of the format cf[12345]
     * @property {String[]} operators - list of valid operators that can be used with field operand (e.g., "=", "in", "is", "is not", etc.)
     * @property {String[]} types - Java class(es) this function object can be type cast to (or was cast from?)
     * @property auto - "true" or "false"
     * @property orderable - "true" or "false"
     * @property searchable - "true" or "false"
     */

    /**
     * Makes an input field capable of offering suggestions for JQL syntax and values one might fill in for fields in JQL.
     *
     * @exports jira/autocomplete/jql-autocomplete
     * @class JQLAutoComplete
     * @extends AutoComplete
     * @param options
     * @param {JQLAutoComplete.MyParser} options.parser - the parser to use for parsing JQL
     * @param {JqlFunctionName[]} options.jqlFunctionNames - Array of of JQL function names
     * @param {JqlFieldName[]} options.jqlFieldNames - Array of JQL fields
     * @param {String} options.autoCompleteUrl - REST endpoint where value suggestions will come from
     * @param {String} options.errorID - ID of the DOM element to output JQL error messages to
     * @returns {Object}
     */
    var JQLAutoComplete = function(options) {

        /** @lends JQLAutoComplete.prototype */
        var that = Objects.begetObject(AutoComplete);

        var parser = options.parser;
        var result;
        var jql_field_names = jQuery.grep(options.jqlFieldNames, function(arrValue) {
            // We only want the searchable fields
            return arrValue.searchable;
        });
        var jql_order_by_field_names = jQuery.grep(options.jqlFieldNames, function(arrValue) {
            // We only want the orderable fields
            return arrValue.orderable;
        });
        var jql_function_names = options.jqlFunctionNames;
        var PARSE_INDICATOR = jQuery("#" + options.errorID);
        var suggestionCount = 0;
        var jqlcolumnnum = jQuery("#jqlcolumnnum");
        var jqlrownum = jQuery("#jqlrownum");
        var autoCompleteUrl = options.autoCompleteUrl || contextPath + "/rest/api/2/jql/autocompletedata/suggestions";

        that.textToSuggestionCursorPosition = function() {
            return that.field.selectionRange().textBefore;
        };


        that.pushSuggestionsOnHtmlStack = function(suggestions, suggestionNodes, htmlParts, listItemIdentifier, mayNeedParenthesis) {
            var length = Math.min(15, suggestions.length);
            for (var i = 0; i < length; i++) {
                var actualValueSug;
                var displayNameSug;
                // We may have an object with displayName and value OR it may just be a string
                if (suggestions[i].value) {
                    var resultSug = suggestions[i];
                    if (result && mayNeedParenthesis) {
                        // This is a hack that adds an initial ( when the value is the first completed in a list
                        // We only do this for suggestions and not moreSuggestions since we know that this is
                        // the position that the values will take, moreSuggestions will be function suggestions
                        actualValueSug = ((result.getNeedsOpenParen()) ? "(" : "") + resultSug.value;
                    }
                    else {
                        actualValueSug = resultSug.value;
                    }
                    displayNameSug = resultSug.displayName;
                }
                else {
                    displayNameSug = suggestions[i];
                    actualValueSug = displayNameSug;
                }
                suggestionNodes.push(actualValueSug);
                htmlParts.push(
                    '<li id="',
                    listItemIdentifier,
                    i,
                    '">',
                    displayNameSug,
                    '</li>'
                );
            }
        };

        /**
         * Order of rendering:
         * 1. Operator suggestions
         * 2. "normal" suggestions
         * 3. More suggestions
         *
         * @param {JqlObject[]} suggestions
         * @param {JqlObject[]} moreSuggestions
         * @param {JqlObject[]} operatorSuggestions
         * @returns {Array}
         */
        that.renderSuggestions = function(suggestions, moreSuggestions, operatorSuggestions) {
            var suggestionNodes = [];

            if (suggestions instanceof Array) {
                if (suggestions.length < 1 && (moreSuggestions && moreSuggestions.length < 1) && (operatorSuggestions && operatorSuggestions.length < 1)) {
                    return suggestionNodes;
                }

                var htmlParts = ['<ul>'];
                if (operatorSuggestions && operatorSuggestions.length > 0) {
                    that.pushSuggestionsOnHtmlStack(operatorSuggestions, suggestionNodes, htmlParts, "jql_operator_suggest_", false);
                }
                that.pushSuggestionsOnHtmlStack(suggestions, suggestionNodes, htmlParts, "jql_value_suggest_", true);
                if (moreSuggestions && moreSuggestions.length > 0) {
                    that.pushSuggestionsOnHtmlStack(moreSuggestions, suggestionNodes, htmlParts, "jql_function_suggest_", false);
                }
                htmlParts.push('</ul>');

                var syntaxHelpLink = jQuery('<a class="syntax-help" target="_jiraHelp"></a>')
                    .attr('title', Meta.get('advanced-search-help-title'))
                    .attr('href', Meta.get('advanced-search-help-url'))
                    .text("Syntax Help");
                var syntaxHelpContainer = jQuery('<div class="syntax-help-container">').append(syntaxHelpLink);

                that.responseContainer
                    .html(htmlParts.join(''))
                    .append(syntaxHelpContainer)
                    .find('li').each(function(i) {
                        suggestionNodes[i] = [jQuery(this), suggestionNodes[i]];
                    });

                that.addSuggestionControls(suggestionNodes);
            }

            return suggestionNodes;
        };

        that.completeField = function(value) {
            var start = that.getReplacementStartIndex(result, value);

            var end = that.getReplacementEndIndex(result, start);

            that.replaceValue(start, end, value);

            // Parse the whole thing again with the full string so we can set the parse/not parse indicator correctly, possibly a third parse, this is starting to get crazy
            var newToken = parser.parse(that.field.val());
            that.updateParseIndicator(newToken);
        };

        that.prepareOperandSuggestions = function(canAutoComplete, fieldName, functionSuggestions, operatorSuggestions, suggestedValue) {
            if (canAutoComplete) {
                var currentSuggestionCount = suggestionCount;
                var fieldValue = (suggestedValue == null) ? ( (result.getLastOperand() === null) ? "" : Util.stripEscapeCharacters(result.getLastOperand())) : suggestedValue;
                var fieldNameValueKey = fieldName + ":" + fieldValue;
                var data = {fieldName: Util.stripEscapeCharacters(fieldName)};
                if (result.getLastOperand() !== null || suggestedValue !== null) {
                    data.fieldValue = fieldValue;
                }
                var includeEmpty = OperatorUtil.isWasOperator(result.getLastOperator());
                if (!that.getSavedResponse(fieldNameValueKey)) {
                    // We only delay the AJAX request, if it comes back and we have already suggested something else then the results will be dropped because of suggestionCount
                    that.dropdownController.dropdown.removeClass("dropdown-ready");
                    that.delay(function() {
                        that._makeRequest({
                            url: autoCompleteUrl,
                            dataType: "json",
                            data: data,
                            success: function(response) {
                                var results;
                                if (response !== null && response.results !== null) {
                                    results = response.results;
                                }
                                else {
                                    results = [];
                                }
                                // Cache the results
                                //append empty
                                if (includeEmpty) {
                                    var suggestion = data.fieldValue;
                                    results = that.appendEmpty(suggestion, results);
                                }
                                that.saveResponse(fieldNameValueKey, results);
                                that.renderSuggestionsForOperands(fieldValue, results, functionSuggestions, operatorSuggestions, currentSuggestionCount);
                            },
                            error: function() {
                                that.renderSuggestionsForOperands(fieldValue, [], functionSuggestions, operatorSuggestions, currentSuggestionCount);
                            }
                        });
                    }, that.queryDelay);
                }
                else {
                    that.renderSuggestionsForOperands(fieldValue, that.getSavedResponse(fieldNameValueKey), functionSuggestions, operatorSuggestions, currentSuggestionCount);
                }
            }
            else {
                // We should at least render the function suggestions
                that.renderSuggestionsForOperands(Util.stripEscapeCharacters(result.getLastOperand()), [], functionSuggestions, operatorSuggestions, suggestionCount);
            }
        };

        that.preparePredicateSuggestions = function(predicateName, suggestedValue) {
            var currentSuggestionCount = suggestionCount;
            if (typeof suggestedValue === "undefined") {
                suggestedValue = null;
            }
            var functionSuggestions = that.slimListForPredicates(suggestedValue, jql_function_names, predicateName);
            that.boldMatchingString(suggestedValue, functionSuggestions);
            var predicateValue = (suggestedValue == null) ? ( (result.getLastOperand() === null) ? "" : Util.stripEscapeCharacters(result.getLastOperand())) : suggestedValue;
            var predicateNameValueKey = predicateName + ":" + predicateValue;
            var data = {predicateName: Util.stripEscapeCharacters(predicateName)};
            if (result.getLastOperand() !== null || suggestedValue !== null) {
                data.predicateValue = predicateValue;
            }
            if (result.getLastFieldName() !== null) {
                data.fieldName = result.getLastFieldName();
                predicateNameValueKey = result.getLastFieldName() + ":" + predicateNameValueKey;
            }
            if (that.predicateSupportsAutoComplete(predicateName)) {
                if (!that.getSavedResponse(predicateNameValueKey)) {
                    // We only delay the AJAX request, if it comes back and we have already suggested something else then the results will be dropped because of suggestionCount
                    that.dropdownController.dropdown.removeClass("dropdown-ready");
                    that.delay(function() {
                        that._makeRequest({
                            url: autoCompleteUrl,
                            dataType: "json",
                            data: data,
                            success: function(response) {
                                var results;
                                if (response !== null && response.results !== null) {
                                    results = response.results;
                                }
                                else {
                                    results = [];
                                }
                                // Cache the results
                                //append empty
                                var suggestion = data.predicateValue;
                                results = that.appendEmpty(suggestion, results);
                                that.saveResponse(predicateNameValueKey, results);
                                that.renderSuggestions(results, functionSuggestions);
                            },
                            error: function() {
                                that.renderSuggestionsForOperands(predicateValue, []);
                            }
                        });
                    }, that.queryDelay);
                }
                else {
                    that.renderSuggestions(that.getSavedResponse(predicateNameValueKey), functionSuggestions);
                }
            }
            else {
                // simply render functions
                that.renderSuggestions([], functionSuggestions);
            }
        };

        that.incompleteOperator = function() {
            var tokens = result.getTokens();
            if (tokens == null || tokens.length < 2) {
                return "";
            }
            else {
                tokens = that.textToSuggestionCursorPosition().split(" ");
                if (tokens.length > 2) {
                    return tokens[tokens.length - 1];
                }
            }
            return "";
        };

        that.incompletePredicateValue = function() {
            var tokens = result.getTokens();
            if (tokens == null || tokens.length < 3) {
                return "";
            }
            else {
                tokens = that.textToSuggestionCursorPosition().split(/[\s(,]+/);
                if (tokens.length > 3) {
                    return tokens[tokens.length - 1];
                }
            }
            return "";
        };

        that.appendEmpty = function(suggestion, results) {
            var empty_list = that.slimListForMapResults(suggestion, grammar.empty_operand, true);
            if (suggestion != null) {
                that.boldMatchingString(suggestion, empty_list);
            }
            if (results.length < 15) {
                results = results.concat(empty_list);
            }
            else {
                results[14] = empty_list[0];
            }
            return results;
        };

        that.dispatcher = function(val) {

            var selectionRange = jQuery(that.field).selectionRange();
            var parseValue = val.substring(0, selectionRange.start);

            var value;
            var functionSuggestions;

            var token = parser.parse(parseValue);

            result = token.getResult();
            // We will always make a suggestion from here so lets increment the count
            suggestionCount++;
            // In this case we suggest operators
            if (result.getNeedsField()) {
                that.renderSuggestionsFromMap(Util.stripEscapeCharacters(result.getLastFieldName()), jql_field_names, grammar.jql_not_logical_operator, true);
            }
            // for was queries you msay need either an operator or operand
            else if (result.getNeedsOperatorOrOperand()) {
                functionSuggestions = (OperatorUtil.isEmptyOnlyOperator(result.getLastOperator())) ? grammar.empty_operand : jql_function_names;

                token.calcLastOperandStartIndex();
                var parsedOperator = token.getParsedOperator();
                var operatorSuggestions = that.getSuggestionsForOperators(parsedOperator, grammar.jql_operators);

                if (operatorSuggestions && operatorSuggestions.length > 0) {
                    var operandSuggestion = that.incompleteOperator();
                    that.prepareOperandSuggestions(true, result.getLastFieldName(), functionSuggestions, operatorSuggestions, operandSuggestion);
                }
            }
            else if (result.getNeedsOperator()) {
                that.renderSuggestionsForOperators(result.getLastOperator(), grammar.jql_operators);
            }
            else if (result.getNeedsPredicateOperand()) {
                var predicate = result.getLastWasPredicate();
                that.preparePredicateSuggestions(predicate, Util.stripEscapeCharacters(result.getLastOperand()));
            }
            else if (result.getNeedsLogicalOperator()) {
                if (result.getNeedsWasPredicate()) {
                    if (result.getNeedsOrderBy()) {
                        value = (result.getLastOrderBy() === null) ? result.getLastWasPredicate() : result.getLastOrderBy();
                        if (result.getLastOperator() === 'was') {
                            that.renderSuggestionsFromMap(value, grammar.jql_was_predicates_and_order_by, false);
                        }
                        else {
                            that.renderSuggestionsFromMap(value, grammar.jql_changed_predicates_and_order_by, false);
                        }
                    }
                    else {
                        if (result.getLastOperator() === 'was') {
                            that.renderSuggestionsFromMap(result.getLastWasPredicate(), grammar.jql_was_predicates_and_logical_operators, false);
                        }
                        else {
                            that.renderSuggestionsFromMap(result.getLastWasPredicate(), grammar.jql_changed_predicates_and_logical_operators, false);
                        }
                    }

                }
                else {
                    if (result.getNeedsOrderBy()) {
                        value = (result.getLastOrderBy() === null) ? result.getLastLogicalOperator() : result.getLastOrderBy();
                        that.renderSuggestionsFromMap(value, grammar.jql_logical_operators_and_order_by, false);
                    }
                    else {
                        that.renderSuggestionsFromMap(result.getLastLogicalOperator(), grammar.jql_logical_operators, false);
                    }
                }
            }
            else if (result.getNeedsOrderByField()) {
                that.renderSuggestionsFromMap(Util.stripEscapeCharacters(result.getLastOrderByFieldName()), jql_order_by_field_names, true);
            }
            else if (result.getNeedsOrderByDirection()) {
                that.renderSuggestionsFromMap(result.getLastOrderByDirection(), grammar.jql_order_by_direction, false);
            }
            else if (result.getNeedsOperand()) {
                var fieldName = result.getLastFieldName();

                var canAutoComplete = false;
                // If we know that we are only suggesting empty then we do not need to suggest values
                if (!OperatorUtil.isEmptyOnlyOperator(result.getLastOperator())) {
                    for (var i = 0; i < jql_field_names.length; i++) {
                        if (Util.equalsIgnoreCase(result.getUnquotedString(jql_field_names[i].value), fieldName) ||
                            (jql_field_names[i].cfid && Util.equalsIgnoreCase(jql_field_names[i].cfid, fieldName))) {
                            canAutoComplete = jql_field_names[i].auto;
                            break;
                        }
                    }
                }

                functionSuggestions = (OperatorUtil.isEmptyOnlyOperator(result.getLastOperator())) ? grammar.empty_operand : jql_function_names;
                that.prepareOperandSuggestions(canAutoComplete, fieldName, functionSuggestions, {});
            }
            else if (result.getNeedsOrderBy()) {
                that.renderSuggestionsFromMap(result.getLastOrderBy(), grammar.jql_logical_operators_and_order_by, false);
            }
            else {
                that.dropdownController.hideDropdown();
            }

            // Need to update the parse/not parse indicator
            that.parse(val);
        };

        that.parse = function(val) {
            var newToken = parser.parse(val);
            that.updateParseIndicator(newToken);
            that.updateColumnLineCount();
            return newToken.getResult();
        };

        that.renderSuggestionsFromMap = function(stringVal, list, otherSuggestions, showFull) {
            if (!otherSuggestions) {
                otherSuggestions = {};
            }
            var suggestions = that.slimListForMapResults(stringVal, list, showFull);
            var relevantOtherSuggestions = that.slimListForMapResults(stringVal, otherSuggestions, showFull);
            that.boldMatchingString(stringVal, relevantOtherSuggestions);
            that.boldMatchingString(stringVal, suggestions);

            that.renderSuggestions(suggestions, relevantOtherSuggestions);
            if (suggestions.length === 0 && relevantOtherSuggestions.length === 0) {
                that.dropdownController.hideDropdown();
            }
        };

        that.getSuggestionsForOperators = function(stringVal, list) {
            var suggestions = that.slimListForMapResults(stringVal, list, false);

            var fieldName = result.getLastFieldName();
            // Find the current field, if we know about it and get the supported operators
            var supportedOperators;
            for (var i = 0; i < jql_field_names.length; i++) {
                if (Util.equalsIgnoreCase(result.getUnquotedString(jql_field_names[i].value), fieldName) ||
                    (jql_field_names[i].cfid && Util.equalsIgnoreCase(jql_field_names[i].cfid, fieldName))) {
                    supportedOperators = jql_field_names[i].operators;
                    break;
                }
            }

            // Now lets run through the remaining list and if we can identify the field we can see if that field
            // supports which operators
            if (supportedOperators) {
                suggestions = jQuery.grep(suggestions, function(arrValue) {
                    return jQuery.inArray(arrValue.value, supportedOperators) > -1;
                });
            }
            that.boldMatchingString(stringVal, suggestions);
            return suggestions;
        };

        that.renderSuggestionsForOperators = function(stringVal, list) {
            var suggestions = that.getSuggestionsForOperators(stringVal, list);
            that.renderSuggestions(suggestions);
            if (suggestions.length === 0) {
                that.dropdownController.hideDropdown();
            }
        };

        that.renderSuggestionsForOperands = function(stringVal, ajaxSuggestions, functions, operatorSuggestions, providedSuggestionCount) {
            // Only render the suggestions if we are the current suggestion
            if (providedSuggestionCount === suggestionCount) {
                // Don't need to slim the ajaxSuggestions since they came from the server slimmed down
                var functionsSuggestions = that.slimListForFunctionResults(stringVal, functions, result.getLastOperator());
                that.boldMatchingString(stringVal, functionsSuggestions);
                that.renderSuggestions(ajaxSuggestions, functionsSuggestions, operatorSuggestions);

                if (ajaxSuggestions.length === 0 && functionsSuggestions.length === 0 && operatorSuggestions.length === 0) {
                    that.dropdownController.hideDropdown();
                }
            }
        };

        // This bolds the beginning portion of the matching string and converts the list to be value/displayName. This
        // assumes that all strings in the list have already been confirmed to match the incomming stringVal
        that.boldMatchingString = function(stringVal, list) {
            if (stringVal == null || list.length === 0) {
                return;
            }

            var boldLength = stringVal.length;
            // Run through all the characters looking for html escape characters so we can include their extra length in
            // the bold length
            for (var j = 0, n = boldLength; j < n; j++) {
                switch (stringVal.charAt(j)) {
                    case "<":
                    case ">":
                        // We have one character representing this already, lets add the other 3 for &lt; or &gt;
                        boldLength += 3;
                        break;
                    case "&":
                        // We have one character representing this already, lets add the other 4 for &amp;
                        boldLength += 4;
                        break;
                    case '"':
                        // We have one character representing this already, lets add the other 5 for &quot;
                        boldLength += 5;
                        break;
                }
            }

            for (var i = 0; i < list.length; i++) {
                if (list[i].displayName) {
                    var origVal = list[i].displayName;
                    // Create a new copy of the object so we don't mess up the original list
                    list[i] = {value: list[i].value, displayName: "<b>" + origVal.substring(0, boldLength) + "</b>" + origVal.substring(boldLength)};
                }
                else {
                    // Add a displayName so we don't mess up the value
                    list[i] = {value: list[i], displayName: "<b>" + list[i].substring(0, boldLength) + "</b>" + list[i].substring(boldLength)};
                }
            }
        };

        that.getReplacementStartIndex = function(result, value) {
                var jQueryReference = jQuery(that.field);
                var start;
                if (result.getNeedsField()) {
                    start = result.getLastFieldNameStartIndex();
                }
                else if (result.getNeedsOperatorOrOperand()) {
                    // was presents difficulties - it may be followed by either an operand or an operator
                    if (result.getNeedsOperator() && OperatorUtil.isWasOperator(value)) {
                        start = result.getLastOperatorStartIndex();
                    }
                    else {
                        start = result.getLastOperandStartIndex();
                    }
                }
                else if (result.getNeedsOperand()) {
                    start = result.getLastOperandStartIndex();
                }
                else if (result.getNeedsOperator()) {
                    start = result.getLastOperatorStartIndex();
                }
                else if (result.getNeedsOrderByField()) {
                    start = result.getLastOrderByFieldNameStartIndex();
                }
                else if (result.getNeedsOrderByDirection()) {
                    start = result.getLastOrderByDirectionStartIndex();
                }
                else if (result.getNeedsPredicateOperand()) {
                    start = result.getLastOperandStartIndex();
                }
                else if (result.getNeedsLogicalOperator()) {
                    if (result.getLastLogicalOperatorStartIndex() !== null && result.getLastLogicalOperatorStartIndex() !== 0) {
                        start = result.getLastLogicalOperatorStartIndex();
                    }
                    else {
                        if (result.getLastOrderBy() !== null && result.getLastOrderByStartIndex() !== 0) {
                            start = result.getLastOrderByStartIndex();
                        }
                        else if (result.getLastWasPredicate() != null && result.getLastWasPredicateStartIndex() !== 0) {
                            start = result.getLastWasPredicateStartIndex();
                        }
                        else if (result.getMustBeOperatorOrPredicate() === true) {
                            start = jQueryReference.selectionRange().start;
                        }
                        else {
                            start = jQueryReference.selectionRange().start - 1;
                        }
                    }
                }
                else if (result.getNeedsWasPredicate()) {
                    start = result.getLastWasPredicateStartIndex();
                }
                else if (result.getNeedsOrderBy()) {
                    start = result.getLastOrderByStartIndex();
                }
                else {
                    start = jQueryReference.selectionRange().start - 1;
                }
                // sanity check
                return start != null ? start : jQueryReference.selectionRange().start;
            };

        that.getReplacementEndIndex = function(result, start) {
            var jQueryReference = jQuery(that.field);
            var selectionRange = jQueryReference.selectionRange();
            var end = null;
            // We only need to do a second parse if we have no highlighted selection AND we are not at the end of the input string
            // But we also must check that cursor is now in the middle or end of the word. (3 condition)
            // otherwise we just use the selectionEnd
            if (selectionRange.start === selectionRange.end && selectionRange.end !== that.field.val().length && start < selectionRange.start) {
                // Lets get the token number from the first parse, this is the token we are currently on
                var currentTokenIdx = result.getTokens().length - 1;

                // Parse it again, but this time the full string so we know what the full token is that we are trying to replace
                // with the selected completion
                var token = parser.parse(that.field.val());
                if (!token.getParseError()) {
                    // The user has not highlighted text so lets assume we are completing to the end of the current token
                    // Ask the newly parsed result for the complete token we are in the middle of
                    var fullTokenValue = token.getResult().getTokens()[currentTokenIdx];
                    // This is a special case, we don't want to replace the '(' or ')' instead we want to add inside
                    if (fullTokenValue !== null && fullTokenValue !== '(' && fullTokenValue !== ')') {
                        var fullTextVal = that.field.val();
                        // Lets get the start position in the string
                        var remainingString = fullTextVal.substring(start, fullTextVal.length);
                        // We know that we are going to see the fullTokenValue next, but there may be some whitespace between
                        // here and there, lets make sure we ditch the whitespace as well.
                        var remainingStringArr = remainingString.split("");
                        var whitespaceCount = 0;
                        for (var i = 0; i < remainingStringArr.length; i++) {
                            if (grammar.REGEXP_WHITESPACE.test(remainingStringArr[i])) {
                                whitespaceCount++;
                            }
                            else {
                                // Stop as soon as we no longer see whitespace
                                break;
                            }
                        }
                        end = start + fullTokenValue.length + whitespaceCount;
                    }
                }
            }

            if (end === null) {
                end = selectionRange.end;
            }
            // As the start position could have been incremented to account for spaces in operators
            // e.g. was not in, it is feasible that end may be less than start so a quick check is in order.
            // If start is less than end pad with a space (one is sufficient)
            if (end < start) {
                that.replaceValue(start, end, " ");
                end = start;
            }
            return end;
        };

        that.replaceValue = function(start, end, newValue) {
            var jQueryReference = jQuery(that.field);
            // Lets reset the selection range to include the characters that the user has already typed
            jQueryReference.selectionRange(start, end);
            // Lets replace the value with the autocomplete selected value
            //The following if clause is needed to provide correct undo behavior in JQL text field
            //Webkit family doesn't put jQuery.selection to undo stack, so we are getting an ugly undo
            //On the other hand non-webkit browser don't insert the text through document.execCommand.
            //But they work correct with selection and undo.
            if ($.browser.webkit) {
                document.execCommand("insertText", false, newValue);
            } else {
                jQueryReference.selection(newValue);
            }
            // Lets stop the replaced bit from being highlighted
            var newEnd = jQueryReference.selectionRange().end;
            jQueryReference.selectionRange(newEnd, newEnd);
        };

        that.slimListForMapResults = function(stringVal, list, showFull) {
            var escString = Util.htmlEscape(stringVal);
            var slimedList = jQuery.grep(list, function(arrValue) {
                return Util.startsWithIgnoreCaseNullsMeanAll(escString, arrValue.displayName);
            });

            if (!showFull) {
                // We only want to show the value when the user has fully typed it in IF there are more than one suggestion
                // with this prefix.
                if (slimedList.length === 1 && !Util.startsWithNotEqualsIgnoreCaseNullMeansAll(escString, slimedList[0].displayName)) {
                    return {};
                }
            }
            return slimedList;
        };

        that.slimListForFunctionResults = function(stringVal, list, operator) {
            var fieldName = result.getLastFieldName();
            // Find the current field, if we know about it and get the supported types
            var supportedTypes;
            for (var i = 0; i < jql_field_names.length; i++) {
                if (Util.equalsIgnoreCase(result.getUnquotedString(jql_field_names[i].value), fieldName) ||
                    (jql_field_names[i].cfid && Util.equalsIgnoreCase(jql_field_names[i].cfid, fieldName))) {
                    supportedTypes = jql_field_names[i].types;
                    break;
                }
            }

            var slimedList = jQuery.grep(list, function(arrValue) {
                // For functions we only want to show the is list ones with list operators and vice versa
                if ((arrValue.isList && !OperatorUtil.isListSupportingOperator(operator)) ||
                    (!arrValue.isList && OperatorUtil.isListSupportingOperator(operator))) {
                    return false;
                }
                if (supportedTypes) {
                    // Need to check for Object since this means we always fit
                    var supportsFunction = jQuery.inArray("java.lang.Object", arrValue.types) > -1 || jQuery.inArray("java.lang.Object", supportedTypes) > -1;
                    for (var i = 0; i < supportedTypes.length && !supportsFunction; i++) {
                        supportsFunction = jQuery.inArray(supportedTypes[i], arrValue.types) !== -1;
                    }
                    if (!supportsFunction) {
                        return false;
                    }
                }
                else {
                    // Can't find the field so we know that no functions will work with it
                    return false;
                }
                return Util.startsWithIgnoreCaseNullsMeanAll(stringVal, arrValue.value) || Util.startsWithIgnoreCaseNullsMeanAll(stringVal, arrValue.displayName);
            });

            // We only want to show the value when the user has fully typed it in IF there are more than one suggestion
            // with this prefix.
            if (slimedList.length === 1 && !Util.startsWithNotEqualsIgnoreCaseNullMeansAll(stringVal, slimedList[0].displayName)) {
                return {};
            }
            return slimedList;
        };

        that.slimListForPredicates = function(stringVal, list, predicate) {
            var supportedType;
            var supportsList;
            for (var i = 0; i < grammar.jql_changed_predicates.length; i++) {
                if (Util.equalsIgnoreCase(result.getUnquotedString(grammar.jql_changed_predicates[i].value), predicate)) {
                    supportedType = grammar.jql_changed_predicates[i].type;
                    supportsList = grammar.jql_changed_predicates[i].supportsList;
                    break;
                }
            }

            var slimedList = jQuery.grep(list, function(arrValue) {
                // For functions we only want to show the is list ones with list operators and vice versa

                if (typeof arrValue.isList !== "undefined") {
                    if ((arrValue.isList && !!supportsList) || (!arrValue.isList && supportsList)) {
                        return false;
                    }
                }
                var supportsFunction = jQuery.inArray(supportedType, arrValue.types) !== -1;
                return supportsFunction ? Util.startsWithIgnoreCaseNullsMeanAll(stringVal, arrValue.value) || Util.startsWithIgnoreCaseNullsMeanAll(stringVal, arrValue.displayName) : false;
            });

            // We only want to show the value when the user has fully typed it in IF there are more than one suggestion
            // with this prefix.
            if (slimedList.length === 1 && !Util.startsWithNotEqualsIgnoreCaseNullMeansAll(stringVal, slimedList[0].displayName)) {
                return {};
            }
            return slimedList;
        };

        that.predicateSupportsAutoComplete = function(predicate) {
            var auto;
            for (var i = 0; i < grammar.jql_changed_predicates.length; i++) {
                if (Util.equalsIgnoreCase(result.getUnquotedString(grammar.jql_changed_predicates[i].value), predicate)) {
                    auto = grammar.jql_changed_predicates[i].auto;
                    break;
                }
            }
            return auto;

        };

        /**
         * Gets cached response from <em>requested</em> object
         * @param {String} val
         * @returns {Object}
         */
        that.getSavedResponse = function(val) {
            if (!this.requested) {
                this.requested = {};
            }
            return this.requested[val];
        };

        /**
         * Saves response to <em>requested</em> object
         * @param {String} val
         * @param {Object} response
         */
        that.saveResponse = function(val, response) {
            if (typeof val === "string" && typeof response === "object") {
                if (!this.requested) {
                    this.requested = {};
                }
                this.requested[val] = response;
            }
        };

        that.startsWithIgnoreCase = function(startStr, str) {
            if (str === null || startStr === null || str.length < startStr.length) {
                return false;
            }
            else {
                return startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
            }
        };

        that.updateParseIndicator = function(token) {
            if (token.getParseError()) {
                PARSE_INDICATOR.attr("title", token.getResult().getParseErrorMsg()).removeClass("jqlgood").addClass("jqlerror");
            }
            else {
                PARSE_INDICATOR.attr("title", "").removeClass("jqlerror").addClass("jqlgood");
            }
        };

        that.updateColumnLineCount = function() {
            var jQueryReference = jQuery(that.field);
            var totalCharCountToCursor = 0;

            if (that.field[0] === document.activeElement) {
                var selectionRange = jQueryReference.selectionRange();
                totalCharCountToCursor = selectionRange.start;
            }
            else {
                totalCharCountToCursor = that.field[0].value.length;
            }
            var rowCount = 1;
            var colCount = 1;

            var fieldValue = that.field.val();

            for (var i = 0; i < totalCharCountToCursor; i++) {
                if (grammar.REGEXP_NEW_LINE.test(fieldValue.charAt(i))) {
                    rowCount++;
                    colCount = 1;
                }
                else {
                    colCount++;
                }
            }

            // Update our counts for where our cursor is at the moment
            jqlcolumnnum.text(colCount);
            jqlrownum.text(rowCount);
        };

        that.init(options);

        return that;
    };

    return JQLAutoComplete;
});

define('jira/jql/util', [
    'jira/jql/jql-grammar'
], function(
    grammar
) {
    "use strict";

    /** @exports jira/jql/util */
    var JQLAutoCompleteUtil = {};

    JQLAutoCompleteUtil.htmlEscape = function(stringVal) {
        if (stringVal == null) {
            return null;
        }
        var escapedVal = "";
        var strArr = stringVal.split("");
        // Run through all the characters looking for html escape characters so we can include their extra length in
        // the bold length
        for (var j = 0; j < strArr.length; j++) {
            if (strArr[j] === "<") {
                escapedVal += "&lt;";
            }
            else if (strArr[j] === ">") {
                escapedVal += "&gt;";
            }
            else if (strArr[j] === "&") {
                // We have one character representing this already, lets add the other 4 for &amp;
                escapedVal += "&amp;";
            }
            else if (strArr[j] === "\"") {
                // We have one character representing this already, lets add the other 5 for &quot;
                escapedVal += "&quot;";
            }
            else {
                escapedVal += strArr[j];
            }
        }
        return escapedVal;
    };

    JQLAutoCompleteUtil.stripEscapeCharacters = function(val) {

        if (val == null) {
            return val;
        }
        var newVal = "";
        var strArr = val.split("");
        for (var i = 0; i < strArr.length; i++) {
            if (strArr[i] === '\\') {
                // If we are a unicode string then we just consume it like normal
                if (!grammar.REGEXP_UNICODE.test(val.substring(i, val.length))) {
                    // Just chew past the escape and use the next char, the parser has already made sure this is cool
                    i++;
                    if (i >= val.length) {
                        break;
                    }
                }
            }
            newVal += strArr[i];
        }
        return newVal;
    };

    JQLAutoCompleteUtil.equalsIgnoreCase = function(str1, str2) {
        if (str1 === null && str2 === null) {
            return true;
        }
        else if (str1 === null || str1 === null) {
            return false;
        }
        else {
            return str1.toLowerCase() === str2.toLowerCase();
        }
    };

    JQLAutoCompleteUtil.startsWithIgnoreCaseNullsMeanAll = function(startStr, str) {
        // In this case we want all elements of the list included
        if (str === null || startStr === null) {
            return true;
        }
        if (str.length < startStr.length) {
            return false;
        }
        else {
            return startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
        }
    };

    JQLAutoCompleteUtil.startsWithNotEqualsIgnoreCaseNullMeansAll = function(startStr, str) {
        // In this case we want all elements of the list included
        if (str === null || startStr === null) {
            return true;
        }
        if (str.length < startStr.length) {
            return false;
        }
        else {
            var subStrEquals = startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
            if (subStrEquals) {
                // HACK!! This is a hack so that the custom field display values will not show up as a suggestion when they
                // are completely typed in.
                var equalsString = null;
                if (grammar.REGEXP_FIELD_NAME.test(str.substr(startStr.length, str.length))) {
                    equalsString = str.substr(0, startStr.length);
                }
                else {
                    equalsString = str;
                }
                return startStr.toLowerCase() != equalsString.toLowerCase();
            }
            return false;
        }
    };

    return JQLAutoCompleteUtil;
});

define('jira/jql/operator-util', function() {
    "use strict";

    /** @exports jira/jql/operator-util */
    var that = {};

    that.isListSupportingOperator = function(operator) {
        return operator === 'in' || operator === 'not in' || operator === 'was not in' || operator === 'was in';
    };

    that.isEmptyOnlyOperator = function(operator) {
        return operator === 'is' || operator === 'is not';
    };

    that.isWasOperator = function(operator) {
        return operator === 'was' || operator === 'was in' || operator === 'was not in' || operator === 'was not';
    };

    that.isChangedOperator = function(operator) {
        return operator === 'changed';
    };

    that.isHistoryOperator = function(operator) {
        return that.isWasOperator(operator) || that.isChangedOperator(operator);
    };

    return that;
});

define('jira/jql/jql-parser', [
    'jira/jql/jql-grammar',
    'jira/jql/jql-parse-token',
    'jira/jql/operator-util',
    'jquery'
], function(
    grammar,
    Token,
    OperatorUtil,
    jQuery
) {
    /*jshint bitwise:true, curly:true, eqeqeq:false, eqnull:true, forin:true, noarg:true, noempty:true, nonew:true, undef:true, indent:4 */

    /**
     * @exports jira/jql/jql-parser
     * @class JQLAutoComplete.MyParser
     * @param {String[]} jqlReservedWords - list of words that have special meaning in the JQL language
     */
    return function(jqlReservedWords) {

        var jql_reserved_words = jqlReservedWords;

        return /** @lends JQLAutoComplete.MyParser.prototype */ {
            parse: function(input) {
                var token = Token();

                token.init(input);
                this.jql(token);
//            token.toString();
                return token;
            },

            orderByClause: function(token) {
                var remainingString = token.remainingString();
                // Lets consume the 'order' token
                var matchArray = remainingString.match(grammar.REGEXP_ORDER_BY);

                if (matchArray) {
                    var orderByString = remainingString.substring(0, matchArray[0].length);
                    token.consumeCharacters(orderByString.length);
                    token.getResult().setLastOrderBy(orderByString, token);

                    if (!token.isComplete()) {
                        // We must have some space in order to parse an order by fields
                        remainingString = token.remainingString();
                        if (grammar.REGEXP_WHITESPACE.test(remainingString)) {
                            this.chewWhitespace(token);
                            // Look for order by fields
                            this.orderByFields(token);
                        }
                        else {
                            token.getResult().resetLogicalOperators();
                            token.setParseError();
                        }
                    }
                    else {
                        token.getResult().resetLogicalOperators();
                        token.setParseError();
                    }
                }
                else {
                    // Consume the remaining string
                    token.consumeCharacters(remainingString.length);
                    token.getResult().setLastOrderBy(remainingString, token);
                    token.setParseError();
                }
            },

            orderByFields: function(token) {
                // Look for fields followed by 'asc' or 'desc' or commas
                this.orderByField(token);
                this.chewWhitespace(token);
                if (token.isComplete()) {
                    // We always need to check to see if we need to put in a place-holder for the order by direction
                    if (!token.getResult().getNeedsOrderByField()) {
                        token.getResult().setLastOrderByDirection("", token);
                        // This is not a parse error, it is just a token place holder so we will complete correctly
                    }
                }
                else {
                    // Look for a comma
                    var remainingString = token.remainingString();
                    if (this.startsWithIgnoreCase(",", remainingString)) {
                        token.consumeCharacter();
                        // Lets recurse back looking for more order by fields
                        this.orderByFields(token);
                        this.chewWhitespace(token);
                    }
                    else {
                        remainingString = token.remainingString();
                        if (remainingString !== null) {
                            token.consumeCharacters(remainingString.length);
                        }
                        token.getResult().setNeedsOrderByDirection();
                        token.getResult().setLastOrderByDirection(remainingString, token);
                        token.setParseError();
                    }
                }
            },

            orderByField: function(token) {
                this.chewWhitespace(token);
                var fieldName = this.fieldName(token);
                if (fieldName.length !== 0) {
                    token.getResult().setLastOrderByFieldName(fieldName, token);

                    // If we see a comma then we don't have an order by direction
                    var remainingString = token.remainingString();

                    if (!token.isComplete() && !grammar.REGEXP_COMMA_DELIMITER.test(remainingString)) {
                        // Better look for a direction, but it is optional so no big deal if we do not find it
                        // We need a space between the order by field name and the direction
                        if (grammar.REGEXP_ASCENDING.test(remainingString)) {
                            this.chewWhitespace(token);
                            // consume and move on
                            token.consumeCharacters(3);
                            token.getResult().setLastOrderByDirection("asc", token);
                            token.getResult().setNeedsOrderByComma();
                        }
                        else if (grammar.REGEXP_DESCENDING.test(remainingString)) {
                            this.chewWhitespace(token);
                            // consume and move on
                            token.consumeCharacters(4);
                            token.getResult().setLastOrderByDirection("desc", token);
                            token.getResult().setNeedsOrderByComma();
                        }
                        else {
                            token.getResult().setNeedsOrderByDirection();
                        }
                    }
                    else {
                        token.getResult().setNeedsOrderByField();
                        this.chewWhitespace(token);
                    }
                }
                else {
                    token.getResult().setLastOrderByFieldName("", token);
                    token.getResult().setNeedsOrderByField();
                    token.setParseError();
                }
            },

            jql: function(token) {
                this.orClause(token);
                var remainingString = token.remainingString();
                if (this.startsWithIgnoreCase("ord", remainingString)) {
                    this.orderByClause(token);
                }
            },

            orClause: function(token) {

                while (!token.isComplete() && !this.startsWithIgnoreCase(")", token.remainingString())) {
                    this.chewWhitespace(token);
                    var remainingString = token.remainingString();
                    if (this.startsWithIgnoreCase("ord", remainingString)) {
                        // lets give control back to the jql function so we can end up in the orderByClause
                        break;
                    }
                    if (token.getResult().getMustBeOperatorOrPredicate()) {
                        token.getResult().resetLastPredicates();
                    }
                    else {
                        token.getResult().resetLogicalOperators();
                        this.andClause(token);
                    }
                    if (!token.isComplete() && token.getResult().getLastLogicalOperator() === null) {
                        if (token.getResult().getNeedsWasPredicate()) {
                            this.predicateClause(token);
                        }
                        // we may as well exit early if the predicate clause has been handled
                        // and the token is complete
                        if (token.isComplete()) {
                            return;
                        }
                        // Look for an OR clause
                        remainingString = token.remainingString();
                        if (this.startsWithIgnoreCase("ord", remainingString)) {
                            // lets give control back to the jql function so we can end up in the orderByClause
                            break;
                        }
                        else if (remainingString !== null && (grammar.REGEXP_ORS.test(remainingString) || this.startsWithIgnoreCase("|", remainingString) || this.startsWithIgnoreCase("||", remainingString))) {
                            if (this.startsWithIgnoreCase("||", remainingString)) {
                                token.getResult().setLastLogicalOperator("||", token.getTokenStringIdx());
                                token.consumeCharacters(2);
                            }
                            else if (grammar.REGEXP_ORS.test(remainingString)) {
                                token.getResult().setLastLogicalOperator("OR", token.getTokenStringIdx());
                                token.consumeCharacters(3);
                            }
                            else {
                                token.getResult().setLastLogicalOperator("|", token.getTokenStringIdx());
                                token.consumeCharacters(1);
                            }

                            token.getResult().resetTerminalClause();
                            if (token.isComplete()) {
                                token.setParseError();
                            }
                            token.getResult().setNeedsField();
                        }
                        // This block of code is very confusing. The reason it is here is that when we are in a nested
                        // block of '('s it is the terminalClause that handles the parens and it calls off to this orClause.
                        // The orClause needs to ignore the close paren so that the terminalClause can handle it, BUT only
                        // when we are currently in a set of parens. So, ff the remaining character is a close paren and
                        // we are not in parens then we are NOT in error, otherwise we are
                        else if (!this.startsWithIgnoreCase(")", remainingString) || !token.getInParens()) {
                            this.chewWhitespace(token);
                            var errorIdx = (remainingString === null) ? token.getMaxTokenStringIdx() : token.getMaxTokenStringIdx() - remainingString.length;
                            // let's tokenise this to simplify space handling
                            var tokens;
                            if (remainingString != null) {
                                tokens = remainingString.split(" ");
                                token.getResult().setLastLogicalOperator(tokens[0], errorIdx);
                                token.getResult().setLastWasPredicate(tokens[0], token);
                                token.getResult().setNeedsLogicalOperator(token);
                            }

                            // may need to go around again to check for predicate
                            if (token.getResult().getLastWasOperator() == null) {
                                token.setParseError();
                            }
                            else {
                                if (tokens != null) {
                                    // JRADEV-6053 fails after and
                                    if (grammar.REGEXP_PREDICATE.test(tokens[0])) {
                                        token.getResult().setLastLogicalOperator(null);
                                        // JRADEV-7204 deleting back to predicate still leaves suggestions
                                        // in place, check this condition and reset
                                        token.getResult().resetNeedsPredicateOperand();
                                    }
                                    else {
                                        if (grammar.REGEXP_ANDS.test(remainingString)) {
                                            token.consumeCharacters(4);
                                            token.getResult().resetTerminalClause();
                                            token.getResult().setNeedsField();
                                        }
                                        if (token.isComplete() || tokens.length === 1) {
                                            token.setParseError();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },

            andClause: function(token) {
                this.chewWhitespace(token);
                this.notClause(token);
                if (!token.isComplete() && token.getResult().getLastLogicalOperator() === null) {
                    // Look for an AND clause
                    this.chewWhitespace(token);

                    var remainingString = token.remainingString();
                    if (remainingString !== null && (grammar.REGEXP_ANDS.test(remainingString) || this.startsWithIgnoreCase("&", remainingString) || this.startsWithIgnoreCase("&&", remainingString))) {
                        if (this.startsWithIgnoreCase("&&", remainingString)) {
                            token.getResult().setLastLogicalOperator("&&", token.getTokenStringIdx());
                            token.consumeCharacters(2);
                        }
                        else if (this.startsWithIgnoreCase("&", remainingString)) {
                            token.getResult().setLastLogicalOperator("&", token.getTokenStringIdx());
                            token.consumeCharacters(1);
                        }
                        else {
                            token.getResult().setLastLogicalOperator("AND", token.getTokenStringIdx());
                            token.consumeCharacters(4);
                        }
                        token.getResult().resetTerminalClause();
                        if (token.isComplete()) {
                            token.setParseError();
                        }

                        token.getResult().setNeedsField();
                    }
                    else {
                        token.getResult().setNeedsLogicalOperator(token);
                        // This is a special case for when we are about to place a logical operator into an existing string
                        // so that we will have a null place-holder token for the logical operator we expect.
                        if (token.isComplete()) {
                            token.getResult().setLastLogicalOperator(null, token.getMaxTokenStringIdx());
                        }
                    }
                }
            },

            notClause: function(token) {
                this.chewWhitespace(token);
                if (!token.isComplete()) {
                    // Look for a NOT clause
                    this.chewWhitespace(token);
                    var remainingString = token.remainingString();
                    if (remainingString !== null && (grammar.REGEXP_NOTS.test(remainingString) || this.startsWithIgnoreCase("!", remainingString))) {
                        // This is a bit of a hack that makes it so that you do not get a suggestion for a field until
                        // after you have typed a space after the NOT
                        token.getResult().needsField = false;
                        if (this.startsWithIgnoreCase("!", remainingString)) {
                            token.getResult().setLastLogicalOperator("!", token.getTokenStringIdx());
                            token.consumeCharacters(1);
                        }
                        else {
                            token.getResult().setLastLogicalOperator("NOT", token.getTokenStringIdx());
                            token.consumeCharacters(4);
                        }
                        token.getResult().resetTerminalClause();
                        if (token.isComplete()) {
                            token.setParseError();
                        }

                        token.getResult().setNeedsField();
                    }
                    else {
                        this.terminalClause(token);
                    }
                }
                else {
                    // Let the terminal clause set all the error conditions and needs
                    this.terminalClause(token);
                    token.setParseError();
                }
            },

            predicateClause: function(token) {
                this.chewWhitespace(token);
                if (!token.isComplete()) {
                    var remainingString = token.remainingString();
                    var tokens = remainingString.split(/[\s(]+/);
                    if (remainingString !== null) {
                        token.getResult().setMustBeOperatorOrPredicate(false);
                        // if the string starts with logical operator - return control to the
                        // not clause, however check if this is the last token, and if it is set the parse error flag
                        if (this.startsWithLogicalOperator(remainingString)) {
                            if (tokens.length === 1) {
                                token.getResult().setLastWasPredicate(tokens[0], token);
                                token.setParseError();
                                return;
                            }
                            return;
                        }
                        token.getResult().resetNeedsPredicateOperand();
                        token.consumeCharacters(tokens[0].length);
                        token.getResult().setLastWasPredicate(tokens[0], token);
                        // if there is only 1 token then there is no whitespace, so get out of Dodge
                        if (tokens.length === 1) {
                            token.setParseError();
                            return;
                        }
                        if (this.wasPredicateComplete(tokens[0])) {
                            token.getResult().setNeedsPredicateOperand();
                            token.getResult().setLastOperand(null, token);
                            this.predicateOperand(token);
                        }
                        else {
                            token.setParseError();
                        }
                    }
                }
                else {
                    // Let the terminal clause set all the error conditions and needs
                    token.setParseError();
                }

            },

            predicateOperand: function(token) {
                this.chewWhitespace(token);
                var predicateOperand = this.collectPredicateOperands(token);
                if (predicateOperand == null || predicateOperand == "") { // eslint-disable-line eqeqeq
                    token.getResult().setLastOperandStartIndex(token.getTokenStringIdx());
                    token.setParseError();
                }
                // need a workaround to ensure you reset the needsPredicateOperand
                // easiest way is to check if you have entered a space after the
                // operand - meaning you want to go on parsing
                if (token.remainingString() != null) {
                    token.getResult().resetNeedsPredicateOperand();
                    token.getResult().resetLastPredicates();
                    token.getResult().setMustBeOperatorOrPredicate(true);
                    token.getResult().setNeedsLogicalOperator(token);
                    this.chewWhitespace(token);
                }

            },

            collectPredicateOperands: function(token) {
                // If we have and in or not in operator then we need either a function or an open paren
                if (token.getResult().getLastWasPredicate() === 'DURING') {
                    token.getResult().setNeedsOpenParen(true);
                }

                var predicateOperand = this.listOperand(token, true);
                if (predicateOperand.length === 0) {
                    predicateOperand = this.functionOperand(token);
                    if (predicateOperand.length === 0) {
                        predicateOperand = this.singleValueOperand(token);
                    }
                    else {
                        // We were handled by a function so we no longer need the open paren
                        token.getResult().setNeedsOpenParen(false);
                    }
                }
                else {
                    // We were handled by a list so we no longer need the open paren
                    token.getResult().setNeedsOpenParen(false);
                }
                return token.getResult().getUnquotedString(predicateOperand);
            },

            terminalClause: function(token) {
                // Lets always reset the last field variables
                token.getResult().resetTerminalClause();
                this.chewWhitespace(token);

                var remainingString = token.remainingString();
                // If we see a ( then we need to hand off to the or clause again
                if (this.startsWithIgnoreCase("(", remainingString)) {
                    token.getResult().addToken('(');
                    token.setInParens();
                    token.consumeCharacter();
                    this.orClause(token);
                    this.chewWhitespace(token);
                    remainingString = token.remainingString();
                    if (this.startsWithIgnoreCase(")", remainingString)) {
                        token.getResult().addToken(')');
                        token.consumeCharacter();
                        token.setOutOfParens();
                        if (token.isComplete()) {
                            // We don't want to suggest a logical operator to the user if the query parses
                            token.getResult().resetLogicalOperators();
                            token.getResult().resetLastPredicates();
                        }
                    }
                    else {
                        token.setParseError();
                    }
                }
                else {
                    this.field(token);
                    if (!token.isComplete()) {
                        this.oper(token);
                        if (!token.isComplete()) {
                            if (token.getResult().getLastWasOperator() === 'changed') {
                                token.getResult().setNeedsLogicalOperator(token);
                                return;
                            }
                            this.operand(token);

                            // This will only happen when we have seen a list operand that is properly closed
                            if (token.getResult().getOperandComplete()) {
                                // JRADEV-6372 Autocomplete does not parse after was in (or indeed was not in)
                                var lastWasOperator = token.getResult().getLastWasOperator();
                                token.getResult().setNeedsNothing();
                                if (lastWasOperator) {
                                    token.getResult().setLastWasOperator(lastWasOperator);
                                }
                            }
                            else if (token.isComplete() && !token.getResult().getNeedsListComma()) {
                                // This is not a parse error since we have found everything we were looking for
                                token.getResult().setNeedsOperand();
                            }
                        }
                        else {
                            //if (token.getResult().get that.ge token.getResult().setNeedsOperator();
                            if (token.getResult().getLastOperator() === "was" || token.getResult().getLastOperator() === "was not") {
                                token.getResult().setNeedsOperandOrOperator();
                            }
                            else if (token.getResult().getLastWasOperator() === 'changed') {
                                // JRADEV-7179 Need to make sure that there is a space before calling for an autocomplete
                                var currentChar = token.currentCharacter();
                                if (currentChar !== null && grammar.REGEXP_SPACE_OR_ELSE.test(currentChar)) {
                                    token.getResult().setNeedsLogicalOperator(token);
                                }
                                else {
                                    token.getResult().resetLogicalOperators();
                                    token.getResult().setNeedsOrderBy(false);
                                }
                                return;
                            }
                            else {
                                token.getResult().setNeedsOperator();
                            }
                            token.setParseError();
                        }
                    }
                    else {
                        token.getResult().setNeedsField();
                        token.setParseError();
                    }
                }
            },

            field: function(token) {
                var fieldName = this.fieldName(token);
                if (fieldName.length !== 0) {
                    token.getResult().setLastFieldName(fieldName, token);
                }
                else if (token.getResult().getLastFieldName() === null) {
                    var remainingString = token.remainingString();
                    token.getResult().setNeedsField();
                    token.getResult().setLastFieldName(remainingString, token);
                    token.setParseError();
                }
            },

            fieldName: function(token) {
                this.chewWhitespace(token);

                // Field is either a string or cf[12345]
                var remainingString = token.remainingString();
                if (this.startsWithIgnoreCase("cf", remainingString)) {
                    var origIdx = token.getTokenStringIdx();
                    var origString = token.remainingString();
                    token.consumeCharacters(2);
                    this.chewWhitespace(token);
                    remainingString = token.remainingString();
                    // Now we must find a [ or the show is off
                    if (this.startsWithIgnoreCase("[", remainingString)) {
                        token.consumeCharacter();
                        // We must find a number in here until we encounter a ]
                        remainingString = token.remainingString();
                        var custFieldId = this.numberValue(token);
                        if (custFieldId.length !== 0) {
                            // Lets find our closing ]
                            this.chewWhitespace(token);
                            remainingString = token.remainingString();
                            if (this.startsWithIgnoreCase("]", remainingString)) {
                                token.consumeCharacter();
                                return origString.substring(0, token.getTokenStringIdx() - origIdx);
                            }
                        }
                    }
                    token.setParseError();
                    return origString;
                }
                else if (this.startsWithIgnoreCase("issue.property", remainingString)) {
                    return this.entityPropertyName("issue.property", token);
                }
                else {
                    return this.fieldOrFunctionName(token);
                }
            },
            entityPropertyName: function(propertyPrefix, token) {
                token.consumeCharacters(propertyPrefix.length);
                this.chewWhitespace(token);
                var remainingString = token.remainingString();
                // Now we must find a [ or the show is off
                if (this.startsWithIgnoreCase("[", remainingString)) {
                    token.consumeCharacter();
                    // Now the string is propertyKey

                    var propertyKeys = [this.stringValue(token)];

                    while (!token.parseError && this.startsWithIgnoreCase('.', token.remainingString())) {
                        token.consumeCharacter();
                        propertyKeys[propertyKeys.length] = this.stringValue(token);
                    }
                    if (propertyKeys.length !== 0 && propertyKeys[0].length !== 0 && !this.startsWithIgnoreCase('.', propertyKeys[0]) /*we don't want to allow .key as keys*/) {
                        // Lets find our closing ]
                        this.chewWhitespace(token);
                        remainingString = token.remainingString();
                        if (this.startsWithIgnoreCase("]", remainingString)) {
                            token.consumeCharacter();
                            //now we expect property path the key after ]
                            var propertyPaths = [this.stringValue(token)];

                            while (!token.parseError && this.startsWithIgnoreCase('.', token.remainingString())) {
                                token.consumeCharacter();
                                propertyPaths[propertyPaths.length] = this.stringValue(token);
                            }
                            return propertyPrefix + '[' + propertyKeys.join('.') + ']' + propertyPaths.join('.');
                        }
                    }
                }
                token.setParseError();
                return "";
            },
            oper: function(token) {
                this.chewWhitespace(token);
                var remainingString = token.remainingString();
                var operator = this.getLongestOperatorMatch(remainingString, grammar.jql_operators);
                if (operator !== null) {
                    // We found an operator, record it and consume the right amount of characters
                    token.getResult().setLastOperator(operator, token.getTokenStringIdx());
                    if (OperatorUtil.isWasOperator(operator) || OperatorUtil.isChangedOperator(operator)) {
                        token.getResult().setLastWasOperator(operator);
                    }
                    token.consumeCharacters(operator.length);
                    // If we are one of the word operators we need to enforce a space here
                    if (operator === "in" || operator === "is" || operator === "is not" || operator === "not in" || operator === "was" || operator === "was not" || operator === "was in" || operator === "was not in") {
                        // We need a space or else
                        var currentChar = token.currentCharacter();
                        if (currentChar !== null && !grammar.REGEXP_SPACE_OR_ELSE.test(currentChar)) {
                            token.setParseError();
                        }
                    }
                    // was may be followed by not, so if it ihas a n or a no then the parser is still
                    // in error

                    if (operator === "was") {
                        token.getResult().setNeedsOperandOrOperator();
                        this.chewWhitespace(token);
                        remainingString = token.remainingString();

                        if (remainingString != null && (grammar.REGEXP_NOTSTART.test(remainingString) || grammar.REGEXP_INSTART.test(remainingString))) {
                            token.setParseError();
                        }
                    }
                    else if (operator === "was not") {
                        token.getResult().setNeedsOperandOrOperator();
                        this.chewWhitespace(token);
                        remainingString = token.remainingString();

                        if (remainingString != null && (grammar.REGEXP_INSTART.test(remainingString))) {
                            token.setParseError();
                        }
                    }
                    else if (operator === "changed") {
                        token.getResult().setNeedsLogicalOperator(token);
                    }
                    else {
                        token.getResult().setNeedsOperand();
                    }
                }
                else if (token.getResult().getLastOperator() === null) {
                    var errorIdx = (remainingString === null) ? token.getMaxTokenStringIdx() : token.getMaxTokenStringIdx() - remainingString.length;
                    token.getResult().setLastOperator(remainingString, errorIdx);
                    token.getResult().setNeedsOperator();
                    token.setParseError();
                }
            },

            operand: function(token) {
                this.chewWhitespace(token);

                // If we have and in or not in operator then we need either a function or an open paren
                if (token.getResult().getLastOperator() === 'in' || token.getResult().getLastOperator() === 'not in' || token.getResult().getLastOperator() === 'was not in' || token.getResult().getLastOperator() === 'was in') {
                    token.getResult().setNeedsOpenParen(true);
                }

                var operand = this.listOperand(token, true);
                if (operand.length === 0) {
                    operand = this.functionOperand(token);
                    if (operand.length === 0) {
                        operand = this.singleValueOperand(token);
                    }
                    else {
                        // We were handled by a function so we no longer need the open paren
                        token.getResult().setNeedsOpenParen(false);
                    }
                }
                else {
                    // We were handled by a list so we no longer need the open paren
                    token.getResult().setNeedsOpenParen(false);
                }

                if (operand === null || operand.length === 0) {
                    var remainingString = token.remainingString();
                    token.getResult().setLastOperand(remainingString, token);
                    token.getResult().setNeedsOperand();
                    token.setParseError();
                }
                if (operand.length !== 0) {
                    return operand;
                }
                return "";
            },

            singleValueOperand: function(token) {
                var operand = this.stringValue(token);
                if (operand.length !== 0) {
                    token.getResult().setLastOperand(operand, token);
                    // Lets exclude empty and null, even though it is reserved
                    if (operand.toLowerCase() !== "empty" && operand.toLowerCase() !== "null" && this.isReservedWord(operand.toLowerCase())) {
                        // These are reserved words
                        token.setParseError();
                    }
                    return operand;
                }
                return "";
            },

            functionOperand: function(token) {
                var startIdx = token.getTokenStringIdx();
                var functionName = this.fieldOrFunctionName(token);
                // There can be whitespace between function name and arguments
                this.chewWhitespace(token);
                var listArguments = this.listOperand(token, false);
                if (functionName.length !== 0 && listArguments.length !== 0) {
                    var operand = functionName + listArguments;
                    // read in the whole value until we reach a close )
                    token.getResult().setLastOperand(operand, token);
                    return operand;
                }
                else {
                    // back track
                    token.backTrackToIdx(startIdx);
                    return "";
                }
            },

            listOperand: function(token, treatAsOperands) {
                if (token.currentCharacter() === '(') {
                    token.consumeCharacter();
                    var listValue = this.collectListValues(token, treatAsOperands);
                    var operandVal = "(" + listValue;

                    this.chewWhitespace(token);
                    if (token.currentCharacter() === ')') {
                        token.consumeCharacter();
                        operandVal += ")";
                        if (operandVal === "()" && treatAsOperands) {
                            // Special case of an empty list which is still valid
                            token.getResult().setLastOperand(operandVal, token);
                        }
                        if (treatAsOperands) {
                            token.getResult().setOperandComplete();
                            token.getResult().resetNeedsPredicateOperand();
                        }
                    }
                    else {
                        token.setParseError();
                    }
                    return operandVal;
                }
                else {
                    return "";
                }
            },

            collectListValues: function(token, treatAsOperands) {
                if (treatAsOperands) {
                    token.getResult().setNeedsOperand();
                }
                this.chewWhitespace(token);

                // grab the contents of the list, they should be singleValueOperands separated by commas, we only
                // need to keep track of the last encountered operand.
                var currentOperand = (treatAsOperands) ? this.operand(token) : this.stringValue(token);

                if (currentOperand.length !== 0) {
                    // If there is whitespace then lets remember we need a comma
                    if (this.chewWhitespace(token) && treatAsOperands) {
                        token.getResult().setNeedsListComma();
                    }
                    if (token.currentCharacter() === ',') {
                        // Consume the comma and recurse so we can collect the other values
                        token.consumeCharacter();
                        var nextValue = this.collectListValues(token, treatAsOperands);
                        if (nextValue.length === 0) {
                            token.setParseError();
                        }
                        return currentOperand + ", " + nextValue;
                    }
                    else {
                        return currentOperand;
                    }
                }
                else {
                    return "";
                }
            },

            startsWithIgnoreCase: function(startStr, str) {
                if (str === null || startStr === null || str.length < startStr.length) {
                    return false;
                }
                else {
                    return startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
                }
            },

            startsWithLogicalOperator: function(str) {
                if (str === null) {
                    return false;
                }
                else {
                    return this.startsWithOr(str) || this.startsWithAnd(str) || this.startsWithNot(str) || this.startsWithBraces(str);
                }
            },

            startsWithOr: function(str) {
                return this.startsWithIgnoreCase("|", str) || this.startsWithIgnoreCase("||", str) ||
                    this.startsWithIgnoreCase("or", str);
            },

            startsWithAnd: function(str) {
                return this.startsWithIgnoreCase("&", str) || this.startsWithIgnoreCase("&&", str) ||
                    this.startsWithIgnoreCase("and", str);
            },

            startsWithNot: function(str) {
                return this.startsWithIgnoreCase("!", str) ||
                    this.startsWithIgnoreCase("not", str);
            },

            startsWithBraces: function(str) {
                return this.startsWithIgnoreCase("(", str) ||
                    this.startsWithIgnoreCase(")", str);
            },

            chewWhitespace: function(token) {
                var foundWhiteSpace = false;
                var currentChar = token.currentCharacter();
                while (currentChar !== null && grammar.REGEXP_WHITESPACE.test(currentChar)) {
                    token.consumeCharacter();
                    currentChar = token.currentCharacter();
                    foundWhiteSpace = true;
                }
                return foundWhiteSpace;
            },

            getLongestOperatorMatch: function(value, listOfValues) {
                var longestMatch = null;
                var matchArray;
                // These first three cases are special since they might have more to them
                if (this.startsWithIgnoreCase("is", value)) {
                    // Look ahead for NOT, if we don't find it next then we must just be is
                    matchArray = value.substring(2).match(grammar.REGEXP_SNOT);

                    if (matchArray) {
                        longestMatch = value.substring(0, matchArray[0].length + 2);
                    }
                    else {
                        longestMatch = "is";
                    }
                }
                if (this.startsWithIgnoreCase("was", value)) {
                    // Look ahead for NOT or IN , if we don't find it next then we must just be was
                    matchArray = value.substring(3).match(grammar.REGEXP_SNOT_IN);

                    if (matchArray) {
                        longestMatch = value.substring(0, matchArray[0].length + 3);
                    }
                    else {
                        longestMatch = "was";
                    }
                }
                else if (this.startsWithIgnoreCase("not", value)) {
                    // Look ahead for IN, if we don't find it next then we are not an operator
                    var matchArrayNot = value.substring(3).match(grammar.REGEXP_SIN);

                    if (matchArrayNot) {
                        longestMatch = value.substring(0, matchArrayNot[0].length + 3);
                    }
                }
                else {
                    for (var i = 0; i < listOfValues.length; i++) {
                        if (this.startsWithIgnoreCase(listOfValues[i].value, value)) {
                            // We found a match
                            if (longestMatch === null || grammar.jql_operators[i].value.length > longestMatch) {
                                longestMatch = grammar.jql_operators[i].value;
                            }
                        }
                    }
                }
                return longestMatch;
            },

            getValueMinusExtraWhitespace: function(value) {
                if (value === null) {
                    return null;
                }
                var newValue = "";
                var firstWhitespace = true;
                var valueArr = value.split("");
                for (var i = 0; i < valueArr.length; i++) {
                    var currentChar = valueArr[i];
                    if (grammar.REGEXP_WHITESPACE.test(currentChar)) {
                        // We want to ignore extra whitespace, keeping only the first
                        if (firstWhitespace) {
                            firstWhitespace = false;
                            newValue = newValue + currentChar;
                        }
                    }
                    else {
                        // If we encounter a non-whitespace then we want to reset our firstWhitespace test
                        firstWhitespace = true;
                        newValue = newValue + currentChar;
                    }
                }
                return newValue;
            },

            fieldOrFunctionName: function(token) {
                var stringValue = this.stringValue(token);
                // Field or function names can not be the empty string
                if (stringValue === "\"\"" || stringValue === "''") {
                    token.setParseError();
                }
                if (this.isReservedWord(stringValue.toLowerCase())) {
                    // These are reserved words
                    token.setParseError();
                }
                return stringValue;
            },

            isReservedWord: function(word) {
                return jQuery.inArray(word, jql_reserved_words) !== -1;
            },

            stringValue: function(token) {
                var stringValue = "";

                var inQuote = false;
                var inSingleQuote = false;
                var currentChar = token.currentCharacter();
                while (currentChar !== null && (inQuote || inSingleQuote || grammar.REGEXP_TOKEN_CHAR.test(currentChar))) {
                    // Read the escape character into the string
                    stringValue = stringValue + currentChar;
                    token.consumeCharacter();
                    // Handle the escape character
                    if (currentChar === '\\') {
                        // Just consume the next char as well
                        currentChar = token.currentCharacter();
                        if (currentChar === null) {
                            token.setParseError();
                            break;
                        }
                        // These are the only valid characters to escape
                        else if (grammar.REGEXP_CHARS_TO_ESCAPE.test(currentChar)) {
                            // Check for unicode escapes
                            var remainingString = token.remainingString();
                            if (!grammar.REGEXP_UNICODE.test(remainingString)) {
                                token.setParseError();
                                break;
                            }
                        }

                        stringValue = stringValue + currentChar;
                        token.consumeCharacter();
                    }
                    // Check for illegal characters and kill the whole parse
                    else if (grammar.REGEXP_SPECIAL_CHAR.test(currentChar) && !(inQuote || inSingleQuote)) {
                        token.setParseError();
                        break;
                    }
                    // We need to keep track if we are in a quote or not
                    else if (currentChar === '"' && !inSingleQuote) {
                        inQuote = !inQuote;
                    }
                    else if (currentChar === "'" && !inQuote) {
                        inSingleQuote = !inSingleQuote;
                    }
                    currentChar = token.currentCharacter();
                }
                // We should never get left in a quote or single quote
                if (token.isComplete() && (inQuote || inSingleQuote)) {
                    token.setParseError();
                }
                return stringValue;
            },

            numberValue: function(token) {
                var numberVal = "";

                this.chewWhitespace(token);
                var currentChar = token.currentCharacter();
                while (currentChar !== null) {
                    if (grammar.REGEXP_NUMBER.test(currentChar)) {
                        numberVal = numberVal + currentChar;
                        token.consumeCharacter();
                    }
                    else {
                        // found not a number time to return
                        break;
                    }
                    currentChar = token.currentCharacter();
                }
                return numberVal;
            },

            wasPredicateComplete: function(predicate) {
                var foundPredicate = false;
                var arLen = grammar.jql_changed_predicates.length;
                for (var i = 0; i < arLen; ++i) {
                    if (predicate.toLowerCase() == grammar.jql_changed_predicates[i].value.toLowerCase()) {
                        foundPredicate = true;
                        break;
                    }

                }
                return foundPredicate;
            }

        };
    };
});

define('jira/jql/jql-parse-result', function() {
    "use strict";

    /**
     * @exports jira/jql/jql-parse-result
     * @class JQLAutoComplete.ParseResult
     */
    return function() {

        var tokens = [];
        var tokenIdx = 0;

        return /** @lends JQLAutoComplete.ParseResult.prototype */ {

            getTokens: function() {
                return tokens;
            },

            addToken: function(token) {
                tokens[tokenIdx++] = token;
            },

            setLastFieldName: function(lastFieldName, token) {
                this.fieldNameStartIndex = (lastFieldName === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastFieldName.length);
                // Get rid of quotes if we need to
                this.lastFieldName = this.getUnquotedString(lastFieldName);
                tokens[tokenIdx++] = lastFieldName;
            },

            getLastFieldName: function() {
                return this.lastFieldName;
            },

            getLastFieldNameStartIndex: function() {
                return this.fieldNameStartIndex;
            },

            setLastOrderByFieldName: function(lastFieldName, token) {
                this.orderByFieldNameStartIndex = (lastFieldName === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastFieldName.length);
                // Get rid of quotes if we need to
                this.lastOrderByFieldName = this.getUnquotedString(lastFieldName);
                this.lastOrderByDirection = null;
                tokens[tokenIdx++] = lastFieldName;
            },

            getLastOrderByFieldName: function() {
                return this.lastOrderByFieldName;
            },

            getLastOrderByFieldNameStartIndex: function() {
                return this.orderByFieldNameStartIndex;
            },

            setLastOrderByDirection: function(lastDirection, token) {
                this.orderByDirectionStartIndex = (lastDirection === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastDirection.length);
                this.lastOrderByDirection = lastDirection;
                tokens[tokenIdx++] = lastDirection;
            },

            getLastOrderByDirection: function() {
                return this.lastOrderByDirection;
            },

            getLastOrderByDirectionStartIndex: function() {
                return this.orderByDirectionStartIndex;
            },

            setNeedsField: function() {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsField = true;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = false;
                this.needsWasPredicate = false;
                this.lastWasOperator = null;
            },

            getNeedsField: function() {
                return this.needsField;
            },

            setNeedsOrderByField: function() {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsField = false;
                this.needsOrderByField = true;
                this.needsOrderByDirection = false;
                this.lastOrderByDirection = null;
                this.needsListComma = false;
            },

            getNeedsOrderByField: function() {
                return this.needsOrderByField;
            },

            setNeedsOrderByDirection: function() {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsField = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = true;
                this.needsListComma = false;
            },

            getNeedsOrderByDirection: function() {
                return this.needsOrderByDirection;
            },

            setNeedsOrderByComma: function() {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsField = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = false;
            },

            setNeedsListComma: function() {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsField = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = true;
            },

            getNeedsListComma: function() {
                return this.needsListComma;
            },

            setLastOperator: function(lastOperator, startIndex) {
                this.lastOperator = lastOperator;
                this.operatorStartIndex = startIndex;
                tokens[tokenIdx++] = lastOperator;
            },

            setLastWasOperator: function(lastWasOperator) {
                this.lastWasOperator = lastWasOperator;
            },

            getLastWasOperator: function() {
                return this.lastWasOperator;
            },

            getLastOperator: function() {
                return this.lastOperator;
            },

            getLastOperatorStartIndex: function() {
                return this.operatorStartIndex;
            },

            setLastOperand: function(lastOperand, token) {
                this.operandStartIndex = (lastOperand === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastOperand.length);
                // Get rid of quotes if we need to
                this.lastOperand = this.getUnquotedString(lastOperand);
                tokens[tokenIdx++] = lastOperand;
            },

            getLastOperand: function() {
                return this.lastOperand;
            },

            setNeedsOperand: function() {
                this.needsField = false;
                this.needsOperator = false;
                this.needsLogicalOperator = false;
                this.needsOperand = true;
                this.needsOrderBy = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = false;
            },

            setNeedsOperandOrOperator: function() {
                this.needsField = false;
                this.needsOperator = true;
                this.needsLogicalOperator = false;
                this.needsOperand = true;
                this.needsOrderBy = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = false;
            },

            getNeedsOperand: function() {
                return this.needsOperand;
            },

            setNeedsPredicateOperand: function() {
                this.needsPredicateOperand = true;
            },

            resetNeedsPredicateOperand: function() {
                this.needsPredicateOperand = false;
                this.needsOperand = false;
            },

            getNeedsPredicateOperand: function() {
                return this.needsPredicateOperand;
            },

            getLastOperandStartIndex: function() {
                return this.operandStartIndex;
            },

            setLastOperandStartIndex: function(index) {
                this.operandStartIndex = index;
            },

            setLastLogicalOperator: function(lastLogicalOperator, startIndex) {
                this.lastLogicalOperator = lastLogicalOperator;
                this.logicalOperatorStartIndex = startIndex;
                tokens[tokenIdx++] = lastLogicalOperator;
            },

            setNeedsOperator: function() {
                this.needsField = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsOperator = true;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = false;
            },

            getNeedsOperatorOrOperand: function() {
                return this.needsOperator && this.needsOperand;
            },

            getNeedsOperator: function() {
                return this.needsOperator;
            },

            getLastLogicalOperator: function() {
                return this.lastLogicalOperator;
            },

            getLastLogicalOperatorStartIndex: function() {
                return this.logicalOperatorStartIndex;
            },

            setNeedsLogicalOperator: function(token) {
                this.needsLogicalOperator = true;
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsField = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = false;
                // Every time we need a logical operator we also could need an order by as long as we are not in parens
                this.needsOrderBy = !token.getInParens();
                // Every time a logical operator is needed you may need a predicate, but only if the last clause
                // was a was clause
                if (this.lastWasOperator != null) {
                    this.needsWasPredicate = true;
                }
            },

            setNeedsOpenParen: function(value) {
                this.needsOpenParen = value;
            },

            getNeedsOpenParen: function() {
                return this.needsOpenParen;
            },

            getNeedsLogicalOperator: function() {
                return this.needsLogicalOperator;
            },

            setNeedsOrderBy: function(value) {
                this.needsOrderBy = value;
            },

            getNeedsOrderBy: function() {
                return this.needsOrderBy;
            },

            getNeedsWasPredicate: function() {
                return this.needsWasPredicate;
            },

            setLastWasPredicate: function(lastWasPredicate, token) {
                this.wasPredicateStartIndex = (lastWasPredicate === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastWasPredicate.length);
                this.lastWasPredicate = lastWasPredicate;
                tokens[tokenIdx++] = lastWasPredicate;
            },

            getLastWasPredicate: function() {
                return this.lastWasPredicate;
            },

            resetLastPredicates: function() {
                this.lastLogicalOperator = null;
                this.lastWasPredicate = null;
                this.lastOperand = null;
                this.wasPredicateStartIndex = null;
                this.operandStartIndex = null;
            },

            getLastWasPredicateStartIndex: function() {
                return this.wasPredicateStartIndex;
            },

            setLastOrderBy: function(lastOrderBy, token) {
                this.orderByStartIndex = (lastOrderBy === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastOrderBy.length);
                this.lastOrderBy = lastOrderBy;
                tokens[tokenIdx++] = lastOrderBy;
            },

            getLastOrderBy: function() {
                return this.lastOrderBy;
            },

            getLastOrderByStartIndex: function() {
                return this.orderByStartIndex;
            },

            resetLogicalOperators: function() {
                this.lastLogicalOperator = null;
                this.logicalOperatorStartIndex = null;
                this.needsLogicalOperator = null;
            },

            getUnquotedString: function(value) {
                // We only remove the last quote if it is NOT preceeded by an escape character
                var secondToLastNotEsacape = value != null && value.length >= 3 && value.charAt(value.length - 2) !== '\\';

                if (value != null && value.charAt(0) === '"') {
                    value = value.substring(1, value.length);

                    if (value.charAt(value.length - 1) === '"' && secondToLastNotEsacape) {
                        value = value.substring(0, value.length - 1);
                    }
                }
                else if (value != null && value.charAt(0) === "'") {
                    value = value.substring(1, value.length);

                    if (value.charAt(value.length - 1) === "'" && secondToLastNotEsacape) {
                        value = value.substring(0, value.length - 1);
                    }
                }

                return value;
            },

            setParseError: function(message) {
                this.parseError = true;
                this.parseErrorMsg = message;
            },

            getParseError: function() {
                return this.parseError;
            },

            getParseErrorMsg: function() {
                return this.parseErrorMsg;
            },

            setNeedsNothing: function() {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsField = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsOpenParen = false;
                this.needsListComma = false;
                this.needsWasPredicate = null;
                this.needsPredicateOperand = null;
                this.mustBeOperatorOrPredicate = null;
                this.lastWasOperator = null;
            },

            setOperandComplete: function() {
                this.operandComplete = true;
            },

            getOperandComplete: function() {
                return this.operandComplete;
            },

            setMustBeOperatorOrPredicate: function(state) {
                this.mustBeOperatorOrPredicate = state;
            },

            getMustBeOperatorOrPredicate: function() {
                return this.mustBeOperatorOrPredicate;
            },

            resetTerminalClause: function() {
                this.lastFieldName = null;
                this.fieldNameStartIndex = null;
                this.needsField = null;
                this.lastOperator = null;
                this.operatorStartIndex = null;
                this.needsOperator = null;
                this.lastOperand = null;
                this.operandStartIndex = null;
                this.needsOperand = null;
                this.operandComplete = null;
                this.needsOpenParen = null;
                this.needsListComma = false;
                this.mustBeOperatorOrPredicate = null;
            },

            /** @private */
            init: function() {
                this.lastFieldName = null;
                this.fieldNameStartIndex = null;
                this.needsField = null;
                this.lastOperator = null;
                this.operatorStartIndex = null;
                this.needsOperator = null;
                this.lastOperand = null;
                this.operandStartIndex = null;
                this.needsOperand = null;
                this.lastLogicalOperator = null;
                this.logicalOperatorStartIndex = null;
                this.lastOrderByFieldName = null;
                this.lastOrderByFieldNameStartIndex = null;
                this.lastOrderByDirection = null;
                this.lastOrderByDirectionStartIndex = null;
                this.orderByStartIndex = null;
                this.lastOrderBy = null;
                this.needsOrderBy = null;
                this.needsOrderByField = null;
                this.needsOrderByDirection = null;
                this.operandComplete = null;
                this.needsOpenParen = null;
                this.needsListComma = null;
                this.wasPredicateStartIndex = null;
                this.lastWasPredicate = null;
                this.needsWasPredicate = null;
                this.needsPredicateOperand = null;
                this.mustBeOperatorOrPredicate = null;
                this.lastWasOperator = null;
            }
        };
    };
});

define('jira/jql/jql-parse-token', [
    'jira/jql/jql-parse-result'
], function(
    ParseResult
) {
    "use strict";

    /**
     * @exports jira/jql/jql-parse-token
     * @class JQLAutoComplete.Token
     */
    return function() {
        return /** @lends JQLAutoComplete.Token.prototype */ {

            init: function(tokenString) {
                this.tokenStringIdx = 0;
                this.tokenString = tokenString;
                this.parseError = false;
                this.parseErrorMsg = null;
                this.result = ParseResult();
                this.result.init();
                this.inParens = 0;
            },

            consumeCharacter: function() {
                this.tokenStringIdx++;
            },

            consumeCharacters: function(numChars) {
                this.tokenStringIdx = this.tokenStringIdx + numChars;
            },

            backTrackToIdx: function(backTrackIdx) {
                this.tokenStringIdx = backTrackIdx;
                // Lets clear any parse errors that might have occurred as well
                this.parseError = false;
                this.parseErrorMsg = null;
                this.result.parseError = false;
                this.result.parseErrorMsg = null;
            },

            getTokenStringIdx: function() {
                return this.tokenStringIdx;
            },

            currentCharacter: function() {
                if (this.tokenStringIdx >= this.tokenString.length) {
                    return null;
                }
                return this.tokenString.charAt(this.tokenStringIdx);
            },

            remainingString: function() {
                if (this.tokenStringIdx >= this.tokenString.length) {
                    return null;
                }
                return this.tokenString.substr(this.tokenStringIdx, this.tokenString.length);
            },

            getMaxTokenStringIdx: function() {
                return this.tokenString.length;
            },

            isComplete: function() {
                if (this.parseError) {
                    return true;
                }
                return this.tokenStringIdx >= this.tokenString.length;
            },

            setInParens: function() {
                this.inParens++;
            },

            setOutOfParens: function() {
                // Lets never go into negative here
                if (this.inParens !== 0) {
                    this.inParens--;
                }
            },

            getInParens: function() {
                return this.inParens !== 0;
            },

            setParseError: function() {
                this.parseError = true;
                var preFixIdx = ((this.tokenStringIdx - 9) < 0) ? 0 : this.tokenStringIdx - 9;
                var errorPrefix = this.tokenString.substring(preFixIdx, this.tokenStringIdx - 1);
                this.result.setParseError("..." + errorPrefix + "^" + this.tokenString.substring(this.tokenStringIdx, this.tokenString.length));
            },

            getParseError: function() {
                return this.parseError;
            },

            calcLastOperandStartIndex: function() {
                var result = this.getResult();
                var operator = result.getLastOperator();
                if (operator.length > 0) {
                    var numSpaces = operator.length - (operator.replace(/\s+/g, '')).length;
                    result.setLastOperandStartIndex(result.getLastOperatorStartIndex() + operator.length + numSpaces + 1);
                }
            },

            getParsedOperator: function() {
                var result = this.getResult();
                return (result.getLastOperator().length > 0) ? this.tokenString.substr(result.getLastOperatorStartIndex()) : null;
            },

            getResult: function() {
                return this.result;
            }

        };

    };
});

/** Preserve legacy namespace
 @deprecated jira.widget.autocomplete.JQL */
AJS.namespace("jira.widget.autocomplete.JQL", null, require('jira/autocomplete/jql-autocomplete'));
AJS.namespace("JIRA.JQLAutoComplete", null, require('jira/autocomplete/jql-autocomplete'));
AJS.namespace("JIRA.JQLAutoComplete.MyParser", null, require('jira/jql/jql-parser'));
AJS.namespace("JIRA.JQLAutoComplete.ParseResult", null, require('jira/jql/jql-parse-result'));
AJS.namespace("JIRA.JQLAutoComplete.Token", null, require('jira/jql/jql-parse-token'));
;
;
/* module-key = 'jira.webresources:jqlautocomplete', location = '/includes/jira/autocomplete/initJQLAutoComplete.js' */
;(function() {
    "use strict";

    var JQLAutoComplete = require('jira/autocomplete/jql-autocomplete');
    var JQLParser = require('jira/jql/jql-parser');
    var Forms = require('jira/util/forms');
    var jQuery = require('jquery');

    jQuery(function() {

        jQuery(".jql-autocomplete-params").each(function() {
            var params = {};

            jQuery(this).find("input").each(function() {
                var $this = jQuery(this);
                params[$this.attr("id")] = $this.val();
            });

            var jqlFieldNames = JSON.parse(jQuery("#jqlFieldz").text());
            var jqlFunctionNames = JSON.parse(jQuery("#jqlFunctionNamez").text());
            var jqlReservedWords = JSON.parse(jQuery("#jqlReservedWordz").text());

            var jqlAutoComplete = JQLAutoComplete({
                fieldID: 'jqltext',
                parser: JQLParser(jqlReservedWords),
                queryDelay: 0.65,
                jqlFieldNames: jqlFieldNames,
                jqlFunctionNames: jqlFunctionNames,
                minQueryLength: 0,
                allowArrowCarousel: true,
                autoSelectFirst: false,
                errorID: 'jqlerrormsg'
            });

            var jQueryRef = jQuery('#jqltext');

            jQueryRef.unbind("keypress", Forms.submitOnEnter).keypress(
                function(e) {
                    if (jqlAutoComplete.dropdownController === null || !jqlAutoComplete.dropdownController.displayed || jqlAutoComplete.selectedIndex < 0) {
                        if (e.keyCode === 13 && !e.ctrlKey && !e.shiftKey) {
                            jQuery('#jqlform').submit();
                            return false;
                        } else {
                            return true;
                        }
                    }
                });
            jqlAutoComplete.buildResponseContainer();
            jqlAutoComplete.parse(jQueryRef.text());
            jqlAutoComplete.updateColumnLineCount();

            jQueryRef.click(function() {
                jqlAutoComplete.dropdownController.hideDropdown();
            });
        });
    });
})();
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'util/utils.js' */
(function() {
    "use strict";

    var FunctionalUtils = require("jira/components/util/functionalutils");

    _.mixin({
        lambda: FunctionalUtils.lambda,
        isNotBlank: FunctionalUtils.isNotBlank
    });

    if (!JIRA.Issues) {
        JIRA.Issues = {};
    }

    /**
     * Adds the class 'checkboxmultiselect-container' to the parent form-body div of a sparker.
     * This removes the implicit padding from the container as all other types of searchers
     * have padding by default.
     */
    JIRA.bind(JIRA.Events.CHECKBOXMULITSELECT_READY, function(e, $select) {
        $select.closest(".form-body").addClass("checkboxmultiselect-container");
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/templates/util.soy' */
// This file was automatically generated from util.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Issues.ComponentUtil.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Issues == 'undefined') { JIRA.Templates.Issues = {}; }
if (typeof JIRA.Templates.Issues.ComponentUtil == 'undefined') { JIRA.Templates.Issues.ComponentUtil = {}; }


JIRA.Templates.Issues.ComponentUtil.throbber = function(opt_data, opt_ignored) {
  return '<div class="icon throbber" />';
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.throbber.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.throbber';
}


JIRA.Templates.Issues.ComponentUtil.simpleLink = function(opt_data, opt_ignored) {
  return '<a' + ((opt_data.link.id) ? ' id="' + soy.$$escapeHtml(opt_data.link.id) + '"' : '') + 'href="' + ((opt_data.link.href) ? soy.$$escapeHtml(opt_data.link.href) : '#') + '"' + ((opt_data.link.styleClass || opt_data.additionalStyleClass) ? 'class="' + soy.$$escapeHtml(opt_data.link.styleClass) + ((opt_data.additionalStyleClass) ? ' ' + soy.$$escapeHtml(opt_data.additionalStyleClass) : '') + '"' : '') + ((opt_data.link.title) ? 'title="' + soy.$$escapeHtml(opt_data.link.title) + '"' : '') + '><span>' + soy.$$escapeHtml(opt_data.link.label) + '</span></a>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.simpleLink.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.simpleLink';
}


JIRA.Templates.Issues.ComponentUtil.issueNotFound = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("issues.components.query.search.selected.issue.nonexistent.html",opt_data.issueAnchor));
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.issueNotFound.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.issueNotFound';
}


JIRA.Templates.Issues.ComponentUtil.issueAnchor = function(opt_data, opt_ignored) {
  return '<a class="issue-key" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.issueKey) + '"> ' + soy.$$escapeHtml(opt_data.issueKey) + ' </a>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.issueAnchor.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.issueAnchor';
}


JIRA.Templates.Issues.ComponentUtil.buildMessage = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.messages.length == 1) {
    output += soy.$$escapeHtml(opt_data.messages[0]);
  } else {
    output += '<ul>';
    var messageList52 = opt_data.messages;
    var messageListLen52 = messageList52.length;
    for (var messageIndex52 = 0; messageIndex52 < messageListLen52; messageIndex52++) {
      var messageData52 = messageList52[messageIndex52];
      output += '<li>' + soy.$$escapeHtml(messageData52) + '</li>';
    }
    output += '</ul>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.buildMessage.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.buildMessage';
}


JIRA.Templates.Issues.ComponentUtil.auiMessage = function(opt_data, opt_ignored) {
  return '' + ((opt_data.messages.length > 0) ? '<div class="aui-message ' + soy.$$escapeHtml(opt_data.typeClass) + '"><span class="aui-icon icon-' + soy.$$escapeHtml(opt_data.typeClass) + '"></span>' + JIRA.Templates.Issues.ComponentUtil.buildMessage(opt_data) + '</div>' : '');
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.auiMessage.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.auiMessage';
}


JIRA.Templates.Issues.ComponentUtil.errorMessage = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + JIRA.Templates.Issues.ComponentUtil.auiMessage({typeClass: 'error', messages: opt_data.messages ? opt_data.messages : [opt_data.msg]});
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.errorMessage.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.errorMessage';
}


JIRA.Templates.Issues.ComponentUtil.warningMessage = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + JIRA.Templates.Issues.ComponentUtil.auiMessage({typeClass: 'warning', messages: opt_data.messages ? opt_data.messages : [opt_data.msg]});
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.warningMessage.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.warningMessage';
}


JIRA.Templates.Issues.ComponentUtil.anonymousErrorDialog = function(opt_data, opt_ignored) {
  return '<div class="aui-dialog-content"><div class="form-body"><h2 class="dialog-title">' + soy.$$escapeHtml("Session Expired") + '</h2>' + JIRA.Templates.Issues.ComponentUtil.auiMessage({typeClass: 'warning', messages: ["It looks like your session has timed out, or you have been logged out of JIRA. You will need to log back in to continue."]}) + '</div><div class="buttons-container form-footer"><div class="buttons"><a accesskey="' + soy.$$escapeHtml("s") + '" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to submit this form","s",opt_data.modifierKey)) + '" class="aui-button submit" href="' + soy.$$escapeHtml("/jira") + '/login.jsp?os_destination=' + soy.$$escapeHtml(opt_data.redirect) + '">' + soy.$$escapeHtml("Log in again") + '</a><a accesskey="' + soy.$$escapeHtml("`") + '" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to cancel","`",opt_data.modifierKey)) + '" class="aui-button aui-button-link cancel">' + soy.$$escapeHtml("Ignore") + '</a></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.anonymousErrorDialog.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.anonymousErrorDialog';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/SingleSelectMixin.js' */
define("jira/components/query/mixin/singleselect", function() {
    "use strict";

    /**
     * Mixin that provides single selection on a collection.
     * Requires that the object being mixed into provides "getSelected" and "setSelected" methods. These can be created by having a "selected" attribute or otherwise.
     */
    return {

        /**
         * collection: item in selection
         */
        namedAttributes: ["collection"],

        /**
         * Selects the model with the given id. No validation is done; if the id is invalid, this.selected will be undefined.
         * @param id if of model to select.
         */
        selectById: function(id) {
            this.setSelected(this.getCollection().get(id));
        },

        /**
         * Selects the model and the given index.
         * @param index index of model to select
         */
        selectAt: function(index) {
            this.setSelected(this.getCollection().at(index));
        },

        /**
         * Clears selection
         */
        clearSelection: function() {
            this.setSelected();
        },

        /**
         * Selects the next element, or the first if none is selected.
         */
        next: function() {
            var selected = this.getSelected();
            var col = this.getCollection();

            if (!selected) {
                if (col.length > 0) {
                    this.setSelected(col.first());
                }
            }
            else {
                var index = col.indexOf(selected);
                var nextIndex = (index + 1) % col.length;
                this.setSelected(col.at(nextIndex));
            }
        },

        /**
         * Selects the previous element, or the last if none is selected.
         */
        prev: function() {
            var selected = this.getSelected();
            var col = this.getCollection();

            if (!selected) {
                if (col.length > 0) {
                    this.setSelected(col.last());
                }
            }
            else {
                var index = col.indexOf(selected);
                var nextIndex = (index + col.length - 1) % col.length;
                this.setSelected(col.at(nextIndex));
            }
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/templates/query-basic.soy' */
// This file was automatically generated from query-basic.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavQueryBasic.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavQueryBasic == 'undefined') { JIRA.Templates.IssueNavQueryBasic = {}; }


JIRA.Templates.IssueNavQueryBasic.basicQueryView = function(opt_data, opt_ignored) {
  return '<div class="search-field-container">' + ((opt_data.hasOrderBy) ? '<div class="list-ordering-container"><div class="list-ordering"></div></div>' : '') + '<div class="search-criteria-container"><div class="search-criteria"><ul class="criteria-list"><li class="text-query hidden"><div class="text-query-container"><input class="search-entry text ajs-dirty-warning-exempt" id="searcher-query" type="text" name="text" placeholder="' + soy.$$escapeHtmlAttribute("Contains text") + '" /></div></li><li class="criteria-actions"></li>' + ((opt_data.hasSearchButton) ? '<li><button class="aui-button aui-button-subtle search-button" type="button" title="' + soy.$$escapeHtmlAttribute("Search for issues") + '"><span class="aui-icon aui-icon-small aui-iconfont-search">' + soy.$$escapeHtml("Search") + '</span></button></li>' : '') + '</ul></div><div class="search-criteria-extended"><ul class="criteria-list"></ul></div></div></div><div class="search-options-container"><div class="mode-switcher"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.basicQueryView.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.basicQueryView';
}


JIRA.Templates.IssueNavQueryBasic.criteriaButton = function(opt_data, opt_ignored) {
  return '<button type="button" data-id="' + soy.$$escapeHtmlAttribute(opt_data.id) + '" class="criteria-selector aui-button aui-button-subtle drop-arrow" /><a href="#" class="remove-filter" title="' + soy.$$escapeHtmlAttribute("Remove criterion") + '" tabindex="-1"><span class="aui-icon aui-icon-small aui-iconfont-remove"></span></a>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.criteriaButton.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.criteriaButton';
}


JIRA.Templates.IssueNavQueryBasic.criteriaButtonContent = function(opt_data, opt_ignored) {
  return '<div class="criteria-wrap">' + ((opt_data.extended || ! opt_data.viewHtml) ? '<span class="fieldLabel">' + soy.$$escapeHtml(opt_data.name) + ':</span> ' : '') + ((opt_data.viewHtml) ? soy.$$filterNoAutoescape(opt_data.viewHtml) : soy.$$escapeHtml("All")) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.criteriaButtonContent.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.criteriaButtonContent';
}


JIRA.Templates.IssueNavQueryBasic.lozengeDropdownContent = function(opt_data, opt_ignored) {
  return '<form id="issue-filter" action="#" class="searchfilter aui top-label aui-popup-content"><div class="form-body"></div>' + ((opt_data.displayBackButton) ? '<a href="#" class="back">' + soy.$$escapeHtml("Back") + '</a>' : '') + ((opt_data.displayUpdateCancel) ? '<div class="buttons-container form-footer"><div class="buttons"><input type="submit" name="filter" class="aui-button filter" value="' + soy.$$escapeHtmlAttribute("Update") + '" /><a href="#" class="aui-button aui-button-link cancel-update">' + soy.$$escapeHtml("Close") + '</a></div></div>' : '') + '</form>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.lozengeDropdownContent.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.lozengeDropdownContent';
}


JIRA.Templates.IssueNavQueryBasic.lozengeDropdownCannotEdit = function(opt_data, opt_ignored) {
  return '<div class="searcher-no-edit-content">' + JIRA.Templates.Issues.ComponentUtil.auiMessage({typeClass: 'info', messages: [AJS.format("To search by {0} please switch to advanced.",opt_data.fieldName)]}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.lozengeDropdownCannotEdit.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.lozengeDropdownCannotEdit';
}


JIRA.Templates.IssueNavQueryBasic.clauseButtonView = function(opt_data, opt_ignored) {
  return '<button type="button" class="add-criteria aui-button ' + ((opt_data.isSubtle) ? 'aui-button-subtle' : '') + ' drop-arrow" title="' + soy.$$escapeHtmlAttribute("Add more fields to search with") + '">' + soy.$$escapeHtml("More") + '</button>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.clauseButtonView.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.clauseButtonView';
}


JIRA.Templates.IssueNavQueryBasic.searcherDropdownContent = function(opt_data, opt_ignored) {
  var output = '<div class="searcher-groups available"><ul>';
  var groupList71 = opt_data.searcherGroups;
  var groupListLen71 = groupList71.length;
  for (var groupIndex71 = 0; groupIndex71 < groupListLen71; groupIndex71++) {
    var groupData71 = groupList71[groupIndex71];
    output += '<li class="twixi-block ' + ((groupIndex71 == 0) ? 'expanded' : 'collapsed') + '" data-id="' + soy.$$escapeHtmlAttribute(groupData71.id) + '"><div class="twixi-trigger">' + soy.$$escapeHtml(groupData71.name) + '</div><ul class="twixi-content">';
    var searcherList83 = groupData71.searchers;
    var searcherListLen83 = searcherList83.length;
    for (var searcherIndex83 = 0; searcherIndex83 < searcherListLen83; searcherIndex83++) {
      var searcherData83 = searcherList83[searcherIndex83];
      output += '<li><a href="#" data-id="' + soy.$$escapeHtmlAttribute(searcherData83.id) + '" class="searcher-option" >' + soy.$$escapeHtml(searcherData83.name) + '</a></li>';
    }
    output += '</ul></li>';
  }
  output += '</ul><div class="buttons-container"><div class="buttons"><a href="#" class="aui-button aui-button-link">' + soy.$$escapeHtml("Close") + '</a></div></div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.searcherDropdownContent.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.searcherDropdownContent';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/TextQueryBuilder.js' */
define("jira/components/query/basic/textquerybuilder", ["require"], function(require) {
    "use strict";

    var jQuery = require("jquery");

    return {
        BACKSLASH_PATTERN: /\\/g,
        MULTIPLE_WHITESPACE_PATTERN: /\s+/g,
        QUOTE_PATTERN: /\"/g,

        DOUBLE_BACKSLASH: "\\\\",

        buildJql: function(textQuery) {
            if (!textQuery) {
                return "";
            }
            textQuery = "" + textQuery;
            textQuery = jQuery.trim(textQuery);
            textQuery = textQuery.replace(this.BACKSLASH_PATTERN, this.DOUBLE_BACKSLASH); // replace single literal backslash with two backslashes (escaped here)
            textQuery = textQuery.replace(this.MULTIPLE_WHITESPACE_PATTERN, " "); // remove multiple whitespaces
            textQuery = textQuery.replace(this.QUOTE_PATTERN, "\\\"");
            return this.createQueryClause(textQuery);
        },

        createQueryClause: function(searchTerm) {
            return 'text ~ "' + searchTerm + '"';
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/BasicQueryModule.js' */
define("jira/components/query/basic/basicquerymodule", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var BasicQueryView = require("jira/components/query/basic/basicqueryview");
    var SearcherCollection = require("jira/components/query/basic/searchercollection");

    /**
     * Module for basic query mode
     */
    return Brace.Evented.extend({

        namedEvents: ["jqlTooComplex", "searchRequested", "basicModeCriteriaCountWhenSearching", "verticalResize"],

        initialize: function(options) {
            this._queryStateModel = options.queryStateModel;
            this.searcherCollection = new SearcherCollection([], {
                fixedLozenges: options.primaryClauses,
                queryStateModel: options.queryStateModel,
                initData: options.initialSearcherCollectionState,
                context: options.context
            });
            this.view = new BasicQueryView({
                queryStateModel: options.queryStateModel,
                searcherCollection: this.searcherCollection
            })
                .onVerticalResize(this.triggerVerticalResize, this)
                .onSearchRequested(this.triggerSearchRequested, this);

            this.searcherCollection.onSearchRequested(_.bind(function(jql) {
                this.triggerBasicModeCriteriaCountWhenSearching({
                    count: this.searcherCollection.getAllSelectedCriteriaCount()
                });
                var jqlWithOrderBy = this._attachOrderByClause(jql);
                this.triggerSearchRequested(jqlWithOrderBy);
            }, this));

            this.searcherCollection.onJqlTooComplex(_.bind(function(jql) {
                this.triggerJqlTooComplex(jql);
            }, this));
        },

        hasErrors: function() {
            return this.searcherCollection.any(function(searcherModel) {
                return searcherModel.hasErrorInEditHtml();
            });
        },

        /**
         * Remove all searchers and clear the text query.
         */
        clear: function() {
            this.searcherCollection.clear();
        },

        queryChanged: function() {
            this.searcherCollection.restoreFromQuery(this._queryStateModel.getJql());
        },

        queryReset: function(jql) {
            this.searcherCollection.setInteractive(false);
            return this.searcherCollection.restoreFromQuery(jql, true).always(_.bind(function() {
                this.searcherCollection.setInteractive(true);
            }, this));
        },

        /**
         * Wait any in flight updates to search collection.
         */
        searchersReady: function() {
            return this.searcherCollection.searchersReady();
        },

        createView: function() {
            return this.view;
        },

        getSelectedCriteria: function() {
            return this.searcherCollection.getAllSelectedCriteria();
        },

        _attachOrderByClause: function(jql) {
            var orderByRegex = /\bORDER\s+BY\b.*$/i;
            var existingOrderByClause = orderByRegex.exec(this._queryStateModel.getJql());
            if (existingOrderByClause && orderByRegex.exec(jql) === null) {
                jql = jql ? jql + ' ' + existingOrderByClause[0] : existingOrderByClause[0];
            }
            return jql;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/CriteriaView.js' */
define("jira/components/query/basic/criteriaview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryBasic = require("jira/components/query/templates/issuenavquerybasic");
    var SearcherDialog = require("jira/components/query/basic/searcherdialog");
    var Tipsy = require("jira/issues/tipsy");

    return Brace.View.extend({

        tagName: 'li',

        template: IssueNavQueryBasic.criteriaButton,
        contentTemplate: IssueNavQueryBasic.criteriaButtonContent,

        events: {
            'click': 'hideTipsy',
            'click .criteria-selector': '_onClickCriteriaSelector',
            'click .remove-filter': '_onClickRemoveCriteria',
            'mousedown .remove-filter': '_preventFocusWhileDisabled',
            'keydown': '_onKeydown'
        },

        initialize: function(options) {
            this.extended = options.extended; // Indicates that a valid criteria can be removed from the UI
            this.searcherCollection = options.searcherCollection;
            this.searcherCollection.onCollectionChanged(this.update, this);
            this.searcherCollection.onInteractiveChanged(this._handleInteractiveChanged, this);
            this.searcherCollection.bind('change:isSelected', this._onCriteriaSelectionChanged, this);

            SearcherDialog.instance.onHide(_.bind(this._addTooltip, this));
            SearcherDialog.instance.onShow(_.bind(this._onCriteriaDialogShow, this));
        },

        /**
         * Initial render, should only be called once
         */
        render: function() {
            this.$el.html(this.template({
                id: this.model.getId()
            }));
            this.$el.attr('data-id', this.model.getId());
            if (this.extended) {
                this.$el.addClass('extended-searcher');
            }
            this.update();
            this.prepareForDisplay();
        },

        /**
         * Prepare the view before it is displayed: hook up event handlers, etc.
         */
        prepareForDisplay: function() {
            this._addTooltip();
            this.delegateEvents();
        },

        hideTipsy: function() {
            if (this.tipsy) {
                this.tipsy.hide();
            }
        },

        /**
         * Update view to reflect model changes
         */
        update: function() {

            var noSearchers = this.searcherCollection.length === 0; // Searchers have not loaded, but render them anyway default 'All' value
            var searcher = this._getSearcher();
            var validSearcher = this._isValidSearcher();
            var hidden = (!noSearchers && !searcher) || (searcher && !searcher.getIsShown()); // Searchers have loaded, but this searcher is not present
            var disabled = noSearchers || !validSearcher;
            var $button = this.$('button');
            var $cross = this.$('.remove-filter');

            this.$el.toggleClass('hidden', hidden);

            $button
                .attr('aria-disabled', disabled ? 'true' : null)
                .html(this.contentTemplate({
                    name: searcher && searcher.getName() || this.model.getName(),
                    viewHtml: searcher && searcher.getViewHtml(),
                    extended: this.extended
                }));

            // Validity
            this.$el
                .toggleClass('invalid-searcher', !validSearcher)
                .toggleClass('partial-invalid-searcher', (validSearcher && $button.find(".invalid_sel").length !== 0));

            $cross.toggleClass('hidden', !(!validSearcher || !!this.extended));

            return this;
        },

        /**
         * Destroys and cleans up the criteria view.
         * As the name implies, this is a destructive operation, and the View should not be used afterwards (construct a new one if needed).
         * Meant for use with extended criteria - primary criteria should only be hidden, not destroyed.
         */
        destroy: function() {
            this.hideTipsy();
            this.$el.remove();
        },

        _getSearcher: function() {
            return this.searcherCollection.get(this.model.getId());
        },

        /**
         * Searcher validity: returns true if there is no searcher, or searcher is valid
         */
        _isValidSearcher: function() {
            var searcher = this._getSearcher();
            return !searcher || (searcher.getValidSearcher() !== false); // Assume getValidSearcher()===undefined means valid searcher
        },

        /**
         * Value validity: returns true if there is an invalid value for the searcher
         */
        _containsInvalidValue: function(searcher) {
            return (jQuery(searcher.getViewHtml()).find('.invalid_sel').length > 0);
        },

        _showDialog: function() {
            if (this.searcherCollection.isInteractive() && this._getSearcher() && this._isValidSearcher()) {
                SearcherDialog.instance.show(this._getSearcher());
            }
        },

        /**
         * Clear the searcher jql for this criteria
         *
         * direction is optional, and supplied when removing a criteria by
         * Backspace or Delete keys, which have an implicit direction associated with them.
         * The direction is passed along with the beforeCriteriaRemoved event so BasicQueryView can choose
         * an appropriate element to focus.
         *
         * If supplied, direction is either -1 (back) or 1 (forward)
         */
        _removeCriteria: function(direction) {
            var removable = this.extended || !this._isValidSearcher();
            if (this.searcherCollection.isInteractive() && removable) {
                this.searcherCollection.triggerBeforeCriteriaRemoved(this.model.getId(), direction);
                /*
                 Need to defer otherwise InlineLayer will hide. This happens because the inline dialog chooses to close
                 if the target element clicked is not a child element of the InlineLayer. Because we switch the content in the
                 dialog, the back link is no longer in the InlineLayer therefor not a child element.  To rectify the problem
                 we delay the toggling of content.
                 */
                _.defer(_.bind(function() {
                    this.searcherCollection.clearClause(this.model.getId());
                }, this));
            }
        },

        /**
         * @return the text to show in the searcher's tooltip.
         * @private
         */
        _getTooltipText: function() {
            var searcherModel = this.searcherCollection.get(this.model.getId());
            var tooltipText;

            if (!this._isValidSearcher()) {
                tooltipText = "This criteria is not valid for the project and/or issue type";
            } else if (this._containsInvalidValue(searcherModel)) {
                tooltipText = "This criteria contains invalid value(s)";
            } else {
                tooltipText = searcherModel.getTooltipText();
            }

            return searcherModel && tooltipText || "";
        },

        /**
         * Add a tooltip to the searcher.
         * <p/>
         * This method can safely be called multiple times.
         *
         * @private
         */
        _addTooltip: function() {
            this.tipsy = new Tipsy({
                el: this.$el,
                showCondition: this.searcherCollection.isInteractive,
                tipsy: {
                    title: _.bind(this._getTooltipText, this)
                }
            });
        },

        _handleInteractiveChanged: function(interactive) {
            this.$("button, .remove-filter").attr("aria-disabled", (interactive) ? null : "true");
        },

        _onClickCriteriaSelector: function(event) {
            if (this.searcherCollection.isInteractive() && this._getSearcher() && this._isValidSearcher()) {
                SearcherDialog.instance.toggle(this._getSearcher());
            }
            event.preventDefault();
        },

        _onClickRemoveCriteria: function(event) {
            this._removeCriteria();
            event.preventDefault();
        },

        _onKeydown: function(event) {
            switch (event.which) {
                case jQuery.ui.keyCode.DOWN:
                    this._showDialog();
                    break;
                case jQuery.ui.keyCode.ESCAPE:
                    this.$('button:focus').blur();
                    break;
                case jQuery.ui.keyCode.BACKSPACE:
                    this._removeCriteria(-1);
                    break;
                case jQuery.ui.keyCode.DELETE:
                    this._removeCriteria(1);
                    break;
                default:
                    return;
            }
            event.preventDefault();
        },

        /**
         * Remove the searcher's tooltip if its dialog is showing.
         * <p/>
         * Called when jira/components/query/basic/searcherdialog is shown.
         *
         * @private
         */
        _onCriteriaDialogShow: function() {
            var currentSearcher = SearcherDialog.instance.getCurrentSearcher();
            if (currentSearcher === this._getSearcher()) {
                if (this.tipsy) {
                    this.tipsy.remove();
                }
            }
        },

        _preventFocusWhileDisabled: function(event) {
            if (jQuery(event.target).closest("[aria-disabled=true]").length > 0) {
                event.preventDefault();
            }
        }

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/SearcherModel.js' */
define("jira/components/query/basic/searchermodel", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var SmartAjax = require("jira/ajs/ajax/smart-ajax");
    var DisplayFailSearchMessage = JIRA.Issues.displayFailSearchMessage;
    var contextPath = AJS.contextPath();

    return Brace.Model.extend({
        /**
         * id: searcher id
         * name: The name of the clause
         * viewHtml: html to display in the criteria selector button, or the text to display in the input for the text searcher.
         * editHtml: html to display in the edit dropdown
         * groupId: group id
         * groupName: group name
         * isSelected: whether or not the searcher has been selected as a criteria for a search
         * jql: jql representation of the clause
         * position: The searcher's position in the extended criteria view.
         * validSearcher: is entire searcher valid for current search context
         * lastViewed: the time the searcher was last viewed in milliseconds
         */
        namedAttributes: [
            "id",
            "name",
            "isShown",
            "viewHtml",
            "editHtml",
            "groupId",
            "groupName",
            "initParams",
            "isSelected",
            "jql",
            "position",
            "serializedParams",
            "validSearcher",
            "key",
            "lastViewed"
        ],

        /**
         * readyForDisplay: edit html has been retrieved and is ready to be displayed
         */
        namedEvents: ["readyForDisplay"],

        initialize: function() {
            // Extract the "baseline" params from the edit HTML.
            this._onEditHtmlUpdated();
            this.bind("change:editHtml", this._onEditHtmlUpdated, this);
        },

        parse: function(json) {
            if (json.viewHtml) {
                json.viewHtml = this._cleanViewHtml(json.viewHtml);
            }
            return json;
        },

        /**
         * "Cleans" view HTML returned from the server for display.
         *
         * @param viewHtml The original view HTML.
         * @return the cleaned view HTML.
         * @private
         */
        _cleanViewHtml: function(viewHtml) {
            var $container = jQuery("<div/>").appendCatchExceptions(viewHtml);
            $container.find(".fieldLabel").remove();

            // Remove links, leaving their HTML content.
            $container.find("a").replaceWith(function() {
                return jQuery(this).html();
            });

            // Most searchers only have one "searcherValue" even if multiple values
            // are selected. For those with multiple, insert dashes between them.
            $container.find(".searcherValue").slice(0, -1).each(function() {
                jQuery(this).after('-');
            });

            // Remove titles so they don't conflict with our tooltips.
            $container.find("*").removeAttr("title");
            return $container.html();
        },

        /**
         * @param {Boolean} [forceUpdate=false] Force update of the JQL, even if autoupdate is disabled
         * @returns {*}
         */
        createOrUpdateClauseWithQueryString: function(forceUpdate) {
            return this.collection.createOrUpdateClauseWithQueryString(this.id, forceUpdate);
        },

        getQueryString: function() {

            var params = {};
            // custom handling for text query
            if (this.collection.QUERY_ID === this.getId()) {
                if (this.getViewHtml()) {
                    params[this.collection.QUERY_PARAM] = this.getDisplayText(); // query string shouldn't be html-encoded
                    return jQuery.param(params);
                }
                return null;
            }

            // return jql for invalid searchers as the server doesn't return editHtml if a searcher is invalid, but it does return jql
            if ((!this.getValidSearcher() || /^\s*$/.test(this.getEditHtml())) && this.getJql()) {
                params = {};
                params[this.collection.JQL_INVALID_QUERY_PREFIX + this.getId()] = this.getJql();
                return jQuery.param(params);
            }

            return this.getSerializedParams();
        },

        /**
         * Returns just the text of the viewHtml, cleaning up whitespace.
         */
        getDisplayText: function() {
            var html = this.getViewHtml();
            var text = '';
            if (html) {
                var $container = jQuery('<div>').appendCatchExceptions(html);
                text = jQuery.trim($container.text()).replace(/[\n\r\s]+/g, ' ');
            }
            return text;
        },

        hasClause: function() {
            if (this.collection.QUERY_ID === this.getId()) {
                return !!this.getViewHtml();
            }
            else if (!this.getValidSearcher()) {
                return !!this.getJql();
            }
            else {
                return !!this.getQueryString();
            }
        },

        /**
         * Reset the searcher's state.
         */
        clearSearchState: function() {
            this.set({
                viewHtml: null,
                editHtml: null,
                jql: null,
                validSearcher: null,
                isSelected: false
            });
        },

        /**
         * Returns the current time in milliseconds. Cannot always use Date.now() because of IE8.
         */
        _now: Date.now || function() {
            return new Date().getTime();
        },

        select: function() {
            this.set({
                isSelected: true,
                position: this.collection.getNextPosition(),
                validSearcher: true,
                lastViewed: this._now()
            });
        },

        /**
         * Ensures edit html exists. Triggers readyForDisplay when editHtml has been retrieved, which may be asynchronous if the value has not been retrieved,
         * or immediate if we already have editHtml
         */
        retrieveEditHtml: function() {
            var jql = this.collection.createJql();

            // TODO: Abort a pending request if there is one.
            // Avoid race condition -- ensure last request received is also last request issued.

            /* EditHtml is always populated when we request the list of searchers from the server,
             * for all searchers that have a value. We will always have editHtml when first showing a searcher.
             * this.getEditHtml() will be null in 2 cases:
             * - when we have just added a new searcher and it has no value
             * - when we have closed a dialog and are waiting for the list of searchers (and new editHtml) to update.
             * The second case is done because we *don't* cache the editHtml DOM elements. When showing an edit dialog
             * we have to regenerate the DOM - however because the elements might have changed (eg values entered into
             * inputs) we clear this.editHtml on hide (see this.clearEditHtml) so that it will be re-requested on show.
             */

            if (this.getEditHtml()) {
                return new jQuery.Deferred().resolve(this.getEditHtml());
            }

            return SmartAjax.makeRequest({
                type: "POST",
                url: contextPath + "/secure/QueryComponentRendererEdit!Default.jspa",
                success: _.bind(this.setEditHtml, this),
                dataType: "html",
                error: DisplayFailSearchMessage,
                data: {
                    fieldId: this.getId(),
                    decorator: "none",
                    jqlContext: jql
                }
            });
        },

        /**
         * Returns true if this element has edit html and it contains an error class
         */
        hasErrorInEditHtml: function() {
            var $el = jQuery('<div>').htmlCatchExceptions(this.getEditHtml());
            if (!$el) {
                return false;
            } else {
                return $el.find(".error, .has-errors").length > 0;
            }
        },

        // See this._fetchEditHtml
        clearEditHtml: function() {
            this.setEditHtml(null);
        },

        _onEditHtmlUpdated: function() {
            this.setSerializedParams(jQuery("<form/>").appendCatchExceptions(this.getEditHtml()).serialize());
        },

        /**
         * @return the text to be shown in the searcher's tooltip.
         */
        getTooltipText: function() {
            if (this.getValidSearcher !== false) {
                var value = this.getDisplayText() || "All";
                return this.getName() + ": " + value;
            } else {
                return "This criteria is not valid for the project and/or issue type";
            }
        },

        /**
         * Wait any in flight updates to search collection.
         */
        searchersReady: function() {
            return this.collection.searchersReady();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/SearcherCollection.js' */
define("jira/components/query/basic/searchercollection", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var Meta = require("jira/util/data/meta");
    var SearcherModel = require("jira/components/query/basic/searchermodel");
    var TextQueryBuilder = require("jira/components/query/basic/textquerybuilder");
    var FunctionalUtils = require("jira/components/util/functionalutils");
    var SmartAjax = require("jira/ajs/ajax/smart-ajax");
    var GroupDescriptor = require("jira/ajs/list/group-descriptor");
    var ItemDescriptor = require("jira/ajs/list/item-descriptor");
    var LatestSearchStore = require("jira/components/search/latestStorage");
    var contextPath = AJS.contextPath();
    var displayFailSearchMessage = JIRA.Issues.displayFailSearchMessage;

    var ajsEscapeHtml = AJS.escapeHtml;

    function trace() {
        return JIRA.trace.apply(JIRA, arguments);
    }

    return Brace.Collection.extend({

        model: SearcherModel,

        /**
         * searchRequested: a user action has caused us to select a new search
         *
         * collectionChanged: the collection has changed. This is fired at most once per public interface method. Clients
         * requesting changes should listen to this method to receive updates instead of add, change, remove if they
         * want only a single notification of change.
         *
         * requestUpdateFromView: requests non-auto-submit views (eg text query view) to update the form values in their model
         *
         * beforeCriteriaRemoved: a user action caused a criteria to be removed from view. Args: id, direction
         */
        namedEvents: ["searchRequested", "collectionChanged", "jqlTooComplex", "textFieldChanged", "requestUpdateFromView", "interactiveChanged", "beforeCriteriaRemoved"],

        QUERY_PARAM: "text",
        QUERY_ID: "text",

        /**
         * Prefix used to send jql for invalid searchers to the server, because we don't generate editHtml for invalid searchers
         * (but we can generate jql)
         */
        JQL_INVALID_QUERY_PREFIX: "__jql_",

        initialize: function(models, options) {
            if (models && models.length) {
                this._searcherCache = models;
            }
            this.fixedLozenges = options && options.fixedLozenges ? options.fixedLozenges : [];
            this.queryStateModel = options && options.queryStateModel;
            this.initData = options && options.initData;
            this.context = options && options.context;
            this._interactive = true;
        },

        /**
         * Converts an array of SearcherModels to an array of ItemDescriptors.
         *
         * @param {Array<JIRA.Issues.SearcherModel>} searchers
         * @return {Array<AJS.ItemDescriptor>}
         */
        _createItemDescriptors: function(searchers) {
            return _.map(searchers, function(searcher) {
                return new ItemDescriptor({
                    meta: {
                        isShown: searcher.isShown
                    },
                    label: searcher.name,
                    title: searcher.isShown ? searcher.name : searcher.name + " " + "is not applicable for the current project and/or issue type.",
                    selected: searcher.isSelected || searcher.jql,
                    value: searcher.id
                });
            });
        },

        /**
         * Construct group and item descriptors for the "add criteria" menu.
         * <p/>
         * Returns valid non-primary searchers sorted by name (case insensitive).
         *
         * @return {Array} AJS.GroupDescriptors for the "add criteria" menu.
         */
        getAddMenuGroupDescriptors: function() {
            // Retrieve all valid, non-primary searchers.
            this._updateSearcherCache();

            var primarySearcherIds = this.fixedLozengeIds().concat(this.QUERY_ID);

            var searchers = _.filter(this._searcherCache, function(searcher) {
                var isPrimary = _.contains(primarySearcherIds, searcher.id);
                var isValid = !!searcher.groupName;
                return !isPrimary && isValid;
            });

            if (searchers.length) {
                var allSearchers = new GroupDescriptor({
                    label: "All Criteria",
                    items: this._createItemDescriptors(_.sortBy(searchers, function(searcher) {
                        return searcher.name.toLowerCase();
                    }))
                });
                var recentSearchers = new GroupDescriptor({
                    label: "Recent Criteria",
                    items: this._createItemDescriptors(_.first(_.sortBy(_.filter(searchers, function(searcher) {
                        return searcher.lastViewed;
                    }), function(searcher) {
                        return -searcher.lastViewed;
                    }), Meta.getNumber("max-recent-searchers")))
                });
                return [recentSearchers, allSearchers];
            } else {
                return [];
            }
        },

        /**
         * Returns a searcher by id from either the model collection or the raw searcher cache.
         *
         * If a model is not found in the model collection it is added from the raw cache and returned.
         *
         * Assumes that a searcher being requested, if not present in the model collection, is in the raw searcher
         * collection. This is done as the raw searchers are used to generate the searcher list.
         *
         * @param id The Searcher ID
         */
        getSearcher: function(id) {
            var searcher = this.get(id);

            if (!searcher) {
                this.add(this._searcherCache[id]);
                searcher = this.get(id);
            }

            return searcher;
        },

        /**
         * Sets the jql for the model with the given id, creating one if it doesn't exist
         * @param id id of model
         * @param jql jql to set
         */
        setJql: function(id, jql) {
            this._addOrSet(id, {
                jql: jql
            });
        },

        /**
         * Returns a single jql string expressing all subclauses in this collection.
         */
        createJql: function() {
            var arr = this.pluck("jql");
            return _.filter(arr, FunctionalUtils.isNotBlank).join(" AND ") || "";
        },

        /**
         * Has the user specified any clauses?
         */
        isDirty: function() {
            return this.any(function(lozenge) {
                // clauses are ultimately defined by a jql clause
                return lozenge.getJql() !== undefined && lozenge.getJql() !== ""; // TODO the stupid text field strikes again. it has a "" state after routing
            });
        },

        /**
         * Clears entire search state
         */
        clearSearchState: function() {
            this.each(function(searcherModel) {
                searcherModel.clearSearchState();
            });
            // TODO: optimise by only requerying server if search state changes
            this._querySearchersAndValues("");
        },

        /**
         * Clear the search state for a single searcher.
         *
         * If the searcher has a clause (i.e. it could be affecting search results),
         * the search will be re-performed.
         *
         * @param id The id of searcher.
         */
        clearClause: function(id) {
            // We don't need to requery here if invalid clauses
            var searcher = this.get(id);
            var hasClause = searcher && searcher.hasClause();

            if (searcher) {
                searcher.clearSearchState();
            }

            this.triggerCollectionChanged();
            this.triggerRequestUpdateFromView();

            // We only need to refresh results if the searcher had a clause.
            if (hasClause) {
                this.triggerSearchRequested(this.createJql());
            }
        },

        getTextQuery: function() {
            var model = this.get(this.QUERY_ID);
            return model ? model.getViewHtml() : "";
        },

        /**
         * Set the interactive flag to indicate whether searchers respond to user input.
         * @param {boolean} interactive
         */
        setInteractive: function(interactive) {
            if (interactive !== this._interactive) {
                this._interactive = interactive;
                this.triggerInteractiveChanged(interactive);
            }
        },

        /**
         * Determine whether searchers respond to user input.
         * @return {boolean}
         */
        isInteractive: function() {
            return this._interactive;
        },

        handleBasicViewSubmit: function() {
            this.triggerRequestUpdateFromView();
            this.triggerSearchRequested(this.createJql());
        },

        updateTextQuery: function(textQuery) {
            if (textQuery) {
                var textQueryHtml = ajsEscapeHtml(textQuery);
                this._addOrSet(this.QUERY_ID, {
                    viewHtml: textQueryHtml,
                    editHtml: textQueryHtml,
                    jql: TextQueryBuilder.buildJql(textQuery)
                });
            }
            else {
                this.remove(this.QUERY_ID);
            }
            this.triggerTextFieldChanged();
        },

        /**
         * Creates a queryString representing all querystring members
         * @return {string}
         */
        getQueryString: function() {
            var queryStrings = [];
            this.each(function(searcherModel) {
                var qs = searcherModel.getQueryString();
                if (qs) {
                    queryStrings.push(qs);
                }
            });
            return queryStrings.join("&");
        },

        /**
         * Adds or sets parameters. If a model with the given id is found, the values in params are set. Otherwise a model is created
         * with the given id and params.
         * @param id id to of model to find.
         * @param params parameters
         * @param options
         */
        _addOrSet: function(id, params, options) {
            var model = this.get(id);
            if (model) {
                // Backbone doesn't support parse: true for set()
                if (options && options.parse && model.parse) {
                    params = model.parse(params);
                    delete options.parse;
                }
                if (params.jql) {
                    params.isSelected = true;
                }
                model.set(params, options);
            } else {
                var paramsWithId = _.clone(params);
                paramsWithId.id = id;
                paramsWithId.isSelected = !!params.jql;
                this.add(paramsWithId, options);
                model = this.get(id);
            }
            return model;
        },

        /**
         * Update the basic mode query view to represent the given jql unless the jql can't fit into the basic view.
         * IF the query is "too complex" a jqlTooComplex event is fired.
         * @param {JIRA.Issues.queryStateModel} jql
         * @param reset
         */
        restoreFromQuery: function(jql, reset) {

            // We won't have JQL if a filter is private; just show empty searchers.
            this.queryStateModel.setJql(jql);
            var contextJql = this._getJqlWithContext(jql);

            var requestData = {
                jql: contextJql || "",
                decorator: "none"
            };

            // If the request is already in the URL we don't always need to call search, but we persist the current
            // search anyway
            LatestSearchStore.save(requestData);

            // We store a json blob on the page when we first load so we don't need to go to the server.
            if (this.initData) {
                if (!this.initData.errorMessages) {
                    this._onQuerySearchersAndValues(this.initData);
                    this.initData = null;
                    return new jQuery.Deferred().resolve();
                } else {
                    // this json blob may also contain errors
                    this._handleSearcherError(requestData.jql, this.initData);
                    this.initData = null;
                    return new jQuery.Deferred().reject();
                }
            } else {
                var response = jQuery.ajax({
                    url: contextPath + "/secure/QueryComponent!Jql.jspa",
                    headers: {'X-SITEMESH-OFF': true},
                    data: requestData,
                    type: "POST"
                });

                response.success(_.bind(function(data) {
                    if (reset) {
                        this.clearExpectingUpdate(reset);
                    }
                    this._onQuerySearchersAndValues(data);
                }, this));

                response.error(_.bind(function(resp) {
                    if (reset) {
                        this.clearExpectingUpdate();
                    }
                    try {
                        var json = JSON.parse(resp.responseText);
                        if (json) {
                            this._handleSearcherError(requestData.jql, json);
                        }
                    } catch (e) {
                        /*eslint-disable no-console */
                        console.log("search response error - not JSON?");
                        /*eslint-enable no-console */
                    }

                }, this));

                response.always(function() {
                    trace("jira.search.searchers.updated");
                });

                return response;
            }

        },

        /**
         * Resets state, before we apply new values.
         */
        clearExpectingUpdate: function() {
            this.reset();
            this.updateTextQuery("");
        },

        /**
         *  Handles error when requesting searchers
         *
         * @param jql
         * @param data
         * @private
         */
        _handleSearcherError: function(jql, data) {
            if (_.include(data.errorMessages, "jqlTooComplex") || _.include(data.errorMessages, "jqlInvalid")) {
                // I know I know. A bloody setTimeout.
                // This is because when we first load the page as we are not async (we are using json blob from page) this
                // event is triggered before switchToPreferred search is called. This means that we flick to advanced but
                // then back to the preferred search (which could be basic). If the jql is too complex we need to be sure

                window.setTimeout(_.bind(function() {
                    this.triggerJqlTooComplex(jql);
                }, this), 0);
            }
        },

        searcherAffectsContext: function(id) {
            return "project" === id || 'issuetype' === id;
        },

        /**
         * Tells the clause to update from the values selected in its editHtml, creating or updating it as required.
         * This update involves an AJAX request to retrieve the jql and criteria content from the server.
         * @param id -- SearcherModel id
         * @param {Boolean} [forceUpdate=false] Force update of the JQL, even if autoupdate is disabled
         */
        createOrUpdateClauseWithQueryString: function(id, forceUpdate) {

            this.triggerRequestUpdateFromView();

            var deferred;
            if (this.searcherAffectsContext(id)) {
                // Requery all searchers and values
                deferred = this._querySearchersAndValues(this.getQueryString());
            }
            else {
                deferred = this._querySearchersByValue(id);
            }

            deferred.done(_.bind(function() {
                if ((this.queryStateModel.getBasicAutoUpdate() || forceUpdate) && !this.containsInvalidSearchers()) {
                    this.triggerSearchRequested(this.createJql());
                }
            }, this));

            return deferred;

            // TODO: could optimise by only requesting all searchers and values when context changes (ie project or issue type)
            // and requesting only valuehtml for other cases. see _querySingleValue
        },

        containsInvalidSearchers: function() {
            return this.any(function(searcherModel) {
                return searcherModel.hasErrorInEditHtml();
            });
        },

        _querySearchersByValue: function(id) {
            var model = this.get(id);
            var data = jQuery.param({
                decorator: "none",
                jqlContext: this.queryStateModel.getJql()
            });

            if (model) {
                var modelString = model.getQueryString();
                if (modelString) {
                    data = data + '&' + modelString;
                }
            }

            if (this._activeSearcherReq) {
                this._activeSearcherReq.abort();
            }

            this._activeSearcherReq = SmartAjax.makeRequest({
                type: "POST",
                data: data,
                processData: false,
                url: contextPath + "/secure/QueryComponentRendererValue!Default.jspa",
                success: _.bind(function(data) {
                    var model = this.get(id);
                    if (model) {
                        if (data[id]) {
                            data[id].groupName = model.getGroupName();
                            data[id].groupId = model.getGroupId();
                        } else {
                            // If the searcher isn't present in the response, then
                            // it currently has no value and we need to reset it.
                            data[id] = _.extend(model.toJSON(), {
                                editHtml: null,
                                jql: null,
                                viewHtml: null
                            });
                        }
                    }

                    this._setSearchersFromData(data, true);
                }, this),
                dataType: "json",
                error: function(xhr) {
                    displayFailSearchMessage(xhr);
                }
            }).always(_.bind(function() {
                this._activeSearcherReq = null;
            }, this));

            return this._activeSearcherReq;
        },

        /**
         * Returns a map by id of all searchers from the response
         * @param data response data
         */
        _parseSearcherGroups: function(data) {
            var searchers = {};
            var without = this.queryStateModel.getWithout();

            _.each(data.groups, function(group) {
                _.each(group.searchers, function(searcher) {
                    if (!_.contains(without, searcher.id)) {
                        searcher.groupId = group.type;
                        searcher.groupName = group.title;
                        searchers[searcher.id] = searcher;
                    }
                });
            });

            return searchers;
        },

        _querySearchersAndValues: function(queryString) {

            var data = "decorator=none";

            if (this._activeSearcherReq) {
                // If it is the same as the request we are currently waiting for we can just ignore.
                if (this._activeSearcherQuery === queryString) {
                    return new jQuery.Deferred().reject();
                }
                // Otherwise we will abort and issue a new request.
                this._activeSearcherReq.abort();
            }

            // store data for this request so we can use it to compare against new requests
            this._activeSearcherQuery = queryString;

            if (queryString) {
                data += "&" + queryString;
            }

            this._activeSearcherReq = jQuery.ajax({
                url: contextPath + "/secure/QueryComponent!Default.jspa",
                headers: {'X-SITEMESH-OFF': true},
                type: "POST",
                data: data,
                processData: false
            });

            this._activeSearcherReq.done(_.bind(function(data) {
                this._onQuerySearchersAndValues(data);
            }, this));

            this._activeSearcherReq.fail(_.bind(function(xhr) {
                displayFailSearchMessage(xhr);
            }, this));

            this._activeSearcherReq.always(_.bind(function() {
                this._activeSearcherReq = null;
            }, this));

            return this._activeSearcherReq;
        },

        /**
         * Remove all searchers from the collection and clear the text query.
         */
        clear: function() {
            this.reset([], {silent: true});
            this.updateTextQuery("");
            this.triggerCollectionChanged();
        },

        /**
         * Wait any in flight updates to search collection.
         */
        searchersReady: function() {
            if (this._activeSearcherReq) {
                return this._activeSearcherReq;
            } else {
                return new jQuery.Deferred().resolve();
            }
        },

        _onQuerySearchersAndValues: function(data) {

            // merge searchers and values from response
            var searchers = this._parseSearcherGroups(data.searchers);
            var without = this.queryStateModel.getWithout();
            _.each(data.values, _.bind(function(value, id) {
                // compose searcher and value from response
                var searcher = searchers[id];
                if (_.contains(without, id)) {
                    value.isShown = false;
                    value.validSearcher = false;
                    value.jql = "";
                }
                if (!searcher) {
                    searchers[id] = value;
                }
                else {
                    _.extend(searcher, value);
                }

            }, this));

            var modelsToRemove = [];
            this.each(function(searcher) {
                var searcherId = searcher.id;
                if (!_.any(searchers, function(newSearcher) {
                        return newSearcher.id === searcherId;
                    })) {
                    if (searcher.getIsSelected()) {
                        searcher.setValidSearcher(false);
                    } else {
                        modelsToRemove.push(searcher);
                    }
                }
            });
            if (modelsToRemove.length) {
                this.remove(modelsToRemove);
            }

            this._setSearchersFromData(searchers);
        },

        /**
         * Updates the searcher cache to mirror the current state of the searcher collection.
         *
         * @private
         */
        _updateSearcherCache: function() {
            if (this._searcherCache) {
                this.each(_.bind(function(searcher) {
                    this._searcherCache[searcher.id] = searcher.toJSON();
                    this._searcherCache[searcher.id].id = searcher.id;
                }, this));
            }
        },

        /**
         * Sets the initial state of the searcher collection.
         *
         * Accepts a JSON object of raw searcher definitions and values and adds
         * real SearcherModels to SearcherCollection for each if they are primary or
         * they have viewHtml (i.e. in use).
         *
         * This is an optimisation to prevent every searcher model being instantiated
         * which is an incredibly slow process in IE8.
         *
         * @param searchers
         * @param update
         * @private
         */
        _setSearchersFromData: function(searchers, update) {
            _.each(searchers, _.bind(function(value, id) {
                this._addOrSet(id, {
                    groupId: value.groupId,
                    groupName: value.groupName,
                    isShown: value.isShown,
                    name: value.name,
                    viewHtml: value.viewHtml,
                    jql: value.jql,
                    editHtml: value.editHtml,
                    validSearcher: value.validSearcher,
                    key: value.key,
                    lastViewed: value.lastViewed
                }, {parse: true});
            }, this));

            if (update) {
                this._updateSearcherCache();
            } else {
                this._searcherCache = searchers;
            }

            this.triggerCollectionChanged();

            trace("jira.search.searchers.updated");
        },

        /**
         * combine the jql with the context jql. The purpose of this method is narrow down the option values in dropdownlist following the context
         * (for ex: in project, if project does not define issue type "Bug", the dropdown list should not render "Bug" option)
         * contextJql (for ex: project = "Service Desk")
         * @param jql (for ex: issuetype = "IT Help")
         * @return a complete jql in a scope. (project = "Service Desk' AND issuetype = "IT Help"_
         */
        _getJqlWithContext: function(jql) {
            var contextJql = this.context ? this.context : jql;
            if (this.context && jql) {
                contextJql = this.context + " AND " + jql;
            }
            return contextJql;
        },

        /**
         * Return a list of extended criteria.
         * - the searcher has a value
         * - the searcher is not query text or a primary clause
         */
        getVariableClauses: function() {
            var variableClauses = [];
            this.each(_.bind(function(searcherModel) {
                if (!this.isFixed(searcherModel) && searcherModel.hasClause()) {
                    variableClauses.push(searcherModel);
                }
            }, this));

            return variableClauses;
        },

        /**
         * @return {JIRA.Issues.SearcherModel[]} All selected non-prime searchers,
         *     in ascending order of position.
         */
        getSelectedCriteria: function() {
            var instance = this;
            var isSelectedCriteria = function(searcher) {
                return !instance.isFixed(searcher) &&
                    (searcher.hasClause() || searcher.getIsSelected());
            };

            return this.chain()
                .filter(isSelectedCriteria)
                .sortBy(function(searcher) {
                    return searcher.getPosition();
                })
                .value();
        },

        getAllSelectedCriteriaCount: function() {
            return this.getAllSelectedCriteria().length;
        },

        getAllSelectedCriteria: function() {
            var selectedCriteria = [];

            this.each(_.bind(function(searcherModel) {
                if (searcherModel.hasClause() || searcherModel.getIsSelected()) {
                    selectedCriteria.push(searcherModel);
                }
            }, this));

            return selectedCriteria;
        },

        isFixed: function(searcherModel) {
            return _.contains(this.fixedLozengeIds(), searcherModel.getId()) || searcherModel.getId() === this.QUERY_ID;
        },

        fixedLozengeIds: function() {
            return _.pluck(this.fixedLozenges, "id");
        },

        /**
         * Extended criteria searchers have position values that are used to
         * determine their position in ExtendedCriteriaView; they appear in
         * ascending order. This method calculates the next position value.
         *
         * @return {number} The next position value.
         */
        getNextPosition: function() {
            return this.reduce(function(memo, searcher) {
                    var max = Math.max(memo, searcher.getPosition());
                    return isNaN(max) ? memo : max;
                }, -1) + 1;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/CriteriaModel.js' */
/**
 *
 * A CriteriaModel is a simple representation of a SearcherModel of the same id and name
 * so that the criterion can still be rendered before the SearcherModel has been constructed.
 * This happens in the case of primary criteria since they are rendered on page load, but their values
 * still need to be retrieved.
 *
 * To get the actual searcher values, the SearcherModel should be accessed from SearcherCollection, e.g:
 *
 *     var searcherModel = searchCollection.get(criteriaModel.getId())
 *
 */
define("jira/components/query/basic/criteriamodel", ["require"], function(require) {
    "use strict";

    var Brace = require("jira/components/libs/brace");

    return Brace.Model.extend({
        namedAttributes: ["id", "name"]
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/CardView.js' */
define("jira/components/query/basic/cardview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");

    /**
     * View that switching between a couple of views
     */
    return Brace.View.extend({

        /**
         * viewChanged: fired when the active view is changed.
         */
        namedEvents: ["viewChanged"],

        /**
         * @param options
         * options.views: map of views by id (required)
         * options.activeView: id of view to show (optional, defaults to first in view)
         */
        initialize: function(options) {
            this.views = options.views;
            if (options.activeView) {
                this.activeView = options.activeView;
            }
            else {
                var keys = _.keys(this.views);
                if (keys.length > 0) {
                    this.activeView = keys[0];
                }
            }
        },

        /**
         * Renders the table element's contents.
         */
        render: function() {
            this._renderActiveView();
        },

        /**
         * Sets the active view. If id is the current active view, this is a no-op.
         * @param id id of view to make active
         */
        changeToView: function(id) {
            if (id === this.activeView) {
                return;
            }
            this.activeView = id;
            if (this.$el) {
                this._renderActiveView(id);
            }
            this.triggerViewChanged(id);
        },

        _renderActiveView: function() {
            var view = this.views[this.activeView];
            view.setElement(this.$el);
            view.render();
        }

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/BasicQueryView.js' */
define("jira/components/query/basic/basicqueryview", ["require"], function(require) {
    "use strict";

    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryBasic = require("jira/components/query/templates/issuenavquerybasic");
    var TextFieldView = require("jira/components/query/basic/textfieldview");
    var PrimaryCriteriaContainerView = require("jira/components/query/basic/primarycriteriacontainerview");
    var ExtendedCriteriaContainerView = require("jira/components/query/basic/extendedcriteriacontainerview");
    var ClauseButtonView = require("jira/components/query/basic/clausebuttonview");
    var Tipsy = require("jira/issues/tipsy");
    var OrderBy = require("jira/components/orderby");

    /**
     * Renders the Basic Query component.
     */
    return Brace.View.extend({

        namedEvents: ["verticalResize", "searchRequested"],

        template: IssueNavQueryBasic.basicQueryView,

        initialize: function(options) {
            this.searcherCollection = options.searcherCollection;
            this.queryStateModel = options.queryStateModel;

            this.textFieldView = new TextFieldView({
                collection: this.searcherCollection
            });

            // Subview for rendering primary criteria (project, assignee, etc)
            this.primaryCriteriaContainerView = new PrimaryCriteriaContainerView({
                collection: this.searcherCollection
            });

            // Subview for rendering extended criteria
            this.extendedCriteriaContainerView = new ExtendedCriteriaContainerView({
                collection: this.searcherCollection
            }).onVerticalResize(this.triggerVerticalResize, this);

            if (this.queryStateModel.getBasicOrderBy()) {
                this.basicOrderByView = OrderBy.create();

                this.queryStateModel.on("change:jql", function() {
                    this.basicOrderByView.setJql(this.queryStateModel.getJql());
                }, this);

                this.basicOrderByView.onSort(this.triggerSearchRequested, this);
            }

            // The subview for the clear all and add additional filters.
            this.clauseButtonView = new ClauseButtonView({
                searcherCollection: this.searcherCollection,
                queryStateModel: this.queryStateModel
            });

            this.searcherCollection.onInteractiveChanged(this._handleInteractiveChanged, this);
            this.searcherCollection.onBeforeCriteriaRemoved(this._handleBeforeCriteriaRemoved, this);
        },

        _handleInteractiveChanged: function(interactive) {
            this.$el.toggleClass("loading", !interactive);
        },

        _handleBeforeCriteriaRemoved: function(id, direction) {
            // If a criteria was removed with a direction, focus on the next focusable element in that direction
            if (direction) {
                this._shiftFocus(id, direction);
            }
        },

        /**
         * This render function is only called when the BasicQueryView is first initialized,
         * and also when switching from advanced to basic mode.
         *
         * All further renders are handled at the sub-view level.
         */
        render: function() {
            this.$el.html(this.template({
                hasOrderBy: this.queryStateModel.getBasicOrderBy(),
                hasSearchButton: this.queryStateModel.hasSearchButton()
            }));

            this.primaryCriteriaContainerView.setElement(this.$el.find(".search-criteria .criteria-list"));
            this.textFieldView.setElement(this.$el.find("input.search-entry"));
            this.clauseButtonView.setElement(this.$el.find(".criteria-actions"));
            this.extendedCriteriaContainerView.setElement(this.$el.find(".search-criteria-extended .criteria-list"));
            if (this.basicOrderByView) {
                this.basicOrderByView.setElement(this.$el.find(".list-ordering")).render();
                this.basicOrderByView.setJql(this.queryStateModel.getJql());
            }

            this.primaryCriteriaContainerView.render();
            this.$el.find(".text-query").removeClass("hidden");

            this.textFieldView.render();
            this.clauseButtonView.render();

            this.extendedCriteriaContainerView.render();

            this._handleInteractiveChanged(this.searcherCollection.isInteractive());
            this.triggerVerticalResize();

            new Tipsy({
                el: this.$el.find(".search-button"),
                tipsy: {
                    trigger: "hover",
                    delayIn: 300
                }
            });

            return this;
        },

        /**
         * Performs a search using the current state in the Basic Query View.
         */
        search: function() {
            this.searcherCollection.handleBasicViewSubmit();
        },

        /**
         * Put the focus on the next focusable element in the given direction (-1: back, 1: forward),
         * assuming the currently focused item is about to be removed
         */
        _shiftFocus: function(currentId, direction) {
            var $current = this.primaryCriteriaContainerView.getFocusableForCriteria(currentId);
            if (!$current.length) {
                $current = this.extendedCriteriaContainerView.getFocusableForCriteria(currentId);
            }
            var $allFocusables = this.primaryCriteriaContainerView.getFocusables()
                .add(this.extendedCriteriaContainerView.getFocusables());
            var currentIndex = $allFocusables.index($current);
            var nextIndex;
            // If the element being removed is at either end, there is only 1 element the focus can move to,
            // irrespective of direction
            if (currentIndex === 0) {
                nextIndex = 1;
            } else if (currentIndex === $allFocusables.length - 1) {
                nextIndex = $allFocusables.length - 2;
            } else {
                nextIndex = currentIndex + direction;
            }
            $allFocusables.eq(nextIndex).focus();
        },

        focus: function() {
            this.primaryCriteriaContainerView.getFocusables().first().focus();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/TextFieldView.js' */
define("jira/components/query/basic/textfieldview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");

    /**
     * Simple Query View's text search field.
     */
    return Brace.View.extend({

        namedEvents: ["searchRequested"],

        events: {
            keypress: "handleKeypress"
        },

        initialize: function() {
            _.bindAll(this,
                "_updateSearcherCollectionTextField",
                "_handleInteractiveChanged",
                "render");

            this.collection.on("remove change add", _.bind(function(model) {
                if (model.getId() === this.collection.QUERY_ID) {
                    this.render();
                }
            }, this));
            this.collection.onTextFieldChanged(this.render);
            this.collection.onRequestUpdateFromView(this._updateSearcherCollectionTextField);
            this.collection.onInteractiveChanged(this._handleInteractiveChanged);
        },

        handleKeypress: function(e) {
            if (e.keyCode === 13) {
                this.collection.handleBasicViewSubmit();
                e.preventDefault();
            }
        },

        render: function() {
            // Attempt to extract the query from the model's edit HTML. If that
            // fails, just fall back to its display value (used in tests too).
            var model = this.collection.get(this.collection.QUERY_ID);

            if (model) {
                // the html is just a raw value html encoded
                var val = model.getEditHtml();
                var decodedVal = jQuery('<div></div>').html(val || '').text();
                this.setQuery(decodedVal);
            } else {
                this.setQuery("");
            }
        },

        setQuery: function(query) {
            this.$el.val(query);
        },

        _updateSearcherCollectionTextField: function() {
            if (this.$el.is("input")) {
                var textFieldValue = jQuery.trim(this.$el.val());
                this.collection.updateTextQuery(textFieldValue);
            }
        },

        _handleInteractiveChanged: function(interactive) {
            // Disable the text input while noninteractive.
            this.$el.prop("disabled", !interactive);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/PrimaryCriteriaContainerView.js' */
define("jira/components/query/basic/primarycriteriacontainerview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var CriteriaView = require("jira/components/query/basic/criteriaview");
    var CriteriaModel = require("jira/components/query/basic/criteriamodel");

    return Brace.View.extend({

        initialize: function() {
            this._criteriaViews = _.map(this.collection.fixedLozenges, function(primary) {
                return new CriteriaView({
                    model: new CriteriaModel(primary),
                    searcherCollection: this.collection
                });
            }, this);
        },

        render: function() {
            _.each(this._criteriaViews, function(view) {
                view.render();
            });

            this.$el.prepend(_.pluck(this._criteriaViews, 'el'));
        },

        getCriteriaViews: function() {
            return this._criteriaViews;
        },

        /**
         * Returns a jQuery array of elements within this container that can be tab-focused
         */
        getFocusables: function() {
            return this.$('.criteria-selector, #searcher-query, .add-criteria, .search-button');
        },

        /**
         * Returns the focusable element for the given criteria. The element returned should be one
         * of the elements in getFocusables()
         */
        getFocusableForCriteria: function(criteriaId) {
            return this.$('.criteria-selector[data-id="' + criteriaId + '"]');
        }

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/ExtendedCriteriaContainerView.js' */
define("jira/components/query/basic/extendedcriteriacontainerview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var CriteriaView = require("jira/components/query/basic/criteriaview");
    var CriteriaModel = require("jira/components/query/basic/criteriamodel");

    /**
     * View that handles displaying a search clause and creating its associated dialog
     */
    return Brace.View.extend({

        namedEvents: ["verticalResize"],

        initialize: function() {
            this.collection.on('change:isSelected', this._onCriteriaSelectionChanged, this);
            this.collection.on('add', this._onCriteriaSelectionChanged, this);
            this.collection.on('remove', this._removeViewForSearcher, this);
            this.collection.on('reset', this._onReset, this);

            this._criteriaViews = _.map(this.collection.getSelectedCriteria(), _.bind(function(searcherModel) {
                if (searcherModel.getPosition() == null) {
                    searcherModel.setPosition(this.collection.getNextPosition());
                }
                return this._buildCriteriaViewForSearcher(searcherModel);
            }, this));
        },

        render: function() {
            _.each(this._criteriaViews, _.bind(function(criteriaView) {
                criteriaView.render();
                this.$el.append(criteriaView.$el);
            }, this));
        },

        /**
         * Returns a jQuery array of elements within this container that can be tab-focused
         */
        getFocusables: function() {
            return this.$('.criteria-selector');
        },

        /**
         * Returns the focusable element for the given criteria. The element returned should be one
         * of the elements in getFocusables()
         */
        getFocusableForCriteria: function(criteriaId) {
            return this.$('.criteria-selector[data-id="' + criteriaId + '"]');
        },

        _buildCriteriaViewForSearcher: function(searcherModel) {
            return new CriteriaView({
                model: new CriteriaModel({
                    id: searcherModel.get('id'),
                    name: searcherModel.get('name')
                }),
                searcherCollection: this.collection,
                extended: true
            });
        },

        /**
         * Handles the adding and removing of extended criteria
         */
        _onCriteriaSelectionChanged: function(searcherModel) {
            if (searcherModel.getIsSelected() && !this.collection.isFixed(searcherModel)) {
                this._addViewForSearcher(searcherModel);
            } else {
                this._removeViewForSearcher(searcherModel);
            }
        },

        _addViewForSearcher: function(searcherModel) {
            var criteriaView = this._buildCriteriaViewForSearcher(searcherModel);
            criteriaView.render();
            this.$el.append(criteriaView.$el);
            this._criteriaViews.push(criteriaView);
            this.triggerVerticalResize();
        },

        _removeViewForSearcher: function(searcherModel) {
            this._criteriaViews = _.reject(this._criteriaViews, function(criteriaView) {
                if (criteriaView.model.getId() === searcherModel.getId()) {
                    criteriaView.destroy();
                    return true; // Reject
                }
                return false;
            });
            this.triggerVerticalResize();
        },

        _onReset: function() {
            _.each(this._criteriaViews, function(criteriaView) {
                criteriaView.destroy();
            });
            this._criteriaViews = [];
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/SearcherGroupListDialogView.js' */
define("jira/components/query/basic/searchergrouplistdialogview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryBasic = require("jira/components/query/templates/issuenavquerybasic");
    var SearcherDialog = require("jira/components/query/basic/searcherdialog");
    var CheckboxMultiSelectSuggestHandler = require("jira/ajs/select/suggestions/checkbox-multi-select-suggest-handler");
    var CheckboxMultiSelect = require("jira/ajs/select/checkbox-multi-select");
    var SuggestHelper = require("jira/ajs/select/suggestions/suggest-helper");
    var GroupDescriptor = require("jira/ajs/list/group-descriptor");
    var Tipsy = require("jira/issues/tipsy");
    var AJSTemplates = AJS.Templates;
    var ajsHideReason = AJS.HIDE_REASON;

    var $moreCriteriaFooter;

    /**
     * List of searchers that can be added to a search
     */
    var module = Brace.View.extend({

        template: IssueNavQueryBasic.searcherDropdownContent,

        /**
         * searcherSelected(id): a searcher has been selected. id is the id of the searcher
         * hideRequested: dialog close has been requested
         */
        namedEvents: ["searcherSelected", "hideRequested"],

        events: {
            "keydown": "_keyPressed"
        },

        initialize: function(options) {
            this.searcherCollection = options.searcherCollection;
            this.$el.scrollLock('.aui-list-scroll');
        },

        render: function() {

            var descriptors = this.searcherCollection.getAddMenuGroupDescriptors();
            var tooManySearchers = descriptors.length && descriptors[0].properties.items.length > module.CRITERIA_DISPLAY_LIMIT;

            var select = jQuery(AJSTemplates.queryableSelect({
                descriptors: descriptors,
                id: "criteria"
            }));

            // Even though it works, weird stuff happens if you call .html(select) since select is a jQuery object.
            this.$el.empty().append(select);

            var options = {
                element: select,
                suggestionsHandler: module.SuggestHandler,
                hideFooterButtons: true
            };

            var searchersHiddenMessage = "...excluding \u003cspan class=hidden-no\u003e\u003c/span\u003e hidden";
            var searchersHiddenDetails = "These criteria are hidden because they are not applicable to the current project and/or issue type";

            // Performance optimisation. When appending more than 100 custom fields performance suffers dramatically.
            if (tooManySearchers) {
                options.maxInlineResultsDisplayed = module.CRITERIA_DISPLAY_LIMIT;
                searchersHiddenMessage = "...excluding \u003cspan class=hidden-no\u003e\u003c/span\u003e hidden. Please enter a keyword to refine.";
                searchersHiddenDetails = "These criteria are hidden because there are either too many to display or they are not applicable to the current project and/or issue type";
            }

            new CheckboxMultiSelect(options);

            $moreCriteriaFooter = jQuery("<div class='more-criteria-footer' />").html(searchersHiddenMessage);
            this.$el.append($moreCriteriaFooter);
            new Tipsy({
                el: $moreCriteriaFooter,
                tipsy: {
                    title: function() {
                        return searchersHiddenDetails;
                    },
                    className: "tipsy-front"
                }
            });

            // this.$el is an element owned by AJS.InlineLayer and is detached from the dom each time we switch
            // from basic to advanced. Thus, we need to rebind when we render rather than use the backbone way of
            // binding.
            this.$el.unbind("selected").bind("selected", _.bind(this._searcherSelected, this));
            this.$el.unbind("unselect").bind("unselect", _.bind(this._searcherUnselected, this));

            return this.$el;
        },

        _searcherUnselected: function(e, descriptor) {
            this.searcherCollection.clearClause(descriptor.properties.value);
        },

        _searcherSelected: function(e, descriptor) {
            var searcher = this.searcherCollection.getSearcher(descriptor.properties.value);
            searcher.select();
            SearcherDialog.instance.hide();
            SearcherDialog.instance.show(searcher);
        },

        _keyPressed: function(event) {
            if (event.keyCode === jQuery.ui.keyCode.TAB) {
                var tabbableElements = jQuery(":tabbable", this.$el);

                var noTabbableElements = (tabbableElements.length === 0);
                var shiftTabbingOnFirst = (event.shiftKey && (document.activeElement === tabbableElements.first()[0]));
                var tabbingOnLast = (!event.shiftKey && (document.activeElement === tabbableElements.last()[0]));

                if (noTabbableElements || shiftTabbingOnFirst || tabbingOnLast) {
                    this.triggerHideRequested(ajsHideReason.tabbedOut);
                    event.preventDefault();
                }
            }
        }
    }, {
        CRITERIA_DISPLAY_LIMIT: 100
    });

    module.SuggestHandler = CheckboxMultiSelectSuggestHandler.extend({
        formatSuggestions: function(groups, query) {
            var numberHidden = 0;
            var selectedItems = SuggestHelper.removeDuplicates(this.model.getDisplayableSelectedDescriptors());

            // Prepend a group containing all selected items.
            groups.splice(0, 0, new GroupDescriptor({
                actionBarHtml: selectedItems.length > 1 ? this.createClearAll() : null,
                items: selectedItems,
                styleClass: "selected-group"
            }));

            _.each(groups, function(group) {
                if (query.length === 0) {
                    var items = _.filter(group.items(), function(item, index) {
                        var meta = item.meta();
                        return meta && meta.isShown && index < module.CRITERIA_DISPLAY_LIMIT;
                    });

                    numberHidden += group.items().length - items.length;
                    group.items(items);
                } else {
                    _.each(group.items(), function(item) {
                        var meta = item.meta();
                        item.disabled(!(meta && meta.isShown));
                    });
                }
            });

            _.defer(function() {
                if ($moreCriteriaFooter) {
                    if (numberHidden) {
                        $moreCriteriaFooter.show().find(".hidden-no").text(numberHidden);
                    } else {
                        $moreCriteriaFooter.hide();
                    }
                }
            });

            return groups;
        }
    });

    return module;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/SearcherEditDialogView.js' */
define("jira/components/query/basic/searchereditdialogview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryBasic = require("jira/components/query/templates/issuenavquerybasic");
    var Events = require("jira/util/events");
    var Types = require("jira/util/events/types");
    var Reasons = require("jira/util/events/reasons");
    var AJSHideReason = AJS.HIDE_REASON;

    /**
     * The view for editing the value that one criterion has.
     *
     */
    return Brace.View.extend({

        namedEvents: ["backRequested", "hideRequested"],

        autoUpdate: [".js-autoupdate-checkboxmultiselect", ".js-default-checkboxmultiselect", ".js-default-checkboxmultiselectstatuslozenge", ".js-user-checkboxmultiselect", ".js-usergroup-checkboxmultiselect", ".js-group-checkboxmultiselect", ".js-label-checkboxmultiselect"],

        events: function() {
            var events = {
                "click .cancel-update": "_onCancelClicked",
                "click": "_stopPropagation",
                "submit": "_onSubmit",
                'keydown': '_keyPressed'
            };

            if (this.queryStateModel.getBasicAutoUpdate()) {
                events["selected " + this.autoUpdate.join(',')] = "applyChanges";
                events["unselect " + this.autoUpdate.join(',')] = "applyChanges";
            }

            return events;
        },

        template: IssueNavQueryBasic.lozengeDropdownContent,

        initialize: function(options) {
            this._formData = "";
            this.queryStateModel = options.queryStateModel;
            this.$el.scrollLock('.aui-list-scroll');
        },

        renderDeferred: function() {
            var deferred = new jQuery.Deferred();
            // Ask the searcher to retrieve html (which will trigger readyForDisplay immediately if the editHtml is cached)
            this.model.retrieveEditHtml().done(_.bind(function(editHtml) {
                deferred.resolve(this.render(editHtml));
            }, this));
            return deferred.promise();
        },

        hasAutoUpdate: function(editHtml) {
            return this.queryStateModel.getBasicAutoUpdate() && jQuery(editHtml).find(this.autoUpdate.join(',')).length !== 0;
        },

        render: function(editHtml) {
            var containsEditContent = !(/^\s*$/.test(editHtml));
            var renderedContent;
            if (containsEditContent) {
                renderedContent = jQuery(this.template({
                    displayBackButton: this.displayBackButton,
                    displayUpdateCancel: !this.hasAutoUpdate(editHtml) && !jQuery(editHtml).hasClass("searchfilter-not-found")
                }));
            } else {
                renderedContent = jQuery(IssueNavQueryBasic.lozengeDropdownCannotEdit({fieldName: this.model.getName()}));
            }

            this.$el.html(renderedContent);
            this.$el.find(".form-body").appendCatchExceptions(editHtml);
            this.$el.find("form").addClass(this.model.id + "-criteria");
            this.$el.find("label:first").remove(); // Server sends back label. todo: remove label on server
            // Trigger NEW_CONTENT_ADDED as searchers may need to add js to editHtml
            Events.trigger(Types.NEW_CONTENT_ADDED, [this.$el, Reasons.criteriaPanelRefreshed]);
            this._formData = this.$el.find("form").serialize();
            this.model.setInitParams(this._formData);
            return this.$el;
        },

        _stopPropagation: function(e) {
            e.stopPropagation();
        },

        _preventDefault: function(e) {
            e.preventDefault();
        },

        /**
         * @return {Boolean}
         */
        applyFilter: function() {
            var formData = this.$el.find("form").serialize();
            // Note: We can't compare formData to this.model.getSerializedParams() since this
            // is updated by the searcher HTML request, causing hasChanged to always evaluate
            // to true. @see JRADEV-14898
            var hasChanged = (formData !== this._formData);
            this._formData = formData;
            this.model.setSerializedParams(this._formData);
            return hasChanged;
        },

        applyChanges: function() {
            if (this.applyFilter()) {
                this.model.createOrUpdateClauseWithQueryString();
            }
        },

        // For non-auto-updating searchers only. This is different to clicking on "clear" within the CheckboxMultiSelect.
        _onCancelClicked: function(e) {
            e.preventDefault();
            this.triggerHideRequested(AJSHideReason.cancelClicked);
        },

        _onSubmit: function(e) {
            e.preventDefault();
            this.triggerHideRequested(AJSHideReason.submit);
        },

        _keyPressed: function(event) {
            if (event.keyCode === jQuery.ui.keyCode.TAB) {
                var tabbableElements = jQuery(":tabbable", this.$el);

                var noTabbableElements = (tabbableElements.length === 0);
                var shiftTabbingOnFirst = (event.shiftKey && (document.activeElement === tabbableElements.first()[0]));
                var tabbingOnLast = (!event.shiftKey && (document.activeElement === tabbableElements.last()[0]));

                if (noTabbableElements || shiftTabbingOnFirst || tabbingOnLast) {
                    this.triggerHideRequested(AJSHideReason.tabbedOut);
                    event.preventDefault();
                }
            }
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/ClauseListDialogView.js' */
define("jira/components/query/basic/clauselistdialogview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryBasic = require("jira/components/query/templates/issuenavquerybasic");

    /**
     * List of clauses (ie searchers with a value) that have been added to the search
     */
    return Brace.View.extend({

        events: {
            "click .clauses .searcherValue": "_clauseSelected",
            "click .remove-filter": "_removeFilterRequested"
        },

        template: IssueNavQueryBasic.enabledClauses,

        namedEvents: ["clauseSelected", "hideRequested"],

        initialize: function(options) {
            this.searcherCollection = options.searcherCollection;
            // TODO: bind to valueUpdated to rerender on change?
            this.searcherCollection.onCollectionChanged(this._renderAndCheckForClose, this);
        },

        render: function() {
            this.$el.html(this.template({
                clauses: this._getClauses()
            }));
        },

        /**
         * Re-renders and checks to
         */
        _renderAndCheckForClose: function() {
            this.render();
            if (!this._getClauses().length) {
                this.triggerHideRequested();
            }
        },

        _clauseSelected: function(e) {
            e.preventDefault();
            var $target = jQuery(e.target);
            var id = $target.parents("li").first().data("id");
            this.triggerClauseSelected(id);
        },

        _removeFilterRequested: function(e) {
            e.preventDefault();

            var instance = this;

            /*
             Need to defer otherwise InlineLayer will hide This happens because the inline dialog chooses to close
             if the target element clicked is not a child element of the InlineLayer. Because we switch the content in the
             dialog, the back link is no longer in the InlineLayer therefor not a child element.  To rectify the problem
             we delay the toggling of content.
             */
            _.defer(function() {
                var $target = jQuery(e.target);
                var $listElement = $target.parents("li").first();
                var id = $listElement.data("id");

                instance.searcherCollection.clearClause(id);

                $listElement.remove();
                instance.triggerHideRequested();
            });
        },

        _getClauses: function() {
            var clauses = this.searcherCollection.getVariableClauses();
            var clausesJson = _.invoke(clauses, "toJSON");
            _.each(clausesJson, this._formatForTemplate);
            return clausesJson;
        },

        _formatForTemplate: function(clauseJson) {
            if (clauseJson.validSearcher) {
                clauseJson.invalidMessage = "";
            }
            else {
                clauseJson.invalidMessage = "This criteria is not valid for the project and/or issue type";
            }
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/ClauseButtonView.js' */
define("jira/components/query/basic/clausebuttonview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryBasic = require("jira/components/query/templates/issuenavquerybasic");
    var SearcherGroupListDialogView = require("jira/components/query/basic/searchergrouplistdialogview");
    var InlineLayer = require('jira/ajs/layer/inline-layer');
    var Tipsy = require("jira/issues/tipsy");
    var AJSLeft = AJS.LEFT;
    var AJSHideReason = AJS.HIDE_REASON;

    /**
     * View that handles "add criteria" and "clear criteria" buttons
     */


    return Brace.View.extend({

        template: IssueNavQueryBasic.clauseButtonView,

        addCriteriaButton: ".add-criteria",

        events: {
            "click .add-criteria": "_showDialog",
            "keydown .add-criteria": "_onKeydown"
        },

        initialize: function(options) {
            _.bindAll(this,
                "_handleInteractiveChanged",
                "_showOrHideClauseButtons");

            var instance = this;

            this.queryStateModel = options.queryStateModel;
            this.searcherCollection = options.searcherCollection;
            this.searcherCollection.onCollectionChanged(this._showOrHideClauseButtons);
            this.searcherCollection.onInteractiveChanged(this._handleInteractiveChanged);

            var dialog = this.dialog = new InlineLayer({
                width: "auto",
                alignment: AJSLeft,
                // Lazilly get offset target as it isn't in the DOM at this time
                offsetTarget: function() {
                    return instance.$el.find(instance.addCriteriaButton);
                },
                // Each time we open our dialog this function will be called to retrieve content
                content: function() {
                    /*eslint-disable no-use-before-define */
                    return listView.render();
                    /*eslint-enable no-use-before-define */
                }
            });

            dialog.bind(InlineLayer.EVENTS.hide, function(e, layer, reason) {
                if (reason === AJSHideReason.escPressed || reason === AJSHideReason.toggle ||
                    reason === AJSHideReason.tabbedOut) {
                    instance.$(instance.addCriteriaButton).focus();
                }
            });

            // Contents of InlineLayer
            var listView = new SearcherGroupListDialogView({
                searcherCollection: this.searcherCollection,
                dialog: dialog
            });

            // Allow the view inside of the InlineLayer to trigger hiding
            listView.onHideRequested(function(reason) {
                dialog.hide(reason);
            });

            dialog.bind(InlineLayer.EVENTS.show, function(event, $layer) {
                jQuery("#criteria-input").focus();
                // List.js also resets the scrollTop but because the dialog is still hidden at that point, the browser won't actually do any scrolling.
                // @see JRADEV-15097
                $layer.find(".aui-list-scroll").scrollTop(0);
            });
        },

        render: function() {
            this.$el.html(this.template({
                isSubtle: this.queryStateModel.hasSubtleMoreCriteria()
            }));
            this._showOrHideClauseButtons();
            this._addToolTip();
            return this.$el;
        },

        _addToolTip: function() {
            new Tipsy({
                el: this.$el.find(this.addCriteriaButton),
                showCondition: ":not(.active)"
            });
        },

        _showOrHideClauseButtons: function() {
            var addFiltersButton = this.$(this.addCriteriaButton);
            if (this.searcherCollection.getAddMenuGroupDescriptors().length > 0) {
                addFiltersButton.show();
            } else {
                addFiltersButton.hide();
            }
        },

        _showDialog: function(event) {
            if (this.searcherCollection.isInteractive()) {
                this.dialog.toggle();
            }
            event.preventDefault();
        },

        _handleInteractiveChanged: function(interactive) {
            this.$(this.addCriteriaButton).attr("aria-disabled", (interactive) ? null : "true");
        },

        _onKeydown: function(event) {
            switch (event.which) {
                case jQuery.ui.keyCode.DOWN:
                    this._showDialog(event);
                    break;
                case jQuery.ui.keyCode.ESCAPE:
                    jQuery(event.target).blur();
                    break;
                case jQuery.ui.keyCode.BACKSPACE:
                    // Prevent Backspace on the Add Criteria button from navigating back in history
                    break;
                default:
                    return;
            }
            event.preventDefault();
        }

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/SearcherDialog.js' */
define("jira/components/query/basic/searcherdialog", ["require"], function() {
    "use strict";

    var SearcherEditDialogView = require("jira/components/query/basic/searchereditdialogview");
    var _ = require("jira/components/libs/underscore");
    var InlineLayer = require('jira/ajs/layer/inline-layer');
    var AJSHideReason = AJS.HIDE_REASON;
    var AJSLeft = AJS.LEFT;
    var jQuery = require("jquery");

    function trace() {
        return JIRA.trace.apply(JIRA, arguments);
    }

    /**
     * A singleton that reuses the same InlineLayer for many different criteria selectors.
     */
    var module = function() {

        return {
            initialize: function(options) {
                if (!this.instance) {
                    this.instance = initSearcherDialog(options);
                }
            }
        };

        function initSearcherDialog(options) {
            AJSHideReason.switchLozenge = "switchLozenge";

            var reasonsToFocusCriteria = [
                AJSHideReason.escPressed,
                AJSHideReason.toggle,
                AJSHideReason.cancelClicked,
                AJSHideReason.submit,
                AJSHideReason.tabbedOut
            ];

            function findLozenge(searcher) {
                return searcher ? jQuery(".criteria-selector[data-id='" + searcher.getId() + "']") : jQuery();
            }

            var promise;
            var _currentSearcher; // JIRA.Issues.SearcherModel
            var _currentView;

            var _dialog = new InlineLayer({
                width: "auto",
                alignment: AJSLeft,
                offsetTarget: function() {
                    // Don't cache the lozenge under the current implementation since it can get reblatted
                    return findLozenge(_currentSearcher);
                },
                // Uses AJS.DeferredContentRetriever.
                content: function() {
                    _currentView = new SearcherEditDialogView({
                        model: _currentSearcher,
                        queryStateModel: options.queryStateModel
                    });
                    _currentView.onHideRequested(function(reason) {
                        _dialog.hide(reason);
                    });
                    return _currentView.renderDeferred();
                }
            });

            _dialog.bind(InlineLayer.EVENTS.show, function(e, $layer) {
                var input = $layer.find(":input:not(submit):visible:first");
                input.focus();

                // List.js also resets the scrollTop but because the dialog is still hidden at that point, the browser won't actually do any scrolling.
                // @see JRADEV-15097
                $layer.find(".aui-list-scroll").scrollTop(0);
            });

            _dialog.bind(InlineLayer.EVENTS.beforeHide, function(e, layer, reason, id, originalTarget) {
                if (reason === AJSHideReason.clickOutside && originalTarget && jQuery(originalTarget).closest(".calendar").length) {
                    e.preventDefault();
                }
            });

            _dialog.bind(InlineLayer.EVENTS.hide, function(e, layer, reason) {
                var _searcher = _currentSearcher;

                if (_.contains(reasonsToFocusCriteria, reason)) {
                    findLozenge(_searcher).focus();
                }

                function doSearch() {
                    // A searcher has been submitted. Create a clause and add it to the clause collection
                    promise = _currentSearcher.createOrUpdateClauseWithQueryString(reason === AJSHideReason.submit);
                    promise.done(function() {
                        // Check for an "error" class in the searcher's editHtml.
                        // If so, leave the dialog open and rerender to the the updated editHtml.
                        // Otherwise close the dialog.
                        if (_searcher.hasErrorInEditHtml()) {
                            // Prevent displaying the error dialog if the mode has switched to advanced as a
                            // result of the click outside (i.e. on the Switch to Advanced link)
                            if (options.queryStateModel.getSearchMode() === "basic") {
                                module.instance.show(_searcher);
                            }
                        }

                        if (InlineLayer.current) {
                            // page layout might have changed as a result of updating a lozenge content (need to make sure dialog is in correct position)
                            InlineLayer.current.setPosition();
                        }
                    });

                    promise.always(function() {
                        promise = null;
                    });

                    _searcher.clearEditHtml();
                }

                if (reason === AJSHideReason.submit) {
                    // If this is a submit, always do de search
                    _currentView.applyFilter();
                    doSearch();
                } else if (reason !== AJSHideReason.cancelClicked && reason !== AJSHideReason.escPressed &&
                    reason !== AJSHideReason.tabbedOut) {
                    // If the dialog has not been cancelled, do the search only if the selector has not changed.
                    if (_currentView.applyFilter()) {
                        doSearch();
                    }
                } else {
                    trace("jira.search.searchers.hiddenWithoutUpdate");
                }

                _currentView.$el.remove();
                _currentView = null;
                _currentSearcher = null;
            });

            /**
             * JRADEV-15697 - Ensure all the dialog is closed when we switch search modes.
             */
            options.queryStateModel.on("change:searchMode", function() {
                _dialog.hide();
            });

            return {
                /**
                 * @return {SearcherModel} the searcher for which the dialog was last shown.
                 */
                getCurrentSearcher: function() {
                    return _currentSearcher;
                },

                /**
                 * Hide and show dialog
                 */
                toggle: function(searcher) {
                    if (_currentSearcher != null) {
                        if (_currentSearcher !== searcher) {
                            _dialog.hide(AJSHideReason.switchLozenge);
                            this.show(searcher);
                        } else {
                            _dialog.hide(AJSHideReason.toggle);
                        }
                    } else {
                        this.show(searcher);
                    }
                },

                _show: function(searcher) {
                    _.defer(function() {
                        _currentSearcher = searcher;
                        _dialog.show();
                        _dialog.setPosition();
                    });
                },

                /**
                 * shows dialog with correct searcher
                 * @param {JIRA.Issues.SearcherModel} searcher
                 */
                show: function(searcher) {
                    var waitingToShow;
                    if (module.waitingToShow) {
                        waitingToShow = true;
                    }

                    var instance = this;
                    module.waitingToShow = function() {
                        instance._show(searcher);
                        module.waitingToShow = null;
                    };

                    if (!waitingToShow) {
                        // Defer showing until all searchers are ready.
                        searcher.searchersReady().done(function() {
                            if (promise) {
                                promise.done(function() {
                                    module.waitingToShow();
                                });
                            } else {
                                module.waitingToShow();
                            }
                        });
                    }
                },

                /**
                 * Bind a handler to be called when the dialog is shown.
                 *
                 * @param handler The function to call when the dialog is shown.
                 */
                onShow: function(handler) {
                    _dialog.bind(InlineLayer.EVENTS.show, handler);
                },

                /**
                 * Hide the current dialog. Drrrrr!
                 */
                hide: function() {
                    _dialog.hide();
                },

                /**
                 * Bind a handler to be called when the dialog is hidden.
                 *
                 * @param handler The function to call when the dialog is hidden.
                 */
                onHide: function(handler) {
                    _dialog.bind(InlineLayer.EVENTS.hide, handler);
                }
            };
        }
    }();

    return module;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/templates/query-jql.soy' */
// This file was automatically generated from query-jql.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavQueryJql.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavQueryJql == 'undefined') { JIRA.Templates.IssueNavQueryJql = {}; }


JIRA.Templates.IssueNavQueryJql.jqlQueryView = function(opt_data, opt_ignored) {
  return '<div class="search-field-container"><div class="atlassian-autocomplete"><label for="advanced-search"><span id="jqlerrormsg" class="icon jqlgood"><span>' + soy.$$escapeHtml("parse") + '</span></span> <span class="jql-label">' + soy.$$escapeHtml("Query") + ' <span id="jqlcolrowcount">' + soy.$$escapeHtml("line") + ':<span id="jqlrownum">0</span>' + soy.$$escapeHtml("character") + ':<span id="jqlcolumnnum">0</span></span></span></label><textarea id="advanced-search" class="search-entry advanced-search ajs-dirty-warning-exempt" name="jql"></textarea><a class="syntax-help" href="' + soy.$$escapeHtml(opt_data.helpUrl) + '" title="' + soy.$$escapeHtml("Syntax Help") + '" target="_jirahelp" tabindex="-1"><span class="aui-icon aui-icon-small aui-iconfont-help">' + soy.$$escapeHtml("Syntax Help") + '</span></a></div></div><div class="search-options-container">' + ((opt_data.hasSearchButton) ? '<button class="aui-item aui-button aui-button-subtle search-button" type="button" title="' + soy.$$escapeHtml("Search for issues") + '"><span class="aui-icon aui-icon-small aui-iconfont-search">' + soy.$$escapeHtml("Search") + '</span></button>' : '') + '<span class="mode-switcher"></span></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryJql.jqlQueryView.soyTemplateName = 'JIRA.Templates.IssueNavQueryJql.jqlQueryView';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/jql/JqlAutoCompleteView.js' */
define("jira/components/query/jql/jqlautocompleteview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var JQLParser = require("jira/jql/jql-parser");
    var JQLAutoComplete = require("jira/autocomplete/jql-autocomplete");
    var contextPath = AJS.contextPath();

    return Brace.View.extend({

        namedEvents: ["jqlValid", "jqlInvalid", "searchRequested"],

        events: {
            "focus": "_onFocus"
        },

        getJqlAutoCompleteData: function() {
            var deferred = new jQuery.Deferred();
            if (this.jqlFieldNames == null || this.jqlFunctionNames == null || this.jqlReservedWords == null) {
                var $jqlFieldNames = jQuery("#jqlFieldz");
                var $jqlFunctionNames = jQuery("#jqlFunctionNamez");
                var $jqlReservedWords = jQuery("#jqlReservedWordz");
                if ($jqlFieldNames.length > 0 && $jqlFunctionNames.length > 0 && $jqlReservedWords.length > 0) {
                    this.jqlFieldNames = JSON.parse($jqlFieldNames.text());
                    this.jqlFunctionNames = JSON.parse($jqlFunctionNames.text());
                    this.jqlReservedWords = JSON.parse($jqlReservedWords.text());
                } else {
                    jQuery.ajax({
                        url: contextPath + "/rest/querycomponent/latest/jqlAutoComplete"
                    }).done(_.bind(function(response) {
                        var jqlAutoCompleteData = JSON.parse(response);
                        this.jqlFieldNames = _.reject(JSON.parse(jqlAutoCompleteData.jqlFieldz), _.bind(function(item) {
                            return _.contains(this.model.getWithout(), item.value);
                        }, this));
                        this.jqlFunctionNames = JSON.parse(jqlAutoCompleteData.jqlFunctionNamez);
                        this.jqlReservedWords = JSON.parse(jqlAutoCompleteData.jqlReservedWordz);
                        deferred.resolve();
                    }, this));
                    return deferred.promise();
                }
            }
            return deferred.resolve().promise();
        },

        _initJQLAutoComplete: function() {
            var $advSearch = this.$el;
            var jqlAutoComplete = new JQLAutoComplete({
                fieldID: $advSearch.attr("id"),
                parser: new JQLParser(this.jqlReservedWords),
                queryDelay: 0.65,
                jqlFieldNames: this.jqlFieldNames,
                jqlFunctionNames: this.jqlFunctionNames,
                minQueryLength: 0,
                allowArrowCarousel: true,
                autoSelectFirst: false,
                errorID: 'jqlerrormsg'
            });

            var instance = this;

            $advSearch.keypress(function(event) {
                if (jqlAutoComplete.dropdownController === null || !jqlAutoComplete.dropdownController.displayed || jqlAutoComplete.selectedIndex < 0) {
                    if (event.keyCode === 13 && !event.ctrlKey && !event.shiftKey) {
                        event.preventDefault();
                        jqlAutoComplete.dropdownController.hideDropdown();
                        // Dodgy but the JQL auto complete has stopped propagation of the keypress event. And we need to let
                        // the query module know a search has been requested.
                        instance.triggerSearchRequested($advSearch.val());
                    }
                }
            });

            var oldUpdateParseIndicator = jqlAutoComplete.updateParseIndicator;
            jqlAutoComplete.updateParseIndicator = function(token) {
                oldUpdateParseIndicator.apply(this, arguments);
                if (!token.getParseError()) {
                    instance.triggerJqlValid($advSearch.val());
                } else {
                    instance.triggerJqlInvalid($advSearch.val());
                }
            };

            jqlAutoComplete.buildResponseContainer();
            jqlAutoComplete.parse($advSearch.val());
            jqlAutoComplete.updateColumnLineCount();

            $advSearch.bind('expandedOnInput', function() {
                jqlAutoComplete.positionResponseContainer();
            }).bind("updateParseIndicator", function() {
                jqlAutoComplete.parse($advSearch.val());
            }).click(function() {
                jqlAutoComplete.dropdownController.hideDropdown();
            });
        },

        _onFocus: function() {
            // The renderer may destroy the old <textarea> and insert a new one, so we'll need to
            // init JQL autocompletion anytime this property is not set.
            if (!this.model.getAutocompleteEnabled() || this.$el.data("JQLAutoComplete_init")) {
                return;
            }
            this.$el.data("JQLAutoComplete_init", true);
            this.getJqlAutoCompleteData().done(_.bind(this._initJQLAutoComplete, this));
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/jql/JqlQueryModule.js' */
define("jira/components/query/jql/jqlquerymodule", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var JqlQueryView = require("jira/components/query/jql/jqlqueryview");
    var Events = require("jira/util/events");
    var Types = require("jira/util/events/types");
    var Reasons = require("jira/util/events/reasons");

    /**
     * Module for JQL query mode
     */
    return Brace.Evented.extend({

        namedEvents: ["searchRequested", "verticalResize", "searchChanged"],

        initialize: function(options) {

            this._queryStateModel = options.queryStateModel;
            this.view = new JqlQueryView({
                queryStateModel: options.queryStateModel
            })
                .onVerticalResize(this.triggerVerticalResize, this)
                .onSearchRequested(this.triggerSearchRequested, this)
                .onSearchChanged(this.triggerSearchChanged, this);

            /* Absolute hack to prevent DESK-1623 - after return to search, the jql box is thin cause issue nav is hidden when
             rendered so height calculation is wrong. We need to trigger it to recalculate height on return to search.
             I have added a method, refreshLayout to the query component which we now call from issue-nav-plugin
             SearchPageModule, however jira can be using a newer version of issue-nav-components that issue-nav-plugin
             (installed via service desk). So we need this nasty hack until the minimum version of jira service desk
             supports has the updateLayout call inside of SearchPageModule.
             */
            Events.bind(Types.NEW_CONTENT_ADDED, _.bind(function(e, el, reason) {
                if (reason === Reasons.returnToSearch) {
                    this.setQuery();
                }
            }, this));
        },

        search: function() {
            var jql = this.view.readJql();
            this.triggerSearchRequested(jql);
        },

        setQuery: function() {
            this.view.setQuery();
        },

        createView: function() {
            return this.view;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/jql/JqlQueryView.js' */
define("jira/components/query/jql/jqlqueryview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryJql = require("jira/components/query/templates/issuenavqueryjql");
    var JQLAutoCompleteView = require("jira/components/query/jql/jqlautocompleteview");
    var Meta = require("jira/util/data/meta");
    var Tipsy = require("jira/issues/tipsy");

    /**
     * Renders the JQL textarea.
     */
    return Brace.View.extend({
        template: IssueNavQueryJql.jqlQueryView,

        namedEvents: ["verticalResize", "searchRequested", "searchChanged"],

        events: {
            "expandedOnInput": "_handleExpandOnInput",
            "input": function() {
                this.trigger("searchChanged", {
                    newJql: this.readRawJql()
                });
            }
        },

        initialize: function(options) {
            this.queryStateModel = options.queryStateModel;
            this.queryStateModel.on("change:jql", this.setQuery, this);
            jQuery(document).bind('issueNavWidthChanged', _.bind(this._resizeHeight, this));

            if (JQLAutoCompleteView) {
                this.JQLAutoCompleteView = new JQLAutoCompleteView({model: this.queryStateModel});
                this.JQLAutoCompleteView.onJqlValid(function(jql) {
                    if (this.queryStateModel.getAdvancedAutoUpdate()) {
                        this.triggerSearchRequested(jql);
                    }
                }, this);
                this.JQLAutoCompleteView.onSearchRequested(this.triggerSearchRequested, this);
            }
        },

        render: function() {

            this.$el.html(this.template({
                helpUrl: Meta.get('advanced-search-help-url'),
                helpTitle: Meta.get('advanced-search-help-title'),
                hasSearchButton: this.queryStateModel.hasSearchButton()
            }));

            this.$el.addClass("loading");

            if (this.JQLAutoCompleteView) {
                this.JQLAutoCompleteView.setElement(this.$el.find(".advanced-search"));
                this.JQLAutoCompleteView.getJqlAutoCompleteData();
            }

            new Tipsy({
                el: this.$el.find(".search-button"),
                tipsy: {
                    trigger: "hover",
                    delayIn: 300
                }
            });

            this.setQuery();
            return this;
        },

        /**
         * Gets the JQL from the input field.
         *
         * The difference with readJQL() is that this method has no
         * side effects, it just returns the JQL as-is.
         *
         * @returns {string} The JQL, or empyt string if the JQL is empty
         */
        readRawJql: function() {
            var $inputField = this._getInputField();
            return $inputField.val() || "";
        },

        /**
         * Sanizites the JQL from the input field and returns it.
         *
         * Note: this function have a few side effects:
         *      * It trims the JQL
         *      * It changes the field to the trimmed JQL
         *      * It changes the height of the field
         *
         * @returns {string} the JQL
         */
        readJql: function() {
            var jql = this.readRawJql();
            var $inputField = this._getInputField();

            // Prettify input field with trimmed JQL
            var trimmedJql = jQuery.trim(jql);
            if (jql !== trimmedJql) {
                $inputField.val(trimmedJql);
            }
            this._resizeHeight();
            return trimmedJql;
        },

        _handleExpandOnInput: function() {
            this.triggerVerticalResize();
        },

        _resizeHeight: function() {
            var $input = this._getInputField();
            // Need to set the height of the input to 0 for expandOnInput to reliably expand.
            // However, expandOnInput doesn't change the height of empty inputs, so need to handle those a little differently.
            if ($input.val()) {
                $input.height(0).expandOnInput();
            } else {
                $input.expandOnInput().height(0).trigger('refreshInputHeight');
            }

        },

        setQuery: function() {
            this.$el.removeClass("loading"); // Just in case we have come here from basic, loading class might be persisted. So remove.
            this._getInputField().val(this.queryStateModel.getJql());
            this._getInputField().trigger("updateParseIndicator");
            this._resizeHeight();
        },

        focus: function() {
            this._getInputField().focus();
        },

        _getInputField: function() {
            return this.$el ? this.$el.find("textarea") : jQuery();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/templates/query.soy' */
// This file was automatically generated from query.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavQuery.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavQuery == 'undefined') { JIRA.Templates.IssueNavQuery = {}; }


JIRA.Templates.IssueNavQuery.searchSwitcher = function(opt_data, opt_ignored) {
  var output = '';
  var itemList3 = opt_data.items;
  var itemListLen3 = itemList3.length;
  for (var itemIndex3 = 0; itemIndex3 < itemListLen3; itemIndex3++) {
    var itemData3 = itemList3[itemIndex3];
    output += JIRA.Templates.IssueNavQuery.searchSwitcherItem({id: itemData3.id, isActive: itemData3.id == opt_data.selectedId});
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQuery.searchSwitcher.soyTemplateName = 'JIRA.Templates.IssueNavQuery.searchSwitcher';
}


JIRA.Templates.IssueNavQuery.searchSwitcherItem = function(opt_data, opt_ignored) {
  return '<a href="#" class="switcher-item' + soy.$$escapeHtml(opt_data.isActive ? ' active' : '') + ' " data-id=\'' + soy.$$escapeHtml(opt_data.id) + '\' title="' + ((opt_data.id == 'basic') ? soy.$$escapeHtml("Switch to advanced search using JQL") : soy.$$escapeHtml("Switch to basic search")) + '">' + ((opt_data.id == 'basic') ? soy.$$escapeHtml("Advanced") : soy.$$escapeHtml("Basic")) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQuery.searchSwitcherItem.soyTemplateName = 'JIRA.Templates.IssueNavQuery.searchSwitcherItem';
}


JIRA.Templates.IssueNavQuery.queryView = function(opt_data, opt_ignored) {
  return '<div class="aui-group"><div class="aui-item search-wrap"><div class="search-container"></div><div class="save-filter-controls"></div></div>' + ((opt_data.layoutSwitcher) ? '<div class="aui-item view-selector" id="layout-switcher-toggle"></div>' : '') + '</div><div class="notifications"></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQuery.queryView.soyTemplateName = 'JIRA.Templates.IssueNavQuery.queryView';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/QueryModule.js' */
define("jira/components/query/querymodule", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var QueryView = require("jira/components/query/queryview");
    var SearcherDialog = require("jira/components/query/basic/searcherdialog");
    var BasicQueryModule = require("jira/components/query/basic/basicquerymodule");
    var JqlQueryModule = require("jira/components/query/jql/jqlquerymodule");

    /**
     * Module for basic query mode
     */
    return Brace.Evented.extend({

        namedEvents: [
            "jqlChanged",
            "jqlTooComplex",
            "jqlError",
            "jqlSuccess",
            "searchRequested",
            "searchChanged",
            "queryTooComplexSwitchToAdvanced",
            "changedPreferredSearchMode",
            "basicModeCriteriaCountWhenSearching",
            "verticalResize",
            "initialized"
        ],

        initialize: function(options) {
            this._queryStateModel = options.queryStateModel;
            this._queryStateModel.on("change:preferredSearchMode", _.bind(function() {
                this.triggerChangedPreferredSearchMode(this._queryStateModel.getPreferredSearchMode());
            }, this));

            SearcherDialog.initialize({
                queryStateModel: this._queryStateModel
            });
            this._jqlQueryModule = new JqlQueryModule({
                queryStateModel: this._queryStateModel
            })
            .onSearchRequested(this.handleAdvancedSearchRequested, this)
            .onVerticalResize(this.triggerVerticalResize, this)
            .onSearchChanged(this.triggerSearchChanged, this);

            this._errors = {};
            this._errors[this._queryStateModel.BASIC_SEARCH] = [];
            this._errors[this._queryStateModel.ADVANCED_SEARCH] = [];

            this._queryStateModel.on("change:searchMode", this.showSearchErrors, this);

            this._basicQueryModule = new BasicQueryModule({
                queryStateModel: this._queryStateModel,
                primaryClauses: options.primaryClauses,
                initialSearcherCollectionState: options.searchers,
                context: options.context
            })
                .onSearchRequested(this.clearSearchErrors, this)
                .onJqlTooComplex(this.handleJqlTooComplex, this)
                .onSearchRequested(this.handleSearchRequested, this)
                .onVerticalResize(this.triggerVerticalResize, this)
                .onBasicModeCriteriaCountWhenSearching(this.triggerBasicModeCriteriaCountWhenSearching, this);
        },

        // If we have rendered in the background (when hidden), our size calculations for jql box are incorrect so we need
        // away for the outside world to tell us to recalculate.
        refreshLayout: function() {
            this._jqlQueryModule.setQuery();
        },

        handleAdvancedSearchRequested: function(jql) {
            this.handleSearchRequested(jql);
            this._basicQueryModule.queryChanged();
        },

        handleSearchRequested: function(jql) {
            this._queryStateModel.setJql(jql);
            this.clearSearchErrors();
        },

        handleJqlTooComplex: function(jql) {
            if (this.getSearchMode() !== this._queryStateModel.ADVANCED_SEARCH) {
                this.triggerQueryTooComplexSwitchToAdvanced();
            }
            this.setSearchMode(this._queryStateModel.ADVANCED_SEARCH);
            this.triggerJqlTooComplex(jql);
            if (this._queryView) {
                this._queryView.switcherViewModel.disableSwitching();
            }
        },

        getJql: function() {
            return this._queryStateModel.getJql();
        },

        getSearcherCollection: function() {
            return this._basicQueryModule.searcherCollection;
        },

        /**
         * @return {boolean} whether the query module is currently in basic mode.
         * @private
         */
        isBasicMode: function() {
            return this._queryStateModel.getSearchMode() === this._queryStateModel.BASIC_SEARCH;
        },

        /**
         * Reset the query module to match the current query.
         *
         * Clears error messages, switches to the user's preferred search mode, and
         * hides the entire query view if the currently selected filter is invalid.
         *
         * If the user has requested a new search then this method will focus the search view.
         *
         * @param jql
         * @param options
         * @param options.focusQuery true if we should focus the searchers after resetting
         */
        resetToQuery: function(jql, options) {
            this.clearSearchErrors();
            return this._basicQueryModule.queryReset(jql).always(_.bind(function() {
                this._queryStateModel.switchToPreferredSearchMode();
                this._jqlQueryModule.setQuery();
                if (options && options.focusQuery === true) {
                    this._queryView.getView().focus();
                }

                this._basicQueryModule.off("searchRequested", this.publishJqlChanges);
                this._jqlQueryModule.off("searchRequested", this.publishJqlChanges);

                // subsequent search requestes are published
                this._basicQueryModule.onSearchRequested(this.publishJqlChanges, this);
                this._jqlQueryModule.onSearchRequested(this.publishJqlChanges, this);
            }, this));
        },

        publishJqlChanges: function(jql) {
            this.triggerJqlChanged(jql);
        },

        setVisible: function(value) {
            this._queryView.setVisible(value);
        },

        /**
         * Notifies this module that the underlying jql has changed and it should update itself
         */
        queryChanged: function() {
            this.clearSearchErrors();
            this._basicQueryModule.queryChanged();
        },

        onSearchSuccess: function(warnings) {
            if (this._queryView) {
                this._queryView.showWarnings(warnings);
            }
            this.triggerJqlSuccess();
        },

        /**
         * Wait any in flight updates to search collection.
         */
        searchersReady: function() {
            return this._basicQueryModule.searchersReady();
        },

        onSearchError: function(response) {
            this._errors.renderFunction = "showErrors";
            var basicModeErrors = (response.errorMessages) ? response.errorMessages.concat() : [];
            var advancedModeErrors = [];

            _.each(response.errors, function(message, type) {
                if (type === "jql") {
                    advancedModeErrors.push(message);
                } else {
                    basicModeErrors.push(message);
                }
            });

            if (this.getSearchMode() === this._queryStateModel.BASIC_SEARCH && !this._basicQueryModule.hasErrors() && advancedModeErrors.length > 0) {
                // If the search was performed in basic mode, an advanced mode error was
                // encountered, switch to advanced mode before rendering these errors.
                this.setSearchMode(this._queryStateModel.ADVANCED_SEARCH);
            }

            this._errors[this._queryStateModel.BASIC_SEARCH] = basicModeErrors;
            this._errors[this._queryStateModel.ADVANCED_SEARCH] = advancedModeErrors.concat(basicModeErrors);

            this.showSearchErrors();
            this.triggerJqlError();
        },

        /**
         * Show error messages applicable to the current search mode.
         */
        showSearchErrors: function() {
            if (this._queryView) {
                this._queryView.clearNotifications();
                var renderFunction = this._errors.renderFunction || "showErrors";
                this._queryView[renderFunction](this._errors[this.getSearchMode()]);
            }
        },

        /**
         * Remove error messages from all search modes.
         */
        clearSearchErrors: function() {
            if (this._queryView) {
                this._queryView.clearNotifications();
                this._queryView.switcherViewModel.enableSwitching();
            }
            this._errors[this._queryStateModel.BASIC_SEARCH].length = 0;
            this._errors[this._queryStateModel.ADVANCED_SEARCH].length = 0;
        },

        getSearchMode: function() {
            return this._queryStateModel.getSearchMode();
        },

        getActiveBasicModeSearchers: function() {
            return this._basicQueryModule.getSelectedCriteria();
        },

        /**
         * @param {string} searchMode -- Either "basic" or "advanced"
         * @return {boolean} -- Indicates whether or not the search mode actually changed
         */
        setSearchMode: function(searchMode) {
            if (this.getSearchMode() !== searchMode) {
                this._queryStateModel.switchToSearchMode(searchMode);
                return true;
            }
            return false;
        },

        createAndRenderView: function($el) {
            this._queryView = new QueryView({
                el: $el,
                queryStateModel: this._queryStateModel,
                basicQueryModule: this._basicQueryModule,
                jqlQueryModule: this._jqlQueryModule
            }).onVerticalResize(this.triggerVerticalResize, this);
            this._queryView.render();
        },

        isQueryValid: function() {
            return (this._errors &&
            this._errors[this._queryStateModel.BASIC_SEARCH].length === 0 &&
            this._errors[this._queryStateModel.ADVANCED_SEARCH].length === 0);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/QueryStateModel.js' */
define("jira/components/query/querystatemodel", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var displayFailSearchMessage = JIRA.Issues.displayFailSearchMessage;
    var contextPath = AJS.contextPath();
    var jQuery = require("jquery");

    function trace() {
        return JIRA.trace.apply(JIRA, arguments);
    }

    /**
     * Represents current and preferred search modes (basic or jql)
     */
    return Brace.Model.extend({

        BASIC_SEARCH: "basic",
        ADVANCED_SEARCH: "advanced",

        namedAttributes: [
            "style",
            "searchMode",
            "preferredSearchMode",
            "jql",
            "without",
            "layoutSwitcher",
            "autocompleteEnabled",
            "advancedAutoUpdate",
            "basicAutoUpdate",
            "basicOrderBy"
        ],

        defaults: {
            searchMode: "basic",
            preferredSearchMode: "basic"
        },

        /**
         * Sets search mode
         * @param searchMode search mode (basic or advanced)
         */
        switchToSearchMode: function(searchMode) {
            this.setSearchMode(searchMode);
        },

        /**
         * Changes the preferred and actual search mode and saves the preferred search mode.
         */
        switchPreferredSearchMode: function(mode) {
            this.switchToSearchMode(mode);
            this.setPreferredSearchMode(mode);
            this._savePreferredSearchMode();
        },

        /**
         * Switches to whatever is the preferred search mode
         */
        switchToPreferredSearchMode: function() {
            this.switchToSearchMode(this.getPreferredSearchMode());
        },

        hasSearchButton: function() {
            return this.getStyle() !== "field";
        },

        /**
         * Should the more criteria button be subtly styled
         */
        hasSubtleMoreCriteria: function() {
            return this.getStyle() !== "field";
        },

        /**
         * Persists preferred search mode to the server
         */
        _savePreferredSearchMode: function() {
            jQuery.ajax({
                url: contextPath + "/rest/querycomponent/latest/userSearchMode", // IssueTableResource (JIRA core)
                type: 'POST',
                headers: {
                    "X-Atlassian-Token": "no-check"
                },
                data: {
                    searchMode: this.getPreferredSearchMode()
                },
                error: _.bind(function(xhr) {
                    if (displayFailSearchMessage) {
                        displayFailSearchMessage(xhr);
                    }
                }, this),
                success: function() {
                    trace("jira.search.mode.changed");
                }
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/SwitcherModel.js' */
define("jira/components/query/switchermodel", ["require"], function(require) {
    "use strict";

    var Brace = require("jira/components/libs/brace");

    return Brace.Model.extend({

        /**
         * id: id of the switcher
         * name: switcher name (displayed in switcher view)
         * view: backbone view object
         */
        namedAttributes: ["id", "name", "view", "text"]

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/SwitcherCollection.js' */
define("jira/components/query/switchercollection", ["require"], function(require) {
    "use strict";

    var Brace = require("jira/components/libs/brace");
    var SwitcherModel = require("jira/components/query/switchermodel");

    return Brace.Collection.extend({
        model: SwitcherModel
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/QuerySwitcherViewModel.js' */
define("jira/components/query/queryswitcherviewmodel", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var SingleSelect = require("jira/components/query/mixin/singleselect");

    /**
     * Model that represents a switcher collection with a selection for the switcher in the query view
     */
    return Brace.Model.extend({

        mixins: [SingleSelect],

        namedAttributes: ["disabled"],

        namedEvents: ["selectionChanged"],

        initialize: function(attributes, options) {
            this.queryStateModel = options.queryStateModel;
            this.queryStateModel.on("change:searchMode", _.bind(function() {
                this.triggerSelectionChanged.apply(this, arguments);
            }, this));
        },

        getSelected: function() {
            var id = this.queryStateModel.getSearchMode();
            return id ? this.getCollection().get(id) : null;
        },

        setSelected: function(selected) {
            this.queryStateModel.switchPreferredSearchMode(selected ? selected.id : null);
        },

        enableSwitching: function() {
            this.setDisabled(false);
        },

        disableSwitching: function() {
            this.setDisabled(true);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/QueryView.js' */
define("jira/components/query/queryview", ["require"], function(require) {
    "use strict";

    var Brace = require("jira/components/libs/brace");
    var IssueNavQuery = require("jira/components/query/templates/issuenavquery");
    var SwitcherCollection = require("jira/components/query/switchercollection");
    var SwitcherView = require("jira/components/query/switcherview");
    var QuerySwitcherViewModel = require("jira/components/query/queryswitcherviewmodel");
    var ComponentUtilTemplate = require("jira/components/query/templates/issues/componentutil");

    /**
     * This renders the container for either the basic query view or the advanced query view.
     *
     * @see JIRA.Issues.JqlQueryView
     * @see JIRA.Issues.BasicQueryView
     */
    return Brace.View.extend({

        namedEvents: ["verticalResize"],

        template: IssueNavQuery.queryView,

        events: {
            "click .search-button": "search",
            "submit": "preventDefault"
        },

        initialize: function(options) {
            this.queryStateModel = options.queryStateModel;

            var switcherCollection = new SwitcherCollection([
                {
                    id: this.queryStateModel.BASIC_SEARCH,
                    name: "Basic",
                    view: options.basicQueryModule.createView()
                }, {
                    id: this.queryStateModel.ADVANCED_SEARCH,
                    name: "Advanced",
                    view: options.jqlQueryModule.createView()
                }
            ]);

            // TODO: hack for search() below, to fix
            this.jqlQueryModule = options.jqlQueryModule;

            this.switcherViewModel = new QuerySwitcherViewModel({
                collection: switcherCollection
            }, {
                queryStateModel: this.queryStateModel
            });

            this.switcherView = new SwitcherView({
                template: IssueNavQuery.searchSwitcher,
                model: this.switcherViewModel,
                containerClass: ".search-container"
            }).onVerticalResize(this.triggerVerticalResize, this);

        },

        render: function() {
            this.$el.html(this.template(this.queryStateModel.toJSON()));
            this.switcherView.setElement(this.$el).render();
            return this;
        },

        preventDefault: function(e) {
            e.preventDefault();
        },

        /**
         * Clear the notifications area (errors and warnings).
         */
        clearNotifications: function() {
            this.$(".notifications").empty();
        },

        /**
         * Performs a search with a query defined by the value of the textarea.
         *
         * This calls search on the model, only if we don't have an active saved search,
         * or if the query was changed from the current active saved search.
         *
         */
        search: function() {
            // TODO: temp hack for jql query view rework
            if (this.queryStateModel.ADVANCED_SEARCH === this.switcherViewModel.getSelected().getId()) {
                this.jqlQueryModule.search();
            }
            else {
                this.getView().search();
            }
        },

        getView: function() {
            return this.switcherViewModel.getSelected().getView();
        },

        /**
         * Display one or more errors in the notification area.
         *
         * @param {Array} errors The error(s) to be displayed.
         */
        showErrors: function(errors) {
            this.$(".notifications").append(ComponentUtilTemplate.errorMessage({messages: errors}));
        },

        /**
         * Display one or more warnings in the notification area.
         *
         * @param {Array} warnings The warning(s) to be displayed.
         */
        showWarnings: function(warnings) {
            this.$(".notifications").append(ComponentUtilTemplate.warningMessage({messages: warnings}));
        },

        /**
         * Hide or show the view (excluding error messages).
         *
         * @param isVisible Whether the view should be visible.
         */
        setVisible: function(isVisible) {
            this.$(".search-container").toggleClass('hidden', !isVisible);
            this.switcherView.setVisible(isVisible);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/SwitcherView.js' */
define("jira/components/query/switcherview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var Tipsy = require("jira/issues/tipsy");

    /**
     * View that allows switching between querying modes
     */
    return Brace.View.extend({

        namedEvents: ["verticalResize"],

        tagName: "div",

        events: {
            "click .switcher-item": "_onSwitcherClick"
        },

        initialize: function(options) {
            this.containerClass = options.containerClass;
            this.model = options.model;
            this.template = options.template;
            this.model.onSelectionChanged(this._onSelect, this);
            this.switchEl = jQuery();
            this.model.on("change:disabled", _.bind(this._setSwitching, this));
        },

        /**
         * Render the switcher and the currently selected item.
         */
        render: function() {
            this._onSelect();
            this._render();
        },

        /**
         * Render the switcher.
         *
         * @private
         */
        _render: function() {
            var selected = this.model.getSelected();

            this.switchEl = this.$el.find(".mode-switcher");
            this.switchEl.html(this.template({
                items: this.model.getCollection().toJSON(),
                selectedId: selected && selected.id
            }));

            new Tipsy({
                el: this.$el.find(".switcher-item.active")
            });
        },

        getSwitcherTrigger: function() {
            return this.switchEl.find('.switcher-item.active');
        },

        _onSelect: function() {
            var container = this.$el.find(this.containerClass).empty();
            var selected = this.model.getSelected();
            if (selected) {
                container.attr("data-mode", selected.id);
                selected.getView().setElement(container).render();
            }

            this._render();
            this.triggerVerticalResize();
        },

        _onSwitcherClick: function(event) {
            event.preventDefault();
            if (!this.model.getDisabled()) {
                this.model.next();

                var selectedView = this.model.getSelected().getView();
                if (selectedView.focus) {
                    selectedView.focus();
                }
            }
        },

        _setSwitching: function() {
            if (this.model.getDisabled()) {
                this.disableSwitching();
            } else {
                this.enableSwitching();
            }
        },

        disableSwitching: function() {
            this.switchEl.addClass("disabled");
            this.getSwitcherTrigger().attr("original-title", "This query is too complex to display in Simple mode.");
        },

        enableSwitching: function() {
            this.switchEl.removeClass("disabled");
            var selected = this.model.getSelected();
            //if we're currently in advanced mode and we're re-enabling the switcher we need to restore the original title to indicate
            //that the link allows you to switch back to basic mode.
            if (selected && selected.id === "advanced") {
                this.getSwitcherTrigger().attr("original-title", "Switch to basic search");
            }
        },

        /**
         * Hide or show the switcher trigger.
         *
         * @param isVisible Whether the switcher should be visible.
         */
        setVisible: function(isVisible) {
            this.switchEl.toggleClass("hidden", !isVisible);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/Query.js' */
define("jira/components/query", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var QueryModule = require("jira/components/query/querymodule");
    var QueryStateModel = require("jira/components/query/querystatemodel");

    return function() {

        var CLAUSES = {
            project: "Project",
            issuetype: "Type",
            status: "Status",
            assignee: "Assignee",
            reporter: "Reporter",
            labels: "Labels",
            resolution: "Resolution",
            created: "Created Date",
            updated: "Updated Date",
            resolutiondate: "Resolution Date",
            description: "Description",
            duedate: "Due Date",
            comment: "Comment",
            fixfor: "Fix Version",
            version: "Affects Version",
            component: "Component"
        };

        return {

            DEFAULT_CLAUSES: ["project", "issuetype", "status", "assignee"],

            create: function(options) {

                options = _.defaults(options, {
                    primaryClauses: this.DEFAULT_CLAUSES,
                    without: [],
                    style: "generic",
                    /* This has to be true :( - If issue-nav-components is anything below 6.2, the layoutSwitcher option
                     * didn't exist when it was first consumed in 6.1. */
                    layoutSwitcher: true,
                    autocompleteEnabled: true,
                    advancedAutoUpdate: false,
                    basicOrderBy: false,
                    basicAutoUpdate: true,
                    preferredSearchMode: "basic"
                });

                options.primaryClauses = _.reject(options.primaryClauses, function(clause) {
                    return _.contains(options.without, clause.id);
                });

                _.each(options.primaryClauses, function(clause, idx) {
                    if (typeof clause === "string") {
                        if (CLAUSES[clause]) {
                            options.primaryClauses[idx] = {id: clause, name: CLAUSES[clause]};
                        } else {
                            /*eslint-disable no-console */
                            console.error("jira/components/query: You have specified clause [" + clause + "]. " +
                            "But we do not have the i18n string for it, probably a custom field. Instead use {id:" + clause + ", name: '[NAME_HERE]'}");
                            /*eslint-enable no-console */
                        }
                    }
                });

                var queryModule = new QueryModule({
                    queryStateModel: new QueryStateModel({
                        jql: options.jql,
                        without: options.without,
                        style: options.style,
                        layoutSwitcher: options.layoutSwitcher,
                        autocompleteEnabled: options.autocompleteEnabled,
                        advancedAutoUpdate: options.advancedAutoUpdate,
                        basicAutoUpdate: options.basicAutoUpdate,
                        preferredSearchMode: options.preferredSearchMode,
                        basicOrderBy: options.basicOrderBy
                    }),
                    primaryClauses: options.primaryClauses,
                    searchers: options.searchers,
                    context: options.context
                });

                jQuery(options.el).addClass("query-component " + options.style + "-styled");

                queryModule.createAndRenderView(options.el);

                if (options.jql || options.jql === "") {
                    queryModule.resetToQuery(options.jql).always(function() {
                        jQuery(options.el).addClass("ready");
                        // Consumers of this component want to know when the jql (given at construction) is represented in the ui.
                        queryModule.triggerInitialized(options.jql);
                    });
                }
                return queryModule;
            }
        };
    }();
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/templates/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/components/query/templates/issuenavquery", function() {
    "use strict";

    return JIRA.Templates.IssueNavQuery;
});

define("jira/components/query/templates/issuenavquerybasic", function() {
   "use strict";

    return JIRA.Templates.IssueNavQueryBasic;
});

define("jira/components/query/templates/issuenavqueryjql", function() {
    "use strict";

    return JIRA.Templates.IssueNavQueryJql;
});

define("jira/components/query/templates/issues/componentutil", function() {
   "use strict";

    return JIRA.Templates.Issues.ComponentUtil;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed. Later, we can restore the
 * global reference if needed (see ../namespace.js)
 */
AJS.namespace("JIRA.Templates.IssueNavQuery", null, require("jira/components/query/templates/issuenavquery"));
AJS.namespace("JIRA.Templates.IssueNavQueryBasic", null, require("jira/components/query/templates/issuenavquerybasic"));
AJS.namespace("JIRA.Templates.IssueNavQueryJql", null, require("jira/components/query/templates/issuenavqueryjql"));
AJS.namespace("JIRA.Templates.Issues.ComponentUtil", null, require("jira/components/query/templates/issues/componentutil"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/namespace.js' */
AJS.namespace("JIRA.Components.Query", null, require("jira/components/query"));

AJS.namespace("JIRA.Issues.QueryModule", null, require("jira/components/query/querymodule"));
AJS.namespace("JIRA.Issues.QueryStateModel", null, require("jira/components/query/querystatemodel"));
AJS.namespace("JIRA.Issues.QuerySwitcherViewModel", null, require("jira/components/query/queryswitcherviewmodel"));
AJS.namespace("JIRA.Issues.QueryView", null, require("jira/components/query/queryview"));
AJS.namespace("JIRA.Issues.SwitcherCollection", null, require("jira/components/query/switchercollection"));
AJS.namespace("JIRA.Issues.SwitcherModel", null, require("jira/components/query/switchermodel"));
AJS.namespace("JIRA.Issues.SwitcherView", null, require("jira/components/query/switcherview"));

AJS.namespace("JIRA.Issues.Mixin.SingleSelect", null, require("jira/components/query/mixin/singleselect"));

AJS.namespace("JIRA.Issues.JqlQueryModule", null, require("jira/components/query/jql/jqlquerymodule"));
AJS.namespace("JIRA.Issues.JqlQueryView", null, require("jira/components/query/jql/jqlqueryview"));
AJS.namespace("JIRA.Issues.JQLAutoCompleteView", null, require("jira/components/query/jql/jqlautocompleteview"));

AJS.namespace("JIRA.Issues.BasicQueryModule", null, require("jira/components/query/basic/basicquerymodule"));
AJS.namespace("JIRA.Issues.SearcherCollection", null, require("jira/components/query/basic/searchercollection"));
AJS.namespace("JIRA.Issues.SearcherDialog", null, require("jira/components/query/basic/searcherdialog"));
AJS.namespace("JIRA.Issues.SearcherModel", null, require("jira/components/query/basic/searchermodel"));
AJS.namespace("JIRA.Issues.BasicQueryView", null, require("jira/components/query/basic/basicqueryview"));
AJS.namespace("JIRA.Issues.CardView", null, require("jira/components/query/basic/cardview"));
AJS.namespace("JIRA.Issues.ClauseButtonView", null, require("jira/components/query/basic/clausebuttonview"));
AJS.namespace("JIRA.Issues.ClauseListDialogView", null, require("jira/components/query/basic/clauselistdialogview"));
AJS.namespace("JIRA.Issues.CriteriaModel", null, require("jira/components/query/basic/criteriamodel"));
AJS.namespace("JIRA.Issues.CriteriaView", null, require("jira/components/query/basic/criteriaview"));
AJS.namespace("JIRA.Issues.ExtendedCriteriaContainerView", null, require("jira/components/query/basic/extendedcriteriacontainerview"));
AJS.namespace("JIRA.Issues.PrimaryCriteriaContainerView", null, require("jira/components/query/basic/primarycriteriacontainerview"));
AJS.namespace("JIRA.Issues.SearcherEditDialogView", null, require("jira/components/query/basic/searchereditdialogview"));
AJS.namespace("JIRA.Issues.SearcherGroupListDialogView", null, require("jira/components/query/basic/searchergrouplistdialogview"));
AJS.namespace("JIRA.Issues.TextFieldView", null, "jira/components/query/basic/textfieldview");
AJS.namespace("JIRA.Issues.TextQueryBuilder", null, "jira/components/query/basic/textquerybuilder");
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-query', location = 'content/js/search/query/SearchShifter.js' */
(function() {
    "use strict";

    /**
     * Creates a shifter group factory for search criteria.
     *
     * @param {object} options
     * @param {function} options.isBasicMode A function that returns true iff basic mode is selected.
     * @param {function} options.isFullScreenIssue A function that returns true iff a full screen issue is visible.
     * @param {JIRA.Issues.SearcherCollection} options.searcherCollection The application's searcher collection.
     * @return {function} A shifter group factory suitable to be passed to <tt>JIRA.Shifter.register</tt>.
     */
    JIRA.Issues.SearchShifter = function(options) {
        var getSuggestions;
        var onSelection;
        var shouldShow;
        var toSuggestion;

        getSuggestions = function() {
            var suggestions = options.searcherCollection.chain()
                .filter(shouldShow)
                .map(toSuggestion)
                .value();

            return function() {
                return new jQuery.Deferred().resolve(suggestions).promise();
            };
        };

        onSelection = function(id) {
            var currentSearcher = JIRA.Issues.SearcherDialog.instance.getCurrentSearcher();
            var searcher = options.searcherCollection.get(id);

            if (!searcher.getIsSelected()) {
                searcher.select();
            }

            // toggle closes the dialog if it's open, so ensure that's not the case.
            if (!currentSearcher || currentSearcher.getId() !== searcher.getId()) {
                JIRA.Issues.SearcherDialog.instance.toggle(searcher);
            }
        };

        // Determine whether the given searcher should be suggested.
        shouldShow = function(searcherModel) {
            return searcherModel.getIsShown();
        };

        // Create a shifter suggestion from a SearcherModel.
        toSuggestion = function(searcherModel) {
            return {
                label: searcherModel.getName(),
                value: searcherModel.getId()
            };
        };

        return function() {
            // Only show suggestions if we're in basic mode and the search criteria are visible.
            if (!options.isBasicMode() || options.isFullScreenIssue()) {
                return null;
            }

            return {
                getSuggestions: getSuggestions(),
                name: "Search Criteria",
                onSelection: onSelection,
                weight: 150
            };
        };
    };

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-2.1.0', location = 'libs/marionette-2.1.0.js' */
define("jira/components/libs/marionette-2.1.0", [
    "atlassian/libs/factories/marionette-2.1.0",
    "jira/components/libs/backbone",
    "jira/components/libs/underscore"
], function(
    marionetteFactory,
    Backbone,
    _
) {
    "use strict";
    var Marionette = marionetteFactory(_, Backbone);

    /**
     * Triggers a preventable event.
     *
     * The event will include an EventObject, and the handler can call eventObject.preventDefault() to prevent the event.
     *
     * @param {string} eventName Name of the event being triggered.
     * @param {EventObject} [eventObject] EventObject used as template to construct the actual EventObject used in the event.
     *
     * @returns {EventObject} EventObject passed to the event.
     */
    function triggerPreventable(eventName, eventObject) {
        /**
         * EventObject passed to preventable events
         * @typedef {Object} EventObject
         * @property {Object} emitter Original emitter of the event.
         * @property {boolean} isPrevented Whether the event has been prevented by the event handler.
         * @property {Function} preventDefault Syntax sugar for set the `isPrevented` value.
         */
        var event = _.defaults({}, eventObject || {}, {
            isPrevented: false,
            emitter: this,
            preventDefault: function () {
                this.isPrevented = true;
            }
        });

        this.trigger(eventName, event);
        return event;
    }

    function retriggerPreventable(eventName, eventObject) {
        var groupEvent = this.triggerPreventable(eventName, eventObject);
        if (groupEvent.isPrevented) {
            eventObject.preventDefault();
        }
    }

    _.extend(Marionette.View.prototype, {
        /**
         * This method unwraps the Backbone.View.
         *
         * By default, Backbone will create a <div> and render the template inside. By calling this
         * method, you can get rid of that <div>, so the main element in your template will be the
         * root element in your template.
         */
        unwrapTemplate: function unwrapTemplate() {
            if (this.$el.parent().length) {
                // If the template is already rendered in the page
                var children = this.$el.children();
                this.$el.replaceWith(children);
                this.setElement(children);
            } else {
                // If the template is in memory
                this.setElement(this.$el.children());
            }
        },
        triggerPreventable: triggerPreventable,
        retriggerPreventable: retriggerPreventable
    });

    _.extend(Marionette.Controller.prototype, {
        triggerPreventable: triggerPreventable,
        retriggerPreventable: retriggerPreventable
    });

    Marionette.ViewManager = Marionette.Object.extend({
        constructor: function() {
            //Make sure we initialize the 'views' map first, so descentants
            //of this class can build views in their constructor
            this.views = {};
            Marionette.Controller.apply(this, arguments);
        },

        hideView: function(viewName) {
            var view = this.views[viewName];
            if (view) {
                this.stopListening(view);
                if (!view.isDestroyed) {
                    view.destroy();
                }
                delete this.views[viewName];
            }
        },

        showView: function(viewName, factory) {
            var view = this.buildView(viewName, factory);
            view.render();
        },

        buildView: function(viewName, factory) {
            var view = this.views[viewName];
            if (!view) {
                view = factory.call(this);
                this.listenTo(view, "destroy", function() {
                    this.hideView(viewName);
                });
                this.views[viewName] = view;
            }
            return view;
        },

        getView: function(viewName) {
            return this.views[viewName];
        },

        onDestroy: function() {
            _.each(this.views, function(view, viewName) {
                this.hideView(viewName);
            }, this);
        }
    });


    return Marionette;
});
define("jira/components/lib/marionette-2.1.0", ["jira/components/libs/marionette-2.1.0"], function(M) { "use strict"; return M;});
;
;
/* module-key = 'com.atlassian.plugin.jslibs:backbone.paginator-2.0.2-factory', location = 'factories/backbone.paginator/2.0.2/backbone.paginator-2.0.2-factory.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
    define('atlassian/libs/factories/backbone.paginator-2.0.2', function() {
        return function(_, Backbone) {
            var env = {
                _: _,
                Backbone: Backbone
            };
            factory.call(env);
            var PageableCollection = Backbone.PageableCollection.noConflict();
            PageableCollection.VERSION = "2.0.2";
            return PageableCollection;
        }
    });
})(function(){
/////// End of Atlassian modification ///////

    /*
     backbone.paginator 2.0.2
     http://github.com/backbone-paginator/backbone.paginator

     Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
     Licensed under the MIT @license.
     */

    (function (factory) {
/////////// Modified by Atlassian ///////////
        var root = this;
        var _ = root._;
        var Backbone = root.Backbone;
/////// End of Atlassian modification ///////

        // CommonJS
        if (typeof exports == "object") {
            module.exports = factory(require("underscore"), require("backbone"));
        }
        // AMD
        else if (typeof define == "function" && define.amd) {
            define(["underscore", "backbone"], factory);
        }
        // Browser
        else if (typeof _ !== "undefined" && typeof Backbone !== "undefined") {
            var oldPageableCollection = Backbone.PageableCollection;
            var PageableCollection = factory(_,Backbone);

            /**
             __BROWSER ONLY__

             If you already have an object named `PageableCollection` attached to the
             `Backbone` module, you can use this to return a local reference to this
             Backbone.PageableCollection class and reset the name
             Backbone.PageableCollection to its previous definition.

             // The left hand side gives you a reference to this
             // Backbone.PageableCollection implementation, the right hand side
             // resets Backbone.PageableCollection to your other
             // Backbone.PageableCollection.
             var PageableCollection = Backbone.PageableCollection.noConflict();

             @static
             @member Backbone.PageableCollection
             @return {Backbone.PageableCollection}
             */
            Backbone.PageableCollection.noConflict = function () {
                Backbone.PageableCollection = oldPageableCollection;
                return PageableCollection;
            };
        }

/////////// Modified by Atlassian ///////////
    }).call(this, (function (_, Backbone)
    {
/////// End of Atlassian modification ///////

        "use strict";

        var _extend = _.extend;
        var _omit = _.omit;
        var _clone = _.clone;
        var _each = _.each;
        var _pick = _.pick;
        var _contains = _.contains;
        var _isEmpty = _.isEmpty;
        var _pairs = _.pairs;
        var _invert = _.invert;
        var _isArray = _.isArray;
        var _isFunction = _.isFunction;
        var _isObject = _.isObject;
        var _keys = _.keys;
        var _isUndefined = _.isUndefined;
        var ceil = Math.ceil;
        var floor = Math.floor;
        var max = Math.max;

        var BBColProto = Backbone.Collection.prototype;

        function finiteInt (val, name) {
            if (!_.isNumber(val) || _.isNaN(val) || !_.isFinite(val) || ~~val !== val) {
                throw new TypeError("`" + name + "` must be a finite integer");
            }
            return val;
        }

        function queryStringToParams (qs) {
            var kvp, k, v, ls, params = {}, decode = decodeURIComponent;
            var kvps = qs.split('&');
            for (var i = 0, l = kvps.length; i < l; i++) {
                var param = kvps[i];
                kvp = param.split('='), k = kvp[0], v = kvp[1] || true;
                k = decode(k), v = decode(v), ls = params[k];
                if (_isArray(ls)) ls.push(v);
                else if (ls) params[k] = [ls, v];
                else params[k] = v;
            }
            return params;
        }

        // hack to make sure the whatever event handlers for this event is run
        // before func is, and the event handlers that func will trigger.
        function runOnceAtLastHandler (col, event, func) {
            var eventHandlers = col._events[event];
            if (eventHandlers && eventHandlers.length) {
                var lastHandler = eventHandlers[eventHandlers.length - 1];
                var oldCallback = lastHandler.callback;
                lastHandler.callback = function () {
                    try {
                        oldCallback.apply(this, arguments);
                        func();
                    }
                    catch (e) {
                        throw e;
                    }
                    finally {
                        lastHandler.callback = oldCallback;
                    }
                };
            }
            else func();
        }

        var PARAM_TRIM_RE = /[\s'"]/g;
        var URL_TRIM_RE = /[<>\s'"]/g;

        /**
         Drop-in replacement for Backbone.Collection. Supports server-side and
         client-side pagination and sorting. Client-side mode also support fully
         multi-directional synchronization of changes between pages.

         @class Backbone.PageableCollection
         @extends Backbone.Collection
         */
        var PageableCollection = Backbone.PageableCollection = Backbone.Collection.extend({

            /**
             The container object to store all pagination states.

             You can override the default state by extending this class or specifying
             them in an `options` hash to the constructor.

             @property {Object} state

             @property {0|1} [state.firstPage=1] The first page index. Set to 0 if
             your server API uses 0-based indices. You should only override this value
             during extension, initialization or reset by the server after
             fetching. This value should be read only at other times.

             @property {number} [state.lastPage=null] The last page index. This value
             is __read only__ and it's calculated based on whether `firstPage` is 0 or
             1, during bootstrapping, fetching and resetting. Please don't change this
             value under any circumstances.

             @property {number} [state.currentPage=null] The current page index. You
             should only override this value during extension, initialization or reset
             by the server after fetching. This value should be read only at other
             times. Can be a 0-based or 1-based index, depending on whether
             `firstPage` is 0 or 1. If left as default, it will be set to `firstPage`
             on initialization.

             @property {number} [state.pageSize=25] How many records to show per
             page. This value is __read only__ after initialization, if you want to
             change the page size after initialization, you must call #setPageSize.

             @property {number} [state.totalPages=null] How many pages there are. This
             value is __read only__ and it is calculated from `totalRecords`.

             @property {number} [state.totalRecords=null] How many records there
             are. This value is __required__ under server mode. This value is optional
             for client mode as the number will be the same as the number of models
             during bootstrapping and during fetching, either supplied by the server
             in the metadata, or calculated from the size of the response.

             @property {string} [state.sortKey=null] The model attribute to use for
             sorting.

             @property {-1|0|1} [state.order=-1] The order to use for sorting. Specify
             -1 for ascending order or 1 for descending order. If 0, no client side
             sorting will be done and the order query parameter will not be sent to
             the server during a fetch.
             */
            state: {
                firstPage: 1,
                lastPage: null,
                currentPage: null,
                pageSize: 25,
                totalPages: null,
                totalRecords: null,
                sortKey: null,
                order: -1
            },

            /**
             @property {"server"|"client"|"infinite"} [mode="server"] The mode of
             operations for this collection. `"server"` paginates on the server-side,
             `"client"` paginates on the client-side and `"infinite"` paginates on the
             server-side for APIs that do not support `totalRecords`.
             */
            mode: "server",

            /**
             A translation map to convert Backbone.PageableCollection state attributes
             to the query parameters accepted by your server API.

             You can override the default state by extending this class or specifying
             them in `options.queryParams` object hash to the constructor.

             @property {Object} queryParams
             @property {string} [queryParams.currentPage="page"]
             @property {string} [queryParams.pageSize="per_page"]
             @property {string} [queryParams.totalPages="total_pages"]
             @property {string} [queryParams.totalRecords="total_entries"]
             @property {string} [queryParams.sortKey="sort_by"]
             @property {string} [queryParams.order="order"]
             @property {string} [queryParams.directions={"-1": "asc", "1": "desc"}] A
             map for translating a Backbone.PageableCollection#state.order constant to
             the ones your server API accepts.
             */
            queryParams: {
                currentPage: "page",
                pageSize: "per_page",
                totalPages: "total_pages",
                totalRecords: "total_entries",
                sortKey: "sort_by",
                order: "order",
                directions: {
                    "-1": "asc",
                    "1": "desc"
                }
            },

            /**
             __CLIENT MODE ONLY__

             This collection is the internal storage for the bootstrapped or fetched
             models. You can use this if you want to operate on all the pages.

             @property {Backbone.Collection} fullCollection
             */

            /**
             Given a list of models or model attributues, bootstraps the full
             collection in client mode or infinite mode, or just the page you want in
             server mode.

             If you want to initialize a collection to a different state than the
             default, you can specify them in `options.state`. Any state parameters
             supplied will be merged with the default. If you want to change the
             default mapping from #state keys to your server API's query parameter
             names, you can specifiy an object hash in `option.queryParams`. Likewise,
             any mapping provided will be merged with the default. Lastly, all
             Backbone.Collection constructor options are also accepted.

             See:

             - Backbone.PageableCollection#state
             - Backbone.PageableCollection#queryParams
             - [Backbone.Collection#initialize](http://backbonejs.org/#Collection-constructor)

             @param {Array.<Object>} [models]

             @param {Object} [options]

             @param {function(*, *): number} [options.comparator] If specified, this
             comparator is set to the current page under server mode, or the #fullCollection
             otherwise.

             @param {boolean} [options.full] If `false` and either a
             `options.comparator` or `sortKey` is defined, the comparator is attached
             to the current page. Default is `true` under client or infinite mode and
             the comparator will be attached to the #fullCollection.

             @param {Object} [options.state] The state attributes overriding the defaults.

             @param {string} [options.state.sortKey] The model attribute to use for
             sorting. If specified instead of `options.comparator`, a comparator will
             be automatically created using this value, and optionally a sorting order
             specified in `options.state.order`. The comparator is then attached to
             the new collection instance.

             @param {-1|1} [options.state.order] The order to use for sorting. Specify
             -1 for ascending order and 1 for descending order.

             @param {Object} [options.queryParam]
             */
            constructor: function (models, options) {

                BBColProto.constructor.apply(this, arguments);

                options = options || {};

                var mode = this.mode = options.mode || this.mode || PageableProto.mode;

                var queryParams = _extend({}, PageableProto.queryParams, this.queryParams,
                                options.queryParams || {});

                queryParams.directions = _extend({},
                        PageableProto.queryParams.directions,
                        this.queryParams.directions,
                                queryParams.directions || {});

                this.queryParams = queryParams;

                var state = this.state = _extend({}, PageableProto.state, this.state,
                                options.state || {});

                state.currentPage = state.currentPage == null ?
                        state.firstPage :
                        state.currentPage;

                if (!_isArray(models)) models = models ? [models] : [];
                models = models.slice();

                if (mode != "server" && state.totalRecords == null && !_isEmpty(models)) {
                    state.totalRecords = models.length;
                }

                this.switchMode(mode, _extend({fetch: false,
                    resetState: false,
                    models: models}, options));

                var comparator = options.comparator;

                if (state.sortKey && !comparator) {
                    this.setSorting(state.sortKey, state.order, options);
                }

                if (mode != "server") {
                    var fullCollection = this.fullCollection;

                    if (comparator && options.full) {
                        this.comparator = null;
                        fullCollection.comparator = comparator;
                    }

                    if (options.full) fullCollection.sort();

                    // make sure the models in the current page and full collection have the
                    // same references
                    if (models && !_isEmpty(models)) {
                        this.reset(models, _extend({silent: true}, options));
                        this.getPage(state.currentPage);
                        models.splice.apply(models, [0, models.length].concat(this.models));
                    }
                }

                this._initState = _clone(this.state);
            },

            /**
             Makes a Backbone.Collection that contains all the pages.

             @private
             @param {Array.<Object|Backbone.Model>} models
             @param {Object} options Options for Backbone.Collection constructor.
             @return {Backbone.Collection}
             */
            _makeFullCollection: function (models, options) {

                var properties = ["url", "model", "sync", "comparator"];
                var thisProto = this.constructor.prototype;
                var i, length, prop;

                var proto = {};
                for (i = 0, length = properties.length; i < length; i++) {
                    prop = properties[i];
                    if (!_isUndefined(thisProto[prop])) {
                        proto[prop] = thisProto[prop];
                    }
                }

                var fullCollection = new (Backbone.Collection.extend(proto))(models, options);

                for (i = 0, length = properties.length; i < length; i++) {
                    prop = properties[i];
                    if (this[prop] !== thisProto[prop]) {
                        fullCollection[prop] = this[prop];
                    }
                }

                return fullCollection;
            },

            /**
             Factory method that returns a Backbone event handler that responses to
             the `add`, `remove`, `reset`, and the `sort` events. The returned event
             handler will synchronize the current page collection and the full
             collection's models.

             @private

             @param {Backbone.PageableCollection} pageCol
             @param {Backbone.Collection} fullCol

             @return {function(string, Backbone.Model, Backbone.Collection, Object)}
             Collection event handler
             */
            _makeCollectionEventHandler: function (pageCol, fullCol) {

                return function collectionEventHandler (event, model, collection, options) {

                    var handlers = pageCol._handlers;
                    _each(_keys(handlers), function (event) {
                        var handler = handlers[event];
                        pageCol.off(event, handler);
                        fullCol.off(event, handler);
                    });

                    var state = _clone(pageCol.state);
                    var firstPage = state.firstPage;
                    var currentPage = firstPage === 0 ?
                            state.currentPage :
                            state.currentPage - 1;
                    var pageSize = state.pageSize;
                    var pageStart = currentPage * pageSize, pageEnd = pageStart + pageSize;

                    if (event == "add") {
                        var pageIndex, fullIndex, addAt, colToAdd, options = options || {};
                        if (collection == fullCol) {
                            fullIndex = fullCol.indexOf(model);
                            if (fullIndex >= pageStart && fullIndex < pageEnd) {
                                colToAdd = pageCol;
                                pageIndex = addAt = fullIndex - pageStart;
                            }
                        }
                        else {
                            pageIndex = pageCol.indexOf(model);
                            fullIndex = pageStart + pageIndex;
                            colToAdd = fullCol;
                            var addAt = !_isUndefined(options.at) ?
                                    options.at + pageStart :
                                    fullIndex;
                        }

                        if (!options.onRemove) {
                            ++state.totalRecords;
                            delete options.onRemove;
                        }

                        pageCol.state = pageCol._checkState(state);

                        if (colToAdd) {
                            colToAdd.add(model, _extend({}, options || {}, {at: addAt}));
                            var modelToRemove = pageIndex >= pageSize ?
                                    model :
                                            !_isUndefined(options.at) && addAt < pageEnd && pageCol.length > pageSize ?
                                    pageCol.at(pageSize) :
                                    null;
                            if (modelToRemove) {
                                runOnceAtLastHandler(collection, event, function () {
                                    pageCol.remove(modelToRemove, {onAdd: true});
                                });
                            }
                        }
                    }

                    // remove the model from the other collection as well
                    if (event == "remove") {
                        if (!options.onAdd) {
                            // decrement totalRecords and update totalPages and lastPage
                            if (!--state.totalRecords) {
                                state.totalRecords = null;
                                state.totalPages = null;
                            }
                            else {
                                var totalPages = state.totalPages = ceil(state.totalRecords / pageSize);
                                state.lastPage = firstPage === 0 ? totalPages - 1 : totalPages || firstPage;
                                if (state.currentPage > totalPages) state.currentPage = state.lastPage;
                            }
                            pageCol.state = pageCol._checkState(state);

                            var nextModel, removedIndex = options.index;
                            if (collection == pageCol) {
                                if (nextModel = fullCol.at(pageEnd)) {
                                    runOnceAtLastHandler(pageCol, event, function () {
                                        pageCol.push(nextModel, {onRemove: true});
                                    });
                                }
                                else if (!pageCol.length && state.totalRecords) {
                                    pageCol.reset(fullCol.models.slice(pageStart - pageSize, pageEnd - pageSize),
                                            _extend({}, options, {parse: false}));
                                }
                                fullCol.remove(model);
                            }
                            else if (removedIndex >= pageStart && removedIndex < pageEnd) {
                                if (nextModel = fullCol.at(pageEnd - 1)) {
                                    runOnceAtLastHandler(pageCol, event, function() {
                                        pageCol.push(nextModel, {onRemove: true});
                                    });
                                }
                                pageCol.remove(model);
                                if (!pageCol.length && state.totalRecords) {
                                    pageCol.reset(fullCol.models.slice(pageStart - pageSize, pageEnd - pageSize),
                                            _extend({}, options, {parse: false}));
                                }
                            }
                        }
                        else delete options.onAdd;
                    }

                    if (event == "reset") {
                        options = collection;
                        collection = model;

                        // Reset that's not a result of getPage
                        if (collection == pageCol && options.from == null &&
                                options.to == null) {
                            var head = fullCol.models.slice(0, pageStart);
                            var tail = fullCol.models.slice(pageStart + pageCol.models.length);
                            fullCol.reset(head.concat(pageCol.models).concat(tail), options);
                        }
                        else if (collection == fullCol) {
                            if (!(state.totalRecords = fullCol.models.length)) {
                                state.totalRecords = null;
                                state.totalPages = null;
                            }
                            if (pageCol.mode == "client") {
                                state.lastPage = state.currentPage = state.firstPage;
                            }
                            pageCol.state = pageCol._checkState(state);
                            pageCol.reset(fullCol.models.slice(pageStart, pageEnd),
                                    _extend({}, options, {parse: false}));
                        }
                    }

                    if (event == "sort") {
                        options = collection;
                        collection = model;
                        if (collection === fullCol) {
                            pageCol.reset(fullCol.models.slice(pageStart, pageEnd),
                                    _extend({}, options, {parse: false}));
                        }
                    }

                    _each(_keys(handlers), function (event) {
                        var handler = handlers[event];
                        _each([pageCol, fullCol], function (col) {
                            col.on(event, handler);
                            var callbacks = col._events[event] || [];
                            callbacks.unshift(callbacks.pop());
                        });
                    });
                };
            },

            /**
             Sanity check this collection's pagination states. Only perform checks
             when all the required pagination state values are defined and not null.
             If `totalPages` is undefined or null, it is set to `totalRecords` /
             `pageSize`. `lastPage` is set according to whether `firstPage` is 0 or 1
             when no error occurs.

             @private

             @throws {TypeError} If `totalRecords`, `pageSize`, `currentPage` or
             `firstPage` is not a finite integer.

             @throws {RangeError} If `pageSize`, `currentPage` or `firstPage` is out
             of bounds.

             @return {Object} Returns the `state` object if no error was found.
             */
            _checkState: function (state) {

                var mode = this.mode;
                var links = this.links;
                var totalRecords = state.totalRecords;
                var pageSize = state.pageSize;
                var currentPage = state.currentPage;
                var firstPage = state.firstPage;
                var totalPages = state.totalPages;

                if (totalRecords != null && pageSize != null && currentPage != null &&
                        firstPage != null && (mode == "infinite" ? links : true)) {

                    totalRecords = finiteInt(totalRecords, "totalRecords");
                    pageSize = finiteInt(pageSize, "pageSize");
                    currentPage = finiteInt(currentPage, "currentPage");
                    firstPage = finiteInt(firstPage, "firstPage");

                    if (pageSize < 1) {
                        throw new RangeError("`pageSize` must be >= 1");
                    }

                    totalPages = state.totalPages = ceil(totalRecords / pageSize);

                    if (firstPage < 0 || firstPage > 1) {
                        throw new RangeError("`firstPage must be 0 or 1`");
                    }

                    state.lastPage = firstPage === 0 ? max(0, totalPages - 1) : totalPages || firstPage;

                    if (mode == "infinite") {
                        if (!links[currentPage + '']) {
                            throw new RangeError("No link found for page " + currentPage);
                        }
                    }
                    else if (currentPage < firstPage ||
                            (totalPages > 0 &&
                                    (firstPage ? currentPage > totalPages : currentPage >= totalPages))) {
                        throw new RangeError("`currentPage` must be firstPage <= currentPage " +
                                (firstPage ? ">" : ">=") +
                                " totalPages if " + firstPage + "-based. Got " +
                                currentPage + '.');
                    }
                }

                return state;
            },

            /**
             Change the page size of this collection.

             Under most if not all circumstances, you should call this method to
             change the page size of a pageable collection because it will keep the
             pagination state sane. By default, the method will recalculate the
             current page number to one that will retain the current page's models
             when increasing the page size. When decreasing the page size, this method
             will retain the last models to the current page that will fit into the
             smaller page size.

             If `options.first` is true, changing the page size will also reset the
             current page back to the first page instead of trying to be smart.

             For server mode operations, changing the page size will trigger a #fetch
             and subsequently a `reset` event.

             For client mode operations, changing the page size will `reset` the
             current page by recalculating the current page boundary on the client
             side.

             If `options.fetch` is true, a fetch can be forced if the collection is in
             client mode.

             @param {number} pageSize The new page size to set to #state.
             @param {Object} [options] {@link #fetch} options.
             @param {boolean} [options.first=false] Reset the current page number to
             the first page if `true`.
             @param {boolean} [options.fetch] If `true`, force a fetch in client mode.

             @throws {TypeError} If `pageSize` is not a finite integer.
             @throws {RangeError} If `pageSize` is less than 1.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            setPageSize: function (pageSize, options) {
                pageSize = finiteInt(pageSize, "pageSize");

                options = options || {first: false};

                var state = this.state;
                var totalPages = ceil(state.totalRecords / pageSize);
                var currentPage = totalPages ?
                        max(state.firstPage, floor(totalPages * state.currentPage / state.totalPages)) :
                        state.firstPage;

                state = this.state = this._checkState(_extend({}, state, {
                    pageSize: pageSize,
                    currentPage: options.first ? state.firstPage : currentPage,
                    totalPages: totalPages
                }));

                return this.getPage(state.currentPage, _omit(options, ["first"]));
            },

            /**
             Switching between client, server and infinite mode.

             If switching from client to server mode, the #fullCollection is emptied
             first and then deleted and a fetch is immediately issued for the current
             page from the server. Pass `false` to `options.fetch` to skip fetching.

             If switching to infinite mode, and if `options.models` is given for an
             array of models, #links will be populated with a URL per page, using the
             default URL for this collection.

             If switching from server to client mode, all of the pages are immediately
             refetched. If you have too many pages, you can pass `false` to
             `options.fetch` to skip fetching.

             If switching to any mode from infinite mode, the #links will be deleted.

             @param {"server"|"client"|"infinite"} [mode] The mode to switch to.

             @param {Object} [options]

             @param {boolean} [options.fetch=true] If `false`, no fetching is done.

             @param {boolean} [options.resetState=true] If 'false', the state is not
             reset, but checked for sanity instead.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this if `options.fetch` is `false`.
             */
            switchMode: function (mode, options) {

                if (!_contains(["server", "client", "infinite"], mode)) {
                    throw new TypeError('`mode` must be one of "server", "client" or "infinite"');
                }

                options = options || {fetch: true, resetState: true};

                var state = this.state = options.resetState ?
                        _clone(this._initState) :
                        this._checkState(_extend({}, this.state));

                this.mode = mode;

                var self = this;
                var fullCollection = this.fullCollection;
                var handlers = this._handlers = this._handlers || {}, handler;
                if (mode != "server" && !fullCollection) {
                    fullCollection = this._makeFullCollection(options.models || [], options);
                    fullCollection.pageableCollection = this;
                    this.fullCollection = fullCollection;
                    var allHandler = this._makeCollectionEventHandler(this, fullCollection);
                    _each(["add", "remove", "reset", "sort"], function (event) {
                        handlers[event] = handler = _.bind(allHandler, {}, event);
                        self.on(event, handler);
                        fullCollection.on(event, handler);
                    });
                    fullCollection.comparator = this._fullComparator;
                }
                else if (mode == "server" && fullCollection) {
                    _each(_keys(handlers), function (event) {
                        handler = handlers[event];
                        self.off(event, handler);
                        fullCollection.off(event, handler);
                    });
                    delete this._handlers;
                    this._fullComparator = fullCollection.comparator;
                    delete this.fullCollection;
                }

                if (mode == "infinite") {
                    var links = this.links = {};
                    var firstPage = state.firstPage;
                    var totalPages = ceil(state.totalRecords / state.pageSize);
                    var lastPage = firstPage === 0 ? max(0, totalPages - 1) : totalPages || firstPage;
                    for (var i = state.firstPage; i <= lastPage; i++) {
                        links[i] = this.url;
                    }
                }
                else if (this.links) delete this.links;

                return options.fetch ?
                        this.fetch(_omit(options, "fetch", "resetState")) :
                        this;
            },

            /**
             @return {boolean} `true` if this collection can page backward, `false`
             otherwise.
             */
            hasPreviousPage: function () {
                var state = this.state;
                var currentPage = state.currentPage;
                if (this.mode != "infinite") return currentPage > state.firstPage;
                return !!this.links[currentPage - 1];
            },

            /**
             @return {boolean} `true` if this collection can page forward, `false`
             otherwise.
             */
            hasNextPage: function () {
                var state = this.state;
                var currentPage = this.state.currentPage;
                if (this.mode != "infinite") return currentPage < state.lastPage;
                return !!this.links[currentPage + 1];
            },

            /**
             Fetch the first page in server mode, or reset the current page of this
             collection to the first page in client or infinite mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getFirstPage: function (options) {
                return this.getPage("first", options);
            },

            /**
             Fetch the previous page in server mode, or reset the current page of this
             collection to the previous page in client or infinite mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getPreviousPage: function (options) {
                return this.getPage("prev", options);
            },

            /**
             Fetch the next page in server mode, or reset the current page of this
             collection to the next page in client mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getNextPage: function (options) {
                return this.getPage("next", options);
            },

            /**
             Fetch the last page in server mode, or reset the current page of this
             collection to the last page in client mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getLastPage: function (options) {
                return this.getPage("last", options);
            },

            /**
             Given a page index, set #state.currentPage to that index. If this
             collection is in server mode, fetch the page using the updated state,
             otherwise, reset the current page of this collection to the page
             specified by `index` in client mode. If `options.fetch` is true, a fetch
             can be forced in client mode before resetting the current page. Under
             infinite mode, if the index is less than the current page, a reset is
             done as in client mode. If the index is greater than the current page
             number, a fetch is made with the results **appended** to #fullCollection.
             The current page will then be reset after fetching.

             @param {number|string} index The page index to go to, or the page name to
             look up from #links in infinite mode.
             @param {Object} [options] {@link #fetch} options or
             [reset](http://backbonejs.org/#Collection-reset) options for client mode
             when `options.fetch` is `false`.
             @param {boolean} [options.fetch=false] If true, force a {@link #fetch} in
             client mode.

             @throws {TypeError} If `index` is not a finite integer under server or
             client mode, or does not yield a URL from #links under infinite mode.

             @throws {RangeError} If `index` is out of bounds.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getPage: function (index, options) {

                var mode = this.mode, fullCollection = this.fullCollection;

                options = options || {fetch: false};

                var state = this.state,
                        firstPage = state.firstPage,
                        currentPage = state.currentPage,
                        lastPage = state.lastPage,
                        pageSize = state.pageSize;

                var pageNum = index;
                switch (index) {
                    case "first": pageNum = firstPage; break;
                    case "prev": pageNum = currentPage - 1; break;
                    case "next": pageNum = currentPage + 1; break;
                    case "last": pageNum = lastPage; break;
                    default: pageNum = finiteInt(index, "index");
                }

                this.state = this._checkState(_extend({}, state, {currentPage: pageNum}));

                options.from = currentPage, options.to = pageNum;

                var pageStart = (firstPage === 0 ? pageNum : pageNum - 1) * pageSize;
                var pageModels = fullCollection && fullCollection.length ?
                        fullCollection.models.slice(pageStart, pageStart + pageSize) :
                        [];
                if ((mode == "client" || (mode == "infinite" && !_isEmpty(pageModels))) &&
                        !options.fetch) {
                    this.reset(pageModels, _omit(options, "fetch"));
                    return this;
                }

                if (mode == "infinite") options.url = this.links[pageNum];

                return this.fetch(_omit(options, "fetch"));
            },

            /**
             Fetch the page for the provided item offset in server mode, or reset the current page of this
             collection to the page for the provided item offset in client mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getPageByOffset: function (offset, options) {
                if (offset < 0) {
                    throw new RangeError("`offset must be > 0`");
                }
                offset = finiteInt(offset);

                var page = floor(offset / this.state.pageSize);
                if (this.state.firstPage !== 0) page++;
                if (page > this.state.lastPage) page = this.state.lastPage;
                return this.getPage(page, options);
            },

            /**
             Overidden to make `getPage` compatible with Zepto.

             @param {string} method
             @param {Backbone.Model|Backbone.Collection} model
             @param {Object} [options]

             @return {XMLHttpRequest}
             */
            sync: function (method, model, options) {
                var self = this;
                if (self.mode == "infinite") {
                    var success = options.success;
                    var currentPage = self.state.currentPage;
                    options.success = function (resp, status, xhr) {
                        var links = self.links;
                        var newLinks = self.parseLinks(resp, _extend({xhr: xhr}, options));
                        if (newLinks.first) links[self.state.firstPage] = newLinks.first;
                        if (newLinks.prev) links[currentPage - 1] = newLinks.prev;
                        if (newLinks.next) links[currentPage + 1] = newLinks.next;
                        if (success) success(resp, status, xhr);
                    };
                }

                return (BBColProto.sync || Backbone.sync).call(self, method, model, options);
            },

            /**
             Parse pagination links from the server response. Only valid under
             infinite mode.

             Given a response body and a XMLHttpRequest object, extract pagination
             links from them for infinite paging.

             This default implementation parses the RFC 5988 `Link` header and extract
             3 links from it - `first`, `prev`, `next`. Any subclasses overriding this
             method __must__ return an object hash having only the keys
             above. However, simply returning a `next` link or an empty hash if there
             are no more links should be enough for most implementations.

             @param {*} resp The deserialized response body.
             @param {Object} [options]
             @param {XMLHttpRequest} [options.xhr] The XMLHttpRequest object for this
             response.
             @return {Object}
             */
            parseLinks: function (resp, options) {
                var links = {};
                var linkHeader = options.xhr.getResponseHeader("Link");
                if (linkHeader) {
                    var relations = ["first", "prev", "next"];
                    _each(linkHeader.split(","), function (linkValue) {
                        var linkParts = linkValue.split(";");
                        var url = linkParts[0].replace(URL_TRIM_RE, '');
                        var params = linkParts.slice(1);
                        _each(params, function (param) {
                            var paramParts = param.split("=");
                            var key = paramParts[0].replace(PARAM_TRIM_RE, '');
                            var value = paramParts[1].replace(PARAM_TRIM_RE, '');
                            if (key == "rel" && _contains(relations, value)) links[value] = url;
                        });
                    });
                }

                return links;
            },

            /**
             Parse server response data.

             This default implementation assumes the response data is in one of two
             structures:

             [
             {}, // Your new pagination state
             [{}, ...] // An array of JSON objects
             ]

             Or,

             [{}] // An array of JSON objects

             The first structure is the preferred form because the pagination states
             may have been updated on the server side, sending them down again allows
             this collection to update its states. If the response has a pagination
             state object, it is checked for errors.

             The second structure is the
             [Backbone.Collection#parse](http://backbonejs.org/#Collection-parse)
             default.

             **Note:** this method has been further simplified since 1.1.7. While
             existing #parse implementations will continue to work, new code is
             encouraged to override #parseState and #parseRecords instead.

             @param {Object} resp The deserialized response data from the server.
             @param {Object} the options for the ajax request

             @return {Array.<Object>} An array of model objects
             */
            parse: function (resp, options) {
                var newState = this.parseState(resp, _clone(this.queryParams), _clone(this.state), options);
                if (newState) this.state = this._checkState(_extend({}, this.state, newState));
                return this.parseRecords(resp, options);
            },

            /**
             Parse server response for server pagination state updates. Not applicable
             under infinite mode.

             This default implementation first checks whether the response has any
             state object as documented in #parse. If it exists, a state object is
             returned by mapping the server state keys to this pageable collection
             instance's query parameter keys using `queryParams`.

             It is __NOT__ neccessary to return a full state object complete with all
             the mappings defined in #queryParams. Any state object resulted is merged
             with a copy of the current pageable collection state and checked for
             sanity before actually updating. Most of the time, simply providing a new
             `totalRecords` value is enough to trigger a full pagination state
             recalculation.

             parseState: function (resp, queryParams, state, options) {
                 return {totalRecords: resp.total_entries};
               }

             If you want to use header fields use:

             parseState: function (resp, queryParams, state, options) {
                   return {totalRecords: options.xhr.getResponseHeader("X-total")};
               }

             This method __MUST__ return a new state object instead of directly
             modifying the #state object. The behavior of directly modifying #state is
             undefined.

             @param {Object} resp The deserialized response data from the server.
             @param {Object} queryParams A copy of #queryParams.
             @param {Object} state A copy of #state.
             @param {Object} [options] The options passed through from
             `parse`. (backbone >= 0.9.10 only)

             @return {Object} A new (partial) state object.
             */
            parseState: function (resp, queryParams, state, options) {
                if (resp && resp.length === 2 && _isObject(resp[0]) && _isArray(resp[1])) {

                    var newState = _clone(state);
                    var serverState = resp[0];

                    _each(_pairs(_omit(queryParams, "directions")), function (kvp) {
                        var k = kvp[0], v = kvp[1];
                        var serverVal = serverState[v];
                        if (!_isUndefined(serverVal) && !_.isNull(serverVal)) newState[k] = serverState[v];
                    });

                    if (serverState.order) {
                        newState.order = _invert(queryParams.directions)[serverState.order] * 1;
                    }

                    return newState;
                }
            },

            /**
             Parse server response for an array of model objects.

             This default implementation first checks whether the response has any
             state object as documented in #parse. If it exists, the array of model
             objects is assumed to be the second element, otherwise the entire
             response is returned directly.

             @param {Object} resp The deserialized response data from the server.
             @param {Object} [options] The options passed through from the
             `parse`. (backbone >= 0.9.10 only)

             @return {Array.<Object>} An array of model objects
             */
            parseRecords: function (resp, options) {
                if (resp && resp.length === 2 && _isObject(resp[0]) && _isArray(resp[1])) {
                    return resp[1];
                }

                return resp;
            },

            /**
             Fetch a page from the server in server mode, or all the pages in client
             mode. Under infinite mode, the current page is refetched by default and
             then reset.

             The query string is constructed by translating the current pagination
             state to your server API query parameter using #queryParams. The current
             page will reset after fetch.

             @param {Object} [options] Accepts all
             [Backbone.Collection#fetch](http://backbonejs.org/#Collection-fetch)
             options.

             @return {XMLHttpRequest}
             */
            fetch: function (options) {

                options = options || {};

                var state = this._checkState(this.state);

                var mode = this.mode;

                if (mode == "infinite" && !options.url) {
                    options.url = this.links[state.currentPage];
                }

                var data = options.data || {};

                // dedup query params
                var url = options.url || this.url || "";
                if (_isFunction(url)) url = url.call(this);
                var qsi = url.indexOf('?');
                if (qsi != -1) {
                    _extend(data, queryStringToParams(url.slice(qsi + 1)));
                    url = url.slice(0, qsi);
                }

                options.url = url;
                options.data = data;

                // map params except directions
                var queryParams = this.mode == "client" ?
                        _pick(this.queryParams, "sortKey", "order") :
                        _omit(_pick(this.queryParams, _keys(PageableProto.queryParams)),
                                "directions");

                var i, kvp, k, v, kvps = _pairs(queryParams), thisCopy = _clone(this);
                for (i = 0; i < kvps.length; i++) {
                    kvp = kvps[i], k = kvp[0], v = kvp[1];
                    v = _isFunction(v) ? v.call(thisCopy) : v;
                    if (state[k] != null && v != null) {
                        data[v] = state[k];
                    }
                }

                // fix up sorting parameters
                if (state.sortKey && state.order) {
                    var o = _isFunction(queryParams.order) ?
                            queryParams.order.call(thisCopy) :
                            queryParams.order;
                    data[o] = this.queryParams.directions[state.order + ""];
                }
                else if (!state.sortKey) delete data[queryParams.order];

                // map extra query parameters
                var extraKvps = _pairs(_omit(this.queryParams,
                        _keys(PageableProto.queryParams)));
                for (i = 0; i < extraKvps.length; i++) {
                    kvp = extraKvps[i];
                    v = kvp[1];
                    v = _isFunction(v) ? v.call(thisCopy) : v;
                    if (v != null) data[kvp[0]] = v;
                }

                if (mode != "server") {
                    var self = this, fullCol = this.fullCollection;
                    var success = options.success;
                    options.success = function (col, resp, opts) {

                        // make sure the caller's intent is obeyed
                        opts = opts || {};
                        if (_isUndefined(options.silent)) delete opts.silent;
                        else opts.silent = options.silent;

                        var models = col.models;
                        if (mode == "client") fullCol.reset(models, opts);
                        else {
                            fullCol.add(models, _extend({at: fullCol.length},
                                    _extend(opts, {parse: false})));
                            self.trigger("reset", self, opts);
                        }

                        if (success) success(col, resp, opts);
                    };

                    // silent the first reset from backbone
                    return BBColProto.fetch.call(this, _extend({}, options, {silent: true}));
                }

                return BBColProto.fetch.call(this, options);
            },

            /**
             Convenient method for making a `comparator` sorted by a model attribute
             identified by `sortKey` and ordered by `order`.

             Like a Backbone.Collection, a Backbone.PageableCollection will maintain
             the __current page__ in sorted order on the client side if a `comparator`
             is attached to it. If the collection is in client mode, you can attach a
             comparator to #fullCollection to have all the pages reflect the global
             sorting order by specifying an option `full` to `true`. You __must__ call
             `sort` manually or #fullCollection.sort after calling this method to
             force a resort.

             While you can use this method to sort the current page in server mode,
             the sorting order may not reflect the global sorting order due to the
             additions or removals of the records on the server since the last
             fetch. If you want the most updated page in a global sorting order, it is
             recommended that you set #state.sortKey and optionally #state.order, and
             then call #fetch.

             @protected

             @param {string} [sortKey=this.state.sortKey] See `state.sortKey`.
             @param {number} [order=this.state.order] See `state.order`.
             @param {(function(Backbone.Model, string): Object) | string} [sortValue] See #setSorting.

             See [Backbone.Collection.comparator](http://backbonejs.org/#Collection-comparator).
             */
            _makeComparator: function (sortKey, order, sortValue) {
                var state = this.state;

                sortKey = sortKey || state.sortKey;
                order = order || state.order;

                if (!sortKey || !order) return;

                if (!sortValue) sortValue = function (model, attr) {
                    return model.get(attr);
                };

                return function (left, right) {
                    var l = sortValue(left, sortKey), r = sortValue(right, sortKey), t;
                    if (order === 1) t = l, l = r, r = t;
                    if (l === r) return 0;
                    else if (l < r) return -1;
                    return 1;
                };
            },

            /**
             Adjusts the sorting for this pageable collection.

             Given a `sortKey` and an `order`, sets `state.sortKey` and
             `state.order`. A comparator can be applied on the client side to sort in
             the order defined if `options.side` is `"client"`. By default the
             comparator is applied to the #fullCollection. Set `options.full` to
             `false` to apply a comparator to the current page under any mode. Setting
             `sortKey` to `null` removes the comparator from both the current page and
             the full collection.

             If a `sortValue` function is given, it will be passed the `(model,
             sortKey)` arguments and is used to extract a value from the model during
             comparison sorts. If `sortValue` is not given, `model.get(sortKey)` is
             used for sorting.

             @chainable

             @param {string} sortKey See `state.sortKey`.
             @param {number} [order=this.state.order] See `state.order`.
             @param {Object} [options]
             @param {"server"|"client"} [options.side] By default, `"client"` if
             `mode` is `"client"`, `"server"` otherwise.
             @param {boolean} [options.full=true]
             @param {(function(Backbone.Model, string): Object) | string} [options.sortValue]
             */
            setSorting: function (sortKey, order, options) {

                var state = this.state;

                state.sortKey = sortKey;
                state.order = order = order || state.order;

                var fullCollection = this.fullCollection;

                var delComp = false, delFullComp = false;

                if (!sortKey) delComp = delFullComp = true;

                var mode = this.mode;
                options = _extend({side: mode == "client" ? mode : "server", full: true},
                        options);

                var comparator = this._makeComparator(sortKey, order, options.sortValue);

                var full = options.full, side = options.side;

                if (side == "client") {
                    if (full) {
                        if (fullCollection) fullCollection.comparator = comparator;
                        delComp = true;
                    }
                    else {
                        this.comparator = comparator;
                        delFullComp = true;
                    }
                }
                else if (side == "server" && !full) {
                    this.comparator = comparator;
                }

                if (delComp) this.comparator = null;
                if (delFullComp && fullCollection) fullCollection.comparator = null;

                return this;
            }

        });

        var PageableProto = PageableCollection.prototype;

        return PageableCollection;

/////////// Modified by Atlassian ///////////
    }));

});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:backbone.paginator', location = 'libs/backbone.paginator.js' */
define("jira/components/libs/backbone.paginator", [
    "atlassian/libs/factories/backbone.paginator-2.0.2",
    "jira/components/libs/backbone",
    "jira/components/libs/underscore"
], function(
    backbonePaginatorFactory,
    Backbone,
    _
) {
    "use strict";

    return backbonePaginatorFactory(_, Backbone);
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:search', location = 'search/Search.js' */
define("jira/components/search", [
    "jira/components/libs/backbone",
    "jira/components/libs/underscore",
    "jquery",
    "jira/components/search/results",
    "jira/components/search/latestStorage"
], function (
    Backbone,
    _,
    jQuery,
    Results,
    LatestSearchStore
) {
    "use strict";

    /**
     * This class contains the model for a Search. A Search is a collection of issues as a result
     * of running a JQL in the server. This entity is not meant to be used directly by any view.
     * Instead, this entity will generate a SearchResults entity that contains the stable search.
     *
     * All operations performed in this entity will result in a new set of results
     * (aka un-stable search).
     */
    return Backbone.Collection.extend({
        url: function () {
            return AJS.contextPath() + "/rest/issueNav/1/issueTable";
        },

        searchParams: {
            jql: "",
            filterId: null,
            columnConfig: "explicit",
            columns: [],
            layoutKey: "split-view",
            startIndex: 0
        },

        sync: function () {
            var args = _.toArray(arguments);
            var params = args[2];

            params.type = "POST";
            params.headers = {
                "X-Atlassian-Token": "no-check"
            };

            // Add our search data.
            params.data = {};
            _.each(_.keys(this.searchParams), function (key) {
                if (this.searchParams[key] !== null) {
                    params.data[key] = this.searchParams[key];
                }
            }, this);

            return Backbone.Collection.prototype.sync.apply(this, args);
        },

        parse: function (resp) {
            // Clean the data
            var data = resp && resp.issueTable;
            if (!data || !data.issueIds) {
                return [];
            }

            // Extract all the issues from the first search.
            return _.map(data.issueIds, function (id, index) { return {id: id, key: data.issueKeys[index]}; });
        },

        update: function(response) {
            this.set(this.parse(response));
        },

        /**
         * @param preloadedData expects an object like { jql: "..jql used..", response: {..ajax response..} }
         */
        setPreloadedData: function(preloadedData) {
            this.preloadedData = preloadedData;
        },

        parseResults: function(jql, response) {
            return new Results([], {
                issues: this.toJSON(),
                pageSize: response.issueTable.pageSize,
                totalRecordsInDB: response.issueTable.total,
                totalRecordsInSearch: this.length,
                jql: jql
            });
        },

        search: function (jql) {
            this.searchParams.jql = jql;

            var deferred = new jQuery.Deferred();

            if (this.preloadedData && this.preloadedData.jql === jql) {
                this.reset(this.preloadedData.response, { parse: true });
                deferred.resolve(this.parseResults(jql, this.preloadedData.response));
                delete this.preloadedData;
            } else {
                this.fetch({
                    reset: true,
                    success: _.bind(function (collection, response) {
                        deferred.resolve(this.parseResults(collection.searchParams.jql, response));
                    }, this),
                    error: function (collection, response) {
                        deferred.reject(response);
                    }
                });
            }

            deferred.done(function(results){
                LatestSearchStore.save({jql: results.jql});
            });

            return deferred.promise();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:search', location = 'search/SearchResult.js' */
define("jira/components/search/result", [
    "jira/components/libs/backbone"
], function (
    Backbone
) {
    "use strict";
    return Backbone.Model.extend({
        initialize: function () {
            // We need to create url function inside the initialize method because when combining
            // Backbone 1.0.0 and PageableCollection, it will pass its own URL when creating models,
            // making all the models have the same URL than the collection (duh). This has been fixed
            // in Backbone 1.1.0
            this.url = function () {
                return AJS.contextPath() + "/rest/api/2/issue/" + this.id + "?fields=summary,status,issuetype";
            };
        },

        parse: function (data) {
            // Backbone will call this method two times:
            // 1. When the SearchResults is initially created with a specific page.
            // 2. When updating an issue after a successful inline edit.

            var result = {};

            if (!data.inaccessible) {
                result.id = parseInt(data.id, 10);
                result.key = data.key;

                if (data.fields) {
                    // This comes from inline edit.
                    result.summary = data.fields.summary;
                    result.status = data.fields.status.name;
                    result.type = {
                        description: data.fields.issuetype.description,
                        iconUrl: data.fields.issuetype.iconUrl,
                        name: data.fields.issuetype.name
                    };
                } else {
                    // This comes from fetching a page
                    result.status = data.status;
                    result.summary = data.summary;
                    result.type = data.type;
                }
            } else {
                result.id = parseInt(data.id, 10);
                result.key = data.key;
                result.inaccessible = true;
            }

            return result;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:search', location = 'search/SearchResults.js' */
define("jira/components/search/results", [
    "jira/components/libs/backbone",
    "jira/components/libs/backbone.paginator",
    "jira/components/libs/underscore",
    "jquery",
    "jira/components/search/result"
], function (
    Backbone,
    PageableCollection,
    _,
    jQuery,
    Result
) {
    "use strict";

    var Results = PageableCollection.extend({
        initialize: function (models, options) {
            options = options || {};
            this.allIssues = options.issues;
            this.state.pageSize = options.pageSize;
            this.state.totalRecords = options.totalRecordsInSearch;
            this.totalRecordsInDB = options.totalRecordsInDB;
            this.allowNoSelection = options.allowNoSelection;
            this.jql = options.jql;
        },

        model: Result,

        url: function () {
            return AJS.contextPath() + "/rest/issueNav/1/issueTable/stable";
        },

        // Initial pagination states
        state: {
            firstPage: 0,
            currentPage: 0
        },

        queryParams: {
            currentPage: null,
            pageSize: null,
            totalPages: null,
            totalRecords: null,
            sortKey: null,
            directions: null
        },

        sync: function () {
            var args = _.toArray(arguments);
            var params = args[2];

            params.type = "POST";
            params.headers = {
                "X-Atlassian-Token": "no-check"
            };
            params.data.layoutKey = "split-view";
            params.data.id = this._getStableKeys();

            return PageableCollection.prototype.sync.apply(this, args);
        },

        isAtTheEndOfStableSearch: function () {
            var isLastPage = this.state.currentPage === this.state.lastPage;
            var areThereMoreIssues = this.totalRecordsInDB > this.state.totalRecords;
            return isLastPage && areThereMoreIssues;
        },

        /**
         * @param preloadedData expects an object like this: { ids: [1000,1001,10002], response: {..ajax response..}}
         */
        setPreloadedData: function(preloadedData) {
            this.preloadedData = preloadedData;
            return this;
        },

        _getStableKeys: function (startIndex) {
            var start = typeof startIndex === 'undefined' ? this._getStartIndex() : startIndex;
            return _.pluck(this.allIssues, "id").slice(start, start + this.state.pageSize);
        },

        _getStartIndex: function () {
            return this.state.pageSize * this.state.currentPage;
        },

        _loadPageAndSelect: function (pageToLoad, issueToSelect) {
            var deferred = new jQuery.Deferred();

            var options = {fetch: true, reset: true};
            this.trigger("before:loadpage", {
                pageToLoad: pageToLoad
            });
            this.getPage(pageToLoad, options)
                .done(_.bind(function () {
                    this.select(issueToSelect);
                    deferred.resolve(this.length);
                }, this))
                .fail(_.bind(function(response) {
                    deferred.reject(response);
                    this.trigger("error:loadpage", response);
                }, this));

            return deferred.promise();
        },

        fetch: function(options) {
            var promise;
            if (this.preloadedData && _.isEqual(this.preloadedData.ids, this._getStableKeys(this.state.pageSize * options.to))) {
                this.reset(this.preloadedData.response, { parse: true });
                promise = new jQuery.Deferred().resolve().promise();
                delete this.preloadedData;
            } else {
                promise = PageableCollection.prototype.fetch.call(this, options);
            }
            return promise;
        },

        jumpToPage: function (page) {
            var deferred = new jQuery.Deferred();
            this._loadPageAndSelect(page, "first")
                .done(deferred.resolve)
                .fail(deferred.reject);
            return deferred.promise();
        },

        jumpToPageForIssue: function (issueIdOrKey) {
            var deferred = new jQuery.Deferred();
            var isIssueId = (typeof issueIdOrKey === "number");
            var isIssueKey = (typeof issueIdOrKey === "string");

            // Find which page the issue belongs to
            var pageToLoad;
            var issue;
            for (var i = 0, len = this.allIssues.length; i < len && !issue; i++) {
                if (
                    (isIssueId && this.allIssues[i].id === issueIdOrKey) ||
                    (isIssueKey && this.allIssues[i].key === issueIdOrKey)
                ) {
                    issue = this.allIssues[i];
                    pageToLoad = Math.floor(i / this.state.pageSize);
                }
            }

            if (typeof pageToLoad === "number" && isFinite(pageToLoad)) {
                // Page for issue found, go to the page and select the issue
                this._loadPageAndSelect(pageToLoad, issue.id).done(deferred.resolve);
            } else if (this.allowNoSelection) {
                // Page for issue not found, but we allow having no selection
                // Load the page but do not select anything
                this._loadPageAndSelect("first", null).done(_.bind(function(){
                    this.trigger("selectIssueNotInList", new Result({
                        id: isIssueId ? issueIdOrKey : undefined,
                        key: isIssueKey ? issueIdOrKey : undefined
                    }));
                }, this)).done(deferred.resolve);
            } else {
                // Page for issue not found and we require a selection, select
                // the first issue in the first page
                this._loadPageAndSelect("first", "first").done(deferred.resolve);
            }
            return deferred.promise();
        },

        parse: function (resp, options) {
            var requestData = options.data;
            var data = resp && resp.issueTable;

            var allIssues = this.allIssues;
            _.each(data.table, function (rawIssue, index) {
                // If an issue is missing from the server, it will contain the value 'null'
                if (rawIssue === null) {
                    // We take advantage of the fact that the order of requestData and the response is the same.
                    var issueId = requestData.id[index];

                    // Search for this particular issue in the list of issues for this search.
                    var oldIssueData = _.findWhere(allIssues, {id: issueId});
                    if (oldIssueData) {
                        // Even if the issue is missing from the server, populate the required fields (id and key)
                        // so all our views, events and url management will continue to work.
                        data.table[index] = {
                            id: oldIssueData.id,
                            key: oldIssueData.key,
                            inaccessible: true
                        };
                    }
                }
            });

            return PageableCollection.prototype.parse.call(this, data);
        },

        parseState: function () {
            return {};
        },

        parseRecords: function (resp) {
            if (resp.table) {
                return resp.table;
            }
            else {
                return [];
            }
        },

        select: function (model) {
            if (typeof model === "string") {
                switch (model) {
                    case "first":
                        model = this.at(0);
                        break;
                    case "last":
                        model = this.at(this.length - 1);
                        break;
                    default:
                        model = this.findWhere({key: model});
                        break;
                }
            } else if (typeof model === "number") {
                model = this.get(model);
            }

            if (this.selected !== model) {
                this.unselect();
            }
            if (!model) {
                return;
            }
            this.selected = model;
            this.selected.trigger("select", this.selected);
        },

        unselect: function () {
            if (this.selected) {
                this.selected.trigger("unselect", this.selected);
            }
            this.selected = null;
        },

        navigate: function (step) {
            var index = this.indexOf(this.selected);
            var newIndex = index + step;
            var model = this.at(newIndex);
            if (model) {
                this.select(model);
            }
            else if (step > 0 && this.hasNextPage()) {
                this._loadPageAndSelect("next", "first");
            } else if (step < 0 && this.hasPreviousPage()) {
                this._loadPageAndSelect("prev", "last");
            }
            return {current: newIndex, total: this.length};
        },

        selectNext: function () {
            return this.navigate(1);
        },

        selectPrev: function () {
            return this.navigate(-1);
        },

        /**
         * Gets the issue based on an offset from the current selected issue.
         * @param {number} offset Offset (eg: '1' gets the next issue, '-1' gets the previous issue)
         * @returns {jQuery.Promise} Promise that will be resolved with the selected issue, or rejected if the issue
         *          does not exist.
         * @private
         */
        _getIssueByNavigation: function(offset) {
            var index = this.indexOf(this.selected);
            var newIndex = index + offset;
            var model = this.at(newIndex);
            var deferred = new jQuery.Deferred();

            if (model) {
                this.select(model);
                deferred.resolve(model);
            } else if (offset > 0 && this.hasNextPage()) {
                this._loadPageAndSelect("next", "first").done(function() {
                    deferred.resolve(this.selected);
                }.bind(this));
            } else if (offset < 0 && this.hasPreviousPage()) {
                this._loadPageAndSelect("prev", "last").done(function() {
                    deferred.resolve(this.selected);
                }.bind(this));
            } else {
                deferred.reject();
            }

            return deferred.promise();
        },

        /**
         * Gets the next issue
         *
         * @returns {jQuery.Promise} Promise that will be resolved with the selected issue, or rejected if the issue
         *          does not exist.
         */
        getNextIssue: function() {
            return this._getIssueByNavigation(1);
        },

        /**
         * Gets the previous issue
         *
         * @returns {jQuery.Promise} Promise that will be resolved with the selected issue, or rejected if the issue
         *          does not exist.
         */
        getPreviousIssue: function() {
            return this._getIssueByNavigation(-1);
        },

        updateSelectedIssue: function () {
            if (this.selected) {
                this.selected.fetch();
            }
        },

        updateIssue: function(issueId) {
            var issue = this.get(issueId);
            if (issue) {
                issue.fetch();
            }
        },

        hasIssueInSearch: function (issueKey) {
            return !!_.where(this.allIssues, {key: issueKey}).length;
        },

        isEmptySearch: function () {
            return !this.allIssues.length;
        },

        /**
         * This method removes the model from the collection. If the model was selected, it will
         * try to select a new issue based on the following algorithm:
         *
         *  * If there is a next issue, select it. ...
         *  * If there is a previous issue, select it. Else...
         *  * The list is empty, select nothing
         *
         * @param {JIRA.Components.Search.Result} model Issue to delete
         */
        removeAndUpdateSelectionIfNeeded: function (model) {
            var issueKey = model.get('key');
            var issueToSelectAfterRemoveOperation;
            var allKeys = _.chain(this.allIssues).map(function (issue) {return issue.key;}).value();
            var currentIndex = _.indexOf(allKeys, issueKey);
            var hasNext = currentIndex + 1 < allKeys.length;
            var hasPrevious = currentIndex - 1 >= 0;

            if (hasNext) {
                issueToSelectAfterRemoveOperation = allKeys[currentIndex + 1];
            }
            else if (hasPrevious) {
                issueToSelectAfterRemoveOperation = allKeys[currentIndex - 1];
            }
            else {
                // There are no more issues, select nothing
                issueToSelectAfterRemoveOperation = null;
            }

            // Remove the issue from this.allIssues
            for (var i = 0; i < this.allIssues.length; i++) {
                var issue = this.allIssues[i];
                if (issue.key === issueKey) {
                    this.allIssues.splice(i, 1);
                    break;
                }
            }

            // Remove the issue from the pagination related counters
            this.state.totalRecords = this.state.totalRecords - 1;
            this.totalRecordsInDB = this.totalRecordsInDB - 1;

            // Unselect and remove it
            this.unselect();
            this.remove(model);

            // If we have an issue to select after the remove operation, load its page
            if (issueToSelectAfterRemoveOperation) {
                return this.jumpToPageForIssue(issueToSelectAfterRemoveOperation).done(_.bind(function() {
                    this.trigger("issueDeleted");
                }, this));
            } else {
                return new jQuery.Deferred().resolve(0).promise().done(_.bind(function() {
                    this.trigger("issueDeleted");
                }, this));
            }
        },

        getIssueKeyForIndex: function(index) {
            var issue = this.allIssues[index];
            if(!issue) return;

            return issue.key;
        },

        getIssueAtGlobalIndex: function(index) {
            return this.allIssues[index];
        },


        getPositionOfIssueInSearchResults: function(issueId) {
            var position = _.indexOf(_.pluck(this.allIssues, 'id'), issueId);
            if (position > -1) {
                return position;
            } else {
                return null;
            }
        },

        getPositionOfIssueInPage: function(issueId) {
            var model = this.get(issueId);
            var position = this.indexOf(model);
            if (position > -1) {
                return position;
            } else {
                return null;
            }
        },

        /**
         * @deprecated In JIRA 7.0. Will be removed in JIRA 8.0. Use getTotalIssuesInSearch() instead;
         */
        getTotalIssues: function() {
            return this.getTotalIssuesInSearch();
        },

        getTotalIssuesInSearch: function() {
            return this.allIssues.length;
        },

        getTotalIssuesInDb: function() {
            return this.totalRecordsInDB;
        }
    });

    AJS.deprecate.prop(Results.prototype, 'getTotalIssues', {
        removeInVersion: '8.0',
        alternativeName: 'jira/components/search/results#getTotalIssuesInSearch()',
        sinceVersion: '7.1',
        displayName: "Method jira/components/search/results#getTotalIssues()"
    });

    return Results;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:brace', location = '/inline-issue-create/lib/backbone.brace/backbone.brace-amd.js' */
define("jira/inline-issue-create/lib/backbone", [
    "atlassian/libs/factories/backbone-1.0.0",
    "atlassian/libs/underscore-1.5.2",
    "jquery"

], function(backboneFactory, _, $){
    return backboneFactory(_, $);
});

define("jira/inline-issue-create/lib/brace", [
    "jira/inline-issue-create/lib/backbone",
    "atlassian/libs/underscore-1.5.2",
    "atlassian/libs/factories/brace-2014.09.03"
], function(backbone, _, braceFactory) {
    "use strict";
    return braceFactory(_, Backbone);
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:marionette', location = '/inline-issue-create/lib/backbone.marionette/backbone.marionette-amd.js' */
define("jira/inline-issue-create/lib/marionette", [
    "jquery",
    "jira/inline-issue-create/lib/backbone",
    "atlassian/libs/underscore-1.5.2",
    "atlassian/libs/factories/marionette-2.1.0"
], function($, Backbone, _, marionetteFactory) {
    "use strict";
    var Marionette =  marionetteFactory(_, Backbone);

    /**
     * This method unwraps the Backbone.View.
     *
     * By default, Backbone will create a <di`v> and render the template inside. By calling this
     * method, you can get rid of that <div>, so the main element in your template will be the
     * root element in your template.
     */
    var extensions = {
        unwrapTemplate: function unwrapTemplate() {
            var children = this.$el.children();
            if (children.length > 1) {
                AJS.warn("[IIC] Unwrapping template with more than one child - some content will be lost");
            }

            var child = $(children.get(0));
            if (this.$el.parent().length) {
                // If the template is already rendered in the page
                this.$el.replaceWith(child);
                this.setElement(child);
            } else {
                // If the template is in memory
                this.setElement(child);
            }
        }
    };

    _.extend(Marionette.ItemView.prototype, extensions);
    _.extend(Marionette.CompositeView.prototype, extensions);
    _.extend(Marionette.CollectionView.prototype, extensions);
    _.extend(Marionette.LayoutView.prototype, extensions);

    return Marionette;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:placeholder', location = '/inline-issue-create/lib/jquery-placeholder.js' */
/*! MIT License - https://github.com/mathiasbynens/jquery-placeholder/blob/master/LICENSE-MIT.txt */
/*! http://mths.be/placeholder v2.0.8 by @mathias */
;(function(window, document, $) {

    // Opera Mini v7 doesn’t support placeholder although its DOM seems to indicate so
    var isOperaMini = Object.prototype.toString.call(window.operamini) == '[object OperaMini]';
    var isInputSupported = 'placeholder' in document.createElement('input') && !isOperaMini;
    var isTextareaSupported = 'placeholder' in document.createElement('textarea') && !isOperaMini;
    var prototype = $.fn;
    var valHooks = $.valHooks;
    var propHooks = $.propHooks;
    var hooks;
    var placeholder;

    if (isInputSupported && isTextareaSupported) {

        placeholder = prototype.placeholder = function() {
            return this;
        };

        placeholder.input = placeholder.textarea = true;

    } else {

        placeholder = prototype.placeholder = function() {
            var $this = this;
            $this
                .filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]')
                .not('.placeholder')
                .bind({
                    'focus.placeholder': clearPlaceholder,
                    'blur.placeholder': setPlaceholder
                })
                .data('placeholder-enabled', true)
                .trigger('blur.placeholder');
            return $this;
        };

        placeholder.input = isInputSupported;
        placeholder.textarea = isTextareaSupported;

        hooks = {
            'get': function(element) {
                var $element = $(element);

                var $passwordInput = $element.data('placeholder-password');
                if ($passwordInput) {
                    return $passwordInput[0].value;
                }

                return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
            },
            'set': function(element, value) {
                var $element = $(element);

                var $passwordInput = $element.data('placeholder-password');
                if ($passwordInput) {
                    return $passwordInput[0].value = value;
                }

                if (!$element.data('placeholder-enabled')) {
                    return element.value = value;
                }
                if (value == '') {
                    element.value = value;
                    // Issue #56: Setting the placeholder causes problems if the element continues to have focus.
                    if (element != safeActiveElement()) {
                        // We can't use `triggerHandler` here because of dummy text/password inputs :(
                        setPlaceholder.call(element);
                    }
                } else if ($element.hasClass('placeholder')) {
                    clearPlaceholder.call(element, true, value) || (element.value = value);
                } else {
                    element.value = value;
                }
                // `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
                return $element;
            }
        };

        if (!isInputSupported) {
            valHooks.input = hooks;
            propHooks.value = hooks;
        }
        if (!isTextareaSupported) {
            valHooks.textarea = hooks;
            propHooks.value = hooks;
        }

        $(function() {
            // Look for forms
            $(document).delegate('form', 'submit.placeholder', function() {
                // Clear the placeholder values so they don't get submitted
                var $inputs = $('.placeholder', this).each(clearPlaceholder);
                setTimeout(function() {
                    $inputs.each(setPlaceholder);
                }, 10);
            });
        });

        // Clear placeholder values upon page reload
        $(window).bind('beforeunload.placeholder', function() {
            $('.placeholder').each(function() {
                this.value = '';
            });
        });

    }

    function args(elem) {
        // Return an object of element attributes
        var newAttrs = {};
        var rinlinejQuery = /^jQuery\d+$/;
        $.each(elem.attributes, function(i, attr) {
            if (attr.specified && !rinlinejQuery.test(attr.name)) {
                newAttrs[attr.name] = attr.value;
            }
        });
        return newAttrs;
    }

    function clearPlaceholder(event, value) {
        var input = this;
        var $input = $(input);
        if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
            if ($input.data('placeholder-password')) {
                $input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
                // If `clearPlaceholder` was called from `$.valHooks.input.set`
                if (event === true) {
                    return $input[0].value = value;
                }
                $input.focus();
            } else {
                input.value = '';
                $input.removeClass('placeholder');
                input == safeActiveElement() && input.select();
            }
        }
    }

    function setPlaceholder() {
        var $replacement;
        var input = this;
        var $input = $(input);
        var id = this.id;
        if (input.value == '') {
            if (input.type == 'password') {
                if (!$input.data('placeholder-textinput')) {
                    try {
                        $replacement = $input.clone().attr({ 'type': 'text' });
                    } catch(e) {
                        $replacement = $('<input>').attr($.extend(args(this), { 'type': 'text' }));
                    }
                    $replacement
                        .removeAttr('name')
                        .data({
                            'placeholder-password': $input,
                            'placeholder-id': id
                        })
                        .bind('focus.placeholder', clearPlaceholder);
                    $input
                        .data({
                            'placeholder-textinput': $replacement,
                            'placeholder-id': id
                        })
                        .before($replacement);
                }
                $input = $input.removeAttr('id').hide().prev().attr('id', id).show();
                // Note: `$input[0] != input` now!
            }
            $input.addClass('placeholder');
            $input[0].value = $input.attr('placeholder');
        } else {
            $input.removeClass('placeholder');
        }
    }

    function safeActiveElement() {
        // Avoid IE9 `document.activeElement` of death
        // https://github.com/mathiasbynens/jquery-placeholder/pull/99
        try {
            return document.activeElement;
        } catch (exception) {}
    }

}(this, document, jQuery));;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:util', location = '/inline-issue-create/util/util.js' */
/*globals console*/
define('jira/inline-issue-create/util', [
    'jquery'
], function(
    $
) {
    "use strict";

    var bodyStyle = (document.body || document.documentElement).style;
    var eventNames = ["oAnimationEnd", "MSAnimationEnd", "mozAnimationEnd", "webkitAnimationEnd", "animationend"];

    var logFilter;

    return {
        cssAnimationsSupport: bodyStyle.transition !== undefined || bodyStyle.WebkitTransition !== undefined || bodyStyle.MozTransition !== undefined || bodyStyle.MsTransition !== undefined || bodyStyle.OTransition !== undefined,
        addClassAndRemoveOnAnimationEnd: function addClassAndRemoveOnAnimationEnd(el, className, durationInMilis) {
            var i;
            el = $(el);

            function listener() {
                for (i = 0; i < eventNames.length; i++) {
                    el.off(eventNames[i], listener);
                }
                el.removeClass(className);
            }

            if (this.cssAnimationsSupport) {
                for (i = 0; i < eventNames.length; i++) {
                    el.on(eventNames[i], listener);
                }
            } else {
                setTimeout(function() {
                    el.removeClass(className);
                }, durationInMilis || 1000);
            }
            el.addClass(className);
        },
        scrollElementToView: function scrollElementToView($scrollingContainer, $element) {
            var viewportRect = $scrollingContainer[0].getBoundingClientRect();
            var elementRect = $element[0].getBoundingClientRect();

            var containerScrollTop = $scrollingContainer.scrollTop();
            var scrollOffset = 0;
            if (elementRect.top < viewportRect.top) {
                // the element is before the view port begining
                scrollOffset = elementRect.top - viewportRect.top;
            } else if (viewportRect.bottom < elementRect.bottom) {
                // the element is after the view port ending
                scrollOffset = elementRect.bottom - viewportRect.bottom;
            }

            if (scrollOffset !== 0) {
                $scrollingContainer.scrollTop(containerScrollTop + scrollOffset);
            }
        },
        keyCode: {
            ENTER: 13,
            ESC: 27
        },
        after: function after(object, method, body) {
            if (!_.isFunction(body)) {
                throw "Body is not a function";
            }
            object[method] = _.wrap(object[method], function wrapper(originalFunction) {
                var originalArguments = Array.prototype.slice.call(arguments, 1);
                var result = originalFunction.apply(object, originalArguments);
                body.apply(this, _.union([result], originalArguments));
                return result;
            });
        },

        /**
         *
         * @param object
         * @param {...*} message
         */
        error: function error(object) {
            if (console && console.error) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (_.isString(args[0])) {
                    args[0] = "[IIC]" + args[0];
                }
                console.error.apply(console, args);
            }
        },        /**
         *
         * @param object
         * @param {...*} message
         */
        debug: function debug(object) {
            if(this.shouldDisplay(object)){
                if (console && console.debug) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (_.isString(args[0])) {
                        args[0] = "[IIC]" + args[0];
                    }
                    console.debug.apply(console, args);
                }
            }
        },
         /*
         * @param object
         * @param {...*} message
         */
        trace: function trace(object) {
            if(this.shouldDisplay(object)){
                if (console && console.debug) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (_.isString(args[0])) {
                        args[0] = "[IIC]" + args[0];
                    }
                    console.debug.apply(console, args);
                }
            }
        },
        shouldDisplay: function(object) {
            if(logFilter === "all" || object === logFilter) {
                return true;
            }
            return false;
        },
        showLogsFor: function showLogsFor(object) {
            logFilter = object;
        }
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-preffilable-create-issue-dialog', location = '/inline-issue-create/components/prefillable-create-issue-dialog/custom-form-container-factory.js' */
define('jira/inline-issue-create/prefillable-create-issue-dialog/custom-form-container-factory', [
    'jquery',
    'underscore'
], function (
    $,
    _
) {
    "use strict";

    var build = function () {
        var JiraFormsContainer = JIRA.Forms.Container;

        return JiraFormsContainer.extend({
            lazyInit: function lazyInit() {
                var options = this.options.call(this);
                this.prefilledValues = options.prefilledValues;
                this.prefilledValues.fieldsToRetain = _.keys(options.prefilledValues);
                this.prefilledValues =  $.param(options.prefilledValues);

                // Override options to just return what was evaluated and not evaluate it twice.
                // This way extra objects won't get created when super tries to call options again .
                this.options = function overridenOpitons() {
                    return options;
                };
                return this._super();
            },
            /**
             * Renders quick form. What is actually rendered is based apon user configuration. Full form will be showed first,
             * but if user switches to configurable form that will be persisted.
             *
             * It was extended, to use values retrieved from inline issue create JQL context.
             *
             * @return jQuery.Deferred
             */
            render: function render() {
                var instance = this,
                    deferred = $.Deferred();
                // re-evaluate options
                this.lazyInit();

                // values provided from context should be treated as they were provided by user
                // for backwards compatibility reasons check whether method is there
                if(_.isFunction(instance.model.markFieldAsDirty)) {
                    Object.keys(this.options().prefilledValues).forEach(function(key) {
                        instance.model.markFieldAsDirty(key);
                    });
                }

                instance.model.getUseConfigurableForm().done(function getUseConfigurableFormDone(answer) {
                    if (answer === true) {
                        instance.configurableForm.render(instance.prefilledValues).done(function rendered(el, scripts) {
                            deferred.resolveWith(instance, [instance.$element]);
                            instance.$element.append(scripts);
                        });
                    } else {
                        instance.unconfigurableForm.render(instance.prefilledValues).done(function rendered(el, scripts) {
                            deferred.resolveWith(instance, [instance.$element, scripts]);
                            instance.$element.append(scripts);
                        });
                    }
                }).fail(function getUseConfigurableFormFailed() {
                    deferred.resolveWith(instance, [instance.$element]);
                });

                return deferred.promise();
            }
        });
    };
    return {build: build};
});
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-preffilable-create-issue-dialog', location = '/inline-issue-create/components/prefillable-create-issue-dialog/prefillable-create-issue-dialog-init-form.js' */
define('jira/inline-issue-create/prefillable-create-issue-dialog/init-form', [
    'underscore',
    'jira/inline-issue-create/prefillable-create-issue-dialog/custom-form-container-factory'
], function (
    _,
    CustomFormContainerFactory
) {
    "use strict";

    /**
     * Initializes the JIRA.Forms.Container form and resolves passed deferred param with JIRA.Forms.Container.
     *
     * @param {jQuery.Deferred} deferred - Deferred that is resolved to the JIRA.Forms.Container form after the WRM resources have been downloaded and the form is ready to be displayed. Can be used to asynchronously show the form when all resources are downloaded.
     * @param {jQuery.Promise} fieldValuesRetrieved - Promise that is resolved with form parameters obtained from rest resource. The parameters are needed to ensure that the issue created will satisfy the actual JQL entered by user.
     */
    return function (deferred, fieldValuesRetrieved)  {
        if (!_.isObject(fieldValuesRetrieved)) {
            throw new Error("You must provide promise that will resolve with fieldValues to create this form. Use standard create issue form if you have none.");
        }

        var JiraFormsCreateIssueModel = JIRA.Forms.CreateIssueModel;
        var JiraFormsConfigurableCreateIssueForm = JIRA.Forms.ConfigurableCreateIssueForm;
        var JiraFormsUnconfigurableCreateIssueForm = JIRA.Forms.UnconfigurableCreateIssueForm;
        var JiraFormsCreateIssueError = JIRA.Forms.CreateIssueError;
        var applyErrorsToForm = JIRA.applyErrorsToForm;
        var applyErrorMessageToForm = JIRA.applyErrorMessageToForm;

        var data;
        fieldValuesRetrieved.done(function whenInitializedAndHasFields(responseData) {
            data = responseData;

            data.prefilledFields = data.prefilledFields || {};
            data.errors = data.errors || {};
            data.errorMessages = data.errorMessages || {};
        }).fail(function whenFailedInitialization() {
            data = {
                prefilledFields: {},
                errors: {},
                errorMessages: {}
            };
        });

        // Copied from Quick Edit plugin to override the title
        var CustomFormContainer = CustomFormContainerFactory.build();
        var form = new CustomFormContainer(function containerInitFunction() {
            var containerOptions = {
                title: "Create Issue",
                id: "prefillable-create-issue-dialog",
                globalEventNamespaces: ["PrefillableCreateIssueDialog"],
                issueType: undefined // we will set that later when context is resolved
            };

            // model that gets fields and sets user preferences
            var model = new JiraFormsCreateIssueModel({
                projectId: undefined, // we will set that later when context is resolved
                issueType: undefined // we will set that later when context is resolved
            });

            var configurableForm = new JiraFormsConfigurableCreateIssueForm({
                model: model,
                title: containerOptions.title,
                globalEventNamespaces: containerOptions.globalEventNamespaces
            });

            var unconfigurableForm = new JiraFormsUnconfigurableCreateIssueForm({
                model: model,
                title: containerOptions.title,
                globalEventNamespaces: containerOptions.globalEventNamespaces
            });

            return {
                globalEventNamespaces: containerOptions.globalEventNamespaces,
                model: model,
                errorHandler: new JiraFormsCreateIssueError(),
                configurableForm: configurableForm,
                unconfigurableForm: unconfigurableForm,
                // when this variable is used it will be already defined because
                // this function isn't called until AFTER fieldValuesRetrieved is resolved
                prefilledValues: data.prefilledFields
            };
        });

        var dialog = form.asDialog({
            windowTitle: "Create Issue",
            id: "prefillable-create-issue-dialog"
        });

        // we can modify dialog's options after creation, specifically the
        // delayShowUntil option, as it is used in the show method for the first time
        dialog.options.delayShowUntil = function delayShowUntilFieldValuesRetrieved() {
            return fieldValuesRetrieved;
        };

        form.asDialog = function asDialog() {
            return form.dialog;
        };

        dialog.onContentReady(function formInitialized() {
            if (_.keys(data.errors).length) {
                // add global error message indicating that there are field errors            }
                data.errorMessages.unshift("Please fix the fields marked below.");
                // add per-field error messages
                applyErrorsToForm(form.$element, data.errors);
            }
            if (data.errorMessages.length) {
                // add global error message, join multiple messsages with <br> if needed
                applyErrorMessageToForm(form.$element, data.errorMessages.join("<br/>"));
            }
        });

        deferred.resolve(form);
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-preffilable-create-issue-dialog', location = '/inline-issue-create/components/prefillable-create-issue-dialog/prefillable-create-issue-dialog.js' */
define('jira/inline-issue-create/prefillable-create-issue-dialog', [
    'wrm/require',
    'jquery',
    'underscore',
    'jira/inline-issue-create/lib/marionette',
    'jira/loading/loading',
    'jira/flag',
    'jira/inline-issue-create/prefillable-create-issue-dialog/init-form'
], function (
    wrmRequire,
    $,
    _,
    Marionette,
    Loading,
    Flag,
    initForm
) {
    "use strict";

    var ajsDim = AJS.dim;
    var ajsUndim = AJS.undim;

    var showLoadingIndicator = function () {
        ajsDim();
        Loading.showLoadingIndicator();
    };
    var hideLoadingIndicator = function () {
        ajsUndim();
        Loading.hideLoadingIndicator();
    };

    /**
     * Factory to create Create Issue Form promise
     *
     * @return promise that is resolved with JIRA.Forms.Container
     */
    var createPrefillableCreateIssueForm = function createPrefillableCreateIssueForm(
        fieldValuesRetrieved,
        shouldShowLoadingIndicator
    ) {
        var deferred = new $.Deferred();

        if (shouldShowLoadingIndicator) {
            showLoadingIndicator();
        }

        wrmRequire(['wr!com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue'], initForm.bind(undefined, deferred, fieldValuesRetrieved)).fail(function () {
            if (shouldShowLoadingIndicator) {
                hideLoadingIndicator();
            }
            Flag.showErrorMsg(null, "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.");
        });

        return deferred.promise();
    };

    return {
        createPrefillableCreateIssueForm: createPrefillableCreateIssueForm
    };
});

define('jira/inline-issue-create/prefillable-create-issue-dialog/custom-form-container-factory', [
    'jquery',
    'underscore'
], function (
    $,
    _
) {
    "use strict";

    var JiraFormsContainer = JIRA.Forms.Container;

    var build = function () {
        return JiraFormsContainer.extend({
            lazyInit: function lazyInit() {
                var options = this.options.call(this);
                this.prefilledValues = options.prefilledValues;
                this.prefilledValues.fieldsToRetain = _.keys(options.prefilledValues);
                this.prefilledValues =  $.param(options.prefilledValues);

                // Override options to just return what was evaluated and not evaluate it twice.
                // This way extra objects won't get created when super tries to call options again .
                this.options = function overridenOpitons() {
                    return options;
                };
                return this._super();
            },
            /**
             * Renders quick form. What is actually rendered is based apon user configuration. Full form will be showed first,
             * but if user switches to configurable form that will be persisted.
             *
             * It was extended, to use values retrieved from inline issue create JQL context.
             *
             * @return jQuery.Deferred
             */
            render: function render() {
                var instance = this,
                    deferred = $.Deferred();
                // re-evaluate options
                this.lazyInit();

                // values provided from context should be treated as they were provided by user
                // for backwards compatibility reasons check whether method is there
                if(_.isFunction(instance.model.markFieldAsDirty)) {
                    Object.keys(this.options().prefilledValues).forEach(function(key) {
                        instance.model.markFieldAsDirty(key);
                    });
                }

                instance.model.getUseConfigurableForm().done(function getUseConfigurableFormDone(answer) {
                    if (answer === true) {
                        instance.configurableForm.render(instance.prefilledValues).done(function rendered(el, scripts) {
                            deferred.resolveWith(instance, [instance.$element]);
                            instance.$element.append(scripts);
                        });
                    } else {
                        instance.unconfigurableForm.render(instance.prefilledValues).done(function rendered(el, scripts) {
                            deferred.resolveWith(instance, [instance.$element, scripts]);
                            instance.$element.append(scripts);
                        });
                    }
                }).fail(function getUseConfigurableFormFailed() {
                    deferred.resolveWith(instance, [instance.$element]);
                });

                return deferred.promise();
            }
        });
    };
    return {build: build};
});

define('jira/inline-issue-create/prefillable-create-issue-dialog/ondone', [
    'underscore',
    'jira/inline-issue-create/prefillable-create-issue-dialog/custom-form-container-factory'
], function (
    _,
    CustomFormContainerFactory
) {
    "use strict";

    var JiraFormsCreateIssueModel = JIRA.Forms.CreateIssueModel;
    var JiraFormsConfigurableCreateIssueForm = JIRA.Forms.ConfigurableCreateIssueForm;
    var JiraFormsUnconfigurableCreateIssueForm = JIRA.Forms.UnconfigurableCreateIssueForm;
    var JiraFormsCreateIssueError = JIRA.Forms.CreateIssueError;
    var applyErrorsToForm = JIRA.applyErrorsToForm;
    var applyErrorMessageToForm = JIRA.applyErrorMessageToForm;

    return function (deferred, fieldValuesRetrieved)  {
        if (!_.isObject(fieldValuesRetrieved)) {
            throw new Error("You must provide promise that will resolve with fieldValues to create this form. Use standard create issue form if you have none.");
        }

        var data;
        fieldValuesRetrieved.done(function whenInitializedAndHasFields(responseData) {
            data = responseData;

            data.prefilledFields = data.prefilledFields || {};
            data.errors = data.errors || {};
            data.errorMessages = data.errorMessages || {};
        }).fail(function whenFailedInitialization() {
            data = {
                prefilledFields: {},
                errors: {},
                errorMessages: {}
            };
        });

        // Copied from Quick Edit plugin to override the title
        var CustomFormContainer = CustomFormContainerFactory.build();
        var form = new CustomFormContainer(function containerInitFunction() {
            var containerOptions = {
                title: "Create Issue",
                id: "prefillable-create-issue-dialog",
                globalEventNamespaces: ["PrefillableCreateIssueDialog"],
                issueType: undefined // we will set that later when context is resolved
            };

            // model that gets fields and sets user preferences
            var model = new JiraFormsCreateIssueModel({
                projectId: undefined, // we will set that later when context is resolved
                issueType: undefined // we will set that later when context is resolved
            });

            var configurableForm = new JiraFormsConfigurableCreateIssueForm({
                model: model,
                title: containerOptions.title,
                globalEventNamespaces: containerOptions.globalEventNamespaces
            });

            var unconfigurableForm = new JiraFormsUnconfigurableCreateIssueForm({
                model: model,
                title: containerOptions.title,
                globalEventNamespaces: containerOptions.globalEventNamespaces
            });

            return {
                globalEventNamespaces: containerOptions.globalEventNamespaces,
                model: model,
                errorHandler: new JiraFormsCreateIssueError(),
                configurableForm: configurableForm,
                unconfigurableForm: unconfigurableForm,
                // when this variable is used it will be already defined because
                // this function isn't called until AFTER fieldValuesRetrieved is resolved
                prefilledValues: data.prefilledFields
            };
        });

        var dialog = form.asDialog({
            windowTitle: "Create Issue",
            id: "prefillable-create-issue-dialog"
        });

        // we can modify dialog's options after creation, specifically the
        // delayShowUntil option, as it is used in the show method for the first time
        dialog.options.delayShowUntil = function delayShowUntilFieldValuesRetrieved() {
            return fieldValuesRetrieved;
        };

        form.asDialog = function asDialog() {
            return form.dialog;
        };

        dialog.onContentReady(function formInitialized() {
            if (_.keys(data.errors).length) {
                // add global error message indicating that there are field errors            }
                data.errorMessages.unshift("Please fix the fields marked below.");
                // add per-field error messages
                applyErrorsToForm(form.$element, data.errors);
            }
            if (data.errorMessages.length) {
                // add global error message, join multiple messsages with <br> if needed
                applyErrorMessageToForm(form.$element, data.errorMessages.join("<br/>"));
            }
        });

        deferred.resolve(form);
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/inline-issue-create-widget.soy' */
// This file was automatically generated from inline-issue-create-widget.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.InlineIssueCreate.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.InlineIssueCreate == 'undefined') { JIRA.Templates.InlineIssueCreate = {}; }


JIRA.Templates.InlineIssueCreate.trigger = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div class="iic' + ((opt_data.cssClass) ? ' ' + soy.$$escapeHtml(opt_data.cssClass) : '') + '"><div class="iic-trigger"><button type="button">' + soy.$$escapeHtml("Create issue") + '</button></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.InlineIssueCreate.trigger.soyTemplateName = 'JIRA.Templates.InlineIssueCreate.trigger';
}


JIRA.Templates.InlineIssueCreate.widget = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div class="iic-widget' + ((opt_data.cssClass) ? ' ' + soy.$$escapeHtml(opt_data.cssClass) : '') + '"><form action="#" method="POST" class="iic-widget__form aui"><div class="iic-widget__issue-type-selector-container"></div><div><textarea name="summary" rows="1" cols="50" maxlength="255" class="iic-widget__summary" placeholder="' + soy.$$escapeHtml("What needs to be done?") + '">' + ((opt_data.summary) ? soy.$$escapeHtml(opt_data.summary) : '') + '</textarea><div class="iic-widget__footer"><div class="iic-widget__description-container"></div><button type="button" class="aui-button aui-button-subtle iic-widget__more" title="' + soy.$$escapeHtml("Open create dialog") + '"><span class="aui-icon aui-icon-small aui-iconfont-more">' + soy.$$escapeHtml("More") + '</span></button><button type="button" class="aui-button aui-button-link iic-widget__cancel">' + soy.$$escapeHtml("Cancel") + '</button></div></div></form></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.InlineIssueCreate.widget.soyTemplateName = 'JIRA.Templates.InlineIssueCreate.widget';
}


JIRA.Templates.InlineIssueCreate.issueTypeSelector = function(opt_data, opt_ignored) {
  return '<div class="iic-widget__issue-type-selector"><button type="button" class="iic-widget__issue-type-selector__trigger aui-dropdown2-trigger" aria-owns="iic-issue-type-dropdown-' + soy.$$escapeHtml(opt_data.widgetId) + '" aria-haspopup="true">' + ((! opt_data.isLocked) ? '<img src="' + soy.$$escapeHtml(opt_data.issueTypeIconUrl) + '" width="16" height="16" />' : '<img src="data:image/gif;base64,R0lGODlhEAAQAMQAAP///+7u7t3d3bu7u6qqqpmZmYiIiHd3d2ZmZlVVVURERDMzMyIiIhEREQARAAAAAP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFBwAQACwAAAAAEAAQAAAFdyAkQgGJJOWoQgIjBM8jkKsoPEzgyMGsCjPDw7ADpkQBxRDmSCRetpRA6Rj4kFBkgLC4IlUGhbNQIwXOYYWCXDufzYPDMaoKGBoKb886OjAKdgZAAgQkfCwzAgsDBAUCgl8jAQkHEAVkAoA1AgczlyIDczUDA2UhACH5BAUHABAALAAAAAAPABAAAAVjICSO0IGIATkqIiMKDaGKC8Q49jPMYsE0hQdrlABCGgvT45FKiRKQhWA0mPKGPAgBcTjsspBCAoH4gl+FmXNEUEBVAYHToJAVZK/XWoQQDAgBZioHaX8igigFKYYQVlkCjiMhACH5BAUHABAALAAAAAAQAA8AAAVgICSOUGGQqIiIChMESyo6CdQGdRqUENESI8FAdFgAFwqDISYwPB4CVSMnEhSej+FogNhtHyfRQFmIol5owmEta/fcKITB6y4choMBmk7yGgSAEAJ8JAVDgQFmKUCCZnwhACH5BAUHABAALAAAAAAQABAAAAViICSOYkGe4hFAiSImAwotB+si6Co2QxvjAYHIgBAqDoWCK2Bq6A40iA4yYMggNZKwGFgVCAQZotFwwJIF4QnxaC9IsZNgLtAJDKbraJCGzPVSIgEDXVNXA0JdgH6ChoCKKCEAIfkEBQcAEAAsAAAAABAADgAABUkgJI7QcZComIjPw6bs2kINLB5uW9Bo0gyQx8LkKgVHiccKVdyRlqjFSAApOKOtR810StVeU9RAmLqOxi0qRG3LptikAVQEh4UAACH5BAUHABAALAAAAAAQABAAAAVxICSO0DCQKBQQonGIh5AGB2sYkMHIqYAIN0EDRxoQZIaC6bAoMRSiwMAwCIwCggRkwRMJWKSAomBVCc5lUiGRUBjO6FSBwWggwijBooDCdiFfIlBRAlYBZQ0PWRANaSkED1oQYHgjDA8nM3kPfCmejiEAIfkEBQcAEAAsAAAAABAAEAAABWAgJI6QIJCoOIhFwabsSbiFAotGMEMKgZoB3cBUQIgURpFgmEI0EqjACYXwiYJBGAGBgGIDWsVicbiNEgSsGbKCIMCwA4IBCRgXt8bDACkvYQF6U1OADg8mDlaACQtwJCEAIfkEBQcAEAAsAAABABAADwAABV4gJEKCOAwiMa4Q2qIDwq4wiriBmItCCREHUsIwCgh2q8MiyEKODK7ZbHCoqqSjWGKI1d2kRp+RAWGyHg+DQUEmKliGx4HBKECIMwG61AgssAQPKA19EAxRKz4QCVIhACH5BAUHABAALAAAAAAQABAAAAVjICSOUBCQqHhCgiAOKyqcLVvEZOC2geGiK5NpQBAZCilgAYFMogo/J0lgqEpHgoO2+GIMUL6p4vFojhQNg8rxWLgYBQJCASkwEKLC17hYFJtRIwwBfRAJDk4ObwsidEkrWkkhACH5BAUHABAALAAAAQAQAA8AAAVcICSOUGAGAqmKpjis6vmuqSrUxQyPhDEEtpUOgmgYETCCcrB4OBWwQsGHEhQatVFhB/mNAojFVsQgBhgKpSHRTRxEhGwhoRg0CCXYAkKHHPZCZRAKUERZMAYGMCEAIfkEBQcAEAAsAAABABAADwAABV0gJI4kFJToGAilwKLCST6PUcrB8A70844CXenwILRkIoYyBRk4BQlHo3FIOQmvAEGBMpYSop/IgPBCFpCqIuEsIESHgkgoJxwQAjSzwb1DClwwgQhgAVVMIgVyKCEAIfkECQcAEAAsAAAAABAAEAAABWQgJI5kSQ6NYK7Dw6xr8hCw+ELC85hCIAq3Am0U6JUKjkHJNzIsFAqDqShQHRhY6bKqgvgGCZOSFDhAUiWCYQwJSxGHKqGAE/5EqIHBjOgyRQELCBB7EAQHfySDhGYQdDWGQyUhADs=" width="16" height="16" />') + '</button><div id="iic-issue-type-dropdown-' + soy.$$escapeHtml(opt_data.widgetId) + '" class="aui-dropdown2 aui-style-default iic-widget__issue-type-selector__dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"></ul></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.InlineIssueCreate.issueTypeSelector.soyTemplateName = 'JIRA.Templates.InlineIssueCreate.issueTypeSelector';
}


JIRA.Templates.InlineIssueCreate.issueTypeSelectorItem = function(opt_data, opt_ignored) {
  return '<li><a href="#" class="aui-icon-container" data-id="' + soy.$$escapeHtml(opt_data.id) + '" style="background-image: url(\'' + soy.$$escapeHtml(opt_data.iconUrl) + '\');">' + soy.$$escapeHtml(opt_data.name) + '</a></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.InlineIssueCreate.issueTypeSelectorItem.soyTemplateName = 'JIRA.Templates.InlineIssueCreate.issueTypeSelectorItem';
}


JIRA.Templates.InlineIssueCreate.description = function(opt_data, opt_ignored) {
  return '<div class="iic-widget__description' + ((! opt_data.issueTypeName) ? ' iic-widget__description_invisible' : '') + '">' + soy.$$escapeHtml("New") + ' <span class="iic-widget__description__selected-issue-type-name">' + ((opt_data.issueTypeName) ? soy.$$escapeHtml(opt_data.issueTypeName) : '') + '</span></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.InlineIssueCreate.description.soyTemplateName = 'JIRA.Templates.InlineIssueCreate.description';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/possibleValues.js' */
define('jira/inline-issue-create/entities/possible-values', [
    'backbone',
    'jira/inline-issue-create/lib/brace'
], function (
    Backbone,
    Brace
) {
    "use strict";

    return Brace.Collection.extend({
        url: function url() {
            var queries = _.map(this.jqls, function (jql) {return "query=" + encodeURIComponent(jql) + "&";});
            return AJS.contextPath() + "/rest/inline-create/1.0/context/possibleValues/" + this.getEntityName() + "?".concat.apply("?", queries);
        },
        getEntityName: undefined,
        initialize: function initialize(attributes, options) {
            this._initializeState(attributes, options);
        },
        _initializeState: function _initializeState(attributes, options) {
            if (options && options.jqls) {
                this.jqls = options.jqls;
            } else {
                this.jqls = undefined;
            }

            this.fetching = false;
            this.initialized = false;
        },
        parse: function parse(response) {
            return response.values;
        },
        setJQLs: function settJQLs(jqls) {
            if (_.isEqual(this.jqls, jqls)) {
                return;
            }
            this.jqls = jqls;
            this.fetch({reset: true});
        },
        reset: function reset() {
            this.fetching = false;
            this.initialized = true;
            return Backbone.Collection.prototype.reset.apply(this, arguments);
        },
        fetch: function fetch(options) {
            var collection = this;

            function triggerFetched() {
                collection.fetching = false;
                collection.initialized = true;
                collection.trigger("fetch:finished");
            }

            options = options || {};
            if (options.success) {
                options.success = _.wrap(options.success, function successWrapper(originalSuccessHandler) {
                    triggerFetched();
                    return originalSuccessHandler.apply(collection, Array.prototype.slice.call(arguments, 1));
                });
            } else {
                options.success = triggerFetched;
            }
            this.trigger("fetch:started");
            this.fetching = true;
            return Backbone.Collection.prototype.fetch.call(this, options);
        },
        isInitialized: function isInitialized() {
            return this.initialized;
        },
        isFetching: function isFetching() {
            return this.fetching;
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/issueType.js' */
define('jira/inline-issue-create/entities/issue-type', [
    'jira/inline-issue-create/lib/brace'
], function (
    Brace
) {
    "use strict";
    var IssueTypeModel = Brace.Model.extend({
        namedAttributes: {
            id: "string",
            name: "string",
            description: "string",
            iconUrl: "string",
            subtask: "boolean"
        }
    });

    return IssueTypeModel;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/issueTypes.js' */
define('jira/inline-issue-create/entities/issue-types', [
    'jira/inline-issue-create/entities/possible-values',
    'jira/inline-issue-create/entities/issue-type'
], function (
    PossibleValues,
    IssueTypeModel
) {
    "use strict";

    return PossibleValues.extend({
        model: IssueTypeModel,
        getEntityName: function () {
            return "issuetype";
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/project.js' */
define('jira/inline-issue-create/entities/project', [
    'jira/inline-issue-create/lib/brace'
], function (
    Brace
) {
    "use strict";
    return Brace.Model.extend({
        namedAttributes: {
            id: "number"
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/projects.js' */
define('jira/inline-issue-create/entities/projects', [
    'jira/inline-issue-create/entities/possible-values',
    'jira/inline-issue-create/entities/project'
], function (
    PossibleValues,
    ProjectModel
) {
    "use strict";

    return PossibleValues.extend({
        model: ProjectModel,
        comparator: function comparator(project) {
            return project.getId();
        },
        getEntityName: function () {
            return "project";
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/inlineIssue.js' */
define('jira/inline-issue-create/entities/inline-issue', [
    'jquery',
    'underscore',
    'jira/inline-issue-create/lib/brace'
], function (
    $,
    _,
    Brace
) {
    "use strict";

    return Brace.Model.extend({
        initialize: function initialize() {
            this._isSaving = false;
        },

        save: function save() {
            var instance = this;
            var deferred = $.ajax(AJS.contextPath() + "/rest/inline-create/1.0/issue", {
                data: JSON.stringify(this.toJSON()),
                contentType: 'application/json',
                type: 'POST'
            });
            this._isSaving = true;
            return deferred.always(function unmarkSending() {
                instance._isSaving = false;
            });
        },

        isSaving: function isSaving() {
            return this._isSaving;
        }
    });
});

;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/inlineBootstrap.js' */
define('jira/inline-issue-create/entities/inline-bootstrap', [
    'backbone',
    'jira/inline-issue-create/lib/brace',
    'jira/inline-issue-create/entities/projects',
    'jira/inline-issue-create/entities/issue-types'
], function (
    Backbone,
    Brace,
    ProjectsCollection,
    IssueTypesCollection
    ) {
    "use strict";

    return Brace.Model.extend({

        issueTypesCollectionType: IssueTypesCollection,
        projectsCollectionType: ProjectsCollection,

        namedAttributes: {
            hasCreateIssuePermission: "boolean",
            hasScheduleIssuePermission: "boolean"
        },

        initialize : function initialize(){
            this.issueTypes = new this.issueTypesCollectionType();
            this.projects = new this.projectsCollectionType();
        },

        url: function url() {
            var queries = _.map(this.jqls, function (jql) {return "query=" + encodeURIComponent(jql) + "&";});
            return AJS.contextPath() + "/rest/inline-create/1.0/context/bootstrap"+ "?".concat.apply("?", queries);
        },
        _initializeState: function _initializeState(attributes, options) {
            if (options && options.jqls) {
                this.jqls = options.jqls;
            } else {
                this.jqls = undefined;
            }

            this.fetching = false;
            this.initialized = false;
        },
        setJQLs: function setJQLs(jqls) {
            if (_.isEqual(this.jqls, jqls)) {
                return;
            }
            this.jqls = jqls;
            this.fetch({reset: true});
        },
        parse: function parse(response) {
            var instance = this;
            // SW-1051 - brace doesn't allow to pass extra attributes
            var issueTypes = _.map(response.issueTypes.values, function(issueType) {
                return _.pick(issueType, _.keys(instance.issueTypes.model.prototype.namedAttributes));
            });
            this.issueTypes.reset(issueTypes);

            var projects = _.map(response.projects.values, function(project) {
                return _.pick(project, _.keys(instance.projects.model.prototype.namedAttributes));
            });
            this.projects.reset(projects);

            return _.pick(response, "hasCreateIssuePermission", "hasScheduleIssuePermission");
        },
        fetch: function fetch(options) {
            var model = this;

            function triggerFetched() {
                model.fetching = false;
                model.initialized = true;
                JIRA.trace("inline.create.bootstrap.fetched");
            }

            options = options || {};
            if (options.success) {
                options.success = _.wrap(options.success, function successWrapper(originalSuccessHandler) {
                    triggerFetched();
                    return originalSuccessHandler.apply(model, Array.prototype.slice.call(arguments, 1));
                });
            } else {
                options.success = triggerFetched;
            }
            this.fetching = true;
            JIRA.trace("inline.create.bootstrap.fetching");
            return Backbone.Model.prototype.fetch.call(this, options);
        },
        isInitialized: function isInitialized() {
            return this.initialized;
        },
        isFetching: function isFetching() {
            return this.fetching;
        },
        fireWhenInitialized: function fireWhenInitialized(func) {
            if(this.isInitialized() && (!this.isFetching())){
                func();
            } else {
                this.listenToOnce(this, "sync", func);
            }
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/views/description.js' */
define('jira/inline-issue-create/views/description', [
    'jquery',
    'jira/inline-issue-create/lib/marionette'
], function (
    $,
    Marionette
) {
    "use strict";

    var DescriptionView = Marionette.ItemView.extend({
        template: JIRA.Templates.InlineIssueCreate.description,
        ui: {
            selectedIssueTypeName: '.iic-widget__description__selected-issue-type-name'
        },
        modelEvents: {
            "change:selectedIssueType": function onSelectedIssueTypeChange() {
                var name = (this.model.getSelectedIssueType() && this.model.getSelectedIssueType().getName()) || "";
                if (name) {
                    this.$el.removeClass("iic-widget__description_invisible");
                    this.ui.selectedIssueTypeName.text(name);
                } else {
                    this.$el.addClass("iic-widget__description_invisible");
                }
            }
        },
        serializeData: function serializeData() {
            var data = {};
            if (this.model.getSelectedIssueType()) {
                data = this.model.getSelectedIssueType().toJSON();
            }
            return {
                issueTypeName: data.name
            };
        },
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });

    return DescriptionView;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/views/issueTypeDropdown.js' */
define('jira/inline-issue-create/views/issue-type-dropdown', [
    'jquery',
    'jira/inline-issue-create/lib/marionette',
    'jira/inline-issue-create/views/issue-type-dropdown-item'
], function (
    $,
    Marionette,
    IssueTypeDropdownItemView
) {
    "use strict";

    var IssueTypesDropdown = Marionette.CompositeView.extend({
        childView: IssueTypeDropdownItemView,
        childViewOptions: function itemViewOptions(model, index) {
            return {
                model: model,
                dropdownModel: this.model
            };
        },
        template: JIRA.Templates.InlineIssueCreate.issueTypeSelector,
        childViewContainer: ".aui-list-truncate",
        ui: {
            trigger: '.iic-widget__issue-type-selector__trigger',
            issueTypeIcon: '.iic-widget__issue-type-selector__trigger img',
            issueTypeDropdown: '.iic-widget__issue-type-selector__dropdown'
        },
        events: {
            "focus @ui.trigger": function onTriggerFocus() {
                this.ui.trigger.click();
            }
        },
        modelEvents: {
            "change:selectedIssueType": function onSelectedIssueTypeChange() {
                if (this.model.getSelectedIssueType()) {
                    this.ui.issueTypeIcon.attr("src", this.model.getSelectedIssueType().getIconUrl());
                }
            },
            "change:lockState": function onLockStateChange(m, state) {
                this.render();
                if (state === this.model.constants.STATE_LOCK_SENDING) {
                    this.ui.trigger.attr("aria-disabled", true);
                } else {
                    this.ui.trigger.attr("aria-disabled", false);
                }
            }
        },
        onChildviewSelected: function onChildviewSelected(itemView){
            this.trigger("issueTypeSelected", itemView.model);
        },
        initialize: function initialize() {
            this.isDropdownShown = false;
            _.bindAll(this, 'onDropdownShow', 'onDropdownHide');
        },
        serializeData: function serializeData() {
            var data = {};
            if (this.model.getSelectedIssueType()) {
                data = this.model.getSelectedIssueType().toJSON();
            }

            return {
                widgetId: this.options.widgetId,
                isLocked: this.model.getLockState() !== this.model.constants.STATE_LOCK_UNLOCKED,
                issueTypeIconUrl: data.iconUrl
            };
        },
        onRender: function onRender() {
            this.unwrapTemplate();
            this.ui.issueTypeDropdown.on("aui-dropdown2-show", this.onDropdownShow);
            this.ui.issueTypeDropdown.on("aui-dropdown2-hide", this.onDropdownHide);
            if (this.isDropdownShown) {
                this.ui.trigger.click();
            }
        },
        onDropdownShow: function onDropdownShow() {
            this.couldYouPositionDropdownRelativelyToIssueTypeIconPleaseThankYouVeryMuch();

            this.isDropdownShown = true;

            // If the collection is currently fetching, we have to hide the dropdown so it dosen't show as empty.
            // We do it with a css change because we want everyone to think it is shown.
            // After the collection finishes fetching we can show the dropdown again as it will have items inside it
            if (this.collection.isFetching()) {
                this.ui.issueTypeDropdown.css("display", "none");
                this.listenToOnce(this.collection, "reset", function collectionFetched() {
                    // we need to make sure we still want to display the dropdown as the user
                    // could do some other action in the time between attaching this listener and it being fired
                    if (this.isDropdownShown) {
                        this.ui.issueTypeDropdown.css("display", "block");
                    }
                });
            }
        },
        onDropdownHide: function onDropdownHide() {
            this.ui.trigger.removeClass("iic-widget__issue-type-selector__trigger_opened-up");
            this.isDropdownShown = false;
        },
        calculateDropdownDirectionAndHeightPosition: function calculateDropdownDirectionAndHeightPosition(){
            var triggerHeight = this.ui.issueTypeIcon.outerHeight();
            var dropdownContentHeight = this.ui.issueTypeDropdown.outerHeight();
            if ($("body").outerHeight(true) < this.ui.issueTypeIcon.offset().top + triggerHeight + dropdownContentHeight) {
                return {
                    vAlignment: "top"
                };
            } else {
                return {
                    vAlignment: "bottom"
                };
            }
        },
        couldYouPositionDropdownRelativelyToIssueTypeIconPleaseThankYouVeryMuch: function positionDropdownRelativelyToIssueTypeIcon() {
            var $dropdown = this.ui.issueTypeDropdown;
            $dropdown.attr("style", "");

            // we don't want dorpdown to be attached to body so we put it back where it was
            $dropdown.appendTo(this.$el);

            var triggerPosition = this.ui.issueTypeIcon.position();
            var triggerHeight = this.ui.issueTypeIcon.outerHeight();
            var dropdownContentHeight = $dropdown.outerHeight();
            var position = this.calculateDropdownDirectionAndHeightPosition();
            var visibleDropdownContentHeight = position.limitHeight ? position.limitHeight : dropdownContentHeight;

            if (position.vAlignment === "top") {
                $dropdown.addClass("aui-dropdown2-alignment-top");
            } else {
                $dropdown.removeClass("aui-dropdown2-alignment-top");
            }

            $dropdown.attr({
                "data-dropdown2-alignment": "left",
                "aria-hidden": "false"
            }).css({
                display: "block",
                left: triggerPosition.left,
                top: ((position.vAlignment === "top") ? triggerPosition.top - visibleDropdownContentHeight : triggerPosition.top + triggerHeight) + "px"
            });

            if(position.limitHeight) {
                $dropdown.css({
                    "max-height": position.limitHeight + "px",
                    "overflow-y": "auto"
                });
            }

            if (position.vAlignment === "top") {
                this.ui.trigger.addClass("iic-widget__issue-type-selector__trigger_opened-up");
            }
        }
    });

    return IssueTypesDropdown;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/views/issueTypeDropdownItem.js' */
define('jira/inline-issue-create/views/issue-type-dropdown-item', [
    'jquery',
    'jira/inline-issue-create/lib/marionette'
], function (
    $,
    Marionette
) {
    "use strict";

    var ItemView = Marionette.ItemView.extend({
        template: JIRA.Templates.InlineIssueCreate.issueTypeSelectorItem,
        initialize: function initialize(options) {
            this.dropdownModel = options.dropdownModel;
        },
        events: {
            "click a": function onClick(e) {
                e.preventDefault();
                this.trigger("selected");
            }
        },
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });

    return ItemView;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/views/defaultTrigger.js' */
define('jira/inline-issue-create/views/default-trigger', [
    'jquery',
    'jira/inline-issue-create/lib/marionette'
], function (
    $,
    Marionette
) {
    "use strict";

    var DefaultTrigger = Marionette.ItemView.extend({
        template: JIRA.Templates.InlineIssueCreate.trigger,
        ui: {
            trigger: ' .iic-trigger'
        },
        events: {
            "click @ui.trigger": function onClick(e) {
                e.preventDefault();
                this.trigger("selected");
            }
        },
        initialize: function initialize(options) {
            this.widget = options.widget;

            this.listenTo(this.widget, "activated", this.hide);
            this.listenTo(this.widget, "deactivated", this.show);
        },
        onRender: function onRender() {
            this.unwrapTemplate();
            if (this.widget.model.getState() === this.widget.model.constants.STATE_ACTIVE) {
                this.hide();
            }
        },
        hide: function hide() {
            this.ui.trigger.addClass("iic-trigger_hidden");
        },
        show: function show() {
            this.ui.trigger.removeClass("iic-trigger_hidden");
        }
    });

    return DefaultTrigger;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/widget.js' */
define('jira/inline-issue-create/entities/widget-constants', [], function () {
    "use strict";

    var frozenObjectCanNotBeUnfrozenSoGTFO = {
        STATE_CLOSED: "STATE_CLOSED",
        STATE_ACTIVE: "STATE_ACTIVE",
        STATE_LOCK_TEMP_INACTIVE: "STATE_LOCK_TEMP_INACTIVE",
        STATE_LOCK_SENDING: "STATE_LOCK_SENDING",
        STATE_LOCK_PERM_INACTIVE: "STATE_LOCK_PERM_INACTIVE",
        STATE_LOCK_UNLOCKED: "STATE_LOCK_UNLOCKED"
    };
    Object.freeze(frozenObjectCanNotBeUnfrozenSoGTFO); // IE8 is dead!
    return frozenObjectCanNotBeUnfrozenSoGTFO;
});

define('jira/inline-issue-create/entities/widget', [
    'jira/inline-issue-create/lib/brace',
    'jira/inline-issue-create/entities/issue-types',
    'jira/inline-issue-create/entities/issue-type',
    'jira/inline-issue-create/entities/widget-constants'
], function (
    Brace,
    IssueTypesCollection,
    IssueTypeModel,
    WidgetConstants
) {
    "use strict";

    var SELECTED_ISSUE_TYPE_STORAGE_KEY = "iic.slectedIssueType";

    var constants = WidgetConstants;

    var WidgetModel = Brace.Model.extend({

        constants: constants,

        defaults: {
            state: constants.STATE_CLOSED,
            lockState: constants.STATE_LOCK_UNLOCKED
        },

        namedAttributes: {
            "summary": "",
            "selectedIssueType": IssueTypeModel,
            "issueTypes": IssueTypesCollection,
            "state": "",
            "lastState": "",
            "lockState": ""
        },
        initialize: function initialize(attributes) {
            var previouslySelectedIssueTypeJSON;
            var previouslySelectedIssueType;

            if (!attributes || !attributes.selectedIssueType) {
                if (localStorage) {
                    previouslySelectedIssueTypeJSON = JSON.parse(localStorage.getItem(SELECTED_ISSUE_TYPE_STORAGE_KEY)) || {};
                    previouslySelectedIssueTypeJSON = previouslySelectedIssueTypeJSON || {};
                    previouslySelectedIssueType = this.getIssueTypes() && this.getIssueTypes().find(function findIssue(issueType) {
                        return issueType.getId() === previouslySelectedIssueTypeJSON.id;
                    });
                }

                if (previouslySelectedIssueType) {
                    this.setSelectedIssueType(previouslySelectedIssueType);
                } else if (this.getIssueTypes()) {
                    this.setSelectedIssueType(this.getIssueTypes().at(0));
                }
            }

            this.on("change:selectedIssueType", function onSelectedIssueTypeChange(e) {
                var selectedIssueType = this.getSelectedIssueType();
                if (selectedIssueType) {
                    localStorage.setItem(SELECTED_ISSUE_TYPE_STORAGE_KEY, JSON.stringify(selectedIssueType.toJSON()));
                }
            });

            this.listenTo(this.getIssueTypes(), "reset", function onIssueTypesReset() {
                var selectedIssueTypeId = this.getSelectedIssueType() && this.getSelectedIssueType().getId();
                var currentlySelectedIssueTypeInTheCollection;

                if (!selectedIssueTypeId) {
                    selectedIssueTypeId = previouslySelectedIssueTypeJSON.id;
                }

                if (selectedIssueTypeId !== undefined) {
                    currentlySelectedIssueTypeInTheCollection = this.getIssueTypes().get(selectedIssueTypeId);
                    if (currentlySelectedIssueTypeInTheCollection) {
                        // make sure we use the model from the collection, not the one potentially populated from localStorage
                        this.setSelectedIssueType(currentlySelectedIssueTypeInTheCollection);
                    } else {
                        this.setSelectedIssueType(this.getIssueTypes().at(0));
                    }
                } else {
                    this.setSelectedIssueType(this.getIssueTypes().at(0));
                }

            });
        },
        changeState: function changeState(newState) {
            if (newState === this.getState()) {
                return;
            }
            this.setLastState(this.getState());
            this.setState(newState);
        },
        setSelectedIssueTypeIfAvailable: function setSelectedIssueTypeIfAvailable(issueTypeToSelect) {
            if (issueTypeToSelect) {
                var newIssueType = this.getIssueTypes().get(issueTypeToSelect.getId());
                if (newIssueType) {
                    this.setSelectedIssueType(newIssueType);
                }
            }
        },
        toIssueData: function toIssueData() {
            return {
                summary: this.getSummary(),
                issueTypeId: this.getSelectedIssueType() && this.getSelectedIssueType().getId()
            };
        }
    });

    return WidgetModel;
});

;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/views/widget.js' */
define('jira/inline-issue-create/views/widget', [
    'jquery',
    'underscore',
    'jira/inline-issue-create/lib/marionette',
    'jira/inline-issue-create/util'
], function (
    $,
    _,
    Marionette,
    util
) {
    "use strict";
    var ERROR_ANIMATION_LENGTH = 500;

    var WidgetView = Marionette.LayoutView.extend({
        template: JIRA.Templates.InlineIssueCreate.widget,

        regions: {
            issueTypeSelector: ".iic-widget__issue-type-selector-container",
            description: ".iic-widget__description-container"
        },
        ui: {
            summary: '.iic-widget__summary',
            more: '.iic-widget__more',
            cancel: '.iic-widget__cancel',
            form: '.iic-widget__form',
            withTitle: '[title]'
        },
        events: {
            "input @ui.summary": "onSummaryChange",
            "change @ui.summary": "onSummaryChange",
            "keyup @ui.summary": function(e) {
                var value = this.ui.summary.val();
                if (value.length > 255) {
                    this.ui.summary.val(value.substr(0, 255));
                }
                this.onSummaryChange(e);
            },
            "keydown @ui.summary": function onSummaryKeyboard(e) {
                var value = this.ui.summary.val();

                if (e.keyCode === util.keyCode.ENTER) {
                    e.preventDefault();
                    if (value !== "" && value.length <= 255) {
                        if (this.model.getLockState() === this.model.constants.STATE_LOCK_UNLOCKED) {
                            this.ui.summary.blur();
                            this.trigger("createIssue");
                        } else {
                            // TODO unhack this, should reference the appropriate view, probably raise an event to which the view would react
                            util.addClassAndRemoveOnAnimationEnd(this.$(".issue-type-selector"), "iic-error", ERROR_ANIMATION_LENGTH);
                        }
                    } else {
                        util.addClassAndRemoveOnAnimationEnd(this.ui.summary, "iic-error", ERROR_ANIMATION_LENGTH);
                    }
                } else if (e.keyCode === util.keyCode.ESC) {
                    this.trigger("deactivate", {
                        reason: "keypress"
                    });
                } else if (value.length > 255) {
                    util.addClassAndRemoveOnAnimationEnd(this.ui.summary, "iic-error", ERROR_ANIMATION_LENGTH);
                }
            },
            "click @ui.cancel": function onCancelClick(e) {
                e.preventDefault();
                if (this.model.getLockState() !== this.model.constants.STATE_LOCK_SENDING) {
                    this.trigger("deactivate", {
                        reason: "cancel"
                    });
                }

            },
            "click @ui.more": function onMoreClick(e) {
                e.preventDefault();
                if (this.model.getLockState() !== this.model.constants.STATE_LOCK_SENDING) {
                    this.trigger("openFullIssueDialog");
                }
            }
        },
        modelEvents: {
            "change:summary": function onSummaryChange() {
                this.ui.summary.val(this.model.getSummary());
                this.adjustSummarySize();
            },
            "change:state": function onStateChange(model, state) {
                if (state === this.model.constants.STATE_ACTIVE) {
                    this.activate();
                } else if (state === this.model.constants.STATE_CLOSED) {
                    this.deactivate();
                }
            },
            "change:lockState": function onStateLockChange(model, state) {
                if (this.ui.summary.prop) {
                    if (state === this.model.constants.STATE_LOCK_SENDING) {
                        this.ui.summary.prop("disabled", true);
                    } else {
                        this.ui.summary.prop("disabled", false);
                    }
                }
            }
        },
        initialize: function initialize(options) {
            this.cssClass = options.cssClass || "";
            this.listenTo(this.issueTypeSelector, "show", function () {
                this.listenTo(this.issueTypeSelector.currentView, "issueTypeSelected", function () {
                    this.focusSummary();
                });
            });

            _.bindAll(this, 'adjustSummarySize', "onBodyClick");
        },
        onClose: function onClose() {
            $(document).off("click.iic", this.onBodyClick);
        },
        onBodyClick: function onBodyClick(e) {
            // check if target is not the clicked element and hasn't it inside
            if (!this.$el.is(e.target) && this.$el.has(e.target).length === 0) {
                if (this.ui.summary.val() === "") {
                    this.trigger("deactivate", {
                        reason: "cancel"
                    });
                } else if (this.ui.summary.is(":focus")) {
                    // When clicking on issue in agile, even though cursor isn't in the textarea anymore,
                    // blur event isn't fired properly and technically textarea is still focused.
                    // This is why we have to blur it manually.
                    this.ui.summary.blur();
                }
            }
        },
        serializeData: function serializeData() {
            return {
                summary: this.model.getSummary(),
                cssClass: this.cssClass
            };
        },
        onRender: function onRender() {
            this.unwrapTemplate();
            this.ui.withTitle.tooltip({aria: true});

            var that = this;
            this.ui.summary.on('change cut paste drop keydown input',  function deferedAdjustSummarySize() {
                _.defer(that.adjustSummarySize);
            });

            // JAG renders sprint content detached from the DOM so we need to defer this until after it is attached
            _.defer(that.adjustSummarySize);

            this.ui.summary.placeholder();
            if (this.model.getState() === this.model.constants.STATE_ACTIVE) {
                this.activate();
            } else {
                this.deactivate();
            }
        },
        adjustSummarySize: function adjustSummarySize() {
            this.ui.summary.css('height', 'auto');
            var outerHeight = this.ui.summary.outerHeight();
            var scrollHeight = Math.max(outerHeight + this.ui.summary.prop('scrollHeight') - this.ui.summary.prop('clientHeight'), outerHeight);
            if (scrollHeight) {
                this.ui.summary.height(scrollHeight+'px');
            }
        },
        reset: function reset() {
            this.ui.summary.attr("style", "");
        },
        hide: function hide() {
            this.$el.addClass("iic-widget_hidden");
            $(document).off("click.iic", this.onBodyClick);
        },
        show: function show() {
            this.$el.removeClass("iic-widget_hidden");
            this.adjustSummarySize();

            // Add event handler to check if we can close the widget when users clicks outside of it.
            // We need to defer this because event bubbling would cause this to be immediately
            // executed when user clicks on the trigger to show the widget
            var instance = this;
            _.defer(function() {
                $(document).off("click.iic", instance.onBodyClick);
                $(document).on("click.iic", instance.onBodyClick);
            });
        },
        focusSummary: function focusSummary() {
            this.ui.summary.focus();
        },
        activate: function activate() {
            this.show();
            this.trigger("activated");
        },
        focus: function focus() {
            this.focusSummary();
            this.trigger("focused");
        },
        deactivate: function deactivate() {
            this.hide();
            this.trigger("deactivated");
        },
        onSummaryChange: function onSummaryChange(e) {
            this.trigger("summaryChanged", this.ui.summary.val());
        }
    });

    return WidgetView;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/inline-issue-create-widget.js' */
define('jira/inline-issue-create/widget', [
    'jquery',
    'underscore',
    'jira/inline-issue-create/lib/marionette',
    'jira/inline-issue-create/util',
    'jira/inline-issue-create/entities/widget',
    'jira/inline-issue-create/entities/issue-types',
    'jira/inline-issue-create/entities/projects',
    'jira/inline-issue-create/entities/inline-issue',
    'jira/inline-issue-create/views/widget',
    'jira/inline-issue-create/views/issue-type-dropdown',
    'jira/inline-issue-create/views/description',
    'jira/inline-issue-create/prefillable-create-issue-dialog',
    'jira/inline-issue-create/analytics'
], function (
    $,
    _,
    Marionette,
    Util,
    WidgetModel,
    IssueTypeCollection,
    ProjectsCollection,
    InlineIssue,
    WidgetLayout,
    IssueTypeDropdownView,
    DescriptionView,
    PrefillableCreateIssueDialog,
    Analytics
) {
    "use strict";

    /**
     * This function takes options hash and creates a options.fieldName field in options.context object.
     * If options.parameter is a function it is used as a constructor, if it is an object it is taken as-is.
     * If it is empty, the new object is created using default constructor.
     * @param options {parameter, context, fieldName, defaultOptions, defaultConstructor}
     */
    function createFieldFromParam(options) {
        if (_.isFunction(options.parameter)) {
            options.context[options.fieldName] = new options.parameter(options.defaultOptions);
        } else if (_.isObject(options.parameter)) {
            options.context[options.fieldName] = options.parameter;
        } else if (undefined === options.parameter) {
            options.context[options.fieldName] = new options.defaultConstructor(options.defaultOptions);
        }
    }

    var IicWidget = Marionette.Controller.extend({
        initialize: function initialize(options) {
            this._initializeComponents(options);

            if (options.jqls) {
                this.setCurrentJQLs(options.jqls);
            }
            if (options.container) {
                this.attach(options.container);
            }
            this._initializeEvents(options);
        },

        _initializeComponents: function _initializeComponents(options) {
            // createFieldFromParam wasn't used here as the constructor for collection takes 2 parameters
            if (_.isFunction(options.issueTypes)) {
                this.issueTypes = new options.issueTypes(undefined, {
                    jqls: options.jqls
                });
            } else if (_.isObject(options.issueTypes)) {
                this.issueTypes = options.issueTypes;
            } else {
                this.issueTypes = new IssueTypeCollection(undefined, {
                    jqls: options.jqls
                });
            }

            // createFieldFromParam wasn't used here as the constructor for collection takes 2 parameters
            if (_.isFunction(options.projects)) {
                this.projects = new options.projects(undefined, {
                    jqls: options.jqls
                });
            } else if (_.isObject(options.projects)) {
                this.projects = options.projects;
            } else {
                this.projects = new ProjectsCollection(undefined, {
                    jqls: options.jqls
                });
            }

            createFieldFromParam({
                context: this,
                fieldName: "model",
                defaultOptions: {
                    issueTypes: this.issueTypes
                },
                parameter: options.model,
                defaultConstructor: WidgetModel
            });

            createFieldFromParam({
                context: this,
                fieldName: "dropdownView",
                defaultOptions: {
                    model: this.model,
                    collection: this.issueTypes,
                    widgetId: this.model.cid
                },
                parameter: options.dropdownView,
                defaultConstructor: IssueTypeDropdownView
            });

            createFieldFromParam({
                context: this,
                fieldName: "descriptionView",
                defaultOptions: {
                    model: this.model,
                    widgetId: this.model.cid
                },
                parameter: options.descriptionView,
                defaultConstructor: DescriptionView
            });

            this.view = new WidgetLayout({
                model: this.model,
                cssClass: options.cssClass
            });
            this.analytics = new Analytics({widget: this});
            this._currentInlineIssue = undefined;
        },
        _initializeEvents: function _initializeEvents(options) {
            this.listenTo(this.view, "summaryChanged", function onSummaryChanged(newSummary) {
                this.model.setSummary(newSummary);
            });
            this.listenTo(this.view, "createIssue", this.createIssue);
            this.listenTo(this.view, "deactivate", this.deactivate);
            this.listenTo(this.view, "openFullIssueDialog", function onOpenFullIssueDialog() {
                this.trigger("openCreateIssueDialog", {reason: "manual"});
                this.openCreateIssueDialog();
            });
            this.listenTo(this.model, 'change:state', this.onStateChange);
            this.listenTo(this.model, 'change:lockState', this.onLockStateChange);
            this.listenTo(this.issueTypes, 'reset', this.checkWidgetLocked);
            this.listenTo(this.projects, 'reset', this.checkWidgetLocked);

            this.on("issueCreated", function resetSummaryOnIssueCreated() {
                this.model.setSummary("");
            });
            //kick off the world
            this.checkWidgetLocked();
        },
        render: function render() {
            //detaching regions as render would destroy all of them
            //we want to re-attach just after we'll rerender the view
            this.view.issueTypeSelector.attachView(undefined);
            this.view.description.attachView(undefined);
            this.view.render();

            this.view.issueTypeSelector.show(this.dropdownView);
            this.view.description.show(this.descriptionView);
            this.listenTo(this.dropdownView, "issueTypeSelected", function (selectedIssueTypeModel) {
                this.model.setSelectedIssueType(selectedIssueTypeModel);
            });
        },
        onStateChange: function (model, state) {
            if (state === this.model.constants.STATE_ACTIVE) {
                this.trigger('activated');
            } else if (state === this.model.constants.STATE_CLOSED) {
                this.trigger('deactivated');
            }
        },
        onLockStateChange: function onLockStateChange(model, lockState) {
            if (lockState === this.model.constants.STATE_LOCK_PERM_INACTIVE) {
                if (this.model.getState() === this.model.constants.STATE_ACTIVE) {
                    this.deactivate();
                }
            }
        },
        activate: function activate() {
            if (this.model.getLockState() !== this.model.constants.STATE_LOCK_PERM_INACTIVE) {
                this.model.changeState(this.model.constants.STATE_ACTIVE);
                return true;
            } else {
                return false;
            }
        },
        deactivate: function deactivate() {
            this.model.changeState(this.model.constants.STATE_CLOSED);
        },
        checkWidgetLocked: function checkWidgetLocked() {
            //are collections loading?
            if (this.issueTypes.isFetching() || !this.issueTypes.isInitialized()) {
                return this.model.setLockState(this.model.constants.STATE_LOCK_TEMP_INACTIVE);
            }
            if (this.projects.isFetching() || !this.projects.isInitialized()) {
                return this.model.setLockState(this.model.constants.STATE_LOCK_TEMP_INACTIVE);
            }
            //or maybe we are actually saving new issue
            if (this._currentInlineIssue && this._currentInlineIssue.isSaving()) {
                return this.model.setLockState(this.model.constants.STATE_LOCK_SENDING);
            }
            //are collections empty?
            if (!this.issueTypes.length) {
                return this.model.setLockState(this.model.constants.STATE_LOCK_PERM_INACTIVE);
            }
            if (this.projects.length !== 1) {
                return this.model.setLockState(this.model.constants.STATE_LOCK_PERM_INACTIVE);
            }
            //okay! we are good!
            this.model.setLockState(this.model.constants.STATE_LOCK_UNLOCKED);
        },
        focus: function focus() {
            this.view.focus();
        },
        reset: function reset() {
            this.model.setSummary("");
            this.view.reset();
        },
        attach: function attach(container) {
            var $widgetContainer = $(container);
            $widgetContainer.append(this.view.el);
        },
        setCurrentJQLs: function setCurrentJQLs(jqls) {
            this.jqls = jqls;
        },
        setSummary: function setSummary(newSummary) {
            this.model.setSummary(newSummary);
        },
        getSummary: function getSummary() {
            return this.model.getSummary();
        },
        setSelectedIssueTypeIfAvailable: function setSelectedIssueTypeIfAvailable(newIssueType) {
            this.model.setSelectedIssueTypeIfAvailable(newIssueType);
        },
        getSelectedIssueType: function getSelectedIssueType() {
            return this.model.getSelectedIssueType();
        },
        setOverrides: function setOverrides(overrides) {
            this.overrides = overrides;
        },
        createIssue: function createIssue() {
            var instance = this;
            //we need to _.clone objects allowing beforeIssueCreated to modify those data
            var data = {
                summary: this.model.getSummary(),
                contexts: this.jqls,
                issueTypeId: this.model.getSelectedIssueType().getId(),
                overrides: _.clone(this.overrides)
            };
            this.trigger("beforeIssueCreated", instance, data);

            //persist new issue
            this._currentInlineIssue = new InlineIssue(data);
            this._currentInlineIssue.save().done(function successInlineCreate(data) {
                instance.trigger("issueCreated", data.issue, data.prefilledFields, instance, {
                    source: "inline"
                });
                JIRA.trace("inline.create.issue.created");
            }).fail(function failureInlineCreate(response) {
                var dialogDataDeferred = new jQuery.Deferred();
                instance.openCreateIssueDialog(dialogDataDeferred);
                try {
                    var data = JSON.parse(response.responseText);
                    dialogDataDeferred.resolve({
                        errors: data.errors,
                        errorMessages: data.generalErrors,
                        prefilledFields: data.prefilledFields
                    });
                } catch (err) {
                    Util.error(instance, "Could not parse response: " + err, response);
                    var errorMessage = "Unfortunately, there is an internal communication error, so you must use the full dialog to create the issue. Please contact your administrator if this error keeps appearing.";
                    dialogDataDeferred.resolve({
                        errors: {},
                        errorMessages: [errorMessage],
                        prefilledFields: {}
                    });
                }


                instance.trigger("openCreateIssueDialog", {reason: "createFailed"});
            }).always(function checkStateAfterSending() {
                instance.checkWidgetLocked();
            });
            this.checkWidgetLocked();
        },
        openCreateIssueDialog: function openCreateIssueDialog(dialogDataDeferred) {
            var instance = this;
            var issueData = this.model.toIssueData();
            if (this.projects.size() === 1) {
                issueData.project = this.projects.at(0).toJSON();
            }
            var context = {
                summary: issueData.summary,
                contexts: this.jqls,
                issueTypeId: this.model.getSelectedIssueType() ? this.model.getSelectedIssueType() .getId() : undefined,
                overrides: _.clone(this.overrides)
            };
            this.trigger("beforeIssueCreated", instance, context);

            if (!dialogDataDeferred) {
                dialogDataDeferred = this._resolveInlineContext(context, instance);
            }

            var promiseForm = PrefillableCreateIssueDialog.createPrefillableCreateIssueForm(dialogDataDeferred.promise(), true);
            return promiseForm.pipe(function (form) {
                var dialog = form.asDialog();
                function triggerIssueCreated(e, issue) {
                    instance.trigger("issueCreated", issue, issue.fields, instance, {
                        source: "dialog"
                    });
                    JIRA.trace("inline.create.issue.created");
                }
                form.bind("initialized", function () {
                    this.unconfigurableForm.bind("issueCreated", triggerIssueCreated);
                    this.configurableForm.bind("issueCreated", triggerIssueCreated);
                });

                dialog.show();
                return dialog;
            });
        },
        _resolveInlineContext: function(context, instance) {
            var fieldValuesRetrieved = new jQuery.Deferred();
            var fieldValuesResolver = $.ajax(AJS.contextPath() + "/rest/inline-create/1.0/context/resolve", {
                data: JSON.stringify(context),
                contentType: 'application/json',
                type: 'POST'
            });
            fieldValuesResolver.done(function whenInitializedAndHasFields(data) {
                fieldValuesRetrieved.resolve({
                    prefilledFields: data.createIssueInput
                });
            }).fail(function whenFailedInitializingFields() {
                // very basic error recovery
                fieldValuesRetrieved.resolve({
                    prefilledFields: {
                        summary: context.summary ? context.summary : "",
                        issuetype: instance.model.getSelectedIssueType() ?
                            instance.model.getSelectedIssueType().getId() : undefined
                    }
                });
            });
            return fieldValuesRetrieved;
        }
    });

    return IicWidget;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/inline-issue-create-analytics.js' */
define('jira/inline-issue-create/analytics', [
    'jira/inline-issue-create/lib/marionette'
], function (
    Marionette
    ) {
    "use strict";

    return Marionette.Controller.extend({
        initialize: function initialize(options) {
            this.loadTimestamp = new Date().getTime();
            var widget = options.widget;
            this.widgetId = widget.model.cid.substring(1);

            this.listenTo(widget, "issueCreated", this.onIssueCreated);
            this.listenTo(widget, "openCreateIssueDialog", this.onOpenCreateIssueDialog);
            this.listenTo(widget, "activated", this.onActivated);
            this.listenTo(widget, "deactivated", this.onDeactivated);

        },
        triggerAnalytics: function triggerAnalytics(name, params) {
            var args = _.defaults({}, params, {
                instance: this.widgetId,
                timestarted: this.loadTimestamp
            });
            AJS.trigger("analyticsEvent", { name: "jira.inlinecreate." + name, data: args });
        },
        onOpenCreateIssueDialog: function onOpenCreateIssueDialog(args) {
            this.triggerAnalytics("openDialog", {
                reason: args.reason
            });
        },
        onIssueCreated: function onIssueCreated(issue, prefilledFields, widget, args) {
            if (args.source === "inline") {
                this.triggerAnalytics("issueCreatedInline");
            } else {
                this.triggerAnalytics("issueCreatedDialog");
            }
        },
        onDeactivated: function onDeactivated() {
            this.triggerAnalytics("deactivated");
        },
        onActivated: function onActivated() {
            this.triggerAnalytics("activated");
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/inline-issue-create-widget-group.js' */
define('jira/inline-issue-create/widget-group', [
    'jquery',
    'jira/inline-issue-create/lib/marionette',
    'jira/inline-issue-create/widget',
    'jira/inline-issue-create/entities/inline-bootstrap'
], function WidgetGroup(
    $,
    Marionette,
    IicWidget,
    InlineBootstrap
) {
    "use strict";

    var WidgetGroup = Marionette.Controller.extend({
        initialize: function initialize(options) {
            this.TriggerView = options.TriggerView;
            this.Widget = IicWidget;
            this.widgets = {};
            this.currentJQLs = undefined;
            this.createdCallback = options.createdCallback;
            this.activeWidget = undefined;
            this.inlineBootstrap = options.inlineBootstrap || new InlineBootstrap();
            this.widgetOptions = _.defaults(options.widgetOptions || {}, {
                issueTypes: this.inlineBootstrap.issueTypes,
                projects: this.inlineBootstrap.projects
            });
        },
        getWidget: function getWidget(id) {
            if (!this.widgets[id]) {
                this.widgets[id] = this._createNewWidget(id);
            }
            return this.widgets[id];
        },
        setCurrentJqls: function setCurrentJqls(jqls) {
            this.currentJQLs = jqls;
            _.each(this.widgets, function setWidgetJqls(w) {
                w.widget.setCurrentJQLs(jqls);
            });
            this.inlineBootstrap.setJQLs(jqls);
        },
        activateWidget: function activateWidget(widget) {
            if (this.activeWidget === widget) {
                widget.focus();
                return;
            }
            var previouslyActiveWidget = this.activeWidget;
            this.activeWidget = undefined;
            _.each(this.widgets, function deactivateWidget(w) {
                if (w !== widget) {
                    w.widget.deactivate();
                }
            });

            var isActivated = widget.activate();
            if (isActivated) {
                widget.focus();
                this.activeWidget = widget;
                this.trigger("widget:activated", widget, previouslyActiveWidget);

                if (previouslyActiveWidget) {
                    widget.setSummary(previouslyActiveWidget.getSummary());
                    widget.setSelectedIssueTypeIfAvailable(previouslyActiveWidget.getSelectedIssueType());
                    previouslyActiveWidget.reset();
                }
            }

            return isActivated;
        },
        _createNewWidget: function _createNewWidget(id) {
            var manager = this;

            var widget = new this.Widget(this.widgetOptions);
            widget.on("deactivated", function onWidgetDeactivated() {
                if (manager.activeWidget === widget) {
                    manager.activeWidget = undefined;
                    widget.reset();
                }
            });

            if (this.createdCallback) {
                this.createdCallback(widget, id);
            }

            if (this.currentJQLs) {
                widget.setCurrentJQLs(this.currentJQLs);
            }

            var trigger = new manager.TriggerView({
                widget: widget
            });

            trigger.on("selected", function () {
                manager.activateWidget(widget);
            });

            return {
                widget: widget,
                trigger: trigger,
                render: function render($element) {
                    trigger.render();
                    $element.append(trigger.$el);
                    widget.attach(trigger.$el);
                    widget.render();
                    manager.trigger("widget:rendered", widget, trigger, $element);
                }
            };
        }
    });

    return WidgetGroup;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:inline-issue-create', location = 'inline-issue-create/InlineIssueCreate.js' */
define("jira/components/inline-issue-create", [
    "jira/components/libs/marionette-2.1.0",
    "jira/inline-issue-create/widget",
    "jira/inline-issue-create/views/default-trigger",
    "jira/inline-issue-create/entities/inline-bootstrap",
    "underscore"
], function(
    Marionette,
    Widget,
    Trigger,
    Bootstrap,
    _
) {
    "use strict";

    return Marionette.Object.extend({
        _buildBootstrap: function(){
            this.bootstrap = new Bootstrap();
            this.listenTo(this.bootstrap, {
                "sync": function() {
                    this.widget.setCurrentJQLs(this.bootstrap.jqls);
                }
            });
        },

        _buildWidget: function() {
            this.widget = new Widget({
                issueTypes: this.bootstrap.issueTypes,
                projects: this.bootstrap.projects
            });
            this.listenTo(this.widget, {
                "issueCreated": function(issue, fields){
                    this.trigger("issueCreated", {
                        issue: issue,
                        fields: fields
                    });
                },
                "activated": function(){
                    this.trigger("activated");
                },
                "deactivated": function(){
                    this.trigger("deactivated");
                }
            });
        },

        _buildTrigger: function() {
            this.widgetTrigger = new Trigger({
                widget: this.widget
            });
            this.listenTo(this.widgetTrigger, {
                "selected": function () {
                    this.activate();
                    this.trigger("inlineIssueCreateOpened");
                }
            });
        },

        initialize: function() {
            this._buildBootstrap();
            this._buildWidget();
            this._buildTrigger();
            this.render();
        },

        setJQL: function(jql) {
            this.bootstrap.setJQLs([jql]);
        },

        render: function() {
            this.widgetTrigger.render();
            this.widget.render();
        },

        show: function(el) {
            this.render();
            el.append(this.widgetTrigger.$el);
            this.widget.attach(el);
        },

        activate: function() {
            if (this.bootstrap.projects.length) {
                var isActivated = this.widget.activate();
                if (isActivated) {
                    this.widget.focus();
                }
            } else {
                this.widget.openCreateIssueDialog();
            }
        },

        activateWithJQL: function(jql) {
            this.bootstrap.jqls = [jql];
            this.bootstrap.fetch({reset: true}).done(_.bind(function() {
                if (this.bootstrap.projects.length) {
                    var isActivated = this.widget.activate();
                    if (isActivated) {
                        this.widget.focus();
                    }
                }
            }, this));
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/SimpleIssueList.js' */
define("jira/components/simpleissuelist", [
    "jira/components/simpleissuelist/controllers/list",
    "jira/components/simpleissuelist/services/api",
    "jira/components/simpleissuelist/services/inline-issue-create",
    "jira/components/libs/marionette-2.1.0",
    "jira/components/libs/underscore",
    "jquery"
], function(
    ControllerList,
    ServiceAPI,
    InlineIssueCreate,
    Marionette,
    _,
    jQuery
) {
    "use strict";

    return Marionette.Object.extend({
        initialize: function() {
            if (this.options.displayInlineIssueCreate) {
                this.inlineIssueCreate = new InlineIssueCreate();
                this.listenTo(this.inlineIssueCreate, {
                    "issueCreated": function(issueInfo) {
                        this.trigger("issueCreated", issueInfo);
                    },
                    "activated deactivated": function() {
                        // We need to defer this because the Inline Issue Create component
                        // trigger those events *before* it is actually activated or deactivated
                        _.defer(_.bind(function() {
                            this.list.adjustSize();
                        }, this));
                    }
                });
            }
            
            this.list = new ControllerList({
                baseURL: this.options.baseURL,
                inlineIssueCreate: this.inlineIssueCreate
            });
            this.listenTo(this.list, {
                "goToPreviousPage": function() {
                    this.trigger("list:pagination");
                    this.searchResults.jumpToPage("prev");
                },
                "goToNextPage": function() {
                    this.trigger("list:pagination");
                    this.searchResults.jumpToPage("next");
                },
                "goToPage": function(page) {
                    this.trigger("list:pagination");
                    this.searchResults.jumpToPage(page);
                },
                "refresh": function() {
                    this.trigger('refresh');
                },
                "selectIssue": function(event) {
                    this.trigger("list:select", {
                        id: event.id,
                        key: event.key,
                        absolutePosition: this.searchResults.getPositionOfIssueInSearchResults(event.id),
                        relativePosition: this.searchResults.getPositionOfIssueInPage(event.id)
                    });
                    this.searchResults.select(event.id);
                },
                "sort": function(jql) {
                    this.trigger('sort', jql);
                },
                "update": function() {
                    this.trigger("update");
                }
            });
            ServiceAPI.init(this);
        },

        load: function (searchResults, issueIdOrKey) {
            if (this.searchResults) {
                this.stopListening(this.searchResults);
                delete this.searchResults;
            }

            this.searchResults = searchResults;
            if (this.options.displayInlineIssueCreate) {
                this.inlineIssueCreate.setJQL(this.searchResults.jql);
            }

            this.listenTo(this.searchResults, {
                "before:loadpage": function() {
                    this.trigger("before:loadpage");
                },
                "error:loadpage": function(errorInfo) {
                    this.trigger("error:loadpage", errorInfo);
                },
                "reset": function () {
                    this.list.update(this.searchResults);
                },
                "unselect": function (unselectedModel) {
                    this.list.unselectIssue(unselectedModel.get("id"));
                },
                "select": function (selectedModel) {
                    var modelId = selectedModel.get("id") || null;
                    if (modelId) {
                        this.list.selectIssue(selectedModel.get("id"));
                    }
                    this.trigger("select", {
                        id: modelId,
                        key: selectedModel.get('key')
                    });
                },
                "change": function (model) {
                    this.list.updateIssue(model);
                }
            });

            if (issueIdOrKey) {
                // If we are looking for a specific key, jump to the page containing that key
                searchResults.jumpToPageForIssue(issueIdOrKey);
            } else {
                // If we are not looking for a specific key, just load the first page
                searchResults.jumpToPage("first");
            }
        },

        show: function(el) {
            this.list.render({
                el: el
            });
        },

        selectNext: function() {
            if (!this.searchResults) return;
            return this.searchResults.selectNext();
        },

        selectPrevious: function() {
            if (!this.searchResults) return;
            return this.searchResults.selectPrev();
        },

        selectIssue: function(issueId) {
            this.searchResults.select(issueId);
        },

        _getIssueById: function(issueId) {
            if (!this.searchResults) return;
            return this.searchResults.get(issueId);
        },

        refreshIssue: function(issueId) {
            var model = this._getIssueById(issueId);
            if (!model) return;

            model.fetch();
        },

        updateIssue: function(issueId, data) {
            var model = this._getIssueById(issueId);
            if (!model) return;
            model.set(data);
        },

        adjustSize: function() {
            this.list.adjustSize();
        },

        disableIssue: function(issueId) {
            var model = this._getIssueById(issueId);
            if (!model) return;

            model.set("inaccessible", true);
        },

        removeIssue: function(issueId){
            var model = this._getIssueById(issueId);
            if (!model) return new jQuery.Deferred().reject().promise();

            return this.searchResults.removeAndUpdateSelectionIfNeeded(model);
        },

        onDestroy: function() {
            this.list.destroy();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/controllers/List.js' */
define("jira/components/simpleissuelist/controllers/list", [
    "jira/components/simpleissuelist/views/pagination",
    "jira/components/simpleissuelist/views/issuelist",
    "jira/components/simpleissuelist/views/endstablesearch",
    "jira/components/simpleissuelist/views/layout",
    "jira/components/simpleissuelist/views/loading",
    "jira/components/simpleissuelist/views/refresh",
    "jira/components/libs/marionette-2.1.0",
    "jira/components/orderby"
], function(
    Pagination,
    IssueList,
    EndStableSearch,
    Layout,
    Loading,
    Refresh,
    Marionette,
    OrderBy
) {
    "use strict";

    return Marionette.ViewManager.extend({
        _buildPagination: function() {
            return this.buildView("pagination", function() {
                var view = new Pagination({
                    baseURL: this.baseURL
                });
                this.listenTo(view, {
                    "prev": function() {
                        this.trigger("goToPreviousPage");
                    },
                    "next": function() {
                        this.trigger("goToNextPage");
                    },
                    "goto": function(page) {
                        this.trigger("goToPage", page);
                    }
                });
                return view;
            });
        },

        _buildList: function() {
            return this.buildView("list", function() {
                var view = new IssueList();
                this.listenTo(view, {
                    "childview:select": function (childview) {
                        var model = childview.model;
                        this.trigger("selectIssue", {
                            id: model.get('id'),
                            key: model.get('key')
                        });
                    },
                    "update": function () {
                        this.trigger("update");
                    }
                });
                return view;
            });
        },

        _buildEndStableSearch: function() {
            return this.buildView("endOfStableSearch", function() {
                return new EndStableSearch();
            });
        },

        _buildRefresh: function(){
            return this.buildView("refresh", function() {
                var refresh = new Refresh();
                this.listenTo(refresh, {
                    "refresh": function () {
                        this.trigger("refresh");
                    }
                });
                return refresh;
            });
        },

        _buildLayout: function() {
            return this.buildView("layout", function() {
                var view = new Layout();
                this.listenTo(view, {
                    "render": function () {
                        // Render the sub-views
                        this.getView("layout").getRegion("pagination").show(this.getView("pagination"));
                        this.getView("layout").getRegion("searchResults").show(this.getView("list"));
                        this.getView("layout").getRegion("refresh").show(this.getView("refresh"));

                        // OrderBy is a special case, as it is not a view but an external component
                        this.getView("layout").getRegion("orderBy")._ensureElement();
                        this.orderBy.setElement(this.getView("layout").getRegion("orderBy").$el);
                        this.orderBy.render();

                        if (this.inlineIssueCreate) {
                            this.getView("layout").inlineIssueCreateContainer._ensureElement();
                            this.inlineIssueCreate.show(this.getView("layout").inlineIssueCreateContainer.$el);
                        }
                    }
                });
                return view;
            });
        },

        _buildOrderBy: function() {
            this.orderBy = OrderBy.create();

            this.orderBy.onSort(function(jql) {
                this.trigger("sort", jql);
            }, this);

            return this.orderBy;
        },

        _buildViews: function () {
            // Build the views
            this._buildLayout();
            this._buildPagination();
            this._buildList();
            this._buildRefresh();
            this._buildEndStableSearch();

            // Render the layout
            this.getView("layout").render();
        },

        initialize: function(options) {
            // As OrderBy is not an internal view, we can create and reuse it when needed.
            this._buildOrderBy();
            this.baseURL = options.baseURL;
            this.inlineIssueCreate = options.inlineIssueCreate;
            this._buildViews();
        },

        render: function(options) {
            options = options || {};
            var el = options.el;    
            el.append(this.getView("layout").$el);
            this.getView("layout").setElement(el);
        },

        onDestroy: function() {
            this.hideView("layout");
        },

        update: function(searchResults) {
            // Display the EndOfStableSearch message if needed
            if (searchResults.isAtTheEndOfStableSearch()) {
                this.getView("layout").getRegion("endOfStableMessageContainer").show(this.getView("endOfStableSearch"));
            } else {
                this.getView("layout").getRegion("endOfStableMessageContainer").empty();
            }

            // Update the views with the search results
            this.getView("list").update(searchResults);
            this.getView("refresh").render();
            this.getView("pagination").update(searchResults);
            this.orderBy.setElement(this.getView("layout").getRegion("orderBy").$el);
            this.orderBy.render();
            this.orderBy.setJql(searchResults.jql);
            
            if (this.inlineIssueCreate) {
                this.inlineIssueCreate.render();
            }

            // Make sure everything fits on the screen
            this.adjustSize();
        },

        hideLoading: function () {
            this.hideView("loading");
        },

        showLoading: function() {
            this.showView("loading", function () {
                var view = new Loading();
                this.listenTo(view, {
                    "render": function () {
                        this.getView("layout").$el.prepend(view.$el);
                    }
                });
                return view;
            });
        },

        updateIssue: function(model) {
            this.getView("list").updateIssue(model);
        },

        unselectIssue: function(issueId) {
            this.getView("list").unselectIssue(issueId);
        },

        selectIssue: function(issueId) {
            this.getView("list").selectIssue(issueId);
        },

        adjustSize: function() {
            if (!this.getView("layout")) return;
            if (!this.getView("list")) return;

            var listPanel = this.getView("layout").ui.listPanel;
            var listContent = this.getView("list").$el;
            var paginationContainer = this.getView("layout").getRegion("pagination").$el;

            var offsetTop = listContent.offset().top + listPanel.scrollTop();
            var paginationHeight = (paginationContainer ? paginationContainer.outerHeight() : 0);
            var windowHeight = window.innerHeight;
            var endOfStableSearchMessageHeight = ( !this.getView("endOfStableSearch") ? 0 : this.getView("endOfStableSearch").$el.outerHeight());
            var inlineIssueCreateHeight = this.getView("layout").inlineIssueCreateContainer.$el.outerHeight() || 0;

            listPanel.css("height", windowHeight - offsetTop - endOfStableSearchMessageHeight - paginationHeight - inlineIssueCreateHeight);

            this.getView("list").scrollSelectedIssueIntoView();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/services/API.js' */
define("jira/components/simpleissuelist/services/api", [

], function(

) {
    "use strict";

    return {
        init: function(simpleIssueList) {
            AJS.namespace("JIRA.API.Issues");

            JIRA.API.Issues.nextIssue = function() {
                simpleIssueList.selectNext();
            };

            JIRA.API.Issues.previousIssue = function() {
                simpleIssueList.selectPrevious();
            };
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/services/InlineIssueCreate.js' */
define("jira/components/simpleissuelist/services/inline-issue-create", [
    "jira/components/inline-issue-create"
], function(
    InlineIssueCreate
) {
    "use strict";

    return InlineIssueCreate;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/endofstablesearch.soy' */
// This file was automatically generated from endofstablesearch.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.SimpleIssueList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.SimpleIssueList == 'undefined') { JIRA.Components.SimpleIssueList = {}; }
if (typeof JIRA.Components.SimpleIssueList.Templates == 'undefined') { JIRA.Components.SimpleIssueList.Templates = {}; }


JIRA.Components.SimpleIssueList.Templates.endStableSearch = function(opt_data, opt_ignored) {
  return '<div class="end-of-stable-message"><p>' + soy.$$escapeHtml("Too many search results to display. Refine your search criteria and try again.") + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.endStableSearch.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.endStableSearch';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/issue.soy' */
// This file was automatically generated from issue.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.SimpleIssueList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.SimpleIssueList == 'undefined') { JIRA.Components.SimpleIssueList = {}; }
if (typeof JIRA.Components.SimpleIssueList.Templates == 'undefined') { JIRA.Components.SimpleIssueList.Templates = {}; }


JIRA.Components.SimpleIssueList.Templates.issue = function(opt_data, opt_ignored) {
  return '<li title="' + soy.$$escapeHtml(opt_data.summary) + '" data-key="' + soy.$$escapeHtml(opt_data.key) + '"><a class="splitview-issue-link" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.key) + '"><span class="issue-link-key"><img height="16" width="16" alt="' + soy.$$escapeHtml(opt_data.typeName) + '" title="' + soy.$$escapeHtml(opt_data.typeName) + ' - ' + soy.$$escapeHtml(opt_data.typeDescription) + '" src="' + soy.$$escapeHtml(opt_data.typeIcon) + '" />&nbsp;' + soy.$$escapeHtml(opt_data.key) + '</span><span class="issue-link-summary">' + soy.$$escapeHtml(opt_data.summary) + '</span></a></li>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.issue.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.issue';
}


JIRA.Components.SimpleIssueList.Templates.inaccessibleIssue = function(opt_data, opt_ignored) {
  return '<li class="inaccessible-issue" data-key="' + soy.$$escapeHtml(opt_data.key) + '">' + soy.$$escapeHtml("This issue can no longer be opened") + '</li>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.inaccessibleIssue.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.inaccessibleIssue';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/issuelist.soy' */
// This file was automatically generated from issuelist.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.SimpleIssueList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.SimpleIssueList == 'undefined') { JIRA.Components.SimpleIssueList = {}; }
if (typeof JIRA.Components.SimpleIssueList.Templates == 'undefined') { JIRA.Components.SimpleIssueList.Templates = {}; }


JIRA.Components.SimpleIssueList.Templates.issueList = function(opt_data, opt_ignored) {
  return '<div class="list-content"><ol class="issue-list"></ol></div>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.issueList.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.issueList';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/layout.soy' */
// This file was automatically generated from layout.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.SimpleIssueList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.SimpleIssueList == 'undefined') { JIRA.Components.SimpleIssueList = {}; }
if (typeof JIRA.Components.SimpleIssueList.Templates == 'undefined') { JIRA.Components.SimpleIssueList.Templates = {}; }


JIRA.Components.SimpleIssueList.Templates.layout = function(opt_data, opt_ignored) {
  return '<div class="simple-issue-list"><div class="list-panel"><div class="list-ordering"></div><div class="search-results"></div></div><div class="end-of-stable-message-container"></div><div class="inline-issue-create-container"></div><div class="aui-group pagination-view count-pagination"><div class="refresh-container aui-item"></div><div class="pagination-container aui-item"></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.layout.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.layout';
}


JIRA.Components.SimpleIssueList.Templates.loading = function(opt_data, opt_ignored) {
  return '<div class="loading"></div>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.loading.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.loading';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/pagination.soy' */
// This file was automatically generated from pagination.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.SimpleIssueList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.SimpleIssueList == 'undefined') { JIRA.Components.SimpleIssueList = {}; }
if (typeof JIRA.Components.SimpleIssueList.Templates == 'undefined') { JIRA.Components.SimpleIssueList.Templates = {}; }


JIRA.Components.SimpleIssueList.Templates.pagination = function(opt_data, opt_ignored) {
  var output = '<div class="pagination" data-displayable-total="' + soy.$$escapeHtml(opt_data.displayableTotal) + '">';
  var MAX_PAGES_DISPLAYED__soy6 = 5;
  var lastPage__soy7 = Math.floor((opt_data.displayableTotal - 1) / opt_data.pageSize);
  var pageNumber__soy8 = Math.floor(opt_data.startIndex / opt_data.pageSize);
  var urlFragment__soy9 = '' + ((opt_data.hasQueryString) ? soy.$$filterNoAutoescape(opt_data.searchQuery) + '&startIndex=' : soy.$$filterNoAutoescape(opt_data.searchQuery) + '?startIndex=');
  var prevStartIndex__soy19 = opt_data.startIndex - opt_data.pageSize;
  output += ((prevStartIndex__soy19 >= 0) ? '<a href="' + soy.$$escapeHtml(urlFragment__soy9) + soy.$$escapeHtml(prevStartIndex__soy19) + '" data-start-index="' + soy.$$escapeHtml(prevStartIndex__soy19) + '" class="icon icon-previous" title="' + soy.$$escapeHtml(AJS.format("Go to page {0} of {1}",pageNumber__soy8,lastPage__soy7 + 1)) + '"><span>&lt;&lt; ' + soy.$$escapeHtml("Previous") + '</span></a>' : '') + JIRA.Components.SimpleIssueList.Templates.numberLinksLogicBranch({startPage: pageNumber__soy8 - Math.floor(MAX_PAGES_DISPLAYED__soy6 / 2), endPage: pageNumber__soy8 + Math.floor(MAX_PAGES_DISPLAYED__soy6 / 2), lastPage: lastPage__soy7, urlFragment: urlFragment__soy9, currentPage: pageNumber__soy8 + 1, maxPagesDisplayed: MAX_PAGES_DISPLAYED__soy6, pageSize: opt_data.pageSize, displayableTotal: opt_data.displayableTotal});
  var nextStartIndex__soy41 = Math.min(opt_data.startIndex + opt_data.pageSize, opt_data.displayableTotal);
  output += ((nextStartIndex__soy41 < opt_data.displayableTotal) ? '<a href="' + soy.$$escapeHtml(urlFragment__soy9) + soy.$$escapeHtml(nextStartIndex__soy41) + '" data-start-index="' + soy.$$escapeHtml(nextStartIndex__soy41) + '" class="icon icon-next" title="' + soy.$$escapeHtml(AJS.format("Go to page {0} of {1}",pageNumber__soy8 + 2,lastPage__soy7 + 1)) + '"><span>' + soy.$$escapeHtml("Next") + ' &gt;&gt;</span></a>' : '') + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.pagination.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.pagination';
}


JIRA.Components.SimpleIssueList.Templates.numberLinksLogicBranch = function(opt_data, opt_ignored) {
  return '' + ((opt_data.lastPage < opt_data.maxPagesDisplayed) ? JIRA.Components.SimpleIssueList.Templates.numberLinks(soy.$$augmentMap(opt_data, {startPage: 0, endPage: opt_data.lastPage})) : (opt_data.startPage < 0) ? JIRA.Components.SimpleIssueList.Templates.numberLinks(soy.$$augmentMap(opt_data, {startPage: 0, endPage: opt_data.endPage - opt_data.startPage})) : (opt_data.endPage > opt_data.lastPage) ? JIRA.Components.SimpleIssueList.Templates.numberLinks(soy.$$augmentMap(opt_data, {startPage: opt_data.startPage - (opt_data.endPage - opt_data.lastPage), endPage: opt_data.lastPage})) : JIRA.Components.SimpleIssueList.Templates.numberLinks(opt_data));
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.numberLinksLogicBranch.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.numberLinksLogicBranch';
}


JIRA.Components.SimpleIssueList.Templates.numberLinks = function(opt_data, opt_ignored) {
  var output = '';
  var size__soy76 = opt_data.endPage - opt_data.startPage + 1;
  if (size__soy76 > 1) {
    var iLimit79 = Math.round(size__soy76);
    for (var i79 = 0; i79 < iLimit79; i79++) {
      var pageIndex__soy80 = i79 + opt_data.startPage;
      var pageNumber__soy81 = pageIndex__soy80 + 1;
      var pageStartIndex__soy82 = pageIndex__soy80 * opt_data.pageSize;
      var pageEndIndex__soy83 = Math.min(pageStartIndex__soy82 + opt_data.pageSize, opt_data.displayableTotal);
      var pageBoundaries__soy84 = '' + soy.$$escapeHtml(AJS.format("Issues {0} - {1}",pageStartIndex__soy82 + 1,pageEndIndex__soy83));
      output += ' ' + ((pageNumber__soy81 == opt_data.currentPage) ? '<strong title="' + soy.$$escapeHtml(pageBoundaries__soy84) + '">' + soy.$$escapeHtml(pageNumber__soy81) + '</strong>' : '<a href="' + soy.$$escapeHtml(opt_data.urlFragment) + soy.$$escapeHtml(pageStartIndex__soy82) + '" data-page="' + soy.$$escapeHtml(pageNumber__soy81) + '" data-start-index="' + soy.$$escapeHtml(pageStartIndex__soy82) + '" title="' + soy.$$escapeHtml(pageBoundaries__soy84) + '">' + soy.$$escapeHtml(pageNumber__soy81) + '</a>');
    }
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.numberLinks.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.numberLinks';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/refresh.soy' */
// This file was automatically generated from refresh.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.SimpleIssueList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.SimpleIssueList == 'undefined') { JIRA.Components.SimpleIssueList = {}; }
if (typeof JIRA.Components.SimpleIssueList.Templates == 'undefined') { JIRA.Components.SimpleIssueList.Templates = {}; }


JIRA.Components.SimpleIssueList.Templates.refresh = function(opt_data, opt_ignored) {
  return '<a href="#" class="refresh-table" title="' + soy.$$escapeHtml("Refresh results") + '"><span class="aui-icon aui-icon-small aui-iconfont-refresh-small">' + soy.$$escapeHtml("Refresh results") + '</span></a>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.refresh.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.refresh';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/components/simpleissuelist/templates", function() {
    "use strict";

    return JIRA.Components.SimpleIssueList.Templates;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed.
 */
AJS.namespace("JIRA.Components.SimpleIssueList.Templates", null, require("jira/components/simpleissuelist/templates"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/EndStableSearch.js' */
define("jira/components/simpleissuelist/views/endstablesearch", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/simpleissuelist/templates"
], function(
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.endStableSearch
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/Issue.js' */
define("jira/components/simpleissuelist/views/issue", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/simpleissuelist/templates"
], function(
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.issue,

        ui: {
            link: 'a'
        },

        events: {
            'simpleClick': function (ev) {
                ev.preventDefault();
                this.trigger('select');
            }
        },

        serializeData: function() {
            var model = this.model;
            return {
                "id": model.get("id"),
                "key": model.get("key"),
                "summary": model.get("summary"),
                "typeName": model.get("type").name,
                "typeDescription": model.get("type").description,
                "typeIcon": model.get("type").iconUrl
            };
        },

        onRender: function() {
            this.unwrapTemplate();
        },

        highlight: function() {
            this.$el.addClass("focused");
            this.ui.link.focus();
            this.scrollIntoView();
        },

        unhighlight: function() {
            this.$el.removeClass("focused");
        },

        scrollIntoView: function() {
            this.$el.scrollIntoViewForAuto();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/InaccessibleIssue.js' */
define("jira/components/simpleissuelist/views/inaccessibleissue", [
    "jira/components/simpleissuelist/views/issue",
    "jira/components/simpleissuelist/templates"
], function(
    Issue,
    Templates
) {
    "use strict";

    return Issue.extend({
        template: Templates.inaccessibleIssue,

        triggers: {
            'click': "select"
        },

        serializeData: function() {
            var model = this.model;
            return {
                "key": model.get("key")
            };
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/IssueList.js' */
define("jira/components/simpleissuelist/views/issuelist", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/simpleissuelist/views/inaccessibleissue",
    "jira/components/simpleissuelist/views/issue",
    "jira/components/simpleissuelist/templates"
], function(
    Marionette,
    InaccessibleIssue,
    Issue,
    Templates
) {
    "use strict";

    return Marionette.CompositeView.extend({
        template: Templates.issueList,

        childViewContainer: "ol",

        getChildView: function(issue) {
            if (issue.get('inaccessible')) {
                return InaccessibleIssue;
            } else {
                return Issue;
            }
        },

        // Needs to be overwritten with noop because the default implementation
        // is to add some events to the collection when this view is initially
        // rendered, for handling cases like an item added or removed to/from
        // the collection. That case is not going to happen (as we always reset
        // the full collection), so those events are not necessary.
        _initialEvents: function() {},

        onUpdate: function() {
            // If this issue was already selected, highlight it again
            if (this.collection.selected) {
                var childView = this.children.findByModel(this.collection.selected);
                if (childView) {
                    childView.highlight();
                }
            }
        },

        onRender: function() {
            this.unwrapTemplate();
        },

        /**
         * Updates the list with new data.
         *
         * @param {JIRA.Components.Search.Results} collection Data to use
         */
        update: function(collection) {
            this.collection = collection;
            this.render();
            this.triggerMethod("update");
        },

        /**
         * Updates a single issue with new data
         *
         * @param {JIRA.Components.Search.Result} model
         */
        updateIssue: function(model) {
            var view = this.children.findByModel(model);

            // Destroy existing view
            if (!view) return;
            this.removeChildView(view);

            // Create the child view from scratch
            var ChildView = this.getChildView(model);
            var index = this.collection.indexOf(model);
            this.addChild(model, ChildView, index);

            this.triggerMethod("update");
        },

        /**
         * Unselects an issue, if exists
         *
         * @param {Number} issueId Issue to unselect
         */
        unselectIssue: function(issueId){
            // Depending on the network speed, this method could be called before having an actual collection.
            if (!this.collection) return;

            var model = this.collection.get(issueId);
            if (!model) return;

            var view = this.children.findByModel(model);
            if (!view) return;

            view.unhighlight();
        },

        /**
         * Selects an issue, if exists
         *
         * @param {Number} issueId Issue to select
         */
        selectIssue: function(issueId){
            // Depending on the network speed, this method could be called before having an actual collection.
            if (!this.collection) return;

            var model = this.collection.get(issueId);
            if (!model) return;

            var view = this.children.findByModel(model);
            if (!view) return;

            view.highlight();
        },

        scrollSelectedIssueIntoView: function() {
            // Depending on the network speed, this method could be called before having an actual collection.
            if (!this.collection) return;

            var selected = this.collection.selected;
            if (!selected) return;

            var view = this.children.findByModel(selected);
            if (!view) return;

            view.scrollIntoView();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/Layout.js' */
define("jira/components/simpleissuelist/views/layout", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/simpleissuelist/templates"
], function(
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.LayoutView.extend({
        template: Templates.layout,

        regions: {
            pagination: ".pagination-container",
            refresh: ".refresh-container",
            searchResults: ".search-results",
            orderBy: ".list-ordering",
            endOfStableMessageContainer: '.end-of-stable-message-container',
            inlineIssueCreateContainer: '.inline-issue-create-container'
        },

        ui: {
            listPanel: ".list-panel"
        },

        showLoading: function() {
            this.ui.listPanel.addClass("loading");
        },

        hideLoading: function() {
            this.ui.listPanel.removeClass("loading");
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/Loading.js' */
define("jira/components/simpleissuelist/views/loading", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/simpleissuelist/templates"
], function (
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.loading,

        onRender: function () {
            this.unwrapTemplate();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/Pagination.js' */
define("jira/components/simpleissuelist/views/pagination", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/libs/uri",
    "jira/components/simpleissuelist/templates"
], function(
    Marionette,
    URI,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.pagination,

        ui: {
            prev: ".icon-previous",
            next: ".icon-next",
            page: "a[data-page]"
        },

        triggers: {
            "click @ui.prev": "prev",
            "click @ui.next": "next"
        },

        onRender: function() {
            this.unwrapTemplate();
        },

        events: {
            "click @ui.page": function(e) {
                var val = e.target.getAttribute("data-page");
                e.preventDefault();
                this.trigger("goto", parseInt(val, 10) - 1);
            }
        },

        update: function(collection) {
            this.collection = collection;
            this.render();
        },

        serializeData: function() {
            if (!this.collection) return; //Because on the very first render, we don't have the collection yet.

            var url = new URI(this.options.baseURL);
            var hasQueryString = url.query().length > 0;

            return {
                startIndex: this.collection.state.pageSize * this.collection.state.currentPage,
                pageSize: this.collection.state.pageSize,
                searchQuery: url.toString(),
                hasQueryString: hasQueryString,
                displayableTotal: this.collection.state.totalRecords
            };
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/Refresh.js' */
define("jira/components/simpleissuelist/views/refresh", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/simpleissuelist/templates"
], function(
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.refresh,
        triggers: {
            "click": "refresh"
        },

        onRender: function() {
            this.unwrapTemplate();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:pager', location = 'pager/templates/pager.soy' */
// This file was automatically generated from pager.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.Pager.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.Pager == 'undefined') { JIRA.Components.Pager = {}; }
if (typeof JIRA.Components.Pager.Templates == 'undefined') { JIRA.Components.Pager.Templates = {}; }


JIRA.Components.Pager.Templates.Pager = function(opt_data, opt_ignored) {
  return '<ul class="pager"><li class="previous">' + ((opt_data.previousIssue && opt_data.position != 1) ? '<a data-id="' + soy.$$escapeHtml(opt_data.previousIssue.id) + '" data-key="' + soy.$$escapeHtml(opt_data.previousIssue.key) + '" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.previousIssue.key) + '" rel="' + soy.$$escapeHtml(opt_data.previousIssue.key) + '" title="' + soy.$$escapeHtml("Previous Issue") + ' \'' + soy.$$escapeHtml(opt_data.previousIssue.key) + '\'"><span class="icon icon-page-prev"><span>' + soy.$$escapeHtml("Previous Issue") + ' \'' + soy.$$escapeHtml(opt_data.previousIssue.key) + '\'</span></span></a>' : (opt_data.position && opt_data.resultCount) ? '<span class="icon icon-page-prev-deactivated" title="' + soy.$$escapeHtml("Not available - this is the first issue") + '"></span>' : '') + '</li><li class="showing">' + ((opt_data.position && opt_data.resultCount) ? soy.$$escapeHtml(AJS.format("{0} of {1}",opt_data.position,opt_data.resultCount)) : '') + '</li><li class="next">' + ((opt_data.nextIssue && opt_data.position != opt_data.resultCount) ? '<a data-id="' + soy.$$escapeHtml(opt_data.nextIssue.id) + '" data-key="' + soy.$$escapeHtml(opt_data.nextIssue.key) + '" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.nextIssue.key) + '" id="next-issue" rel="' + soy.$$escapeHtml(opt_data.nextIssue.key) + '" title="' + soy.$$escapeHtml("Next Issue") + ' \'' + soy.$$escapeHtml(opt_data.nextIssue.key) + '\'"><span class="icon icon-page-next"><span>' + soy.$$escapeHtml("Next Issue") + ' \'' + soy.$$escapeHtml(opt_data.nextIssue.key) + '\'</span></span></a>' : (opt_data.position && opt_data.resultCount) ? (opt_data.isAtTheEndOfStableSearch) ? '<span class="icon icon-page-next-deactivated" title="' + soy.$$escapeHtml(AJS.format("Whoa, you\x27\x27ve got quite a few issues there. We can show you the first {0}, but you should refine your search to return fewer issues.",opt_data.stableSearchCount)) + '"></span>' : '<span class="icon icon-page-next-deactivated" title="' + soy.$$escapeHtml("Not available - this is the last issue") + '"></span>' : '') + '</li></ul>';
};
if (goog.DEBUG) {
  JIRA.Components.Pager.Templates.Pager.soyTemplateName = 'JIRA.Components.Pager.Templates.Pager';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:pager', location = 'pager/templates/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/components/pager/templates", function() {
    "use strict";

    return JIRA.Components.Pager.Templates;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed.
 */
AJS.namespace("JIRA.Components.Pager.Templates", null, require("jira/components/pager/templates"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:pager', location = 'pager/views/PagerView.js' */
define("jira/components/pager/views/pager", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/pager/templates"
], function (
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        getTemplate: function() {
            if (this.searchResults && this.searchResults.selected) return Templates.Pager;
            else return false;
        },

        ui: {
            "next": ".next a",
            "previous": ".previous a",
            "nextIcon": ".next span.icon"
        },

        triggers: {
            "simpleClick @ui.next": "next",
            "simpleClick @ui.previous": "previous"
        },

        update: function(searchResults) {
            this.searchResults = searchResults;
            // Backbone usually delegates DOM events when the View is constructed, not when it is rendered.
            // As we have variable templates (i.e. the first time we render the view the template is likely
            // to be undefined), we need to re-delegate the events every time we render.
            this.undelegateEvents();
            this.render();
            this.delegateEvents();
        },

        onRender: function() {
            if(this.searchResults && this.searchResults.selected) {
                var lastIssue = this.searchResults.getIssueAtGlobalIndex(this.searchResults.allIssues.length - 1);

                if (lastIssue.id === this.searchResults.selected.id && this.searchResults.isAtTheEndOfStableSearch()) {
                    this.ui.nextIcon.tooltip({
                        gravity: 'ne'
                    });
                }
            }

            if (AJS.activeShortcuts) {
                if (AJS.activeShortcuts.j) { AJS.activeShortcuts.j._addShortcutTitle(this.$el.find(this.ui.nextIssue));}
                if (AJS.activeShortcuts.k) { AJS.activeShortcuts.k._addShortcutTitle(this.$el.find(this.ui.previousIssue));}
            }
        },

        serializeData: function() {
            var model = this.searchResults;

            var selected = model.selected;
            if (!selected) return;

            var currentIssuePosition = this.searchResults.getPositionOfIssueInSearchResults(this.searchResults.selected.id);
            var templateData = {
                position: currentIssuePosition + 1,
                resultCount: this.searchResults.getTotalIssuesInDb()
            };

            var nextIssue = this.searchResults.getIssueAtGlobalIndex(currentIssuePosition + 1);
            if (nextIssue) {
                templateData.nextIssue = {
                    id: nextIssue.id,
                    key: nextIssue.key
                };
            } else if (this.searchResults.isAtTheEndOfStableSearch()) {
                templateData.isAtTheEndOfStableSearch = true;
                templateData.stableSearchCount = this.searchResults.allIssues.length;
            }

            var previousIssue = this.searchResults.getIssueAtGlobalIndex(currentIssuePosition - 1);
            if (previousIssue) {
                templateData.previousIssue = {
                    id: previousIssue.id,
                    key: previousIssue.key
                };
            }

            return templateData;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:pager', location = 'pager/Pager.js' */
define("jira/components/pager", [
    "jira/components/pager/views/pager",
    "jira/components/libs/marionette-2.1.0"
], function (
    View,
    Marionette
) {
    "use strict";

    return Marionette.ViewManager.extend({
        _buildSearchResults: function(searchResults) {
            this._destroySearchResults();

            this.searchResults = searchResults;
            this.listenTo(this.searchResults, {
                "select reset": function () {
                    this.getView("view").update(this.searchResults);
                }
            });
        },

        _destroySearchResults: function() {
            if (!this.searchResults) return;

            this.stopListening(this.searchResults);
            delete this.searchResults;
        },

        _buildView: function() {
            this.buildView("view", function () {
                var view = new View({
                    el: this.el
                });
                this.listenTo(view, {
                    "next": function() {
                        this.trigger("next");
                    },
                    "previous": function() {
                        this.trigger("previous");
                    }
                });
                return view;
            });
        },

        initialize: function(options) {
            this.el = options.el;

            this._buildView();
        },

        onDestroy: function() {
            Marionette.ViewManager.prototype.onDestroy.call(this);
            this._destroySearchResults();
        },

        load: function(searchResults) {
            this._buildSearchResults(searchResults);
        },

        update: function(searchResults) {
            this.load(searchResults);
            this.getView("view").update(searchResults);
        },

        show: function(el) {
            this.hideView("view");
            this.showView("view", function () {
                var view = new View({
                    el: el
                });
                this.listenTo(view, {
                    "next": function() {
                        this.trigger("next");
                    },
                    "previous": function() {
                        this.trigger("previous");
                    }
                });
                return view;
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'lib/jquery.ui.sidebar.js' */
/*!
 * jQuery UI Sidebar
 * http://jqueryui.com
 *
 * Depends:
 *   jquery.ui.widget.js
 */
;(function($) {


    $.widget( "ui.sidebar",  {
        version: "0.1",

        /* defaults */
        options: {
            minWidth: function (ui) { return 50; },
            maxWidth: function (ui) { return window.innerWidth; },
            resize: $.noop,
            easeOff: 0
        },

        /**
         * @constructor
         */
        _create: function() {
            _.bindAll(this,
                "_handleDrag",
                "_persist",
                "_setContainment",
                "_setHandlePosition",
                "updatePosition");

            if (this.options.easeOff) {
                this.updatePosition = _.debounce(this.updatePosition, this.options.easeOff);
            }
            if (!this.options.id) {
                console.error("ui.sidebar: You must specify an id")
            }
            // Create the handle before restoring anything, as the restore operation could fire some events that
            // might end using the handle before it is created. JRADEV-20661
            this._addHandle();
            this._restore();
            $(window).resize(_.debounce(this.updatePosition, 30));
        },

        /**
         * Restores the sidebar to the user configured width
         * @private
         */
        _restore: function () {
            if (window.localStorage) {
                var width = localStorage.getItem("ui.sidebar." + this.options.id);
                if (width) {
                    this._setWidth(width);
                }
            }
        },

        /**
         * Persists the sidebar to the user configured width so it works across page refreshes.
         * @private
         */
        _persist: function () {
            if (window.localStorage) {
                localStorage.setItem("ui.sidebar." + this.options.id, this.element.outerWidth());
            }
        },

        /**
         * Sets the min & max width boundaries for dragging side bar
         * @private
         */
        _setContainment: function () {
            var windowHeight = window.innerHeight;
            this._elementLeft = this.element.offset().left;
            this._minLeft = this._elementLeft + this.options.minWidth(this);
            this._maxLeft = Math.max(this._minLeft, this._elementLeft + this.options.maxWidth(this));
            this.handle.draggable({containment: [this._minLeft, windowHeight,  this._maxLeft, windowHeight]});
        },

        /**\
         * Sets the width of sidebar
         * @param {Object} e
         * @param {Object} ui
         * @private
         */
        _handleDrag: function (e, ui) {
            var target = ui.position.left - this._elementLeft;
            this._setWidth(target, true);
        },

        _setWidth: function (target, force) {
            if (!force) {
                var maxWidth = this.options.maxWidth(this);
                var minWidth = this.options.minWidth(this);
                if (target > maxWidth) {
                    target = maxWidth
                } else if (target < minWidth) {
                    target = minWidth;
                }
            }
            // JRADEV-20949 Assume box-sizing is border-box, adjusting target width for padding/border.
            // The reason this.element is not box-sizing: border-box is because Safari does not respect this
            // with display: table-cell
            target -= this.element.outerWidth() - this.element.width();
            this.element.width(target);
            this.options.resize(target);
        },


        /**
         * Appends a drag handle next to the sidebar
         * @private
         */
        _addHandle: function () {
            var el = document.createElement("div");
            el.setAttribute("class", "ui-sidebar");
            this.handle = $(el).appendTo(this.element);
            this.handle.draggable({axis: "x", drag: this._handleDrag, stop: this._persist});
            this.handle.mousedown(this._setContainment);
            _.defer(this._setHandlePosition);
        },

        /**
         * Aligns the drag handler to the sidebar
         * @private
         */
        _setHandlePosition: function () {
            this._setContainment();
            if (this._minLeft === this._maxLeft) {
                this.handle.hide();
            } else {
                var elOffset = this.element.offset();
                var left = elOffset.left + this.element.outerWidth();
                this.handle.css({
                    top: elOffset.top,
                    left: left,
                    height: this.element.outerHeight()
                }).show();
            }
        },

        /**
         * Updates position of handle. You trigger this externally by jQuery(".sidebar").sidebar("updatePosition")
         */
        updatePosition: function () {
            this._setHandlePosition();
            this._setWidth(this.handle.offset().left - this._elementLeft);
            this._persist();
        }
    });

})( jQuery );
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/templates/detailslayout.soy' */
// This file was automatically generated from detailslayout.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.DetailsLayout.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.DetailsLayout == 'undefined') { JIRA.Components.DetailsLayout = {}; }
if (typeof JIRA.Components.DetailsLayout.Templates == 'undefined') { JIRA.Components.DetailsLayout.Templates = {}; }


JIRA.Components.DetailsLayout.Templates.container = function(opt_data, opt_ignored) {
  return '<div class="details-layout"></div>';
};
if (goog.DEBUG) {
  JIRA.Components.DetailsLayout.Templates.container.soyTemplateName = 'JIRA.Components.DetailsLayout.Templates.container';
}


JIRA.Components.DetailsLayout.Templates.layout = function(opt_data, opt_ignored) {
  return '<div class="aui-group split-view"><div class="aui-item list-results-panel"></div><div class="aui-item detail-panel"><div class="issue-container"></div><div class="tools-container"></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Components.DetailsLayout.Templates.layout.soyTemplateName = 'JIRA.Components.DetailsLayout.Templates.layout';
}


JIRA.Components.DetailsLayout.Templates.empty = function(opt_data, opt_ignored) {
  return '<div><div class="navigator-content empty-results"><div class="jira-adbox jira-adbox-medium no-results no-results-message"><h3>' + soy.$$escapeHtml("No issues were found to match your search") + '</h3><p class="no-results-hint">' + soy.$$filterNoAutoescape(AJS.format("Try modifying your search criteria or {0}creating a new issue{1}",'<a class="create-issue" href="' + "/jira" + '/secure/CreateIssue!default.jspa">','</a>')) + '</p></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Components.DetailsLayout.Templates.empty.soyTemplateName = 'JIRA.Components.DetailsLayout.Templates.empty';
}


JIRA.Components.DetailsLayout.Templates.loading = function(opt_data, opt_ignored) {
  return '<div class="loading"></div>';
};
if (goog.DEBUG) {
  JIRA.Components.DetailsLayout.Templates.loading.soyTemplateName = 'JIRA.Components.DetailsLayout.Templates.loading';
}


JIRA.Components.DetailsLayout.Templates.tools = function(opt_data, opt_ignored) {
  return '<div class="issue-tools"><div class="pager-container"></div>' + ((opt_data.showExpand) ? '<button title="' + soy.$$escapeHtml(AJS.format("Expand issue ( {0} )",opt_data.expandShortcutKey)) + '" class="aui-button aui-button-subtle expand"><span class="aui-icon aui-icon-small aui-iconfont-focus">' + soy.$$escapeHtml(AJS.format("Expand issue ( {0} )",opt_data.expandShortcutKey)) + '</span></button>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Components.DetailsLayout.Templates.tools.soyTemplateName = 'JIRA.Components.DetailsLayout.Templates.tools';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/templates/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/components/detailslayout/templates", function() {
    "use strict";

    return JIRA.Components.DetailsLayout.Templates;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed.
 */
AJS.namespace("JIRA.Components.DetailsLayout.Templates", null, require("jira/components/detailslayout/templates"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/controllers/Tools.js' */
define("jira/components/detailslayout/controllers/tools", ["require"], function(require) {
    "use strict";

    var Marionette = require("jira/components/libs/marionette-2.1.0");
    var Pager = require("jira/components/pager");
    var ToolsView = require("jira/components/detailslayout/views/tools");

    return Marionette.ViewManager.extend({
        initialize: function(options) {
            this.showExpand = options.showExpand;

            this._buildTools();
            this._buildPager();
        },

        show: function (el) {
            this.toolsView.setElement(el);
            this.toolsView.render();
        },

        load: function(searchResults) {
            this.pager.update(searchResults);
        },

        onDestroy: function() {
            this.pager.destroy();
        },

        _buildTools: function() {
            this.toolsView = this.buildView("toolsView", function () {
                var view = new ToolsView({
                    showExpand: this.showExpand
                });
                this.listenTo(view, {
                    render: function() {
                        view.pager._ensureElement();
                        this.pager.show(view.pager.$el);
                    },
                    expand: function() {
                        this.trigger('expand');
                    }
                });
                return view;
            });
        },

        _buildPager: function() {
            this.pager = new Pager();
            this.listenTo(this.pager, {
                "next": function() {
                    this.trigger("pager:next");
                },
                "previous": function() {
                    this.trigger("pager:previous");
                }
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/views/Container.js' */
define("jira/components/detailslayout/views/container", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/detailslayout/templates"
], function (
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.container,

        onRender: function () {
            this.unwrapTemplate();
        },

        showView: function(view) {
            this.$el.append(view.$el);
        },

        showLoading: function(loadingView) {
            this.$el.prepend(loadingView.$el);
        },

        hideLoading: function(loadingView) {
            loadingView.$el.detach();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/views/Empty.js' */
define("jira/components/detailslayout/views/empty", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/detailslayout/templates"
], function (
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.empty,

        onRender: function () {
            this.unwrapTemplate();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/views/Tools.js' */
define("jira/components/detailslayout/views/tools", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/detailslayout/templates",
    "jira/ajs/keyboardshortcut/keyboard-shortcut"
], function (
    Marionette,
    Templates,
    KeyboardShortcut
) {
    "use strict";

    return Marionette.LayoutView.extend({
        initialize: function(options) {
            this.showExpand = options.showExpand;
        },

        template: Templates.tools,

        regions: {
            pager: ".pager-container"
        },

        ui: {
            expand: ".expand"
        },

        triggers: {
            "click @ui.expand": "expand"
        },

        serializeData: function() {
            return {
                showExpand: this.showExpand || false,
                expandShortcutKey: KeyboardShortcut.getKeyboardShortcutKeys('fullscreen.issue')
            };
        },

        onRender: function() {
            if (this.showExpand) {
                this.ui.expand.tooltip({
                    gravity: 'e'
                });
            }
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/views/Layout.js' */
define("jira/components/detailslayout/views/layout", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/libs/underscore",
    "jira/components/detailslayout/templates"
], function (
    Marionette,
    _,
    Templates
) {
    "use strict";

    return Marionette.LayoutView.extend({
        template: Templates.layout,

        regions: {
            issuesList: ".list-results-panel",
            issueEditor: ".issue-container",
            tools: ".tools-container"
        },

        ui: {
            detailPanel: '.detail-panel'
        },

        onRender: function() {
            this.issuesList._ensureElement();
        },

        maximizeDetailPanelHeight: function() {
            var issueContainerTop = this.ui.detailPanel.offset().top;
            this.ui.detailPanel.css("height", window.innerHeight - issueContainerTop);
        },

        showDraggable: function() {
            var oldSize = 0;

            this.issuesList.$el.sidebar({
                id: "layoutview-draggable",
                minWidth: function () {
                    return 250;
                },
                maxWidth: _.bind(function () {
                    return this.$el.width() - 500;
                }, this),
                resize: _.bind(function(newSize) {
                    // This should be handled by the sidebar plugin :(
                    if (newSize !== oldSize) {
                        oldSize = newSize;
                        this.trigger("resize");
                    }
                }, this)
            });
        },

        updateDraggable: function() {
            this.issuesList.$el.sidebar("updatePosition");
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/views/Loading.js' */
define("jira/components/detailslayout/views/loading", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/detailslayout/templates"
], function (
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.loading,

        onRender: function () {
            this.unwrapTemplate();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/DetailsLayout.js' */
define("jira/components/detailslayout", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var IssueEditor = require("jira/components/issueeditor");
    var Marionette = require("jira/components/libs/marionette-2.1.0");
    var SimpleIssueList = require("jira/components/simpleissuelist");
    var ViewContainer = require("jira/components/detailslayout/views/container");
    var ViewEmpty = require("jira/components/detailslayout/views/empty");
    var ViewLayout = require("jira/components/detailslayout/views/layout");
    var ViewLoading = require("jira/components/detailslayout/views/loading");
    var Tools = require("jira/components/detailslayout/controllers/tools");

    /**
     * Utility method to create a debounced version of a function. The generated function will have
     * the properties:
     *
     *   - Initial call will happen after <initial> ms
     *   - After the initial call, it will postpone its execution until after <cooldown> milliseconds have elapsed
     *     since the last time it was invoked.
     *   - After the <cooldown> period, the function will be delayed <initial> ms again.
     *
     * Example timelines with values initial=100 and cooldown=500
     *   - Calling the function once:
     *          0ms - Function called
     *        100ms - Function executed
     *
     *   - Calling the function 4 times every 50ms, then again after 1s
     *          0ms - Function called
     *         50ms - Function called
     *        100ms - Function executed (1)
     *        100ms - Function called
     *        150ms - Function called
     *        650ms - Function executed (2)
     *       1000ms - Function called
     *       1100ms - Function executed (3)
     *
     * @param {Function} fn Function to execute
     * @param {number} initial Initial delay in ms.
     * @param {number} cooldown Subsequent delays, in ms.
     * @returns {Function}
     */
    function variableDebounce(fn, initial, cooldown) {
        var timer;
        var currentTimer = initial;

        return function() {
            var args = arguments;
            clearTimeout(timer);
            timer = setTimeout(function() {
                fn.apply(this, args);
                currentTimer = initial;
            }, currentTimer);
            currentTimer = cooldown;
        };
    }

    return Marionette.ViewManager.extend({
        _buildIssueEditor: function () {
            var editor = this.issueEditor = new IssueEditor();
            var options = this.options;


            this._loadIssueInEditor = variableDebounce(_.bind(function(issueData) {
                editor.loadIssue({
                    id: issueData.id,
                    key: issueData.key,
                    detailView: !options.shouldUpdateCurrentProject
                }).always(_.bind(function() {
                    this.hideLoading();
                }, this));
            }, this), 100, 500);

            this.listenTo(editor, {
                "loadError": function (issueData) {
                    this.simpleIssueList.disableIssue(issueData.issueId);
                    this.trigger("editorError");
                },
                "loadComplete": function (issue, options) {
                    this.adjustSize();

                    // The editor model does not provide info about the issue type, we can't
                    // update that value on the list.
                    this.simpleIssueList.updateIssue(issue.id, {
                        key: issue.get('entity').key,
                        summary: issue.get('entity').summary,
                        status: issue.get('entity').status.name
                    });

                    var eventPayload = {
                        issueKey: issue.get('entity').key,
                        issueId: issue.id,
                        issueEditorOptions: options
                    };
                    if (options && options.loadReason === "issues-cache-refresh") {
                        this.trigger("editorLoadedFromCache", eventPayload);
                    } else {
                        this.trigger("editorLoaded", eventPayload);
                    }
                },
                "saveSuccess": function (event) {
                    this.simpleIssueList.refreshIssue(event.issueId);
                    this.trigger("editor:saveSuccess", {
                        event: event.issueId,
                        savedFieldIds: event.savedFieldIds,
                        savedFieldTypes: event.savedFieldTypes,
                        duration: event.duration
                    });
                },
                "editField": function (event) {
                    this.trigger("editor:editField", event);
                },
                "editFieldCancel": function (event) {
                    this.trigger("editor:editFieldCancel", event);
                },
                "linkToIssue": function(event) {
                    this.trigger("linkToIssue", event);
                },
                "refineViewer": function(event) {
                    event.preventDefault();
                    this.updateEditor(event.query);
                },
                "linkInErrorMessage": function(event) {
                    event.preventDefault();
                    this.simpleIssueList.selectIssue(event.issueData.id);
                }
            });
        },

        _buildSimpleIssueList: function () {
            this.simpleIssueList = new SimpleIssueList({
                baseURL: this.baseURL,
                displayInlineIssueCreate: this.options.displayInlineIssueCreate
            });
            this.listenTo(this.simpleIssueList, {
                "select": function (issueData) {
                    this.trigger('select', issueData);
                },
                "update": function () {
                    this.trigger("list:update");
                },
                "refresh": function () {
                    this.trigger("list:refresh");
                },
                "sort": function (jql) {
                    this.trigger("list:sort", jql);
                },
                "list:select": function(event) {
                    this.trigger("list:select", {
                        id: event.id,
                        key: event.key,
                        absolutePosition: event.absolutePosition,
                        relativePosition: event.relativePosition
                    });
                },
                "list:pagination": function() {
                    this.trigger("list:pagination");
                },
                "before:loadpage": function() {
                    this.showLoading();
                },
                "error:loadpage": function(errorInfo) {
                    this.hideLoading();
                    this.trigger("error:loadpage", errorInfo);
                },
                "issueCreated": function(issueInfo) {
                    this.trigger("issueCreated", issueInfo);
                }
            });
        },

        _buildContainerView: function () {
            this.containerView = this.buildView("containerView", function() {
                var view = new ViewContainer();
                this.listenTo(view, {
                    "render": function() {
                        this.getView("layoutView").render();
                        this.getView("emptyView").render();
                        this.getView("loadingView").render();
                        view.$el.prepend(this.getView("layoutView").$el);
                    }
                });
                return view;
            });
        },

        _buildEmptyView: function() {
            this.emptyView = this.buildView("emptyView", function() {
                var view;
                if (typeof this.options.emptyViewFactory === "function") {
                    view = this.options.emptyViewFactory();
                } else {
                    view = new ViewEmpty();
                }

                this.listenTo(view, {
                    "render": function () {
                        this.containerView.$el.append(view.$el);
                        this.adjustSize();
                        this.trigger("empty");
                    }
                });
                return view;
            });
        },

        _showEmptyView: function () {
            this.layoutView.$el.detach();
            this.containerView.$el.empty();
            this.containerView.showView(this.emptyView);
            this.adjustSize();
            this.trigger("empty");
        },

        _buildTools: function() {
            this.tools = new Tools({
                showExpand: this.useExpand
            });
            this.listenTo(this.tools, {
                "expand": function() {
                    this.trigger('expand');
                },
                "pager:next": function() {
                    var data = this.selectNext();
                    this.trigger("pager:next", data);
                },
                "pager:previous": function() {
                    var data = this.selectPrevious();
                    this.trigger("pager:previous", data);
                }
            });
        },

        _buildLayoutView: function() {
            this.layoutView = this.buildView("layoutView", function () {
                var view = new ViewLayout();
                this.listenTo(view, {
                    "render": function () {
                        view.issueEditor._ensureElement();
                        this.issueEditor.setContainer(view.issueEditor.$el);

                        view.issuesList._ensureElement();
                        this.simpleIssueList.show(view.issuesList.$el);

                        view.tools._ensureElement();
                        this.tools.show(view.tools.$el);
                    },
                    "resize": function () {
                        this.adjustSize();
                    }
                });
                return view;
            });
        },

        _buildLoadingView: function() {
            this.loadingView = this.buildView("loadingView", function () {
                return new ViewLoading();
            });
        },

        _buildComponents: function() {
            this._buildIssueEditor();
            this._buildSimpleIssueList();
            this._buildTools();
        },

        _buildViews: function() {
            this._buildLayoutView();
            this._buildEmptyView();
            this._buildLoadingView();
            this._buildContainerView();

            this.containerView.render();
        },

        initialize: function (options) {
            this.baseURL = options.baseURL;
            this.useExpand = options.useExpand || false;

            this._buildComponents();
            this._buildViews();
        },

        _showLoadingView: function () {
            this.containerView.showLoading(this.loadingView);
        },

        _hideLoadingView: function () {
            this.containerView.hideLoading(this.loadingView);
        },

        _showLayoutView: function() {
            this.emptyView.$el.detach();
            this.containerView.showView(this.layoutView);
            this.layoutView.showDraggable();
            this.adjustSize();
        },

        show: function (el) {
            el.replaceWith(this.containerView.$el);
            return this.containerView.$el;
        },

        onDestroy: function() {
            Marionette.ViewManager.prototype.onDestroy.call(this);
            this.issueEditor.close();
            this.simpleIssueList.destroy();
            this.tools.destroy();
            this.hideView("layoutView");
            this.hideView("loadingView");
            this.hideView("emptyView");
            this.hideView("containerView");
        },

        showLoading: function () {
            this._showLoadingView();
        },

        hideLoading: function() {
            this._hideLoadingView();
        },

        load: function (searchResults, issueIdOrKey) {
            if (this.searchResults) {
                this.stopListening(this.searchResults);
                delete this.searchResults;
            }
            this.searchResults = searchResults;
            this.listenTo(this.searchResults, {
                "issueDeleted": function () {
                    if (!this.searchResults.length) {
                        this._showEmptyView();
                    }
                },
                "select selectIssueNotInList": function (issueModel) {
                    this.showLoading();
                    this._loadIssueInEditor({
                        id: issueModel.id,
                        key: issueModel.get('key')
                    });
                }
            });

            if (this.searchResults.isEmptySearch()) {
                this._showEmptyView();
            } else {
                this.simpleIssueList.load(this.searchResults, issueIdOrKey);
                this.tools.load(this.searchResults);
                this._showLayoutView();
            }

            this.trigger("list:render");
        },

        adjustSize: function () {
            _.defer(_.bind(function () {
                if (this.getView("layoutView")) {
                    this.simpleIssueList.adjustSize();
                    this.getView("layoutView").maximizeDetailPanelHeight();
                    this.issueEditor.applyResponsiveDesign();
                    this.getView("layoutView").updateDraggable();
                }

                if (this.getView("emptyView")) {
                    var emptyViewContainer = this.getView("emptyView").$el;
                    var issueContainerTop = emptyViewContainer.length && emptyViewContainer.offset().top;
                    emptyViewContainer.css("height", window.innerHeight - issueContainerTop);
                }
            }, this));
        },

        refreshIssue: function (issueId) {
            this.simpleIssueList.refreshIssue(issueId);
            return this.issueEditor.refreshIssue();
        },

        removeIssue: function (issueId) {
            this.showLoading();
            return this.simpleIssueList.removeIssue(issueId)
                .always(_.bind(function () {
                    this.hideLoading();
                }, this))
                .done(_.bind(function (listLength) {
                    if (listLength === 0) {
                        this._showEmptyView();
                    }
                }, this));
        },

        getActiveIssueId: function () {
            return this.issueEditor.getIssueId();
        },

        getActiveIssueKey: function () {
            return this.issueEditor.getIssueKey();
        },

        selectNext: function() {
            return this.simpleIssueList.selectNext();
        },

        selectPrevious: function() {
            return this.simpleIssueList.selectPrevious();
        },

        updateEditor: function(params) {
            this.showLoading();
            this.listenToOnce(this.issueEditor, "loadComplete", function() {
                this.hideLoading();
            });
            this.issueEditor.updateIssueWithQuery(params);
        },

        isLoading: function() {
            return this.issueEditor.isCurrentlyLoading();
        },

        hasSavesInProgress: function() {
            return this.issueEditor.hasSavesInProgress();
        },

        canDismissComment: function() {
            return this.issueEditor.canDismissComment();
        },

        getEditorFields: function() {
            return this.issueEditor.getFields();
        },

        abortPending: function() {
            return this.issueEditor.abortPending();
        },

        beforeHide: function() {
            return this.issueEditor.beforeHide();
        },

        beforeShow: function() {
            return this.issueEditor.beforeShow();
        },

        removeIssueMetadata: function() {
            return this.issueEditor.removeIssueMetadata();
        },

        editField: function(field) {
            return this.issueEditor.editField(field);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:uri', location = 'libs/uri.js' */
define("jira/components/libs/uri", [
    "atlassian/libs/uri-1.14.1"
], function(
    URI
) {
    "use strict";

    return URI;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/templates/splitview.soy' */
// This file was automatically generated from splitview.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.SplitView.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.SplitView == 'undefined') { JIRA.Templates.SplitView = {}; }


JIRA.Templates.SplitView.fullSplitView = function(opt_data, opt_ignored) {
  return '<div class="aui-group split-view"><div class="aui-item list-results-panel"><div class="list-panel"><div class="list-ordering"></div><div class="list-content">' + ((opt_data.issuePanelData) ? JIRA.Templates.SplitView.issueList(opt_data.issuePanelData) : '') + '</div></div><div class="end-of-stable-message-container"></div><div class="aui-group pagination-view count-pagination"><div class="refresh-container aui-item">' + JIRA.Templates.IssueNav.refreshResults(null) + '</div><div class="pagination-container aui-item">' + ((opt_data.pagination) ? JIRA.Templates.IssueNavTable.pagination(opt_data.pagination) : '') + '</div></div></div><div class="aui-item detail-panel navigator-issue-only"><div></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.SplitView.fullSplitView.soyTemplateName = 'JIRA.Templates.SplitView.fullSplitView';
}


JIRA.Templates.SplitView.issueList = function(opt_data, opt_ignored) {
  var output = '<ol class="issue-list">';
  var iLimit16 = opt_data.issues.length;
  for (var i16 = 0; i16 < iLimit16; i16++) {
    var issue__soy17 = opt_data.issues[i16];
    var issueID__soy18 = opt_data.issueIDs[i16];
    var isHighlighted__soy19 = issueID__soy18 == opt_data.highlightedID;
    output += (issue__soy17) ? '<li ' + ((isHighlighted__soy19) ? 'class="focused"' : '') + ' data-id="' + soy.$$escapeHtml(issueID__soy18) + '" data-key="' + soy.$$escapeHtml(issue__soy17.key) + '" title="' + soy.$$escapeHtml(issue__soy17.summary) + '">' + JIRA.Templates.SplitView.issueRow(issue__soy17) + '</li>' : JIRA.Templates.SplitView.inaccessibleIssueRow({isHighlighted: isHighlighted__soy19, issueID: issueID__soy18});
  }
  output += '</ol>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.SplitView.issueList.soyTemplateName = 'JIRA.Templates.SplitView.issueList';
}


JIRA.Templates.SplitView.issueRow = function(opt_data, opt_ignored) {
  return '<a class="splitview-issue-link" data-issue-key="' + soy.$$escapeHtml(opt_data.key) + '" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.key) + '">' + ((opt_data.type) ? JIRA.Templates.SplitView.issueIcon(opt_data.type) + '&nbsp;' : '') + '<span class="issue-link-key">' + soy.$$escapeHtml(opt_data.key) + '</span><br/><span class="issue-link-summary">' + soy.$$escapeHtml(opt_data.summary) + '</span></a>';
};
if (goog.DEBUG) {
  JIRA.Templates.SplitView.issueRow.soyTemplateName = 'JIRA.Templates.SplitView.issueRow';
}


JIRA.Templates.SplitView.issueIcon = function(opt_data, opt_ignored) {
  return '<img height="16" width="16" alt="' + soy.$$escapeHtml(opt_data.name) + '" title="' + soy.$$escapeHtml(opt_data.name) + ' - ' + soy.$$escapeHtml(opt_data.description) + '" src="' + soy.$$escapeHtml(opt_data.iconUrl) + '" />';
};
if (goog.DEBUG) {
  JIRA.Templates.SplitView.issueIcon.soyTemplateName = 'JIRA.Templates.SplitView.issueIcon';
}


JIRA.Templates.SplitView.inaccessibleIssueRow = function(opt_data, opt_ignored) {
  return '<li class="inaccessible-issue ' + ((opt_data.isHighlighted) ? 'focused' : '') + '" data-id="' + soy.$$escapeHtml(opt_data.issueID) + '">' + soy.$$escapeHtml("This issue can no longer be opened") + '</li>';
};
if (goog.DEBUG) {
  JIRA.Templates.SplitView.inaccessibleIssueRow.soyTemplateName = 'JIRA.Templates.SplitView.inaccessibleIssueRow';
}


JIRA.Templates.SplitView.issueDetailsNoSelection = function(opt_data, opt_ignored) {
  return '<div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.SplitView.issueDetailsNoSelection.soyTemplateName = 'JIRA.Templates.SplitView.issueDetailsNoSelection';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/views/details/services/Analytics.js' */
define("jira/issues/views/details/analytics", [
], function(
) {
    "use strict";

    return {
        triggerIssueTableRefresh: function() {
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.issueTableRefresh", {
                source: "jira.issuenav.global"
            });
        },

        triggerOpenIssueFromTable: function(data) {
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.openIssueFromTable", {
                issueId: data.id,
                absolutePosition: data.absolutePosition + 1,
                relativePosition: data.relativePosition + 1,
                source: "jira.issuenav.global"
            });
        },

        triggerViewIssue: function(data){
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.viewIssue", {
                issueId: data.issueId,
                loadReason: data.loadReason,
                duration: data.duration,
                loadedFromDom: false,
                source: "jira.issuenav.global"
            });
        },

        triggerInlineEdit: function(data) {
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.inlineEdit", {
                issueId: data.issueId,
                savedFieldIds: data.savedFieldIds,
                savedFieldTypes: data.savedFieldTypes,
                duration: data.duration,
                source: "jira.issuenav.global"
            });
        },

        triggerInlineEditStart: function(data) {
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.inlineEdit.start", {
                issueId: data.issueId,
                fieldId: data.fieldId,
                fieldType: data.fieldType,
                source: "jira.issuenav.global"
            });
        },

        triggerInlineEditCancel: function(data) {
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.inlineEdit.cancel", {
                issueId: data.issueId,
                fieldId: data.fieldId,
                fieldType: data.fieldType,
                source: "jira.issuenav.global"
            });
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/views/details/services/Traces.js' */
define("jira/issues/views/details/traces", [
], function(
) {
    "use strict";

    return {
        triggerSearchFinished: function() {
            JIRA.trace("jira.search.finished");
        },

        triggerStableUpdate: function() {
            JIRA.trace("jira.search.stable.update");
        }

    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/views/details/services/ApplicationAdapter.js' */
define('jira/issues/views/details/application-adapter', [
], function (
) {
    "use strict";

    var existingHandlers = {
        "reqres": {},
        "commands": {}
    };
    
    function replaceHandlers(type, handlers) {
        for (var handlerName in handlers) {
            var implementation = handlers[handlerName];
            
            if (JIRA.Issues.Application.reqres.hasHandler(handlerName)) {
                existingHandlers[type][handlerName] = JIRA.Issues.Application.reqres.getHandler(handlerName);
            } else {
                existingHandlers[type][handlerName] = null;
            }

            JIRA.Issues.Application.reqres.setHandler(handlerName, implementation);
        }    
    }

    function restoreReqRes(type) {
        for (var handlerName in existingHandlers[type]) {
            var implementation = existingHandlers[type][handlerName];
            
            if (implementation) {
                JIRA.Issues.Application.reqres.setHandler(handlerName, implementation);
            } else {
                JIRA.Issues.Application.reqres.removeHandler(handlerName);
            }
            
            delete existingHandlers[type][handlerName];
        }
    }    
    
    return {
        init: function (detailsLayout) {
            replaceHandlers("reqres", {
                "issueEditor:canDismissComment": function() {
                    return detailsLayout.canDismissComment();
                },
                "issueEditor:getIssueId": function() {
                    return detailsLayout.getActiveIssueId();
                },
                "issueEditor:getIssueKey": function() {
                    return detailsLayout.getActiveIssueKey();
                },
                "issueEditor:refreshIssue": function() {
                    return detailsLayout.refreshIssue();
                },
                "issueEditor:isCurrentlyLoading": function() {
                    return detailsLayout.isLoading();
                },
                "issueEditor:hasSavesInProgress": function() {
                    return detailsLayout.hasSavesInProgress();
                },
                "issueEditor:fields": function() {
                    return detailsLayout.getEditorFields();
                }
            });

            replaceHandlers("commands", {
                "issueEditor:abortPending": function() {
                    return detailsLayout.abortPending();
                },
                "issueEditor:beforeHide": function() {
                    return detailsLayout.beforeHide();
                },
                "issueEditor:beforeShow": function() {
                    return detailsLayout.beforeShow();
                },
                "issueEditor:removeIssueMetadata": function() {
                    return detailsLayout.removeIssueMetadata();
                },
                "issueEditor:updateIssueWithQuery": function() {
                    return detailsLayout.updateEditor();
                },
                "issueEditor:editField": function(field) {
                    return detailsLayout.editField(field);
                }
            });
        },
        
        destroy: function() {
            restoreReqRes("reqres");
            restoreReqRes("commands");
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/views/details/services/Metrics.js' */
define('jira/issues/views/details/metrics', [
    'internal/browser-metrics'
], function (
    metrics
) {
    "use strict";

    return {
        viewIssue: function () {
            metrics.start({
                isInitial: true,
                key: "jira.issue.view",
                ready: [
                    {selector: "#key-val", requireUpdate: false},
                    ".issue-body-content"
                ]
            });
        },

        startFromPageLoad: function () {
            metrics.start({
                isInitial: true,
                key: "jira.issue.nav-detail"
            });
        },

        start: function () {
            metrics.start({
                key: "jira.issue.nav-detail"
            });
        },

        end: function () {
            metrics.end({
                key: "jira.issue.nav-detail"
            });
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/views/details/Details.js' */
define("jira/issues/views/details", [
    'jira/components/lib/marionette-2.1.0',
    'jira/components/detailslayout',
    'jira/components/search/results',
    'jira/issues/views/details/metrics',
    "jira/issues/views/details/analytics",
    "jira/issues/views/details/traces",
    "jira/issues/views/details/application-adapter",
    'jira/dropdown/dropdown-factory',
    'jira/components/libs/uri'
], function(
    Marionette,
    DetailsLayout,
    Results,
    metrics,
    analytics,
    traces,
    applicationAdapter,
    DropdownFactory,
    URI
) {
    "use strict";

    return Marionette.Object.extend({
        _buildSearchResults: function(search) {
            this._destroySearchResults();

            var searchResults = search.getResults();
            var keys = searchResults._getIssueIdsToKeys();
            var ids = searchResults.get('issueIds');
            var issues = _.map(ids, function (id) { return {id: id, key: keys[id]}; });

            this.searchResults = new Results([], {
                totalRecordsInDB: searchResults.get('total'),
                pageSize: searchResults.get('pageSize'),
                totalRecordsInSearch: searchResults.get('issueIds').length,
                issues: issues,
                jql: search.getEffectiveJql(),
                allowNoSelection: true
            });
        },

        _destroySearchResults: function() {
            if (this.searchResults) {
                this.stopListening(this.searchResults);
                delete this.searchResults;
            }
        },

        _buildDetailsLayout: function(searchPageModule) {
            var currentQuery = new URI().query();
            var url = new URI(AJS.contextPath() + "/issues/").query(currentQuery).removeQuery("startIndex");
            this.detailsLayout = new DetailsLayout({
                baseURL: url.toString(),
                shouldUpdateCurrentProject: false
            });
            var boundAdjustSize = _.bind(this.detailsLayout.adjustSize, this.detailsLayout);

            this.listenTo(this.detailsLayout, {
                "select": function(issueData) {
                    if (issueData.id) {
                        var shouldReplaceCurrentURLInTheHistory = false;
                        var isThereAnIssueInTheCurrentURL = this.search.getResults().getSelectedIssue().getKey();
                        if (!isThereAnIssueInTheCurrentURL) {
                            shouldReplaceCurrentURLInTheHistory = true;
                        }
                        this.search.getResults().selectIssueById(issueData.id, {replace: shouldReplaceCurrentURLInTheHistory});
                    }
                },
                "list:refresh": function() {
                    metrics.start();
                    analytics.triggerIssueTableRefresh();
                    this.search.refresh();
                },
                "list:sort": function(jql) {
                    this.search.doSort(jql);
                },
                "list:update": function() {
                    traces.triggerSearchFinished();
                    traces.triggerStableUpdate();
                },
                "list:render": function() {
                    this.trigger("render");
                },
                "empty": function() {
                    traces.triggerSearchFinished();
                    this.trigger("render");
                },
                "destroy": function() {
                    JIRA.Issues.offHorizontalResize(boundAdjustSize);
                    JIRA.Issues.offVerticalResize(boundAdjustSize);
                },
                "list:select": function(event) {
                    metrics.start();
                    analytics.triggerOpenIssueFromTable({
                        issueId: event.id,
                        absolutePosition: event.absolutePosition,
                        relativePosition: event.relativePosition
                    });
                },
                "list:pagination": function() {
                    metrics.start();
                },
                "editorLoaded": function(event) {
                    metrics.end();
                    analytics.triggerViewIssue({
                        issueId: event.issueId,
                        loadReason: event.loadReason,
                        duration: event.duration
                    });

                    // Danger, horrible code ahead!!
                    //
                    // The scenario: before, the element '.issue-container' had the scroll for the IssueEditor. Now, the
                    // element with the scroll is it's parent '.detail-panel' (this helps heaps with the position of the
                    // pager).
                    //
                    // The problem(s): design flaws in other components make supporting that scenario near impossible:
                    //  *  Dropdowns in IssueEditor specify that they should get auto-closed when the user scrolls on
                    //    '.issue-container'. That's wrong because it assumes that the scroll will always happen on
                    //    that element. We can't change this without affecting all the users of the IssueEditor.
                    //  * AJS.Dropdown creates an instance for every element marked as 'js-default-dropdown' that handles
                    //    the logic for showing/hidding the dropdown... but does not provide external access to that
                    //    instance. So there is no way to gracefuly close the dropdown, change its properties, etc.
                    //    Changing this will require a change in JIRA core.
                    //
                    // The solution: when the IssueEditor is rendered, serach for all the elements with the scroll
                    // attribute ('data-hide-on-scroll') and change it so it points to '.detail-panel'. Then, rebind
                    // all the dialogs.
                    this.container.find("[data-hide-on-scroll~='.issue-container']").each(function(idx, item) {
                        var $item = AJS.$(item);
                        $item.data("hasDropdown", false);
                        $item.off('click');
                        $item.attr("data-hide-on-scroll", $item.attr("data-hide-on-scroll").replace(".issue-container", ".detail-panel"));
                    });
                    DropdownFactory.bindGenericDropdowns(this.container);
                },
                "editorLoadedFromCache": function() {
                    metrics.end();
                },
                "editor:saveSuccess": function(event) {
                    analytics.triggerInlineEdit({
                        issueId: event.event,
                        savedFieldIds: event.savedFieldIds,
                        savedFieldTypes: event.savedFieldTypes,
                        duration: event.duration
                    });
                },
                "editor:editField": function(event) {
                    analytics.triggerInlineEditStart({
                        issueId: event.issueId,
                        fieldId: event.fieldId,
                        fieldType: event.fieldType
                    });
                },
                "editor:editFieldCancel": function(event) {
                    analytics.triggerInlineEditCancel({
                        issueId: event.issueId,
                        fieldId: event.fieldId,
                        fieldType: event.fieldType
                    });
                },
                "linkToIssue": function(event) {
                    metrics.viewIssue();

                    searchPageModule.reset({
                        selectedIssueKey: event.issueKey
                    });
                }
            });
            
            JIRA.Issues.onHorizontalResize(boundAdjustSize);
            JIRA.Issues.onVerticalResize(boundAdjustSize);
        },

        _destroyDetailsLayout: function() {
            this.detailsLayout.destroy();
            delete this.detailsLayout;
        },

        _buildSearch: function(search) {
            this.search = search;
            this.listenTo(this.search.getResults(), {
                "change:resultsId": this._loadSearch,
                "issueDeleted": function(issueData) {
                    var deletedIssue = this.searchResults.get(issueData.id);
                    this.searchResults.removeAndUpdateSelectionIfNeeded(deletedIssue);
                }
            });

            // These is *not* a regular Backbone event, we can't use listenTo.
            this.search.getResults().onIssueUpdated(this._handleRefreshIssue);

            this.listenTo(this.search.getResults().getSelectedIssue(), {
                "change": function() {
                    var newIssue = this.search.getResults().getSelectedIssue().get('id');
                    if (!newIssue) return;
                    if (!this.searchResults) return;

                    // The selected issue in this.search.getResults() has changed and it isn't
                    // changed in our model: this means it has been changed 'outside' the DetailsLayout
                    // (e.g. push state or API). In this case, we want reload our model to get the
                    // correct page and select the issue.
                    if (this.searchResults.selected && this.searchResults.selected.get('id') !== newIssue) {
                        this.detailsLayout.load(this.searchResults, newIssue);
                    }
                }
            });
        },

        _destroySearch: function(){
            this.search.getResults().setTable(null, {silent: true});
            this.search.getResults().offIssueUpdated(this._handleRefreshIssue);
        },

        _loadSearch: function() {
            var issueKey;

            this._buildSearchResults(this.search);
            if (this.search.getResults().hasSelectedIssue()) {
                issueKey = this.search.getResults().getSelectedIssue().get('key');
            } else if (this.search.getResults().get('startIndex') > 0) {
                issueKey = this.searchResults.getIssueKeyForIndex(this.search.getResults().get('startIndex'));
            } else if (this.search.getResults().hasHighlightedIssue()) {
                issueKey = this.search.getResults().getHighlightedIssue().get('key');
            }

            this.detailsLayout.load(this.searchResults, issueKey);
        },

        _handleRefreshIssue: function(issueId) {
            this.detailsLayout.refreshIssue(issueId);
        },

        initialize: function(options) {
            this._handleRefreshIssue = _.bind(this._handleRefreshIssue, this);

            this._buildDetailsLayout(options.searchPageModule);
            this._buildSearch(options.search);

            // Create a container, we don't want to replace the existing markup
            var container = jQuery("<div></div>");
            options.searchContainer.find(".navigator-content").html('').append(container);
            this.container = this.detailsLayout.show(container);
            jQuery("body").addClass("page-type-split");

            options.fullScreenIssue.hide();

            applicationAdapter.init(this.detailsLayout);
        },

        render: function() {
            // This method is NOT called when the DetailsLayout is loaded initially. It will get called
            // if the uses switches from another layout (i.e. List View) to Details View.

            this._loadSearch();
        },

        close: function() {
            this.destroy();
        },

        onDestroy: function() {
            jQuery("body").removeClass("page-type-split");
            this._destroyDetailsLayout();
            this._destroySearch();
            this._destroySearchResults();
            applicationAdapter.destroy();
        },

        nextIssue: function() {
            this.detailsLayout.selectNext();
        },

        prevIssue: function() {
            this.detailsLayout.selectPrevious();
        },

        isLoading: function() {
            return this.detailsLayout.isLoading();
        },

        isIssueViewActive: function() {
            return false;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/search/FullScreenLayout.js' */
(function(Marionette, SearchService, IssueTable, Application, Messages) {
    "use strict";

    AJS.namespace("JIRA.Issues.FullScreenLayout");

    /**
     * A view containing the entire search/issue app.
     *
     * Handles switching between the search and issue views.
     */
    JIRA.Issues.FullScreenLayout = Marionette.Controller.extend({
        /**
         * Initialise the FullScreenLayout.
         *
         * @param {object} options
         * @param {element} options.searchContainer The element into which the search is to be rendered.
         */
        initialize: function(options) {
            this.searchService = new SearchService({
                searchModule: options.search,
                searchResults: options.search.getResults(),
                columnConfig: options.columnConfig
            });

            this.$navigatorContent = options.searchContainer.find('.navigator-content');
            this.issueTable = new IssueTable({
                searchService: this.searchService,
                el: this.$navigatorContent,
                columnConfig: options.columnConfig
            });
            this.listenTo(this.issueTable, {
                "highlightIssue": function(issueId) {
                    this.searchService.highlightIssue(issueId);
                },
                "render": function() {
                    if (!this.searchService.hasSelectedIssue()) {
                        this.fullScreenIssue.hide();
                    }
                    this.fullScreenIssue.bindSearchService(this.searchService);
                    this.trigger("render");
                }
            });
            this.fullScreenIssue = options.fullScreenIssue;
            this.listenTo(this.fullScreenIssue, {
                "issueHidden": function() {
                    // This is the second highlight. The first one is inside IssueTable component, but due the
                    // internals of FullScreenIssue, when the first one is fired the IssueTable is not in the DOM
                    // so the scrollIntoView() operation will not work. We need to re-highlight the same issue now
                    // that the IssueTable is present in the DOM to force the scroll behaviour
                    this.issueTable.highlightIssue(this.searchService.getHighlightedIssue());
                }
            });

            Application.on("issueEditor:loadError", this.onLoadError, this);
        },

        onLoadError: function(issue) {
            if (!this.fullScreenIssue.isVisible()) {
                this.searchService.unselectIssue();
                Messages.showErrorMsg(
                    AJS.format("{0} can not be opened. The issue may have been deleted or you might not have permission to see the issue.", issue.issueKey),
                    {closeable: true}
                );
            }
        },

        render: function() {
            this.issueTable.show();
        },

        onClose: function() {
            this.fullScreenIssue.deactivate();
            this.issueTable.close();
            this.searchService.close();

            Application.off("issueEditor:loadError", this.onLoadError, this);

            delete this.fullScreenIssue;
            delete this.issueTable;
            delete this.searchService;
        },

        nextIssue: function() {
            this.searchService.selectNextIssue();
        },

        prevIssue: function() {
            this.searchService.selectPreviousIssue();
        },

        returnToSearch: function() {
            this.searchService.unselectIssue();
        },

        handleLeft: function() {
            // No-op
        },

        handleRight: function() {
            // No-op
        },

        isIssueViewActive: function() {
            return this.fullScreenIssue.isVisible();
        },

        isLoading: function() {
            return this.fullScreenIssue.isLoading();
        }
    });
})(JIRA.Marionette, JIRA.Components.SearchService, JIRA.Components.IssueTable, JIRA.Issues.Application, JIRA.Messages);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/search/EmptyResultsView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.EmptyResultsView");

    JIRA.Issues.EmptyResultsView = JIRA.Issues.BaseView.extend({

        initialize: function(options) {
            this.searchResults = options.searchResults;
        },

        render: function() {
            var message;
            var hint;
            var cssClass;
            var linkType;
            var createIssuePerm = JIRA.Issues.UserParms.get().createIssue;

            if (!JIRA.Issues.LoginUtils.isLoggedIn()) {
                message = "No issues were found to match your search";
                hint = "Try \u003ca\u003elogging in\u003c/a\u003e to see more results";
                cssClass = "not-logged-in-message";
                linkType = 'login';
            } else if (this.searchResults.getJiraHasIssues() === false) {
                message = "No issues have been created (yet)";
                hint = createIssuePerm ? "Be the first to \u003ca\u003ecreate an issue\u003c/a\u003e" : null;
                cssClass = "empty-results-message";
                linkType = 'create';
            } else {
                message = "No issues were found to match your search";
                hint = createIssuePerm ?
                    "Try modifying your search criteria or \u003ca\u003ecreating a new issue\u003c/a\u003e" :
                    "Try modifying your search criteria";
                cssClass = "no-results-message";
                linkType = 'create';
            }

            this.$el.addClass("empty-results");
            this.$el.html(JIRA.Templates.IssueNavTable.noResults({
                message: message,
                hint: hint,
                cssClass: cssClass
            }));

            // Make links within the hint work
            var $links = this.$('.no-results-hint a');
            switch (linkType) {
                case 'create':
                    $links.addClass('create-issue').attr('href', AJS.contextPath() + "/secure/CreateIssue!default.jspa");
                    break;
                case 'login':
                    $links.attr('href', JIRA.Issues.LoginUtils.redirectUrlToCurrent()).addClass('login-link');
                    break;
            }

            _.defer(jQuery.event.trigger, 'updateOffsets.popout');
            _.defer(JIRA.trace, 'jira.search.finished');
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-page-changes', location = 'content/js/search/util/DialogCleanup.js' */
(function() {
    "use strict";

    /**
     * Closes any existing dialog when the application is navigation to a new route
     *
     * @param router {JIRA.Issues.IssueNavRouter} Router used by the application
     */
    JIRA.Issues.dialogCleaner = function(router) {
        router.on("navigate", function() {
            if (JIRA.Dialog.current) {
                JIRA.Dialog.current.hide();
            }
            if (AJS.HelpTip && AJS.HelpTip.Manager) {
                AJS.HelpTip.Manager.hideSequences();
                AJS.HelpTip.Manager.clearSequences();
            }
        });
    };
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-page-changes', location = 'content/js/search/util/OverrideIssueDialogUtil.js' */
(function() {
    "use strict";

    /**
     * Overriding from old issue navigator api.
     * todo retire old getDefaultAjaxOptions
     *
     * @this JIRA.FormDialog
     * @return {Object}
     */
    JIRA.Dialogs.getDefaultAjaxOptions = function() {

        var linkIssueURI = this.options.url || this.getRequestUrlFromTrigger();

        this.issueId = JIRA.Issues.Api.getSelectedIssueId();
        this.issueKey = JIRA.Issues.Api.getSelectedIssueKey();

        if (/id=\{0\}/.test(linkIssueURI)) {
            if (!this.issueId) {
                return false;
            } else {
                linkIssueURI = linkIssueURI.replace(/(id=\{0\})/, "id=" + this.issueId);
            }
        }
        return {
            data: {decorator: "dialog", inline: "true"},
            url: linkIssueURI
        };
    };

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-page-changes', location = 'content/js/search/util/OverrideIssueDialogs.js' */
define('jira/issues/search/util/overrideissuedialogs', [
    'jira/issuenavigator/issue-navigator/shortcuts',
    'jira/issues/search/legacyissuenavigatorshortcuts'
], function(
    oldIssueNavApi, // This is the issue nav from JIRA
    legacyIssueNavApi // This is the issue nav from Issue-Nav-Plugin
){
    "use strict";

    var _getIssueId;
    var _isNavigator;
    var _updateIssue;
    var eventHandlersAttached = false;

    /**
     * Patch issue dialogs with KickAss functionality.
     *
     * @param {object} options
     * @param {function} options.getIssueId Retrieves the current issue's ID.
     * @param {boolean} options.isNavigator Whether we're running issue search.
     * @param {function} options.updateIssue Update after a dialog closes.
     */
    var overrideIssueDialogs = function(options) {
        options = _.defaults({}, options, {
            isNavigator: false
        });

        _getIssueId = options.getIssueId;
        _isNavigator = !!options.isNavigator;
        _updateIssue = options.updateIssue;

        if (eventHandlersAttached) {
            return;
        }

        if (_isNavigator) {

            // JRADEV-14888
            // Labels dialog overrode the handleSubmitResponse handler to update labels without refreshing page
            // We do that anyway so we can just use the standard _handlerSubmitResponse.
            JIRA.LabelsDialog.prototype._handleSubmitResponse = JIRA.FormDialog.prototype._handleSubmitResponse;
        }

        // Override handlers for the Quick-Create dialog
        // Have to do it on DOM ready because that's how it's done in JIRA Core's IssueNavigator file.
        AJS.$(function() {
            // TODO NEXT-156: Directly apply the monkey patch to the LegacyIssueNavigatorShortcuts and remove the monkey patchs.
            // TODO TF-711: Replace with AMD module call, or better still, delete old issue nav API.

            // Second Monkey patch - this is used as an intermediate step oldIssueNavApi acts as a proxy to legacyIssueNavApi.
            // The reason this is needed is because _quickEditSessionCompleteHandler is binded twice (once from JIRA,
            // and once from Issue-nav-plugin, which means two events are triggered (one using the overwrite and the other one not).
            if (oldIssueNavApi._quickEditSessionCompleteHandler !== legacyIssueNavApi._quickEditSessionCompleteHandler) {
                JIRA.unbind("QuickEdit.sessionComplete", oldIssueNavApi._quickEditSessionCompleteHandler);
            }

            if (oldIssueNavApi._quickCreateSubtaskSessionCompleteHandler !== legacyIssueNavApi._quickCreateSubtaskSessionCompleteHandler) {
                JIRA.unbind("QuickCreateSubtask.sessionComplete", oldIssueNavApi._quickCreateSubtaskSessionCompleteHandler);
            }

            // Monkey patch quick edit
            JIRA.unbind("QuickEdit.sessionComplete", legacyIssueNavApi._quickEditSessionCompleteHandler);
            JIRA.bind("QuickEdit.sessionComplete", function() {
                _updateIssue(JIRA.Dialog.current);
            });

            // Monkey patch quick create subtask
            JIRA.unbind("QuickCreateSubtask.sessionComplete", legacyIssueNavApi._quickCreateSubtaskSessionCompleteHandler);
            JIRA.bind("QuickCreateSubtask.sessionComplete", function() {
                _updateIssue(JIRA.Dialog.current);
            });
        });

        // Store the issue we opened the dialog on so we can compare if we are on the same issue (hence refresh) when
        // we submit dialog.
        JIRA.bind("Dialog.show", function(e, $el, instance) {
            if (instance) {
                instance.issueId = _getIssueId(JIRA.Dialog.current);
            }
        });

        // Monkey patch issue transitions
        // atl_token is not written into the template onto the server for some reason, so ensure it exists on render
        JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function(e, $el) {
            $el.find(".issueaction-workflow-transition").each(function() {
                var $this = AJS.$(this);
                var href = $this.attr("href");

                /*eslint-disable no-undef*/
                href = href.replace(/atl_token=[^&]*/, "atl_token=" + atl_token());
                /*eslint-enable no-undef*/

                $this.attr("href", href);
            });
        });

        // Monkey patch the "Log In" link to make it redirect correctly. Internally, the API generates this link using
        // whatever URL was requested: in this case, that's the API and the user is redirected to a page-full of JSON.
        JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function() {
            var $loginLink = AJS.$("#ops-login-lnk");
            if ($loginLink.length === 0) {
                return;
            }

            var location = window.location;

            /*eslint-disable no-undef*/
            var uriComponents = parseUri($loginLink.attr("href"));
            /*eslint-enable no-undef*/


            /*eslint-disable camelcase*/
            uriComponents.queryKey.os_destination = location.pathname.slice(AJS.contextPath().length) + location.search;
            /*eslint-enable camelcase*/

            $loginLink.attr("href", uriComponents.path + "?" + AJS.$.param(uriComponents.queryKey));
        });

        eventHandlersAttached = true;
    };

    // Override the default onDialogFinished callback that hides the dialog and
    // reloads the page. For non-issue dialogs, we just defer to the old one.
    var oldGetDefaultOptions = JIRA.FormDialog.prototype._getDefaultOptions;
    JIRA.FormDialog.prototype._getDefaultOptions = function() {
        var options = oldGetDefaultOptions.call(this);
        var oldOnDialogFinished = options.onDialogFinished;

        options.onDialogFinished = function() {
            if (this.isIssueDialog()) {
                onDialogFinished.apply(this, arguments);
            } else {
                oldOnDialogFinished.apply(this, arguments);
            }
        };

        return options;
    };

    // Monkey patch _performRedirect to not actually redirect at all.
    var oldPerformRedirect = JIRA.FormDialog.prototype._performRedirect;
    JIRA.FormDialog.prototype._performRedirect = function() {
        if (this.isIssueDialog()) {
            onDialogFinished.apply(this, arguments);
        } else {
            oldPerformRedirect.apply(this, arguments);
        }
    };

    function onDialogFinished() {
        // JRADEV-11573
        if (this.options.id === "clone-issue-dialog") {
            // This works for standalone only, JRADEV-11618 to fix for splitview
            oldPerformRedirect.apply(this, arguments);
        } else if (this.options.id === "delete-issue-dialog") {
            if (_isNavigator) {
                this.hide();
                _updateIssue(this);
            } else {
                // JRADEV-10933
                var redirectUrl = this._getTargetUrlValue();
                if (redirectUrl && redirectUrl !== "") {
                    AJS.reloadViaWindowLocation(redirectUrl);
                } else if (AJS.$(".page-navigation #next-issue").length > 0) {
                    AJS.reloadViaWindowLocation(AJS.$(".page-navigation #next-issue").attr("href"));
                } else if (AJS.$(".page-navigation #return-to-search").length > 0) {
                    AJS.reloadViaWindowLocation(AJS.$(".page-navigation #return-to-search").attr("href"));
                } else {
                    AJS.reloadViaWindowLocation(AJS.$("#find_link").attr("href"));
                }
            }
        } else {
            var instance = this;
            this.showFooterLoadingIndicator();
            _updateIssue(this).always(function() {
                JIRA.trace("jira.issue.update");
                instance.hideFooterLoadingIndicator();
                instance.hide();
            });
        }
    }

    return overrideIssueDialogs;
});
AJS.namespace('JIRA.Issues.overrideIssueDialogs', null, require('jira/issues/search/util/overrideissuedialogs'));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-page-changes', location = 'content/js/search/enhanceIssueLinks.js' */
(function() {
    "use strict";

    var URI = require('jira/components/libs/uri');
    /**
     * Enhance links outside KA, usually to load things via AJAX.
     * <p/>
     * Only works if the AJAX view issue dark feature is enabled.
     */
    JIRA.Issues.enhanceLinks = {

        /**
         * Search for links that should alter the page state via pushState
         *
         * @param options {Object} Options used by the enhancer
         * @param options.selector {String} (Optional) Selector to use, defaults to .push-state
         */
        withPushState: function(options) {
            options = _.defaults(options, {
                selector: ".push-state"
            });

            AJS.$(document).delegate(options.selector, "simpleClick", function(e) {
                if (this.href) {
                    e.preventDefault();

                    // Let's assume we're only going to be pushing relative links.
                    var path = new URI(this.href).fragment("").resource();

                    // Backbone's fragment doesn't include the history root.
                    path = path.replace(JIRA.Issues.IssueNavRouter.getBackboneRoot(), "");

                    JIRA.Issues.Application.execute('navigation:navigateToUrl', path,
                            {forceRefresh: true, checkPermission: true, replace: true, reset: true});
                }
            });
        },

        /**
         * Search for links to the the issue navigator and enhances them
         */
        toIssueNav: function() {
            var filterSelector = "a.filter-link[data-filter-id], a.filter-link[data-jql]";
            var newSelector = "#issues_new_search_link_lnk";

            AJS.$(document).on("simpleClick", filterSelector, function(e) {
                e.preventDefault();

                var $anchor = AJS.$(e.target).closest("a");
                var filterId = $anchor.data("filter-id");
                var jql = $anchor.data("jql");

                JIRA.Issues.Application.execute("navigation:navigate", {
                    filter: filterId,
                    jql: jql,
                    searchId: _.uniqueId()
                }, {reset: true, resetQuery: true});
            });

            // The "Search for Issues" link in the header.
            AJS.$(document).on("simpleClick", newSelector, function(e) {
                e.preventDefault();
                JIRA.Issues.Application.execute("navigation:navigate", {
                    jql: '',
                    searchId: _.uniqueId()
                }, {reset: true, resetQuery: true});
            });
        },

        isIssueTableDropdown: function() {
            if (AJS.InlineLayer.current) {
                var $offsetTarget = jQuery(AJS.InlineLayer.current.offsetTarget());
                if ($offsetTarget.closest(".list-view table#issuetable").size()) {
                    return true;
                }
            }
        },

        /**
         * Search for links to a particular issue and enhances them
         */
        toIssue: function() {
            // Make issue links load via AJAX.
            var issueSelector = "a.issue-link[data-issue-key]";
            var issueIsParentSelector = ".parentIssue";
            var issueFromTableSelector = ".list-view table#issuetable a.issue-link[data-issue-key]";
            AJS.$(document).on("simpleClick", issueSelector, function(e) {
                if (e.isDefaultPrevented()) return;

                e.preventDefault();
                e.stopPropagation();

                var issueKey = AJS.$(e.target).closest("a").data("issue-key");

                // Check if it is a link from the results table
                var isFromResultsTable = AJS.$(e.target).is(issueFromTableSelector);
                var isLinkToParentIssue = AJS.$(e.target).is(issueIsParentSelector);
                var isIssueTableDropdown = JIRA.Issues.enhanceLinks.isIssueTableDropdown(issueFromTableSelector);

                if (this.searchPageModule && ((isFromResultsTable && !isLinkToParentIssue) || isIssueTableDropdown)) {
                    var searchResults = this.searchPageModule.searchResults;
                    var issueIdAsString = searchResults._getIssueIdForKey(issueKey);
                    var issueId = parseInt(issueIdAsString, 10);

                    JIRA.Issues.Application.execute("analytics:trigger", "kickass.openIssueFromTable", {
                        issueId: issueIdAsString,
                        // these are 1-based indices
                        absolutePosition: searchResults.getPositionOfIssueInSearchResults(issueId) + 1,
                        relativePosition: searchResults.getPositionOfIssueInPage(issueId) + 1,
                        source: "jira.issuenav.global"
                    });
                    JIRA.Issues.Application.execute("navigation:navigate", {
                        selectedIssueKey: issueKey
                    });
                } else {
                    require('jira/issues/navigator/metrics').notifyIssueView();

                    JIRA.Issues.Application.execute("navigation:navigate", {
                        selectedIssueKey: issueKey
                    }, {reset: true});
                }
            }.bind(this));
        },

        registerSearchPageModule: function registerSearchPageModule(searchPageModule) {
            this.searchPageModule = searchPageModule;
        }
    };

}());
;
;
/* module-key = 'com.atlassian.jira.gadgets:searchrequestview-charts', location = 'script/chartpopup/popupuserprefstore.js' */
/**
 * @fileoverview Implements the gadgets.UserPrefStore interface storing data in a javascript store.
 */
AJS.namespace("jira.plugin.chartingstore");

jira.plugin.chartingstore = function() {
    var userPrefMap = {};
    return {
        get: function (gadgetId) {
            var userPrefs = userPrefMap[gadgetId];
            if(!userPrefs) {
                return {};
            }
            return userPrefs;
        },
        set: function (gadgetId, name, value) {
            var prefs = this.get(gadgetId);
            prefs[name] = value;
            userPrefMap[gadgetId] = prefs;
        },
        clear: function() {
            userPrefMap = {};
        }
    };
}();

gadgets.IfrGadgetService.prototype.setUserPref = function(editToken, name, value) {
    var gadgetId = this.f;
    if(gadgetId) {
        gadgetId = gadgetId.substr("gadget-".length);
    }
    jira.plugin.chartingstore.set(gadgetId, name, value);
};
;
;
/* module-key = 'com.atlassian.jira.gadgets:searchrequestview-charts', location = 'script/chartpopup/chartdialog.js' */
/**
 * @module jira.plugin.charting
 * @author Scott Harwood
 * @since 4.0
 * @requires jQuery > v1.6, jQuery.aop
 */

 /*JSLINT options*/
 /*jslint white: true, browser: true, onevar: true, plusplus: true, regexp: true, eqeqeq: true */
 /*global window, document, jQuery, jira*/

AJS.namespace("jira.plugin.charting");

// singleton
jira.plugin.charting = function () {
    var dialog, /* {Object} jquery object */
    DIALOG_ID = "charts-dialog",
    CHARTS_CATEGORY = "Charts",
    CHART_HEIGHT = 522,
    saveFormLoaded = false,
    idToUriMap = {},
    dialogThrobber = AJS.$('<span class="icon throbber"></span>'),

    getPostData = function(formData) {
        var postData = {};
        jQuery.each(formData, function(i, field) {
            postData[field.name] = field.value;
        });
        var filterId = getFilterId();
        if(filterId) {
            postData.filterId = filterId;
        } else {
            postData.jql = getFilterJql() || "";
        }
        var chartPanelId = dialog.getPage(0).curtab;
        postData.gadgetUri = idToUriMap[chartPanelId];
        var userPrefs = jira.plugin.chartingstore.get(chartPanelId);
        if(userPrefs) {
            var prefsMap = {};
            for (var key in userPrefs) {
                prefsMap[key] = userPrefs[key];
            }
            postData.userPrefs = prefsMap;
        }

        return postData;
    },

    loadSaveToDashboardForm = function() {
        if(!saveFormLoaded) {
            var saveFormUrl = contextPath + "/rest/gadget/1.0/chart/add";
            var filterId = getFilterId();
            if(filterId) {
                saveFormUrl = saveFormUrl + "?filterId=" + encodeURIComponent(filterId);
            } else {
                saveFormUrl = saveFormUrl + "?jql=" + encodeURIComponent(getFilterJql());
            }

            var saveFormPanel = jQuery("#saveToDashboardPanel");
            saveFormPanel.empty();
            jQuery.ajax({
                url: saveFormUrl,
                success: function(data) {
                    saveFormPanel.html(data);
                    saveFormLoaded = true;
                    var chartForm = saveFormPanel.find("form#savetodashboardform");
                    var saveButton = saveFormPanel.find("#save-btn1");
                    chartForm.submit(function(e) {
                        e.preventDefault();
                        chartForm.find(".error").remove();
                        chartForm.find(".form-errors p").remove();
                        chartForm.find(".form-errors").hide();
                        saveButton.attr("disabled", "true");

                        var postData = getPostData(chartForm.serializeArray());
                        jQuery.ajax({
                            url: chartForm.attr("action"),
                            contentType:'application/json',
                            dataType: "text",
                            data: JSON.stringify(postData),
                            type:'POST',
                            success: function (data) {
                                chartForm.trigger("fakesubmit");
                                saveButton.removeAttr("disabled", "false");
                                window.location = data;
                            },
                            error: function(XMLHttpRequest, textStatus, errorThrown) {
                                saveButton.removeAttr("disabled", "false");
                                if(XMLHttpRequest.status === 400) {
                                    var errorCollection = eval("(" + XMLHttpRequest.responseText + ")");
                                    if(errorCollection.generic.length > 0) {
                                        jQuery(errorCollection.generic).each(function(i, item) {
                                        chartForm.find(".form-errors").append("<p>" + item + "</p>");
                                        });
                                        chartForm.find(".form-errors").show();
                                    }
                                    if(errorCollection.fields.length > 0) {
                                        jQuery(errorCollection.fields).each(function(i, item) {
                                            chartForm.find("#" + item.field).after("<div class=\"error\">" + item.error + "</div>");
                                        });
                                    }
                                }
                            }
                        });

                    });
                    saveFormPanel.find("#cancel-btn1").click(function(e) {
                        dialog.prevPage();
                        saveButton.removeAttr("disabled", "false");
                        chartForm.find(".form-errors").hide();
                        chartForm.find(".error").remove();
                        e.preventDefault();
                    });
                }
            });
        }
    },

    /**
     * Appends loading indicator (throbber) to all ajax requests. Indicator, controlled via css, appears in the top
     * right corner of the dialog.
     *
     * @private
     */
    addThrobber = function () {
        dialog.popup.element.find(".dialog-button-panel").prepend(dialogThrobber);
        jQuery().ajaxSend(function(a,xhr) {
            if (dialog.popup.element.is(":visible")) {
                jQuery(xhr).throbber({target: dialogThrobber});
            }
        });
    },

    /**
     * Handles failed ajax requests. Will subsitute the page body with the 500 error that occured.
     *
     * @private
     */
    addErrorHandler = function () {
        jQuery().ajaxError(function(e,XMLHttpRequest,ajaxOptions){
            if (XMLHttpRequest.status === 500) {
                dialog.hide();
                jQuery("body").html(XMLHttpRequest.responseText);
            }
        });
    },

    /**
     * ESC hides the dialog
     */
    keypressListener = function(e) {
        if (e.keyCode === 27) {
            dialog.hide();
        }
    },

    /**
     * Creates dialog box. Adds global functionality including error handling and ajax throbber indicator.
     *
     * @private
     * @param {String | Number} width - width of dialog box
     * @param {String | Number} height - height of dialog box
     */
    createDialog = function (width, height, data) {
        dialog = new AJS.Dialog(width, height, DIALOG_ID);
        dialog.addHeader("Gadgets");
        resetPanels(data);
        dialog.addButton("Save to Dashboard",
                function(dialog) {
                    loadSaveToDashboardForm();
                    dialog.nextPage();
                },
                "save-to-dashboard");
        dialog.addCancel("Cancel", function(dialog) {
            dialog.hide();
        });
        dialog.addPage();
        dialog.page[1].addPanel("saveToDashBoard", "<div id=\"saveToDashboardPanel\"</div>");
        dialog.page[1].addHeader("Save gadget to a Dashboard");
        addThrobber();
        addErrorHandler();
        AJS.$(document).keydown(keypressListener);
    },

    /**
     * Resets the dialog to the original state when it pops up.
     *
     * @param {Number} initialPanel - the panel index to go to after resetting the dialog
     * @private
     */
    resetDialog = function(initialPanel) {
        if(dialog) {
            saveFormLoaded = false;
            jQuery("form[name=chartpopup]").show();
            jQuery("input[name=filterName]").val("");
            dialog.gotoPage(0);
            for(var i = 0; dialog.getPanel(i); i++) {
                var panel = dialog.getPanel(i);
                panel.loaded = false;
            }
            dialog.gotoPanel(initialPanel);
        }
    },

    /**
     * Given a directory JSON object this method figures out all the chart gadgets to display in the popup.
     *
     * @private
     * @param {json} data -
     */
    loadChartGadgets = function(data) {
        // Fill items on the right
        var chartGadgets = [];
        var filterResultsGadget;
        var uri = parseUri(window.location);
        var baseUrl = uri.protocol + "://" + uri.authority;
        jQuery(data.gadgets).each(function(i, gadget) {
            //JRADEV-4419: Only add gadgets that are hosted locally to the dialog!
            // ACJIRA-308: Add support of dashboard-items
            if((gadget.gadgetSpecUri && (gadget.gadgetSpecUri.indexOf("http") !== 0 || gadget.gadgetSpecUri.indexOf(baseUrl) === 0))) {

                var chartGadget = {title : gadget.title, gadgetUri: gadget.gadgetSpecUri};

                if (gadget.gadgetSpecUri.indexOf("filter-results") > -1) {
                    filterResultsGadget = chartGadget;
                }

                jQuery([gadget.categories]).each(function(i, catKey) {
                    if(catKey.constructor==Array) { // if there are multiple categories for this gadget, loop through all of them
                        for(var j=0; j<catKey.length; ++j) {
                            // don't add the Filter Results gadget to the array - we'll do it later
                            if(catKey[j] === CHARTS_CATEGORY && filterResultsGadget != chartGadget) {
                                chartGadgets.push(chartGadget);
                            }
                        }
                    }
                    else {
                        // don't add the Filter Results gadget to the array - we'll do it later
                        if(catKey === CHARTS_CATEGORY && filterResultsGadget != chartGadget) {
                            chartGadgets.push(chartGadget);
                        }
                    }
                });
            }
        });

        chartGadgets.sort(function(one, two) { return (one.title > two.title ? 1 : -1); });
        // add the Filter Results gadget to the start
        if (filterResultsGadget) {
            chartGadgets.unshift(filterResultsGadget);
        }
        return chartGadgets;
    },

    /**
     * Renders the contents of a particular panel for a particular chart.
     *
     * @private
     * @param {Object} panel - the panel to render
     * @param {Object} data - json object with the directory contents
     */
    renderPanelContents = function(panel, data) {
        panel.body.html(data);
        panel.loaded = true;
    },

    /**
     * Sets up all the panels when the dialog loads
     *
     * @private
     * @param {Object} data - json object of the directory contents
     */
    resetPanels = function(data) {
        var chartGadgets = loadChartGadgets(data);
        dialog.gotoPage(0);
        jQuery(chartGadgets).each(function(i, gadget) {
            dialog.page[0].addPanel(gadget.title, "<div class=\"loadingPanel\">&nbsp;</div>");
            var panel = dialog.getPanel(i);
            if(panel) {
                panel.loaded = false;
                idToUriMap[i] = gadget.gadgetUri;
                panel.body.show = function (panel, show) {
                    return function() {
                        if(!panel.loaded) {
                            var rendererUrl = contextPath + "/rest/gadget/1.0/chart/render?id=" + i + "&gadgetUri=" + encodeURIComponent(gadget.gadgetUri);
                            var filterId = getFilterId();
                            if(filterId) {
                                rendererUrl = rendererUrl + "&filterId=" + encodeURIComponent(filterId);
                            } else {
                                rendererUrl = rendererUrl + "&jql=" + encodeURIComponent(getFilterJql());
                            }

                            jQuery.ajax({
                                url: rendererUrl,
                                success: function(data) {
                                    renderPanelContents(panel, data);
                                }
                            });
                        }
                        show.call(panel.body);
                    };
                }(panel, panel.body.show);
            }
        });
    },

    /**
     * Creates a new dialog (if necessary and displays it)
     *
     * @private
     * @param {String} url - the url to get the direcotry JSON object from
     * @param {String | Number} width - width of dialog box
     * @param {String | Number} height - height of dialog box
     * @param {String | Number} initialPanel - the first panel to load
     */
    launchDialog = function (url, width, height, initialPanel) {
        if(dialog) {
            //this ensures that all the panels will get loaded from the server again.
            resetDialog(initialPanel);
            dialog.show();
        } else {
            jQuery(jQuery.ajax({
                url: url,
                dataType: 'json',
                success: function (data) {
                    if (!dialog) {
                        createDialog(width, height, data);
                    }
                    dialog.show();
                    dialog.gotoPage(0);
                    dialog.gotoPanel(initialPanel);
                }
            })).throbber({target: jQuery("#throbber-space")});
        }
    },

    getFilterId = function()
    {
        var filterId = AJS.Meta.get('filter-id');

        if (filterId && filterId >= 0) {
            return filterId;
        }

        return null;
    },

    getFilterJql = function()
    {
        return AJS.Meta.get('filter-jql');
    };

    return function () {
        // if they clicked on Charts we default to the first chart i.e. Panel 1
        jQuery("body").delegate("#charts", "click", function(e) {
            AJS.populateParameters();
            launchDialog(contextPath + "/rest/config/1.0/directory.json", 800, CHART_HEIGHT, 1);
            e.preventDefault();
        });
        // if they clicked on On Dashboard we default to the Filter Results gadget i.e. Panel 0
        jQuery("body").delegate("#onDashboard", "click", function(e) {
            AJS.populateParameters();
            launchDialog(contextPath + "/rest/config/1.0/directory.json", 800, CHART_HEIGHT, 0);
            e.preventDefault();
        });
    };
}();

// wait for page to fully load to make sure we have all the elements we need
jQuery(document).ready(jira.plugin.charting);

;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:standalone-issue-nav', location = 'content/js/search/IssueNavInit.js' */
(function(require) {
    "use strict";

    var jQuery = require("jquery");
    var Backbone = require("backbone");
    var _ = require("underscore");
    var KeyboardShortcut = require("jira/ajs/keyboardshortcut/keyboard-shortcut");
    var SmartAjax = require("jira/ajs/ajax/smart-ajax");
    var Messages = require("jira/message");
    var Meta = require("jira/util/data/meta");

    // Prevent escape key from cancelling XHR requests in FF
    jQuery(document).on('keydown', function(e) {
        if (e.which === 27) e.preventDefault();
    });

    jQuery(function() {

        JIRA.Issues.Application.start({
            showReturnToSearchOnError: function() {
                return JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey() !== "split-view";
            },
            useLog: Meta.get("dev-mode") === true
        });

        /**
         * Create all our Backbone stuff
         */
        JIRA.Issues.GlobalIssueNavCreator.create(jQuery(document), JIRA.Issues.GlobalIssueNavCreator.readInitialData());

        Backbone.history.start({
            root: JIRA.Issues.IssueNavRouter.getBackboneRoot(),
            pushState: true
        });

        // Workaround for Chrome bug firing a null popstate event on page load.
        // Backbone should fix this!
        // @see http://code.google.com/p/chromium/issues/detail?id=63040
        // @see also JRADEV-14804
        if (jQuery.browser.webkit) {
            JIRA.Issues.ignorePopState = true;
            window.addEventListener('load', function() {
                _.defer(function() {
                    JIRA.Issues.ignorePopState = false;
                });
            });
        }

        KeyboardShortcut.addIgnoreCondition(function(e, key, ctx) {
            return ctx === "issueaction" && JIRA.Issues.Api.isCurrentlyLoadingIssue();
        });

        /*
         * Some shenanigans to get get table to resize with window gracefully. Sets the width of the issue navigator results
         * wrapper. Keeps the right hand page elements within the browser view when the results table is wider than the browser view.
         */
        var bodyMinWidth = parseInt(jQuery('body').css('minWidth'), 10);
        jQuery(document).bind('resultsWidthChanged', function() {
            var $contained = jQuery('.contained-content');
            var $containedParent = $contained.parent();

            if ($contained.length > 0) {
                var containedLeft = $contained.offset().left;
                var target = Math.max(window.innerWidth, bodyMinWidth) - containedLeft;
                var targetPct = target / $containedParent.width() * 100;
                if (targetPct < 100) {
                    $contained.css('width', targetPct + '%');
                } else {
                    $contained.css('width', '');
                }
                jQuery(document).trigger('issueNavWidthChanged');
            }
        });

        // Trigger the event on page load to make sure the controls are visible.
        jQuery(document).trigger("resultsWidthChanged");

        JIRA.Issues.onVerticalResize(function() {
            jQuery.event.trigger("updateOffsets.popout");
        });

        // When switching layouts we need to update the height of sidebar
        JIRA.bind(JIRA.Events.LAYOUT_RENDERED, function() {
            _.defer(function() {
                jQuery.event.trigger("updateOffsets.popout");
            });
        });
    });

    /**
     * Determines the appropriate message to show upon search ajax failure
     *
     * @param xhr XHR object from jQuery.ajax
     */
    JIRA.Issues.displayFailSearchMessage = function(xhr) {
        if (xhr && xhr.statusText !== "abort") {
            return Messages.showErrorMsg(SmartAjax.buildSimpleErrorContent(xhr), {
                closeable: true
            });
        }
    };

}(window.require));
;
;
/* module-key = 'jira.webresources:field-templates', location = '/includes/jira/field/templates/singleUserPicker.soy' */
// This file was automatically generated from singleUserPicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Fields.Pickers.User.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Fields == 'undefined') { JIRA.Templates.Fields = {}; }
if (typeof JIRA.Templates.Fields.Pickers == 'undefined') { JIRA.Templates.Fields.Pickers = {}; }
if (typeof JIRA.Templates.Fields.Pickers.User == 'undefined') { JIRA.Templates.Fields.Pickers.User = {}; }


JIRA.Templates.Fields.Pickers.User.single = function(opt_data, opt_ignored) {
  var output = '<select id="' + soy.$$escapeHtml(opt_data.field.id) + '" name="' + soy.$$escapeHtml(opt_data.field.name) + '" class="single-user-picker js-' + ((opt_data.type) ? soy.$$escapeHtml(opt_data.type) : 'default-user-picker') + '"' + ((opt_data.inputText) ? ' data-input-text="' + soy.$$escapeHtml(opt_data.inputText) + '"' : '') + ((opt_data.editValue) ? ' data-edit-value="' + soy.$$escapeHtml(opt_data.editValue) + '"' : '') + ((opt_data.showDropdownButton) ? ' data-show-dropdown-button="true"' : '') + ((opt_data.userType) ? ' data-user-type="' + soy.$$escapeHtml(opt_data.userType) + '"' : '') + ((opt_data.containerClass) ? ' data-container-class="' + soy.$$escapeHtml(opt_data.containerClass) + '"' : '') + '>';
  var optionList38 = opt_data.options;
  var optionListLen38 = optionList38.length;
  for (var optionIndex38 = 0; optionIndex38 < optionListLen38; optionIndex38++) {
    var optionData38 = optionList38[optionIndex38];
    if (optionData38.optionGroup) {
      output += '<optgroup id="' + soy.$$escapeHtml(opt_data.field.id) + '-group-' + soy.$$escapeHtml(optionData38.id) + '" label="' + soy.$$escapeHtml(optionData38.display) + '"' + ((optionData38.footer) ? ' data-footer-text="' + soy.$$escapeHtml(optionData38.footer) + '"' : '') + ((optionData38.weight != -1) ? ' data-weight="' + soy.$$escapeHtml(optionData38.weight) + '"' : '') + '>';
      var groupOptionList59 = optionData38.groupOptions;
      var groupOptionListLen59 = groupOptionList59.length;
      for (var groupOptionIndex59 = 0; groupOptionIndex59 < groupOptionListLen59; groupOptionIndex59++) {
        var groupOptionData59 = groupOptionList59[groupOptionIndex59];
        output += JIRA.Templates.Fields.Pickers.User.option(groupOptionData59);
      }
      output += '</optgroup>';
    } else {
      output += JIRA.Templates.Fields.Pickers.User.option(optionData38);
    }
  }
  output += '</select>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.Pickers.User.single.soyTemplateName = 'JIRA.Templates.Fields.Pickers.User.single';
}


JIRA.Templates.Fields.Pickers.User.option = function(opt_data, opt_ignored) {
  return '<option ' + ((opt_data.loggedInUser) ? 'class="current-user" ' : '') + ((opt_data.selected) ? 'selected="selected" ' : '') + 'value="' + soy.$$escapeHtml(opt_data.optionName) + '" data-field-text="' + soy.$$escapeHtml(opt_data.displayName) + '" data-field-label="' + soy.$$escapeHtml(opt_data.displayName) + ((opt_data.emailAddress) ? ' - ' + soy.$$escapeHtml(opt_data.emailAddress) : '') + ((opt_data.optionName && opt_data.optionName != '-1') ? ' (' + soy.$$escapeHtml(opt_data.optionName) + ')' : '') + '" data-icon="' + soy.$$escapeHtml(opt_data.avatarURL) + '" >' + soy.$$escapeHtml(opt_data.displayName) + '</option>';
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.Pickers.User.option.soyTemplateName = 'JIRA.Templates.Fields.Pickers.User.option';
}
;
;
/* module-key = 'jira.webresources:field-templates', location = '/includes/jira/field/templates/assigneeField.soy' */
// This file was automatically generated from assigneeField.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Fields.Pickers.User.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Fields == 'undefined') { JIRA.Templates.Fields = {}; }
if (typeof JIRA.Templates.Fields.Pickers == 'undefined') { JIRA.Templates.Fields.Pickers = {}; }
if (typeof JIRA.Templates.Fields.Pickers.User == 'undefined') { JIRA.Templates.Fields.Pickers.User = {}; }


JIRA.Templates.Fields.Pickers.User.assignee = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.Fields.Pickers.User.single(soy.$$augmentMap(opt_data, {options: opt_data.assigneeOptions.options, showDropdownButton: true, userType: 'assignee', type: 'assignee-picker', containerClass: 'long-field'})) + ((opt_data.isLoggedInUserAssignable) ? '<a href="#' + soy.$$escapeHtml(opt_data.field.id) + '" id="assign-to-me-trigger">' + soy.$$escapeHtml("Assign to me") + '</a>' : '') + '<fieldset class="hidden parameters"><input type="hidden" title="projectKeys" value="' + soy.$$escapeHtml(opt_data.projectKeys) + '"/>' + ((opt_data.issueKey) ? '<input type="hidden" title="assigneeEditIssueKey" value="' + soy.$$escapeHtml(opt_data.issueKey) + '"/>' : '') + ((opt_data.actionDescriptorId) ? '<input type="hidden" title="actionDescriptorId" value="' + soy.$$escapeHtml(opt_data.actionDescriptorId) + '"/>' : '') + '</fieldset>';
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.Pickers.User.assignee.soyTemplateName = 'JIRA.Templates.Fields.Pickers.User.assignee';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/lib/jquery.dotdotdot-1.5.7.js' */
/*	
 *	jQuery dotdotdot 1.5.7
 *	
 *	Copyright (c) 2013 Fred Heusschen
 *	www.frebsite.nl
 *
 *	Plugin website:
 *	dotdotdot.frebsite.nl
 *
 *	Dual licensed under the MIT and GPL licenses.
 *	http://en.wikipedia.org/wiki/MIT_License
 *	http://en.wikipedia.org/wiki/GNU_General_Public_License
 */

(function( $ )
{
	if ( $.fn.dotdotdot )
	{
		return;
	}

	$.fn.dotdotdot = function( o )
	{
		if ( this.length == 0 )
		{
			if ( !o || o.debug !== false )
			{
				debug( true, 'No element found for "' + this.selector + '".' );				
			}
			return this;
		}
		if ( this.length > 1 )
		{
			return this.each(
				function()
				{
					$(this).dotdotdot( o );
				}
			);
		}


		var $dot = this;

		if ( $dot.data( 'dotdotdot' ) )
		{
			$dot.trigger( 'destroy.dot' );
		}

		$dot.bind_events = function()
		{
			$dot.bind(
				'update.dot',
				function( e, c )
				{
					e.preventDefault();
					e.stopPropagation();

					opts.maxHeight = ( typeof opts.height == 'number' ) 
						? opts.height 
						: getTrueInnerHeight( $dot );

					opts.maxHeight += opts.tolerance;

					if ( typeof c != 'undefined' )
					{
						if ( typeof c == 'string' || c instanceof HTMLElement )
						{
					 		c = $('<div />').append( c ).contents();
						}
						if ( c instanceof $ )
						{
							orgContent = c;
						}
					}

					$inr = $dot.wrapInner( '<div class="dotdotdot" />' ).children();
					$inr.empty()
						.append( orgContent.clone( true ) )
						.css({
							'height'	: 'auto',
							'width'		: 'auto',
							'border'	: 'none',
							'padding'	: 0,
							'margin'	: 0
						});

					var after = false,
						trunc = false;

					if ( conf.afterElement )
					{
						after = conf.afterElement.clone( true );
						conf.afterElement.remove();
					}
					if ( test( $inr, opts ) )
					{
						if ( opts.wrap == 'children' )
						{
							trunc = children( $inr, opts, after );
						}
						else
						{
							trunc = ellipsis( $inr, $dot, $inr, opts, after );
						}
					}
					$inr.replaceWith( $inr.contents() );
					$inr = null;
					
					if ( $.isFunction( opts.callback ) )
					{
						opts.callback.call( $dot[ 0 ], trunc, orgContent );
					}

					conf.isTruncated = trunc;
					return trunc;
				}

			).bind(
				'isTruncated.dot',
				function( e, fn )
				{
					e.preventDefault();
					e.stopPropagation();

					if ( typeof fn == 'function' )
					{
						fn.call( $dot[ 0 ], conf.isTruncated );
					}
					return conf.isTruncated;
				}

			).bind(
				'originalContent.dot',
				function( e, fn )
				{
					e.preventDefault();
					e.stopPropagation();

					if ( typeof fn == 'function' )
					{
						fn.call( $dot[ 0 ], orgContent );
					}
					return orgContent;
				}

			).bind(
				'destroy.dot',
				function( e )
				{
					e.preventDefault();
					e.stopPropagation();

					$dot.unwatch()
						.unbind_events()
						.empty()
						.append( orgContent )
						.data( 'dotdotdot', false );
				}
			);
			return $dot;
		};	//	/bind_events

		$dot.unbind_events = function()
		{
			$dot.unbind('.dot');
			return $dot;
		};	//	/unbind_events

		$dot.watch = function()
		{
			$dot.unwatch();
			if ( opts.watch == 'window' )
			{
				var $window = $(window),
					_wWidth = $window.width(),
					_wHeight = $window.height(); 

				$window.bind(
					'resize.dot' + conf.dotId,
					function()
					{
						if ( _wWidth != $window.width() || _wHeight != $window.height() || !opts.windowResizeFix )
						{
							_wWidth = $window.width();
							_wHeight = $window.height();
	
							if ( watchInt )
							{
								clearInterval( watchInt );
							}
							watchInt = setTimeout(
								function()
								{
									$dot.trigger( 'update.dot' );
								}, 10
							);
						}
					}
				);
			}
			else
			{
				watchOrg = getSizes( $dot );
				watchInt = setInterval(
					function()
					{
						var watchNew = getSizes( $dot );
						if ( watchOrg.width  != watchNew.width ||
							 watchOrg.height != watchNew.height )
						{
							$dot.trigger( 'update.dot' );
							watchOrg = getSizes( $dot );
						}
					}, 100
				);
			}
			return $dot;
		};
		$dot.unwatch = function()
		{
			$(window).unbind( 'resize.dot' + conf.dotId );
			if ( watchInt )
			{
				clearInterval( watchInt );
			}
			return $dot;
		};

		var	orgContent	= $dot.contents(),
			opts 		= $.extend( true, {}, $.fn.dotdotdot.defaults, o ),
			conf		= {},
			watchOrg	= {},
			watchInt	= null,
			$inr		= null;

		conf.afterElement	= getElement( opts.after, $dot );
		conf.isTruncated	= false;
		conf.dotId			= dotId++;


		$dot.data( 'dotdotdot', true )
			.bind_events()
			.trigger( 'update.dot' );

		if ( opts.watch )
		{
			$dot.watch();
		}

		return $dot;
	};


	//	public
	$.fn.dotdotdot.defaults = {
		'ellipsis'	: '... ',
		'wrap'		: 'word',
		'lastCharacter': {
			'remove'		: [ ' ', ',', ';', '.', '!', '?' ],
			'noEllipsis'	: []
		},
		'tolerance'	: 0,
		'callback'	: null,
		'after'		: null,
		'height'	: null,
		'watch'		: false,
		'windowResizeFix': true,
		'debug'		: false
	};
	

	//	private
	var dotId = 1;

	function children( $elem, o, after )
	{
		var $elements 	= $elem.children(),
			isTruncated	= false;

		$elem.empty();

		for ( var a = 0, l = $elements.length; a < l; a++ )
		{
			var $e = $elements.eq( a );
			$elem.append( $e );
			if ( after )
			{
				$elem.append( after );
			}
			if ( test( $elem, o ) )
			{
				$e.remove();
				isTruncated = true;
				break;
			}
			else
			{
				if ( after )
				{
					after.remove();
				}
			}
		}
		return isTruncated;
	}
	function ellipsis( $elem, $d, $i, o, after )
	{
		var $elements 	= $elem.contents(),
			isTruncated	= false;

		$elem.empty();

		var notx = 'table, thead, tbody, tfoot, tr, col, colgroup, object, embed, param, ol, ul, dl, select, optgroup, option, textarea, script, style';
		for ( var a = 0, l = $elements.length; a < l; a++ )
		{

			if ( isTruncated )
			{
				break;
			}

			var e	= $elements[ a ],
				$e	= $(e);

			if ( typeof e == 'undefined' )
			{
				continue;
			}

			$elem.append( $e );
			if ( after )
			{
				$elem[ ( $elem.is( notx ) ) ? 'after' : 'append' ]( after );
			}
			if ( e.nodeType == 3 )
			{
				if ( test( $i, o ) )
				{
					isTruncated = ellipsisElement( $e, $d, $i, o, after );
				}
			}
			else
			{
				isTruncated = ellipsis( $e, $d, $i, o, after );
			}

			if ( !isTruncated )
			{
				if ( after )
				{
					after.remove();
				}
			}
		}
		return isTruncated;
	}
	function ellipsisElement( $e, $d, $i, o, after )
	{
		var isTruncated	= false,
			e = $e[ 0 ];

		if ( typeof e == 'undefined' )
		{
			return false;
		}

		var seporator	= ( o.wrap == 'letter' ) ? '' : ' ',
			textArr		= getTextContent( e ).split( seporator ),
			position 	= -1,
			midPos		= -1,
			startPos	= 0,
			endPos		= textArr.length - 1;

		while ( startPos <= endPos )
		{
			var m = Math.floor( ( startPos + endPos ) / 2 );
			if ( m == midPos ) 
			{
				break;
			}
			midPos = m;

			setTextContent( e, textArr.slice( 0, midPos + 1 ).join( seporator ) + o.ellipsis );

			if ( !test( $i, o ) )
			{
				position = midPos;
				startPos = midPos; 
			}
			else
			{
				endPos = midPos;
			}				
		}	
	
		if ( position != -1 && !( textArr.length == 1 && textArr[ 0 ].length == 0 ) )
		{
			var txt = addEllipsis( textArr.slice( 0, position + 1 ).join( seporator ), o );
			isTruncated = true;
			setTextContent( e, txt );
		}
		else
		{
			var $w = $e.parent();
			$e.remove();

			var afterLength = ( after ) ? after.length : 0 ;

			if ( $w.contents().size() > afterLength )
			{
				var $n = $w.contents().eq( -1 - afterLength );
				isTruncated = ellipsisElement( $n, $d, $i, o, after );
			}
			else
			{
				var e = $w.prev().contents().eq( -1 )[ 0 ];

				if ( typeof e != 'undefined' )
				{
					var txt = addEllipsis( getTextContent( e ), o );
					setTextContent( e, txt );
					$w.remove();
					isTruncated = true;
				}

			}
		}

		return isTruncated;
	}
	function test( $i, o )
	{
		return $i.innerHeight() > o.maxHeight;
	}
	function addEllipsis( txt, o )
	{
		while( $.inArray( txt.slice( -1 ), o.lastCharacter.remove ) > -1 )
		{
			txt = txt.slice( 0, -1 );
		}
		if ( $.inArray( txt.slice( -1 ), o.lastCharacter.noEllipsis ) < 0 )
		{
			txt += o.ellipsis;
		}
		return txt;
	}
	function getSizes( $d )
	{
		return {
			'width'	: $d.innerWidth(),
			'height': $d.innerHeight()
		};
	}
	function setTextContent( e, content )
	{
		if ( e.innerText )
		{
			e.innerText = content;
		}
		else if ( e.nodeValue )
		{
			e.nodeValue = content;
		}
		else if (e.textContent)
		{
			e.textContent = content;
		}

	}
	function getTextContent( e )
	{
		if ( e.innerText )
		{
			return e.innerText;
		}
		else if ( e.nodeValue )
		{
			return e.nodeValue;
		}
		else if ( e.textContent )
		{
			return e.textContent;
		}
		else
		{
			return "";
		}
	}
	function getElement( e, $i )
	{
		if ( typeof e == 'undefined' )
		{
			return false;
		}
		if ( !e )
		{
			return false;
		}
		if ( typeof e == 'string' )
		{
			e = $(e, $i);
			return ( e.length )
				? e 
				: false;
		}
		if ( typeof e == 'object' )
		{
			return ( typeof e.jquery == 'undefined' )
				? false
				: e;
		}
		return false;
	}
	function getTrueInnerHeight( $el )
	{
		var h = $el.innerHeight(),
			a = [ 'paddingTop', 'paddingBottom' ];

		for ( var z = 0, l = a.length; z < l; z++ ) {
			var m = parseInt( $el.css( a[ z ] ), 10 );
			if ( isNaN( m ) )
			{
				m = 0;
			}
			h -= m;
		}
		return h;
	}
	function debug( d, m )
	{
		if ( !d )
		{
			return false;
		}
		if ( typeof m == 'string' )
		{
			m = 'dotdotdot: ' + m;
		}
		else
		{
			m = [ 'dotdotdot:', m ];
		}

		if ( typeof window.console != 'undefined' )
		{
			if ( typeof window.console.log != 'undefined' )
			{
				window.console.log( m );
			}
		}
		return false;
	}
	

	//	override jQuery.html
	var _orgHtml = $.fn.html;
    $.fn.html = function( str ) {
		if ( typeof str != 'undefined' )
		{
			if ( this.data( 'dotdotdot' ) )
			{
				if ( typeof str != 'function' )
				{
					return this.trigger( 'update', [ str ] );
				}
			}
			return _orgHtml.call( this, str );
		}
		return _orgHtml.call( this );
    };


	//	override jQuery.text
	var _orgText = $.fn.text;
    $.fn.text = function( str ) {
		if ( typeof str != 'undefined' )
		{
			if ( this.data( 'dotdotdot' ) )
			{
				var temp = $( '<div />' );
				temp.text( str );
				str = temp.html();
				temp.remove();
				return this.trigger( 'update', [ str ] );
			}
			return _orgText.call( this, str );
		}
        return _orgText.call( this );
    };


})( require('jquery') );
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/soy/ProjectTemplatesList.soy' */
// This file was automatically generated from ProjectTemplatesList.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }


JIRA.Templates.ProjectTemplates.renderProjectTemplates = function(opt_data, opt_ignored) {
  return '' + ((soy.$$getMapKeys(opt_data.projectTemplates).length == 0) ? JIRA.Templates.errorMsg({closeable: false, msg: "No project templates could be found."}) : JIRA.Templates.ProjectTemplates.renderTemplates(opt_data));
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderProjectTemplates.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderProjectTemplates';
}


JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.projectTemplatesByType.length == 0) {
    output += JIRA.Templates.errorMsg({closeable: false, msg: "No project templates could be found."});
  } else {
    var projectTypeTemplatesGroupList18 = opt_data.projectTemplatesByType;
    var projectTypeTemplatesGroupListLen18 = projectTypeTemplatesGroupList18.length;
    for (var projectTypeTemplatesGroupIndex18 = 0; projectTypeTemplatesGroupIndex18 < projectTypeTemplatesGroupListLen18; projectTypeTemplatesGroupIndex18++) {
      var projectTypeTemplatesGroupData18 = projectTypeTemplatesGroupList18[projectTypeTemplatesGroupIndex18];
      output += '<div class="template-group" id="project-template-group-' + soy.$$escapeHtml(projectTypeTemplatesGroupData18.projectTypeBean.projectTypeKey) + '"><div class="template-group-header"><h6><img class="project-type-icon" src="data:image/svg+xml;base64, ' + soy.$$escapeHtml(projectTypeTemplatesGroupData18.projectTypeBean.icon) + ' "/><span>' + soy.$$escapeHtml(projectTypeTemplatesGroupData18.projectTypeBean.projectTypeDisplayKey) + '</span></h6></div>' + JIRA.Templates.ProjectTemplates.renderTemplates({projectTemplates: projectTypeTemplatesGroupData18.projectTemplates}) + '</div>';
    }
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType';
}


JIRA.Templates.ProjectTemplates.renderTemplates = function(opt_data, opt_ignored) {
  return '<div class="pt-templates-list">' + JIRA.Templates.ProjectTemplates.renderItems(opt_data) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderTemplates.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderTemplates';
}


JIRA.Templates.ProjectTemplates.renderItems = function(opt_data, opt_ignored) {
  var output = '<ol class="templates" tabindex="100">';
  var templateList37 = opt_data.projectTemplates;
  var templateListLen37 = templateList37.length;
  for (var templateIndex37 = 0; templateIndex37 < templateListLen37; templateIndex37++) {
    var templateData37 = templateList37[templateIndex37];
    output += '<li class="template"' + ((templateData37.itemModuleCompleteKey) ? 'data-item-module-complete-key="' + soy.$$escapeHtml(templateData37.itemModuleCompleteKey) + '"' : '') + ((templateData37.projectTemplateModuleCompleteKey) ? 'data-project-template-module-complete-key="' + soy.$$escapeHtml(templateData37.projectTemplateModuleCompleteKey) + '"' : '') + ((templateData37.createProject) ? 'data-create-project="' + soy.$$escapeHtml(templateData37.createProject) + '"' : '') + ((templateData37.demoProject) ? 'data-demo-project="' + soy.$$escapeHtml(templateData37.demoProject) + '"' : '') + ((templateData37.backgroundIconUrl) ? 'data-background-icon-url="' + soy.$$escapeHtml(templateData37.backgroundIconUrl) + '"' : '') + ((templateData37.name) ? 'data-name="' + soy.$$escapeHtml(templateData37.name) + '"' : '') + ((templateData37.description) ? 'data-description="' + soy.$$escapeHtml(templateData37.description) + '"' : '') + ((templateData37.longDescriptionContent) ? 'data-long-description-content="' + soy.$$escapeHtml(templateData37.longDescriptionContent) + '"' : '') + ((templateData37.infoSoyPath) ? 'data-info-soy-path="' + soy.$$escapeHtml(templateData37.infoSoyPath) + '"' : '') + '><img class="template-preview" src="' + soy.$$escapeHtml(templateData37.iconUrl) + '" /><div class="template-meta"><div class="template-name" title="' + soy.$$escapeHtml(templateData37.name) + '">' + soy.$$escapeHtml(templateData37.name) + '</div><div class="template-description" title="' + soy.$$escapeHtml(templateData37.description) + '">' + soy.$$escapeHtml(templateData37.description) + '</div></div></li>';
  }
  output += '</ol>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderItems.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderItems';
}


JIRA.Templates.ProjectTemplates.loadingTemplatesList = function(opt_data, opt_ignored) {
  return '<div class="wait-container"><img class="wait-icon" src="' + soy.$$escapeHtml("/jira") + '/images/icons/wait.gif"><span class="wait-text">' + soy.$$escapeHtml("Loading project templates") + '&hellip;</span></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.loadingTemplatesList.soyTemplateName = 'JIRA.Templates.ProjectTemplates.loadingTemplatesList';
}


JIRA.Templates.ProjectTemplates.footerLinks = function(opt_data, opt_ignored) {
  return '<div class="footer-links"><a class="import-project-trigger button-panel-link" href="' + soy.$$escapeHtml("/jira") + '/secure/admin/views/ExternalImport1.jspa">' + soy.$$escapeHtml("Import a project") + '</a>|<a class="create-with-shared-config button-panel-link" href="#"><span class="aui-icon aui-icon-create-shared">' + soy.$$escapeHtml("Create with shared configuration") + '</span> ' + soy.$$escapeHtml("Create with shared configuration") + '</a>' + ((opt_data.showDemoLink) ? '| <a class="add-demo-project-trigger button-panel-link" href="#">' + soy.$$escapeHtml("Create sample data") + '</a>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.footerLinks.soyTemplateName = 'JIRA.Templates.ProjectTemplates.footerLinks';
}


JIRA.Templates.ProjectTemplates.addWorkflowsLink = function(opt_data, opt_ignored) {
  return '<a class="add-workflow-link" href="' + soy.$$escapeHtml(opt_data.baseUrl) + '/plugins/servlet/wfshare-import?src=projecttemplates" tabindex="-1">' + soy.$$escapeHtml("View Marketplace Workflows") + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.addWorkflowsLink.soyTemplateName = 'JIRA.Templates.ProjectTemplates.addWorkflowsLink';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/soy/AddProject.soy' */
// This file was automatically generated from AddProject.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }


JIRA.Templates.ProjectTemplates.addProjectForm = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.errors.errorMessages) {
    var errorList5 = opt_data.errors.errorMessages;
    var errorListLen5 = errorList5.length;
    for (var errorIndex5 = 0; errorIndex5 < errorListLen5; errorIndex5++) {
      var errorData5 = errorList5[errorIndex5];
      output += JIRA.Templates.errorMsg({closeable: false, msg: errorData5});
    }
  }
  output += '<div class="add-project-wrapper"><div class="add-project-form-wrapper">' + aui.form.form({content: '' + aui.form.fieldset({legendContent: '', content: '' + JIRA.Templates.ProjectTemplates.longTextField({id: 'name', name: 'name', isRequired: false, maxLength: opt_data.maxNameLength, labelContent: "Name", descriptionText: AJS.format("Max. {0} characters.",opt_data.maxNameLength), value: opt_data.currentName ? opt_data.currentName : '', errorTexts: opt_data.errors.errors.projectName ? [opt_data.errors.errors.projectName] : []}) + JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon({id: 'key', name: 'key', isRequired: false, maxLength: opt_data.maxKeyLength, labelContent: "Key", descriptionText: AJS.format("Max. {0} characters.",opt_data.maxKeyLength), helpTitle: "What\x27s a project key?", value: opt_data.currentKey ? opt_data.currentKey : '', errorTexts: opt_data.errors.errors.projectKey ? [opt_data.errors.errors.projectKey] : []}) + ((opt_data.shouldShowLead) ? JIRA.Templates.ProjectTemplates.projectLeadField({field: opt_data.projectLeadPickerField, isRequired: false, errorTexts: opt_data.errors.errors.projectLead ? [opt_data.errors.errors.projectLead] : [], options: opt_data.leadOptions}) : '') + ((opt_data.addUserToLicense.displayCheckbox) ? JIRA.Templates.ProjectTemplates.addUserToLicense({fieldId: opt_data.addUserToLicense.fieldId, fieldName: opt_data.addUserToLicense.fieldName, applicationName: opt_data.addUserToLicense.applicationName, usedSeats: opt_data.addUserToLicense.usedSeats, totalSeats: opt_data.addUserToLicense.totalSeats, disableCheckbox: opt_data.addUserToLicense.disableCheckbox, licensingUrl: opt_data.addUserToLicense.licensingUrl}) : '') + '<input type="hidden" name="keyEdited" id="keyEdited" value="false"><input type="hidden" name="projectTemplateWebItemKey" value="' + soy.$$escapeHtml(opt_data.projectTemplateWebItemKey) + '"><input type="hidden" name="projectTemplateModuleKey" value="' + soy.$$escapeHtml(opt_data.projectTemplateModuleKey) + '"><input type="submit" class="pt-hidden-submit offscreen-left">'}), id: 'add-project-form'}) + '</div>' + ((opt_data.projectTemplateDescriptionContent) ? '<div class="add-project-description-wrapper"><div class="project-template-title"><h3>' + soy.$$escapeHtml(opt_data.projectTemplateTitle) + '</h3></div><div class="project-template-description">' + soy.$$filterNoAutoescape(opt_data.projectTemplateDescriptionContent) + '</div></div>' : '') + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.addProjectForm.soyTemplateName = 'JIRA.Templates.ProjectTemplates.addProjectForm';
}


JIRA.Templates.ProjectTemplates.keyHelp = function(opt_data, opt_ignored) {
  return '<div class="project-key-help"><p><b>' + soy.$$escapeHtml("What\x27s a project key?") + '</b></p><ul><li>' + soy.$$escapeHtml("It prefixes each issue in the project") + '</li><li>' + soy.$$escapeHtml("It can be changed, but this is not a trivial task") + '</li></ul></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.keyHelp.soyTemplateName = 'JIRA.Templates.ProjectTemplates.keyHelp';
}


JIRA.Templates.ProjectTemplates.projectLeadField = function(opt_data, opt_ignored) {
  var param77 = '' + aui.form.label({forField: opt_data.field.name + '-field', isRequired: opt_data.isRequired, content: "Project Lead"}) + JIRA.Templates.Fields.Pickers.User.single({field: opt_data.field, options: opt_data.options, editValue: opt_data.value}) + aui.form.fieldDescription({message: "Enter the username of the Project Lead."});
  if (opt_data.errorTexts) {
    var errorList90 = opt_data.errorTexts;
    var errorListLen90 = errorList90.length;
    for (var errorIndex90 = 0; errorIndex90 < errorListLen90; errorIndex90++) {
      var errorData90 = errorList90[errorIndex90];
      param77 += aui.form.fieldError({message: errorData90});
    }
  }
  var output = '' + aui.form.fieldGroup({content: param77});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.projectLeadField.soyTemplateName = 'JIRA.Templates.ProjectTemplates.projectLeadField';
}


JIRA.Templates.ProjectTemplates.addUserToLicense = function(opt_data, opt_ignored) {
  var output = '';
  var labelMessage__soy96 = '' + soy.$$escapeHtml(AJS.format("Give me a {0} license so I can access this project.",opt_data.applicationName)) + ((opt_data.totalSeats > 0) ? '<br/>' + soy.$$escapeHtml(AJS.format("({0} of {1} licenses now used)",opt_data.usedSeats,opt_data.totalSeats)) : '');
  output += aui.form.fieldGroup({content: '' + aui.form.label({forField: opt_data.fieldName, content: 'License'}) + ((opt_data.disableCheckbox) ? aui.form.field({id: opt_data.fieldId, name: opt_data.fieldName, value: 'true', type: 'checkbox', isChecked: false, labelContent: labelMessage__soy96, isDisabled: true, descriptionContent: AJS.format("We can\x27\x27t give you access to {0} automatically. You can {1}manage application access{2} to work on {0} projects.",opt_data.applicationName,'<a href="' + "/jira" + opt_data.licensingUrl + '">','</a>')}) : aui.form.field({id: opt_data.fieldId, name: opt_data.fieldName, value: 'true', type: 'checkbox', isChecked: false, labelContent: labelMessage__soy96, isDisabled: false}))});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.addUserToLicense.soyTemplateName = 'JIRA.Templates.ProjectTemplates.addUserToLicense';
}


JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon = function(opt_data, opt_ignored) {
  var param128 = '' + aui.form.label({forField: opt_data.name, isRequired: opt_data.isRequired, content: opt_data.labelContent}) + aui.form.input({id: opt_data.id, name: opt_data.name, type: 'text', maxLength: opt_data.maxLength, value: opt_data.value}) + '<a class="help-lnk" title="' + soy.$$escapeHtml(opt_data.helpTitle) + '" id="' + soy.$$escapeHtml(opt_data.id) + '-help-icon"><span class="aui-icon aui-icon-help">' + soy.$$escapeHtml(opt_data.helpTitle) + '</span></a>' + ((opt_data.descriptionText) ? aui.form.fieldDescription({message: opt_data.descriptionText}) : '');
  if (opt_data.errorTexts) {
    var errorList152 = opt_data.errorTexts;
    var errorListLen152 = errorList152.length;
    for (var errorIndex152 = 0; errorIndex152 < errorListLen152; errorIndex152++) {
      var errorData152 = errorList152[errorIndex152];
      param128 += aui.form.fieldError({message: errorData152});
    }
  }
  var output = '' + aui.form.fieldGroup({content: param128});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon.soyTemplateName = 'JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon';
}


JIRA.Templates.ProjectTemplates.longTextField = function(opt_data, opt_ignored) {
  var param158 = '' + aui.form.label({forField: opt_data.name, isRequired: opt_data.isRequired, content: opt_data.labelContent}) + aui.form.input({id: opt_data.id, name: opt_data.name, type: 'text', maxLength: opt_data.maxLength, value: opt_data.value, extraClasses: 'long-field'}) + ((opt_data.descriptionText) ? aui.form.fieldDescription({message: opt_data.descriptionText}) : '');
  if (opt_data.errorTexts) {
    var errorList176 = opt_data.errorTexts;
    var errorListLen176 = errorList176.length;
    for (var errorIndex176 = 0; errorIndex176 < errorListLen176; errorIndex176++) {
      var errorData176 = errorList176[errorIndex176];
      param158 += aui.form.fieldError({message: errorData176});
    }
  }
  var output = '' + aui.form.fieldGroup({content: param158});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.longTextField.soyTemplateName = 'JIRA.Templates.ProjectTemplates.longTextField';
}


JIRA.Templates.ProjectTemplates.spinner = function(opt_data, opt_ignored) {
  return '<span id=\'' + soy.$$escapeHtml(opt_data.id) + '\' class=\'icon throbber loading\'/>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.spinner.soyTemplateName = 'JIRA.Templates.ProjectTemplates.spinner';
}


JIRA.Templates.ProjectTemplates.formatAnchor = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.href) + '"' + ((opt_data.title) ? ' title="' + soy.$$escapeHtml(opt_data.title) + '"' : '') + '>' + soy.$$escapeHtml(opt_data.body) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.formatAnchor.soyTemplateName = 'JIRA.Templates.ProjectTemplates.formatAnchor';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/soy/CreateSharedProject.soy' */
// This file was automatically generated from CreateSharedProject.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }


JIRA.Templates.ProjectTemplates.createSharedProjectForm = function(opt_data, opt_ignored) {
  return '<div class="create-shared-project-wrapper"><div class="create-shared-project-form-wrapper">' + aui.form.form({content: '' + aui.form.fieldset({content: '<p>' + soy.$$escapeHtml("Select the existing project that you\x27d like to share configurations with.") + '<a class="help-lnk" title="' + soy.$$escapeHtml("What will be shared?") + '" id="shared-help-icon"><span class="aui-icon aui-icon-help">' + soy.$$escapeHtml("What will be shared?") + '</span></a></p>' + aui.form.fieldGroup({extraClasses: 'project-picker-group', content: '' + aui.form.label({forField: 'project-picker', isRequired: false, content: "Choose a project"}) + aui.form.input({id: 'project-picker', name: 'project', type: 'text'}) + '<div id="project-picker-options" data-suggestions="' + soy.$$escapeHtml(opt_data.projectSuggestions) + '"></div>'}) + '<p class="create-shared-info">' + soy.$$escapeHtml("When a configuration is shared with several projects, it means that any changes made to the configuration will affect all the projects.") + '</p>'}), id: 'create-shared-project-form'}) + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.createSharedProjectForm.soyTemplateName = 'JIRA.Templates.ProjectTemplates.createSharedProjectForm';
}


JIRA.Templates.ProjectTemplates.loading = function(opt_data, opt_ignored) {
  return '<div><div class="dialog-spinner"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.loading.soyTemplateName = 'JIRA.Templates.ProjectTemplates.loading';
}


JIRA.Templates.ProjectTemplates.noProjects = function(opt_data, opt_ignored) {
  return '<p>' + soy.$$escapeHtml("Looks like no other projects exist yet. Please create a brand new project first before trying to share an existing project\x27s configuration.") + '</p>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.noProjects.soyTemplateName = 'JIRA.Templates.ProjectTemplates.noProjects';
}


JIRA.Templates.ProjectTemplates.sharedHelp = function(opt_data, opt_ignored) {
  return '<div class="shared-help"><p><strong>' + soy.$$escapeHtml("What will be shared?") + '</strong></p><p>' + soy.$$escapeHtml("Configuration refers to the set of schemes used by a project") + '</p><ul><li>' + soy.$$escapeHtml("Permission Scheme") + '</li><li>' + soy.$$escapeHtml("Notification Scheme") + '</li><li>' + soy.$$escapeHtml("Issue Security Scheme") + '</li><li>' + soy.$$escapeHtml("Workflow Scheme") + '</li><li>' + soy.$$escapeHtml("Issue Type Scheme") + '</li><li>' + soy.$$escapeHtml("Issue Type Screen Scheme") + '</li><li>' + soy.$$escapeHtml("Field Configuration Scheme") + '</li></ul></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.sharedHelp.soyTemplateName = 'JIRA.Templates.ProjectTemplates.sharedHelp';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/Config.js' */
define('jira/project-templates/config', {
    model: {}
});
AJS.namespace('JPT.ConfigModel', null, require('jira/project-templates/config'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/ProjectKeyGenerator.js' */
define('jira/project-templates/project-key-generator', [
    'jquery',
    'underscore'
], function(
    $,
    _
){
    var ProjectKeyGenerator = {};
    ProjectKeyGenerator.IGNORED_WORDS = ["THE", "A", "AN", "AS", "AND", "OF", "OR"];

    // The (non-ascii) characters used as keys will be replaced with their (ascii) value.
    ProjectKeyGenerator.CHARACTER_MAP = {};
    ProjectKeyGenerator.CHARACTER_MAP[199] = "C"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[231] = "c"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[252] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[251] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[250] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[249] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[233] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[234] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[235] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[232] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[226] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[228] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[224] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[229] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[225] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[239] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[238] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[236] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[237] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[196] = "A"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[197] = "A"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[201] = "E"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[230] = "ae"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[198] = "Ae"; // ®
    ProjectKeyGenerator.CHARACTER_MAP[244] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[246] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[242] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[243] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[220] = "U"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[255] = "Y"; // Ø
    ProjectKeyGenerator.CHARACTER_MAP[214] = "O"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[241] = "n"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[209] = "N"; // ?

    ProjectKeyGenerator.desiredKeyLength = 4;
    ProjectKeyGenerator.maxKeyLength = 10;

    ProjectKeyGenerator.getTotalLength = function getTotalLength(words) {
        return words.join("").length;
    };

    ProjectKeyGenerator.removeIgnoredWords = function removeIgnoredWords(words) {
        return _.reject(words, function(word) {
            return $.inArray(word, ProjectKeyGenerator.IGNORED_WORDS) !== -1;
        });
    };

    ProjectKeyGenerator.createAcronym = function createAcronym(words) {
        var result = "";
        $.each(words, function(i, word) {
            result += word.charAt(0);
        });
        return result;
    };

    ProjectKeyGenerator.getFirstSyllable = function getFirstSyllable(word) {
        // Best guess at getting the first syllable
        // Returns the substring up to and including the first consonant to appear after a vowel
        var pastVowel = false;
        var i;
        for (i = 0; i < word.length; i++) {
            if (ProjectKeyGenerator.isVowelOrY(word[i])) {
                pastVowel = true;
            } else {
                if (pastVowel) {
                    return word.substring(0, i + 1);
                }
            }
        }
        return word;
    };

    ProjectKeyGenerator.isVowelOrY = function isVowelOrY(c) {
        return c && c.length === 1 && c.search("[AEIOUY]") !== -1;
    };

    ProjectKeyGenerator.init = function init(desiredKeyLength, maxKeyLength) {
        ProjectKeyGenerator.desiredKeyLength = desiredKeyLength;
        ProjectKeyGenerator.maxKeyLength = maxKeyLength;
    };

    ProjectKeyGenerator.generate = function generate(name) {
        name = $.trim(name);
        if (!name) {
            return "";
        }

        // Brute-force chunk-by-chunk substitution and filtering.
        var filtered = [];
        for(var i=0, ii=name.length; i<ii; i++) {
            var sub = ProjectKeyGenerator.CHARACTER_MAP[name.charCodeAt(i)];
            filtered.push(sub ? sub : name[i]);
        }
        name = filtered.join('');

        // Split into words
        var words = [];
        $.each(name.split(/\s+/), function(i, word) {
            if (word) {
                // Remove whitespace and punctuation characters (i.e. anything not A-Z)
                word = word.replace(/[^a-zA-Z]/g, "");
                // uppercase the word (NOTE: JavaScript attempts to convert characters like § in to SS)
                word = word.toUpperCase();
                // add the word, should it be worthy.
                word.length && words.push(word);
            }
        });

        // Remove ignored words
        if (ProjectKeyGenerator.desiredKeyLength && ProjectKeyGenerator.getTotalLength(words) > ProjectKeyGenerator.desiredKeyLength) {
            words = ProjectKeyGenerator.removeIgnoredWords(words);
        }

        var key;

        if (words.length == 0) {
            // No words were worthy!
            key = "";
        } else if (words.length == 1) {
            // If we have one word, and it is longer than a desired key, get the first syllable
            var word = words[0];
            if (ProjectKeyGenerator.desiredKeyLength && word.length > ProjectKeyGenerator.desiredKeyLength) {
                key = ProjectKeyGenerator.getFirstSyllable(word);
            } else {
                // The word is short enough to use as a key
                key = word;
            }
        } else {
            // If we have more than one word, just take the first letter from each
            key = ProjectKeyGenerator.createAcronym(words);
        }

        // Limit the length of the key
        if (ProjectKeyGenerator.maxKeyLength && key.length > ProjectKeyGenerator.maxKeyLength) {
            key = key.substr(0, ProjectKeyGenerator.maxKeyLength);
        }

        return key;
    };
    return ProjectKeyGenerator;
});
AJS.namespace('JPT.ProjectKeyGenerator', null, require('jira/project-templates/project-key-generator'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/DialogView.js' */
// Warning!
//This module has a hidden circular dependency -> jira/project-templates/dialog-controller
define('jira/project-templates/dialog-view-impl', [
    'require',
    'backbone',
    'underscore'
], function(
    require,
    Backbone,
    _
){
    var Dialog = AJS.Dialog;
    var Trigger = AJS.trigger;

    return Backbone.View.extend({
        events: {
            "click   .add-project-trigger": "_onClickAddProject",
            "click   .add-demo-project-trigger": "_onClickAddDemoProject",
            "click   .add-workflow-link": "_onClickViewMarketplaceWorkflows",
            "click   #add-project-dialog .add-demo-project-trigger": "_onCreateProjectAddDemoProjectClick",
            "click   #add-project-dialog .import-project-trigger": "_onClickImportProject",
            "click   #add-project-dialog .create-with-shared-config": "_onClickCreateShared",
            "keydown #add-project-dialog .pt-templates-list": "_onKeydownInTemplatesList"
        },

        draw: function() {
            var dialog = new Dialog({
                width: 840,
                height: 400,
                id: "add-project-dialog",
                closeOnOutsideClick: false,
                keypressListener: _.bind(this._onKeyPressed, this)
            });

            var $dialog = dialog.popup.element;

            dialog.addPage("project-templates-page");

            dialog.addHeader("Create project", "add-project-dialog-header");

            dialog.addPanel("ProjectTemplatesListPanel", JIRA.Templates.ProjectTemplates.loadingTemplatesList(), "pt-content");

            this._dialog = dialog;
            this._$dialogElement = $dialog;

            dialog.show();

            return dialog;
        },

        /**
         * Removes this DialogView.
         *
         * @return {*}
         */
        remove: function() {
            this._dialog && this._dialog.remove();
        },

        showErrorMessage: function(message) {
            this._dialog.getPanel(1, 0).html(JIRA.Templates.errorMsg({
                closable: false,
                msg: message
            }));
        },

        get$PTContent: function getPTContent() {
            return this.getDialogController().$dialogElement.find(".pt-content");
        },

        /**
         * Removes this dialog when ESC is pressed. Note that this is called on keydown anywhere within the dialog,
         * including all steps of the wizard, so you want to be careful about what you do in here.
         *
         * @param {jQuery.Event} e the keydown Event
         * @returns {boolean}
         * @private
         */
        _onKeyPressed: function(e) {
            var escapeKey = 27;
            if (this._dialog) {
                if (e.keyCode === escapeKey) {
                    this.getDialogController().hideDialogFromNewUser("dismissed");
                    this._dialog.remove();
                    return false; // preventDefault, don't propagate.
                }
            }

            return true;
        },

        /**
         * Proceeds to the next step of the wizard when the user presses ENTER in the project templates list.
         * Unfortunately in this case we can't rely on browser auto-submit of forms because the focus is not inside a
         * text input/
         *
         * @param {jQuery.Event} e
         * @returns {boolean}
         * @private
         */
        _onKeydownInTemplatesList: function(e) {
            var enterKey = 13;
            if (this._dialog) {
                if (e.keyCode === enterKey) {
                    this._$dialogElement.find(".pt-submit-button:visible").click();
                    return false;
                }
            }

            return true;
        },

        _onClickAddProject: function(event) {
            event.preventDefault();
            this.getDialogController().handleProjectTemplateTriggered();
        },

        _onCreateProjectAddDemoProjectClick: function() {
            Trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.demo.create.project.clicked'});
        },

        _onClickViewMarketplaceWorkflows: function () {
            Trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.viewmarketplaceworkflows.clicked'});
        },

        _onClickAddDemoProject: function(event) {
            event.preventDefault();
            var dialog = this.getDialogController().dialog;
            if (dialog && dialog.popup && dialog.popup.element) {
                dialog.remove();
            }
            this.getDialogController().handleDemoProjectTemplateTriggered();
        },

        _onClickImportProject: function(event) {
            this.getDialogController().hideDialogFromNewUser("importproject");
        },

        _onClickCreateShared: function(event) {
            this.getDialogController().handleCreateShared();
        },

        getDialogController: function() {
            return require('jira/project-templates/dialog-controller');
        }
    });
});

define('jira/project-templates/dialog-view', [
    'jira/project-templates/dialog-view-impl',
    'jquery'
], function(
    DialogViewImpl,
    $
){
    return new DialogViewImpl({ el: $(document) });
});
AJS.namespace('JPT.DialogView', null, require('jira/project-templates/dialog-view'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/DialogController.js' */
// Warning!
// This module has a hidden circular dependencies -> jira/project-templates/select-project-template-controller
//                                                -> jira/project-templates/create-shared-controller
define('jira/project-templates/dialog-controller', [
    'jira/project-templates/dialog-view',
    'jira/project-templates/config',
    'jira/ajs/ajax/smart-ajax',
    'jira/util/data/meta',
    'jira/lib/class',
    'jquery',
    'underscore',
    'wrm/data'
], function(
    DialogView,
    Config,
    SmartAjax,
    Meta,
    Class,
    $,
    _,
    wrmData
){
    var contextPath = AJS.contextPath();
    var isDevMode = AJS.isDevMode;
    var log = AJS.log;

    function triggerAnalytics(name, params) {
        AJS.trigger('analyticsEvent', {name: name, data: params});
    }

    var ptAnalyticsData;
    var getPtAnalyticsData = function () {
        if( !ptAnalyticsData ) {
            ptAnalyticsData = wrmData.claim('com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources.ptAnalyticsData') || {};
        }
        return ptAnalyticsData;
    };

    var DialogController = Class.extend({
        WELCOME_REST_URL: contextPath + "/rest/welcome/1.0/show/welcome",

        initialize: function() {
            _.bindAll(this, 'handleProjectTemplateTriggered', 'hideDialogFromNewUser');

            if (Meta.getBoolean('show-welcome-screen')) {
                this.handleProjectTemplateTriggered();
            }
        },

        handleProjectTemplateTriggered: function() {
            this.demoProject = false;
            triggerAnalytics('jira.project.templates.dialog.create.show');
            this.openWithFirstProjectTemplateOfTypePreSelected();
        },

        handleDemoProjectTemplateTriggered: function() {
            this.demoProject = true;
            var projectTemplatesDeferred = this.getTemplateController().loadDemoProjectTemplatesData();
            this.openWithFirstProjectTemplateOfTypePreSelected(null, projectTemplatesDeferred);
            this._addAnalyticsToCreateDemoShow(projectTemplatesDeferred);
        },

        _addAnalyticsToCreateDemoShow: function (projectTemplatesDeferred) {
            projectTemplatesDeferred.done(function (data) {
                var params = {};

                var getDemoSets = function (data) {
                    return data.projectTemplatesGroupedByType.map(
                        function (ptGroup) {
                            return ptGroup.projectTemplates.map(
                                function (pt) {
                                    return pt.itemModuleCompleteKey
                                }).join();
                        }).join();
                };

                params.demoSets = getDemoSets(data);
                params.instanceCreatedDate = getPtAnalyticsData().instanceCreatedDate;

                triggerAnalytics('jira.project.templates.dialog.create.demo.show', params);
            }.bind(this));
        },

        openWithFirstProjectTemplateOfTypePreSelected: function(projectTypeKey, projectTemplatesDeferred) {
            projectTemplatesDeferred = projectTemplatesDeferred || this.getTemplateController().loadProjectTemplatesData();
            //draw dialog with spinner
            this.dialog  = DialogView.draw();

            projectTemplatesDeferred.fail(_.bind(function (jqXHR) {
                this._handleUnknownErrorOfPTRetrieval();
            }, this));

            projectTemplatesDeferred.done(_.bind(function (data) {
                this.$dialogElement = this.dialog.popup.element;

                // Persist the selected template (e.g. after coming back from a GH installation)
                var selectedTemplate;
                if (!_.isUndefined(Config.model.selectedTemplate)) {
                    selectedTemplate = Config.model.selectedTemplate;
                }
                Config.model = data;
                Config.model.selectedTemplate = selectedTemplate;
                this.getTemplateController().init(data, projectTypeKey);
            }, this));
        },

        handleCreateShared: function() {
            triggerAnalytics('jira.project.templates.dialog.create.shared.clicked');
            this.demoProject = false;
            this.openWithCreateShared();
        },

        openWithCreateShared: function() {
            var CreateSharedController = require('jira/project-templates/create-shared-controller');
            CreateSharedController.initCreateShared();
        },

        callbackWithResize: function(callback) {
            return _.bind(_.wrap(callback, function(originalCallback) {
                originalCallback.call(this);
                this.dialog.updateHeight();
            }), this);
        },

        addPage: function(pageConfig) {
            var page = this.dialog.addPage(pageConfig.name).page[this.dialog.curpage];
            this.dialog.addHeader(pageConfig.title, "add-project-dialog-header");
            this.dialog.addPanel(pageConfig.panelName, "", "pt-content");

            if (pageConfig.backButton) {
                this._addBackButton(page);
            }

            this.dialog.addButton(
                pageConfig.submitButtonText,
                this.callbackWithResize(pageConfig.submitButtonCallback),
                pageConfig.submitButtonClass + " pt-submit-button"
            );
            var $submitButton = this.$dialogElement.find("." + pageConfig.submitButtonClass);
            $submitButton.removeClass("button-panel-button").addClass("aui-button aui-button-primary"); /* button-panel-button class doesn't have disabled styles, using .aui-button instead */
            $submitButton.focus();

            this.dialog.addCancel("Cancel", _.bind(function(event) {
                this.hideDialogFromNewUser("dismissed");

                this.dialog.remove();
            }, this));

            return page;
        },

        _backButtonOnClickCallback: function(page) {
            return _.bind(function() {
                if (this.demoProject) {
                    triggerAnalytics("jira.project.templates.dialog.demo.back");
                } else {
                    triggerAnalytics("jira.project.templates.dialog.create.back");
                }
                var $addProjectWrapper = DialogView.get$PTContent();
                $addProjectWrapper.css('background-image', 'none');

                this.dialog.prevPage();
                page.remove();
                this.dialog.page.pop();
            }, this);
        },

        _addBackButton: function(page) {
            this.dialog.addButton(
                "Back",
                this.callbackWithResize(this._backButtonOnClickCallback(page)),
                "add-project-back-button"
            );
            var $backButton = this.$dialogElement.find(".add-project-back-button");
            $backButton.removeClass("button-panel-button").addClass("aui-button");
        },

        _handleUnknownErrorOfPTRetrieval: function() {
            DialogView.showErrorMessage("An error occurred while trying to contact JIRA");
        },

        hideDialogFromNewUser: function(reason) {
            if (reason === "dismissed") {
                if (this.demoProject) {
                    triggerAnalytics("jira.project.templates.dialog.demo.dismissed");
                } else {
                    triggerAnalytics("jira.project.templates.dialog.create.dismissed");
                }
            } else if (reason === "importproject") {
                triggerAnalytics('jira.project.templates.dialog.import.clicked');
            } else if (reason === "templateselected") {
                if (this.demoProject) {
                    triggerAnalytics("jira.project.templates.dialog.demo.templateselected");
                } else {
                    triggerAnalytics("jira.project.templates.dialog.create.templateselected");
                }
            }

            if (Meta.getBoolean('show-welcome-screen')) {
                $.ajax({
                    url: this.WELCOME_REST_URL + "/" + reason,
                    type: "DELETE",
                    success: function () {
                        if (isDevMode && isDevMode()) {
                            log("don't show project template dialog anymore");
                        }
                    }
                });
            }
        },

        getTemplateController: function() {
            return require('jira/project-templates/select-project-template-controller');
        }
    });

    return new DialogController();
});
AJS.namespace('JPT.DialogController', null, require('jira/project-templates/dialog-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/AddProjectView.js' */
// WARNING
// This module has a hidden circular dependency -> jira/project-templates/add-project-controller
define('jira/project-templates/add-project-view-impl', [
    'jira/project-templates/dialog-controller',
    'jira/project-templates/config',
    'jira/util/events',
    'jira/util/events/types',
    'require',
    'backbone',
    'jquery',
    'underscore'
], function(
    DialogController,
    Config,
    Events,
    EventTypes,
    require,
    Backbone,
    $,
    _
){
    var InlineDialog = AJS.InlineDialog;

    return Backbone.View.extend({
        TIMEOUT_MS: 100,

        postDrawCallbacks: [],

        events: {
            "submit #add-project-form": "onSubmitForm"
        },

        page: undefined,
        isSubmitting: false,

        initialize: function(options) {
            _.bindAll(this, "bindHook");
        },

        addPostDrawCallback: function(callback) {
            this.postDrawCallbacks.push(callback);
        },

        /**
         * Prepare the Dialog to hold the Add Project form; this should only be called once for a selected Project Template.
         * The actual form could be rendered multiple times after unsuccessful validations.
         */
        prepareDialog: function(title) {
            this.page = DialogController.addPage({
                name: "add-project",
                title: title,
                panelName: "add-project",
                backButton: true,
                submitButtonText: "Submit",
                submitButtonCallback: this.onSubmitForm.bind(this),
                submitButtonClass: "add-project-dialog-create-button"
            });
        },

        /**
         * Draw the Add Project form into the passed dialog, as a new screen.
         *
         * This will be triggered on clicking "Next", so should render on the second page.
         */
        draw: function(params) {
            function fixErrorObject(errors) {
                if (!errors.errors) {
                    errors.errors = {}
                }
                return errors;
            }
            this.isSubmitting = false;

            DialogController.dialog.gotoPage(this.page.id);

            var projectTemplateModuleCompleteKey = params.webItemData.projectTemplateModuleCompleteKey;
            var templateGroup = _.find(Config.model.projectTemplatesGroupedByType, function(templateGroup){
                return _.any(templateGroup.projectTemplates, function(template) {
                    return template.itemModuleCompleteKey == projectTemplateModuleCompleteKey
                });
            });
            var applicationName = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.applicationName) || '';
            var usedSeats = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.licenseUsedSeats) || 0;
            var totalSeats = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.licenseTotalSeats) || 0;
            var canUserBeAddedToApplication = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.canUserBeAddedToApplication) || false;
            var canUserUseApplication = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.canUserUseApplication) || false;
            var isOnDemand = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.ondemand) || false;
            var displayCheckbox;
            if (!templateGroup || !templateGroup.applicationInfo) {
                displayCheckbox = false;
            } else {
                displayCheckbox = !canUserUseApplication;
            }

            var soyParameters = {
                maxNameLength: Config.model.maxNameLength,
                maxKeyLength: Config.model.maxKeyLength,
                shouldShowLead: Config.model.shouldShowProjectLead,
                projectTemplateWebItemKey: Config.model.selectedTemplate || params.webItemData.itemModuleCompleteKey,
                projectTemplateModuleKey: projectTemplateModuleCompleteKey,
                projectTemplateTitle: params.webItemData.name,
                projectTemplateDescriptionContent: params.webItemData.longDescriptionContent,
                currentKey: params.currentKey || "",
                currentName: params.currentName || "",
                errors: fixErrorObject(params.errors),
                projectLeadPickerField: {
                    id: 'lead',
                    name: 'lead'
                },
                addUserToLicense: {
                    displayCheckbox: displayCheckbox,
                    disableCheckbox: !canUserBeAddedToApplication,
                    applicationName: applicationName,
                    usedSeats: usedSeats,
                    totalSeats: totalSeats,
                    fieldId: 'licenseUser',
                    fieldName: 'licenseUser',
                    licensingUrl: isOnDemand? '/admin/accessconfig' : '/plugins/servlet/applications/versions-licenses'
                },
                leadOptions: [
                    {
                        selected: true,
                        displayName: params.currentUserDisplayName,
                        optionName: params.currentUserName,
                        avatarURL: params.currentUserAvatarUrl
                    }
                ]
            };
            var addProjectForm = JIRA.Templates.ProjectTemplates.addProjectForm(soyParameters);

            DialogController.dialog.getPanel(this.page.id, 0).html(addProjectForm);

            if (params.webItemData && params.webItemData.backgroundIconUrl) {
                var $addProjectWrapper = DialogController.$dialogElement.find(".pt-content");
                $addProjectWrapper.css('background-image', 'url("' + params.webItemData.backgroundIconUrl + '")');
            }

            var $addProjectForm = $("#add-project-form");
            // fire event to create the Single User Picker
            Events.trigger(EventTypes.NEW_CONTENT_ADDED, [$addProjectForm]);

            this.nameElement = DialogController.$dialogElement.find("#name");
            this.keyElement = DialogController.$dialogElement.find("#key");
            this.keyEditedElement = DialogController.$dialogElement.find("#keyEdited");
            this.leadDisplayElement = DialogController.$dialogElement.find("#lead-field");
            this.leadValueElement = DialogController.$dialogElement.find("#lead");

            var $keyHelpElement = this.keyElement.parent().find(".aui-icon-help");
            if ($keyHelpElement.length) {
                new InlineDialog($keyHelpElement, "project-key-help-popup",
                    function(contents, trigger, show) {
                        contents.html(JIRA.Templates.ProjectTemplates.keyHelp());
                        show();
                    }, {
                        width: 330,
                        offsetX: -30
                    });
            }

            // Input restrictions
            this.keyElement.attr("style", "text-transform: uppercase");

            var AddProjectController = require('jira/project-templates/add-project-controller');

            this.nameElement.focus(_.bind(function(e) {
                this.bindHook(e, AddProjectController.nameTimeout);
            }, this));

            var self = this;
            this.nameElement.change(function (e){
                AddProjectController.validateName();
                self.unbindHook(e);
            });

            this.nameElement.focus();

            this.keyElement.focus(_.bind(function(e) {
                var el = $(e.target);
                el.data("lastValue", el.val());
                this.bindHook(e, AddProjectController.keyTimeout);
            }, this));

            this.keyElement.blur(_.bind(function(e) {
                this.unbindHook(e);
            }, this));

            this.keyElement.change(function() {
                AddProjectController.validateKey();
                AddProjectController.autofillKeyIfNeeded();
            });
            if (!_.isEmpty(this.postDrawCallbacks)) {
                _.each(this.postDrawCallbacks, function(callback) {
                    callback();
                });
            }
            DialogController.dialog.updateHeight();
        },

        /**
         * Submits the "Add Project" form.
         *
         * @param {jQuery.Event} e the submit event
         * @returns {boolean}
         */
        onSubmitForm: function(e) {
            var AddProjectController = require('jira/project-templates/add-project-controller');
            AddProjectController.submit();
            return false;
        },

        get$SubmitButton: function() {
            return DialogController.$dialogElement.find(".add-project-dialog-create-button");
        },

        get$BackButton: function() {
            return DialogController.$dialogElement.find(".add-project-back-button");
        },

        bindHook: function bindHook(e, func) {
            var el = $(e.target), hook;
            hook = _.bind(function() {
                this.unbindHook(e);
                func.apply();
                if (el.is(":visible")) {
                    el.data("checkHook", setTimeout(hook, this.TIMEOUT_MS));
                }
            }, this);
            if (!el.data("checkHook")) {
                el.data("checkHook", setTimeout(hook, 0));
            }
        },

        unbindHook: function(e) {
            var el = $(e.target);
            clearTimeout(el.data("checkHook"));
            el.removeData("checkHook");
        },

        /**
         * Show an error for an input element, in the place of its description.
         *
         * @param $element
         * @param msg
         */
        showInlineError: function($element, msg) {
            if (this.isSubmitting) {
                // while the form is being submitted, don't show any late validation errors
                return;
            }
            var $errorElement = $element.parent().find(".error");
            if (!$errorElement.length) {
                $errorElement = $("<div class='error'></div>");
                $element.parent().append($errorElement);
            }
            $errorElement.text(msg);
            $errorElement.show();
        },

        showInlineErrorForName: function showInlineErrorForName(msg) {
            this.showInlineError(this.nameElement, msg);
        },

        showInlineErrorForKey: function showInlineErrorForKey(msg) {
            this.showInlineError(this.keyElement, msg);
        },

        /**
         * Hide any errors for an input field shown by showInlineError, and its description.
         *
         * @param $element
         */
        hideInlineError: function hideInlineError($element) {
            $element.parent().find(".error").hide();
        },

        hideInlineErrorForName: function hideInlineErrorForName() {
            this.hideInlineError(this.nameElement);
        },

        hideInlineErrorForKey: function hideInlineErrorForKey() {
            this.hideInlineError(this.keyElement);
        },

        setName: function setName(value) {
            this.nameElement.val(value);
        },

        getName: function getName() {
            return this.nameElement.val();
        },

        setKey: function setKey(value) {
            this.keyElement.val(value);
        },

        getKey: function getKey() {
            return this.keyElement.val().toUpperCase();
        },

        getLeadDisplayName: function getLeadDisplayName() {
            return this.leadDisplayElement.val();
        },

        getLeadUserName: function getLeadUserName() {
            return this.leadValueElement.val();
        },

        getAvatarUrlOfSelectedLead: function getAvatarUrlOfSelectedLead() {
            var userAvatarBackGroundProperty = DialogController.$dialogElement.find("#lead-single-select .aui-ss-entity-icon").css('background-image');
            if (!_.isUndefined(userAvatarBackGroundProperty)) {
                var userAvatarUrl = userAvatarBackGroundProperty.match(/^url\((.+)\)$/);
                return (userAvatarUrl && userAvatarUrl[1]) ? userAvatarUrl[1] : "";
            } else {
                return "";
            }
        },

        setKeyEdited: function setKeyEdited(value) {
            this.keyEditedElement.val(value);
        },

        getKeyEdited: function getKeyEdited() {
            return this.keyEditedElement.val();
        },

        setKeyEdited: function setKeyEdited() {
            var key = this.getKey();
            // If the key is manually edited, do not suggest automatically generated keys anymore
            // If the key field is cleared, resume suggesting automatically generated keys
            if (this.keyElement.data("lastValue") !== key) {
                this.keyEditedElement.val((key) ? "true" : "false");
            }
            this.keyElement.data("lastValue", key);
        },

        hasNameErrors: function hasNameErrors() {
            return this.nameElement.parent().find(".error").size() > 0;
        },

        getAddProjectForm: function getAddProjectForm() {
            return $("#add-project-form");
        },

        get$FormFields: function getFormFields() {
            return DialogController.$dialogElement.find(":input");
        },

        enterLoadingState: function showLoadingState() {
            $submitButton = this.get$SubmitButton();
            if (!$submitButton.attr("disabled")) {
                $backButton = this.get$BackButton();
                $submitButton.attr("disabled", "disabled");
                $backButton.attr("disabled", "disabled");
                $backButton.before(
                    JIRA.Templates.ProjectTemplates.spinner({
                        id: "addproject-loading"
                    }));
                this.get$FormFields().attr('disabled', 'disabled');

                this.isSubmitting = true;

                return true;
            } else {
                return false;
            }
        },

        hideLoadingState: function hideLoadingState() {
            DialogController.$dialogElement.find("#addproject-loading").remove();
            this.get$SubmitButton().removeAttr('disabled');
            this.get$BackButton().removeAttr('disabled');
            this.get$FormFields().removeAttr('disabled');
        },

        avoidDirtyFormWarning: function avoidDirtyFormWarning() {
            if ($.fn.removeDirtyWarning) {
                this.getAddProjectForm().removeDirtyWarning();
            }
        },

        hasInlineErrors: function hasInlineErrors() {
            return DialogController.$dialogElement.find(".field-group .error:visible").length != 0;
        }

    });
});
define('jira/project-templates/add-project-view', [
    'jira/project-templates/add-project-view-impl',
    'jira/project-templates/dialog-view',
    'jquery'
], function(
    AddProjectViewImpl,
    DialogView,
    $
) {
    return new AddProjectViewImpl({
        el: $(document),
        dialogView: DialogView
    });
});

AJS.namespace('JPT.AddProjectView', null, require('jira/project-templates/add-project-view'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/AddProjectController.js' */
define('jira/project-templates/add-project-controller-impl', [
    'jira/project-templates/add-project-view',
    'jira/project-templates/project-key-generator',
    'jira/project-templates/dialog-controller',
    'jira/project-templates/config',
    'jira/lib/class',
    'jquery',
    'underscore'
], function (
    AddProjectView,
    ProjectKeyGenerator,
    DialogController,
    Config,    
    Class,
    $,
    _
){
    var contextPath = AJS.contextPath();
    var trigger = AJS.trigger;

    return Class.extend({
        postProjectCreationCallbacks: [],
        projectKeyValidationCallbacks: [],
        projectNamesUpperCased: [],

        init: function (options) {
            this._window = options.window || window; // used for mocking 'window' in QUnit
            _.bindAll(this, "projectCreatedHandler", "projectValidationFailedHandler", "nameTimeout", "keyTimeout", "submit");
        },

        initCreateShared: function (existingProjectData) {
            this.existingProjectData = existingProjectData;
            this._initAddProject("Create with shared configuration");
        },

        initProjectTemplate: function (webItemData) {
            this.existingProjectData = undefined;
            this.webItemData = webItemData;
            this._initAddProject(webItemData.name);
        },

        _initAddProject: function (title) {
            this.desiredKeyLength = 4;
            this.lastKeyValidated = "";

            this._getExistingProjects();
            ProjectKeyGenerator.init(this.desiredKeyLength, Config.model.maxKeyLength);

            AddProjectView.prepareDialog(title);
            AddProjectView.draw({
                webItemData: this.webItemData || {},
                maxKeyLength: Config.model.maxKeyLength,
                maxNameLength: Config.model.maxNameLength,
                currentUserName: Config.model.currentUserName,
                currentUserDisplayName: Config.model.currentUserDisplayName,
                currentUserAvatarUrl: Config.model.currentUserAvatarUrl,
                errors: {}
            });
        },

        _resetProjectLeadValues: function () {
            Config.model.currentUserDisplayName = "";
            Config.model.currentUserName = "";
            Config.model.currentUserAvatarUrl = "";
        },

        _hasFullyConfiguredProjectLead: function () {
            return AddProjectView.getLeadDisplayName() && AddProjectView.getAvatarUrlOfSelectedLead() != "";
        },

        submit: function (event) {
            // This data is retrieved before the input fields are disabled (in enterLoadingState()) to avoid null-pointer exceptions when the fields are empty.
            var formData;
            if (this.existingProjectData) {
                formData = {
                    "key": AddProjectView.getKey(),
                    "name": AddProjectView.getName(),
                    "lead": AddProjectView.getLeadUserName() && AddProjectView.getLeadUserName()[0]
                };
            } else {
                formData = jQuery.param(AddProjectView.getAddProjectForm().serializeArray().map(function(param) {
                    // upper case is "visually" enforced by text-transform: uppercase
                    if (param.name === "key") {
                        param.value = param.value.toUpperCase();
                    }
                    return param
                }));
            }

            if (AddProjectView.hasInlineErrors()) {
                return;
            }

            if (AddProjectView.enterLoadingState()) {
                // store lead so we can repopulate the user picker for when the submit fails
                if (this._hasFullyConfiguredProjectLead()) {
                    Config.model.currentUserDisplayName = AddProjectView.getLeadDisplayName();
                    Config.model.currentUserName = Config.model.currentUserDisplayName ? AddProjectView.getLeadUserName() : "";
                    Config.model.currentUserAvatarUrl = AddProjectView.getAvatarUrlOfSelectedLead();
                } else {
                    this._resetProjectLeadValues();
                }

                if (this.existingProjectData) {
                    $.ajax({
                        url: contextPath + "/rest/project-templates/1.0/createshared/" + this.existingProjectData.existingProjectId,
                        type: "POST",
                        contentType: "application/json",
                        data: JSON.stringify(formData)
                    }).then(this.projectCreatedHandler, this.projectValidationFailedHandler);
                } else {
                    $.ajax({
                        url: contextPath +
                            (this.webItemData.demoProject ?
                                "/rest/jira-importers-plugin/1.0/demo/create" :
                                "/rest/project-templates/1.0/templates"),
                        type: "POST",
                        data: formData,
                        headers: {
                            "X-Atlassian-Token": "nocheck"
                        }
                    }).then(this.projectCreatedHandler, this.projectValidationFailedHandler);
                }
            }
        },

        registerPostProjectCreationCallback: function (callback) {
            this.postProjectCreationCallbacks.push(callback);
        },

        registerProjectKeyValidationCallback: function (callback) {
            this.projectKeyValidationCallbacks.push(callback);
        },

        localStoragePrefix: "jira.projecttemplates.",

        projectCreatedHandler: function (data) {
            if (this.existingProjectData) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.shared.project.create.success'});
            } else if (this.webItemData.demoProject) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.demo.success'});
            } else {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.project.success'});
            }
            AddProjectView.avoidDirtyFormWarning();

            // Put the created projects into local storage
            var localStoragePrefix = this.localStoragePrefix;
            var remoteProjectTypes = ["confluenceProject", "fisheyeProject", "crucibleProject", "bambooProject"];
            _.map(remoteProjectTypes, function (remoteProject) {
                if (data.remoteProjectLinks && data.remoteProjectLinks[remoteProject]) {
                    localStorage.setItem(localStoragePrefix + remoteProject, data.remoteProjectLinks[remoteProject]);
                }
            });


            // If there are any post Project Created callbacks registered, call these. Otherwise redirect to the desired return URL.
            if (!_.isEmpty(this.postProjectCreationCallbacks)) {
                DialogController.dialog.addPage("post-project-created-page");
                _.each(this.postProjectCreationCallbacks, function (callback) {
                    callback(DialogController.dialog, data.returnUrl, data.projectId, data.projectKey, data.projectName);
                });
            } else {
                this._window.location = contextPath + data.returnUrl;
            }
        },

        projectValidationFailedHandler: function (jqXhr, textStatus) {
            if (this.existingProjectData) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.shared.project.create.failure'});
            } else if (this.webItemData.demoProject) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.demo.failure'});
            } else {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.project.failure'});
            }

            var errors = {};
            if (this.isBadRequest(jqXhr)) {
                errors = JSON.parse(jqXhr.responseText);
            } else if (this.isUnDefinedServerSideError(jqXhr)) {
                errors = {"errorMessages": ["Hmm... we couldn\'t create your project due to an unknown error. Try refreshing the page to start again."]}
            } else if (this.isDefinedServerSideError(jqXhr)) {
                var errorResponse = JSON.parse(jqXhr.responseText);
                // Project template configuration threw an exception: Project has been created but the template hasn't been configured
                JIRA.Messages.showReloadErrorMsg(errorResponse.message);
                AddProjectView.avoidDirtyFormWarning();
                this._window.location = contextPath + errorResponse.returnUrl;
                // Remain in loading state while refreshing.
                return;
            } else if (this.isTimeoutError(textStatus)) {
                errors = {"errorMessages": ["Request timeout when creating project"]}
            } else {
                // Different kind of error. Let's generate an errors object with a general error that contains the right information
                errors = {"errorMessages": [AJS.format("Error creating project, {0}", jqXhr.responseText)]}
            }

            AddProjectView.draw({
                webItemData: this.webItemData || {},
                errors: errors,
                currentName: AddProjectView.getName(),
                currentKey: AddProjectView.getKey(),
                currentUserDisplayName: Config.model.currentUserDisplayName,
                currentUserName: Config.model.currentUserName,
                currentUserAvatarUrl: Config.model.currentUserAvatarUrl
            });

            AddProjectView.hideLoadingState();
        },

        isBadRequest: function(jqXhr) {
            return (jqXhr.status === 400) ;
        },

        isUnDefinedServerSideError: function(jqXhr){
            if (jqXhr.status === 500) {
                try {
                    JSON.parse(jqXhr.responseText);
                } catch(e) {
                    return true;
                }
            }
            return false;
        },

        isDefinedServerSideError: function(jqXhr) {
            return jqXhr.status === 500 && !_.isUndefined(JSON.parse(jqXhr.responseText).message) ;
        },

        isTimeoutError: function(textStatus) {
            return textStatus === "timeout" ;
        },

        _updateAndValidateKey: function updateKey(key) {
            AddProjectView.setKey(key);
            this.validateKey();
        },

        _shouldUpdateKey: function _shouldUpdateKey() {
            return (AddProjectView.getKeyEdited() != "true");
        },

        autofillKeyIfNeeded: function autofillKeyIfNeeded() {
            if (this._shouldUpdateKey()) {
                var key = ProjectKeyGenerator.generate(AddProjectView.getName());
                // JRADEV-10797 - Rather than validate the key,
                // we'll pretend that a key is always invalid if it's less than 1 character long.
                if (key.length > 1) {
                    this._updateAndValidateKey(key);
                } else {
                    // Blank the key without validation.
                    AddProjectView.setKey("");
                }
            }
        },

        _doesProjectNameExists: function (name) {
            var x;
            for (x in this.projectNamesUpperCased) {
                if (name.toUpperCase() == this.projectNamesUpperCased[x]) {
                    return true;
                }
            }

            return false;
        },

        validateName: function () {
            var name = $.trim(AddProjectView.getName());

            if (!name) {
                return;
            }

            if (name.length < Config.model.minNameLength) {
                AddProjectView.showInlineErrorForName(AJS.format("The project name should be at least {0} characters in length.", Config.model.minNameLength));
                return;
            }

            if (name.length > Config.model.maxNameLength) {
                AddProjectView.showInlineErrorForName(AJS.format("The project name must not exceed {0} characters in length.", Config.model.maxNameLength));
                return;
            }

            if (this._doesProjectNameExists(name)) {
                AddProjectView.showInlineErrorForName("A project with that name already exists.");
                return;
            }

            AddProjectView.hideInlineErrorForName();
        },

        _performKeyValidationChecks: function (key) {
            var validationChecksDeferred = $.ajax({
                url: contextPath + "/rest/api/latest/projectvalidate/key?key=" + key.toUpperCase()
            });

            validationChecksDeferred.done(_.bind(function (errors) {
                if (errors.errors && errors.errors["projectKey"]) {
                    AddProjectView.showInlineErrorForKey(errors.errors["projectKey"]);
                } else {
                    var foundError = false;
                    _.each(this.projectKeyValidationCallbacks, function (callback) {
                        var errors = callback(key.toUpperCase());
                        if (errors.errors && errors.errors["projectKey"]) {
                            foundError = true;
                            AddProjectView.showInlineErrorForKey(errors.errors["projectKey"]);
                        }
                    });
                    if (!foundError) {
                        AddProjectView.hideInlineErrorForKey();
                    }
                }
            }, this));
        },

        validateKey: function validateKey() {
            var key = AddProjectView.getKey();

            // Only validate the key if it has changed since the last time we validated it
            if (this.lastKeyValidated === key) {
                return;
            }

            if (key) {
                this.lastKeyValidated = key;
                this._performKeyValidationChecks(key);
            } else {
                AddProjectView.hideInlineErrorForKey();
            }
        },

        nameTimeout: function nameTimeout() {
            this.autofillKeyIfNeeded();
        },

        keyTimeout: function keyTimeout() {
            AddProjectView.setKeyEdited();
        },

        _getExistingProjects: function () {
            // Avoid retrieving the list twice (e.g. after hitting the 'Back' button and selecting new template)
            if (this.projectNamesUpperCased.length > 0) {
                return this.projectNamesUpperCased;
            }

            var existingProjectsDeferred = $.ajax({
                url: contextPath + "/rest/api/latest/project"
            });

            existingProjectsDeferred.done(_.bind(function (projects) {
                this.projectNamesUpperCased = _.map(projects, function (project) {
                    return project.name.toUpperCase();
                });
            }, this));
        }
    });
});
define('jira/project-templates/add-project-controller', [
    'jira/project-templates/add-project-controller-impl',
    'jquery'
], function(
    AddProjectControllerImpl,
    $
){
    return new AddProjectControllerImpl({el: $(document)});
});
AJS.namespace('JPT.AddProjectController', null, require('jira/project-templates/add-project-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/TemplateInfoView.js' */
// Warning!
// This module has a hidden circular dependency -> jira/project-templates/template-info-controller
define('jira/project-templates/template-info-view', [
    'jira/project-templates/dialog-controller',
    'require',
    'backbone',
    'jquery',
    'underscore'
], function(
    DialogController,
    require,
    Backbone,
    $,
    _
){
    var trigger = AJS.trigger;

    return Backbone.View.extend({

        initialize: function(options) {
            _.bindAll(this, "draw", "onNext")
        },

        draw: function(templatePath, name) {
            var page = DialogController.addPage({
                name: "template-info",
                title: name,
                panelName: "template-info",
                backButton: true,
                submitButtonText: "Select",
                submitButtonCallback: this.onNext,
                submitButtonClass: "template-info-dialog-create-button"
            });

            var templateInfoPanel = this._nameToObj(templatePath)();
            DialogController.dialog.getPanel(page.id, 0).html(templateInfoPanel);

            DialogController.dialog.gotoPage(page.id);
        },

        _nameToObj: function(name) {
            return _.reduce(name.split('.'), function(obj, name) { if (obj) return obj[name]; }, window);
        },

        onNext: function(e) {
            trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.templateinfo.next'});
            // This is a workaround to resolve circular dependencies between these two modules.
            var TemplateInfoController = require('jira/project-templates/template-info-controller');
            TemplateInfoController.next();
            return false;
        }
    });
});
AJS.namespace('JPT.TemplateInfoView', null, require('jira/project-templates/template-info-view'));
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/TemplateInfoController.js' */

define('jira/project-templates/template-info-controller', [
    'jira/project-templates/template-info-view',
    'jira/lib/class',
    'require',
    'underscore'
], function(
    TemplateInfoView,
    Class,
    require,
    _
){
    var TemplateInfoController = Class.extend({

        init: function(options) {
            _.bindAll(this, "initTemplateInfo", "next");
        },

        initTemplateInfo: function(projectTemplateData) {
            this.projectTemplateData = projectTemplateData;

            var infoView = new TemplateInfoView();
            infoView.draw(projectTemplateData.infoSoyPath, projectTemplateData.name);
        },

        next: function() {
            var SelectProjectTemplateController = require('jira/project-templates/select-project-template-controller');
            SelectProjectTemplateController.openAddProjectPage(this.projectTemplateData);
        }
    });
    return new TemplateInfoController();
});
AJS.namespace('JPT.TemplateInfoControllerImpl', null, require('jira/project-templates/template-info-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/SelectProjectTemplateView.js' */
// Warning!
// This module has a hidden circular dependency -> jira/project-templates/select-project-template-controller
define('jira/project-templates/select-project-template-view', [
    'jira/project-templates/dialog-controller',
    'jira/project-templates/config',
    'jira/featureflags/feature-manager',
    'require',
    'backbone',
    'jquery',
    'underscore'
], function(
    DialogController,
    Config,
    featureManager,
    require,
    Backbone,
    $,
    _
){
    var contextPath = AJS.contextPath();
    var preventDefault = AJS.preventDefault;

    return {
        ROW_LENGTH: 2,
        DIALOG_BODY_CLASS: "select-project-templates-page",
        DIALOG_WIDTH: 800,

        draw: function(data, projectType) {
            var SelectProjectTemplateController = require('jira/project-templates/select-project-template-controller');
            this.page = DialogController.addPage({
                name: this.DIALOG_BODY_CLASS,
                title: data.demoProjects ? "Create project with sample data" : "Create project",
                panelName: "ProjectTemplatesListPanel",
                backButton: false,
                submitButtonText: "Next",
                submitButtonCallback: SelectProjectTemplateController.dialogSubmitted,
                submitButtonClass: "create-project-dialog-create-button"
            });

            function getHtml() {
                if (SelectProjectTemplateController.isProjectTypesEnabled(data)) {
                    return JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType({
                        projectTemplatesByType: data.projectTemplatesGroupedByType
                    });
                }
                return JIRA.Templates.ProjectTemplates.renderProjectTemplates({
                    projectTemplates: data.projectTemplates
                });
            }

            DialogController.dialog.getPanel(this.page.id, 0).html(getHtml());

            if (Config.model.projectCount >= 2 && !data.demoProjects) {
                $(JIRA.Templates.ProjectTemplates.addWorkflowsLink({
                    baseUrl : contextPath
                })).appendTo(DialogController.$dialogElement.find(".dialog-title"));
            }

            var $nextButton = DialogController.$dialogElement.find(".create-project-dialog-create-button");
            var self = this;
            this.getTemplateItems().click(function() {
                var $this = $(this);
                $this.addClass("selected");
                self.getTemplateItems().not(this).removeClass("selected");
            }).dblclick(function() {
                $nextButton.click();
            }).focus(function () {
                $(this).click();
            });

            var $templatesContainer = this.get$TemplatesContainer();

            if (!data.demoProjects) {
                $(JIRA.Templates.ProjectTemplates.footerLinks({
                    showDemoLink: featureManager.isFeatureEnabled("jira.onboarding.cyoa")
                }))
                        .prependTo(DialogController.$dialogElement.find(".dialog-button-panel"));
            }

            this.bindKeyboardEvents($templatesContainer);

            if(SelectProjectTemplateController.isProjectTypesEnabled(data)) {
                if((data.projectTemplatesGroupedByType).length == 0) $nextButton.attr("disabled", "disabled");
            } else {
                if((data.projectTemplates).length == 0) $nextButton.attr("disabled", "disabled");
            }

            this.focusOnFirstTemplate($templatesContainer, projectType);

            DialogController.dialog.updateHeight();
            this.truncateTemplateDescriptions();
            this.resizeTemplateWidths();
        },

        get$TemplatesContainer: function() {
            return DialogController.$dialogElement.find('.templates');
        },

        focusOnFirstTemplate: function($templatesContainer, projectType) {
            if (projectType) {
                this.getFirstTemplateItemOfProjectType(projectType).click();
            } else {
                this.getFirstTemplateItem().click();
            }
            // Make sure me don't loose the focus because of any other interactions
            setTimeout(function (){
                $templatesContainer.focus();
            }, 0);
        },

        getSelectedTemplateData: function() {
            var $selectedTemplate = DialogController.$dialogElement.find(".template.selected");

            return $selectedTemplate.data();
        },

        /**
         * Converts arrow directions into sibling movement amounts in a grid.
         * @param which - the code of the key pressed
         * @return {Number} the amount to move, or 0 if no move should occur for this key code
         */
        getMoveDeltaForKey: function (which) {
            switch (which) {
                case 37: return -1; // left
                case 39: return +1; // right
                case 38: return -this.ROW_LENGTH; // up
                case 40: return +this.ROW_LENGTH; // down
            }
            return 0;
        },

        /**
         * Key-bindings on arrow-keys to change the selected template in the template container.
         */
        bindKeyboardEvents: function ($container) {
            $container.bind("keydown", _.bind(function (e) {
                var delta = this.getMoveDeltaForKey(e.which);
                if (delta) {
                    this.moveSelection($container, delta);
                    return preventDefault(e);
                }
            }, this));
        },

        /**
         * Move the selection in the template container forward or backward by a specified number of templates
         * @param container the template container jQuery object
         * @param delta - positive to move forward, negative to move backward
         */
        moveSelection: function (container, delta) {
            var $results = container.find('.template');
            var $selected = $results.filter('.selected');
            var index = $results.index($selected) + delta;
            if (index < $results.length && index >= 0) {
                var $next = $results.eq(index);
                $next.click().focus();

                this.scrollToSelectedElement($next);
            }
        },

        scrollToSelectedElement: function($selected) {
            var $itemContainer = $(".dialog-panel-body.pt-content");
            var itemContainerTopPosition = $itemContainer.offset().top;
            var nextTopPosition = $selected.offset().top;
            var nextBottomPosition = nextTopPosition + $selected.height();
            var itemContainerBottomPosition = itemContainerTopPosition + $itemContainer.height();

            if (nextTopPosition < itemContainerTopPosition) {
                $itemContainer.scrollTop($itemContainer.scrollTop() - (itemContainerTopPosition - nextTopPosition));
            } else if(nextBottomPosition > (itemContainerTopPosition + $itemContainer.height())) {
                $itemContainer.scrollTop($itemContainer.scrollTop() + nextBottomPosition - itemContainerBottomPosition);
            }
        },

        get$NextButton: function() {
            return DialogController.$dialogElement.find(".create-project-dialog-create-button");
        },

        disableNextButton: function() {
            this.get$NextButton().attr('disabled','disabled');
        },

        truncateTemplateDescriptions: function() {
            var locale = AJS.Meta.get("user-locale");
            var wrap = "word";
            if (locale === "ja_JP") {
                wrap = "letter";
            }
            DialogController.$dialogElement.find(".template-description").each(function() {
                $(this).dotdotdot({
                    'wrap': wrap,
                    'lastCharacter': {
                        'remove'		: [ ' ', ',', ';', '.', '!', '?', '。' ],
                        'noEllipsis'	: []
                    }
                });
            });
        },

        getTemplatesDialogContainer: function() {
            return DialogController.$dialogElement
                    .find("." + this.DIALOG_BODY_CLASS)
                    .find(".dialog-panel-body.pt-content")
                    .get(0);
        },

        getFirstTemplateItem: function() {
            return this.getTemplateItems().first();
        },

        getFirstTemplateItemOfProjectType: function(projectType) {
            return this.getTemplateItems().filter("#project-template-group-" + projectType + " *").first();
        },

        getTemplateItems: function() {
            return DialogController.$dialogElement.find(".template");
        },

        widthOfScrollbarForElement: function(el) {
            var visibleWidth = el.offsetWidth;
            var visibleWidthWithoutBorders = el.clientWidth;

            return visibleWidth - visibleWidthWithoutBorders;
        },

        widthOfDialogAvailableForTemplateList: function() {
            var dialogScrollbarWidth = this.widthOfScrollbarForElement(this.getTemplatesDialogContainer());

            return this.DIALOG_WIDTH - dialogScrollbarWidth;
        },

        widthOfTemplateItem: function() {
            var maxWidthForEachItem = this.widthOfDialogAvailableForTemplateList() / this.ROW_LENGTH;

            return maxWidthForEachItem - this.borderWidthOfTemplateItem();
        },

        borderWidthOfTemplateItem: function() {
            var templateItemBorderWidthString = this.getFirstTemplateItem().css("border-top-width");

            return parseInt(templateItemBorderWidthString, 10);
        },

        resizeTemplateWidths: function() {
            this.getTemplateItems().each(_.bind(function(index, el) {
                $(el).css("width", this.widthOfTemplateItem());
            }, this));
        }
    };
});
AJS.namespace('JPT.SelectProjectTemplateView', null, require('jira/project-templates/select-project-template-view'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/SelectProjectTemplateController.js' */
define('jira/project-templates/select-project-template-controller', [
    'jira/project-templates/select-project-template-view',
    'jira/project-templates/template-info-controller',
    'jira/project-templates/add-project-controller',
    'jira/project-templates/dialog-controller',
    'jira/project-templates/dialog-view',
    'jira/project-templates/config',
    'wrm/context-path',
    'jquery',
    'underscore'
], function(
    SelectProjectTemplateView,
    TemplateInfoController,
    AddProjectController,
    DialogController,
    DialogView,
    Config,
    ContextPath,
    $,
    _
){
    var contextPath = ContextPath();
    var SelectProjectTemplateController = {
        init: function init(data, projectTypeKey) {
            SelectProjectTemplateView.draw(data, projectTypeKey);
        },

        /**
         * Returns true if project types have been enabled on the server.
         * @param data the model returned by the server
         * @returns {boolean} true if project types have been enabled on the server.
         */
        isProjectTypesEnabled: function isProjectTypesEnabled(data) {
            return data.projectTemplatesGroupedByType != null;
        },

        /**
         * Return a Promise that others can hook into that returns the data required.
         */
        loadProjectTemplatesData: function loadProjectTemplatesData() {
            // Perform AJAX request for web items in the dialog and return them.
            return $.ajax({
                url: contextPath + "/rest/project-templates/1.0/templates",
                type: "GET"
            });
        },

        loadDemoProjectTemplatesData: function loadProjectTemplatesData() {
            // Perform AJAX request for web items in the dialog and return them.
            return $.ajax({
                url: contextPath + "/rest/project-templates/1.0/templates/demo-projects",
                type: "GET"
            }).then(function(result) {
                result.demoProjects = true;
                return result;
            });
        },

        dialogSubmitted: function dialogSubmitted() {
            var projectTemplateData = SelectProjectTemplateView.getSelectedTemplateData();

            DialogController.hideDialogFromNewUser("templateselected");

            SelectProjectTemplateController.raiseAtlassianEvent(projectTemplateData.itemModuleCompleteKey);

            if (!_.isUndefined(projectTemplateData.infoSoyPath)) {
                TemplateInfoController.initTemplateInfo(projectTemplateData);
            } else {
                SelectProjectTemplateController.openAddProjectPage(projectTemplateData);
            }
        },

        openAddProjectPage: function openAddProjectPage(projectTemplateData) {
            if (!projectTemplateData) {
                // Null data? How did you get here? It should be impossible to have no selected item.
                DialogView.showErrorMessage("An error occurred while trying to contact JIRA");
                return;
            }

            // Should the template key be missing, go to the project configuration step
            if (projectTemplateData.createProject) {
                AddProjectController.initProjectTemplate(projectTemplateData);
                // Otherwise, no template key provided: fire an event passing the dialog, so the plugin can choose what to do next
            } else {
                DialogController.dialog.addPage("blank-template-page");
                $("body").trigger(projectTemplateData.itemModuleCompleteKey, DialogController.dialog);
            }
        },

        raiseAtlassianEvent: function raiseAtlassianEvent(projectTemplateModuleKey) {
            Config.model.selectedTemplate = projectTemplateModuleKey;
            if (AJS.EventQueue) {
                AJS.EventQueue.push({
                    name: "projecttemplates.templateselected",
                    properties: {
                        selectedTemplate: projectTemplateModuleKey
                    }
                });
            }
        }
    };
    return SelectProjectTemplateController;
});
AJS.namespace('JPT.SelectProjectTemplateController', null, require('jira/project-templates/select-project-template-controller'));
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/CreateSharedView.js' */
// Warning!
// This module has a hidden circular dependency -> jira/project-templates/create-shared-controller
define('jira/project-templates/create-shared-view', [
    'jira/project-templates/dialog-controller',
    'jira/project-templates/dialog-view',
    'jira/ajs/select/scrollable-single-select',
    'jira/ajs/select/suggestion-collection-model',
    'require',
    'backbone',
    'jquery'
], function(
    DialogController,
    DialogView,
    ScrollableSingleSelect,
    SuggestionCollectionModel,
    require,
    Backbone,
    $
){
    "use strict";

    var InlineDialog = AJS.InlineDialog;
    var trigger = AJS.trigger;

    var CreateSharedView = Backbone.View.extend({
        events: {
            "submit #create-shared-project-form": "onSubmitForm"
        },

        page: undefined,

        /**
         * Prepare the Dialog to hold the Create Shared Project form; this should only be called once.
         */
        prepareDialog: function(title) {
            var CreateSharedController = require('jira/project-templates/create-shared-controller');
            this.page = DialogController.addPage({
                name: "create-shared-project",
                title: title,
                panelName: "create-shared-project",
                backButton: true,
                submitButtonText: "Next",
                submitButtonCallback: CreateSharedController.dialogSubmitted,
                submitButtonClass: "create-shared-dialog-button"
            });
        },

        /**
         * Draw the Add Project form into the passed dialog, as a new screen.
         *
         * This will be triggered on clicking "Next", so should render on the second page.
         */
        draw: function(params) {
            DialogController.dialog.gotoPage(this.page.id);

            var createSharedForm = JIRA.Templates.ProjectTemplates.createSharedProjectForm({
                "projectSuggestions": JSON.stringify(params.projectSuggestions)
            });

            DialogController.dialog.getPanel(this.page.id, 0).html(createSharedForm);

            this._createProjectPicker();

            var $sharedHelpElement = DialogController.$dialogElement.find("#shared-help-icon");
            if ($sharedHelpElement.length) {
                new InlineDialog($sharedHelpElement, "shared-project-help-popup",
                        function(contents, trigger, show) {
                            contents.html(JIRA.Templates.ProjectTemplates.sharedHelp());
                            show();
                        }, {
                            width: 330,
                            offsetX: -30
                        });
            }

            DialogController.$dialogElement.find(".dialog-button-panel button").removeAttr("disabled");
        },

        showProjectMissingError: function () {
            this._clearFormErrors();

            this._getProjectPickerInput().after(aui.form.fieldError({
                extraClasses: 'project-picker-missing-error',
                message: "Please select an existing project first."
            }));
        },

        drawEmptyInfo: function() {
            var noProjects = JIRA.Templates.ProjectTemplates.noProjects();
            DialogController.dialog.getPanel(this.page.id, 0).html(noProjects);

            DialogController.$dialogElement.find(".dialog-button-panel button").hide();
        },

        drawError: function(message) {
            DialogController.dialog.getPanel(this.page.id, 0).html(JIRA.Templates.errorMsg({
                closable: false,
                msg: message
            }));
        },

        drawLoading: function() {
            DialogController.dialog.gotoPage(this.page.id);

            var addProjectForm = JIRA.Templates.ProjectTemplates.loading();

            DialogController.dialog.getPanel(this.page.id, 0).html(addProjectForm);

            DialogController.$dialogElement.find(".dialog-spinner").spin();
            DialogController.$dialogElement.find(".dialog-button-panel button").attr("disabled", "disabled");
        },

        _clearFormErrors: function() {
            DialogController.$dialogElement.find(".project-picker-missing-error").remove();
        },

        _getProjectPickerInput: function() {
            return DialogController.$dialogElement.find("#project-picker");
        },

        onSubmitForm: function(e) {
            this._clearFormErrors();
            var CreateSharedController = require('jira/project-templates/create-shared-controller');
            CreateSharedController.dialogSubmitted();
            return false;
        },

        _getExtraInfoMessage: function() {
            return DialogController.$dialogElement.find(".create-shared-info");
        },

        _createProjectPicker: function() {
            this._getExtraInfoMessage().hide();
            this.projectSelect = new ScrollableSingleSelect({
                element: this._getProjectPickerInput(),
                revertOnInvalid: true,
                pageSize: 50,
                pagingThreshold: 100,
                model: SuggestionCollectionModel
            });

            this.projectSelect.$field.focus();

            var self = this;
            this._getProjectPickerInput().on("selected", function(e, selected) {
                if(selected.value()) {
                    trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.shared.project.selected'});
                    self._getExtraInfoMessage().show();
                }
            });
        },

        getSelectedProject: function() {
            return this.projectSelect.getSelectedDescriptor() && this.projectSelect.getSelectedDescriptor().value();
        }
    });

    return new CreateSharedView({
        el: $(document),
        dialogView: DialogView
    });
});
AJS.namespace('JPT.CreateSharedView', null, require('jira/project-templates/create-shared-view'));
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/CreateSharedController.js' */
define('jira/project-templates/create-shared-controller-impl', [
    'jira/project-templates/add-project-controller',
    'jira/project-templates/create-shared-view',
    'jira/lib/class',
    'jquery',
    'underscore'
], function(
    AddProjectController,
    CreateSharedView,
    Class,
    $,
    _
) {
    "use strict";

    var contextPath = AJS.contextPath();

    return Class.extend({

        init: function (options) {
            this._window = options.window || window; // used for mocking 'window' in QUnit
            _.bindAll(this, "dialogSubmitted");
        },

        initCreateShared: function () {
            CreateSharedView.prepareDialog("Create with shared configuration");

            var self = this;
            this._getProjectSuggestions().done(function (resp) {
                if (self._hasSuggestions(resp)) {
                    CreateSharedView.draw({projectSuggestions: resp});
                } else {
                    CreateSharedView.drawEmptyInfo();
                }
            }).fail(function () {
                CreateSharedView.drawError("An error occurred while trying to contact JIRA");
            });

            CreateSharedView.drawLoading();
        },

        _hasSuggestions: function (projectSuggestions) {
            var hasSuggestions = false;
            $.each(projectSuggestions, function (i, group) {
                if (group && group.items && group.items.length > 0) {
                    hasSuggestions = true;
                }
            });
            return hasSuggestions;
        },

        _getProjectSuggestions: function () {
            return $.ajax({
                url: contextPath + "/rest/project-templates/1.0/createshared"
            });
        },

        dialogSubmitted: function () {
            var selectedProject = CreateSharedView.getSelectedProject();
            if (selectedProject) {
                AddProjectController.initCreateShared({existingProjectId: selectedProject});
            } else {
                CreateSharedView.showProjectMissingError();
            }
        }
    });
});
define('jira/project-templates/create-shared-controller', [
    'jira/project-templates/create-shared-controller-impl',
    'jquery'
], function(
    CreateSharedControllerImpl,
    $
){
    return new CreateSharedControllerImpl({el: $(document)});
});
AJS.namespace('JPT.CreateSharedController', null, require('jira/project-templates/create-shared-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/RemoteProjectsCreatedMessage.js' */
var $ = require('jquery');
$(function () {

    var format = AJS.format;
    var AddProjectController = require('jira/project-templates/add-project-controller');

    var confluenceProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "confluenceProject");
    var fishEyeProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "fisheyeProject");
    var crucibleProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "crucibleProject");
    var bambooProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "bambooProject");

    localStorage.removeItem(AddProjectController.localStoragePrefix + "confluenceProject");
    localStorage.removeItem(AddProjectController.localStoragePrefix + "fisheyeProject");
    localStorage.removeItem(AddProjectController.localStoragePrefix + "crucibleProject");
    localStorage.removeItem(AddProjectController.localStoragePrefix + "bambooProject");

    var message;
    function formatAnchor(link, label) {
        return JIRA.Templates.ProjectTemplates.formatAnchor({
            href: link,
            body: label,
            title: label
        });
    }
    function createProjectLinks(confluenceProjectLink, fecruProjectLink, crucibleProjectLink, bambooProjectLink) {
        var links = [];
        links.push("a JIRA project");
        if (confluenceProjectLink) {
            links.push(formatAnchor(confluenceProjectLink, "a Confluence space"));
        }
        if (fecruProjectLink) {
            links.push(formatAnchor(fecruProjectLink, "a FishEye repository"));
        }
        if (crucibleProjectLink) {
            links.push(formatAnchor(crucibleProjectLink, "a Crucible project"));
        }
        if (bambooProjectLink) {
            links.push(formatAnchor(bambooProjectLink, "a Bamboo project"));
        }
        return links;
    }
    function createMessage(confluenceProjectLink, fecruProjectLink, crucibleProjectLink, bambooProjectLink) {
        var title = "The following entities were created: {0} and {1}.";
        var projectLinks = createProjectLinks(confluenceProjectLink, fecruProjectLink, crucibleProjectLink, bambooProjectLink);
        var lastLink = projectLinks.pop();
        return (projectLinks.length > 0) ? format(title, projectLinks.join(", "), lastLink) : null;
    }
    function scrollTo(selector) {
        var settingsOffset = $(selector).offset();
        if (settingsOffset) {
            window.scrollTo(settingsOffset.left, settingsOffset.top);
        }
    }

    if (confluenceProjectLink || fishEyeProjectLink || crucibleProjectLink || bambooProjectLink) {
        message = createMessage(confluenceProjectLink, fishEyeProjectLink, crucibleProjectLink, bambooProjectLink);
        if (message) {
            JIRA.Messages.showSuccessMsg(message, {
                closeable:true
            });
        }
        scrollTo("#project-config-webpanel-summary-settings");
    }
});;
;
/* module-key = 'com.atlassian.plugins.jira-project-creation:project-creation-resources', location = '/js/lib/ajaxHooks/xdr.js' */
/**
 Copyright 2012 Julian Aubourg <j@ubourg.net>

 https://github.com/jaubourg/ajaxHooks

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
if ( window.XDomainRequest ) {
    jQuery.ajaxTransport(function( s ) {
        if ( s.crossDomain && s.async ) {
            if ( s.timeout ) {
                s.xdrTimeout = s.timeout;
                delete s.timeout;
            }
            var xdr;
            return {
                send: function( _, complete ) {
                    function callback( status, statusText, responses, responseHeaders ) {
                        xdr.onload = xdr.onerror = xdr.ontimeout = jQuery.noop;
                        xdr = undefined;
                        complete( status, statusText, responses, responseHeaders );
                    }
                    xdr = new XDomainRequest();
                    xdr.onload = function() {
                        callback( 200, "OK", { text: xdr.responseText }, "Content-Type: " + xdr.contentType );
                    };
                    xdr.onerror = function() {
                        callback( 404, "Not Found" );
                    };
                    xdr.onprogress = jQuery.noop;
                    xdr.ontimeout = function() {
                        callback( 0, "timeout" );
                    };
                    xdr.timeout = s.xdrTimeout || Number.MAX_VALUE;
                    xdr.open( s.type, s.url );
                    xdr.send( ( s.hasContent && s.data ) || null );
                },
                abort: function() {
                    if ( xdr ) {
                        xdr.onerror = jQuery.noop;
                        xdr.abort();
                    }
                }
            };
        }
    });
};
;
/* module-key = 'com.atlassian.plugins.jira-project-creation:project-creation-resources', location = '/js/project-creation.js' */
ATLAS_PROJECT_CREATE = {};

(function ($) {

    AJS.EventQueue = AJS.EventQueue || [];

    var JIRA_PROJECT_CAPABILITY_KEY = 'jira.project';

    //This will most likely be added to the SPI in future versions
    var CAPABILITY_WEIGHT = {
        "confluence.space" : 30,
        "bamboo.project" : 20,
        "ondemand.svn-repository" : 10
    };

    ATLAS_PROJECT_CREATE.getFilteredRootTypes = function getFilteredRootTypes(response) {
        var types = {};
        for (var key in response.types) {
            if (key !== JIRA_PROJECT_CAPABILITY_KEY) {
                types[key] = response.types[key];
            }
        }
        return types;
    };

    ATLAS_PROJECT_CREATE.loadRemoteRoots = function loadRemoteRoots(capabilities) {
        var deferred = jQuery.Deferred(),
            innerPromises = [],
            rootTypes = [];

        // map each capability to the promise of an ajax call, when they're all done innerpromises will contain an array of promises, one for each
        // inner ajax call made. Once this outer mega-promise is resolved, we can create a new mega-promise out of the contents of innerPromises.
        // Once that mega-promise is resolved we can resolve the outside visible promise (projectCreationPromise), passing in the gathered root types.
        mapToPromise(capabilities,function (capability) {
            var baseUrl = capability.capabilitiesUrl;
            return AJS.$.ajax(baseUrl + '/aggregate-root', {
                success: function (response) {
                    var types = ATLAS_PROJECT_CREATE.getFilteredRootTypes(response);
                    innerPromises = innerPromises.concat(_.map(types, function (type, key) {
                        return AJS.$.ajax(type.href, {
                            xhrFields: {
                                withCredentials: true
                            },
                            success: function (rootType) {
                                rootTypes.push(ATLAS_PROJECT_CREATE.constructFullRootType(rootType, type.label, key, baseUrl, capability.id));
                            },
                            error: function (xhr, status, errorThrown) {
                                AJS.log('Got ' + errorThrown + ' from aggregate root type ' + type.href);
                            }
                        }).promise();
                    }));
                }, error: function (xhr, status, errorThrown) {
                    // TODO ROTP-1146 ROTP-1147: handle 401, 403 better
                    AJS.log('Got ' + errorThrown + ' from aggregate roots capapbility for ' + baseUrl);
                }
            }).promise();
        }).done(function () {
                promiseFromPromiseList(innerPromises).done(function () {
                    deferred.resolve(rootTypes);
                });
            });
        return deferred.promise();
    };

    ATLAS_PROJECT_CREATE.constructFullRootType = function constructFullRootType(rootType, label, capabilityKey, baseUrl, instanceId) {
        return {
            keys: rootType.keys,
            url: rootType.links.self,
            label: label,
            capabilityKey: capabilityKey,
            baseUrl: baseUrl,
            instanceId: instanceId
        };
    };

    ATLAS_PROJECT_CREATE.createLink = function createLink(linkDetails, complete) {
        console.log("creating link from " + linkDetails.entityType + " to " + linkDetails.remoteEntityType);
        var linkRequest = JSON.stringify({
            "local": linkDetails.baseUrl + "/aggregate-root/" + linkDetails.entityType + "/" + linkDetails.entityKey,
            "target": linkDetails.remoteInstanceBaseUrl + "/aggregate-root/" + linkDetails.remoteEntityType + "/" + linkDetails.remoteEntityKey
        });
        AJS.$.ajax(linkDetails.baseUrl + "/aggregate-root-link", {
            type: "POST",
            contentType: "application/json",
            data: linkRequest,
            timeout: 8000,
            complete: complete
        });
    };


    ATLAS_PROJECT_CREATE.linkAllTheThings = function linkAllTheThings(dialog, createdThings, projectKey, projectCreationPage, acknowledgeButton) {

        var linksToCreate = [];
        $.each(createdThings, function createLinks(idx, entity) {
            linksToCreate.push({
                baseUrl: entity.type.baseUrl,
                entityType: entity.type.capabilityKey,
                entityKey: entity.data.key,
                remoteInstanceBaseUrl: getAppBaseUrl() + "/rest/capabilities",
                remoteEntityType: JIRA_PROJECT_CAPABILITY_KEY,
                remoteEntityKey: projectKey
            });

            linksToCreate.push({
                baseUrl: getAppBaseUrl() + "/rest/capabilities",
                entityType: JIRA_PROJECT_CAPABILITY_KEY,
                entityKey: projectKey,
                remoteInstanceBaseUrl: entity.type.baseUrl,
                remoteEntityType: entity.type.capabilityKey,
                remoteEntityKey: entity.data.key
            });

            AJS.$.each(createdThings, function createLinkBetweenRemoteEntities(targetIdx, targetEntity) {
                //first check we are not trying to link something to itself or something else in the same instance
                if (targetEntity !== entity) {
                    linksToCreate.push({
                        baseUrl: entity.type.baseUrl,
                        entityType: entity.type.capabilityKey,
                        entityKey: entity.data.key,
                        remoteInstanceBaseUrl: targetEntity.type.baseUrl,
                        remoteEntityType: targetEntity.type.capabilityKey,
                        remoteEntityKey: targetEntity.data.key
                    });
                }
            });
        });

        //TODO ROTP-992 : Doesn't need to be serialized once applinks fixes up race condition
        var numErrors = 0;

        function createNext(xhr, status) {
            if (status !== "success") {
                numErrors++;
                // render the error message
                var errorMessage = xhr.statusText;
                try {
                    var data = JSON.parse(xhr.responseText);
                    if (data && data.message) {
                        errorMessage = data.message;
                    }
                } catch (err) {

                }
                AJS.messages.error(".li-linking-status", {
                    title: "Could not create links between created projects",
                    body: errorMessage
                });
                dialog.updateHeight();
            }
            if (linksToCreate.length > 0) {
                ATLAS_PROJECT_CREATE.createLink(linksToCreate.pop(), createNext);
            } else {
                if (numErrors > 0) {
                    projectCreationPage.find(".linking-status").html('<span class="aui-icon aui-icon-small aui-iconfont-error">' + "Error" + '</span>');
                } else {
                    projectCreationPage.find(".linking-status").html('<span class="aui-icon aui-icon-small aui-iconfont-success">' + "Success" + '</span>');
                }
                acknowledgeButton.prop("disabled", false);
                acknowledgeButton.attr('aria-disabled', 'false');
            }
        }

        createNext(null, "success");
    };

    var remoteRootsPromise;

    function bindRemoteRootsPromise(promise, getDialog, onCheckboxChange) {
        var dialog = getDialog();
        $.when(promise).then(
            // success handler
            function (types) {
                dialog.getCurPanel().body.find('.field-group.loading').remove();

                types.sort(sortCapabilities);
                if (types.length !== 0) {
                    var projectCreateForm = dialog.getCurPanel().body.find('form');
                    projectCreateForm.append(project.creation.remoteRootsCheckboxes({rootTypes: types}));
                    if (onCheckboxChange) {
                        projectCreateForm.find('input[type="checkbox"]').filter('.remote-root').change(onCheckboxChange);
                    }

                    dialog.updateHeight();
                }

                enableSubmitBtn(dialog, true);
            },
            // fail handler
            function () {
                dialog.getCurPanel().body.find('.field-group.loading').remove();
                enableSubmitBtn(dialog, true);
                dialog.updateHeight();
                // the provided promise only ever resolves. This shouldn't happen, but if something explodes it should
                // be enough to just revert back to default JIRA behaviour.
            }
        );
    }

    var panel;

    function setupProjectCreationIntegration(getDialog, onCheckboxChange) {
        var dialog = getDialog();
        //Store a ref to the panel for use in some promises
        panel = dialog.getCurPanel();
        // Attach some info and a spinner below Project Create name & key entry
        panel.body.find('form').append(project.creation.remoteRootsLoading({}));

        enableSubmitBtn(dialog, false);
        dialog.updateHeight();

        //Make sure the height is good again when the user hits back
        panel.page.element.find(".add-project-back-button").click(function() {
            dialog.updateHeight();
        });


        initRemoteRoots(bindRemoteRootsPromise, getDialog, onCheckboxChange);
    }

    function getSelectedTypes(types) {
        var selectedCheckboxes = _.filter(panel.body.find("input.remote-root.checkbox"), function (checkbox) {
            return checkbox.checked === true;
        });
        var selectedTypeIds = _.map(selectedCheckboxes,
            function (input) {
                return input.id;
            });
        return _.filter(types, function (type) {
            return _.contains(selectedTypeIds, 'capability_' + type.capabilityKey);
        });
    }

    var userMetaTag = AJS.$('meta[name="ajs-remote-user"]');
    // if we neither got a user tag, or it had no content then bail out.
    if (!userMetaTag || !userMetaTag[0] || !userMetaTag[0].content) {
        console.log("Project create didn't get a user META tag, or it had no content.  Bailing out");
        return;
    }

    // if the dark feature is disabled, return here.
    if (!AJS.DarkFeatures.isEnabled("rotp.project.create")) {
        return;
    }

    var postProjectCreationCallback = function postProjectCreationCallback(dialog, redirectFn, projectId, projectKey, projectName) {
        var callRedirectFn = function callRedirectFn(redirectFn, acknowledgeButton) {
            acknowledgeButton.prop("disabled", true);
            acknowledgeButton.attr('aria-disabled', 'true');
            acknowledgeButton.before('<span class="aui-icon aui-icon-wait project-creation-acknowledge-spinner">' + "Loading, please wait" + '</span>');
            redirectFn();
        };

        $.when(remoteRootsPromise).then(
            function (types) {
                var selectedTypes = getSelectedTypes(types);
                sendAnalytics(selectedTypes);

                if (selectedTypes.length === 0) {
                    //Make sure we don't show empty next page which is the default of project templates
                    dialog.prevPage();
                    redirectFn();
                    return;
                }

                createProjectCreationResultPanel(dialog, callRedirectFn, redirectFn);

                var templateData = [];
                var createdThings = [];
                mapToPromise(selectedTypes, function (type) {
                    var statusId = "creation_status_" + type.capabilityKey.replace(".", "_") + "_" + type.instanceId;
                    templateData.push({
                        statusId: statusId,
                        label: type.label
                    });

                    return AJS.$.ajax(type.url + "/" + projectKey, {
                        type: "PUT",
                        data: JSON.stringify({
                            label: projectName
                        }),
                        xhrFields: {
                            withCredentials: true
                        },
                        success: function (data) {
                            createdThings = createdThings.concat(processCreatedRoots(data, type));
                            renderCreatedRoots(data, statusId);
                        },
                        error: function (xhr, textStatus, errorThrown) {
                            renderErrorDuringRootCreation(statusId, type, xhr, errorThrown);
                        },
                        contentType: "application/json",
                        dataType: "json"
                    }).promise();
                }).always(function () {
                    renderErrorHeaderInCaseOfErrors(dialog);
                    console.log("about to begin linking created objects");
                    ATLAS_PROJECT_CREATE.linkAllTheThings(dialog,
                                                            createdThings,
                                                            projectKey,
                                                            AJS.$(".post-project-created-page-content"),
                                                            AJS.$(".project-create-acknowledge-button"));
                });

                AJS.$(".post-project-created-page-content").append(project.creation.remoteRootsSuccess({rootTypes: templateData}));
            }
        );
    };


    var checkIfKeyExists = function checkIfKeyExists(projectKey) {
        var duplicateFound;
        $.when(remoteRootsPromise).then(
            function (types) {
                var selectedTypes = getSelectedTypes(types);
                _.each(selectedTypes, function (type) {
                    if (type.keys) {
                        for (var key in type.keys) {
                            if (type.keys.hasOwnProperty(key)) {
                                if (projectKey.toUpperCase() === key.toUpperCase()) {
                                    duplicateFound = type;
                                }
                            }
                        }
                    }
                });
            });
        var response = {errors: {}};
        if (duplicateFound) {
            response.errors.projectKey = AJS.format("{0} with that key already exists in the remote instance", duplicateFound.label);
        }
        return response;
    };


    function getOrigin() {
        return window.location.origin ? window.location.origin : (window.location.protocol + '//' + window.location.host);
    }

    function getAppBaseUrl() {
        var baseUrl = getOrigin();
        return baseUrl + AJS.contextPath();
    }

    /**
     * Parse and return some components of a URL.
     * @param {string} url A URL, e.g. "http://google.com:80/a/b/c"
     * @returns {{host: string, protocol: string, port: string}}
     */
    function parseUrl(url) {
        var a = document.createElement('a');
        a.href = url;
        return {
            host: a.hostname,
            port: a.port,
            protocol: a.protocol.replace(':', '')
        };
    }

    /**
     * Determine if making a request from one URL to another would represent a security downgrade, and
     * as such be blocked by the browser.
     *
     * @param {string} origin The URL from which a request to *destination* is to be made.
     * @param {string} destination The destination URL.
     * @returns {boolean} true if origin uses https: and destination uses http:
     */
    function isSecurityDowngrade(origin, destination) {
        var aParts = parseUrl(origin);
        var bParts = parseUrl(destination);
        return aParts.protocol === "https" && bParts.protocol === "http";
    }

    function initRemoteRoots(fn, getDialog, onCheckboxChange) {
        AJS.$.ajax(getAppBaseUrl() + '/rest/capabilities/awareness', {
            type: "GET",

            /**
             * @param {{applications: object, links: {selfInstanceId: string} }} data
             */
            success: function parseAwarenessResponse(data) {
                // We need to be careful with what requests we make. Making a request from a HTTPS page to a HTTP
                // page will be blocked by the browser and will only fail after the timeout period has elapsed.
                var willTimeout = _.partial(isSecurityDowngrade, getOrigin());
                var capabilities = _
                    .chain(data.applications)
                    .map(function (details, url) {
                        return _.extend(details, {capabilitiesUrl: url});
                    })
                    .filter(function (details) {
                        return willTimeout(details.capabilitiesUrl) === false;
                    })
                    .value();

                //push an object in to gather any local capabilities
                capabilities.push({
                    id: data.links.selfInstanceId,
                    capabilitiesUrl: data.links.collection
                });

                remoteRootsPromise = ATLAS_PROJECT_CREATE.loadRemoteRoots(capabilities);
                selfInstanceId = data.links.selfInstanceId;
                if (typeof fn === 'function') {
                    fn(remoteRootsPromise, getDialog, onCheckboxChange);
                }
            },
            error: function (xhr, status, errorThrown) {
                // log & revert to vanilla JIRA behaviour.
                console.log("Project create error - error gathering roots from awareness capability");
                if (getDialog) {
                    $(getDialog().getCurPanel().page.element).find(".pt-submit-button").attr('aria-disabled', 'false');
                }
            }
        });
    }


    var selfInstanceId;
    var odFecruAwareness = null;

    // given a list<X> and a function fn : X -> promise returns a promise composed
    // of all the promises returned by applying fn to members of list
    function mapToPromise(list, fn) {
        var promises = _.map(list, fn);
        return promiseFromPromiseList(promises);
    }

    // given a list of promises, construct a new promise which fires done when all proivded promises have either been resolved or rejected.
    // NOTE: can not just be return $.when.apply(promises).promise() because that would reject when the first internal promise is rejected,
    // whereas we want the promise to fire after all are completed.
    // Again, NOTE: resolution of the returned promise will be empty. This should only be used when you want flow control,
    // data access should be by other means (or wrapped around one of these).
    function promiseFromPromiseList(promises) {
        var deferred = $.Deferred();
        var resolutionCount = 0;
        if (promises.length === 0) {
            deferred.resolve();
        } else {
            _.each(promises, function (promise) {
                promise.always(function () {
                    resolutionCount++;
                    if (resolutionCount === promises.length) {
                        deferred.resolve();
                    }
                });
            });
        }
        return deferred.promise();
    }

    function createProjectCreationResultPanel(dialog, callRedirectFn, redirectFn) {
        dialog.addPanel("title", "", "post-project-created-page-content");
        dialog.addHeader("Creating and linking companions for your JIRA project");
        dialog.addButton("All done!", function () {
            callRedirectFn(redirectFn, AJS.$(this));
        }, "project-create-acknowledge-button");

        AJS.$(".project-create-acknowledge-button").removeClass("button-panel-button")
            .addClass("aui-button aui-button-primary")
            .attr('aria-disabled', 'true')
            .prop('disabled', true);
    }

    function processCreatedRoots(data, type) {
        var createdThings = [];
        if (type.capabilityKey === "ondemand.svn-repository") {
            // TODO: Remove this special case when FeCru is removed from OnDemand
            // this is a hack to handle the fact that SVN repositories
            // are being created in JIRA.
            console.log("got back created SVN repository");
            createdThings.push({
                type: {
                    capabilityKey: "fecru.repository",
                    instanceId: odFecruAwareness.id,
                    baseUrl: odFecruAwareness.capabilitiesUrl
                },
                data: {
                    key: data.key
                }
            });
            createdThings.push({
                type: {
                    capabilityKey: "fecru.project",
                    instanceId: odFecruAwareness.id,
                    baseUrl: odFecruAwareness.capabilitiesUrl
                },
                data: {
                    key: "CR-" + data.key
                }
            });
        } else {
            console.log("got back created thing " + type.capabilityKey);
            var createdThing = {
                type: type,
                data: data
            };
            createdThings.push(createdThing);
        }

        return createdThings;
    }

    function renderCreatedRoots(data, statusId) {
        var statusBlock = AJS.$("." + statusId);
        statusBlock.empty(); //remove spinner
        statusBlock.append('<span class="aui-icon aui-icon-small aui-iconfont-success">' + "Success" + '</span>');
        if (data.links.resource) {
            var link = AJS.$("<a target='_blank'></a>");
            link.text(data.label);
            link.attr("href",data.links.resource);
            link.attr("title",data.label);
            statusBlock.closest('li').append(link);
        }
    }

    function renderErrorDuringRootCreation(statusId, type, xhr, errorThrown) {
        var statusBlock = AJS.$("." + statusId);
        statusBlock.empty(); //remove spinner
        statusBlock.append('<span class="aui-icon aui-icon-small aui-iconfont-error">' + "Error" + '</span>');
        var errorMessage = errorThrown;
        if (xhr && xhr.responseText) {
            try {
                var data = JSON.parse(xhr.responseText);
                if (data && data.message) {
                    errorMessage = data.message;
                }
            } catch (err) {
                // swallow syntax error if response is not valid JSON and display the response text as error
                errorMessage = xhr.responseText;
            }
        }

        AJS.messages.error(".li-" + statusId, {
            title: AJS.format("Could not create {0}", type.label),
            body: errorMessage
        });
    }

    function renderErrorHeaderInCaseOfErrors(dialog) {
        // if we have any errors, add a helpful message
        var currentPanel = dialog.getCurrentPanel();
        if (currentPanel.body.find('.aui-message.error').size() !== 0) {
            AJS.messages.warning('.project-creation-success', {
                title: "We were unable to create everything you requested",
                body: '<p>' + "However, you can create them yourself and manually set up links." + '</p>'
            });

            dialog.updateHeight();
        }
    }

    function sendAnalytics(selectedTypes) {
        var capabilityKeys = _.map(selectedTypes, function (type) { return type.capabilityKey;});
        var analyticsValue = (capabilityKeys.length == 0) ? "none" : capabilityKeys.sort().join('_');

        AJS.EventQueue.push({name: 'project.create.aggregateroots.selected', properties: {capabilitykeys: analyticsValue}});
    }

    function enableSubmitBtn(dialog, enabled) {
        $(dialog.getCurPanel().page.element).find(".pt-submit-button").attr('aria-disabled', !enabled);
    }

    function sortCapabilities(capabilityA, capabilityB) {
        return getCapabilityWeight(capabilityB.capabilityKey) - getCapabilityWeight(capabilityA.capabilityKey);
    }

    function getCapabilityWeight(capabilityKey) {
        return _.has(CAPABILITY_WEIGHT, capabilityKey) ? CAPABILITY_WEIGHT[capabilityKey] : 0;
    }



    JPT.AddProjectController.registerProjectKeyValidationCallback(checkIfKeyExists);

    var getJptDialog = function getJptDialog() {
        return JPT.DialogView.dialog || JPT.DialogView._dialog;
    };
    var onJptCheckboxChange = function onJptCheckboxChange() {
        if (JPT.AddProjectView.getKey().length >= 2) {
            JPT.AddProjectController._performKeyValidationChecks(JPT.AddProjectView.getKey());
        }
    };

    JPT.AddProjectView.addPostDrawCallback(function () {
        setupProjectCreationIntegration(getJptDialog, onJptCheckboxChange);
    });

    JPT.AddProjectController.registerPostProjectCreationCallback(function (dialog, returnUrl, projectId, projectKey, projectName) {
        var redirectFn = function() {
            window.location = AJS.contextPath() + returnUrl;
        };
        postProjectCreationCallback(dialog, redirectFn, projectId, projectKey, projectName);
    });

    // Embed project create in Greenhopper project create flow
    // (But only in flow creating a JIRA project at the same time)
    var registerGhCallbacks = function registerGhCallbacks() {
        var GH_PROJECT_CREATION_STEP = "projectCreation";
        GH.StartWizardView.registerWizardStepPreRenderCallback(function ghProjectCreateSetup(stepName) {
            if (stepName == GH_PROJECT_CREATION_STEP) {
                initRemoteRoots();

                GH.StartWizardView.registerWizardStepOnCreateCallbacks(function ghProjectCreageCallback(dialog, executeNextCallback, model) {
                    console.log("creating external entities");
                    dialog.addPage("post-project-created-page");
                    postProjectCreationCallback(dialog, executeNextCallback, null, model.project.key, model.project.name);
                });
            }
        });
        GH.StartWizardView.registerWizardStepPostRenderCallback(function renderGhProjectCheckboxes(stepName, dialog) {
            if (stepName == GH_PROJECT_CREATION_STEP) {
                setupProjectCreationIntegration(function getGhDialog() {
                    return dialog;
                });
                dialog.updateHeight();
            }
        });
        GH.StartWizardView.registerWizardStepOnValidateCallback(function validateProjectKey(stepName, dialog) {
            if (stepName == GH_PROJECT_CREATION_STEP) {
                var $keyInput = dialog.getCurPanel().body.find("#ghx-wizard-project-projectkey");
                var keyExistsResponse = checkIfKeyExists($keyInput.val());
                if (keyExistsResponse.errors.projectKey) {
                    var $errorElement = AJS.$("<div class='error project-creation-error'></div>");
                    var parent = $keyInput.parent();
                    parent.find(".project-creation-error").remove();
                    parent.append($errorElement);
                    $errorElement.text(keyExistsResponse.errors.projectKey);
                    $errorElement.show();
                    return false;
                }
            }
            return true;
        });
    };

    $(function() {

        // Embed project create in JIRA project templates dialog
        // on clicking the project create link, we want to start gathering our capabilities
        AJS.$('.add-project-trigger').live('click', initRemoteRoots);

        // check if Greenhopper is available and that it is a version which has support for the required
        // callbacks.  If so, register greenhopper callbacks
        if (typeof GH !== 'undefined') {
            if (GH.StartWizardView && GH.StartWizardView.registerWizardStepPreRenderCallback) {
                // GH has support for the required callbacks....
                registerGhCallbacks();
            }
        }
    });

    // Embed project create in JIRA project templates dialog
    // on clicking the project create link, we want to start gathering our capabilities
    $(function () {
        AJS.$('.add-project-trigger').live('click', initRemoteRoots);
    });


})(jQuery);
;
;
/* module-key = 'com.atlassian.plugins.jira-project-creation:project-creation-resources', location = '/templates/project-creation.soy' */
// This file was automatically generated from project-creation.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace project.creation.
 */

if (typeof project == 'undefined') { var project = {}; }
if (typeof project.creation == 'undefined') { project.creation = {}; }


project.creation.remoteRootsLoading = function(opt_data, opt_ignored) {
  return '<div class="field-group loading"><span class="aui-icon aui-icon-wait"/>' + soy.$$escapeHtml("Retrieving additional project types you might want to create") + '</div>';
};
if (goog.DEBUG) {
  project.creation.remoteRootsLoading.soyTemplateName = 'project.creation.remoteRootsLoading';
}


project.creation.remoteRootsCheckboxes = function(opt_data, opt_ignored) {
  var output = '<fieldset class="group remote-root-checkboxes"><h4>' + soy.$$escapeHtml("Create a linked:") + '</h4><div class=\'field-group\'>';
  var rootTypeList10 = opt_data.rootTypes;
  var rootTypeListLen10 = rootTypeList10.length;
  for (var rootTypeIndex10 = 0; rootTypeIndex10 < rootTypeListLen10; rootTypeIndex10++) {
    var rootTypeData10 = rootTypeList10[rootTypeIndex10];
    output += '<div class="checkbox"><input class="checkbox remote-root" type="checkbox" id="capability_' + soy.$$escapeHtml(rootTypeData10.capabilityKey) + '" checked="true" data-url="' + soy.$$escapeHtml(rootTypeData10.url) + '"></input><label for="capability_' + soy.$$escapeHtml(rootTypeData10.capabilityKey) + '">' + soy.$$escapeHtml(rootTypeData10.label) + '</label></div>';
  }
  output += '</div></fieldset>';
  return output;
};
if (goog.DEBUG) {
  project.creation.remoteRootsCheckboxes.soyTemplateName = 'project.creation.remoteRootsCheckboxes';
}


project.creation.remoteRootsSuccess = function(opt_data, opt_ignored) {
  var output = '<div class="project-creation-success"><ul>';
  var rootTypeList24 = opt_data.rootTypes;
  var rootTypeListLen24 = rootTypeList24.length;
  for (var rootTypeIndex24 = 0; rootTypeIndex24 < rootTypeListLen24; rootTypeIndex24++) {
    var rootTypeData24 = rootTypeList24[rootTypeIndex24];
    output += '<li class="li-' + soy.$$escapeHtml(rootTypeData24.statusId) + '"><div class="' + soy.$$escapeHtml(rootTypeData24.statusId) + ' created-entity-status"><span class="aui-icon aui-icon-wait">' + soy.$$escapeHtml("Loading, please wait") + '</span></div><div class="created-entity-status">' + soy.$$escapeHtml(rootTypeData24.label) + '</div></li>';
  }
  output += '<li class="li-linking-status"><div class="linking-status created-entity-status"><span class="aui-icon aui-icon-wait">' + soy.$$escapeHtml("Loading, please wait") + '</span></div><div class="created-entity-status">' + soy.$$escapeHtml("Creating links") + '</div></li></ul></div>';
  return output;
};
if (goog.DEBUG) {
  project.creation.remoteRootsSuccess.soyTemplateName = 'project.creation.remoteRootsSuccess';
}
;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/store-1.3.1.js' */
/* Copyright (c) 2010-2012 Marcus Westin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function(){
	var store = {},
		win = window,
		doc = win.document,
		localStorageName = 'localStorage',
		globalStorageName = 'globalStorage',
		namespace = '__storejs__',
		storage;

	store.disabled = false;
	store.set = function(key, value) {};
	store.get = function(key) {};
	store.remove = function(key) {};
	store.clear = function() {};
	store.transact = function(key, transactionFn) {
		var val = store.get(key);
		if (typeof val == 'undefined') { val = {} }
		transactionFn(val);
		store.set(key, val);
	};

	store.serialize = function(value) {
		return JSON.stringify(value);
	};
	store.deserialize = function(value) {
		if (typeof value != 'string') { return undefined }
		return JSON.parse(value);
	};

	// Functions to encapsulate questionable FireFox 3.6.13 behavior 
	// when about.config::dom.storage.enabled === false
	// See https://github.com/marcuswestin/store.js/issues#issue/13
	function isLocalStorageNameSupported() {
		try { return (localStorageName in win && win[localStorageName]); }
		catch(err) { return false; }
	}
	
	function isGlobalStorageNameSupported() {
		try { return (globalStorageName in win && win[globalStorageName] && win[globalStorageName][win.location.hostname]); }
		catch(err) { return false; }
	}	

	if (isLocalStorageNameSupported()) {
		storage = win[localStorageName];
		store.set = function(key, val) {
			if (val === undefined) { return store.remove(key); }
			storage.setItem(key, store.serialize(val));
		};
		store.get = function(key) { return store.deserialize(storage.getItem(key)); };
		store.remove = function(key) { storage.removeItem(key); };
		store.clear = function() { storage.clear(); };

	} else if (isGlobalStorageNameSupported()) {
		storage = win[globalStorageName][win.location.hostname];
		store.set = function(key, val) {
			if (val === undefined) { return store.remove(key); }
			storage[key] = store.serialize(val);
		};
		store.get = function(key) { return store.deserialize(storage[key] && storage[key].value); };
		store.remove = function(key) { delete storage[key]; };
		store.clear = function() { for (var key in storage ) { delete storage[key]; } };

	} else if (doc.documentElement.addBehavior) {
		var storageOwner,
			storageContainer;
		// Since #userData storage applies only to specific paths, we need to
		// somehow link our data to a specific path.  We choose /favicon.ico
		// as a pretty safe option, since all browsers already make a request to
		// this URL anyway and being a 404 will not hurt us here.  We wrap an
		// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
		// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
		// since the iframe access rules appear to allow direct access and
		// manipulation of the document element, even for a 404 page.  This
		// document can be used instead of the current document (which would
		// have been limited to the current path) to perform #userData storage.
		try {
			storageContainer = new ActiveXObject('htmlfile');
			storageContainer.open();
			storageContainer.write('<s' + 'cript>document.w=window</s' + 'cript><iframe src="/favicon.ico"></frame>');
			storageContainer.close();
			storageOwner = storageContainer.w.frames[0].document;
			storage = storageOwner.createElement('div');
		} catch(e) {
			// somehow ActiveXObject instantiation failed (perhaps some special
			// security settings or otherwse), fall back to per-path storage
			storage = doc.createElement('div');
			storageOwner = doc.body;
		}
		function withIEStorage(storeFunction) {
			return function() {
				var args = Array.prototype.slice.call(arguments, 0);
				args.unshift(storage);
				// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
				// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
				storageOwner.appendChild(storage);
				storage.addBehavior('#default#userData');
				storage.load(localStorageName);
				var result = storeFunction.apply(store, args);
				storageOwner.removeChild(storage);
				return result;
			}
		}
		store.set = withIEStorage(function(storage, key, val) {
			if (val === undefined) { return store.remove(key) }
			storage.setAttribute(key, store.serialize(val));
			storage.save(localStorageName);
		});
		store.get = withIEStorage(function(storage, key) {
			return store.deserialize(storage.getAttribute(key));
		});
		store.remove = withIEStorage(function(storage, key) {
			storage.removeAttribute(key);
			storage.save(localStorageName);
		});
		store.clear = withIEStorage(function(storage) {
			var attributes = storage.XMLDocument.documentElement.attributes;
			storage.load(localStorageName);
			for (var i=0, attr; attr = attributes[i]; i++) {
				storage.removeAttribute(attr.name);
			}
			storage.save(localStorageName);
		});
	}
	
	try {
		store.set(namespace, namespace);
		if (store.get(namespace) != namespace) { store.disabled = true; }
		store.remove(namespace);
	} catch(e) {
		store.disabled = true;
	}
	
	if (typeof module != 'undefined') { module.exports = store; }
	else if (typeof define === 'function' && define.amd) { define(store); }
	else { this.store = store; }
})();;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/page-visibility.js' */
define('atlassian/analytics/page-visibility', function () {
    var hasBrowserSupport = (document.hidden !== undefined);

    /**
     * A partial wrapper for the Page Visibility API
     * @exports atlassian/analytics/page-visibility
     */
    var wrapper = {

        /** Is the API supported by the browser? */
        supported: hasBrowserSupport,

        /**
         * A proxy for `document.hidden`.
         * Defaults to false if the API is not supported by the browser
         * @returns {boolean}
         */
        isHidden: function () {
            return hasBrowserSupport ? document.hidden : false;
        }
    };

    return wrapper;
});;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/user-activity-xhr-header.js' */
/**
 * Provides overrides that add a custom HTTP header to XHR and fetch requests
 * to make MAU User Activity event tracking easier by identifying requests
 * from inactive tabs/windows
 *
 * @module atlassian/analytics/user-activity-xhr-header
 *
 * @see module:atlassian/analytics/page-visibility
 */
define('atlassian/analytics/user-activity-xhr-header', ['atlassian/analytics/page-visibility'], function (pageVisibility) {

    var ACTIVITY_IGNORE_HEADER = 'x-atlassian-mau-ignore';

    // Store native xhr and fetch methods
    var oldSend = XMLHttpRequest.prototype.send;
    var oldFetch = window.fetch;

    var _installed = false;

    return /** @alias module:atlassian/analytics/user-activity-xhr-header */ {
        /**
         * Install global overrides to XHR send and fetch methods to add a
         * custom HTTP header that makes MAU User Activity event tracking
         * easier by identifying requests from inactive tabs/windows
         */
        install: function () {
            // Only install if the override is not already installed
            // and if the browser supports the Page Visibility API
            if (!_installed && pageVisibility.supported) {

                // Override the native send()
                XMLHttpRequest.prototype.send = function () {
                    if (pageVisibility.isHidden()) {
                        this.setRequestHeader(ACTIVITY_IGNORE_HEADER, pageVisibility.isHidden());
                    }
                    oldSend.apply(this, arguments);
                };

                // Override the native fetch() if it exists
                if (oldFetch) {
                    window.fetch = function (input, init) {
                        var augmentedInit = init || {};
                        var headers = augmentedInit.headers;

                        if (pageVisibility.isHidden()) {
                            augmentedInit.headers = (headers) ? new Headers(headers) : new Headers();
                            augmentedInit.headers.append(ACTIVITY_IGNORE_HEADER, pageVisibility.isHidden());
                        }

                        return oldFetch.call(this, input, augmentedInit);
                    };
                }

                _installed = true;
            }
        },

        /**
         * Restore native XHR send and fetch methods
         */
        uninstall: function () {
            if (_installed) {
                XMLHttpRequest.prototype.send = oldSend;
                if (oldFetch) {
                    window.fetch = oldFetch;
                }
            }
            _installed = false;
        }
    };

});

require('atlassian/analytics/user-activity-xhr-header').install();;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/atlassian-analytics.js' */
(function ($) {
    // Make sure we are getting the jQuery.ajax method, even if it has been overridden elsewhere.
    // This will only work if this code is executed before any code which overrides the ajax method.
    var $ajax = AJS.$.ajax;
    var baseStorageKey = 'atlassian-analytics';
    var contextPath =
        typeof AJS.contextPath == "function" ? AJS.contextPath() :
        typeof AJS.Confluence != "undefined" ? AJS.Confluence.getContextPath() :
        window.contextPath != null ? window.contextPath : "";

    var publish = null;
    var storageKey = null;
    var lockKey = null;

    // A unique identifier for this browser tab
    // Source: http://stackoverflow.com/a/2117523
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
    });

    var determineStorageKey = function(){
        // We need to give each product it's own key for events because in ondemand multiple product live
        // at the same url.
        var product = 'unknown';
        if (document.body.id == 'jira'){
            product = 'jira';
        }
        else if (document.body.id == 'com-atlassian-confluence'){
            product = 'confluence';
        }
        storageKey = baseStorageKey + '.' + product;
        lockKey = storageKey + '.lock';
    };

    var getLock = function() {
        if (store.get(lockKey)) {
            return false;
        }

        store.set(lockKey, uuid);

        // Reduce chance of race condition - read back lock to make sure we still have it
        return (store.get(lockKey) === uuid);
    };

    var releaseLock = function() {
        store.set(lockKey, null);
    };

    /**
     * Persists the events that have been generated until such time that they can be sent.
     */
    var saveForLater = function() {
        var events = [],
            event,
            e, i, ii;
        if (AJS.EventQueue.length == 0)
            return;
        // Prime our events array with anything that's already saved.
        events = store.get(storageKey) || events;
        // Suck the events out of the event queue and in to our events array.
        for (i = 0, ii = AJS.EventQueue.length; i < ii; ++i) {
            e = AJS.EventQueue[i];
            if (e.name) {
                // the queue could contain anything - shear unusable properties
                event = { name: e.name, properties: e.properties, time: e.time || 0};
                events.push(event);
            }
        }
        // Empty the event queue
        AJS.EventQueue.length = 0;
        // Save our events for later
        store.set(storageKey, events);
    };

    // Variable to track the number of retries to publish
    var bulkPublishRetryCount = 0;

    /**
     * Gets the amount of time that should be waited until the next publish attempt.
     * @param retryCount How many requests failed since the last successful publish.
     * @returns {number} how many ms that should be waited.
     */
    var getBulkPublishBackoff = function (retryCount) {
        return Math.min(5000 * Math.pow(2, retryCount), 5*60*1000);
    };

    /**
     * Publishes every event that's ready for publishing.
     */
    var bulkPublish = function() {
        var events;

        function reschedule() {
            setTimeout(bulkPublish, getBulkPublishBackoff(bulkPublishRetryCount = 0));
        }

        function rescheduleFailed() {
            setTimeout(bulkPublish, getBulkPublishBackoff(++bulkPublishRetryCount));
        }

        // Avoid multiple browser tabs hitting this all at once
        if (!getLock()) {
            return reschedule();
        }

        // Make sure every event we might have is stored.
        saveForLater();
        // Pull the stored events out and get 'em ready for transmission.
        events = store.get(storageKey);

        if (!events || !events.length) {
            releaseLock();
            return reschedule();
        }

        // Wipe the stored events.
        store.remove(storageKey);

        releaseLock();

        // Validate events and remove any dodgy ones
        if (!validateEvents(events)) {
            return reschedule();
        }

        // try to present a rough timing of events that the server can interpret relative to it's own time.
        var currentTime = new Date().getTime();
        for (var i = 0; i < events.length; i++){
            if (events[i].time > 0){
                events[i].timeDelta = events[i].time - currentTime;
            }
            else{
                // just fake it. This corresponds to a millisecond for each place behind last in the array.
                // This should be rare. Basically, events added to EventQueue before this script was loaded.
                events[i].timeDelta = i - events.length;
            }
            delete events[i].time;
        }

        // AJS.safe.post appears to corrupt a JSON data object, so we send it as a context param instead.
        // Failing to JSON encode the data results in jQuery not attempting to send, and silently swallowing our attempt
        publish = $ajax({
            type: "POST",
            url: contextPath + "/rest/analytics/1.0/publish/bulk",
            data: JSON.stringify(events),
            contentType: "application/json",
            dataType: "json"
        });
        // In case the transmission fails, let's keep the events we just attempted to send.
        publish.fail(function() {
            // This actually drops events, but the alternative is to use something like:
            //   $.merge(AJS.EventQueue, events);
            // Unfortunately using that will cause some fairly nasty issues where duplicate events continually
            // get sent - see https://jira.atlassian.com/browse/AA-179 for more details.
            // TODO: investigate why the above happens and fix this functionality for good
            AJS.EventQueue.concat(events);

            saveForLater();
            rescheduleFailed();
        });
        publish.done(function () {
            reschedule();
        });
    };

    /**
     * Check for any invalid events and remove/sanitise them.
     * @param events - the list of events to be published
     * @returns the number of valid events remaining
     */
    var validateEvents = function(events) {
        for (var i = events.length - 1; i >= 0; i--) {
            var validMsg = "";
            var event = events[i];
            var properties = event.properties;
            if (typeof event.name === "undefined") {
                validMsg = "you must provide a name for the event.";
            } else if (typeof properties !== "undefined" && properties !== null) {
                if (properties.constructor !== Object) {
                    validMsg = "properties must be an object with key value pairs.";
                } else {
                    sanitiseProperties(properties);
                }
            }
            if (validMsg !== "") {
                AJS.log("WARN: Invalid analytics event detected and ignored, " + validMsg + "\nEvent: "+JSON.stringify(event));
                events.splice(i, 1);
            }
        }
        return events.length;
    };

    var sanitiseProperties = function(properties) {
        for (var propertyName in properties) {
            if (properties.hasOwnProperty(propertyName)) {
                var propertyValue = properties[propertyName];
                if (typeof propertyValue !== "undefined" && propertyValue !== null && propertyValue.toString) {
                    // Sanitise the property value by invoking its "toString"
                    properties[propertyName] = propertyValue.toString();
                } else {
                    // If it's an undefined, null or invalid value - blank it out
                    properties[propertyName] = "";
                }
            }
        }
    };

    var cancelPublish = function() {
        if (publish && !(publish.state() === "resolved" || publish.state() === "rejected")) {
            publish.abort(); // This will cancel the request to the server, and cause the events to be saved for later.
        }
    };

    /**
     * Provides a way to publish events asynchronously, without requiring AJS.Events to have loaded.
     * Users of this property must conditionally initialise it to an empty array. Objects pushed
     * must have a name property, and optionally a properties property of other data to send.
     * @example
     * AJS.EventQueue = AJS.EventQueue || [];
     * AJS.EventQueue.push({name: 'eventName', properties: {some: 'data', more: true, hits: 20}});
     */
    AJS.EventQueue = AJS.EventQueue || [];

    var arrayPush = Array.prototype.push;
    AJS.EventQueue.push = function(obj) {
    	obj.time = new Date().getTime();
    	arrayPush.call(AJS.EventQueue, obj);
    };

    AJS.toInit(function() {
    	determineStorageKey();
        setTimeout(bulkPublish, 500);
        removeOldAnalytics();
    });
    $(window).unload(function() {
        cancelPublish();
        saveForLater();
    });

    /**
     * @deprecated since v3.39, please trigger as normal and use whitelisting to denote privacy policy safe events
     */
    AJS.Analytics = {
        triggerPrivacyPolicySafeEvent: function(name, properties) {
            AJS.log("WARN: 'triggerPrivacyPolicySafeEvent' has been deprecated");
            AJS.EventQueue.push({name: name, properties: properties});
        }
    };

    /**
     * Binds to an event that developers can trigger without having to do any feature check.
     * If this code is available then the event will get published and if it's not the event
     * will go unnoticed.
     * @example
     * AJS.trigger('analytics', {name: 'pageSaved', data: {pageName: page.name, space: page.spaceKey}});
     */
    AJS.bind('analytics', function(event, data) {
    	AJS.EventQueue.push({name: data.name, properties: data.data});
    });

    // legacy binding until Confluence page layout JS is updated
    AJS.bind('analyticsEvent', function(event, data) {
    	AJS.EventQueue.push({name: data.name, properties: data.data});
    });

    /**
     * As part of bundling this plugin in BTF now, we need to remove the existing JIRA analytics setting if we see it.
     */
    var removeOldAnalytics = function () {
        if (window.location.pathname.indexOf("/secure/admin/ViewApplicationProperties") > -1) {
            AJS.$("[data-property-id='analytics-enabled']").remove();
        } else if (window.location.pathname.indexOf("/secure/admin/EditApplicationProperties") > -1) {
            var $analytics = AJS.$(":contains(Enable Atlassian analytics)");
            if ($analytics.size() > 0) {
                var parentElement = $analytics[$analytics.size() - 2];
                if (parentElement) {
                    parentElement.remove();
                }
            }
        }
    }

}(AJS.$));
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:application-header-administration-cog-resource', location = 'header/cog.js' */
var NavLinks = (function (NavLinks) {

    NavLinks.ApplicationHeader = function (ApplicationHeader) {

        ApplicationHeader.Cog = (function () {

            var _get = function () {

                var jiraSection = AJS.$("#system-admin-menu-content");
                if (jiraSection.length > 0) {
                    return jiraSection;
                }

                var confluenceSection = AJS.$("#admin-menu-link-content");
                if (confluenceSection.length > 0) {
                    return confluenceSection;
                }

                // Bamboo
                return AJS.$("#bamboo\\.global\\.header-admin\\.menu");
            };

            return {
                getDropdown: _get
            };
        }());
        return ApplicationHeader;
    }(NavLinks.ApplicationHeader || {});

    return NavLinks;
}(NavLinks || {}));;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:administration-shortcuts-resources', location = 'adminshortcuts/adminshortcuts.soy' */
// This file was automatically generated from adminshortcuts.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.adminshortcuts.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.adminshortcuts == 'undefined') { navlinks.templates.adminshortcuts = {}; }


navlinks.templates.adminshortcuts.section = function(opt_data, opt_ignored) {
  var param5 = '<ul class="aui-list-truncate">';
  var linkList7 = opt_data.links;
  var linkListLen7 = linkList7.length;
  for (var linkIndex7 = 0; linkIndex7 < linkListLen7; linkIndex7++) {
    var linkData7 = linkList7[linkIndex7];
    param5 += '<li><a href="' + soy.$$escapeHtml(linkData7.link) + '">' + soy.$$escapeHtml(linkData7.label) + '</a></li>';
  }
  param5 += '</ul>';
  var output = '' + aui.dropdown2.section({id: 'nl-remote-admin-section', label: "Other applications", content: param5});
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.adminshortcuts.section.soyTemplateName = 'navlinks.templates.adminshortcuts.section';
}
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:administration-shortcuts-resources', location = 'adminshortcuts/adminnavlinks.js' */
var NavLinks = (function (NavLinks) {

    NavLinks.AdminShortcuts = (function () {

        var _requestLinks = function () {
            return AJS.$.ajax({
                url:AJS.contextPath() + '/rest/menu/latest/admin',
                cache:false,
                dataType:'json'
            });
        };

        var trackAnalytics = function () {
            AJS.$("#nl-remote-admin-section").on('click', 'a', function () {
                NL.trackEvent('remoteAdminItemSelected', NL.getCurrentApplication(), $(this).attr('href'));
            });
        };

        return {
            render: function () {

                _requestLinks().done(function (linkData) {

                    // filter links to exclude the local admin link
                    linkData = _.reject(linkData,  function (link) {
                        return link['local'] === true;
                    });

                    if (linkData.length) {
                        // if we have remote admin links, render them in a new dropdown section
                        var renderedTemplate = navlinks.templates.adminshortcuts.section({links: linkData});
                        NavLinks.ApplicationHeader.Cog.getDropdown().append(renderedTemplate);

                        trackAnalytics();
                    }
                })
            }
        };
    }());

    return NavLinks;
}(NavLinks || {}));;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:administration-shortcuts', location = 'adminshortcuts/adminshortcuts-cdn.js' */
AJS.toInit(function () {
    if (AJS.DarkFeatures && AJS.DarkFeatures.isEnabled('rotp.admin.shortcuts')) {
        NavLinks.AdminShortcuts.render();
    }
});;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-projectshortcuts', location = 'projectshortcuts/projectshortcuts.soy' */
// This file was automatically generated from projectshortcuts.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.projectshortcuts.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.projectshortcuts == 'undefined') { navlinks.templates.projectshortcuts = {}; }


navlinks.templates.projectshortcuts.dialogContent = function(opt_data, opt_ignored) {
  return '' + ((opt_data.localShortcuts && opt_data.localShortcuts.length > 0) ? navlinks.templates.projectshortcuts.dialogContentShortcuts({shortcuts: opt_data.localShortcuts, listClass: 'projectshortcut-links'}) : '') + ((opt_data.remoteShortcuts != null) ? (opt_data.remoteShortcuts.length > 0) ? '<h2 class="projectshortcuts-heading">Related Links</h2>' + navlinks.templates.projectshortcuts.dialogContentShortcuts(soy.$$augmentMap(opt_data.remoteShortcuts, {shortcuts: opt_data.remoteShortcuts, listClass: 'projectshortcut-links'})) : '' : navlinks.templates.projectshortcuts.dialogLoading(null));
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogContent.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogContent';
}


navlinks.templates.projectshortcuts.headingWrapper = function(opt_data, opt_ignored) {
  return '<div class="project-dialog-header-wrapper"><div class="project-header"><img class="project-img" src="' + soy.$$escapeHtml(opt_data.logoUrl) + '"><h2 class="dialog-title">' + soy.$$escapeHtml(opt_data.title) + '</h2></div><div class="project-content-wrapper">' + soy.$$filterNoAutoescape(opt_data.contentHtml) + '</div></div>';
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.headingWrapper.soyTemplateName = 'navlinks.templates.projectshortcuts.headingWrapper';
}


navlinks.templates.projectshortcuts.dialogContentShortcuts = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  var output = '<ul' + ((opt_data.listClass) ? ' class="' + soy.$$escapeHtml(opt_data.listClass) + '"' : '') + '>';
  var shortcutList35 = opt_data.shortcuts;
  var shortcutListLen35 = shortcutList35.length;
  for (var shortcutIndex35 = 0; shortcutIndex35 < shortcutListLen35; shortcutIndex35++) {
    var shortcutData35 = shortcutList35[shortcutIndex35];
    output += '<li' + ((shortcutIndex35 == shortcutListLen35 - 1) ? ' class="last"' : '') + '>' + navlinks.templates.projectshortcuts.dialogContentShortcut(shortcutData35) + '</li>';
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogContentShortcuts.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogContentShortcuts';
}


navlinks.templates.projectshortcuts.dialogContentShortcut = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.link) + '"' + ((opt_data.tooltip) ? ' title="' + soy.$$escapeHtml(opt_data.tooltip) + '"' : '') + '>' + soy.$$escapeHtml(opt_data.label) + '</a>';
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogContentShortcut.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogContentShortcut';
}


navlinks.templates.projectshortcuts.dialogLoading = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div class="projectshortcuts-loading">' + ((opt_data.text) ? soy.$$escapeHtml(opt_data.text) : '') + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogLoading.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogLoading';
}
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-projectshortcuts', location = 'projectshortcuts/projectshortcuts.js' */
(function ($, NL) {
    var dialog,
        dialogDataCache = {},
        triggerDataEntityKey = 'key',
        triggerDataEntityName = 'name',
        triggerDataEntityType = 'entity-type';

    function showShortcutsDialog(e) {
        var $trigger = $(this),
            projectKey = $trigger.data(triggerDataEntityKey),
            projectName = $trigger.data(triggerDataEntityName),
            projectEntityType = $trigger.data(triggerDataEntityType);

        if (typeof projectKey === 'undefined') {
            return;
        }

        e.preventDefault();

        dialog = new AJS.Dialog({
            width: 600,
            keypressListener: function (e) {
                if (e.which == jQuery.ui.keyCode.ESCAPE) {
                    dialog.remove();
                }
            },
            id: "project-shortcuts-dialog"
        })
            .addCancel('Close', function () {
                dialog.remove();
            })
            .addPanel('',
                    navlinks.templates.projectshortcuts.headingWrapper({
                            title: projectName,
                            logoUrl: getLogoUrl(),
                            contentHtml : navlinks.templates.projectshortcuts.dialogLoading({ text: 'Retrieving links…' })
                        }))
            .show();

        updateDialogHeight(dialog);

        if (!dialogDataCache[projectKey]) {
            dialogDataCache[projectKey] = {
                entity: {
                    title: projectName
                },
                localShortcuts: null,
                remoteShortcuts: null
            };
            getData(AJS.contextPath() + '/rest/project-shortcuts/1.0/local/' + projectKey, { entityType: projectEntityType }).done(updateLocal);
            getData(AJS.contextPath() + '/rest/project-shortcuts/1.0/remote/' + projectKey, { entityType: projectEntityType }).done(updateRemote).fail(function () {
                var $wrapper = dialog.getCurrentPanel().body.find('.project-content-wrapper');
                $wrapper.find('.projectshortcuts-loading').remove();
                AJS.messages.error($wrapper, {
                    body: "Could not retrieve remote project shortcuts",
                    closeable: false
                });
                updateDialogHeight(dialog);
            });
        } else {
            updateShortcutsDialog(dialogDataCache[projectKey]);
        }

        function updateLocal(data) {
            dialogDataCache[projectKey].localShortcuts = data.shortcuts;
            updateShortcutsDialog(dialogDataCache[projectKey]);
        }
        function updateRemote(data) {
            dialogDataCache[projectKey].remoteShortcuts = data.shortcuts;
            updateShortcutsDialog(dialogDataCache[projectKey]);
        }
    }

    function getLogoUrl() { 
        return $(".project-shortcut-dialog-trigger img").attr("src");
    }

    function updateShortcutsDialog(data) {
        if (data.localShortcuts) { // Don't update the dialog until we have entity data and local links (stops the dialog from displaying remote links only if remote links has returned first)
            dialog.getCurrentPanel().html(
                    navlinks.templates.projectshortcuts.headingWrapper({
                        title: data.entity.title,
                        logoUrl: getLogoUrl(),
                        contentHtml: navlinks.templates.projectshortcuts.dialogContent(data)
                    }));

            updateDialogHeight(dialog);
        }
    }
    
    function truncateDesc(desc) {

        var trunc = 210;
        if(!desc || desc.length <= trunc)
            return desc;

        var i = trunc;
        while(i > 0 && desc.charAt(i) != " ") {
            i--;
        }
        if(i == 0) {
            i = trunc;
        }

        desc = desc.substring(0, i);
        if(desc.length >= i)
            desc = desc + "...";
        return desc;
    }

    /**
     * Since AJS.Dialog's height updating is completely broken we need to do it custom for our dialog
     * @param dialog
     */
    function updateDialogHeight(dialog) {
        var $dialog = dialog.popup.element,
            $body = $dialog.find('.dialog-panel-body'),
            $components = $dialog.find('.dialog-components');

        $body.height('auto');
        $dialog.height($components.outerHeight() - 1);
        $('.aui-shadow').remove();
    }

    function getData(url, data) {
        return $.ajax({
            url: url,
            cache: false,
            data: data,
            dataType: 'json'
        });
    }

    $(document).on('click', '.project-shortcut-dialog-trigger', showShortcutsDialog);
}(jQuery, window.NL = (window.NL || {})));
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:atlassian-ui-popup-display-controller', location = 'popups/DisplayController.js' */
AJS.Popups = AJS.Popups || {};

/**
 * Coordinate the display of popup dialogs requested from other functions in the application.
 *
 * Its responsibility is to organise the display of these popups so that that they do not come into conflict with
 * each other.
 */
AJS.Popups.DisplayController = function () {

    var _popupDialogRegistry = [];
    var _renderPerformed = false;
    var _dialogShown = false;

    AJS.toInit(function () {
        setTimeout(function () {
            AJS.Popups.DisplayController.render();
        }, 0);
    });

    return {

        /**
         * Request the display of a popup dialog to this controller.
         *
         * @param popupDialog An {Object} containing a request to display a popup dialog.
         */
        request:function (popupDialog) {
            _popupDialogRegistry.push(popupDialog);
            if (_renderPerformed && _dialogShown === false) {
                this.render();
            }
        },

        /**
         * Renders a popup dialog on screen.
         *
         * If more than one popup has been requested, it will render the one that has the lowest "weight",
         * if no popups have been requested, no dialog will be displayed.
         *
         */
        render:function () {
            _popupDialogRegistry.sort(function (first, second) {
                return first.weight - second.weight;
            });

            _renderPerformed = true;

            if (_popupDialogRegistry.length !== 0) {
                _dialogShown = true;
                _popupDialogRegistry[0].show();
            }
        }
    };
}();;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-web-plugin:issue-link-web-link', location = 'js/issuelink-weblink.js' */
(function () {
    var $hiddenImg = AJS.$("<img>"),
        $iconUrlInput,
        $urlInput,
        faviconUrl,
        throbberTimeoutId;

    $hiddenImg.load(function() {
        $iconUrlInput.val(faviconUrl);
        $urlInput.css("background-image", 'url("' + faviconUrl + '")');

        clearTimeout(throbberTimeoutId);
        $urlInput.removeClass("loading");
    });
    $hiddenImg.error(function() {
        clearTimeout(throbberTimeoutId);
        $urlInput.removeClass("loading");
    });

    function init(context) {
        $iconUrlInput = AJS.$("#web-link-icon-url", context);
        $urlInput = AJS.$("#web-link-url", context).bind("change", fetchFavicon);

        if ($iconUrlInput.val()) {
            $urlInput.css("background-image", "url(" + $iconUrlInput.val() + ")");
        }
    }

    function fetchFavicon() {
        // Initialise state
        $hiddenImg.attr("src", '');
        $iconUrlInput.val('');
        $urlInput.css("background-image", '');
        faviconUrl = parseFaviconUrl($urlInput.val());

        if (!faviconUrl) {
            return;
        }

        /**
         * IE specific hack: For some reason I cannot change the class inside event handler for the event source.
         */
        setTimeout(function() { $urlInput.addClass("loading"); }, 0);
        throbberTimeoutId = setTimeout(function() { $urlInput.removeClass("loading"); }, 3000);

        $hiddenImg.attr("src", faviconUrl);
    }

    function parseFaviconUrl(url) {
        var hostUrl = url.match(/^([^/]*\/\/[^/]+)/)[1];

        if (!hostUrl) {
            return;
        }

        return hostUrl + "/favicon.ico";
    }

    JIRA.bind(JIRA.Events.NEW_PAGE_ADDED, function (e, context) {
        init(context);
    });
})();;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/path.js' */
define("dndattachment/ctrlv/path", [
    "exports"
], function (
  exports
) {
    "use strict";

    /**
     * Get the basename of a URI (i.e. the last path component).
     * @param {String} uri
     * @returns {String}
     */
    var basename = function basename(uri) {
        return uri.split(/\//).pop();
    };

    exports.basename = basename;

    /**
     * Get everything *except* the basename of a URI.
     * @param {String} uri
     * @returns {String}
     */
    exports.dirname = function (uri) {
        var basenameResult = basename(uri);
        return uri.substring(0, uri.length - basenameResult.length);
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/ie_version.js' */
define("dndattachment/ctrlv/version", [
    "jquery",
    "underscore",
    "jira/util/navigator",
    "exports"
  ],
  function(
    $,
    _,
    Navigator,
    exports
  ){
    "use strict";


    // It's a sad state of affairs that we need this browser detection, but unfortunately there's no reliable feature
    // detection for image pasting from clipboard support, so we're left with browser detection.
    //
    // JIRA politely puts classes on <html> to identify the browser for us, so let's treat that as our browser detection
    // API. We only care about IE for special casing clipboard behaviour, for all other browsers we'll assume they
    // support the HTML5 clipboard API,
    var classes = document.documentElement.className.split(/\s+/);
    var isIE = Navigator.isIE();
    var gt7 = $.inArray("msie-gt-7", classes) > -1;
    var gt8 = $.inArray("msie-gt-8", classes) > -1;
    var gt9 = $.inArray("msie-gt-9", classes) > -1;
    var gt10 = $.inArray("msie-gt-10", classes) > -1;

    var isIE8  = isIE && gt7 && !gt8;
    var isIE9  = isIE && gt8 && !gt9;
    var isIE10 = isIE && gt9 && !gt10;

    exports.isIE8 = _.once(function(){
      return isIE8;
    });

    exports.isIE9 = _.once(function(){
      return isIE9;
    });

    exports.isIE10 = _.once(function(){
      return isIE10;
    });

});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/resource-uris.js' */
define("dndattachment/ctrlv/resource-uris", [
    "jquery",
    "exports"
], function (
  $,
  exports
) {
    "use strict";

    var dataKey = "com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources.resource-uris";
    var data = WRM.data.claim(dataKey) || {};

    exports.get = function(name) {
        return data[name];
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'templates/soy/attach-screenshot-form.soy' */
// This file was automatically generated from attach-screenshot-form.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Html5Screenshot.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Html5Screenshot == 'undefined') { JIRA.Templates.Html5Screenshot = {}; }


JIRA.Templates.Html5Screenshot.attachScreenshotForm = function(opt_data, opt_ignored) {
  return '<h2 class="dialog-title">' + soy.$$escapeHtml("Attach Screenshot") + '</h2><form action="ShowAttachScreenshotFormAction.jspa" class="aui" method="post" id="attach-screenshot-form" data-attach-secure-token="' + soy.$$escapeHtml(opt_data.attachUserToken) + '" data-submit-secure-token="' + soy.$$escapeHtml(opt_data.submitUserToken) + '"><input type="hidden" name="id" value="' + soy.$$escapeHtml(opt_data.id) + '"/><input type="hidden" name="atl_token" value="' + soy.$$escapeHtml(opt_data.atlToken) + '"><input type="hidden" name="formToken" value="' + soy.$$escapeHtml(opt_data.formToken) + '"><input type="hidden" name="filetoconvert" value=""><div class="attach-screenshot-padding"><div class="attach-screenshot-container"><div id="attach-screenshot-inner-container"><div class="mod-content"><ul class="item-details"><li><dl><dt>' + soy.$$escapeHtml("Take a screenshot:") + '</dt>' + ((opt_data.userPlatform == 'pc') ? '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3ePrtScn\x3c/kbd\x3e") + '</dd>' : '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3e\x26#8963; Ctrl\x3c/kbd\x3e + \x3ckbd\x3e\x26#8984; Cmd\x3c/kbd\x3e + \x3ckbd\x3e\x26#8679; Shift\x3c/kbd\x3e + \x3ckbd\x3e3\x3c/kbd\x3e") + '</dd>') + '</dl></li><li><dl><dt>' + soy.$$escapeHtml("Paste the image:") + '</dt>' + ((opt_data.userPlatform == 'pc') ? '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3eCtrl\x3c/kbd\x3e + \x3ckbd\x3ev\x3c/kbd\x3e") + '</dd>' : '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3e\x26#8984; Cmd\x3c/kbd\x3e + \x3ckbd\x3ev\x3c/kbd\x3e") + '</dd>') + '</dl></li></ul></div><input type="text" id="attach-screenshot-fake-input"><div class="attach-screenshot-padding attach-screenshot-padding-inner"><div id="attach-screenshot-image-container" class="attach-screenshot-image-container"><div class="attach-screenshot-placeholder"><div class="mod-content"><ul class="item-details"><li><dl><dt id="attach-screenshot-placeholder-message">' + soy.$$escapeHtml("Your image will be pasted here") + '</dt></dl></li></ul></div></div></div></div><div id=\'attach-max-size\' class="hidden">' + soy.$$escapeHtml(opt_data.maxSize) + '</div></div></div></div><fieldset><div><legend><span>' + soy.$$escapeHtml("Attach Screenshot") + '</span></legend><div id="attach-screenshot-filename-group" class="field-group"><div id="attach-screenshot-progress-container"></div><label for="attachscreenshotname">' + soy.$$escapeHtml("File name") + ' <span class="aui-icon icon-required">' + soy.$$escapeHtml("Required") + '</span></label><input class="text" type="text" id="attachscreenshotname" name="attachscreenshotname" title="File Name" value="' + soy.$$escapeHtml(opt_data.nextScreenshotName) + '"><div class="description">' + soy.$$escapeHtml("A file name to be used as attached image name") + '</div></div></div></fieldset><div class="buttons-container form-footer"><div class="buttons"><button class="aui-button aui-button-primary" id="attach-screenshot-html5-upload">' + soy.$$escapeHtml("Upload") + '</button><a href="#" class="cancel">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form>';
};
if (goog.DEBUG) {
  JIRA.Templates.Html5Screenshot.attachScreenshotForm.soyTemplateName = 'JIRA.Templates.Html5Screenshot.attachScreenshotForm';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/requireDeployJava.js' */
define("dndattachment/ctrlv/requireDeployJava", [
    "jquery",
    "dndattachment/ctrlv/resource-uris",
    "exports"
], function (
  $,
  resourceUris,
  exports
) {
    "use strict";

    var deployJavaPromise = null;

    /**
     * AMD-ish pattern akin to require('deployJava').
     *
     * Oracle provides a JavaScript function -- deployJava -- that makes it easy to install Java in the browser.
     * @returns a jQuery promise that's resolved with two arguments:
     *     - {Function} `deployJava`
     *     - {WindowProxy} the contentWindow where `deployJava` exists.
     */
    exports.requireDeployJava = function () {
        var deferred;

        if (deployJavaPromise !== null) {
            return deployJavaPromise;
        }

        deferred = $.Deferred();
        deployJavaPromise = deferred.promise();

        $('<iframe style="display: none !important; visibility: hidden !important; opacity: 0"/>')
            .attr('src', resourceUris.get("deployJava.html"))
            .one('load', function () {
                deferred.resolve(this.contentWindow.deployJava, this.contentWindow);
            })
            .one('error', deferred.reject.bind(deferred))
            .appendTo('body');

        return deployJavaPromise;
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/polyfill.js' */
define("dndattachment/ctrlv/polyfill", [
    "jquery",
    "underscore",
    "dndattachment/ctrlv/utility",
    "dndattachment/ctrlv/requireDeployJava",
    "dndattachment/ctrlv/resource-uris",
    "dndattachment/ctrlv/path",
    "dndattachment/ctrlv/version",
    "jira/ajs/ajax/smart-ajax",
    "exports"
], function (
  $,
  _,
  utility,
  requireDeployJava,
  resourceUris,
  path,
  version,
  SmartAjax,
  exports
) {
    "use strict";

    var appletNode;

    var pasteImageWidth = 510;
    var pasteImageHeight = 280;
    var dataURILimit = version.isIE8() ? 32000 : Number.MAX_VALUE;

    exports.pasteImageWidth = pasteImageWidth;
    exports.pasteImageHeight = pasteImageHeight;
    exports.dataURILimit = dataURILimit;

    /**
     * Create a rejected jQuery deferred. All arguments are passed to .reject().
     * @returns a jQuery deferred.
     */
    function fail() {
        var deferred = $.Deferred();
        return deferred.reject.apply(deferred, arguments);
    }

    var $node;

    // paste polyfill
    var handleKeydown = function (event) {
        if (utility.isKeyPasteEvent(event)) {
            appletNode.reload();
            var imageUri = appletNode.getClipboardData();
            if (imageUri) {
                var previewImageUri = appletNode.getClipboardData(pasteImageWidth, pasteImageHeight);
                if (previewImageUri.length > dataURILimit) {
                    var f = dataURILimit / previewImageUri.length;
                    previewImageUri = appletNode.getClipboardData(pasteImageWidth * f, pasteImageHeight * f);
                }
                $node.trigger('polyPaste', [imageUri, previewImageUri]);
            }
        }
    };

    /**
     * Use the Java applet to make a HTTP request.
     * @param data
     * @param requestUrl
     * @returns a jQuery deferred that pretends to be a jqXHR. The only addition is a '.abort()' method to try to
     *   conform closer to jqXHR API.
     */
    function executeAjaxUpload(data, requestUrl) {
        var cookies = document.cookies,
          deferred = $.Deferred();

        var xhr = {
            getResponseHeader: function (name) {
                return responseHeaders[name];
            }
        };

        var requestDeferred = new $.Deferred()
          .progress(_.bind(deferred.notify, deferred))
          .done(_.bind(deferred.resolve, deferred))
          .fail(function(error, responseJson) {
              var errorMessage = responseJson || JSON.stringify({ errorMessage: errorMessage });
              deferred.reject(null, null, null, new SmartAjax.SmartAjaxResult(xhr, 0, "error", errorMessage, true));
          });

        appletNode.doMultipartRequest(requestUrl, "UTF-8", window.navigator.userAgent, requestDeferred);
        // Java applets use the browser's cookie storage for URLConnection for non-http-only cookies. This means
        // xsrftoken and other cookies can pollute the browser's.
        deferred.always(function () {
            document.cookies = cookies;
        });
        return deferred;
    }

    /**
     * Install the polyfill to provide clipboard access to non-HTML5 browsers.
     *
     * @param {Element} node Where the 'keydown' event handler should be added.
     * @returns a jQuery promise that's resolved with [deployJava, contentWindow], or rejected
     *   with a [reason, message].
     *
     * Reasons include:
     * - "java-absent" -- Java isn't installed.
     * - "java-version" -- The version Java is not supported.
     * - "java-security" -- Java security settings are blocking the applet. Typically this can be overcome by
     *   lowering the 'Security Level' in Java's 'Control Panel' (e.g. from High to Medium).
     * - "unknown" -- Every other case.
     */
    exports.install = _.once(function (node) {
        $node = $(node);

        return requireDeployJava.requireDeployJava()
            .pipe(function (deployJava, contentWindow) {
                // Unfortunately using deployJava.versionCheck() isn't guaranteed to be accurate. Depending on the
                // platform and JRE. For example Java 1.7.0_06 on IE9 only reports the JRE as 1.7.0 (i.e. no update
                // information).
                // Given that the specific rules/cases/etc are ambiguous, we'll opt for doing a 'best effort' here
                // rather than hard coding a bunch of special case rules that aren't guaranteed to be reliable.
                var attributes,
                    parameters,
                    requiresLegacyApplet,
                    minimumVersion = '1.7.0_06',
                    uri;

                if (deployJava.getJREs().length === 0) {
                    return fail("java-absent");
                } else if (!deployJava.versionCheck(minimumVersion + '+')) {
                    return fail("java-version");
                }

                // Java 1.7.0_45 changed the manifest attributes that are required to allow JavaScript to invoke
                // applet methods. Java 1.7.0_40 and earlier requires the 'Trusted-Library' attribute, but later
                // versions require the 'Caller-Allowable-Codebase' attribute.
                //
                // See https://blogs.oracle.com/java-platform-group/entry/7u45_caller_allowable_codebase_and for more
                // details.
                requiresLegacyApplet = !deployJava.versionCheck('1.7.0_45+');
                uri = resourceUris.get(requiresLegacyApplet ? "clipboard-legacy.jar" : "clipboard.jar");

                attributes = {
                    id: 'JIRA HTML5 Images Applet',
                    codebase: path.dirname(uri),
                    code: "com.atlassian.plugins.jira.screenshot.applet.ScreenshotApplet.class",
                    archive: path.basename(uri),
                    width: 0,
                    height: 0
                };
                parameters = {
                    permissions: "all-permissions"
                };

                deployJava.runApplet(attributes, parameters, minimumVersion);
                appletNode = contentWindow.document.getElementById(attributes.id);

                try {
                    // We need a try/catch here because...
                    // A 'appletNode.isSecurity' doesn't work, because it's falsey on IE. We can use .hasOwnProperty
                    // but it doesn't tell us if it's a function, and 'typeof appletNode.isSecurity' returns
                    // "unknown".
                    if (!appletNode || !appletNode.isSecurityOk()) {
                        return fail("java-security");
                    }
                } catch (e) {
                    return fail("java-security");
                }

                if(! utility.isUnifiedAttachmentsEnabled()){
                    $node.on('keydown', handleKeydown);
                }
                return executeAjaxUpload;
            }, function () {
                return fail("unknown");
            })
            // Add a message to the error.
            .pipe(null, function (reason) {
                var messages;
                if(utility.isUnifiedAttachmentsEnabled()){
                    messages = {
                        "unknown": "A problem occurred while attempting to attach screenshot via Ctrl+V.",
                        "java-version": AJS.format("You need to {0}upgrade Java{1} to be able to attach screenshots via Ctrl+V.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-absent": AJS.format("You need to install {0}Java{1} to be able to attach screenshots via Ctrl+V.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-security": AJS.format("Your Java security settings are blocking the ability to attach screenshots via Ctrl+V. Please upgrade to the latest {0}Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>")
                    }
                } else {
                    messages = {
                        "unknown": "A problem occurred while running Java.",
                        "java-version": AJS.format("You need to {0}upgrade Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-absent": AJS.format("You need to install {0}Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-security": AJS.format("Your Java security settings are blocking this feature. Please upgrade to the latest {0}Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>")
                    }
                }

                return fail(reason, messages[reason]);
            });
    });

    exports.getClipboardData = function(){
        var deferred = new $.Deferred();
        exports.install(document).done(function(){
            try {
                appletNode.reload();
                deferred.resolve(appletNode.getClipboardData());
            } catch(e){
                deferred.reject("A problem occurred while attempting to attach screenshot via Ctrl+V.");
            }
        }).fail(function(reason, message){
            deferred.reject(message);
        });
        return deferred;
    };

    exports.isRequired = function () {
        // Enable the Java applet for IE 8/9/10, assume all other browsers are compatible, since we
        // support latest IE, Chrome, Firefox, and all of these support HTML5 clipboard.
        return version.isIE8() || version.isIE9() || version.isIE10();
    };

    exports.isRequiredForBinaryAjax = function () {
        // The applet has security restrictions on Windows 8 + IE10, so we can't use it there. Luckily IE10 supports
        // AJAX requests with binary data anyway, so we can use that. IE8 and IE9 don't support binary data.
        return version.isIE8() || version.isIE9();
    };

    // proxy ajax request, because session with temporary attachments is in applet
    exports.proxyAjaxRequest = function (fn, userTokenFn) {
        return function () {
            var _smartAjaxMakeRequest = SmartAjax.makeRequest;

            SmartAjax.makeRequest = function (requestOptions) {
                var requestParams = _.reduce(_.keys(requestOptions.data), function (r, name) {
                    r.push(name, requestOptions.data[name]);
                    return r;
                }, []);

                requestParams.push("secureToken", userTokenFn());

                var requestResult = appletNode.doAjaxRequest(requestOptions.url, "UTF-8", window.navigator.userAgent, $.Deferred(), requestParams);
                requestResult.abort = $.noop;
                requestResult.then(function (data) {
                    var responseHeaders = _.filter(arguments, function (el, idx) {
                        return idx > 0;
                    });
                    responseHeaders[0] = "Status";
                    responseHeaders = _.reduce(_.reduce(responseHeaders, function (r, el, idx) {
                        var pdx = (idx / 2) << 0;
                        (r[pdx] || (r[pdx] = [])).push(el);
                        return r;
                    }, []), function (r, el) {
                        r[el[0]] = el[1];
                        return r;
                    }, {});

                    var xhr = {
                        getResponseHeader: function (name) {
                            return responseHeaders[name];
                        }
                    };
                    var textStatus = 'success';
                    var smartAjaxResult = new SmartAjax.SmartAjaxResult(xhr, 0, "success", data, true);
                    requestOptions.complete(xhr, textStatus, smartAjaxResult);
                });

                return requestResult;
            };

            fn.apply(this, arguments);

            SmartAjax.makeRequest = _smartAjaxMakeRequest;
        };
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/html5.js' */
define("dndattachment/ctrlv/html5", [
    "jquery",
    "underscore",
    "dndattachment/ctrlv/polyfill",
    "dndattachment/ctrlv/base64decode",
    "dndattachment/ctrlv/utility",
    "jira/dialog/dialog",
    "jira/dialog/dialog-register",
    "jira/ajs/ajax/smart-ajax",
    "jira/attachment/inline-attach",
    "exports"
], function (
  $,
  _,
  polyfill,
  base64decode,
  utility,
  Dialog,
  DialogRegister,
  SmartAjax,
  InlineAttach,
  exports
) {
    "use strict";

    /**
     * Try to get File Blob from event object, function is asynchronous since on some browsers we may want to
     * implement an workaround for clipboardData.items/files absence
     *
     * @param event JQuery Event object
     * @returns {$.Deferred}
     */
    exports.getFileFromEvent = function (event) {
        var deferred = new $.Deferred();

        if (utility.isImagePasteEvent(event)) {
            // look for image content in items and files, check mimetype and return the first one
            deferred.resolve(
                _(event.clipboardData.items)
                    .filter(function (item) {
                        return item.type.indexOf("image") !== -1;
                    }).map(function (item) {
                        return item.getAsFile();
                    })[0] ||
                    // according to bugzilla in future Mozilla will support this via files:
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=891247
                _(event.clipboardData.files)
                    .filter(function (item) {
                        return item.type.indexOf("image") !== -1;
                    })[0]);
        } else {
            deferred.reject();
        }

        return deferred.promise();
    };

    //exports.screenshotPasteHandler = {
    exports.REQUEST_TIMEOUT_MILLIS = 5 * 60 * 1000;

    exports.screenshotFileUpload = {};
    exports.screenshotFileUploadUri = null;

    exports.$document = undefined;
    exports.$window = undefined;
    exports.$container = undefined;
    exports.$fakeInput = undefined;

    exports.uploadError = false;
    exports.uploadErrorMsg = "";

    exports.progressView = {
        hidden: false,
        progress: 0,
        old: 0,
        progressBarContainer: undefined,
        progressEl: undefined,
        container: undefined,
        options: undefined,
        staticProgress: undefined,

        initProgress: function () {
            this.container = this.buildContainer();
            this.progressEl = this.buildProgress();
            this.container.append(this.progressEl);

            this.options = {showPercentage: false, height: "5px"};

            this.progressBarContainer = $("#attach-screenshot-progress-container");
            this.progressBarContainer.empty();
            this.progressBarContainer.append(this.container);

            this.staticProgress = this.container;
            this.hidden = true;
        },

        finish: function () {
            this.value(100);
        },

        progressHandler: function (event) {
            var percentage = Math.round(event.loaded * 100 / event.total);
            this.value(percentage);
        },

        value: function (value) {
            if (value > 100) {
                value = 100;
            } else if (value < 0) {
                value = 0;
            }

            if (this.hidden) {
                this.progressEl.show();
                this.hidden = false;
            }

            if (this.old !== value) {
                this.progressEl.progressBar(value, this.options);
                if (value >= 100) {
                    this.progressEl.fadeOut();
                }
                this.old = value;
            }
        },

        buildContainer: function () {
            return $("<div>").addClass("file-progress");
        },

        buildProgress: function () {
            return $("<div>").attr("id", "attach-screenshot-upload-progress");
        }
    };

    exports.dialogView = {
        pasteCatcher: {},
        presenter: undefined,

        getMaxSize: function () {
            return $("#attach-max-size").text();
        },

        getFileSize: function () {
            if ($.isPlainObject(this.presenter.screenshotFileUpload) && _.isEmpty(this.presenter.screenshotFileUpload)) {
                return 0;
            }
            return this.presenter.screenshotFileUpload.size || this.presenter.screenshotFileUpload.byteLength || this.presenter.screenshotFileUpload.length;
        },

        cleanGeneralErrors: function () {
            $("#error-attach-screenshot-image").closest(".field-group").remove();
        },

        cleanFileErrors: function () {
            $("#error-attach-screenshot-filename").remove();
        },

        displayErrors: function (errors) {
            if(utility.isUnifiedAttachmentsEnabled()){
                if ("compatibility" in errors) {
                    utility.showErrorMsg("", errors["compatibility"]);
                }
                if ("fileName" in errors) {
                    utility.showErrorMsg("", errors["fileName"]);
                }
                if ("fileUpload" in errors) {
                    utility.showErrorMsg("", errors["fileUpload"]);
                }
            }
            else{
                // cleanup old error messages
                exports.dialogView.cleanFileErrors();
                exports.dialogView.cleanGeneralErrors();

                if ("compatibility" in errors) {
                    $("#attach-screenshot-inner-container").before(aui.message.error({
                        content: errors["compatibility"]
                    }));
                }
                if ("fileName" in errors) {
                    $("#attach-screenshot-filename-group").append("<div class=\"error\" id=\"error-attach-screenshot-filename\" data-field=\"attachscreenshotname\"></div>").find('.error').text(errors["fileName"]);
                }
                if ("fileUpload" in errors) {
                    $("#attach-screenshot-inner-container").append("<div class=\"field-group attach-screenshot-image-error\"><div class=\"error\" id=\"error-attach-screenshot-image\"></div></div>").find('.error').text(errors["fileUpload"]);
                }
            }
        },

        appendBlobImage: function (blob) {
            // and use a URL or webkitURL (whichever is available to the browser)
            // to create a temporary URL to the object
            var URLObj = window.URL || window.webkitURL;
            var source = URLObj.createObjectURL(blob);
            this.presenter.screenshotFileUpload = blob;
            this.createImage(source);
        },

        /**
         * Creates and shows image
         * Supports:
         *  Chrome binary data from Webkit
         *  base64 encoded data from FireFox
         * @param uri image data
         */
        createImage: function (uri) {
            var pastedImage = new Image();
            pastedImage.onload = function () {
                // You now have the image!
            };
            pastedImage.src = uri;

            this.presenter.screenshotToUpload = pastedImage;

            // Appending image to document
            var jqueryImage = $(pastedImage);
            jqueryImage.addClass("attach-screenshot-pasted-image");
            var screenshotContainer = $("#attach-screenshot-image-container");
            screenshotContainer.empty();
            screenshotContainer.append(jqueryImage);

            this.presenter.$fakeInput.focus();

            // handle async upload
            // IE11 quirk: if this is called within onPaste handler, browser will throw "Access denied" on any XHR
            _.defer(function () {
                exports.imageCreatedHandler();
            });

        },

        /**
         * Parse the input in the paste catcher element
         */
        checkInput: function () {
            var image,
              node = exports.dialogView.pasteCatcher.childNodes[0];

            if (node) {
                // If the user pastes an image, the src attribute
                // will represent the image as a base64 encoded string.
                if ("IMG" === node.tagName) {
                    // does not start with data, try to get contents via canvas
                    if (node.src.indexOf("data:") === 0) {
                        image = node.src;
                    } else {
                        // we could use canvas and toDataURL here, but it is not allowed by browser:
                        // https://html.spec.whatwg.org/multipage/scripting.html#dom-canvas-todataurl
                    }
                }

                // Clear the inner html to make sure we're always getting the latest inserted content.
                exports.dialogView.pasteCatcher.innerHTML = "";
            }

            if (!image) {
                exports.$fakeInput.focus();
            }

            return image;
        },

        /**
         * onPaste handler, Either uses webkits clipboardData object on the paste event, or interprets
         * the data uri that has been embedded in the page by firefox.
         */
        onPaste: function (event) {
            exports.dialogView.cleanFileErrors();
            exports.dialogView.cleanGeneralErrors();

            // TODO: ensure target is not text fields - this prevents pasting text in text fields

            // We need to check if event contains image content we can use
            if (utility.isImagePasteEvent(event)) {
                // Get the items from the clipboard
                exports.getFileFromEvent(event).then(function (file) {
                    this.appendBlobImage(file);
                }.bind(this));
                // If we can't handle clipboard data directly (Firefox),
                // we need to read what was pasted from the contenteditable element
            } else {
                setTimeout(function () {
                    var image = this.checkInput();

                    if (image) {
                        // Firefox image is base64 encoded - decoding while setting up the data
                        exports.screenshotFileUpload = base64decode.decodeBase64DataUri(image);
                        exports.dialogView.createImage(image);
                    }

                }.bind(this), 0);
            }
        },

        getFakeInput: function () {
            return $("#attach-screenshot-fake-input");
        },

        getContainer: function () {
            return $("#attach-screenshot-image-container");
        },

        getIssueKey: function () {
            return $("input[name='id']").val();
        },

        getDocument: function () {
            return $(document);
        },

        getWindow: function () {
            return $(window);
        },

        getFileNameInput: function () {
            return $("#attachscreenshotname");
        },

        hasPngExtension: function (str) {
            var pattern = /\.png$/i; // REGEX: Ends with ".png". Case insensitive
            return pattern.test(str);
        },

        setFileToConvert: function (value) {
            $("input[name='filetoconvert']").val(value);
        },

        /**
         * Pasting into a content-editable element is the most cross-browser HTML5 approach.
         */
        buildPasteCatcher: function () {
            if (!document.getElementById("attach-screenshot-form")) return;
            var catcher = document.createElement("div");
            catcher.setAttribute("contenteditable", "true");
            catcher.style.width = 0;
            catcher.style.height = 0;
            /* make sure the catcher is rendered outside the browser view to prevent vertical scrollbars */
            catcher.style.position = 'absolute';
            catcher.style.top = '-5000px';
            document.getElementById("attach-screenshot-form").appendChild(catcher);
            return catcher;
        },

        _getFormSubmits: function () {
            return $("#attach-screenshot-form").find("button.aui-button");
        },

        disable: function () {
            this._getFormSubmits().attr("disabled", "disabled");
            return this;
        },
        enable: function () {
            this._getFormSubmits().removeAttr("disabled");
            return this;
        },
        isEnabled: function () {
            return this.isVisible() && !this._getFormSubmits().attr("disabled");
        },

        isVisible: function () {
            return $("#attach-screenshot-form").length > 0;
        },

        initDialog: function (presenter) {
            this.pasteCatcher = {};
            this.presenter = presenter;

            if (!polyfill.isRequired()) {
                this.pasteCatcher = this.buildPasteCatcher();
            }
        }
    };

    exports.initScreenshotPasteHandler = function () {
        var dialogView = exports.dialogView;

        exports.screenshotFileUpload = {};
        exports.resetUploadErrors();

        exports.dialogView.initDialog(exports);

        // Caching elements needed to fix tabbing
        exports.$document = dialogView.getDocument();
        exports.$window = dialogView.getWindow();
        exports.$container = dialogView.getContainer();
        exports.$fakeInput = dialogView.getFakeInput();

        // Event Handlers
        exports.bindOnce(exports.$container, "click", exports.setFocusOnClickHandler);
        exports.bindOnce(exports.$fakeInput, "focus", exports.showFocusOnFieldHandler);
        exports.bindOnce(exports.$fakeInput, "blur", exports.hideFocusOnFieldHandler);
        exports.bindOnce(exports.$fakeInput, "keydown", exports.keyDownHandler);

        if (!utility.browserIsSupported()) {
            dialogView.displayErrors({"compatibility": AJS.format("Your browser is not supported. Consider using an alternative supported browser such as {0}Google Chrome{1} or {2}Firefox{3}.", "<a href=\"//www.google.com/chrome/browser/\">", "</a>", "<a href=\"//www.mozilla.org/firefox/\">", "</a>")});
        } else if (polyfill.isRequired()) {
            polyfill.install(document)
              .done(function (executeAjaxUploadFromApplet) {
                  exports.bindOnce(exports.$document, "polyPaste", exports.polyPasteHandler);
                  if (polyfill.isRequiredForBinaryAjax()) {
                      exports.executeAjaxUpload = executeAjaxUploadFromApplet;
                  }
              })
              .fail(function (reason, message) {
                  dialogView.displayErrors({"compatibility": message});
              });
        } else {
            exports.bindOnce(exports.$window, "paste", exports.pasteHandler);
        }
    };

    exports.resetUploadErrors = function () {
        exports.uploadError = false;
        exports.uploadErrorMsg = undefined;
    };

    exports.setUploadError = function (errorMsg) {
        exports.uploadError = true;
        exports.uploadErrorMsg = errorMsg;
    };

    /**
     * Ensures only one event is bound to the element
     * @param jqueryEl
     * @param eventName
     * @param handler
     */
    exports.bindOnce = function (jqueryEl, eventName, handler) {
        jqueryEl.unbind(eventName, handler);
        jqueryEl.bind(eventName, handler);
    };

    exports.showFocusOnFieldHandler = function () {
        exports.$container.addClass("focus");
    };

    exports.hideFocusOnFieldHandler = function () {
        exports.$container.addClass("focus");
    };

    exports.setFocusOnClickHandler = function () {
        exports.$fakeInput.focus();
    };

    exports.pasteHandler = function (event) {
        if (!exports.dialogView.isEnabled()) {
            return;
        }
        event = utility.normalizePasteEvent(event);

        exports.dialogView.onPaste(event);
    };

    exports.polyPasteHandler = function (event, imageUri, imagePreviewUri) {
        if (!exports.dialogView.isEnabled()) {
            return;
        }

        exports.screenshotFileUpload = {length: -1};
        exports.screenshotFileUploadUri = imageUri;
        exports.dialogView.createImage(imagePreviewUri);
    };

    exports.keyDownHandler = function (event) {
        if (utility.isKeyPasteEvent(event)) {
            if (exports.dialogView.pasteCatcher.focus) {
                exports.dialogView.pasteCatcher.focus();
            }
        }
    };

    exports.imageCreatedHandler = function () {
        exports.doAjaxUpload(this.dialogView.getIssueKey(), this.dialogView.getFileNameInput().val());
    };

    exports.getMimeType = function () {
        if (polyfill.isRequired()) {
            return "image/jpeg";
        }
        return "image/png";
    };

    exports.createData = function () {
        if (polyfill.isRequired() && !polyfill.isRequiredForBinaryAjax() && !utility.isUnifiedAttachmentsEnabled()) {
            return base64decode.decodeBase64DataUri(exports.screenshotFileUploadUri);
        }
        return exports.screenshotFileUpload;
    };

    // TODO function is not called delete?
    exports.clipboardDataIsEmpty = function (event) {
        // Internet Explorer will fire paste event for anything but image content, therefore we can assume that such event is not empty
        if (window.clipboardData != null) {
            return false;
        }

        return !(event && event.clipboardData && event.clipboardData.types && event.clipboardData.types.length > 0);
    };

    exports.validateFileSize = function (errors, fileSize, maxSize) {
        var fileSize = fileSize || exports.dialogView.getFileSize();
        var maxSize = maxSize || exports.dialogView.getMaxSize();
        if (fileSize > maxSize) {
            //TODO: hack, using IninleAttach module, check if this a blessed way to go
            var sizes = InlineAttach.Text.fileSize(maxSize, fileSize);
            errors["fileUpload"] = AJS.format("Screenshot is too large to attach. Attachment is {0} but the largest allowed attachment is {1}.", sizes[1], sizes[0]);
        }
    };

    exports.validateFormData = function (fileUpload, fileName) {
        var errors = {};

        if ($.isPlainObject(fileUpload) && _.isEmpty(fileUpload)) {
            errors["fileUpload"] = "Please paste the image you wish to upload";
        }
        exports.validateFileSize(errors);
        if (exports.uploadError) {
            errors["fileUpload"] = "The error occurred during image upload - you will need to try the pasting image again. Sorry for the inconvenience.";
        }

        if ("" == fileName) {
            errors["fileName"] = "You must specify a filename of the image.";
        }

        if (!utility.isValidFileName(fileName)) {
            errors["fileName"] = "Filename must not contain the characters \'\\\', \'/\', \'\"\', \':\', \'?\', \'*\', \'\u003c\', \'|\', \'\u003e\', \'!\'";
        }
        return errors;
    };

    exports.doAjaxUpload = function (issueKey, fileName) {
        exports.dialogView.disable();

        var errors = {};
        exports.validateFileSize(errors);
        if (!_.isEmpty(errors)) {
            exports.dialogView.displayErrors(errors);
            exports.dialogView.enable();

            // Prevent form from uploading
            return;
        }

        var data = exports.createData(),
          mimeType = exports.getMimeType(),
          secureToken = $("#attach-screenshot-form").data("attach-secure-token"),
          formToken = $("#attach-screenshot-form").find("input[name='formToken']").attr('value');

        var requestUrl = AJS.contextPath() + "/rest/internal/1.0/AttachTemporaryFile" +
          (polyfill.isRequired() ? "/secure?" : "?") +
          "size=" + exports.dialogView.getFileSize() + "&" +
          "filename=" + encodeURIComponent(fileName) + "&" +
          "atl_token=" + encodeURIComponent(atl_token()) + "&" +
          "issueId=" + encodeURIComponent(this.dialogView.getIssueKey()) +
          (secureToken ? ("&secureToken=" + encodeURIComponent(secureToken)) : "") +
          (formToken ? ("&formToken=" + encodeURIComponent(formToken)) : "");

        exports.resetUploadErrors();
        exports.executeAjaxUpload(data, requestUrl, mimeType).progress(function (val) {
            if (val == 'init') {
                exports.progressView.initProgress();
            }
        }).done(function (val) {
            if (typeof val == "string") {
                val = JSON.parse(val);
            }

            exports.dialogView.setFileToConvert(val.id);
        }).fail(function (jqXHR, textStatus, msg, smartAjaxResult) {
            var errMsg;
            if (smartAjaxResult.statusText == "abort") {
                errMsg = "The call to the JIRA server did not complete within the timeout period.  We are unsure of the result of this operation.";
            } else if (smartAjaxResult.hasData) {
                var data = JSON.parse(smartAjaxResult.data);

                if (data.errorMessage) {
                    errMsg = data.errorMessage;
                } else {
                    errMsg = SmartAjax.buildSimpleErrorContent(smartAjaxResult, {alert: false});
                }
            }
            exports.setUploadError(errMsg);
            exports.dialogView.displayErrors({"fileUpload": errMsg});
        }).always(function () {
            var deferred = $.Deferred();

            // polyfill is required so we need a new secureToken
            if (polyfill.isRequired()) {
                exports.reloadSecureToken(deferred);
            } else {
                deferred.resolve();
            }

            deferred.then(function () {
                exports.dialogView.enable();
                // Progress Listener cleanup
                exports.progressView.finish();
            });
        }).progress(function (val) {
            if (val != 'init') {
                exports.progressView.progressHandler(val);
            }
        });
    };

    exports.executeAjaxUpload = function (data, requestUrl, mimeType) {
        var deferred = $.Deferred();

        var xhr = SmartAjax.makeRequest({
            type: 'POST',
            url: requestUrl,
            contentType: mimeType,
            processData: false,
            data: data,
            timeout: exports.REQUEST_TIMEOUT_MILLIS,
            success: deferred.resolve.bind(deferred),
            error: deferred.reject.bind(deferred),
            xhr: function () {
                var xhr = $.ajaxSettings.xhr();

                deferred.notify('init');
                xhr.upload.addEventListener("progress", deferred.notify.bind(deferred));
                return xhr;
            }
        });

        deferred.always(function () {
            $.ajaxSettings.xhr().removeEventListener("progress", exports.progressView.progressHandler);
            $(DialogRegister.attachScreenshotDialog).off("Dialog.hide", xhr.abort);
        });

        // cancel upload on dialog hide
        $(DialogRegister.attachScreenshotDialog).one("Dialog.hide", xhr.abort);

        return deferred.promise();
    };

    exports.reloadSecureToken = function (deferred) {
        var formUrl = AJS.contextPath() + "/secure/ShowAttachScreenshotFormAction!default.jspa?" +
          "id=" + encodeURIComponent(this.dialogView.getIssueKey()) +
          "&inline=true&decorator=dialog&_=" + (new Date().getTime());

        $.get(formUrl).then(function (response) {
            var newToken = $(response).find("#attach-screenshot-form").data("attach-secure-token");
            if (newToken) {
                $("#attach-screenshot-form").data("attach-secure-token", newToken);
                deferred.resolve(newToken);
            } else {
                deferred.reject();
            }
        }, _.bind(deferred.reject, deferred));
    };

    /**
     * Trigger Attach Screenshot dialog and resolve deferred once it is open
     *
     * @returns {$.Deferred}
     */
    exports.show = function () {
        var deferred = new $.Deferred();
        var $dialogTrigger = $(".issueaction-attach-screenshot-html5.aui-list-item-link");

        // Such situation is not supported yet
        // TODO remove once we add support for textfields in create issue dialog (temporary attachments problem)
        if (Dialog.current != null) {
            return deferred.reject().promise();
        }

        // trigger is not available
        // TODO refactor when we start supporting create issue dialog
        if ($dialogTrigger.length == 0) {
            return deferred.reject().promise();
        }

        // IE11 quirk: if this is called within onPaste handler, browser will throw "Access denied" on any XHR
        _.defer(function () {
            $dialogTrigger.trigger("click");
        });

        $(document).on("dialogContentReady", function (event, dialog) {
            if (dialog === DialogRegister.attachScreenshotDialog &&
              exports.dialogView.isEnabled()) {
                deferred.resolve(dialog);
            } else {
                deferred.reject();
            }
        });

        // each impression of dialog causes ajax request, reject deferred if there was request for dialog content, but after some brief time deferred was still not resolved
        $(document).on("ajaxComplete.jira.screenshot.dialog", function (event, jqXhr, options) {
            if (options.url.indexOf($dialogTrigger.attr("href")) > -1) {
                setTimeout(function () {
                    if (!deferred.isResolved()) {
                        deferred.reject();
                    }
                }, 1000);
            }
        });

        // unbind from ajaxComplete
        deferred.always(function () {
            $(document).off("ajaxComplete.jira.screenshot.dialog");
        });

        return deferred.promise();
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/issue-paste.js' */
define("dndattachment/ctrlv/issue-paste", [
    "jquery",
    "dndattachment/ctrlv/trace",
    "dndattachment/ctrlv/tracking",
    "dndattachment/ctrlv/utility",
    "dndattachment/ctrlv/html5",
    "dndattachment/ctrlv/polyfill",
    "dndattachment/ctrlv/base64decode",
    "jira/dialog/dialog",
    "jira/util/events",
    'dndattachment/util/events/types',
    "exports"
], function (
  $,
  trace,
  tracker,
  utility,
  html5,
  polyfill,
  base64decode,
  Dialog,
  Events,
  EventTypes,
  exports
) {
    "use strict";

    /** Ze State Machine **/

    // Event types
    var EVENT_WINDOW_KEYDOWN = 0;
    var EVENT_WINDOW_PASTE = 1;

    var EVENT_FILE_LOADED = 2;
    var EVENT_FILE_LOAD_ERROR = 3;

    var EVENT_IMAGE_LOADED = 4;
    var EVENT_IMAGE_LOAD_ERROR = 5;

    var EVENT_DIALOG_LOADED = 6;
    var EVENT_DIALOG_CLOSED = 7;
    var EVENT_DIALOG_CANCELED = 8;

    var EVENT_TIMEOUT = 9;
    /**
     * Stub function, does nothing, in future may wrap states in some default behavior
     * @param {Function} state
     * @returns {State}
     * @constructor
     */
    function State(stateName, state) {
        state.stateName = stateName;
        var result = function() {
            var handler = state.apply(null, arguments);
            handler.stateName = stateName;
            return handler;
        };
        result.stateName = stateName;

        return result;
    }

    /**
     * Wraps given state, so that it will receive EVENT_TIMEOUT event after given timeout
     * @param {Function} state
     * @param {Number} timeout in milliseconds
     * @returns {WeakState}
     * @constructor
     */
    function WeakState(stateName, state, timeoutDelay) {
        return State(stateName, function() {
            var timeout = setTimeout(function() {
                triggerEvent(EVENT_TIMEOUT);
            }, timeoutDelay);

            var handler = state.apply(null, arguments);
            var result = function(eventType, eventObject) {
                var result = handler(eventType, eventObject);
                // we will change state, so clear timeout
                if(result) {
                    clearTimeout(timeout);
                    return result;
                }
            };
            result.stateName = stateName;

            return result;
        });
    }

    /**
     * Idle state, initial
     */
    var StateIdle = State("idle", function() {

        function isValidTarget(event) {
            // - don't play with catching paste events on any input elements other than wiki-textfield
            // - ignore content editable, because it will rather handle paste on its own
            // - summary field is an exception, because it is focused by default in create issue dialog
            if($(event.target).is(':input:not(.wiki-textfield, #summary)') || utility.isContentEditable(event.target)) {
                return;
            }

            return true;
        }


        return function(eventType, eventObject) {
            // We have this just in case something goes wrong after OD deployment
            if(utility.isIssuePasteDisabledEnabled()) {
                trace("jira/attach-images-plugin/issuePasteDisabled");
                return;
            }

            if(eventType == EVENT_WINDOW_KEYDOWN && utility.isKeyPasteEvent(eventObject)) {
                // in chrome we rely 100% on onPaste event, in Safari we don't want to make any attempts on catching clipboard data
                if (utility.browserIsNativePaste() || !isValidTarget(eventObject) || !utility.browserIsSupported()) {
                    return;
                }

                tracker.trigger("attach.screenshot.html5.catchClipboard");

                return new StateCatchClipboard(eventObject);
            }

            if(eventType == EVENT_WINDOW_PASTE) {
                if(utility.isImagePasteEvent(eventObject)) {
                    tracker.trigger("attach.screenshot.html5.handlePaste");

                    if(!isValidTarget(eventObject)) {
                        trace("jira/attach-images-plugin/pasteIgnored");
                        return;
                    }

                    /** Prevent paste now so after pressing cancel in dialog selected fragment in textarea won't be removed */
                    if($(eventObject.target).is(':input.wiki-textfield')) {
                        eventObject.preventDefault();
                    }

                    return new StateFileLoading(eventObject);
                } else {
                    trace("jira/attach-images-plugin/pasteIgnoredNotImage");
                }
            }
        }
    });

    /**
     * Catch clipboard contents after CTRL+V
     * @param {Event} keyPasteEvent
     */
    var StateCatchClipboard = WeakState("catchClipboard", function(keyPasteEvent) {
        // we will switch focus from currently active element, but we want to restore it once we are done with this state
        var activeElement = document.activeElement;

        // preserve initial selection information for later use
        keyPasteEvent.selectionStart = keyPasteEvent.target.selectionStart;
        keyPasteEvent.selectionEnd = keyPasteEvent.target.selectionEnd;

        var $contentEditable = $('<div contenteditable="true" class="attach-screenshot-paste-catcher"></div>').appendTo('body');

        // focus on content editable, so the paste event will go into this element and we will get content from it (possible an image)
        $contentEditable.focus();

        // we rely on :focusable or :aui-focusable selector from AUI, we don't want to refocus on non focusable elements, because
        // it may cause unnecessary scroll
        // also focus only on input input elements
        if($(activeElement).is(':focusable:input,:aui-focusable:input')) {
            // this quirk is required for FF, otherwise it will bug cursor
            setTimeout(function() {
                activeElement.focus();
            });
        }

        // TODO refactor this, so we won't need to call this each time we want to leave this state
        function cleanUp() {
            $contentEditable.remove();
        }

        return function(eventType, eventObject) {
            if(eventType == EVENT_WINDOW_PASTE) {
                if(utility.isImagePasteEvent(eventObject)) {
                    cleanUp();

                    eventObject.target = activeElement;
                    return new StateFileLoading(eventObject);
                }

                if(utility.isHtmlImagePasteEvent(eventObject)) {
                    cleanUp();

                    eventObject.target = activeElement;
                    return new StateImageLoading(eventObject);
                }

                if(utility.isTextPasteEvent(eventObject)) {
                    cleanUp();

                    var text1 = utility.getTextPasteContent(eventObject);
                    utility.insertToInput(text1, keyPasteEvent.target, keyPasteEvent.selectionStart, keyPasteEvent.selectionEnd);

                    // This is required for consistent behavior, IE requires preventDefault, while others don't
                    eventObject.preventDefault();

                    return new StateIdle();
                }
            }

            if(eventType == EVENT_TIMEOUT) {
                cleanUp();

                var $img = $contentEditable.find('>img');
                if($img.is(':only-child')) {
                    var imgSrc = $img.attr("src");
                    if (imgSrc.toLowerCase().indexOf("http") === 0) {
                        // we could use canvas and toDataURL here, but it is not allowed by browser:
                        // https://html.spec.whatwg.org/multipage/scripting.html#dom-canvas-todataurl
                        return StateIdle();
                    }
                    else {
                        var array = base64decode.decodeBase64DataUri(imgSrc);
                        var blob = new Blob([array], {type: "image/png"});

                        return new StateAttachImage(blob, keyPasteEvent);
                    }
                } else {
                    // special handling for IE10
                    if(polyfill.isRequired() && !$contentEditable.text()){
                        // if we are here, we know:
                        // - user pressed Ctrl+v while not in a text field
                        // - the clipboard does not contain text (if it did it would have been handled elsewhere)
                        // this is a good place to attempt to load the java applet.
                        // We are not certain the user is trying to paste an image,
                        // but if not they can just choose not to load the applet.
                        return new StateAppletLoading(keyPasteEvent);
                    }
                    else {
                        // there was no image paste, so we need to reinsert pasted text into text input
                        var text2 = utility.getTextContent($contentEditable[0]);
                        utility.insertToInput(text2, keyPasteEvent.target, keyPasteEvent.selectionStart, keyPasteEvent.selectionEnd);

                        return StateIdle();
                    }
                }
            }
        }
    });

    var StateAppletLoading = State("appletLoading", function(keyPasteEvent) {
        polyfill.getClipboardData().done(function(imgUri){
            var array = base64decode.decodeBase64DataUri(imgUri);
            var blob = new Blob([array], {type: "image/jpeg"});
            triggerEvent(EVENT_IMAGE_LOADED, blob);
        }).fail(function(message){
            utility.showErrorMsg("", message);
            triggerEvent(EVENT_IMAGE_LOAD_ERROR);
        });

        return function(eventType, blob){
            if(eventType == EVENT_IMAGE_LOADED){
                return new StateAttachImage(blob, keyPasteEvent);
            }
            if(eventType == EVENT_IMAGE_LOAD_ERROR) {
                return new StateIdle();
            }
        }
    });

    /**
     * Load File from image, this state is not weak, because we expect file loading to take some time
     * @param {Event} pasteEvent that contains text/html in clipboardData
     */
    var StateImageLoading = State("imageLoading", function(pasteEvent) {
        var imageSrc = utility.getHtmlImagePaste(pasteEvent);
        if(!imageSrc) {
            triggerEvent(EVENT_IMAGE_LOAD_ERROR);
        } else {
            utility.loadImage(imageSrc).then(function(image) {
                triggerEvent(EVENT_IMAGE_LOADED, image);
            }, triggerEvent.bind(null, EVENT_IMAGE_LOAD_ERROR));
        }

        return function(eventType, eventObject) {
            if(eventType == EVENT_IMAGE_LOADED) {
                var file = utility.convertImageToBlob(eventObject);

                if(file) {
                    return new StateAttachImage(file, pasteEvent);
                } else {
                    return new StateIdle();
                }
            }

            if(eventType == EVENT_TIMEOUT || eventType == EVENT_IMAGE_LOAD_ERROR) {
                return new StateIdle();
            }
        }
    });

    /**
     * Handle paste event, get file open attach screenshot dialog
     * @param {Event} pasteEvent
     */
    var StateFileLoading = WeakState("fileLoading", function(pasteEvent) {
        html5.getFileFromEvent(pasteEvent).done(function (file) {
            triggerEvent(EVENT_FILE_LOADED, file);
        }).fail(function () {
            triggerEvent(EVENT_FILE_LOAD_ERROR);
        });

        return function(eventType, eventObject) {
            if (eventType == EVENT_FILE_LOADED) {
                return new StateAttachImage(eventObject, pasteEvent);
            } else if (eventType == EVENT_FILE_LOAD_ERROR || eventType == EVENT_TIMEOUT) {
                return new StateIdle();
            }
        }
    }, 1000);

    var StateAttachImage = State("attachImage", function(file, pasteEvent) {
        var pasteTarget =  pasteEvent.target;
        var screenshotName = utility.generateFileName() + (polyfill.isRequired() ? ".jpg" : ".png");

        var pastedImage = utility.convertBlobToImage(file, screenshotName);

        Events.trigger(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, {
            files: [pastedImage],
            // We want the attachment executor to know if a wiki textfield is in focus
            // so that the executor can then decide whether it wants to perform its action.
            isWikiTextfieldFocused: utility.isWikiTextfield($(pasteTarget)),
            wikiTextfield: pasteTarget,
            // Tell the dropzone whether the files came from a paste or from an actual drag and drop
            isPaste: true,
            successCallback: function() {
                triggerEvent(EVENT_DIALOG_LOADED)
            }
        });

        return function(eventType, eventObject) {
            return new StateIdle();
        };
    });

    /**
     * Current state, which will receive next event, initilized with {StateIdle}
     * @type {State}
     */
    var currentState = new StateIdle();

    /**
     * Trigger current state with given parameters
     * @param {Number} eventType
     * @param {Object} eventObject
     */
    function triggerEvent(eventType, eventObject) {
        // some states may call this function during initialization, therefore there is a need to queue such events
        // in order to avoid nested executions
        if(triggerEvent.eventQueue) {
            triggerEvent.eventQueue.push({ type: eventType, object: eventObject });
            return;
        }

        triggerEvent.eventQueue = [{ type: eventType, object: eventObject }];

        while(triggerEvent.eventQueue.length > 0) {
            var event = triggerEvent.eventQueue.splice(0, 1)[0];
            var newState = currentState(event.type, event.object);
            if(newState) {
                currentState = newState;
            }
        }

        delete triggerEvent.eventQueue;
    }

    /**
     * Required for tests
     */
    exports._getStateMap = function() {
        return {
            events: {
                EVENT_WINDOW_KEYDOWN: EVENT_WINDOW_KEYDOWN,
                EVENT_WINDOW_PASTE: EVENT_WINDOW_PASTE,

                EVENT_FILE_LOADED: EVENT_FILE_LOADED,
                EVENT_FILE_LOAD_ERROR: EVENT_FILE_LOAD_ERROR,

                EVENT_IMAGE_LOADED: EVENT_IMAGE_LOADED,
                EVENT_IMAGE_LOAD_ERROR: EVENT_IMAGE_LOAD_ERROR,

                EVENT_DIALOG_LOADED: EVENT_DIALOG_LOADED,
                EVENT_DIALOG_CLOSED: EVENT_DIALOG_CLOSED,
                EVENT_DIALOG_CANCELED: EVENT_DIALOG_CANCELED,

                EVENT_TIMEOUT: EVENT_TIMEOUT
            },
            states: {
                StateIdle: StateIdle,
                StateCatchClipboard: StateCatchClipboard,
                StateAppletLoading: StateAppletLoading,
                StateImageLoading: StateImageLoading,
                StateFileLoading: StateFileLoading,
                StateAttachImage: StateAttachImage
            }
        }
    };

    exports.initIssuePaste = function () {
        // handle CTRL+V on wiki textfields
        $(window).on('keydown', function (event) {
            triggerEvent(EVENT_WINDOW_KEYDOWN, event);
        });
        $(window).on("paste", function (event) {
            triggerEvent(EVENT_WINDOW_PASTE, utility.normalizePasteEvent(event));
        });
        Events.bind("Dialog.hide", function (event, $popup, reason) {
            if (reason) {
                triggerEvent(EVENT_DIALOG_CANCELED, $popup);
            } else {
                triggerEvent(EVENT_DIALOG_CLOSED, $popup);
            }
        });
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/trace.js' */
define("dndattachment/ctrlv/trace", [], function () {
  "use strict";
  // tests often redefine JIRA.trace this avoid grabbing a stale version
  return function amdJiraTrace() {
    return JIRA.trace.apply(undefined, arguments);
  };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/tracking.js' */
define("dndattachment/ctrlv/tracking", [
  "exports"
], function (
  exports
) {
  "use strict";
  exports.trigger = function (analyticKey, payload) {
    AJS.trigger("analytics", {name: analyticKey, data: payload || {}});
  };
});

;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/executor.js' */
define("dndattachment/ctrlv/executor", [
    "jquery",
    "jira/util/events",
    "dndattachment/ctrlv/html5",
    "dndattachment/upload/handler",
    "exports"
], function (
    $,
    Events,
    html5,
    DnDUploadHandler,
    exports
) {

    exports.register = function () {
        /*
         * This executor spawns the attach screenshot dialog and is only valid if user pastes an attachment via ctrlv.
         */
        var ctrlvExecutor = {
            name: 'JIRA Ctrl+V attachment executor',
            // This weight is higher than the default executor (weight 0) and lower than the ServiceDesk executor (weight 50)
            weight: 5,
            isValid: function (event, args) {
                return !!args.isPaste;
            },
            processFiles: function (files, attachmentDropZone) {
                var deferred = $.Deferred();
                html5.show().done(function (dialog) {
                    var $el = $("#attach-screenshot-placeholder-message");
                    var evt = $.Event("paste");
                    evt.clipboardData = {files: files};
                    $el.focus();
                    setTimeout(function() {
                        $el.trigger(evt)
                    });

                    Events.bind("Dialog.hide", function (event, $popup, reason) {
                        if (reason) {
                            deferred.reject();
                        }
                        else {
                            // If there is no reason, then we know the file was uploaded successfully.
                            deferred.resolve([$popup.find('#attachscreenshotname').val() + '.png']);
                        }
                    });
                });

                return deferred;
            }
        };

        DnDUploadHandler.registerExecutor(ctrlvExecutor);
    }

});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/initialize.js' */
define("dndattachment/ctrlv/initialize", [
  "jquery",
  "underscore",
  "dndattachment/ctrlv/polyfill",
  "dndattachment/ctrlv/utility",
  "dndattachment/ctrlv/html5",
  "dndattachment/ctrlv/issue-paste",
  "dndattachment/ctrlv/tracking",
  "dndattachment/ctrlv/executor",
  "jira/dialog/dialog-register",
  "jira/dialog/form-dialog",
  "exports"
], function (
  $,
  _,
  polyfill,
  utility,
  html5,
  issue_paste,
  tracker,
  executor,
  DialogRegister,
  FormDialog,
  exports
) {
  "use strict";

  // Initialization of HTML5 paste handler
  exports.init = function() {
    var AttachImageDialog = FormDialog.extend({
      options: {}
    });

    /**
     * SW-306 js errors are present when this reference isn't available in global scope
     * @deprecated
     */
    JIRA.ScreenshotDialog = AttachImageDialog;

    issue_paste.initIssuePaste();

    // Upload and Cancel Button Handlers
    $(document).ready(function () {
      "use strict";

      var delayShowUntil = $.Deferred();

      if (!utility.browserIsSupported() || !polyfill.isRequired()) {
        delayShowUntil.resolve();
      }

      // Shows the Attach Screenshot in a Popup
      DialogRegister.attachScreenshotDialog = new AttachImageDialog({
        id: "attach-screenshot-dialog",
        trigger: "a.issueaction-attach-screenshot-html5",
        isIssueDialog: true,
        onContentRefresh: function attachScreenshotContentRefresh() {

          this.$form.bind("before-submit", function attachScreenshotContentRefreshBeforeSubmit(e) {
            var errors = html5.validateFormData(html5.screenshotFileUpload, $.trim(html5.dialogView.getFileNameInput().val()));
            if (html5.dialogView.getFileSize() == 0) {
              e.preventDefault();
              return false;
            } else if (!_.isEmpty(errors)) {
              html5.dialogView.displayErrors(errors);
              e.preventDefault();
              return false;
            }
            return true;
          });

        },
        delayShowUntil: function () {
          if (polyfill.isRequired()) {
            polyfill.install(document)
              .done(function () {
                AttachImageDialog.prototype._submitForm = polyfill.proxyAjaxRequest(AttachImageDialog.prototype._submitForm, function () {
                  return $("#attach-screenshot-form").data("submit-secure-token");
                });
              })
              .always(function () {
                delayShowUntil.resolve();
              });
          }
          return delayShowUntil;
        }
      });

      $(document).bind("dialogContentReady", function (event, dialog) {
        // Ensure that the dialog is *ours*, and that it's showing the Attach screen shot form. It's possible that
        // it's populated with an error from the server, in which case we wouldn't want to "init" it.
        if (dialog === DialogRegister.attachScreenshotDialog && document.getElementById("attach-screenshot-form") !== null) {
          tracker.trigger("attach.screenshot.html5.contentReady");
          html5.initScreenshotPasteHandler();
        }
      });

      $(document).ready(function () {
        // Atlassian Analytics - Capture click events
        $(document).on("click", "#attach-screenshot-html5", function () {
          tracker.trigger("attach.screenshot.html5.display");
        });
      });
    });

    executor.register();
  };
});

require([
  "dndattachment/ctrlv/initialize",
  "jquery"
], function(
  jhtml5,
  $
) {
  "use strict";
  $(function() { jhtml5.init(); });
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'applet/deployJava.js' */
/*
 * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * deployJava.js
 *
 * This file is part of the Deployment Toolkit.  It provides functions for web
 * pages to detect the presence of a JRE, install the latest JRE, and easily run
 * applets or Web Start programs.  More Information on usage of the
 * Deployment Toolkit can be found in the Deployment Guide at:
 * http://docs.oracle.com/javase/6/docs/technotes/guides/jweb/index.html
 *
 * The "live" copy of this file may be found at :
 * http://java.com/js/deployJava.js.
 * For web pages provisioned using https, you may want to access the copy at:
 * https://java.com/js/deployJava.js.
 *
 * You are encouraged to link directly to the live copies.
 * The above files are stripped of comments and whitespace for performance,
 * You can access this file w/o the whitespace and comments removed at:
 * http://java.com/js/deployJava.txt.
 *
 */

var deployJava = function() {
    /** HTML attribute filter implementation */
    var hattrs = {
        core: [ 'id', 'class', 'title', 'style' ],
        i18n: [ 'lang', 'dir' ],
        events: [ 'onclick', 'ondblclick', 'onmousedown', 'onmouseup',
            'onmouseover', 'onmousemove', 'onmouseout', 'onkeypress',
            'onkeydown', 'onkeyup' ],
        applet: [ 'codebase', 'code', 'name', 'archive', 'object',
            'width', 'height', 'alt', 'align', 'hspace', 'vspace' ],
        object: [ 'classid', 'codebase', 'codetype', 'data', 'type',
            'archive', 'declare', 'standby', 'height', 'width', 'usemap',
            'name', 'tabindex', 'align', 'border', 'hspace', 'vspace' ]
    };

    var object_valid_attrs = hattrs.object.concat(hattrs.core, hattrs.i18n,
        hattrs.events);
    var applet_valid_attrs = hattrs.applet.concat(hattrs.core);

    // generic log function, use console.log unless it isn't available
    // then revert to alert()
    function log(message) {
        if ( ! rv.debug ) {return};

        if (console.log) {
            console.log(message);
        } else {
            alert(message);
        }
    }

    //checks where given version string matches query
    //
    //NB: assume format is correct. Can add format check later if needed
    // from dtjava.js
    function versionCheckEx(query, version) {
        if (query == null || query.length == 0) return true;

        var c = query.charAt(query.length - 1);

        //if it is not explicit pattern but does not have update version then need to append *
        if (c != '+' && c != '*' && (query.indexOf('_') != -1 && c != '_')) {
            query = query + "*";
            c = '*';
        }

        query = query.substring(0, query.length - 1);
        //if query ends with ".", "_" then we want to strip it to allow match of "1.6.*" to shorter form such as "1.6"
        //TODO: add support for match of "1.7.0*" to "1.7"?
        if (query.length > 0) {
            var z = query.charAt(query.length - 1);
            if (z == '.' || z == '_') {
                query = query.substring(0, query.length - 1);
            }
        }
        if (c == '*') {
            //it is match if version starts from it
            return (version.indexOf(query) == 0);
        } else if (c == '+') {
            //match if query string is lexicographically smaller
            return query <= version;
        }
        return false;
    }

    function getWebStartLaunchIconURL() {
        var imageUrl = '//java.com/js/webstart.png';
        try {
            // for http/https; use protocol less url; use http for all other protocol
            return document.location.protocol.indexOf('http') != -1 ?
                imageUrl : 'http:' + imageUrl;
        } catch (err) {
            return 'http:' + imageUrl;
        }
    }

    // GetJava page
    function constructGetJavaURL(query) {

        var getJavaURL = 'http://java.com/dt-redirect';

        if (query == null || query.length == 0) return getJavaURL;
        if(query.charAt(0) == '&')
        {
            query = query.substring(1, query.length);
        }
        return getJavaURL + '?'+  query;
    }

    function arHas(ar, attr) {
        var len = ar.length;
        for (var i = 0; i < len; i++) {
            if (ar[i] === attr) return true;
        }
        return false;
    }

    function isValidAppletAttr(attr) {
        return arHas(applet_valid_attrs, attr.toLowerCase());
    }

    function isValidObjectAttr(attr) {
        return arHas(object_valid_attrs, attr.toLowerCase());
    }

    /**
     * returns true if we can enable DT plugin auto-install without chance of
     * deadlock on cert mismatch dialog
     *
     * requestedJREVersion param is optional - if null, it will be
     * treated as installing any JRE version
     *
     * DT plugin for 6uX only knows about JRE installer signed by SUN cert.
     * If it encounter Oracle signed JRE installer, it will have chance of
     * deadlock when running with IE.  This function is to guard against this.
     */
    function enableWithoutCertMisMatchWorkaround(requestedJREVersion) {

        // Non-IE browser are okay
        if ('MSIE' != deployJava.browserName) return true;

        // if DT plugin is 10.0.0 or above, return true
        // This is because they are aware of both SUN and Oracle signature and
        // will not show cert mismatch dialog that might cause deadlock
        if (deployJava.compareVersionToPattern(deployJava.getPlugin().version,
            ["10", "0", "0"], false, true)) {
            return true;
        }

        // If we got there, DT plugin is 6uX

        if (requestedJREVersion  == null) {
            // if requestedJREVersion is not defined - it means ANY.
            // can not guarantee it is safe to install ANY version because 6uX
            // DT does not know about Oracle certificates and may deadlock
            return false;
        }

        // 6u32 or earlier JRE installer used Sun certificate
        // 6u33+ uses Oracle's certificate
        // DT in JRE6 does not know about Oracle certificate => can only
        // install 6u32 or earlier without risk of deadlock
        return !versionCheckEx("1.6.0_33+", requestedJREVersion);
    }

    /* HTML attribute filters */

    var rv = {

        debug: null,

        /* version of deployJava.js */
        version: "20120801",

        firefoxJavaVersion: null,

        myInterval: null,
        preInstallJREList: null,
        returnPage: null,
        brand: null,
        locale: null,
        installType: null,

        EAInstallEnabled: false,
        EarlyAccessURL: null,


        // mime-type of the DeployToolkit plugin object
        oldMimeType: 'application/npruntime-scriptable-plugin;DeploymentToolkit',
        mimeType: 'application/java-deployment-toolkit',

        /* location of the Java Web Start launch button graphic is right next to
         * deployJava.js at:
         *    http://java.com/js/webstart.png
         *
         * Use protocol less url here for http/https support
         */
        launchButtonPNG: getWebStartLaunchIconURL(),

        browserName: null,
        browserName2: null,

        /**
         * Returns an array of currently-installed JRE version strings.
         * Version strings are of the form #.#[.#[_#]], with the function returning
         * as much version information as it can determine, from just family
         * versions ("1.4.2", "1.5") through the full version ("1.5.0_06").
         *
         * Detection is done on a best-effort basis.  Under some circumstances
         * only the highest installed JRE version will be detected, and
         * JREs older than 1.4.2 will not always be detected.
         */
        getJREs: function() {
            var list = new Array();
            if (this.isPluginInstalled()) {
                var plugin =  this.getPlugin();
                var VMs = plugin.jvms;
                for (var i = 0; i < VMs.getLength(); i++) {
                    list[i] = VMs.get(i).version;
                }
            } else {
                var browser = this.getBrowser();

                if (browser == 'MSIE') {
                    if (this.testUsingActiveX('1.7.0')) {
                        list[0] = '1.7.0';
                    } else if (this.testUsingActiveX('1.6.0')) {
                        list[0] = '1.6.0';
                    } else if (this.testUsingActiveX('1.5.0')) {
                        list[0] = '1.5.0';
                    } else if (this.testUsingActiveX('1.4.2')) {
                        list[0] = '1.4.2';
                    } else if (this.testForMSVM()) {
                        list[0] = '1.1';
                    }
                } else if (browser == 'Netscape Family') {
                    this.getJPIVersionUsingMimeType();
                    if (this.firefoxJavaVersion != null) {
                        list[0] = this.firefoxJavaVersion;
                    } else if (this.testUsingMimeTypes('1.7')) {
                        list[0] = '1.7.0';
                    } else if (this.testUsingMimeTypes('1.6')) {
                        list[0] = '1.6.0';
                    } else if (this.testUsingMimeTypes('1.5')) {
                        list[0] = '1.5.0';
                    } else if (this.testUsingMimeTypes('1.4.2')) {
                        list[0] = '1.4.2';
                    } else if (this.browserName2 == 'Safari') {
                        if (this.testUsingPluginsArray('1.7.0')) {
                            list[0] = '1.7.0';
                        } else if (this.testUsingPluginsArray('1.6')) {
                            list[0] = '1.6.0';
                        } else if (this.testUsingPluginsArray('1.5')) {
                            list[0] = '1.5.0';
                        } else if (this.testUsingPluginsArray('1.4.2')) {
                            list[0] = '1.4.2';
                        }
                    }
                }
            }

            if (this.debug) {
                for (var i = 0; i < list.length; ++i) {
                    log('[getJREs()] We claim to have detected Java SE ' + list[i]);
                }
            }

            return list;
        },

        /**
         * Triggers a JRE installation.  The exact effect of triggering an
         * installation varies based on platform, browser, and if the
         * Deployment Toolkit plugin is installed.
         *
         * The requestVersion string is of the form #[.#[.#[_#]]][+|*],
         * which includes strings such as "1.4", "1.5.0*", and "1.6.0_02+".
         * A star (*) means "any version starting within this family" and
         * a plus (+) means "any version greater or equal to this".
         * "1.5.0*" * matches 1.5.0_06 but not 1.6.0_01, whereas
         * "1.5.0+" matches both.
         *
         * installCallback is an optional argument which holds a reference
         * to a javascript callback function for reporting install status.
         *
         * If the Deployment Toolkit plugin is not present, this will just call
         * this.installLatestJRE().
         */
        installJRE: function(requestVersion, installCallback) {
            var ret = false;
            if (this.isPluginInstalled() &&
                this.isAutoInstallEnabled(requestVersion)) {
                var installSucceeded = false;
                if (this.isCallbackSupported()) {
                    installSucceeded =
                        this.getPlugin().installJRE(requestVersion, installCallback);
                } else {
                    installSucceeded = this.getPlugin().installJRE(requestVersion);
                }

                if (installSucceeded) {
                    this.refresh();
                    if (this.returnPage != null) {
                        document.location = this.returnPage;
                    }
                }
                return installSucceeded;
            } else {
                return this.installLatestJRE();
            }
        },

        /**
         * returns true if jre auto install for the requestedJREVersion is enabled
         * for the local system; false otherwise
         *
         * requestedJREVersion param is optional - if not specified, it will be
         * treated as installing any JRE version
         *
         * DT plugin for 6uX only knows about JRE installer signed by SUN cert.
         * If it encounter Oracle signed JRE installer, it will have chance of
         * deadlock when running with IE.  This function is to guard against this.
         */
        isAutoInstallEnabled: function(requestedJREVersion) {
            // if no DT plugin, return false
            if (!this.isPluginInstalled()) return false;

            if (typeof requestedJREVersion  == 'undefined') {
                requestedJREVersion = null;
            }

            return enableWithoutCertMisMatchWorkaround(requestedJREVersion);

        },

        /**
         * returns true if jre install callback is supported
         * callback support is added since dt plugin version 10.2.0 or above
         */
        isCallbackSupported: function() {
            return this.isPluginInstalled() &&
                this.compareVersionToPattern(this.getPlugin().version,
                    ["10", "2", "0"], false, true);
        },

        /**
         * Triggers a JRE installation.  The exact effect of triggering an
         * installation varies based on platform, browser, and if the
         * Deployment Toolkit plugin is installed.
         *
         * In the simplest case, the browser window will be redirected to the
         * java.com JRE installation page, and (if possible) a redirect back to
         * the current URL upon successful installation.  The return redirect is
         * not always possible, as the JRE installation may require the browser to
         * be restarted.
         *
         * installCallback is an optional argument which holds a reference
         * to a javascript callback function for reporting install status.
         *
         * In the best case (when the Deployment Toolkit plugin is present), this
         * function will immediately cause a progress dialog to be displayed
         * as the JRE is downloaded and installed.
         */
        installLatestJRE: function(installCallback) {
            if (this.isPluginInstalled() && this.isAutoInstallEnabled()) {
                var installSucceeded = false;
                if (this.isCallbackSupported()) {
                    installSucceeded = this.getPlugin().installLatestJRE(installCallback);
                } else {
                    installSucceeded = this.getPlugin().installLatestJRE();
                }
                if (installSucceeded) {
                    this.refresh();
                    if (this.returnPage != null) {
                        document.location = this.returnPage;
                    }
                }
                return installSucceeded;
            } else {
                var browser = this.getBrowser();
                var platform = navigator.platform.toLowerCase();
                if ((this.EAInstallEnabled == 'true') &&
                    (platform.indexOf('win') != -1) &&
                    (this.EarlyAccessURL != null)) {

                    this.preInstallJREList = this.getJREs();
                    if (this.returnPage != null) {
                        this.myInterval =
                            setInterval("deployJava.poll()", 3000);
                    }

                    location.href = this.EarlyAccessURL;

                    // we have to return false although there may be an install
                    // in progress now, when complete it may go to return page
                    return false;
                } else {
                    if (browser == 'MSIE') {
                        return this.IEInstall();
                    } else if ((browser == 'Netscape Family') &&
                        (platform.indexOf('win32') != -1)) {
                        return this.FFInstall();
                    } else {
                        location.href = constructGetJavaURL(
                            ((this.returnPage != null) ?
                                ('&returnPage=' + this.returnPage) : '') +
                                ((this.locale != null) ?
                                    ('&locale=' + this.locale) : '') +
                                ((this.brand != null) ?
                                    ('&brand=' + this.brand) : ''));
                    }
                    // we have to return false although there may be an install
                    // in progress now, when complete it may go to return page
                    return false;
                }
            }
        },


        /**
         * Ensures that an appropriate JRE is installed and then runs an applet.
         * minimumVersion is of the form #[.#[.#[_#]]], and is the minimum
         * JRE version necessary to run this applet.  minimumVersion is optional,
         * defaulting to the value "1.1" (which matches any JRE).
         * If an equal or greater JRE is detected, runApplet() will call
         * writeAppletTag(attributes, parameters) to output the applet tag,
         * otherwise it will call installJRE(minimumVersion + '+').
         *
         * After installJRE() is called, the script will attempt to detect that the
         * JRE installation has completed and begin running the applet, but there
         * are circumstances (such as when the JRE installation requires a browser
         * restart) when this cannot be fulfilled.
         *
         * As with writeAppletTag(), this function should only be called prior to
         * the web page being completely rendered.  Note that version wildcards
         * (star (*) and plus (+)) are not supported, and including them in the
         * minimumVersion will result in an error message.
         */
        runApplet: function(attributes, parameters, minimumVersion) {
            if (minimumVersion == 'undefined' || minimumVersion == null) {
                minimumVersion = '1.1';
            }

            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";

            var matchData = minimumVersion.match(regex);

            if (this.returnPage == null) {
                // if there is an install, come back here and run the applet
                this.returnPage = document.location;
            }

            if (matchData != null) {
                var browser = this.getBrowser();
                if (browser != '?') {
                    if (this.versionCheck(minimumVersion + '+')) {
                        this.writeAppletTag(attributes, parameters);
                    } else if (this.installJRE(minimumVersion + '+')) {
                        // after successful install we need to refresh page to pick
                        // pick up new plugin
                        this.refresh();
                        location.href = document.location;
                        this.writeAppletTag(attributes, parameters);
                    }
                } else {
                    // for unknown or Safari - just try to show applet
                    this.writeAppletTag(attributes, parameters);
                }
            } else {
                log('[runApplet()] Invalid minimumVersion argument to runApplet():' +
                    minimumVersion);
            }
        },


        /**
         * Outputs an applet tag with the specified attributes and parameters, where
         * both attributes and parameters are associative arrays.  Each key/value
         * pair in attributes becomes an attribute of the applet tag itself, while
         * key/value pairs in parameters become <PARAM> tags.  No version checking
         * or other special behaviors are performed; the tag is simply written to
         * the page using document.writeln().
         *
         * As document.writeln() is generally only safe to use while the page is
         * being rendered, you should never call this function after the page
         * has been completed.
         */
        writeAppletTag: function(attributes, parameters) {
            var startApplet = '<' + 'applet ';
            var params = '';
            var endApplet = '<' + '/' + 'applet' + '>';
            var addCodeAttribute = true;

            if (null == parameters || typeof parameters != 'object') {
                parameters = new Object();
            }

            for (var attribute in attributes) {
                if (! isValidAppletAttr(attribute)) {
                    parameters[attribute] = attributes[attribute];
                } else {
                    startApplet += (' ' +attribute+ '="' +attributes[attribute] + '"');
                    if (attribute == 'code') {
                        addCodeAttribute = false;
                    }
                }
            }

            var codebaseParam = false;
            for (var parameter in parameters) {
                if (parameter == 'codebase_lookup') {
                    codebaseParam = true;
                }
                // Originally, parameter 'object' was used for serialized
                // applets, later, to avoid confusion with object tag in IE
                // the 'java_object' was added.  Plugin supports both.
                if (parameter == 'object' || parameter == 'java_object' ||
                    parameter == 'java_code' ) {
                    addCodeAttribute = false;
                }
                params += '<param name="' + parameter + '" value="' +
                    parameters[parameter] + '"/>';
            }
            if (!codebaseParam) {
                params += '<param name="codebase_lookup" value="false"/>';
            }

            if (addCodeAttribute) {
                startApplet += (' code="dummy"');
            }
            startApplet += '>';

            document.write(startApplet + '\n' + params + '\n' + endApplet);
        },


        /**
         * Returns true if there is a matching JRE version currently installed
         * (among those detected by getJREs()).  The versionPattern string is
         * of the form #[.#[.#[_#]]][+|*], which includes strings such as "1.4",
         * "1.5.0*", and "1.6.0_02+".
         * A star (*) means "any version within this family" and a plus (+) means
         * "any version greater or equal to the specified version".  "1.5.0*"
         * matches 1.5.0_06 but not 1.6.0_01, whereas "1.5.0+" matches both.
         *
         * If the versionPattern does not include all four version components
         * but does not end with a star or plus, it will be treated as if it
         * ended with a star.  "1.5" is exactly equivalent to "1.5*", and will
         * match any version number beginning with "1.5".
         *
         * If getJREs() is unable to detect the precise version number, a match
         * could be ambiguous.  For example if getJREs() detects "1.5", there is
         * no way to know whether the JRE matches "1.5.0_06+".  versionCheck()
         * compares only as much of the version information as could be detected,
         * so versionCheck("1.5.0_06+") would return true in in this case.
         *
         * Invalid versionPattern will result in a JavaScript error alert.
         * versionPatterns which are valid but do not match any existing JRE
         * release (e.g. "32.65+") will always return false.
         */
        versionCheck: function(versionPattern)
        {
            var index = 0;
            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?(\\*|\\+)?$";

            var matchData = versionPattern.match(regex);

            if (matchData != null) {
                // default is exact version match
                // examples:
                //    local machine has 1.7.0_04 only installed
                //    exact match request is "1.7.0_05":  return false
                //    family match request is "1.7.0*":   return true
                //    minimum match request is "1.6+":    return true
                var familyMatch = false;
                var minMatch = false;

                var patternArray = new Array();

                for (var i = 1; i < matchData.length; ++i) {
                    // browser dependency here.
                    // Fx sets 'undefined', IE sets '' string for unmatched groups
                    if ((typeof matchData[i] == 'string') && (matchData[i] != '')) {
                        patternArray[index] = matchData[i];
                        index++;
                    }
                }

                if (patternArray[patternArray.length-1] == '+') {
                    // + specified in request - doing a minimum match
                    minMatch = true;
                    familyMatch = false;
                    patternArray.length--;
                } else if (patternArray[patternArray.length-1] == '*') {
                    // * specified in request - doing a family match
                    minMatch = false;
                    familyMatch = true;
                    patternArray.length--;
                } else if (patternArray.length < 4) {
                    // versionPattern does not include all four version components
                    // and does not end with a star or plus, it will be treated as
                    // if it ended with a star. (family match)
                    minMatch = false;
                    familyMatch = true;
                }

                var list = this.getJREs();
                for (var i = 0; i < list.length; ++i) {
                    if (this.compareVersionToPattern(list[i], patternArray,
                        familyMatch, minMatch)) {
                        return true;
                    }
                }

                return false;
            } else {
                var msg = 'Invalid versionPattern passed to versionCheck: ' +
                    versionPattern;
                log('[versionCheck()] ' + msg);
                alert(msg);
                return false;
            }
        },


        /**
         * Returns true if an installation of Java Web Start of the specified
         * minimumVersion can be detected.  minimumVersion is optional, and
         * if not specified, '1.4.2' will be used.
         * (Versions earlier than 1.4.2 may not be detected.)
         */
        isWebStartInstalled: function(minimumVersion) {

            var browser = this.getBrowser();
            if (browser == '?') {
                // we really don't know - better to try to use it than reinstall
                return true;
            }

            if (minimumVersion == 'undefined' || minimumVersion == null) {
                minimumVersion = '1.4.2';
            }

            var retval = false;
            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";
            var matchData = minimumVersion.match(regex);

            if (matchData != null) {
                retval = this.versionCheck(minimumVersion + '+');
            } else {
                log('[isWebStartInstaller()] Invalid minimumVersion argument to isWebStartInstalled(): ' + minimumVersion);
                retval = this.versionCheck('1.4.2+');
            }
            return retval;
        },

        // obtain JPI version using navigator.mimeTypes array
        // if found, set the version to this.firefoxJavaVersion
        getJPIVersionUsingMimeType: function() {
            // Walk through the full list of mime types.
            for (var i = 0; i < navigator.mimeTypes.length; ++i) {
                var s = navigator.mimeTypes[i].type;
                // The jpi-version is the plug-in version.  This is the best
                // version to use.
                var m = s.match(/^application\/x-java-applet;jpi-version=(.*)$/);
                if (m != null) {
                    this.firefoxJavaVersion = m[1];
                    // Opera puts the latest sun JRE last not first
                    if ('Opera' != this.browserName2) {
                        break;
                    }
                }
            }
        },

        // launch the specified JNLP application using the passed in jnlp file
        // the jnlp file does not need to have a codebase
        // this requires JRE 7 or above to work
        // if machine has no JRE 7 or above, we will try to auto-install and then launch
        // (function will return false if JRE auto-install failed)
        launchWebStartApplication: function(jnlp) {
            var uaString = navigator.userAgent.toLowerCase();

            this.getJPIVersionUsingMimeType();

            // make sure we are JRE 7 or above
            if (this.isWebStartInstalled('1.7.0') == false) {

                // perform latest JRE auto-install
                if ((this.installJRE('1.7.0+') == false) ||
                    ((this.isWebStartInstalled('1.7.0') == false))) {
                    return false;
                }
            }

            var jnlpDocbase = null;

            // use document.documentURI for docbase
            if (document.documentURI) {
                jnlpDocbase = document.documentURI;
            }

            // fallback to document.URL if documentURI not available
            if (jnlpDocbase == null) {
                jnlpDocbase = document.URL;
            }

            var browser = this.getBrowser();

            var launchTag;

            if (browser == 'MSIE') {

                launchTag = '<' +
                    'object classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93" ' +
                    'width="0" height="0">' +
                    '<' + 'PARAM name="launchjnlp" value="' + jnlp + '"' + '>' +
                    '<' + 'PARAM name="docbase" value="' + jnlpDocbase + '"' + '>' +
                    '<' + '/' + 'object' + '>';
            } else if (browser == 'Netscape Family') {

                launchTag = '<' +
                    'embed type="application/x-java-applet;jpi-version=' +
                    this.firefoxJavaVersion + '" ' +
                    'width="0" height="0" ' +
                    'launchjnlp="' +  jnlp + '"' +
                    'docbase="' +  jnlpDocbase + '"' +
                    ' />';
            }

            if (document.body == 'undefined' || document.body == null) {
                document.write(launchTag);
                // go back to original page, otherwise current page becomes blank
                document.location = jnlpDocbase;
            } else {
                var divTag = document.createElement("div");
                divTag.id = "div1";
                divTag.style.position = "relative";
                divTag.style.left = "-10000px";
                divTag.style.margin = "0px auto";
                divTag.className ="dynamicDiv";
                divTag.innerHTML = launchTag;
                document.body.appendChild(divTag);
            }
        },

        createWebStartLaunchButtonEx: function(jnlp, minimumVersion) {

            if (this.returnPage == null) {
                // if there is an install, come back and run the jnlp file
                this.returnPage = jnlp;
            }

            var url = 'javascript:deployJava.launchWebStartApplication(\'' + jnlp +
                '\');';

            document.write('<' + 'a href="' + url +
                '" onMouseOver="window.status=\'\'; ' +
                'return true;"><' + 'img ' +
                'src="' + this.launchButtonPNG + '" ' +
                'border="0" /><' + '/' + 'a' + '>');
        },


        /**
         * Outputs a launch button for the specified JNLP URL.  When clicked, the
         * button will ensure that an appropriate JRE is installed and then launch
         * the JNLP application.  minimumVersion is of the form #[.#[.#[_#]]], and
         * is the minimum JRE version necessary to run this JNLP application.
         * minimumVersion is optional, and if it is not specified, '1.4.2'
         * will be used.
         * If an appropriate JRE or Web Start installation is detected,
         * the JNLP application will be launched, otherwise installLatestJRE()
         * will be called.
         *
         * After installLatestJRE() is called, the script will attempt to detect
         * that the JRE installation has completed and launch the JNLP application,
         * but there are circumstances (such as when the JRE installation
         * requires a browser restart) when this cannot be fulfilled.
         */
        createWebStartLaunchButton: function(jnlp, minimumVersion) {

            if (this.returnPage == null) {
                // if there is an install, come back and run the jnlp file
                this.returnPage = jnlp;
            }

            var url = 'javascript:' +
                'if (!deployJava.isWebStartInstalled(&quot;' +
                minimumVersion + '&quot;)) {' +
                'if (deployJava.installLatestJRE()) {' +
                'if (deployJava.launch(&quot;' + jnlp + '&quot;)) {}' +
                '}' +
                '} else {' +
                'if (deployJava.launch(&quot;' + jnlp + '&quot;)) {}' +
                '}';

            document.write('<' + 'a href="' + url +
                '" onMouseOver="window.status=\'\'; ' +
                'return true;"><' + 'img ' +
                'src="' + this.launchButtonPNG + '" ' +
                'border="0" /><' + '/' + 'a' + '>');
        },


        /**
         * Launch a JNLP application, (using the plugin if available)
         */
        launch: function(jnlp) {
            /*
             * Using the plugin to launch Java Web Start is disabled for the time being
             */
            document.location=jnlp;
            return true;
        },


        /*
         * returns true if the ActiveX or XPI plugin is installed
         */
        isPluginInstalled: function() {
            var plugin = this.getPlugin();
            if (plugin && plugin.jvms) {
                return true;
            } else {
                return false;
            }
        },

        /*
         * returns true if the plugin is installed and AutoUpdate is enabled
         */
        isAutoUpdateEnabled: function() {
            if (this.isPluginInstalled()) {
                return this.getPlugin().isAutoUpdateEnabled();
            }
            return false;
        },

        /*
         * sets AutoUpdate on if plugin is installed
         */
        setAutoUpdateEnabled: function() {
            if (this.isPluginInstalled()) {
                return this.getPlugin().setAutoUpdateEnabled();
            }
            return false;
        },

        /*
         * sets the preferred install type : null, online, kernel
         */
        setInstallerType: function(type) {
            this.installType = type;
            if (this.isPluginInstalled()) {
                return this.getPlugin().setInstallerType(type);
            }
            return false;
        },

        /*
         * sets additional package list - to be used by kernel installer
         */
        setAdditionalPackages: function(packageList) {
            if (this.isPluginInstalled()) {
                return this.getPlugin().setAdditionalPackages(
                    packageList);
            }
            return false;
        },

        /*
         * sets preference to install Early Access versions if available
         */
        setEarlyAccess: function(enabled) {
            this.EAInstallEnabled = enabled;
        },

        /*
         * Determines if the next generation plugin (Plugin II) is default
         */
        isPlugin2: function() {
            if (this.isPluginInstalled()) {
                if (this.versionCheck('1.6.0_10+')) {
                    try {
                        return this.getPlugin().isPlugin2();
                    } catch (err) {
                        // older plugin w/o isPlugin2() function -
                    }
                }
            }
            return false;
        },

        //support native DT plugin?
        allowPlugin: function() {
            this.getBrowser();

            // Safari and Opera browsers find the plugin but it
            // doesn't work, so until we can get it to work - don't use it.
            var ret = ('Safari' != this.browserName2 &&
                'Opera' != this.browserName2);

            return ret;
        },

        getPlugin: function() {
            this.refresh();

            var ret = null;
            if (this.allowPlugin()) {
                ret = document.getElementById('deployJavaPlugin');
            }
            return ret;
        },

        compareVersionToPattern: function(version, patternArray,
                                          familyMatch, minMatch) {
            if (version == undefined || patternArray == undefined) {
                return false;
            }
            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";
            var matchData = version.match(regex);

            if (matchData != null) {
                var index = 0;
                var result = new Array();

                for (var i = 1; i < matchData.length; ++i) {
                    if ((typeof matchData[i] == 'string') && (matchData[i] != ''))
                    {
                        result[index] = matchData[i];
                        index++;
                    }
                }

                var l = Math.min(result.length, patternArray.length);

                // result contains what is installed in local machine
                // patternArray is what is being requested by application
                if (minMatch) {
                    // minimum version match, return true if what we have (installed)
                    // is greater or equal to what is requested.  false otherwise.
                    for (var i = 0; i < l; ++i) {
                        if (result[i] < patternArray[i]) {
                            return false;
                        } else if (result[i] > patternArray[i]) {
                            return true;
                        }
                    }
                    return true;
                } else {
                    for (var i = 0; i < l; ++i) {
                        if (result[i] != patternArray[i]) return false;
                    }
                    if (familyMatch) {
                        // family match - return true as long as what we have
                        // (installed) matches up to the request pattern
                        return true;
                    } else {
                        // exact match
                        // result and patternArray needs to have exact same content
                        return (result.length == patternArray.length);
                    }
                }
            } else {
                return false;
            }
        },

        getBrowser: function() {

            if (this.browserName == null) {
                var browser = navigator.userAgent.toLowerCase();

                log('[getBrowser()] navigator.userAgent.toLowerCase() -> ' + browser);


                // order is important here.  Safari userAgent contains mozilla,
                // IE 11 userAgent contains mozilla and netscape,
                // and Chrome userAgent contains both mozilla and safari.
                if ((browser.indexOf('msie') != -1) && (browser.indexOf('opera') == -1)) {
                    this.browserName = 'MSIE';
                    this.browserName2 = 'MSIE';
                } else if (browser.indexOf('trident') != -1 || browser.indexOf('Trident') != -1) {
                    this.browserName = 'MSIE';
                    this.browserName2 = 'MSIE';
                } else if (browser.indexOf('iphone') != -1) {
                    // this included both iPhone and iPad
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'iPhone';
                } else if ((browser.indexOf('firefox') != -1) && (browser.indexOf('opera') == -1)) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Firefox';
                } else if (browser.indexOf('chrome') != -1) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Chrome';
                } else if (browser.indexOf('safari') != -1) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Safari';
                } else if ((browser.indexOf('mozilla') != -1) && (browser.indexOf('opera') == -1)) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Other';
                } else if (browser.indexOf('opera') != -1) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Opera';
                } else {
                    this.browserName = '?';
                    this.browserName2 = 'unknown';
                }

                log('[getBrowser()] Detected browser name:'+ this.browserName +
                    ', ' + this.browserName2);
            }
            return this.browserName;
        },


        testUsingActiveX: function(version) {
            var objectName = 'JavaWebStart.isInstalled.' + version + '.0';

            // we need the typeof check here for this to run on FF/Chrome
            // the check needs to be in place here - cannot even pass ActiveXObject
            // as arg to another function
            if (typeof ActiveXObject == 'undefined' || !ActiveXObject) {
                log('[testUsingActiveX()] Browser claims to be IE, but no ActiveXObject object?');
                return false;
            }

            try {
                return (new ActiveXObject(objectName) != null);
            } catch (exception) {
                return false;
            }
        },


        testForMSVM: function() {
            var clsid = '{08B0E5C0-4FCB-11CF-AAA5-00401C608500}';

            if (typeof oClientCaps != 'undefined') {
                var v = oClientCaps.getComponentVersion(clsid, "ComponentID");
                if ((v == '') || (v == '5,0,5000,0')) {
                    return false;
                } else {
                    return true;
                }
            } else {
                return false;
            }
        },


        testUsingMimeTypes: function(version) {
            if (!navigator.mimeTypes) {
                log ('[testUsingMimeTypes()] Browser claims to be Netscape family, but no mimeTypes[] array?');
                return false;
            }

            for (var i = 0; i < navigator.mimeTypes.length; ++i) {
                s = navigator.mimeTypes[i].type;
                var m = s.match(/^application\/x-java-applet\x3Bversion=(1\.8|1\.7|1\.6|1\.5|1\.4\.2)$/);
                if (m != null) {
                    if (this.compareVersions(m[1], version)) {
                        return true;
                    }
                }
            }
            return false;
        },

        testUsingPluginsArray: function(version) {
            if ((!navigator.plugins) || (!navigator.plugins.length)) {
                return false;
            }
            var platform = navigator.platform.toLowerCase();

            for (var i = 0; i < navigator.plugins.length; ++i) {
                s = navigator.plugins[i].description;
                if (s.search(/^Java Switchable Plug-in (Cocoa)/) != -1) {
                    // Safari on MAC
                    if (this.compareVersions("1.5.0", version)) {
                        return true;
                    }
                } else if (s.search(/^Java/) != -1) {
                    if (platform.indexOf('win') != -1) {
                        // still can't tell - opera, safari on windows
                        // return true for 1.5.0 and 1.6.0
                        if (this.compareVersions("1.5.0", version) ||
                            this.compareVersions("1.6.0", version)) {
                            return true;
                        }
                    }
                }
            }
            // if above dosn't work on Apple or Windows, just allow 1.5.0
            if (this.compareVersions("1.5.0", version)) {
                return true;
            }
            return false;



        },

        IEInstall: function() {

            location.href = constructGetJavaURL(
                ((this.returnPage != null) ?
                    ('&returnPage=' + this.returnPage) : '') +
                    ((this.locale != null) ?
                        ('&locale=' + this.locale) : '') +
                    ((this.brand != null) ? ('&brand=' + this.brand) : ''));

            // should not actually get here
            return false;
        },

        done: function (name, result) {
        },

        FFInstall: function() {

            location.href = constructGetJavaURL(
                ((this.returnPage != null) ?
                    ('&returnPage=' + this.returnPage) : '') +
                    ((this.locale != null) ?
                        ('&locale=' + this.locale) : '') +
                    ((this.brand != null) ? ('&brand=' + this.brand) : '') +
                    ((this.installType != null) ?
                        ('&type=' + this.installType) : ''));

            // should not actually get here
            return false;
        },

        // return true if 'installed' (considered as a JRE version string) is
        // greater than or equal to 'required' (again, a JRE version string).
        compareVersions: function(installed, required) {

            var a = installed.split('.');
            var b = required.split('.');

            for (var i = 0; i < a.length; ++i) {
                a[i] = Number(a[i]);
            }
            for (var i = 0; i < b.length; ++i) {
                b[i] = Number(b[i]);
            }
            if (a.length == 2) {
                a[2] = 0;
            }

            if (a[0] > b[0]) return true;
            if (a[0] < b[0]) return false;

            if (a[1] > b[1]) return true;
            if (a[1] < b[1]) return false;

            if (a[2] > b[2]) return true;
            if (a[2] < b[2]) return false;

            return true;
        },

        enableAlerts: function() {
            // reset this so we can show the browser detection
            this.browserName = null;
            this.debug = true;
        },

        poll: function() {

            this.refresh();
            var postInstallJREList = this.getJREs();

            if ((this.preInstallJREList.length == 0) &&
                (postInstallJREList.length != 0)) {
                clearInterval(this.myInterval);
                if (this.returnPage != null) {
                    location.href = this.returnPage;
                };
            }

            if ((this.preInstallJREList.length != 0) &&
                (postInstallJREList.length != 0) &&
                (this.preInstallJREList[0] != postInstallJREList[0])) {
                clearInterval(this.myInterval);
                if (this.returnPage != null) {
                    location.href = this.returnPage;
                }
            }

        },

        writePluginTag: function() {
            var browser = this.getBrowser();

            if (browser == 'MSIE') {
                // width=0 and height=0 don't seem to be enough to hide the object element on all IE versions
                // so position: absolute + top were added to ensure the expected behaviour
                document.write('<' +
                    'object classid="clsid:CAFEEFAC-DEC7-0000-0001-ABCDEFFEDCBA" ' +
                    'id="deployJavaPlugin" width="0" height="0" style="position: absolute; top: -5000px;">' +
                    '<' + '/' + 'object' + '>');
            } else if (browser == 'Netscape Family' && this.allowPlugin()) {
                this.writeEmbedTag();
            }
        },

        refresh: function() {
            navigator.plugins.refresh(false);

            var browser = this.getBrowser();
            if (browser == 'Netscape Family' && this.allowPlugin()) {
                var plugin = document.getElementById('deployJavaPlugin');
                // only do this again if no plugin
                if (plugin == null) {
                    this.writeEmbedTag();
                }
            }
        },

        writeEmbedTag: function() {
            var written = false;
            if (navigator.mimeTypes != null) {
                for (var i=0; i < navigator.mimeTypes.length; i++) {
                    if (navigator.mimeTypes[i].type == this.mimeType) {
                        if (navigator.mimeTypes[i].enabledPlugin) {
                            document.write('<' +
                                'embed id="deployJavaPlugin" type="' +
                                this.mimeType + '" hidden="true" />');
                            written = true;
                        }
                    }
                }
                // if we ddn't find new mimeType, look for old mimeType
                if (!written) for (var i=0; i < navigator.mimeTypes.length; i++) {
                    if (navigator.mimeTypes[i].type == this.oldMimeType) {
                        if (navigator.mimeTypes[i].enabledPlugin) {
                            document.write('<' +
                                'embed id="deployJavaPlugin" type="' +
                                this.oldMimeType + '" hidden="true" />');
                        }
                    }
                }
            }
        }
    }; // deployJava object

    rv.writePluginTag();
    if (rv.locale == null) {
        var loc = null;

        if (loc == null) try {
            loc = navigator.userLanguage;
        } catch (err) { }

        if (loc == null) try {
            loc = navigator.systemLanguage;
        } catch (err) { }

        if (loc == null) try {
            loc = navigator.language;
        } catch (err) { }

        if (loc != null) {
            loc.replace("-","_")
            rv.locale = loc;
        }
    }

    return rv;
}();;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:attachment-menu-link-init', location = 'js/menu/initAttachmentMenuLink.js' */
require([
        'jquery',
        'dndattachment/aui',
        'jira/util/events',
        'dndattachment/util/events/types'
    ], function ($,
                 AJS,
                 Events,
                 EventTypes) {

        var ISSUEACTION_ATTACH_FILES_CLASS = "issueaction-attach-file";

        var addDialogClassAndInvoke = function($el) {
            $el.addClass(ISSUEACTION_ATTACH_FILES_CLASS);
            $el.click();
        };

        var openFilePickerForPage = function() {
            var $tempFileInput = $("<input type=\"file\" multiple />");
            $tempFileInput.change(function (event) {
                Events.trigger(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, {
                    files: $tempFileInput[0].files
                });
            });
            $tempFileInput.click();
        };

        var isSubtaskLink = function($link) {
            return !! $link.data("issuekey");
        };

        // This should use skate once skate is a thing in jira-core
        var initialiseMenuAttachmentLink = function () {
            $(document).on('click', '.unified-attach-file', function (e) {
                AJS.trigger('analytics', { name : 'issue.dnd.attachment.opsbar.attachFiles.linkClick', data : {}});

                var $target = $(e.target);

                // If we have the old issueaction class, then do nothing
                if($target.hasClass(ISSUEACTION_ATTACH_FILES_CLASS)) {
                    return;
                }

                e.preventDefault();

                // Check if we have a Drop Zone present
                var isDropZonePresent = $(".issue-drop-zone").length;
                if(isDropZonePresent && !isSubtaskLink($target)) {
                    // If we have a drop zone available then we  create a dummy file input and open it
                    openFilePickerForPage();
                } else {
                    // If we do not, then add the class to make it behave the old way then click the target again to open the dialog
                    // This is mainly for JIRA Agile, who won't have a drop zone available to listen accept the files.
                    addDialogClassAndInvoke($target);
                }
            });
        };

        var onReady = function () {
            initialiseMenuAttachmentLink();
        };

        if ($.isReady) {
            onReady();
        } else {
            AJS.$(onReady);
        }
    }
);;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-public', location = 'js/applinks.public.js' */
/**
 * Support code to provide appropriate behavior for HTML elements created by
 * ApplicationLinkUIService; also, public functions that can be used from JS code
 * in other plugins to create the same kinds of HTML elements, in case it's not
 * convenient to do so on the back end.
 */
var ApplinksUtils = ApplinksUtils || (function($) {

    var pendingRequests = {},
        pendingConfirmations = {};
    
    // Provide a well-defined name for the authentication window/tab we create with
    // window.open() - may be useful in debugging, and is used by integration tests.
    // Note, IE8 does not allow this name to contain hyphens or periods.
    var authWindowName = "com_atlassian_applinks_authentication";

    /**
     * This function is basically duplicated from messages.js in AJS, because some products
     * only provide a stub version of messages.js within gadgets.
     */
    function makeCloseable(message) {
        var $icon = $('<span class="aui-icon icon-close"></span>').click(function () {
            message.trigger("messageClose", [this]).remove();
        });
        message.append($icon);
    }

    /**
     * Helper function to get the DOM object of the current iframe.
     * @return {Object} a DOM object, or null if we are not in an iframe
     */
    function getCurrentIframe() {
        if (window === parent.window) {
            return null;
        }
        var ret = null,
            myFrameWindow = window;
        $('iframe', parent.document.body).each(function(index) {
            if (this.contentWindow.window === myFrameWindow) {
                ret = this;
            }
        });
        return ret;
    }

    /**
     * Event handler that is called by the applinks authorization completion servlet.  It triggers
     * the completion function for any pending authorization request that matches the given applink
     * ID, and also redispatches the event to any other iframes in the current window.
     * @param {Object} eventObject  JQuery event object
     * @param {string} applinkId  application link ID
     * @param {boolean} success  true if the request was approved
     * @param {string} authAdminUri  URI of the "OAuth Access Tokens" page (will be displayed in the
     *   confirmation message)
     * @param {boolean} wasRedispatched  true if the event has been retriggered from another frame
     * @param {Object} [messages]
     *      'userError': an error message relevant to a non-admin user,
     *      'adminError': an error message relevant to an admin user,
     *      'adminErrorDetails': a list of details related to the admin message if there is one 
     */
    function onAuthCompletion(eventObject, applinkId, success, authAdminUri, wasRedispatched, messages) {
        if (applinkId in pendingRequests) {
            var request = pendingRequests[applinkId];
            if (success) {
                request.authAdminUri = authAdminUri;
                delete pendingRequests[applinkId];
            }
            completeAuthRequest(request, success, messages);
        }
        if (!wasRedispatched && parent && (parent !== window)) {
            var myWindow = window;
            $('iframe', parent.document.body).each(function(index, frame) {
                var scope = frame.contentWindow;
                if (scope !== myWindow) {
                    if (scope.AJS && scope.AJS.$) {
                        scope.AJS.$(scope.document).trigger('applinks.auth.completion',
                            [applinkId, success, authAdminUri, true, messages]);
                    }
                }
            });
        }
    }
      
    /**
     * Fires the appropriate event when the authorization flow has completed.  On approval, reloads
     * the window/frame unless an event handler calls {@code preventDefault()} on the event.
     * @param {Object} applinkProperties  has the same properties passed to {@link createAuthRequestBanner}
     * @param {boolean} approved  true if the request was approved
     * @param {Object} [messages]
     *      'userError': an error message relevant to a non-admin user,
     *      'adminError': an error message relevant to an admin user,
     *      'adminErrorDetails': a list of details related to the admin message if there is one
     */
    function completeAuthRequest(applinkProperties, approved, messages) {
        var $scope = $(document);
        if (approved) {
            // Temporarily bind an event handler so our handler runs after any other handlers that
            // may exist.
            var defaultApprovalHandler = function (eventObject) {
                if (eventObject.isDefaultPrevented()) {
                    // Don't reload, just show the confirmation message
                    showAuthConfirmationBanner(applinkProperties);
                } else {
                    // Reload, but first save a reminder to make us show a confirmation message
                    // after we've reloaded.
                    registerPendingConfirmation(applinkProperties);
                    document.location.reload(true);
                }
            };
            $scope.bind('applinks.auth.approved', defaultApprovalHandler);
            $scope.trigger('applinks.auth.approved', applinkProperties);
            $scope.unbind('applinks.auth.approved', defaultApprovalHandler);
        } else {
            // There's no default behavior for a request that was denied, but fire an event in case
            // anyone is interested.
            $scope.trigger('applinks.auth.denied', [applinkProperties, messages]);
        }
    }

    /**
     * Used internally to make the applink support code aware of a "please authenticate" message
     * element that has been displayed, by wiring the appropriate event handlers and adding the
     * applink's properties to an internal list of authentication requests.
     * @param $element {Object}  a JQuery object
     * @param applinkProperties {Object}  has the same properties passed to {@link createAuthRequestBanner}
     */
    function initAuthRequest($element, applinkProperties) {
        var $authLink = $element.find("a.applink-authenticate");
        
        if ($element.hasClass('aui-message')) {
            // Workaround for incomplete AJS availability in some products
            makeCloseable($element);
        }
        
        $authLink.click(function(e) {
            window.open(applinkProperties.authUri, authWindowName);
            e.preventDefault();
        });
        
        pendingRequests[applinkProperties.id] = applinkProperties;
        
        return $element;
    }
    
    /**
     * Used internally to ensure that {@link initAuthRequest} is called for every
     * authorisation request element that was generated as HTML from the back end,
     * rather than by calling {@link createAuthRequestBanner} or
     * {@link createAuthRequestInline}.  The parameters of the request are passed
     * from the back end in hidden input elements.
     */
    function initAuthRequestElements() {
        $('.applinks-auth-request').each(function(index) {
            var $e = $(this),
                applinkId = $e.find(".applinkId").val(),
                appName = $e.find(".appName").val(),
                appUri = $e.find(".appUri").val(),
                authUri = $e.find(".authUri").val();
            // Ignore request banners that have already been created (by {@link createAuthRequestBanner} or
            // {@link createAuthRequestInline})
            if (applinkId && authUri) {
                initAuthRequest($e, {
                    id: applinkId,
                    appName: appName,
                    appUri: appUri,
                    authUri: authUri});
            }
        });
    }

    /**
     * Builds a "please authenticate" banner (in a standard AUI message box) containing a link that
     * that will start authorization for an application link that needs credentials.
     * <p>
     * On completion of the authorization flow, a JQuery event will be triggered on the document,
     * with the event type "applinks.auth.approved" or "applinks.auth.denied", and an additional
     * parameter equal to the {@code applinkProperties} parameter that was passed here.
     * <p>
     * If authorization is granted (event "applinks.auth.approved"), the default behavior is for the
     * window or frame to be reloaded; also, a confirmation banner will be displayed either within
     * a &lt;div&gt; element of class "applinks-auth-confirmation-container" if one exists, or at the top of
     * the document otherwise.  Reloading of the window/frame can be disabled by having an event
     * handler call {@code preventDefault()} on the event.
     *
     * @param {Object} applinkProperties contains the following application link properties:
     *   {@code id}: the application link identifier;
     *   {@code appName}: the name of the remote application;
     *   {@code appUri}: the base URI of the remote application;
     *   {@code authUri}: the URI for starting the authorization flow
     * @return {Object} a JQuery object referring to a {@code <div>} element, which has not yet
     *   been inserted anywhere on the page; its class is "applinks-auth-request"
     */
    function createAuthRequestBanner(applinkProperties) {
        var $banner = $('<div class="aui-message warning closeable applinks-auth-request"><p><span class="aui-icon icon-applinks-key"></span></p></div>');
        // Note that we can't just use the AJS.messages.warning() function, because it will put a
        // standard warning icon in the message box and we want a custom icon.
        $banner.append(AJS.format("Additional information may be available, please \u003ca class=\"applink-authenticate\" href=\"{0}\"\u003eauthenticate\u003c/a\u003e with \u003ca href=\"{1}\"\u003e{2}\u003c/a\u003e.",
                                        AJS.escapeHtml(applinkProperties.authUri),
                                        AJS.escapeHtml(applinkProperties.appUri),
                                        AJS.escapeHtml(applinkProperties.appName)));
        initAuthRequest($banner, applinkProperties);
        return $banner;
    }

    /**
     * Builds a "please authenticate" message suitable for displaying inline (in a span
     * with the class "applinks-auth-request"), containing a link that will start authorization.
     * This behaves identically to {@link createAuthRequestBanner}, except it creates a {@code <span>}
     * element instead of a {@code div} and also allows additional text to be displayed.
     * 
     * @param {string} content  optional HTML content to be displayed within the inline
     *   element (e.g. a description of the entity for which authorization is required);
     *   will not be escaped; may be null
     * @param {Object} applinkProperties  see {@link createAuthRequestBanner}
     * @return {Object} a JQuery object referring to a {@code <span>} element, which has not yet
     *   been inserted anywhere on the page; its class is "applinks-auth-request"
     */
    function createAuthRequestInline(content, applinkProperties) {
        var $lozenge = $('<span class="applinks-auth-request"></span>'),
            $contentSpan = $('<span class="applinks-request-description"></span>'),
            message = AJS.format("\u003ca class=\"applink-authenticate\" href=\"{0}\"\u003eAuthenticate\u003c/a\u003e to see additional information.", AJS.escapeHtml(applinkProperties.authUri));
        if (content) {
            $contentSpan.append(content);
            $contentSpan.append(" - ");
        }
        $contentSpan.append(message);
        $lozenge.append($contentSpan);
        initAuthRequest($lozenge, applinkProperties);
        return $lozenge;
    }

    /**
     * Used internally to remember the fact that we have just completed authorizing an
     * applink and are about to refresh the iframe associated with it, so that we can
     * display a confirmation message after the iframe is refreshed.
     */
    function registerPendingConfirmation(applinkProperties) {
        var frame = getCurrentIframe();
        if ((!frame) || (!frame.id)) {
            return;
        }
        if (! parent.ApplinksUtils.pendingConfirmations) {
            parent.ApplinksUtils.pendingConfirmations = { };
        }
        if (!(frame.id in parent.ApplinksUtils.pendingConfirmations)) {
            parent.ApplinksUtils.pendingConfirmations[frame.id] = [];
        }
        parent.ApplinksUtils.pendingConfirmations[frame.id].push(applinkProperties);
        return;
    }

    /**
     * Called after a page load, to see if we've been refreshed due to a successful authorization.
     * If we're in an iframe, a variable will have been set on the parent window to tell us that
     * this happened.  If so, insert a confirmation banner at the top of the iframe.
     */
    function checkForPendingConfirmations() {
        if (parent && parent.ApplinksUtils && parent.ApplinksUtils.pendingConfirmations) {
            var myFrame = getCurrentIframe();
            if (myFrame) {
                if (myFrame.id in parent.ApplinksUtils.pendingConfirmations) {
                    var pendingConfirmations = parent.ApplinksUtils.pendingConfirmations[myFrame.id];
                    delete parent.ApplinksUtils.pendingConfirmations[myFrame.id];
                    for (var i = 0, n = pendingConfirmations.length; i < n; i++) {
                        showAuthConfirmationBanner(pendingConfirmations[i]);
                    }
                }
            }
        }
    }

    /**
     * Displays a confirmation banner.  If an element exists with the class
     * "applinks-auth-confirmation-contianer", it is inserted there, otherwise at the top of the
     * document.
     */
    function showAuthConfirmationBanner(applinkProperties) {
        var scope = $(document),
            banner = $('<div class="aui-message success closeable applinks-auth-confirmation"><p><span class="aui-icon icon-applinks-key-success"></span></p></div>'),
            container = scope.find('div.applinks-auth-confirmation-container');
        if (!container.length) {
            container = scope.find('body');
        }
        banner.append(AJS.format("This application is now using \u003ca href=\"{0}\"\u003e{1}\u003c/a\u003e\'\'s credentials. Revoke access at any time by going to \u003ca href=\"{2}\"\u003eOAuth access tokens\u003c/a\u003e.",
                                        AJS.escapeHtml(applinkProperties.appUri),
                                        AJS.escapeHtml(applinkProperties.appName),
                                        AJS.escapeHtml(applinkProperties.authAdminUri)));
        makeCloseable(banner);
        container.prepend(banner);
        setTimeout(function() {
            banner.fadeOut(1000, function() {
                $(this).remove();
            });
        }, 5000);
    }
    
    /**
     * Initialization function to be called once at document ready time.
     */
    function setup() {
        // If we're in an iframe, set up an object in the parent window that we can use to
        // keep track of state even if the iframe is refreshed.
        if (parent && !(parent === window)) {
            if (! parent.ApplinksUtils) {
                parent.ApplinksUtils = { };
            }
        }
        
        $(document).bind('applinks.auth.completion', onAuthCompletion);

        initAuthRequestElements();
        checkForPendingConfirmations();
    }

    $(document).ready(setup);
    
    return {      
        createAuthRequestBanner: createAuthRequestBanner,
        createAuthRequestInline: createAuthRequestInline
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:lodash-amd', location = 'applinks/internal/lib/lodash-jslibs.js' */
define('applinks/lib/lodash', ['atlassian/libs/underscore-1.5.2'], function(lodash) {
        return lodash;
    });;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/console-amd.js' */
define('applinks/lib/console', function() {
    return window.console;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/jquery-amd.js' */
define('applinks/lib/jquery', function() {
   return window.jQuery;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/aui-amd.js' */
define('applinks/lib/aui', function() {
   var aui = window.AJS;
   if (!aui) {
      throw "window.AJS not defined, cannot load AUI";
   }
   var auiVersion = aui.version.split(".");
   aui.versionDetails = {
      major: parseInt(auiVersion[0]),
      minor: parseInt(auiVersion[1]),
      bugfix: parseInt(auiVersion[2])
   };
   return aui;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/wrm-amd.js' */
/**
 * Define Web resource manager as an AMD dependency. This should also be present in apps using Atlassian Plugins Web
 * Resources framework.
 */
define('applinks/lib/wrm', function() {
   return window.WRM;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/skate-amd.js' */
define('applinks/lib/skate', function() {
   return window.skate;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/window-amd.js' */
/**
 * Define window as AMD module to facilitate unit testing of some modules
 */
define('applinks/lib/window', function() {
    return window;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/preconditions.js' */
define('applinks/common/preconditions', [
    'applinks/lib/lodash'
], function(
    _
) {
    function nonEmptyString(value, varName, customMessage) {
        _checkArgument(
            _.isString(value) && !_.isEmpty(value),
            customMessage,
            _withVarName(varName, ': expected a non-empty string')
        );
    }

    function isFunction(value, varName, customMessage) {
        _checkArgument(
            _.isFunction(value),
            customMessage,
            _withVarName(varName, ': expected a function, was: ' + value)
        );
    }

    function hasValue(value, varName, customMessage) {
        _checkArgument(
            value,
            customMessage,
            _withVarName(varName, ': expected a value')
        );
    }

    function _checkArgument(value, message, defaultMessage) {
        var actualMessage = message ? message : defaultMessage;
        if (!value) {
            throw new Error(actualMessage)
        }
    }

    function _withVarName(varName, msg) {
        return (varName || '[unspecified]') + msg;
    }

    return {
        checkArgument: _.partial(_checkArgument, _, _, ''),
        nonEmptyString: nonEmptyString,
        isFunction: isFunction,
        hasValue: hasValue
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/context.js' */
define('applinks/common/context', [
    'applinks/lib/console',
    'applinks/lib/window',
    'applinks/lib/wrm',
    'applinks/common/modules'
], function(
    console,
    window,
    WRM,
    ApplinksModules
) {
    var context = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-context'));

    return {
        currentUser: function() {
            return context.currentUser
        },

        /**
         * @returns {object} host application containing `id` and `type` properties
         */
        hostApplication: function() {
            return context.hostApplication
        },

        validateCurrentUser: function() {
            if (!this.currentUser()) {
                console.log('No user context, reloading the page to trigger redirect to the login screen');
                window.location.reload();
            }
        }
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/help-paths.js' */
define('applinks/common/help-paths', [
    'applinks/lib/console',
    'applinks/lib/wrm',
    'applinks/lib/lodash',
    'applinks/common/modules',
    'applinks/common/preconditions'
], function(
    console,
    WRM,
    _,
    ApplinksModules,
    Preconditions
) {
    // lazy-load help paths, facilitates unit-testing
    var allHelpPaths = _.memoize(function() {
        var helpPaths = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-help-paths'));
        if (!helpPaths.entries) {
            console.warn('Help paths not found, all help links are likely to be broken.');
        }
        return helpPaths.entries || {};
    });

    var getPath = function(key, sectionKey) {
        Preconditions.nonEmptyString(key, 'key');
        var path = allHelpPaths()[key] || key;
        if (sectionKey) {
            Preconditions.nonEmptyString(sectionKey, 'sectionKey');
            var prefix = path.replace(/\+/g, ''); // "g" flag to remove _all_ '+' signs
            path += '#' +prefix + '-' + sectionKey;
        }
        return path;
    };

    function endsWith(string, suffix) {
        return string.indexOf(suffix, string.length - suffix.length) !== -1;
    }

    function addSuffixIfRequired(string, suffix) {
        return endsWith(string, suffix) ? string : string + suffix;
    }

    return {
        /**
         * @param key {string} key to get the path for
         * @returns {string} relative help path that can be appended to any relevant docs base URL
         */
        getPath: getPath,

        /**
         * @param key {string} key to get the path for
         * @param sectionKey {string} optional key of the anchor on the target page
         * @returns {string} full help path including the base URL
         */
        getFullPath: function(key, sectionKey) {
            var baseUrl = this.baseUrl();
            return addSuffixIfRequired(baseUrl, '/') + this.getPath(key, sectionKey);
        },

        /**
         * @returns {string} configured base URL for the help paths
         */
        baseUrl: _.partial(getPath, 'applinks.docs.root')
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/events.js' */
define('applinks/common/events', function() {

    var PREFIX = 'applinks.event.';

    return {
        PREREADY: PREFIX + 'preready',
        READY: PREFIX + 'ready',

        /**
         * Raised when applinks list is first loaded
         */
        APPLINKS_LOADED: PREFIX + 'loaded',
        /**
         * Raised when applinks list is updated
         */
        APPLINKS_UPDATED: PREFIX + 'updated',

        /**
         * This event is only raised when linking to Atlassian applications
         * Can be consumed by other plugins
         */
        NEW_APPLINK_CREATED: PREFIX + 'created',

        // legacy events
        Legacy: {
            MESSAGE_BOX_DISPLAYED: PREFIX + 'message-box-displayed'
        }
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/initializer.js' */
define('applinks/common/initializer', [
    'applinks/lib/jquery',
    'applinks/lib/lodash'
], function(
    $,
    _
) {
    function _callInitCallback(module) {
        if (module && _.isFunction(module.init)) {
            module.init();
        }
        if (module && _.isFunction(module.initialize)) {
            module.initialize();
        }
    }

    return {

        /**
         * Init `module`. If the module contains an `init` or `initialize` function, it will be called immediately
         * If both functions are present, both will be called.
         *
         * @param module {object} module to initialize
         */
        init: function(module) {
            _callInitCallback(module);
        },

        /**
         * Init `module` on DOM ready. If the module contains an `init` or `initialize` function, it will be called
         * on DOM ready event. Those functions should contain code that performs UI initialization dependent on the
         * state of the DOM. If both functions are present, both will be called.
         *
         * @param module {object} module to initialize
         */
        initOnDomReady: function(module) {
            $(document).ready(function() {
                _callInitCallback(module);
            });
        }
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/modules.js' */
/**
 * Applinks plugin modules core constants and definitions.
 */
define('applinks/common/modules', function() {
    return {
        /**
         * Applinks plugin key
         */
        PLUGIN_KEY: 'com.atlassian.applinks.applinks-plugin',

        /**
         * Fully qualifies a module name using the plugin key.
         *
         * @param {string} moduleName module name to qualify
         * @returns {string} fully qualified name
         */
        fqn: function(moduleName) {
            return this.PLUGIN_KEY + ':' + moduleName;
        },

        /**
         * Fully qualifies web-resource data using module name and data key.
         *
         * @param {string} moduleName module name
         * @param {string} dataKey key of the data element
         * @returns {string} fully qualified name
         */
        dataFqn: function(moduleName, dataKey) {
            return this.fqn(moduleName) + '.' + dataKey;
        }
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/features.js' */
define('applinks/common/features', [
    'applinks/lib/wrm',
    'applinks/lib/lodash',
    'applinks/common/modules',
    'applinks/common/context',
    'applinks/common/rest'
], function(
    WRM,
    _,
    ApplinksModules,
    ApplinksContext,
    ApplinksRest
) {
    var enabledFeatures, discoveredFeatures;

    function _getEnabledFeatures() {
        if (_.isUndefined(enabledFeatures)) {
            enabledFeatures = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-features'));
        }
        return enabledFeatures;
    }

    function _getDiscoveredFeatures() {
        if (_.isUndefined(discoveredFeatures)) {
            discoveredFeatures = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-discovered-features'));
        }
        return discoveredFeatures;
    }

    function isDiscovered(featureKey) {
        return _.contains(_getDiscoveredFeatures(), featureKey.toLowerCase());
    }

    function addEnabledFeatures(features) {
        _.extend(_getEnabledFeatures(), features);
    }

    function addDiscoveredFeatures(featureKeys) {
        featureKeys.forEach(function(featureKey){
            if (!isDiscovered(featureKey)) {
                _getDiscoveredFeatures().push(featureKey.toLowerCase());
            }
        });
    }

    /**
     * Allows to query for, enable and discover Applinks features.
     */
    return {

        BITBUCKET_REBRAND: 'BITBUCKET_REBRAND',
        V3_UI_OPT_IN: 'V3_UI_OPT_IN',
        V3_UI: 'V3_UI',

        /**
         * @returns {Object.<string, Object>} all enabled features mapped by key
         */
        getEnabledFeatures: function() {
            return _getEnabledFeatures();
        },

        isEnabled: function(featureName) {
            return this.getEnabledFeatures()[featureName];
        },

        /**
         * Disable `featureName`, requires user context and admin permissions.
         *
         * @param featureName {string} feature name to enable
         * @return the request promise to hook callbacks to
         */
        disable: function(featureName) {
            ApplinksContext.validateCurrentUser();
            return ApplinksRest.V3.features(featureName).del()
                .done(function() {
                    _getEnabledFeatures()[featureName] = false;
                });
        },

        /**
         * Enable `featureName`, requires user context and admin permissions.
         *
         * @param featureName {string} feature name to enable
         * @return the request promise to hook callbacks to
         */
        enable: function(featureName) {
            ApplinksContext.validateCurrentUser();
            return ApplinksRest.V3.features(featureName).put()
                .done(function(feature) {
                    addEnabledFeatures(feature);
                });
        },

        /**
         * @returns {string[]} an array of discovered feature keys
         */
        getDiscoveredFeatures: function() {
            return _getDiscoveredFeatures();
        },

        isDiscovered: isDiscovered,

        /**
         * Discover `featureKey`, requires user context.
         *
         * @param featureKey {string} key to discover
         */
        discover: function(featureKey) {
            ApplinksContext.validateCurrentUser();
            ApplinksRest.V3.featureDiscovery(featureKey).put()
                .fail(function(req) {
                    throw 'Feature discovery request failed: ' + req.status + ': ' + req.responseText;
                }).done(function(featureKey) {
                    addDiscoveredFeatures(featureKey);
                });
        }
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/products.js' */
define('applinks/common/products', [
    'applinks/lib/window'
], function(Window) {

    function getTypeName(typeId) {
        // Note: window.appLinksI18n.entries is injected into the page by common_header.vm
        return Window.appLinksI18n.entries['applinks.application.type.'+typeId];
    }

    /**
     * Map of Atlassian product keys to application type IDs
     */
    return {
        BAMBOO: 'bamboo',
        BITBUCKET: 'stash', // special case, see java class com.atlassian.applinks.application.bitbucket.BitbucketApplicationTypeImpl.TYPE_ID
        CONFLUENCE: 'confluence',
        FECRU: 'fecru',
        JIRA: 'jira',
        REFAPP: 'refapp',
        STASH: 'stash',
        getTypeName: getTypeName
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/response-status.js' */
define('applinks/common/response-status', [
    'applinks/lib/lodash'
], function(
    _
) {

    function StatusFamily(familyCode) {
        this.familyCode = familyCode;
    }

    StatusFamily.prototype.matches = function(code) {
        return Math.floor(_getStatusCode(code) / 100) == this.familyCode;
    };

    var StatusFamilies = {
        INFORMATIONAL: new StatusFamily(1),
        SUCCESSFUL: new StatusFamily(2),
        REDIRECTION: new StatusFamily(3),
        CLIENT_ERROR: new StatusFamily(4),
        SERVER_ERROR: new StatusFamily(5),

        forCode: function(code) {
            return _.find(StatusFamilies.all(), function(family) {
                return family.matches(code);
            });
        },

        all: function() {
            return [
                StatusFamilies.INFORMATIONAL,
                StatusFamilies.SUCCESSFUL,
                StatusFamilies.REDIRECTION,
                StatusFamilies.CLIENT_ERROR,
                StatusFamilies.SERVER_ERROR
            ];
        }
    };

    function ResponseStatus(code) {
        this.code = code;
        this.family = StatusFamilies.forCode(code);
    }

    ResponseStatus.prototype.matches = function(code) {
        return _getStatusCode(code) == this.code;
    };

    function _getStatusCode(object) {
        if (object && object.status && _.isNumber(object.status)) {
            return object.status;
        } else if (_.isNumber(object)) {
            return object;
        } else {
            return 0;
        }
    }

    return {
        OK: new ResponseStatus(200),
        CREATED: new ResponseStatus(201),

        BAD_REQUEST: new ResponseStatus(400),
        UNAUTHORIZED: new ResponseStatus(401),
        FORBIDDEN: new ResponseStatus(403),
        NOT_FOUND: new ResponseStatus(404),
        CONFLICT: new ResponseStatus(409),

        Family: StatusFamilies
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/rest-request.js' */
define('applinks/common/rest-request', [
    'applinks/lib/console',
    'applinks/lib/window',
    'applinks/lib/jquery',
    'applinks/lib/lodash',
    'applinks/common/preconditions',
    'applinks/common/response-status'
], function(
    console,
    window,
    $,
    _,
    Preconditions,
    ResponseStatus
) {
    var defaultRequestSettings = {
        dataType: 'json',
        contentType: 'application/json'
    };

    // construct the target URL by adding query params
    function _toUrl(url, queryParams) {
        if (_.isEmpty(queryParams)) {
            return url;
        }
        var separator = url.indexOf('?') > -1 ? '&' : '?';
        return url + separator + $.param(queryParams);
    }

    // create default success and error handlers to ensure we got an expected status
    function _defaultSuccessHandler(statuses) {
        return function(data, textStatus, request) {
            if (!_.some(statuses, function(status) { return status.matches(request) })) {
                console.error('Unexpected response status: ' + request.status + ': ' + request.responseText);
            }
        }
    }

    function _defaultErrorHandler(statuses) {
        return function(request, textStatus, error) {
            if (!_.some(statuses, function(status) { return status.matches(request) })) {
                console.error('Unexpected response status: ' + request.status + ': ' + request.responseText);
                // force re-login if UNAUTHORIZED
                if (ResponseStatus.UNAUTHORIZED.matches(request)) {
                    window.location.reload();
                }
            }
        }
    }

    /**
     * Creates a new instance of `ApplinksRestRequest`.
     *
     * @param url URL to request to. NOTE: URLs with fragments (`#`) are not supported
     * @param params query parameters to add to the request URL
     * @constructor
     */
    function ApplinksRestRequest(url, params) {
        Preconditions.nonEmptyString(url, 'url');
        Preconditions.checkArgument(url.indexOf('#') == -1, 'url: "#" fragments not supported');
        this._url = url;
        this._queryParams = _.extend({}, params);
        this._expectedStatus = [ResponseStatus.Family.SUCCESSFUL];
    }

    ApplinksRestRequest.GET = 'GET';
    ApplinksRestRequest.PUT = 'PUT';
    ApplinksRestRequest.POST = 'POST';
    ApplinksRestRequest.DELETE = 'DELETE';

    ApplinksRestRequest.prototype.get = function() {
        return this._execute(this._requestSettings(ApplinksRestRequest.GET));
    };

    ApplinksRestRequest.prototype.del = function() {
        return this._execute(this._requestSettings(ApplinksRestRequest.DELETE));
    };

    ApplinksRestRequest.prototype.put = function(data) {
        var settings = this._requestSettings(ApplinksRestRequest.PUT);
        if (data) {
            settings.data = data;
        }
        return this._execute(settings);
    };

    ApplinksRestRequest.prototype.post = function(data) {
        var settings = this._requestSettings(ApplinksRestRequest.POST);
        if (data) {
            settings.data = data;
        }
        return this._execute(settings);
    };

    /**
     * Add query param to this request.
     *
     * @param {string} name param name
     * @param {string} value param value
     * @return {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.queryParam = function(name, value) {
        this._queryParams[name] = value;
        return this;
    };

    /**
     * Add query params to this request.
     *
     * @param {Object} params params map to add
     * @returns {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.queryParams = function(params) {
        this._queryParams = _.extend(this._queryParams, params);
        return this;
    };

    /**
     * Add `authorisationCallback` query parameter to this request, this is useful for resources that are expected to
     * respond with `authorisationUri`
     *
     * @param {string} callback URI to call back once authorisation is done
     * @return {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.authorisationCallback = function(callback) {
        this.queryParam('authorisationCallback', callback);
        return this;
    };

    /**
     * Expect a specific status (or status family). Use a specific number or one of the members defined in
     * `applinks/common/response-status`. By default a successful 20x response is expected. If the response does not
     * meet this expectation, a default error handler will be invoked.
     *
     * Invoke this method with any number of of statuses expressed as an object that contains `matches` method (using
     * the ones in `applinks/lib/response-status` is highly recommended).
     * @returns {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.expectStatus = function() {
        this._expectedStatus = _.isArray(arguments[0]) ? arguments[0] : _.toArray(arguments);
        return this;
    };

    ApplinksRestRequest.prototype._requestSettings = function(requestType) {
        var that = this;
        return _.defaults({
            url: _toUrl(that._url, that._queryParams),
            type: requestType
        }, defaultRequestSettings);
    };

    ApplinksRestRequest.prototype._execute = function(settings) {
        return $.ajax(settings)
            .done(_defaultSuccessHandler(this._expectedStatus))
            .fail(_defaultErrorHandler(this._expectedStatus));
    };

    return ApplinksRestRequest;
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/rest.js' */
define('applinks/common/rest', [
    'applinks/lib/aui',
    'applinks/common/preconditions',
    'applinks/common/rest-request',
    'applinks/common/rest-oauth'
], function(
    AJS,
    Preconditions,
    ApplinksRestRequest,
    ApplinksOAuthRest
) {
    function ApplinksRestModule(version) {
        Preconditions.hasValue(version, 'version');
        this._version = version;
    }

    ApplinksRestModule.prototype.baseUrl = function() {
        return AJS.contextPath() + '/rest/applinks/' + this._version;
    };

    ApplinksRestModule.prototype.withPath = function(path) {
        return this.baseUrl() + '/' + path;
    };

    function ApplinksV1RestModule() {
        this.module = new ApplinksRestModule('1.0');
    }

    function ApplinksV2RestModule() {
        this.module = new ApplinksRestModule('2.0');
    }

    function ApplinksV3RestModule() {
        this.module = new ApplinksRestModule('3.0');
    }

    ApplinksV3RestModule.prototype.featureDiscovery = function(featureKey) {
        if (!featureKey) {
            throw 'feature key not defined';
        }
        return new ApplinksRestRequest(this.module.withPath('feature-discovery/' + featureKey));
    };

    ApplinksV3RestModule.prototype.features = function(featureName) {
        if (!featureName) {
            throw 'feature name not defined';
        }
        return new ApplinksRestRequest(this.module.withPath('features/' + featureName));
    };

    ApplinksV3RestModule.prototype.status = function(applinkId) {
        if (!applinkId) {
            throw 'applinkId not defined';
        }
        return new ApplinksRestRequest(this.module.withPath('status/' + applinkId));
    };

    return {
        V1: new ApplinksV1RestModule(),
        V2: new ApplinksV2RestModule(),
        V3: new ApplinksV3RestModule(),
        OAuth: ApplinksOAuthRest
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/rest-oauth.js' */
define('applinks/common/rest-oauth', [
    'applinks/lib/aui',
    'applinks/common/rest-request',
    'applinks/common/preconditions'
], function(
    AJS,
    ApplinksRestRequest,
    Preconditions
) {
    function ApplinksOAuthRestModule(version) {
        Preconditions.hasValue(version, 'version');
        this.baseUrl =  AJS.contextPath() + '/rest/applinks-oauth/' + version + '/';
    }

    ApplinksOAuthRestModule.prototype._withPath = function(path) {
        return this.baseUrl + path;
    };

    function ApplinksOAuthV1RestModule() {
        this.module = new ApplinksOAuthRestModule('1.0');
    }

    ApplinksOAuthV1RestModule.prototype.consumerToken = function(applinkId) {
        Preconditions.hasValue(applinkId, 'applinkId');
        return new ApplinksRestRequest(this.module._withPath('consumer-token/' + applinkId));
    };

    return {
        V1: new ApplinksOAuthV1RestModule()
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/i18n.js' */
define('applinks/common/i18n', [
    'applinks/lib/jquery',
    'applinks/lib/aui'
], function(
    $,
    AJS
) {
    function init() {
        // set up I18n for dynamical calls on client side, remember to use " for AJS.I18n.getText
        // Please make sure that AbstractApplinksServlet.java has put the appLinksI18n.entries correctly on the page
        AJS.I18n.keys = AJS.I18n.keys || {};
        $.extend(AJS.I18n.keys, appLinksI18n.entries);
    }

    return {
        init: init
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'js/fecru-compatibility.js' */
if (jQuery != undefined && AJS != undefined) jQuery = AJS.$; // make sure we're extending the correct jQuery;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/common/rest-service.js' */
/**
 * The triggering of AppLinks initialisation can be customised by setting a function on
 * AJS.AppLinksInitialisationBinder. The binder function should take a single argument which is a zero-arg function to
 * run and should execute this function when appropriate.
 */
AppLinks = AJS.$.extend(window.AppLinks || {}, {
    Event: {
        NAMESPACE: "applinks"
    }
});
var ApplinksEvents = require('applinks/common/events');
AppLinks.Event = AJS.$.extend(window.AppLinks.Event, ApplinksEvents);

// Is there an overridden initialisation binder?
if (AJS.AppLinksInitialisationBinder) {
    AppLinks.initialisationBinder = AJS.AppLinksInitialisationBinder;
} else {
    // The default bind if no specific binder is specified
    AppLinks.initialisationBinder = function(f) {
        AJS.toInit(f);
    }
}

AppLinks.initialisationBinder(function() {
    //$ is passed in by AJS.toInit but initilizationBinder can be over loaded by products so that $ is unsafe.
    var $ = AJS.$;
    AppLinks = $.extend(window.AppLinks || {}, {
        failure: function(data) {
            if (data.status == 401) {
                window.location.reload();
            } else {
                var message = AppLinks.parseError(data);
                var errorDivs = $('.page-error');

                if (errorDivs.length > 0) {
                    errorDivs.html(message).fadeIn('slow');
                }
                else {
                    alert("REST request failed: " + message);
                }
            }
        },
        jsonRequest: function(url, type, data, success, error) {
            if (data) {
                data = JSON.stringify(data);
            }
            $(".page-error").fadeOut('fast');
            if (!error) error = AppLinks.failure;
            return jQuery.ajax({
                url: url,
                type: type,
                data: data,
                dataType: 'json',
                contentType: "application/json; charset=utf-8",
                cache: false,
                success: success,
                error: error
            });
        },
        xmlRequest: function(url, type, data, success, error) {
            if (data) {
                data = JSON.stringify(data);
            }
            $(".page-error").fadeOut('fast');
            if (!error) error = AppLinks.failure;
            return jQuery.ajax({
                url: url,
                type: type,
                data: data,
                dataType: 'xml',
                contentType: "application/xml; charset=utf-8",
                cache: false,
                success: success,
                error: error
            });
        },
        parseError: function(errorData) {
            var error;
            try {
                error = JSON.parse(errorData.responseText);
            } catch (e) {
                if (errorData.statusText) {
                    return error = errorData.statusText;
                } else {
                    return errorData;
                }
            }
            if (error.message) {
                if ($.isArray(error.message)) {
                    return error.message.join(' ');
                }
                return error.message;
            }
            else {
                return errorData.statusText;
            }
        },
        put: function(url, data, success, error) {
            return AppLinks.jsonRequest(url, 'PUT', data, success, error);
        },
        post: function(url, data, success, error) {
            return AppLinks.jsonRequest(url, 'POST', data, success, error);
        },
        update: function(data, success, error) {
            AppLinks.put(AppLinks.self_link(data), data, success, error);
        },
        get: function(url, success, error) {
            return AppLinks.jsonRequest(url, 'GET', null, success, error);
        },
        getXml: function(url, success, error) {
            return AppLinks.xmlRequest(url, 'GET', null, success, error);
        },
        self_link: function(item) {
            for (var i = 0, _i = item.link.length; i < _i; i++) {
                var link = item.link[i];
                if (link.rel == "self") return link.href;
            }

            throw "No self-link found";
        },
        del: function(urlOrObject, success, error) {
            var url;
            if (typeof(urlOrObject) == 'string') url = urlOrObject;
            else url = AppLinks.self_link(urlOrObject);
            return AppLinks.jsonRequest(url, 'DELETE', null, success, error);
        },
        SPI: $.extend({}, {
            API_VERSION: "1.0",
            REST_RESOURCE_URL: AJS.contextPath() + "/rest/applinks/",
            BASE_URL: AJS.contextPath() + "/rest/applinks/1.0",
            OAUTH_REST_RESOURCE_URL: AJS.contextPath() + "/rest/applinks-oauth/",
            OAUTH_BASE_URL: AJS.contextPath() + "/rest/applinks-oauth/1.0",

            /**
             * Update the API version and associated urls.
             * @param version
             */
            setApiVersion: function(version){
                AppLinks.SPI.API_VERSION = version;
                AppLinks.SPI.setBaseUrl(AppLinks.SPI.REST_RESOURCE_URL + AppLinks.SPI.API_VERSION);
            },
            setBaseUrl: function(url){
                AppLinks.SPI.BASE_URL = url;
            },
            setOAuthBaseUrl: function(url){
                AppLinks.SPI.OAUTH_BASE_URL = url;
            },
            /**
             * Build a base URL for rest calls using the specified baseUrl.
             * @param baseUrl
             * @returns {string}
             */
            getRemoteRestBaseUrl: function(baseUrl) {
                return baseUrl + "/rest/applinks/" + AppLinks.SPI.API_VERSION;
            },
            /**
             * Build a base URL for plugin servlet calls using the specified baseUrl.
             * @param baseUrl
             * @returns {string}
             */
            getRemotePluginServletBaseUrl: function(baseUrl) {
                return baseUrl + "/plugins/servlet";
            },
            getAllLinks: function(success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink";
                return AppLinks.get(url, success, failure);
            },
            getAllLinksWithAuthInfo: function(success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/listApplicationlinks";
                return AppLinks.get(url, success, failure);
            },
            getApplicationLinkState: function(id, success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/listApplicationlinkstates/id/" + id;
                return AppLinks.get(url, success, failure);
            },
            getLinksOfType: function(typeId, success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink/type/" + typeId;
                return AppLinks.get(url, success, failure);
            },
            tryToFetchManifest: function(url, success, failure) {
                var restUrl = AppLinks.SPI.BASE_URL + '/applicationlinkForm/manifest.json?url=' + encodeURIComponent(url);
                return AppLinks.get(restUrl, success, failure);
            },
            getManifestFor: function(id, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/manifest/' + id + ".json";
                return AppLinks.get(url, success, failure);
            },
            getLocalManifest: function(success, failure){
                var url = AppLinks.SPI.BASE_URL + '/manifest.json';
                return AppLinks.get(url, success, failure);
            },
            /**
             * Attempt to get the Manifest of the remote application, via a direct REST call.
             * Requires CORS enabled on the REST resource.
             * @param url
             * @param success
             * @param failure
             * @returns {*}
             */
            getRemoteManifest: function(remoteBaseUrl, success, failure){
                var remoteManifestUrl = AppLinks.SPI.getRemoteRestBaseUrl(remoteBaseUrl) + '/manifest.json';
                return AppLinks.get(remoteManifestUrl, success, failure);
            },
            /**
             * Attempt to get the OAuth Consumer Info of the remote application, via a direct call.
             * Requires CORS enabled on the REST resource.
             * @param url
             * @param success
             * @param failure
             * @returns {*}
             */
            getRemoteOAuthConsumerInfo: function(remoteBaseUrl, success, failure){
                var remoteManifestUrl = AppLinks.SPI.getRemotePluginServletBaseUrl(remoteBaseUrl) + '/oauth/consumer-info';
                return AppLinks.getXml(remoteManifestUrl, success, failure);
            },
            getApplinkStatus: function (applinkId, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/status/' + applinkId;
                return AppLinks.get(url, success, failure);
            },
            createStaticUrlAppLink: function(applicationType, success, failure) {
                var restUrl = AppLinks.SPI.BASE_URL + '/applicationlinkForm/createStaticUrlAppLink?typeId=' + applicationType;
                return AppLinks.post(restUrl, null, success, failure);
            },
            createLink: function(applicationLink, username, password, createTwoWayLink, customRpcUrl, rpcUrl, configFormValues, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlinkForm/createAppLink';
                var data = {
                    applicationLink: applicationLink,
                    username: username,
                    password: password,
                    createTwoWayLink: createTwoWayLink,
                    customRpcURL: customRpcUrl,
                    rpcUrl: rpcUrl,
                    configFormValues: configFormValues
                };
                return AppLinks.post(url, data, success, failure);
            },
            createLinkWithOrphanedTrust : function(applicationLink, username, password, createTwoWayLink, customRpcUrl, rpcUrl, configFormValues, orphanedTrust, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlinkForm/createAppLink';
                var data = {
                    applicationLink: applicationLink,
                    username: username,
                    password: password,
                    createTwoWayLink: createTwoWayLink,
                    customRpcURL: customRpcUrl,
                    rpcUrl: rpcUrl,
                    configFormValues: configFormValues,
                    orphanedTrust: orphanedTrust
                };
                return AppLinks.post(url, data, success, failure);
            },
            verifyTwoWayLinkDetails : function (remoteUrl, rpcUrl, username, password, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlinkForm/details';
                var data = {
                    username: username,
                    password: password,
                    remoteUrl: remoteUrl,
                    rpcUrl: rpcUrl
                };
                return AppLinks.post(url, data, success, failure);
            },
            getApplicationLinkInfo: function (appId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlinkInfo/id/" + appId;
                return AppLinks.get(url, success, error);
            },
            deleteLink: function(applicationLink, reciprocate, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink/" + applicationLink.id;
                if (reciprocate) url += "?reciprocate=true";
                return AppLinks.del(url, success, error);
            },
            makePrimary: function(applicationLink, success) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink/primary/" + applicationLink.id;
                return AppLinks.post(url, null, success);
            },
            relocate: function(applicationLink, newUrl, suppressWarnings, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/relocateApplicationlink/" + applicationLink.id + "?newUrl=" + encodeURIComponent(newUrl) +
                        "&nowarning=" + (suppressWarnings ? "true" : "false");
                return AppLinks.post(url, null, success, error);
            },
            legacyUpgrade: function(applicationLink, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/upgrade/legacy/" + applicationLink.id;
                return AppLinks.post(url, null, success, error);
            },
            ualUpgrade: function(applicationLink, body, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/upgrade/ual/" + applicationLink.id;
                return AppLinks.post(url, body, success, error);
            },
            getEntityTypesForApplicationType: function(applicationType, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/type/entity/" + applicationType;
                return AppLinks.get(url, success, error);
            },
            getLocalEntitiesWithLinksToApplication: function(applicationLinkId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/localEntitiesWithLinksTo/" + applicationLinkId + ".json";
                return AppLinks.get(url, success, error);
            },
            getEntityLinksForApplication: function(applicationLinkId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entities/" + applicationLinkId + ".json";
                AppLinks.get(url, success, error);
            },
            getEntityLinksForApplicationUsingAnonymousAccess: function(applicationLinkId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entities/anonymous/" + applicationLinkId + ".json";
                return AppLinks.get(url, success, error);
            },
            createNonUalEntityLink: function(localType, localKey, applicationId, remoteTypeId, remoteKey, name, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/" + localType + "/" + localKey + "?reciprocate=false";
                var data = {
                    applicationId: applicationId,
                    typeId: remoteTypeId,
                    key: remoteKey,
                    name: name,
                    isPrimary: false
                };
                return AppLinks.put(url, data, success, error);
            },
            createEntityLink: function(localType, localKey, entity, reciprocate, success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/" + localType + "/" + localKey + "?reciprocate=";
                url += (reciprocate ? "true" : "false");
                return AppLinks.put(url, entity, success, failure);
            },
            getConfiguredEntityLinks: function(localType, localKey, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/primaryLinks/" + localType + "/" + localKey + ".json";
                return AppLinks.get(url, success, error);
            },
            deleteEntityLink: function(localTypeId, localKey, entity, reciprocate, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/" + localTypeId + "/" + localKey + "?typeId=" + entity.typeId + "&key=" + entity.key + "&applicationId=" + entity.applicationId + "&reciprocate=" + reciprocate;
                return AppLinks.del(url, success, error);
            },
            makePrimaryEntityLink: function(localTypeID, localKey, entity, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/primary/" + localTypeID + "/" + localKey + "?typeId=" + entity.typeId + "&key=" + entity.key + "&applicationId=" + entity.applicationId;
                return AppLinks.post(url, null, success, error);
            },
            canDeleteAppLink: function(applicationId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/permission/reciprocate-application-delete/" + applicationId;
                return AppLinks.get(url, success, error);
            },
            canDeleteEntityLink: function(localTypeId, localKey, entity, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/permission/reciprocate-entity-delete/" + entity.applicationId + "/" + localTypeId + "/" + localKey + "/" + entity.typeId + "/" + entity.key;
                return AppLinks.get(url, success, error);
            },
            canCreateReciprocateEntityLink: function(applicationId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/permission/reciprocate-entity-create/" + applicationId;
                return AppLinks.get(url, success, error);
            },
            processPermissionCode: function(settings) {
                var config = {
                    noPermission: function() {},
                    missing: function() {},
                    credentialsRequired: function(authUrl) {},
                    authenticationFailed: function(authUrl) {},
                    noAuthentication: function(authUrl) {},
                    noAuthenticationConfigured: function() {},
                    noConnection: function() {},
                    allowed: function() {},
                    unrecognisedCode: function(code) {},
                    updateView: function(message, icon, button) {}
                };

                if (!settings) settings = {};

                settings = $.extend(config, settings);

                return function(data) {
                    var code = data.code;
                    if (code == "NO_PERMISSION") {
                        settings.noPermission();
                    } else if (code == "MISSING") {
                        settings.missing();
                    } else if (code == "CREDENTIALS_REQUIRED") {
                        settings.credentialsRequired(data.url);
                    } else if (code == "AUTHENTICATION_FAILED") {
                        settings.authenticationFailed(data.url);
                    } else if (code == "NO_AUTHENTICATION") {
                        settings.noAuthentication(data.url);
                    } else if (code == "NO_AUTHENTICATION_CONFIGURED") {
                        settings.noAuthenticationConfigured();
                    } else if (code == "NO_CONNECTION") {
                        settings.noConnection();
                    } else if (code == "ALLOWED") {
                        settings.allowed();
                    } else {
                        settings.unrecognisedCode(data.code);
                    }
                };
            },
            addAuthenticationTrigger: function(target, authUrl, callbacks) {
                if (!callbacks) {
                    callbacks = {};
                }

                if (typeof callbacks.onSuccess == "undefined") {
                    callbacks.onSuccess = function() {
                        location.reload();
                    }
                }

                if (typeof callbacks.onFailure == "undefined") {
                    callbacks.onFailure = function() {
                        return true;
                    }
                }
                //Unbind previous click listener, otherwise we might end up opening multiple windows.
                $(target).unbind('click');
                $(target).click(function() {
                    if (callbacks.before) {
                        callbacks.before();
                    }
                    AppLinks.authenticateRemoteCredentials(authUrl, callbacks.onSuccess, callbacks.onFailure);
                });
            },
            deleteOrphanedTrust: function(id, type, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/orphaned-trust/" + type + "/" + id;
                return AppLinks.del(url, success, error);
            },
            getOrphanedTrust: function(success, error) {
                var url = AppLinks.SPI.BASE_URL + "/orphaned-trust/";
                return AppLinks.get(url, success, error);
            },
            showCreateEntityLinkSuggestion: function() {
                return true;
            },
            getApplicationLink: function(id, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlink/' + id;
                return AppLinks.get(url, success, failure);
            },
            createApplicationLink: function(id, name, rpcUrl, displayUrl, typeId, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlink';
                var data = {
                    id: id,
                    name: name,
                    rpcUrl: rpcUrl,
                    displayUrl: displayUrl,
                    typeId: typeId
                };
                return AppLinks.put(url, data, success, failure);
            },
// TODO APLDEV-3 extract OAuth creation code into OAuth specific js files in the Oauth plugin.
            createConsumer: function(id, key, name, description, sharedSecret, publicKey, twoLOAllowed, executingTwoLOUser, twoLOImpersonationAllowed, outgoing, success, failure) {
                var url = AppLinks.SPI.OAUTH_BASE_URL + '/applicationlink/' + id + '/authentication/consumer';
                var data = {
                    key: key,
                    name: name,
                    description: description,
                    sharedSecret: sharedSecret,
                    publicKey: publicKey,
                    outgoing: outgoing,
                    twoLOAllowed: twoLOAllowed,
                    executingTwoLOUser: executingTwoLOUser,
                    twoLOImpersonationAllowed: twoLOImpersonationAllowed
                };
                return AppLinks.put(url, data, success, failure);
            },
            createConsumerAutoConfigure: function(id, twoLOAllowed, executingTwoLOUser, twoLOImpersonationAllowed, success, failure) {
                var url = AppLinks.SPI.OAUTH_BASE_URL + '/applicationlink/' + id + '/authentication/consumer?autoConfigure=true';
                var data = {
                    twoLOAllowed: twoLOAllowed,
                    executingTwoLOUser: executingTwoLOUser,
                    twoLOImpersonationAllowed: twoLOImpersonationAllowed
                };
                return AppLinks.put(url, data, success, failure);
            },
            registerProvider: function(id, provider, config, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlink/' + id + '/authentication/provider';
                var data = {
                    config : config,
                    provider : provider
                };
                return AppLinks.put(url, data, success, failure);
            },
            enableFeature: function(featureName, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/features/' + featureName;
                return AppLinks.put(url, {}, success, failure);
            },
            disableFeature: function(featureName, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/features/' + featureName;
                return AppLinks.del(url, success, failure);
            }
        }, (window.AppLinks && window.AppLinks.SPI) || {})
    });

    var i18nRootKey = 'applinks';

    AppLinks.UI = {
        showInfoBox: function(message) {
            $('.aui-message.success').remove();
            AppLinks.UI.createMessage('success', message, 'page-info');
        },
        hideInfoBox: function() {
            $('.aui-message.success').remove();
        },
        showErrorBox: function(message) {
            AppLinks.UI.createMessage('error', message, 'page-error');
        },
        hideErrorBox: function() {
            $('.aui-message.error').remove();
        },
        showWarningBox: function(messages) {
            if ($.isArray(messages) && messages.length > 0) {
                var ulEl = $("<ul></ul>");
                $(messages).each(function(index) {
                    ulEl.append($("<li/>", {
                        text: messages[index]
                    }));
                });
                var messageEl = $('<div class="page-warning"></div>').append(ulEl);
                AppLinks.UI.createMessage('warning', messageEl.html(), 'page-warning');
            } else {
                AppLinks.UI.createMessage('warning', messages, 'page-warning');
            }
        },
        hideWarningBox: function() {
            $('.aui-message.warning').remove();
        },
        shortenString: function(message, maxLength) {
            if (message.length  > maxLength) {
               message = message.substring(0, maxLength) + "...";
            }
            return message;
        },
        createMessage: function(type, message, cssClass) {
            var messageEl = $('<div class="' + cssClass + '">');
            messageEl.html(message);
            AJS.messages[type](".applinks-message-bar", {
                title: "",
                body: messageEl.wrap('<div></div>').parent().html(),
                closeable: true
            });
            $(document).trigger(AppLinks.Event.Legacy.MESSAGE_BOX_DISPLAYED);
        },
        displayValidationErrorMessages: function (errorClass, rootEl, messages) {
            if ($.isArray(messages)) {
                $(messages).each(function(i,v) {
                   var d = $('<div class="error applinks-error">');
                   d.text(v);
                   $(rootEl).find("." + errorClass).append(d);
                });
            } else if(typeof messages != 'undefined'){
                var d = $('<div class="error applinks-error">');
                d.text(messages.toString());
                $(rootEl).find("." + errorClass).append(d);
            }
        },
        displayValidationError: function(errorClass, rootEl, errorFn) {
            return function(xhr) {
                if (xhr.status == 401) {
                    window.location.reload();
                    return;
                }

                $('.applinks-error').remove();
                $('.loading').remove();
                var respJSON = xhr.responseText;
                var respObj = $.parseJSON(respJSON);
                var messages = respObj.message;
                if (typeof respObj.fields == "undefined") {
                    AppLinks.UI.displayValidationErrorMessages(errorClass, rootEl, messages);
                } else {
                    var fields = respObj.fields;
                    $(fields).each(function(index) {
                        var d = $('<div class="error applinks-error" id="' + fields[index] + '-error">');
                        d.text(messages[index]);
                        if ($(rootEl).find('.' + fields[index]).length > 0) {
                          d.insertAfter($(rootEl).find('.' + fields[index]));
                        } else {
                          d.insertAfter($(rootEl).find('.' + errorClass).append(d));
                        }
                    });
                }
                $(rootEl).find('.' + errorClass).addClass("fully-populated-errors");
                if (errorFn) {
                 errorFn();
                }
            }
        },
        addProtocolToURL : function(url) {
            var newUrl = $.trim(url);
            var tempURL = newUrl.toLowerCase();
            var hasProtocol = false;
            if (tempURL.length >= 7) {
                if (tempURL.substring(0,7).indexOf('http') != -1) {
                    hasProtocol = true;
                }
            }
            //default protocol is http
            if (!hasProtocol) {
                newUrl = 'http://' + newUrl;
            }
            return newUrl;
        },
        /**
         * Similar to the standard Javascript join() method, but nicer in that
         * it uses a different delimiter for the last node (by default "and"),
         * so that:
         * {code}
         * "1, 2 and 3" == prettyJoin(['1', '2', '3'], function(value) {return value;});
         * {code}
         *
         * @param inputArray
         * @param resolveFn
         * @param finalDelimiter
         */
        prettyJoin : function(inputArray, resolveFn, finalDelimiter) {
            if (!finalDelimiter) {
                finalDelimiter = AppLinks.I18n.getText('applinks.and');
            }
            var maxLength = inputArray.length;
            var message = "";
            $.each(inputArray, function(index, value) {
                if (index == (maxLength - 1) && maxLength > 1) {
                  message += " " + finalDelimiter + "  " + resolveFn(value);
                } else {
                  message += resolveFn(value);
                  if (index + 2 < maxLength) {
                      message += ", ";
                  }
                }
            });
            return message;
        },
        showLoadingIcon: function(element) {
            $('<span class="loading">&nbsp;</span>').insertAfter(element);
        },
        hideLoadingIcon: function(element) {
            $(element).next('.loading').remove();
        },
        findUrl: function(text) {
            var url = undefined;
            var lcText = text.toLowerCase();
            var startOfUrl = lcText.indexOf('http:');
            if (startOfUrl == -1) {
                startOfUrl = lcText.indexOf('https:');
            }
            if (startOfUrl > -1) {
                var endOfUrl = lcText.indexOf(' ', startOfUrl);
                if (endOfUrl == -1) {
                    endOfUrl = lcText.length;
                }
                url = text.substring(startOfUrl, endOfUrl); // use _case-sensitive_ version to retrieve the actual URL
            }
            return url;
        },
        findApplicationType : function(id) {
            id = id.toLowerCase();
            if (id.indexOf("jira") != -1) {
                return "jira";
            } else if (id.indexOf("fisheye") != -1) {
                return "fecru";
            } else if (id.indexOf("confluence") != -1) {
                return "confluence";
            } else if (id.indexOf("refapp") != -1) {
                return "refapp";
            } else {
                return undefined;
            }
        },
        escapeSelector: function(selector) {
            // based on http://samuelsjoberg.com/archive/2009/09/escape-jquery-selectors
            return selector.replace(/([#;&,\.\+\*\~':"\!\^$\[\]\(\)=>\|])/g, "\\$1");
        },
        sanitiseHTML: function(input) {
            var replacements = {
                "<": "&lt;",
                '"': "&quot;",
                "&": "&amp;"
            };
            return input.replace(/[<"&]/g, function(match) {
                return replacements[match];
            });
        },
        refreshOrphanedTrust: function() {
            // post dialog -- check whether we need to remove any orphaned-trust entries
            var updateOrphanedTrust = function(data) {
                $("tr.orphaned-trust-row").each(function() {
                    var $this = $(this);
                    var id = $this.attr("data-id");
                    var type = $this.attr("data-type");
                    var stillExists = false;
                    for (var i = 0; i < data.orphanedTrust.length; i++) {
                        var ot = data.orphanedTrust[i];
                        if (id == ot.id && type == ot.type) {
                            stillExists = true;
                            break;
                        }
                    }
                    if (!stillExists) {
                        $this.remove();
                        if (data.orphanedTrust.length == 0) {
                            // we just removed the last orphaned trust cert, hide warning!
                            $(".orphaned-trust-warning").hide();
                        }
                    }
                });
            };

            AppLinks.SPI.getOrphanedTrust(updateOrphanedTrust);
        },
        removeCssClass: function(element, prefix) {
            $(element).removeClass( function(index, className) {
                   var classes = className.split(' ');
                   var classToRemove = "";
                   $.each(classes, function(index, value) {
                       if (value.indexOf(prefix) != -1) {
                           classToRemove = value;
                       }
                   });
                   return classToRemove;
            } );
        }
    };

    /**
     * Add jQuery event system to AppLinks.UI namespace.
     */
    (function(){
        var eventBus = $({});
        $.each(['bind', 'unbind', 'trigger'], function(i, current){
            AppLinks.UI[current] = function(){
                return eventBus[current].apply(eventBus, arguments);
            }
        });
    })();

    AppLinks.I18n = {
        // very simple i18n param interpolation, doesn't attempt to respect escaping
        //Deferrs to AJS.format for for legacy reason the array conversion needs to stick around.
        interpolate: function(text, params) {
            if (params) {
                if (!$.isArray(params)) {
                    // single arg
                    params = [new String(params)];
                }
                params.unshift(text);
                text = AJS.format.apply(AJS, params);
            }
            return text;
        },
        getTextWithPrefix: function(key, params) {
            return AppLinks.I18n.interpolate(appLinksI18n.entries[i18nRootKey + "." + key], params);
        },
        getText: function(key, params) {
            return AppLinks.I18n.interpolate(AppLinks.I18n.resolveValue(key), params);
        },
        getApplicationTypeName: function(typeId) {
            return appLinksI18n.entries["applinks.application.type." + typeId];
        },
        getEntityTypeName: function(typeId) {
            return appLinksI18n.entries["applinks.entity.type." + typeId];
        },
        getPluralizedEntityTypeName: function(typeId) {
            return appLinksI18n.entries["applinks.entity.type.plural." + typeId];
        },
        getAuthenticationTypeName: function(type) {
            return appLinksI18n.entries["applinks.auth.provider." + type];
        },
        resolveValue: function(key) {
            var value = appLinksI18n.entries[key];
            return typeof value == "undefined" ? key : value;
        }
    };

    var ApplinksHelpPaths = require('applinks/common/help-paths');
    AppLinks.Docs = {

        /**
         * NOTE: this is a dynamically generated version of the link build in _help_link.vm, any update here should be
         * applied there.
         * @method createDocLink
         * @param pageKey a key that maps to a page in ual-help-paths.properties
         * @param sectionKey (Optional) a key that maps to an anchor section id in ual-help-paths.properties
         * @return an html &lt;a&gt; element targeting the specified page & section
         * @deprecated use
         */
        createDocLink: function(pageKey, sectionKey, css) {
            if (!css) {
                css = "";
            } else {
                css = " " + css;
            }
            return $("<a/>", {
                "class": "ual-help-link help-link" + css,
                href: AppLinks.Docs.getDocHref(pageKey, sectionKey),
                target: "_blank",
                "data-help-link-key": pageKey,
                text: AppLinks.I18n.getText("applinks.help"),
                title: AppLinks.I18n.getText("applinks.help")
            });
        },
        /**
         * @method getDocHref
         * @param pageKey a key that maps to a page in ual-help-paths.properties
         * @param sectionKey (Optional) a key that maps to an anchor section id in ual-help-paths.properties
         * @return the url of the given page and section (if specified)
         */
        getDocHref: function(pageKey, sectionKey) {
            var link = ApplinksHelpPaths.getFullPath(pageKey);
            if (sectionKey) {
                link += '#' + ApplinksHelpPaths.getPath(pageKey);
            }
            return link;
        }
    };

    $(document).trigger(AppLinks.Event.PREREADY);
    $(document).trigger(AppLinks.Event.READY);
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/component/autocomplete.js' */
AJS.$(document).bind(AppLinks.Event.READY, function() {
/**
 * TODO: THIS CODE IS COPIED FROM CONFLUENCE and should be part of AUI/AJS.
 * IF AUI comes with the InputDrivenDropDown when can remove this file.
 * https://studio.atlassian.com/browse/AJS-471
 *
 * A simple cache manager that supports a
 * FIFO cache invalidation strategy.
 *
 * @class cacheManager
 * @namespace AJS.Confluence
 * @constructor
 * @param cacheSize the size of the cache before keys are invalidated
 */
AppLinks.autoComplete = {
        cacheManager : function (cacheSize) {
    var cache = {},
        cacheStack = [],
        cacheSize = cacheSize || 30;

    return {
        /**
         * Return the value stored in the cache for the given key
         * @method get
         * @param key {String}
         */
        get: function(key) {
            return cache[key];
        },
        /**
         * Put the given key, value in the cache
         * @method put
         * @param key {String}
         * @param value {Object}
         */
        put: function(key, value) {
            cache[key] = value;
            cacheStack.push(key);
            if (cacheStack.length > cacheSize) {
                delete cache[cacheStack.shift()];
            }
        },
        /**
         * Clear the cache.
         */
        clear : function() {
            cache = {};
            cacheStack = [];
        }
    };
}};


(function($){
    /**
     * Check that all items in the drop down can be displayed - show ellipses at the end of any that
     * are too long. Also remove any unused properties that the dropDown may have stored for each
     * item in the list.
     *
     * @method truncateText
     * @private
     */
    var truncateText = function (dd) {
        AJS.log("InputDrivenDropDown: truncating text");
        var width = dd.$.closest(".aui-dropdown").width(),
            rightPadding = 20; // add some padding so the ellipsis doesn't run over the edge of the box

        $("a span:not(.icon)", dd.$).each(function () {
            var $a = $(this),
                elpss = AJS("var", "&#8230;"),
                elwidth = elpss.width(),
                isLong = false;

            $a.wrapInner($("<em>"));
            $("em", $a).each(function () {
                var $label = $(this);

                $label.show();
                if (this.offsetLeft + this.offsetWidth > width) {
                    var childNodes = this.childNodes,
                        success = false;

                    for (var j = childNodes.length - 1; j >= 0; j--) {
                        var childNode = childNodes[j],
                            truncatedChars = 1,
                            valueAttr = (childNode.nodeType == 3) ? "nodeValue" : "innerHTML",
                            nodeText = childNode[valueAttr];

                        do {
                            if (truncatedChars <= nodeText.length) {
                                childNode[valueAttr] = nodeText.substr(0, nodeText.length - truncatedChars++);
                            } else { // if we cannot fit even one character of the next word, then try truncating the node just previous to this
                                break;
                            }
                        } while (this.offsetLeft + this.offsetWidth + elwidth > width - rightPadding);

                        if (truncatedChars <= nodeText.length) {
                            // we've managed truncate part of the word and fit it in
                            success = true;
                            break;
                        }
                    }

                    if (success) {
                        isLong = true;
                    } else {
                        $label.hide();
                    }
                }
            });
            if (isLong) {
                $a.append(elpss);
                this.elpss = elpss;
            }
        });
    };

    var highlightTokens = function(dd, tokens) {
        if (!tokens.length || !tokens[0]) return;

        AJS.log("InputDrivenDropDown: highlighting tokens");

        // escape regex chars .*+?|()[]{}\ first
        for (var i = 0, ii = tokens.length; i < ii; i++) {
            var token = tokens[i];
            tokens[i] = token ? token.replace(/[\.\*\+\?\|\(\)\[\]{}\\]/g, "\\$") : "";
        }

        var regex = new RegExp("(" + tokens.join("|") + ")", "gi");

        $("li a:not(.dropdown-prevent-highlight) span", dd.$).each(function() {
            var span = $(this),
                html = span.html().replace(regex, "<strong>$1</strong>");
            span.html(html);
        });
    };

    /**
     * Builds and shows the dropdown.
     *
     * @param idd the InputDrivenDropdown
     * @param dropdownData in the form { matrix, query, queryTokens }
     * @private
     */
    var makeDropdown = function (idd, dropdownData) {
        var options = idd.options,
            old_dd = idd.dd;

        if (old_dd) {
            old_dd.hide();
            old_dd.$.remove();
        }

        options.ajsDropDownOptions = options.ajsDropDownOptions || {};
        if (options.ajsDropDownOptions && !options.ajsDropDownOptions.alignment) { // default to left alignment
            options.ajsDropDownOptions.alignment = "left";
        }
        //this needs to be moved into aui
        options.ajsDropDownOptions.selectionHandler = options.ajsDropDownOptions.selectionHandler || function(e, element) {
            if(e.type != "click") {
                e.preventDefault();
                $("a",element).click();
                document.location = $("a",element).attr("href");
            }
        };

        /* Fixing an AUI bug in here:  AJS.dropdown puts the raw 'matrix[i].name' as html, without escaping it !
           The solution is to override their displayHandler
         */
        /**
         * Escape obj.name and return it
         */
        options.ajsDropDownOptions.displayHandler = function (obj) {
            return AJS.escapeHtml(obj.name);
        }

        var dd = idd.dd = new AJS.dropDown(dropdownData.matrix, options.ajsDropDownOptions)[0];

        // could move into dropdown.js in AUI
        if (options.ajsDropDownOptions && options.ajsDropDownOptions.className) {
            dd.$.addClass(options.ajsDropDownOptions.className);
        }

        // place the created drop down using the configured dropdownPlacement function
        // if there is none then use a default behaviour
        if (options.dropdownPlacement) {
            options.dropdownPlacement(dd.$);
        } else {
            AJS.log("No dropdownPlacement function specified. Appending dropdown to the body.");
            $("body").append(dd.$);
        }

        highlightTokens(dd, dropdownData.queryTokens || [dropdownData.query]);
        truncateText(dd);

        if (options.dropdownPostprocess) {
            options.dropdownPostprocess(dd.$);
        }
        dd.show(idd._effect);

        if (typeof options.onShow == "function") {
            options.onShow.call(dd, dd.$);
        }

        return dd;
    };

    /**
     * Provides a controller-agnostic object that listens for controller changes and populates a dropdown
     * via a callback. Most aspects can be customized via the options object parameter.
     * <br>
     * Options are:
     * <li>
     *   getDataAndRunCallback - (required) callback method used to provide data for the dropdown. It must take
     *                          two parameters, user input value and the callback function to execute.
     * </li>
     * <li>
     *   onShow - function to call when the drop-down is displayed
     * </li>
     * <li>
     *   dropdownPlacement - a function that will be called with the drop down and which should place it in the
     *                          correct place on the page. The supplied arguments are 1) the input that issued the
     *                          search, 2) the dropDown to be placed.
     * </li>
     * <li>
     *   ajsDropDownOptions - any options the underlying dropDown component can handle expects
     * </li>
     * <li>
     *   onDeath - callback to run when dropdown dies
     * </li>
     * @class InputDrivenDropDown
     * @namespace AJS
     */
    function InputDrivenDropDown(id, options) {
        this._effect = "appear";
        this._timer = null;

        this.id = id;
        this.options = options;
        this.inactive = false;
        this.busy = false;
        this.cacheManager = AppLinks.autoComplete.cacheManager();
    }

    /**
     * Clears the cache.
     */
    InputDrivenDropDown.prototype.clearCache = function () {
        this.cacheManager.clear();
    };

    /**
     * This method should be called when the user input for this dropdown has changed.
     * It will check the cache before fetching data (via options.getDataAndRunCallback)
     * and displaying the dropdown.
     *
     * @param value {String} the new value of the user input
     * @param force {Boolean} force a change to occur regardless of user input
     */
    InputDrivenDropDown.prototype.change = function (value, force) {
        var t = this;
        if (value != t._value || force) {
            t._value = value;
            t.busy = false;

            clearTimeout(t._timer);

            if (force || (/\S{0,}/).test(value)) {
                var cachedVal = t.cacheManager.get(value);
                if (cachedVal) {
                    makeDropdown(t, cachedVal);
                } else {
                    t.busy = true;
                    t._timer = setTimeout(function () { // delay sending a request to give the user a chance to finish typing their search term(s)
                        t.options.getDataAndRunCallback.call(t, value, t.show);
                    }, 200);
                }
            } else {
                t.dd && t.dd.hide();
            }
        }
    };

    /**
     * Gets the number of visible options in the dropdown.
     */
    InputDrivenDropDown.prototype.dropDownLength = function () {
        return this.dd.links ? this.dd.links.length : 0;
    };
    
    /**
     * Gets the specified menu item from the dropdown list.
     * 
     * @param index {Integer} the 0-based index of the dropdown option list
     */
    InputDrivenDropDown.prototype.dropDownItem = function (index) {
        return this.dropDownLength() > index ? this.dd.links[index] : null;
    };
    
    /**
     * Hides the drop down
     */
    InputDrivenDropDown.prototype.hide = function () {
        this.dd && this.dd.hide();
    };

    /**
     * Hides and removes the drop down from the DOM.
     */
    InputDrivenDropDown.prototype.remove = function () {
        var dd = this.dd;
        if (dd) {
            this.hide();
            dd.$.remove();
        }
        this.inactive = true;
        this.options.onDeath && this.options.onDeath();
    };

    /**
     * Shows the drop down with the given matrix data and query.
     * <br>
     * Matrix property should be an array of arrays, where the sub-arrays represent the different
     * search categories.
     *
     * Expected properties of category sub-array objects are:
     *  - href
     *  - name
     *  - className
     *  - html (optional, replaces href and name)
     *  - icon (optional)
     *
     *
     * @param matrix {Array} matrix to populate the drop down from
     * @param query {String} the user input string that triggered this show
     * @param queryTokens {Array} an array of strings of the query tokens. Use for highlighting search terms.
     */
    InputDrivenDropDown.prototype.show = function (matrix, query, queryTokens) {
        if (this.inactive) {
            AJS.log("Quick search abandoned before server response received, ignoring. " + this);
            return;
        }

        var dropdownData = {
            matrix: matrix,
            query: query,
            queryTokens: queryTokens
        };
        this.cacheManager.put(query, dropdownData);

        makeDropdown(this, dropdownData);
        this.busy = false;
    };

    /**
     * Returns an InputDrivenDropDown. See InputDrivenDropDown for more documentation.
     * @param options {Object} options for the InputDrivenDropDown
     * @constructor
     */
    AppLinks.inputDrivenDropdown = function (options) {
        return new InputDrivenDropDown("inputdriven-dropdown", options);
    };

})(jQuery);
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/component/wizard.js' */
AJS.$(document).bind(AppLinks.Event.PREREADY, function() {

    (function($) {

        $.fn.wizard = function(settings) {
            var config = {
                width: 500,
                height: 350,
                onshow: function(popup, configuration) {
                    return true;
                },
                aftershow: function() {
                    return true;
                },
                oncancel: function() {
                    return true;
                },
                onsubmit: function() {
                    return true;
                },
                aftersubmit: function() {
                    return true;
                },
                onnext: function() {
                    return true;
                },
                onprevious: function() {
                    return true;
                },
                cancelLabel: AppLinks.I18n.getText("applinks.cancel"),
                submitLabel: AppLinks.I18n.getText("applinks.create"),
                nextLabel: AppLinks.I18n.getText("applinks.next"),
                previousLabel: AppLinks.I18n.getText("applinks.previous"),
                id: ""
            };

            if (!settings) settings = {};

            settings = $.extend(config, settings);

            var result = this;

            this.each(function() {
                var obj = $(this);
                var popup = new AJS.Dialog(settings.width, settings.height, settings.id);
                var showFn = show(popup, settings.onshow, settings.aftershow);
                var cancelFn = cancel(popup, settings.oncancel);
                var submitFn = submit(popup, settings.onsubmit, settings.aftersubmit);
                var previousFn = previous(popup, settings.onprevious)
                var nextFn = next(popup, settings.onnext);

                var disableNextFn = disableNext(popup);
                var enableNextFn  = enableNext(popup);

                var disableSubmitFn = disableSubmit(popup);
                var enableSubmitFn  = enableSubmit(popup);

                var disablePreviousFn = disablePrevious(popup);
                var enablePreviousFn  = enablePrevious(popup);

                if (settings.showButtonId) {
                    $('#' + settings.showButtonId).click(showFn);
                }

                var pages = findPages(obj);


                for (var pageIndex = 0; pageIndex < pages.length; pageIndex++) {
                    var page = pages[pageIndex];
                    createPage(popup, page);
                    if (page.className) {
                        popup.addHeader(page.title, page.className + "-header");
                    } else {
                        popup.addHeader(page.title);
                    }

                    if (pageIndex != 0 && $(page.div).attr("previous") != "false") {
                        popup.addButton(settings.previousLabel, previousFn, "applinks-previous-button");
                    }

                    if (pageIndex < pages.length - 1 && $(page.div).attr("submit") != "true" && $(page.div).attr("next") != "false") {
                        popup.addButton(settings.nextLabel, nextFn, "applinks-next-button");
                    }

                    if ($(page.div).attr("submit") == "true") {
                        popup.addButton(settings.submitLabel, submitFn, "wizard-submit");
                    }

                    if (!popup.getPage(pageIndex).buttonpanel) {
                        //THIS IS A DUMMY BUTTON, which gets remove afterwards
                        //THE DUMMY BUTTON will cause the cancel text link to appear on the correct position.
                        //IT IS A WORKAROUND so I don't have to change the dialog.js code
                        popup.addButton("", null);
                        $(popup.getPage(pageIndex).buttonpanel).empty();
                        var cancelLink = $('<button class="aui-button aui-button-link button-panel-button applinks-cancel-link">' + settings.cancelLabel + '</button>');
                        popup.getPage(pageIndex).buttonpanel.append(cancelLink);
                        cancelLink.click(cancelFn);
                    } else {
                        var cancelLink = $('<button class="aui-button aui-button-link button-panel-link button-panel-cancel-link applinks-cancel-link">' + settings.cancelLabel + '</button>');
                        $(popup.getPage(pageIndex).buttonpanel).append(cancelLink);
                        cancelLink.click(cancelFn);
                    }

                    if (pageIndex < pages.length - 1) {
                        popup.addPage();
                    }
                }

                result = {
                    dialog: popup,
                    nextPage: nextFn,
                    prevPage: previousFn,
                    submit: submitFn,
                    cancel: cancelFn,
                    show: showFn,
                    disableNextBtn     : disableNextFn,
                    enableNextBtn      : enableNextFn,
                    disableSubmitBtn   : disableSubmitFn,
                    enableSubmitBtn    : enableSubmitFn,
                    disablePreviousBtn : disablePreviousFn,
                    enablePreviousBtn  : enablePreviousFn
                };
                popup.gotoPage(0);
                popup.gotoPanel(0);
            });

            return result;
        };

        function disablePrevious(popup) {
            return function() {
                disable(getButton(popup, 'applinks-previous-button'));
            }
        }

        function enablePrevious(popup) {
            return function() {
                enable(getButton(popup, 'applinks-previous-button'));
            }
        }

        function disableNext(popup) {
            return function() {
                disable(getButton(popup, 'applinks-next-button'));
            }
        }

        function enableNext(popup) {
            return function() {
                enable(getButton(popup, 'applinks-next-button'));
            }
        }

        function disableSubmit(popup) {
            return function(showLoading) {
                var buttonEl = getButton(popup, 'wizard-submit');
                disable(buttonEl);
                if (typeof(showLoading) == 'undefined' || showLoading) {
                    $('<span class="loading">&nbsp;</span>').insertBefore(buttonEl);
                } else {
                    buttonEl.parent().find('.loading').remove();
                }
            }
        }

        function enableSubmit(popup) {
            return function() {
                var buttonEl = getButton(popup, 'wizard-submit');
                enable(buttonEl);
                buttonEl.parent().find('.loading').remove();
            }
        }

        function getButton(popup, cssClass) {
            return $(popup.getPage(popup.curpage).buttonpanel).find('.' + cssClass);
        }

        function resetForms(popup) {
             $(popup.popup.element).find('form').each( function() {
                  this.reset();
             });
        }

        function enable(element) {
            element.attr('disabled', false);
        }

        function disable(element) {
            element.attr('disabled', true);
        }
		
        function show(popup, onshow, aftershow) {
            return function(configuration) {
				if (onshow(popup, configuration) !== false) {
                    popup.gotoPage(0);
                    popup.gotoPanel(0);
                    $(document).unbind('keydown.ual.dialog');
                    $(document).bind('keydown.ual.dialog', attachKeypressListener(popup));
					popup.show();
                    aftershow();
                }
            }
        }

        function cancel(popup, oncancel) {
            return function() {
                if (oncancel(popup) !== false) {
                    popup.hide();
                    resetForms(popup);
                }
            }
        }

        function previous(popup, onprevious) {
            return function() {
                if (onprevious(popup) !== false) {
                    popup.prevPage();
                }
            }
        }

        function next(popup, onnext) {
            return function() {
                if (onnext(popup) !== false) {
                    popup.nextPage();
                }
            }
        }

        function attachKeypressListener(popup) {
            return function(e) {
                if (e.keyCode === 27) {
                    resetForms(popup);
                    $(document).unbind('keydown.ual.dialog');
                }
            }
        }

        function submit(popup, onSubmit, afterSubmit) {
            return function() {
                if (onSubmit(popup) !== false) {
                    afterSubmit(popup);
                    resetForms(popup);
                }
            }
        }

        function createPage(popup, page) {
            var panelDivs = $("> div[panel]", page.div);
            if (panelDivs.length > 0) {
                panelDivs.each(function(index, panelDiv) {
                    var popupPage = popup.addPanel(panelDiv.title, null, panelDiv.className, 'menu-' + panelDiv.id);
                    popupPage.getCurrentPanel().body.append(panelDivs[index]);
                });
            }
            else {
                var popupPage = popup.addPanel(page.title);
                popupPage.getCurrentPanel().body.append(page.div);
            }
        }


        function findPages(containerDiv) {
            var pagesDivs = $(" > div", containerDiv);
            var pages = [];
            pagesDivs.each(function(index) {
                var pageDiv = $(this);
                pages[index] = {
                    title: pageDiv.attr('title') || null,
                    className: pageDiv.attr('class'),
                    div: pageDiv
                };
            });
            return pages;
        }
    })(jQuery)
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/feature/applinks-wizard/applinkwizard.js' */
(function($) {
    AppLinks.Wizard = {
        getWizard: function(){
            return $("#create-application-link-container").data('wizard');
        },
        initAuthenticationUI: function(element) {
            var root = $(element);
            var createTwoWayLinkCheckbox = root.find('.create-reciprocal-link');
            var ualArrow = root.find('.ual-arrow');
            var linkDetails = root.find('.two-way-link-details');
            var linkDescription = root.find('.reciprocal-link-description');
            var noLinkDescription = root.find('.no-reciprocal-link-description');
            createTwoWayLinkCheckbox.click(function() {
                if (createTwoWayLinkCheckbox.is(':checked')) {
                    ualArrow.removeClass('no-background');
                    linkDetails.show();
                    linkDescription.show();
                    noLinkDescription.hide();
                } else {
                    ualArrow.addClass('no-background');
                    linkDetails.hide();
                    linkDescription.hide();
                    noLinkDescription.show();
                }
            });
            var sameUserBtn = root.find('.same-user-radio-btn');
            var differentUserBtn = root.find('.different-user-radio-btn');
            var differentUserBaseImage = root.find('.different-userbase-image');
            var sameUserBaseImage = root.find('.same-userbase-image');

            sameUserBtn.click(function() {
                differentUserBaseImage.addClass('different-userbase-image-grey');
                sameUserBaseImage.removeClass('same-userbase-image-grey');
            });

            differentUserBtn.click(function() {
                sameUserBaseImage.addClass('same-userbase-image-grey');
                differentUserBaseImage.removeClass('different-userbase-image-grey');
            });
        },

        initNonUALUI : function(element) {
            var root = $(element);
            var applicationTypesEl = root.find('.application-types');
            for (var i = 0; i < nonAppLinksApplicationTypes.length; i++) {
                $('<option value=\"' + nonAppLinksApplicationTypes[i].typeId + '\">' + nonAppLinksApplicationTypes[i].label + '</option>').appendTo(applicationTypesEl);
            }
        },
        fetchManifest : function(wizard, dialogRootEl, ualAppCallbackFn, nonUALAppCallbackFn) {
            var applicationURLEl = dialogRootEl.find('#application-url');
            if (applicationURLEl.val() == '') {
                var applicationTypeEl = dialogRootEl.find('#application-types');
                if (applicationTypeEl.val() == '') {
                    $('<div class="error applinks-error">' + AppLinks.I18n.getText('applinks.error.url.field.empty') + '</div>').insertAfter(applicationURLEl);
                    return false;
                }
                var success = function(data) {
                    wizard.enableSubmitBtn();
                    wizard.enablePreviousBtn();
                    wizard.cancel();
                    AppLinks.UI.listApplicationLinks(data.applicationLink.id, 'new', data);
                };
                AppLinks.SPI.createStaticUrlAppLink(applicationTypeEl.val(), success, null);
                return true;
            }
            var appUrl = AppLinks.UI.addProtocolToURL(applicationURLEl.val());

            AppLinks.UI.showLoadingIcon(applicationURLEl);
            var success = function(data) {
                var manifest = data;
                wizard.enableNextBtn();
                dialogRootEl.find('.loading').remove();
                dialogRootEl.find('.reciprocal-rpc-url').val($('#baseUrl').val());
                if (typeof data.typeId != "undefined") {
                    AppLinks.Wizard.handleUALManifest(manifest, dialogRootEl);
                    wizard.dialog.gotoPage(2);
                    dialogRootEl.find('.reciprocal-link-username').focus();
                    if (ualAppCallbackFn) {
                      ualAppCallbackFn(manifest);
                    }
                }
                else {
                    if (data.code == 'applinks.warning.redirected.host' && !applicationURLEl.data('hasWarnedAboutRedirection')) {
                        // The host requires a redirection. Stay on the same page, ask for a confirmation.
                        AppLinks.UI.displayValidationErrorMessages('manifest-validation-errors', dialogRootEl, data.warning);
                        applicationURLEl.data('hasWarnedAboutRedirection', 'true');
                        var unsetRedirectionWarning = function () {
                            $(applicationURLEl).removeData('hasWarnedAboutRedirection');
                            $(applicationURLEl).unbind('change', unsetRedirectionWarning);
                        };
                        applicationURLEl.bind('change', unsetRedirectionWarning);
                    }
                	else if (data.code == 'applinks.warning.unknown.host' && !applicationURLEl.data('forceWhenHostIsOffline')) {
                	    // The host doesn't ping. Stay on the same page, ask for a confirmation.
                	    AppLinks.UI.displayValidationErrorMessages('manifest-validation-errors', dialogRootEl, data.warning);
                	    applicationURLEl.data('forceWhenHostIsOffline', 'true');
                	    var unsetForceWhenHostIsOffline = function () {
                	        $(applicationURLEl).removeData('forceWhenHostIsOffline');
                	        $(applicationURLEl).unbind('change', unsetForceWhenHostIsOffline);
                	    };
                	    applicationURLEl.bind('change', unsetForceWhenHostIsOffline);
            		}
                	else {
                        if (manifest.code == 'applinks.warning.unknown.host' || manifest.code == "applinks.warning.redirected.host") {
                	        // The user has already been notified of this warning.
                	        delete manifest.warning;
                	        delete manifest.code;
                	    }
                	    AppLinks.Wizard.handleNonUALManifest(manifest, appUrl, dialogRootEl);
                        wizard.dialog.gotoPage(1);
                        dialogRootEl.find('.application-name').focus();
                        if (nonUALAppCallbackFn) {
                          nonUALAppCallbackFn(manifest);
                        }
                	}
                }
            };
            wizard.disableNextBtn();
            AppLinks.SPI.tryToFetchManifest(appUrl, success, AppLinks.UI.displayValidationError('manifest-validation-errors', dialogRootEl, function() {
                wizard.enableNextBtn();
            }));
            return appUrl;
        },
        handleUALManifest : function(manifest, element) {
            var root = $(element);
            root.find('.remote-app-image').removeClass( function(index, className) {
            var classes = className.split(' ');
            var classToRemove = "";
                $.each(classes, function(index, value) {
                    if (value.indexOf('application-type-image-') != -1) {
                        classToRemove = value;
                    }
                });
                return classToRemove;
            });
            root.find('.remote-app-image').addClass('application-type-image-' + manifest.typeId);
            root.find('.link-to-app-type').html(AppLinks.I18n.getText('applinks.create.title.link.to', AppLinks.I18n.getApplicationTypeName(manifest.typeId)));
            root.find('.remote-app-name').text(AppLinks.UI.shortenString(manifest.name, 20));
            root.find('.create-reciprocal-link').attr('checked', true);
            root.find('#reciprocal-link-back-to-server').html(AppLinks.I18n.getText('applinks.create.link.back.to.server', AJS.escapeHtml(manifest.name)));
            // For the two way link text, we need to specify different roles for the credentials depending on the remote app
            // For JIRA and Confluence version < 3.10, it is system administrator
            // For everything else, it is administrator
            var twoWayLinkParams = ["administrator", AJS.escapeHtml(manifest.name),
                             '<a target="_blank" href="' + AppLinks.Docs.getDocHref("applinks.docs.adding.application.link") + '">', '</a>'];
            if(manifest.applinksVersion != undefined) {
                var remoteVersion = manifest.applinksVersion.split(".");
                var majorVersion = parseInt(remoteVersion[0]);
                var minorVersion = parseInt(remoteVersion[1]);
                // we don't have to check for versions < 3 since those won't have the manifest.
                if ((manifest.typeId == "jira" || manifest.typeId == "confluence") && (majorVersion == 3 && minorVersion < 10)) {
                    twoWayLinkParams[0] = "system administrator";
                }
            }
            root.find('.reciprocal-link-description').html(AppLinks.I18n.getText('applinks.create.two.way.link', twoWayLinkParams));
            root.find('.no-reciprocal-link-description').hide();
            root.find('.no-reciprocal-link-description').html(AppLinks.I18n.getText('applinks.create.two.way.no.link', AJS.escapeHtml(manifest.name)));
            root.find('.reciprocal-link-username').val('');
            root.find('.reciprocal-link-password').val('');
            root.find('.ual-arrow').removeClass('no-background');
            root.find('.two-way-link-details').show();
            root.find('.reciprocal-link-description').show();
            root.find('.no-reciprocal-link-description').hide();
        },
        handleNonUALManifest : function(data, appUrl, element) {
            var root = $(element);
            root.find('.application-name').val('');
            root.find(".application-types option:first-child").attr("selected", "selected");
            root.find('.non-ual-application-url').text(appUrl);
            if (data.warning) {
                root.find('.create-non-ual-warning').show();
                root.find('.create-non-ual-warning').html(data.warning);
            } else {
                root.find('.create-non-ual-warning').hide();
            }
        },
        checkReciprocalLinkFormThreeStepMode : function(element, handleOneWayLinkFn, handleTwoWayLinkDetailsSuccess, appUrl, errorFn) {
            var root = $(element);
            if (root.find('.create-reciprocal-link').is(':checked')) {
                var reciprocalRPCURL = $.trim(root.find('.reciprocal-rpc-url').val());
                if (reciprocalRPCURL == '') {
                    $("<div class='error applinks-error'>" + AppLinks.I18n.getText('applinks.error.url.field.empty') + "</div>").insertAfter(root.find('.reciprocal-rpc-url'))
                    if (errorFn) {
                        errorFn();
                    }
                    return;
                }
                var reciprocalLinkUsername = root.find('.reciprocal-link-username');
                var reciprocalLinkPwd = root.find('.reciprocal-link-password');
                if (reciprocalLinkUsername.val() == '') {
                    $('<div class="error applinks-error">'+ AppLinks.I18n.getText('applinks.error.username.empty') +'</div>').insertAfter(reciprocalLinkUsername);
                    if (errorFn) {
                        errorFn();
                    }
                    return false;
                }

                //verify user has admin rights.
                var successFn = function(data) {
                    root.find('.same-user-description').find('input').attr('checked', true);
                    root.find(".trust-radio-btn").attr('checked', true);
                    root.find('.same-user-radio-btn').click();
                    handleTwoWayLinkDetailsSuccess(data);
                };
                reciprocalRPCURL = AppLinks.UI.addProtocolToURL(reciprocalRPCURL);
                AppLinks.SPI.verifyTwoWayLinkDetails(appUrl, reciprocalRPCURL, reciprocalLinkUsername.val(), reciprocalLinkPwd.val(), successFn, AppLinks.UI.displayValidationError('two-way-link-errors', element, errorFn));
                return false;
            } else {
                handleOneWayLinkFn();
                return false;
            }
        },
        checkReciprocalLinkFormTwoStepMode : function(element, appUrl, successFn, errorFn) {
            var root = $(element);
            var reciprocalRPCURL = $.trim(root.find('.reciprocal-rpc-url').val());
            if (reciprocalRPCURL == '') {
                $("<div class='error applinks-error'>" + AppLinks.I18n.getText('applinks.error.url.field.empty') + "</div>").insertAfter(root.find('.reciprocal-rpc-url'))
                if (errorFn) {
                    errorFn();
                }
                return;
            }
            var reciprocalLinkUsername = root.find('.reciprocal-link-username');
            var reciprocalLinkPwd = root.find('.reciprocal-link-password');
            if (reciprocalLinkUsername.val() == '') {
                $('<div class="error applinks-error">'+ AppLinks.I18n.getText('applinks.error.username.empty') +'</div>').insertAfter(reciprocalLinkUsername);
                if (errorFn) {
                    errorFn();
                }
                return false;
            }

            reciprocalRPCURL = AppLinks.UI.addProtocolToURL(reciprocalRPCURL);
            AppLinks.SPI.verifyTwoWayLinkDetails(appUrl, reciprocalRPCURL, reciprocalLinkUsername.val(), reciprocalLinkPwd.val(), successFn, AppLinks.UI.displayValidationError('two-way-link-errors', element, errorFn));
            return false;
        }
    }
})(AJS.$);
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/common/urls.js' */
define('applinks/common/urls', [
    'applinks/lib/aui',
    'applinks/lib/lodash',
    'applinks/common/products'
], function(
    AJS,
    _,
    Products
) {
    /**
     * Utility functions for generating URLs in JS, including a link to applinks admin screen.
     */
    var ApplinksUrls = {

        /**
         * Generate a URL from the base and parameters.
         * @param baseUrl the baseUrl
         * @param parametersMap a map of parameters to add, in the form of { parameterName :  parameterValue }
         * @return {String}
         */
        generateUrl: function(baseUrl, parametersMap) {
            var redirectUrl = baseUrl;

            if(_.isUndefined(parametersMap)) {
                return redirectUrl;
            } else {
                _.each(parametersMap, function(value, key) {
                    if(redirectUrl.indexOf('?') < 0) {
                        redirectUrl = redirectUrl + '?';
                    } else {
                        redirectUrl = redirectUrl + '&';
                    }
                    redirectUrl = redirectUrl + key + "=" + encodeURIComponent(JSON.stringify(value))
                });

                return redirectUrl;
            }
        }
    };

    ApplinksUrls.Local = {

        admin: function(params) {
            var url = AJS.contextPath() + "/plugins/servlet/applinks/listApplicationLinks";
            return ApplinksUrls.generateUrl(url, params);
        }
    };

    ApplinksUrls.Remote = {

        /**
         * Generate a URL to remote Applinks Admin screen. For compatibility it needs to accept `applicationTypeId`.
         *
         * @param remoteBaseUrl
         * @param applicationTypeId
         * @param params extra URL params
         * @returns {String}
         */
        admin: function(remoteBaseUrl, applicationTypeId, params) {
            var suffix = applicationTypeId === Products.CONFLUENCE ?
                '/admin/listapplicationlinks.action' :
                '/plugins/servlet/applinks/listApplicationLinks';
            var url = remoteBaseUrl + suffix;

            return ApplinksUrls.generateUrl(url, params);
        }
    };

    return ApplinksUrls;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'js/help-link-analytics.js' */
(function ($) {
    $(function () {
        AJS.$('body').on('click', '.help-link', function () {
            AJS.trigger('analyticsEvent', {
                name: 'applinks.view.documentation',
                data: {linkKey: $(this).attr('data-help-link-key')}
            });
        });
    })
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-applinks-common-plugin:issue-link-applinks', location = 'js/issuelink-applinks.js' */
/**
 * Initialises anything requiring OAuth authentication. Requires the following elements:
 * <div class="issue-link-applinks-authentication-message"></div>
 */
var IssueLinkAppLinks = IssueLinkAppLinks || (function($) {
    function createHelper(servers, context, settings) {
        var helper = {};
        var selectedServer = null;

        function selectServer(appId) {
            selectedServer = getServer(servers, appId);

            var authenticationRequired = selectedServer && selectedServer.requireCredentials;
            doAuthenticationRequired(authenticationRequired, context);

            return {"authenticationRequired": authenticationRequired};
        }

        function setAuthenticationRequired(appId, authenticationRequired) {
            var server = getServer(servers, appId);
            if (server) {
                server.requireCredentials = authenticationRequired;

                // Refresh the authenication message if we have updated the selected server
                if (selectedServer && selectedServer.id === appId) {
                    doAuthenticationRequired(authenticationRequired, context);
                }
            }
        }

        function doAuthenticationRequired(required, context) {
            $(".issue-link-applinks-authentication-message", context).empty();
            if (required) {
                createAuthRequiredBanner($(".issue-link-applinks-authentication-message", context), context);
                $(".issue-link-oauth-toggle").hide();
                $(".buttons-container input[type=submit]", context).attr("disabled", "disabled");
            } else {
                $(".issue-link-oauth-toggle").show();
                $(".buttons-container input[type=submit]", context).removeAttr("disabled");
            }
        }

        function createAuthRequiredBanner($container, context) {
            var oauthCallbacks = {
                onSuccess: function () {
                    selectedServer.requireCredentials = false;
                    doAuthenticationRequired(false, context);
                    if (settings.onAuthenticationSuccessCallback) {
                        settings.onAuthenticationSuccessCallback(context, selectedServer.id, helper);
                    }
                },
                onFailure: function () {
                    if (settings.onAuthenticationFailedCallback) {
                        settings.onAuthenticationFailedCallback(context, selectedServer.id, helper);
                    }
                }
            };

            var encodedServerName = AJS.escapeHtml(selectedServer.name);
            if (selectedServer.authUrl) {
                var $banner = $('<div class="aui-message warning closeable shadowed applinks-auth-request"><p><span class="aui-icon icon-applinks-key"></span></p></div>');
                $banner.append(AJS.format("Authorization required to create issue link. Please \u003ca href=\"{0}\" class=\"applink-authenticate\"\u003eauthenticate\u003c/a\u003e with \u003ca href=\"{1}\"\u003e{2}\u003c/a\u003e.", selectedServer.authUrl, selectedServer.url, encodedServerName));
                $("a", $banner).addClass("applink-authenticate");
                $('.applink-authenticate', $banner).click(function (e) {
                    authenticateRemoteCredentials(selectedServer.authUrl, oauthCallbacks.onSuccess, oauthCallbacks.onFailure);
                    e.preventDefault();
                });
                $container.append($banner);
            } else {
                var warningMessage = AJS.format("Unable to create a link to \u003ca href=\"{0}\"\u003e{1}\u003c/a\u003e as the application does not have any authentication configured.", selectedServer.url, encodedServerName);
                AJS.messages.warning($container, {body: warningMessage});
            }
        }

        function createOAuthCallback() {
            if (!AppLinks.OAuthCallback && typeof(oauthCallback) === "undefined") {
                AppLinks.OAuthCallback = function() {

                };

                AppLinks.OAuthCallback.prototype.success = function() {
                    this.aouthWindow.close();
                    this.onSuccess();
                    delete oauthCallback;
                    delete AppLinks.OAuthCallback;
                };

                AppLinks.OAuthCallback.prototype.failure = function() {
                    this.aouthWindow.close();
                    this.onFailure();
                    delete oauthCallback;
                    delete AppLinks.OAuthCallback;
                };

                AppLinks.OAuthCallback.prototype.show = function(url, onSuccess, onFailure) {
                    this.onSuccess = onSuccess;
                    this.onFailure = onFailure;
                    this.aouthWindow = window.open(url, "com_atlassian_applinks_authentication");
                };
                // set the global oAuthCallback variable required by AppLinks
                oauthCallback = new AppLinks.OAuthCallback();
            }
        }

        function authenticateRemoteCredentials(url, onSuccess, onFailure) {
            createOAuthCallback();

            $('.applinks-error').remove();
            oauthCallback.show(url, onSuccess, onFailure);
        }

        return $.extend(helper, {
            selectServer: selectServer,
            setAuthenticationRequired: setAuthenticationRequired
        });
    }

    function getServer(servers, appId) {
        var i;
        if (servers.length) {
            for (i = 0; i < servers.length; i++) {
                if (servers[i].id === appId) {
                    return servers[i];
                }
            }
        }
        return null;
    }

    /**
     * Called only once during the initialisation to retrieve the list of servers.
     *
     * @param context the context to perform the initialisation. This is either the inline dialog or the entire document
     *                body.
     */
    function initApplinkServers(settings, context, deferred) {
        var currentAppId = settings.getCurrentAppId(context);
        var applicationType = $(".issue-link-applinks-application-type", context).val();
        var issueId = settings.getIssueId(context);
        $.get(AJS.contextPath() + '/rest/issueLinkAppLink/1/appLink/info', { type: applicationType, issueIdOrKey: issueId }, function (servers) {
            var helper = createHelper(servers, context, settings);
            var currentRequiresCredentials;
            if (servers && servers.length) {
                var currentServer = getServer(servers, currentAppId);
                if (currentServer) {
                    currentRequiresCredentials = $(".issue-link-applinks-authentication-message", context).hasClass("required");
                    if (currentRequiresCredentials) {
                        currentServer.requireCredentials = true;
                    }
                    helper.selectServer(currentAppId);
                }
                deferred.resolve(context, helper);
            } else {
                deferred.reject(context);
            }
        });
    }

    /**
     * @return jQuery.Promise<String>
     */
    function init(settings, context) {
        var deferred = $.Deferred();

        var isIssueLinkAppLinkContent = $(".issue-link-applinks-authentication-message", context).length !== 0;
        if (isIssueLinkAppLinkContent && settings.shouldExecute(context)) {
            initApplinkServers(settings, context, deferred);
        }

        return deferred.promise();
    }

    return {
        init: init
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-remote-jira-js', location = 'js/issuelink-jira.js' */
/**
 * Initialises OAuth authentication for JIRA Application Links. Requires the following elements:
 * <div class="issue-link-applinks-authentication-message"></div>
 */
(function ($) {

    var settings = {
        getCurrentAppId: function (context) {
            return $("#jira-app-link", context).val();
        },
        shouldExecute: function (context) {
            return $("#jira-app-link", context).length !== 0;
        },
        getIssueId: function (context) {
            return $("input[name=id]", context).val();
        }
    };

    var updateIssuePicker = function($select, appId) {
        if ($select.length) {
            // Update the appId param
            $select.attr("data-ajax-options.data.app-id", appId);
            if (appId && appId !== "") {
                // Set the url for remote JIRA queries
                $select.attr("data-ajax-options.url", contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/picker");
            }
            else {
                // Set the url for local JIRA queries
                $select.attr("data-ajax-options.url", contextPath + "/rest/api/2/issue/picker");
            }

            $select.trigger("updateOptions");

            // Now that we have changed server, our current issue selection is no longer relevant
            $select.trigger("clearSelection");
        }
    };

    var updateCreateReciprocalCheckbox = function(appId, context) {
        var $reciprocalCheckbox = $("#create-reciprocal", context);
        if ($reciprocalCheckbox.length) {
            if (appId && appId !== "") {
                // Get default choice for creating a remote reciprocal link
                var defaultChoice = ($("#create-reciprocal-default", context).val() == "true");
                if (defaultChoice) {
                    $reciprocalCheckbox.attr("checked", "checked");
                } else {
                    $reciprocalCheckbox.removeAttr("checked");
                }
                $reciprocalCheckbox.removeAttr("disabled");
                $("#create-reciprocal-fieldset", context).removeClass("disabled");
            } else {
                // Set to checked for local links, as they always create a reciprocal link
                $reciprocalCheckbox.attr("checked", "checked");
                $reciprocalCheckbox.attr("disabled", "disabled");
                $("#create-reciprocal-fieldset", context).addClass("disabled");
            }
        }
    };

    JIRA.bind(JIRA.Events.NEW_PAGE_ADDED, function (e, context) {

        var $select = $("#jira-issue-keys", context);
        if ($select.length) {
            var appId = $("#jira-app-link", context).val();
            updateIssuePicker($select, appId);
            updateCreateReciprocalCheckbox(appId, context);
        }

        IssueLinkAppLinks.init(settings, context).done(function (context, helper) {
            $("#jira-app-link", context).change(function () {
                var appId = $(this).val();
                helper.selectServer(appId);
                updateIssuePicker($select, appId);
                updateCreateReciprocalCheckbox(appId, context);
            });
        });
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-jira-search-js', location = 'js/issuelink-jira-jqlautocomplete.js' */
/**
 * Instantiates jql autocomplete functionality on request instead of on page load.
 */
var IssueLinkJQLAutoComplete = IssueLinkJQLAutoComplete || (function($) {

    /**
     * Initializes an auto complete field
     */
    function initialize(options) {

        var fieldID = options.fieldID;
        var errorID = options.errorID;
        var autoCompleteUrl = options.autoCompleteUrl;
        var autoCompleteData = options.autoCompleteData;
        var formSubmitFunction = options.formSubmitFunction;

        var $field = $('#'+fieldID);
        var hasFocus = $field.length > 0 && $field[0] == document.activeElement;

        var jqlFieldNames = autoCompleteData.visibleFieldNames || [];
        var jqlFunctionNames = autoCompleteData.visibleFunctionNames || [];
        var jqlReservedWords = autoCompleteData.jqlReservedWords || [];

        var jqlAutoComplete = JIRA.JQLAutoComplete({
            fieldID: fieldID,
            parser: JIRA.JQLAutoComplete.MyParser(jqlReservedWords),
            queryDelay: .65,
            jqlFieldNames: jqlFieldNames,
            jqlFunctionNames: jqlFunctionNames,
            minQueryLength: 0,
            allowArrowCarousel: true,
            autoSelectFirst: false,
            errorID: errorID,
            autoCompleteUrl: autoCompleteUrl
        });

        $field.unbind("keypress", submitOnEnter);

        if (formSubmitFunction) {
            $field.keypress(function (e) {
                if (jqlAutoComplete.dropdownController === null || !jqlAutoComplete.dropdownController.displayed || jqlAutoComplete.selectedIndex < 0) {
                    if (e.keyCode === 13 && !e.ctrlKey && ! e.shiftKey)
                    {
                        formSubmitFunction();
                        return false;
                    }
                    else
                    {
                        return true;
                    }
                }
            });
        }

        jqlAutoComplete.buildResponseContainer();
        jqlAutoComplete.parse($field.text());
        jqlAutoComplete.updateColumnLineCount();

        $field.click(function(){
            jqlAutoComplete.dropdownController.hideDropdown();
        });

        if (hasFocus) {
            $field.select();
        }
    }

    return {
        initialize: initialize
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-jira-search-js', location = 'js/issuelink-jira-search.js' */
AJS.$(function ($) {
    var remoteJiraSearchDialog =  new JIRA.FormDialog({
        id: "remote-jira-search-dialog",
        trigger: "#link-jira-issue .remote-jira-search-trigger",
        widthClass: "large",
        content: function (render) {
            render(JIRA.Templates.RemoteJiraIssueSearch.dialog());
            initSearchDialog(this.$popup);
        },
        submitHandler: function(e, callback){
            e.preventDefault();
            $("#simple-search-panel-button").removeAttr("disabled");
            $("#advanced-search-panel-button").removeAttr("disabled");
            if($(e.target).attr("id") === "remote-jira-simple-search-form"){
                $("#simple-search-panel-button").click();
            } else {
                $("#advanced-search-panel-button").click();
            }
            callback();
        }
    });

    function initSearchDialog($dialog) {
        // Gather the JQL auto complete data
        var appId = $("#jira-app-link").val();
        var autoCompletePromise = getJqlAutoCompleteData(appId);

        // Bind the simple search button
        $("#simple-search-panel-button", $dialog).click(function () {
            $("#search-results-table", $dialog).empty();
            var searchText = $("#link-search-text", $dialog).val();
            searchText = $.trim(searchText);
            if (searchText) {
                doSimpleSearch(searchText, $dialog);
            } else {
                AJS.messages.info("#search-results-table", {
                    body: "Please enter search value.",
                    closeable: false
                });
            }

            return false;
        });

        // Bind the advanced search button
        $("#advanced-search-panel-button", $dialog).click(function() {
            advancedSearchButtonClick($dialog);
            return false;
        });

        $("#simple-search-toggle", $dialog).click(function() {
            $("#remote-jira-simple-search-form", $dialog).show();
            $("#remote-jira-advanced-search-form", $dialog).hide();
            return false;
        });

        $("#linkjiraissue-add-selected", $dialog).click(function(){
            //select selected checkboxes of only *visible* rows
            //filtering to visible is necessary due to tabbed layout
            $("table tbody tr:visible  td.selection input:checked", $dialog).each(function(){
                var issueKey = $(this).parent().data("key");
                $("#jira-issue-keys").trigger("selectOption", [{
                    value: issueKey
                }]);
            });


            // Clear all error messages on the parent dialog, as we now have a newly selected issue
            $("#link-issue-dialog .error").hide();

            remoteJiraSearchDialog.hide();

            $("#link-issue-dialog")
                    .show()
                    .trigger("multiSelectRevealed");

            $("#jira-issue-keys-textarea").focus().select();
        });


        $("#advanced-search-toggle", $dialog).click(function() {
            $("#remote-jira-advanced-search-form", $dialog).show();
            $("#remote-jira-simple-search-form", $dialog).hide();

            // Initialise the JQL auto complete once we have the data
            // Ensure that we only initialise it once only
            var $jqlSearchText = $("#jql-search-text");
            if (!$jqlSearchText.attr("jql-initialized")) {
                setAutoCompleteLoadingIconVisible(true, $dialog);
                WRM.require("wr!jira.webresources:jqlautocomplete", function(){
                    autoCompletePromise.done(function (smartAjaxResult) {
                        if (smartAjaxResult.successful) {
                            // Enable JQL AutoComplete
                            IssueLinkJQLAutoComplete.initialize({
                                fieldID: "jql-search-text",
                                errorID: "jql-search-error",
                                autoCompleteUrl: getAutoCompleteUrl(appId),
                                autoCompleteData: smartAjaxResult.data,
                                formSubmitFunction: function() {
                                    advancedSearchButtonClick($dialog);
                                }
                            });
                        }
                        else {
                            setJQLErrorVisible(false, $dialog);
                            setAutoCompleteFailedIconVisible(true, $dialog);
                        }
                        setAutoCompleteLoadingIconVisible(false, $dialog);
                        $jqlSearchText.attr("jql-initialized", 1);
                    });
                });

            }
            $jqlSearchText.focus();

            return false;
        });

        $("#simple-search-toggle", $dialog).trigger("click");
    }

    function getAutoCompleteUrl(appId) {
        if (appId && appId !== "") {
            // Remote JIRA instance
            return contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/autocomplete?appId=" + appId;
        }
        // Local JIRA instance - will use the default URL in JQLAutoComplete
        return "";
    }

    function advancedSearchButtonClick($dialog) {
        $("#search-results-table", $dialog).empty();
        var searchText = $("#jql-search-text", $dialog).val();
        searchText = $.trim(searchText);
        if (searchText) {
            doAdvancedSearch(searchText, $dialog);
        } else {
            AJS.messages.info("#search-results-table", {
                body: "Please enter search value.",
                closeable: false
            });
        }
    }

    function setLoadingIconVisible(visible, $context) {
        $("#link-search-loading", $context).toggleClass("hidden", !visible);
    }

    function setAutoCompleteLoadingIconVisible(visible, $context) {
        $("#autocomplete-loading", $context).toggleClass("hidden", !visible);
    }

    function setAutoCompleteFailedIconVisible(visible, $context) {
        $("#autocomplete-failed", $context).toggleClass("hidden", !visible);
    }

    function setJQLErrorVisible(visible, $context) {
        $("#jql-search-error", $context).toggleClass("hidden", !visible);
    }

    function doSimpleSearch(searchText, $context) {
        setLoadingIconVisible(true, $context);
        var appId = $("#jira-app-link").val();
        var issueKeyJql = 'key = "' + searchText + '"';
        var projectJql = 'project = "' + searchText + '"';
        var plainTextJql = 'summary ~ "' + searchText + '" OR description ~ "' + searchText + '" OR comment ~ "' + searchText + '"';

        // First, check if search text is an issue key
        // We need to do this because the search will fail if it is not an issue key,
        // even if it is OR'd with a condition that returns results!
        jqlSearch(issueKeyJql, appId).done(function (smartAjaxResult) {
            if (smartAjaxResult.successful && smartAjaxResult.data.issues.length > 0) {
                setLoadingIconVisible(false, $context);
                showResults(smartAjaxResult, $context);
            } else {

                // Then check if search text is a project
                jqlSearch(projectJql, appId).done(function (smartAjaxResult) {
                    if (smartAjaxResult.successful && smartAjaxResult.data.issues.length > 0) {
                        // The search text is a project name or key
                        setLoadingIconVisible(false, $context);
                        showResults(smartAjaxResult, $context);
                    } else {

                        // Finally, a plain text search
                        jqlSearch(plainTextJql, appId).done(function (smartAjaxResult) {
                            setLoadingIconVisible(false, $context);
                            if (smartAjaxResult.successful) {
                                showResults(smartAjaxResult, $context);
                            } else {
                                showResultsError(smartAjaxResult);
                            }
                        });
                    }
                });
            }
        });
    }

    function doAdvancedSearch(jql, $context) {
        setLoadingIconVisible(true, $context);
        var appId = $("#jira-app-link").val();
        jqlSearch(jql, appId).done(function (smartAjaxResult) {
            setLoadingIconVisible(false, $context);
            if (smartAjaxResult.successful) {
                showResults(smartAjaxResult, $context);
            } else {
                if (smartAjaxResult.status === 400) {
                    AJS.messages.warning("#search-results-table", {
                        body: "Invalid JQL query.",
                        closeable: false
                    });
                } else {
                    showResultsError(smartAjaxResult);
                }
            }
        });
    }

    function jqlSearch(jql, appId) {
        var deferred = $.Deferred();
        var url;
        if (appId && appId !== "") {
            // Remote JIRA instance
            url = contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/search?jql=" + jql + "&appId=" + appId + "&maxResults=10";
        } else {
            // Local JIRA instance
            // Filter out current issue from results
            var currentIssueKey = $("#current-issue-key").val();
            jql = "(" + jql + ") and key != " + currentIssueKey;
            url = contextPath + "/rest/api/2/search?jql=" + jql + "&maxResults=10";
        }
        JIRA.SmartAjax.makeRequest({
            url: url,
            complete: function (xhr, textStatus, smartAjaxResult) {
                deferred.resolve(smartAjaxResult);
            }
        });
        return deferred.promise();
    }

    function getJqlAutoCompleteData(appId) {
        var deferred = $.Deferred();
        var remote;
        var url;
        if (appId && appId !== "") {
            // Remote JIRA instance
            url = contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/autocompletedata?appId=" + appId;
            remote = true;
        } else {
            // Local JIRA instance
            url = contextPath + "/rest/api/2/jql/autocompletedata";
            remote = false;
        }
        JIRA.SmartAjax.makeRequest({
            url: url,
            complete: function (xhr, textStatus, smartAjaxResult) {
                if (!smartAjaxResult.successful && remote) {
                    // If a remote JIRA request fails, it probably doesn't have the autocompletedata REST endpoint (added in JIRA v5.1)
                    // Get the auto complete data by parsing the issue navigator page
                    JIRA.SmartAjax.makeRequest({
                        url: contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/autocompletedata/legacy?appId=" + appId,
                        complete: function (xhr, textStatus, smartAjaxResult) {
                            deferred.resolve(smartAjaxResult);
                        }
                    });
                } else {
                    deferred.resolve(smartAjaxResult);
                }
            }
        });
        return deferred.promise();
    }

    function showResults(smartAjaxResult, $context) {
        var resultHtml = JIRA.Templates.RemoteJiraIssueSearch.resultsTable({result: smartAjaxResult.data});
        $("#search-results-table", $context).html(resultHtml);

        $("#linkjiraissue-select-all", $context).click(function(){
            var $masterStatus = $(this).prop("checked");
            $("tbody tr td.selection input", $context).prop("checked", $masterStatus);
        });

        $("tbody tr", $context).click(function (e) {

            //if we click on checkbox directly we don't want to change its value
            if($(e.target).is(":checkbox")){
                return;
            }
            var checkbox = $(this).find("td.selection input");
            checkbox.prop("checked", !checkbox.prop("checked"));


        });
    }

    function showResultsError(smartAjaxResult) {
        AJS.messages.error("#search-results-table", {
            body: JIRA.SmartAjax.buildSimpleErrorContent(smartAjaxResult),
            closeable: false
        });
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-jira-search-js', location = 'templates/dialog/linkjiraissue-search.soy' */
// This file was automatically generated from linkjiraissue-search.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.RemoteJiraIssueSearch.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.RemoteJiraIssueSearch == 'undefined') { JIRA.Templates.RemoteJiraIssueSearch = {}; }


JIRA.Templates.RemoteJiraIssueSearch.dialog = function(opt_data, opt_ignored) {
  return '<h2>' + soy.$$escapeHtml("Find JIRA issues") + '</h2><form class="aui search-form" id="remote-jira-simple-search-form" action="#" method="post"><div class="field-group"><label for="link-search-text">' + soy.$$escapeHtml("Search") + ':</label><input id="link-search-text" type="text" tabindex="0" class="text" size="50"> <input type="submit" tabindex="0" class="button" id="simple-search-panel-button" value="' + soy.$$escapeHtml("Search") + '"> <a id="advanced-search-toggle" href="#" title="' + soy.$$escapeHtml("Perform a JQL search") + '">' + soy.$$escapeHtml("Advanced Search") + '</a><span id="link-search-loading" class="icon loading throbber hidden"/></div></form><form class="aui search-form" id="remote-jira-advanced-search-form" action="#" method="post"><div class="field-group"><label for="jql-search-text">' + soy.$$escapeHtml("JQL Search") + '<span id="autocomplete-loading" class="hidden"><span class="icon loading throbber"/>' + soy.$$escapeHtml("Loading auto-complete") + '</span><span id="autocomplete-failed" class="hidden">' + soy.$$escapeHtml("(auto-complete unavailable)") + '</span></label><div id="jql-search-container"><span id="jql-search-error" class="icon jqlgood" /><div class="atlassian-autocomplete"><textarea id="jql-search-text" class="text full-width-field" tabindex="0" /></div></div><button class="aui-button aui-button-subtle search-button" id="advanced-search-panel-button" type="submit"><span class="aui-icon aui-icon-small aui-iconfont-search" title="' + soy.$$escapeHtml("Search") + '"></span></button> <a id="simple-search-toggle" href="#" title="' + soy.$$escapeHtml("Perform a plain text search") + '">' + soy.$$escapeHtml("Simple Search") + '</a><span id="link-search-loading" class="icon loading throbber hidden"/></div></form><div class="message-panel hidden"></div><div id="search-results-table" class="data-table"></div><div class="buttons-container form-footer"><div class="buttons"><button type="button" class="aui-button" id="linkjiraissue-add-selected">' + soy.$$escapeHtml("Add") + '</button><button class="aui-button aui-button-link cancel" href="#" id="remote-jira-link-cancel" title="' + soy.$$escapeHtml("Press Esc to close") + '">' + soy.$$escapeHtml("Close") + '</button></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.dialog.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.dialog';
}


JIRA.Templates.RemoteJiraIssueSearch.resultsTable = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.result.issues.length > 0) {
    output += '<table id="remote-jira-searchresult" class="aui"><thead><tr><th class="selection" ><input id="linkjiraissue-select-all" type="checkbox"/></th><th class="type">' + soy.$$escapeHtml("Type") + '</th><th class="key">' + soy.$$escapeHtml("Key") + '</th><th class="summary">' + soy.$$escapeHtml("Summary") + '</th><th class="status">' + soy.$$escapeHtml("Status") + '</th></tr></thead><tbody>';
    var issueList44 = opt_data.result.issues;
    var issueListLen44 = issueList44.length;
    for (var issueIndex44 = 0; issueIndex44 < issueListLen44; issueIndex44++) {
      var issueData44 = issueList44[issueIndex44];
      output += '<tr title="' + soy.$$escapeHtml(issueData44.key) + '"><td class="selection" data-key="' + soy.$$escapeHtml(issueData44.key) + '"><input type="checkbox"/></td><td class="type">' + JIRA.Templates.RemoteJiraIssueSearch.issueType({issueType: issueData44.fields.issuetype}) + '</td><td class="key" title="' + soy.$$escapeHtml(issueData44.key) + '">' + soy.$$escapeHtml(issueData44.key) + '</td><td class="summary" title="' + soy.$$escapeHtml(issueData44.fields.summary) + '">' + soy.$$escapeHtml(issueData44.fields.summary) + '</td><td class="status">' + JIRA.Templates.RemoteJiraIssueSearch.status({status: issueData44.fields.status}) + '</td></tr>';
    }
    output += '</tbody></table>';
  } else {
    output += '<div class="aui-message info"><span class="aui-icon icon-info"></span><p>' + soy.$$escapeHtml("Search returned no results.") + '</p></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.resultsTable.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.resultsTable';
}


JIRA.Templates.RemoteJiraIssueSearch.issueType = function(opt_data, opt_ignored) {
  return '<img src="' + soy.$$escapeHtml(opt_data.issueType.iconUrl) + '" alt="' + soy.$$escapeHtml(opt_data.issueType.name) + '" title="' + soy.$$escapeHtml(opt_data.issueType.name) + ' - ' + soy.$$escapeHtml(opt_data.issueType.description) + '"/>';
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.issueType.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.issueType';
}


JIRA.Templates.RemoteJiraIssueSearch.status = function(opt_data, opt_ignored) {
  return '' + JIRA.Template.Util.Issue.Status.issueStatusResolver({issueStatus: opt_data.status});
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.status.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.status';
}
;
;
/* module-key = 'jira.webresources:jira-analytics', location = '/includes/jira/analytics/analytics.js' */
/**
 * Capture analytics events in the JIRA general context.
 */
AJS.toInit(function($) {
    /**
     * Returns the currently selected tab on the Browse Project page
     */
    function getBrowseProjectTab() {
        return $("li.active a.browse-tab").attr("id");
    }

    // Need to defer for debugging support (see analytics-debug.js).
    _.defer(function() {
        if (AJS.EventQueue) {
            // Capture clicks on 'Administer Project' button on Browse Project page
            $(document).delegate("#project-admin-link", "click", function() {
                var selectedTab = getBrowseProjectTab();
                AJS.EventQueue.push({
                    name: "browseproject.administerproject",
                    properties: {
                        selectedtab: selectedTab
                    }
                });
            });

            // Capture clicks on 'Create New Project' button on Browse Projects page
            $(document).delegate("#browse-projects-create-project", "click", function() {
                AJS.EventQueue.push({
                    name: "browseprojects.createproject",
                    properties: {}
                });
            });

            // Capture clicks on the 'create an issue' link on the Issues tab when no issues exist in the project
            $(document).delegate("#no-issues-create-issue", "click", function() {
                AJS.EventQueue.push({
                    name: "browseproject.issuesblankslate.createissue",
                    properties: {}
                });
            });

            // Capture clicks on the issue filter links on the Issues tab
            $(document).delegate("a.issue-filter-link", "click", function() {
                var $el = $(this);
                var id = $el.attr("id").replace("filter_", "");
                var type = $el.attr("data-type");
                AJS.EventQueue.push({
                    name: "browse" + type + ".issuefilter." + id,
                    properties: {}
                });
            });

            $(document).on("click", "#project_import_link_lnk", function() {
                AJS.EventQueue.push({
                    name: "topnav.jim",
                    properties: {}
                });
            });

            $(document).on("click", ".issueaction-viewworkflow", function() {
                var classes = $(this).attr("class");
                var isNew = classes.indexOf("new-workflow-designer") > -1 || classes.indexOf("jira-workflow-designer-link") > -1;
                var version = isNew ? "new" : "old";

                var newEnabled = AJS.DarkFeatures.isEnabled("casper.VIEW_ISSUE");

                AJS.EventQueue.push({
                    name: "issue.viewworkflow",
                    properties: {
                        version: version,
                        newEnabled: newEnabled
                    }
                });
            });
        } // if (AJS.EventQueue)
    });
});
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/jquery/plugins/avataror/avataror.js' */

jQuery.fn.avataror = function (options) {
    var $ = jQuery,
        $document = $(document);
    this.each(function () {
        var $this = $(this);

        var imgsrc = $this.find("img").attr("src");
        $this.css({"-moz-border-radius": "10px", "-webkit-border-radius": "10px"});
        $this.html("<p>Loading?</p>");
        var avataror = {previewSize: 48};
        avataror.preview = $("<div/>").addClass("avataror-preview").css({border: "solid 1px #000", "float": "left", height: avataror.previewSize +"px", overflow: "hidden", width: avataror.previewSize +"px", position: "relative", top: "-9999em", left: "-9999em"});
        avataror.preview.prependTo(options.previewElement);
        avataror.img = $('<img src="' + imgsrc + '" alt="Avatar Source"/>');
        avataror.img.load(function () {
            avataror.image = $("<div/>").css({background: "url('" + imgsrc + "') no-repeat", clear: "left", position: "relative"});
            avataror.marker = $("<div/>").css({cursor: "move", position: "relative" });
            avataror.dash = $("<div/>");
            avataror.shadow = $("<div/>");
            avataror.dash.add(avataror.shadow).css({cursor: "move", opacity: .5, left: 0, top: 0, position: "absolute"});
            avataror.image.append(avataror.shadow).append(avataror.dash).append(avataror.marker);
            $this.append(avataror.image);
            avataror.marker.html('<div></div><div></div><div></div><div></div>');
            $("div", avataror.marker).each(function (i) {
                var $this = $(this);
                $this.css({background: "#000", border: "solid 1px #fff", width: "10px", height: "10px", position: "absolute", "font-size": "1px"});
                $this.css(["left", "right", "right", "left"][i], "-6px");
                $this.css(["top", "top", "bottom", "bottom"][i], "-6px");
                $this.css("cursor", ["nw-resize", "ne-resize", "se-resize", "sw-resize"][i]);
                $this.mousedown(function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    avataror.dragging = {x: e.pageX, y: e.pageY, ax: avataror.x, ay: avataror.y, w: avataror.width, h: avataror.height, i: i + 1};
                    avataror.shadow.hide();
                });
            });
            avataror.marker.add(avataror.image).mousedown(function (e) {
                e.preventDefault();
                avataror.dragging = {
                    x: e.pageX,
                    y: e.pageY,
                    ax: avataror.x,
                    ay: avataror.y,
                    w: avataror.width,
                    h: avataror.height};
                avataror.shadow.hide();
            });

            $document.mouseup(function (e) {
                avataror.handleMouseUp(e);
            });
            $document.mousemove(function (e) {
                if (avataror.dragging) {
                    avataror.handleMouseMove(e.pageX, e.pageY);
                    e.preventDefault();
                }
            });


            avataror.imgwidth = avataror.img.width();
            avataror.imgheight = avataror.img.height();
            avataror.x = parseInt($("#avatar-offsetX").val());
            avataror.y = parseInt($("#avatar-offsetY").val());
            avataror.width = parseInt($("#avatar-width").val());
            avataror.height = avataror.width;
            avataror.image.css({width: avataror.imgwidth + "px", height: avataror.imgheight + "px"});
            avataror.setMarker();

            $this.css({width: avataror.imgwidth + "px"});
            avataror.preview.css({position: "static"});
            $("p", $this).remove();
            $this.trigger("AvatarImageLoaded");
        });
        avataror.preview.append(avataror.img);

        avataror.setMarker = function () {
            avataror.marker.css("border", "dashed 1px #fff");
            avataror.dash.css("border", "solid 1px #000");
            avataror.shadow.css("border", "solid 1px #000");
            avataror.marker.add(this.dash).css("left", this.x - 1 + "px");
            avataror.marker.add(avataror.dash).css("top", avataror.y - 1 + "px");
            avataror.shadow.css("border-left-width", avataror.x + "px");
            avataror.shadow.css("border-right-width", avataror.imgwidth - avataror.x - avataror.width + "px");
            avataror.shadow.css("border-top-width", avataror.y + "px");
            avataror.shadow.css("border-bottom-width", avataror.imgheight - avataror.y - avataror.height + "px");
            avataror.shadow.css("width", avataror.width + "px");
            avataror.shadow.css("height", avataror.height + "px");
            avataror.marker.add(avataror.dash).css("width", avataror.width + "px");
            avataror.marker.add(avataror.dash).css("height", avataror.height + "px");
        };

        avataror.adjustPreview = function() {
            avataror.img.attr("width", avataror.imgwidth * avataror.previewSize / avataror.width);
            avataror.img.attr("height", avataror.imgheight * avataror.previewSize / avataror.height);
            avataror.img.css("margin-left", "-" + avataror.x * avataror.previewSize / avataror.width + "px");
            avataror.img.css("margin-top", "-" + avataror.y * avataror.previewSize / avataror.height + "px");
            avataror.preview.select();
        };

        avataror.handleMouseMove = function(newX, newY) {
            avataror.dragging.nextExec = avataror.dragging.nextExec || 0;
            if (avataror.dragging.nextExec == 0) {
                avataror.dragging.nextExec = 3;
            } else {
                avataror.dragging.nextExec--;
                return;
            }
            var dx = newX - avataror.dragging.x;
            var dy = newY - avataror.dragging.y;
            if (this.dragging.i) {
                var handler = avataror.resizeHandlers[this.dragging.i-1];
                handler(dx,dy);
            } else {
                avataror.x = avataror.dragging.ax + dx;
                avataror.y = avataror.dragging.ay + dy;
                if (avataror.x + avataror.width > avataror.imgwidth) {
                    avataror.x = avataror.imgwidth - avataror.width;
                }
                if (avataror.y + avataror.height > avataror.imgheight) {
                    avataror.y = avataror.imgheight - avataror.height;
                }
                if (avataror.x < 0) {
                    avataror.x = 0;
                }
                if (avataror.y < 0) {
                    avataror.y = 0;
                }
            }
            avataror.setMarker();
            avataror.adjustPreview();
        };

        avataror.handleMouseUp = function(e) {
//            avataror.adjustPreview();
            $("#avatar-offsetX").val(avataror.x);
            $("#avatar-offsetY").val(avataror.y);
            $("#avatar-width").val(avataror.width);
            avataror.dragging = null;
            avataror.shadow.show();
        };

        avataror.originX = function() {
            return avataror.dragging.ax;
        };
        avataror.originY = function() {
            return avataror.dragging.ay;
        };
        avataror.originBottomX = function() {
            return avataror.dragging.ax + avataror.dragging.w;
        };
        avataror.originBottomY = function() {
            return avataror.dragging.ay + avataror.dragging.h;
        };

        avataror.originNw = function() {
            return {x: avataror.originX(), y: avataror.originY()};
        };
        avataror.originNe = function() {
            return {x: avataror.originBottomX(), y: avataror.originY()};
        };
        avataror.originSe = function() {
            return {x: avataror.originBottomX(), y: avataror.originBottomY()};
        };
        avataror.originSw = function() {
            return {x: avataror.originX(), y: avataror.originBottomY()};
        };

        avataror.nwHandler = function(dx, dy) {
            var anchor = avataror.originSe();
            var tmpBase = {x: avataror.originX() + dx, y: avataror.originY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);
            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x - newSize < 0) {
                newSize = anchor.x;
            }
            if (anchor.y - newSize < 0) {
                newSize = anchor.y;
            }
            avataror.x = anchor.x - newSize;
            avataror.y = anchor.y - newSize;
            avataror.width = avataror.height = newSize;
        };

        avataror.neHandler = function(dx, dy) {
            var anchor = avataror.originSw();
            var tmpBase = {x: avataror.originBottomX() + dx, y: avataror.originY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);

            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x + newSize > avataror.imgwidth) {
                newSize = avataror.imgwidth - anchor.x;
            }
            if (anchor.y - newSize < 0) {
                newSize = anchor.y;
            }

            avataror.y = anchor.y - newSize;
            avataror.width = avataror.height = newSize;
        };

        avataror.seHandler = function(dx, dy) {
            var anchor = avataror.originNw();
            var tmpBase = {x: avataror.originBottomX() + dx, y: avataror.originBottomY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);

            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x + newSize > avataror.imgwidth) {
                newSize = avataror.imgwidth - anchor.x;
            }
            if (anchor.y + newSize > avataror.imgheight) {
                newSize = avataror.imgheight - anchor.y;
            }
            avataror.width = avataror.height = newSize;
        };

        avataror.swHandler = function(dx, dy) {
            var anchor = avataror.originNe();
            var tmpBase = {x: avataror.originX() + dx, y: avataror.originBottomY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);

            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x - newSize < 0) {
                newSize = anchor.x;
            }
            if (anchor.y + newSize > avataror.imgheight) {
                newSize = avataror.imgheight - anchor.y;
            }
            avataror.x = anchor.x - newSize;
            avataror.width = avataror.height = newSize;
        };

        avataror.resizeHandlers = [avataror.nwHandler, avataror.neHandler, avataror.seHandler, avataror.swHandler];

        // implementation
    });
};
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/Avatar.js' */
/**
 * Represents an icon for a project or some other entity in JIRA.
 *
 * @Class JIRA.Avatar
 *
 */
JIRA.Avatar = Class.extend({

    /**
     * @constructor
     * @param {object} options
     * @param {Number} options.id
     * @param {Boolean} options.isSystemAvatar
     * @param {object} [options.urls] an optional hash of avatar URLs
     */
    init: function (options) {
        this._id = options.id;
        this._isSystemAvatar = options.isSystemAvatar;
        this._isSelected = options.isSelected;
        this._urls = options.urls;
    },

    /**
     * Sets as unselected
     */
    setUnSelected: function () {
        this._isSelected = false;
    },

    /**
     * Sets as selected
     */
    setSelected: function () {
        this._isSelected = true;
    },

    /**
     * Gets selected state
     */
    isSelected: function () {
        return !!this._isSelected;
    },

    /**
     * Indicates whether the Avatar is a system-provided one or if users have defined it.
     *
     * @return {Boolean} true only if the Avatar is a system-provided one.
     */
    isSystemAvatar: function () {
        return this._isSystemAvatar;
    },

    /**
     * The database identifier for the Avatar, may be null if it hasn't yet been stored.
     *
     * @return the database id or null.
     */
    getId: function () {
        return this._id;
    },

    /**
     * Returns the URL of this avatar in the given size.
     *
     * @param {string} size an avatar size
     * @return {string} the avatar URL
     */
    getUrl: function(size) {
        return this._urls[size];
    },

    /**
     * Serilaizes the object into a JSON object
     *
     * @return {Object}
     */
    toJSON: function () {
        return {
            id: this._id,
            isSystemAvatar: this._isSystemAvatar,
            isSelected: this._isSelected,
            urls: this._urls
        };
    }
});


// Factories

/**
 * Creates custom avatar
 *
 * @param descriptor
 * ... {String} id
 */
JIRA.Avatar.createCustomAvatar = function (descriptor) {
    descriptor.isSystemAvatar = false;
    return new JIRA.Avatar(descriptor);
};

/**
 * Creates system avatar
 *
 * @param descriptor
 * ... {String} id
 */
JIRA.Avatar.createSystemAvatar = function (descriptor) {
    descriptor.isSystemAvatar = true;
    return new JIRA.Avatar(descriptor);
};

/**
 * Converts avatar size name to size object. If passed parameters is object is
 * returned unmodified.
 * @param name
 * @returns {JIRA.Avatar}
 */
JIRA.Avatar.getSizeObjectFromName = function (name) {
    if ( "object" === typeof name ) {
        return name;
    }
    var nameTrimmed = "string" === typeof name ? jQuery.trim(name) : "";
    if ( JIRA.Avatar.LARGE.param===name ) {
        return JIRA.Avatar.LARGE;
    } else if ( JIRA.Avatar.MEDIUM.param===name ) {
        return JIRA.Avatar.MEDIUM;
    } else if ( JIRA.Avatar.SMALL.param===name ) {
        return JIRA.Avatar.SMALL;
    } else if ( "xsmall"===name ) { // Java uses xmall name!#@$
        return JIRA.Avatar.SMALL;
    } else {
        return JIRA.Avatar.LARGE;
    }
};


// Sizes

/**
 * Large avatar settings
 */
JIRA.Avatar.LARGE = {
    param: "large",
    height: 48,
    width: 48
};

/**
 * Medium avatar settings
 */
JIRA.Avatar.MEDIUM = {
    param: "medium",
    width: 32,
    height: 32
};

/**
 * Small avatar settings
 */
JIRA.Avatar.SMALL = {
    param: "small",
    width: 16,
    height: 16
};

;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarManager.js' */
/**
 * Manager interface for JIRA.Avatar objects.
 *
 * You should use this for creating, manipulating and deleteing of avatars. Helper methods such as getting avatar
 * urls are also contained within this class.
 *
 * Please use the factory methods for construction
 *
 * @Class JIRA.AvatarManager
 */
JIRA.AvatarManager = Class.extend({

    /**
     * @param options
     * @param {JIRA.AvatarStore} options.store
     * @param {Number|String} options.defaultAvatarId - This is the avatar that is currently in use if no other have been selected
     * @param {Number|String} options.anonymousAvatarId - In the case of user avatar, this is the one used for logged out/or annonymous users
     * @param {String} options.avatarSrcBaseUrl - The base url used to load the avatar image
     */
    init: function (options) {
        this.store = options.store;
        this.ownerId = options.ownerId;
        this.username = options.username;
        this.anonymousAvatarId = options.anonymousAvatarId;
        this.avatarSrcBaseUrl = options.avatarSrcBaseUrl;
    },

    /**
     * Selects avatar, this will become the displayed avatar for the given type (ie project)
     *
     * @param avatar
     * @param options
     */
    selectAvatar: function (avatar, options) {
        return this.store.selectAvatar(avatar, options);
    },

    /**
     * Retrieve the avatar with the given id.
     *
     * @param avatarId must not be null.
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    getById: function (id) {
        return this.store.getById(id);
    },

    /**
     * Delete the avatar
     *
     * @param {String} avatar must not be null.
     */
    destroy: function (avatar, options) {
        this.store.destroy(avatar, options);
    },

    /**
     * Saves the avatar as an updated version of the avatar with the same id that is already in the store.
     *
     * @param {JIRA.Avatar} avatar must not be null.
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    update: function (avatar, options) {
        this.store.update(avatar, options);
    },

    /**
     * Creates a database record for the given avatar. Use the return value as the persistent avatar, not the one you
     * passed in.
     *
     * @param {JIRA.Avatar} avatar must not be null, must have a null id.
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    add: function (avatar, options) {
        this.store._add(avatar, options);
    },

    /**
     * Provides a list of all system avatars.
     *
     * Note: You will need to call refreshStore first
     *
     * @return {Array<JIRA.Avatar>} the system avatars.
     */
    getAllSystemAvatars: function () {
        return this.store.getAllSystemAvatars();
    },

    /**
     * Provides an array of all system avatars.
     *
     * Note: You will need to call refreshStore first
     *
     * @return {Array<JIRA.Avatar>} the custom avatars.
     */
    getAllCustomAvatars: function () {
        return this.store.getAllCustomAvatars();
    },

    /**
     * Gets selected avatar
     *
     * @return JIRA.Avatar
     */
    getSelectedAvatar: function () {
        return this.store.getSelectedAvatar();
    },

    /**
     *
     * Gets all avatars
     *
     * Note: You will need to call refreshStore first
     *
     * @return {Object}
     * ... {Array<JIRA.Avatar>} system
     * ... {Array<JIRA.Avatar>} custom
     */
    getAllAvatars: function () {
        return this.store.getAllAvatars();
    },

    /**
     * Gets a JSON blob, that contains the img src of each avatar based on the supplied size
     *
     * @param {JIRA.Avatar.LARGE | JIRA.Avatar.MEDIUM | JIRA.Avatar.SMALL} size
     * @return {Object}
     * ... {Array[{id, src, isSystemAvatar}]} system
     * ... {Array[{id, src, isSystemAvatar}] custom
     */
    getAllAvatarsRenderData: function (size) {

        var i,
                instance = this,
                avatars = this.getAllAvatars(),
                renderData = {
                    system: [],
                    custom: []
                };

        for (i = 0; i < avatars.system.length; i++) {
            renderData.system.push(instance.getAvatarRenderData(avatars.system[i], size));
        }

        for (i = 0; i < avatars.custom.length; i++) {
            renderData.custom.push(instance.getAvatarRenderData(avatars.custom[i], size));
        }

        return renderData;
    },

    /**
     * Gets json descriptor of given avatar that contains the img src based on the supplied size
     * @param avatar
     * @param size
     */
    getAvatarRenderData: function (avatar, size) {
        var data = avatar.toJSON();

        data.src = this.getAvatarSrc(avatar, size);
        data.width = size.width;
        data.height = size.height;


        return data;
    },

    /**
     * Refreshes avatar store
     *
     * @param options
     * ... {function} success
     * ... {function} error
     */
    refreshStore: function (options) {
        this.store.refresh(options);
    },

    /**
     *
     * @param {JIRA.Avatar} avatar
     * @param {JIRA.Avatar.LARGE | JIRA.Avatar.MEDIUM | JIRA.Avatar.SMALL} size
     * @return String
     */
    getAvatarSrc: function(avatar, size) {

        if (this.store.isTempAvatar(avatar)) {
            // if the user chooses a new temporary avatar we need to keep making this url unique so that the image is kept fresh
            return contextPath + "/secure/temporaryavatar?" + jQuery.param({
                cropped: true,
                magic: new Date().getTime(),
                size: size.param
            });
        }

        return avatar.getUrl(AJS.format('{0}x{1}', size.height, size.width));
    },

    /**
     * Creates temporary avatar from the value in the supplied file input field
     *
     * @param {HTMLElement} field
     * @param {Object} options
     * ... {function} success
     * ... {function} error
     */
    createTemporaryAvatar: function (field, options) {
        this.store.createTemporaryAvatar(field, options);
    },

    /**
     * Creates an avatar with the properties of the given avatar.
     *
     * @param {Object} instructions
     * ... {Number} cropperOffsetX
     * ... {Number} cropperOffsetY
     * ... {Number} cropperWidth
     *
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    createAvatarFromTemporary: function (instructions, options) {
        this.store.createAvatarFromTemporary(instructions, options);
    },

    /**
     * Gets the avatar id to use to represent an unknown or anonymous user
     * @return {Number} the avatar id for an anonymous user
     */
    getAnonymousAvatarId: function () {
        return this.anonymousAvatarId;
    }

});


// Factories


/**
 *
 * Creates a project avatar manager
 *
 * @param options
 * ... {String} projectKey
 * ... {String} projectId
 * ... {String} defaultAvatarId
 */
JIRA.AvatarManager.createUniversalAvatarManager = function (options) {

    // Cater for the projectKey being empty
    var restQueryUrl,
            restUpdateUrl = "",
            restCreateTempUrl = "",
            restUpdateTempUrl = "",
            restSingleAvatarUrl = "";

    if (options.projectId) {
        var urlAvatarOwnerPrefix = contextPath + "/rest/api/latest/universal_avatar/type/"+options.avatarType+"/owner/" + options.projectId;

        restQueryUrl = urlAvatarOwnerPrefix;

        var avatarCreateUrl = urlAvatarOwnerPrefix + "/avatar";

        restUpdateUrl = null;
        restCreateTempUrl = urlAvatarOwnerPrefix + "/temp";
        restUpdateTempUrl = avatarCreateUrl;
        restSingleAvatarUrl = avatarCreateUrl;
    } else {
        restQueryUrl = contextPath + "/rest/api/latest/avatar/project/system";
        restCreateTempUrl = contextPath + "/rest/api/latest/avatar/project/temporary";
        restUpdateTempUrl = contextPath + "/rest/api/latest/avatar/project/temporaryCrop";
    }

    var store = new JIRA.AvatarStore({
        restQueryUrl: restQueryUrl,
        restUpdateUrl: restUpdateUrl,
        restCreateTempUrl: restCreateTempUrl,
        restUpdateTempUrl: restUpdateTempUrl,
        restSingleAvatarUrl: restSingleAvatarUrl,
        defaultAvatarId: options.defaultAvatarId
    });

    return new JIRA.AvatarManager({
        store: store,
        ownerId: options.projectId,
        avatarSrcBaseUrl: contextPath + "/secure/projectavatar"
    });
};

/**
 *
 * Creates a project avatar manager
 *
 * @param options
 * ... {String} projectKey
 * ... {String} projectId
 * ... {String} defaultAvatarId
 */
JIRA.AvatarManager.createProjectAvatarManager = function (options) {
    options.avatarType = "project";

    return JIRA.AvatarManager.createUniversalAvatarManager(options);
};

/**
 * Creates a user avatar manager
 *
 * @param options
 * ... {String} username
 * ... {String} defaultAvatarId
 */
JIRA.AvatarManager.createUserAvatarManager = function (options) {

    var userRestUrl = contextPath + "/rest/api/latest/user";
    var store = new JIRA.AvatarStore({
        restQueryUrl: userRestUrl + "/avatars",
        restUpdateUrl: userRestUrl + "/avatar",
        restCreateTempUrl: userRestUrl + "/avatar/temporary",
        restUpdateTempUrl: userRestUrl + "/avatar",
        restSingleAvatarUrl: userRestUrl + "/avatar",
        restParams: { 'username': options.username },
        defaultAvatarId: options.defaultAvatarId
    });

    return new JIRA.AvatarManager({
        store: store,
        username: options.username,
        avatarSrcBaseUrl: contextPath + "/secure/useravatar"
    });
};
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarStore.js' */
/**
 * Persistent storage mechanism for JIRA.Avatar
 *
 * This default store uses a CRUD rest interface. There are several parameters to provide. Any optional rest URL
 * parameters are simply not invoked.
 *
 * @param restQueryUrl
 *      Mandatory. Retrieves the list of available avatars to pick from.
 *      Type: GET
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatars
 *      Response: {"system":[{"id":10001,"isSystemAvatar":true,"selected":false}], "custom": [{"id":10002,"isSystemAvatar":false,"selected":false}]}
 *
 * @param restUpdateUrl
 *      Optional. Sets the avatar as the selection for the owner.
 *      Type: PUT
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar
 *      Request: {"id":10001,"isSystemAvatar":true,"selected":false}
 *
 * @param restCreateTempUrl
 *      Mandatory. Uploads a file and stores it as the session's temporary avatar
 *      Type: Wildcard
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar/temporary
 *      Request: io stream (for supporting browsers) or multipart
 *
 * @param restUpdateTempUrl
 *      Mandatory. Crops the temporary avatar. This may also be a good time to convert it into a real avatar, but that
 *      will not always be the case, e.g. when an owner (project, user, etc) is still in the process of being created.
 *      Type: POST
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar
 *      Request: {"cropperOffsetX":"90","cropperOffsetY":"57","cropperWidth":"143"}
 *
 * @param restSingleAvatarUrl
 *      Optional. Deletes avatar.
 *      Type: DELETE
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar
 *      Request: {"id":10001,"isSystemAvatar":true,"selected":false}
 *
 * @param restParams
 *      Optional. e.g. {username: "admin"}
 *
 * @param defaultAvatarId
 *      Mandatory. Used if the currently selected avatar is deleted.
 *
 * Note: If you want to use a different storage mechanism, you can implement the same interface as here and pass it to the
 * constructor of your JIRA.AvatarManager
 */
JIRA.AvatarStore = Class.extend({

    TEMP_ID: "TEMP",

    /**
     * @constructor
     * @param options
     * ... {String} restQueryUrl - Retrieves the list of available avatars to pick from (see class description)
     * ... {String} restUpdateUrl - Sets the avatar as the selection for the owner (see class description)
     * ... {String} restCreateTempUrl - Uploads a file and stores it as the session's temporary avatar (see class description)
     * ... {String} restUpdateTempUrl - Crops the temporary avatar (see class description)
     * ... {String} restSingleAvatarUrl - Deletes avatar (see class description)
     * ... {String} restParams - The optional query parameters to append to the base URL for rest requests (see class description)
     * ... {Number} defaultAvatarId - The id of default avatar. The selected avatar if user has not selected one yet.
     */
    init: function (options) {

        if (!options.restQueryUrl) {
            throw new Error("JIRA.AvatarStore.init: You must specify [restQueryUrl], The rest url for querying avatars (see class description)");
        }

        if (!options.restCreateTempUrl) {
            throw new Error("JIRA.AvatarStore.init: You must specify [restCreateTempUrl], The rest url for creating a temporary avatar (see class description)");
        }

        if (!options.restUpdateTempUrl) {
            throw new Error("JIRA.AvatarStore.init: You must specify [restUpdateTempUrl], The rest url for updating a temporary avatar (see class description)");
        }

        if (!options.defaultAvatarId) {
            throw new Error("JIRA.AvatarStore.init: You must specify [defaultAvatarId] to the contructor so the store " +
                "knows what to select if you delete the selected one");
        }

        this.restQueryUrl = options.restQueryUrl;
        this.restUpdateUrl = options.restUpdateUrl;
        this.restCreateTempUrl = options.restCreateTempUrl;
        this.restUpdateTempUrl = options.restUpdateTempUrl;
        this.restSingleAvatarUrl = options.restSingleAvatarUrl;
        this.restParams = options.restParams || {};
        this.restParams.atl_token = atl_token();
        this.defaultAvatarId = options.defaultAvatarId;
        this.avatars = {system: [], custom: []};
    },

    /**
     * Builds the REST URL using the given url and optional restParams options.
     */
    _buildCompleteUrl: function (url) {
        var completeUrl = url;

        if (this.restParams) {
            var queryParams = '';
            for (var name in this.restParams) {
                queryParams += AJS.format('&{0}={1}', encodeURIComponent(name), encodeURIComponent(this.restParams[name]));
            }

            completeUrl += ('?' + queryParams.substr(1));
        }

        return completeUrl;
    },

    /**
     * Retrieves the Avatar by id.
     *
     * @param avatarId the avatar's id, must not be null.
     * @return the avatar with the given id or null if it doesn't exist.
     */
    getById: function (avatarId) {

        var match;

        jQuery.each(this.avatars.system, function (i, avatar) {
            if (this.getId() === avatarId) {
                match = avatar;
                return false;
            }
        });

        if (!match) {
            jQuery.each(this.avatars.custom, function (i, avatar) {
                if (this.getId() === avatarId) {
                    match = avatar;
                    return false;
                }
            });
        }

        return match;
    },

    /**
     * Checks if the given avatar is the temporarty avatar.
     *
     * @param avatar
     * @return true if it is the temporary avatar, false if otherwise.
     */
    isTempAvatar: function(avatar) {
        return (avatar.getId() === this.TEMP_ID);
    },

    /**
     * Update client side storage
     *
     * @param avatar
     */
    _selectAvatar: function (avatar) {

        var selected = this.getSelectedAvatar();

        if (selected) {
            selected.setUnSelected();
        }
        avatar.setSelected();
    },

    /**
     * Selects avatar, this will become the displayed avatar for the given type (ie project)
     *
     * @param {JIRA.Avatar} avatar
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    selectAvatar: function (avatar, options) {

        var instance = this;

        if (!avatar) {
            throw new Error("JIRA.AvatarStore.selectAvatar: Cannot select Avatar that does not exist");
        }

        if (this.restUpdateUrl) {
            JIRA.SmartAjax.makeRequest({
                type: "PUT",
                contentType: "application/json",
                dataType: "json",
                url: this._buildCompleteUrl(this.restUpdateUrl),
                data: JSON.stringify(avatar.toJSON()),
                success: function () {
                    instance._selectAvatar(avatar);
                    if (options.success) {
                        options.success.call(this, avatar);
                    }
                },
                error: options.error
            });
        } else {
            instance._selectAvatar(avatar);
            if (options.success) {
                options.success.call(this, avatar);
            }
        }
    },

    /**
     * Removes avatar in client side store
     *
     * @param {JIRA.Avatar} avatar
     */
    _destory: function (avatar) {

        var index = jQuery.inArray(avatar, this.avatars.custom);

        if (index !== -1) {
            this.avatars.custom.splice(index, 1);
        } else {
            throw new Error("JIRA.AvatarStore._destroy: Cannot remove avatar [" + avatar.getId() + "], "
                    + "it might be a system avatar (readonly) or does not exist.");
        }
    },

    /**
     * Permanently removes the avatar from the system.
     *
     * @param {JIRA.Avatar} avatar - must not be null.
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    destroy: function (avatar, options) {

        var instance = this;

        options = options || {};

        if (!avatar) {
            throw new Error("JIRA.AvatarStore.destroy: Cannot delete Avatar that does not exist");
        }

        JIRA.SmartAjax.makeRequest({
            type: "DELETE",
            url: this.getRestUrlForAvatar(avatar),
            success: function () {
                instance._destory(avatar);
                if (avatar.isSelected()) {
                    instance.selectAvatar(instance.getById(instance.defaultAvatarId), options);
                } else if (options.success) {
                    options.success.apply(this, arguments);
                }
            },
            error: options.error
        });
    },

    /**
     * Gets selected avatar, the displayed avatar for the given type (ie project)
     *
     * @return {JIRA.Avatar}
     */
    getSelectedAvatar: function () {

        for (var i = 0; i < this.avatars.custom.length; i++) {
            if (this.avatars.custom[i].isSelected()) {
                return this.avatars.custom[i];
            }
        }

        for (i = 0; i < this.avatars.system.length; i++) {
            if (this.avatars.system[i].isSelected()) {
                return this.avatars.system[i];
            }
        }
    },

    /**
     * Updates avatar in our client side store
     *
     * @param {JIRA.Avatar} avatar
     */
    _update: function (avatar) {

        var instance = this;

        if (this.getById(avatar.getId())) {
            jQuery.each(this.avatars.custom, function (i) {
                if (this.getId() === avatar.getId()) {
                    instance.avatars.custom[i] = avatar;
                }
            });
        }
        else {
            throw new Error("JIRA.AvatarStore._update: Cannot update avatar [" + avatar.getId() + "], "
                    + "it might be a system avatar (readonly) or does not exist.");
        }
    },

    /**
     * Updates an avatar's properties to match those in the given avatar. The avatar
     * to change is identified by the id of the given avatar.
     *
     * @param {JIRA.Avatar} avatar - the avatar to update, must not be null.
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    update: function (avatar, options) {

        var instance = this;

        options = options || {};

        JIRA.SmartAjax.makeRequest({
                    type: "PUT",
                    url: this.getRestUrlForAvatar(avatar),
                    error: options.error,
                    success: function () {
                        instance._update(avatar);
                        if (options.success) {
                            options.success.apply(this, arguments);
                        }
                    }
                });
    },

    /**
     * Adds avatar to our client side store
     *
     * @param avatar
     */
    _add: function (avatar) {
        if (avatar.isSystemAvatar()) {
            this.avatars.system.push(avatar);
        }
        else {
            this.avatars.custom.push(avatar);
        }
    },

    /**
     * Creates an avatar with the properties of the given avatar.
     *
     * @param {Object} instructions
     * ... {Number} cropperOffsetX
     * ... {Number} cropperOffsetY
     * ... {Number} cropperWidth
     *
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    createAvatarFromTemporary: function (instructions, options) {

        var instance = this;

        options = options || {};

        if (this.restUpdateTempUrl) {
            JIRA.SmartAjax.makeRequest({
                type: "POST",
                url: this._buildCompleteUrl(this.restUpdateTempUrl),
                data: JSON.stringify(instructions),
                contentType: "application/json",
                dataType: "json",
                success: function (data) {

                    // If no data is returned, no real avatar was created and the temporary avatar has just been updated with the cropping instructions
                    if (!data) {
                        data = {
                            id: instance.TEMP_ID,
                            isSelected: true
                        };
                    }
                    var avatar = JIRA.Avatar.createCustomAvatar(data);
                    instance._add(avatar);

                    if (options.success) {
                        options.success.call(this, data);
                    }
                },
                error: options.error
            });
        }
    },

    /**
     *
     * Creates temporary avatar on server
     *
     * @param {HTMLElement} fileInput
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    createTemporaryAvatar: function (fileInput, options) {
        // add the restParams as option
        options = AJS.$.extend(true, {}, options, { params: this.restParams });

        JIRA.AvatarUtil.uploadTemporaryAvatar(this.restCreateTempUrl, fileInput, options);
    },

    /**
     * Resets store with the Avatars created from the supplied JSON
     *
     * @param JSON avatar descriptors
     */
    _refresh: function (avatars) {

        var instance = this;

        instance.avatars.system = [];
        instance.avatars.custom = [];

        if (avatars.system) {
            jQuery.each(avatars.system, function (i, descriptor) {
                instance.avatars.system.push(JIRA.Avatar.createSystemAvatar(descriptor));
            });
        }

        if (avatars.custom) {
            jQuery.each(avatars.custom, function (i, descriptor) {
                instance.avatars.custom.push(JIRA.Avatar.createCustomAvatar(descriptor));
            });
        }
    },

    /**
     * Goes back to the server and retrievs all avatars
     *
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    refresh: function (options) {

        var instance = this;

        // Remember the temporary avatar if we have one
        var tempAvatar = this.getById(instance.TEMP_ID);

        options = options || {};

        JIRA.SmartAjax.makeRequest({
            url: this._buildCompleteUrl(this.restQueryUrl),
            error: options.error,
            success: function (avatars) {
                instance._refresh(avatars);
                if (tempAvatar) {
                    instance._add(tempAvatar);
                }
                if (options.success) {
                    options.success.apply(this, arguments);
                }
            }
        });
    },

    /**
     * Gets all avatars, custom and system
     *
     * @return {Object}
     * ... {Array<JIRA.Avatar>} system
     * ... {Array<JIRA.Avatar>} custom
     */
    getAllAvatars: function () {
        return this.avatars;
    },

    /**
     * Provides an array of all system avatars.
     *
     * @return the system avatars, never null.
     */
    getAllSystemAvatars: function () {
        return this.avatars.system;
    },

    /**
     * Provides an array of all system avatars.
     *
     * @return the custom avatars.
     */
    getAllCustomAvatars: function () {
        return this.avatars.custom;
    },

    /**
     * Gets rest url to update a single avatar
     *
     * @param avatar
     */
    getRestUrlForAvatar: function (avatar) {
        return this._buildCompleteUrl(this.restSingleAvatarUrl + "/" + avatar.getId());
    }
});
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarUtil.js' */
JIRA.AvatarUtil = {

    uploadUsingIframeRemoting: function (url, field, options) {
        options = options || {};

        var fileName = field.val(),
            form = new AJS.InlineAttach.Form(new AJS.InlineAttach.FileInput(field, false)),
            progress = form.addStaticProgress(fileName);

        //Add a new "File Input" to the form. We use the old input as part of a hidden form that we can submit to the
        //server in the background.
        var $oldInput = form.cloneFileInput();

        form.fileSelector.clear();

        //We only show progress after we are sure the upload will take longer than AJS.InlineAttach.DISPLAY_WAIT.
        var timer = new AJS.InlineAttach.Timer(function() {
            !this.cancelled && progress.show();
        }, this);

        var upload = new AJS.InlineAttach.FormUpload({
            $input: $oldInput,
            url: url,
            params: AJS.$.extend({}, options.params, {
                filename: fileName,
                atl_token: atl_token()
            }),
            scope: this,
            before: function() {
                !this.cancelled && progress.start();
            },
            success: function(val, status) {
                if (val.errorMessages && val.errorMessages.length) {
                    form.addErrorWithFileName(val.errorMessages[0], fileName, JIRA.AvatarUtil.getErrorTarget(form));
                } else if (options.success) {
                    options.success(val, status);
                }
            },
            error: function(text) {

                console.log(text);

                if (this.cancelled) {
                    return;
                }

                if (text.indexOf("SecurityTokenMissing") >= 0) {
                    form.addError(AJS.InlineAttach.Text.tr("upload.xsrf.timeout", fileName), JIRA.AvatarUtil.getErrorTarget(form));
                } else {
                    form.addError(AJS.InlineAttach.Text.tr("upload.error.unknown", fileName), JIRA.AvatarUtil.getErrorTarget(form));
                }
            },
            after: function() {

                timer.cancel();
                progress.remove();

                if (!this.cancelled) {
                    form.enable();
                }
            }
        });

        progress.onCancel(function() {
            upload.abort();
        });

        upload.upload();
    },

    uploadUsingFileApi: function (url, field, options) {

        var timer,
            upload,
            cancelled,
            file = field[0].files[0],
            form = new AJS.InlineAttach.Form(new AJS.InlineAttach.FileInput(field, false)),
            progress = form.addProgress(file);

        options = options || {};

        //We only show progress after we are sure the upload will take longer than AJS.InlineAttach.DISPLAY_WAIT.
        timer = new AJS.InlineAttach.Timer(function() {
            if (!cancelled) {
                progress.show();
            }
        });

        upload = new AJS.InlineAttach.AjaxUpload({
            file: file,
            params: AJS.$.extend({}, options.params, {
                filename: file.name,
                size: file.size,
                atl_token: atl_token()
            }),
            scope: this,
            url: url,
            before: function() {
                field.hide();
                !cancelled && progress.start();
            },
            progress: function(val) {
                progress.progress.$progress.parent().parent().show();
                !cancelled && progress.update(val);
            },
            success: function(val, status) {

                if (cancelled) {
                    return;
                }

                if (val.errorMessages && val.errorMessages.length) {
                    form.addErrorWithFileName(val.errorMessages[0], file.name, JIRA.AvatarUtil.getErrorTarget(form));
                } else if (status === 201) {
                    options.success(val, status);
                }
            },
            error: function(text, status) {


                if (status < 0) {
                    //This is a client error so just render it.
                    form.addError(text, JIRA.AvatarUtil.getErrorTarget(form));
                } else {
                    form.addError(AJS.InlineAttach.Text.tr("upload.error.unknown", file.name), JIRA.AvatarUtil.getErrorTarget(form));
                }

                if (options.error) {
                    options.error(text, status);
                }
            },
            after: function() {
                timer.cancel();
                progress.finish().remove();
                field.val("").show();
            }
        });

        upload.upload();

        progress.onCancel(function () {
            upload.abort();
        });
    },

    getErrorTarget: function (form) {
        return {
            $element: form.$form.find(".error")
        };
    },

    /**
     * Uploads temporary avatar using progress bars (if file API supported)
     *
     * @param {String} url - url to upload to, must accept any type, multipart etc
     * @param {HTMLElement} field - file input field containing file path
     * @param options
     * ... {Function} success
     * ... {Function} error
     * ... {Object} params additional query params to use in the upload request
     */
    uploadTemporaryAvatar: function (url, field, options) {
        if (AJS.InlineAttach.AjaxPresenter.isSupported(field)) {
            this.uploadUsingFileApi(url, field, options);
        } else {
            this.uploadUsingIframeRemoting(url, field, options);
        }
    }
};
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarPicker.js' */
;(function($) {

    /**
     * Creates/Renders avatar picker
     *
     * @class JIRA.AvatarPicker
     */
    JIRA.AvatarPicker = AJS.Control.extend({

        /**
         * @constructor
         * @param {Object} options
         * ... {JIRA.AvatarManager or something that implements same interface} avatarManager
         * ... {JIRA.AvatarPicker.Avatar or something that implements same interface} avatarRenderer
         * ... {JIRA.Avatar.LARGE | JIRA.Avatar.MEDIUM | JIRA.Avatar.SMALL} size
         */
        init: function (options) {
            this.avatarManager = options.avatarManager;
            this.avatarRenderer = options.avatarRenderer;
            this.imageEditor = options.imageEditor;
            this.size = options.size;
            this.selectCallback = options.select;
            this.cropperDialog = null;
            this.initialSelection = options.initialSelection;
        },

        /**
         * Renders avatar picker
         *
         * @param {Function} ready - a callback function that will be called when rendering is complete, the first
         * argument of this function will be the contents of the avatar picker. You can then append this element to wherever you
         * want the picker displayed
         */
        render: function (ready) {

            var instance = this;

            // we need to go to the server and get all the avatars first
            this.avatarManager.refreshStore({

                success: function () {
                    if (instance.cropperDialog instanceof JIRA.Dialog) {
                        instance.cropperDialog.hide();
                        delete instance.cropperDialog;
                    }
                    instance.element = $('<div id="jira-avatar-picker" />');

                    instance.element.html(JIRA.Templates.AvatarPicker.picker({
                        avatars: instance.avatarManager.getAllAvatarsRenderData(instance.size)
                    }));

                    instance._assignEvents("selectAvatar", instance.element.find(".jira-avatar button"));
                    instance._assignEvents("deleteAvatar", instance.element.find(".jira-delete-avatar"));
                    instance._assignEvents("uploader", instance.element.find("#jira-avatar-uploader"));

                    if (undefined !== instance.initialSelection) {
                        instance.getAvatarElById(instance.initialSelection).addClass("jira-selected-avatar");
                    }

                    // we are finished, call with picker contents
                    ready(instance.element);
                },
                error: function (xhr, error, textStatus, smartAjaxResult) {
                    instance.appendErrorContent(instance.element, smartAjaxResult);
                    ready(instance.element);
                }
            });
        },

        /**
         *
         * Gets the most useful error response from a smartAjaxResponse and appends it to the picker
         *
         * @param el
         * @param smartAjaxResult
         */
        appendErrorContent: function (el, smartAjaxResult) {
            try {
                var errors = JSON.parse(smartAjaxResult.data);

                if (errors && errors.errorMessages) {
                    $.each(errors.errorMessages, function (i, message) {
                        AJS.messages.error(el, {
                            body: AJS.escapeHTML(message),
                            closeable: false,
                            shadowed: false
                        });
                    });
                } else {
                    el.append(JIRA.SmartAjax.buildDialogErrorContent(smartAjaxResult, true));
                }
            } catch (e) {
                el.append(JIRA.SmartAjax.buildDialogErrorContent(smartAjaxResult, true));
            }
        },

        /**
         * Saves temporary avatar and invokes cropper
         *
         * @param {HTMLElement} field
         */
        uploadTempAvatar: function (field) {

            var instance = this;

            this.avatarManager.createTemporaryAvatar(field, {

                success: function (data) {

                    if (data.id) {
                        // We have an avatar and don't need to crop
                        instance.render(function () {
                            instance.selectAvatar(data.id);
                        });
                    } else {
                        field.val("");

                        instance.cropperDialog = new JIRA.Dialog({
                            id: "project-avatar-cropper",
                            width: 560,
                            content: function(ready) {
                                var $el = instance.imageEditor.render(data);
                                function disableSubmitButton() {
                                    var $button = $el.find("input[type=submit]");
                                    var $loader = $("<span class='icon throbber loading'></span>");
                                    $button.attr("aria-disabled", "true").attr("disabled", "");
                                    $button.before($loader);
                                    return function() {
                                        $loader.remove();
                                        $button.removeAttr("aria-disabled").removeAttr("disabled");
                                    };
                                }

                                instance.imageEditor.edit({
                                    confirm: function (instructions) {
                                        var reEnableSubmit = disableSubmitButton();
                                        instance.avatarManager.createAvatarFromTemporary(instructions, {
                                            success: function (data) {
                                                instance.render(function () {
                                                    instance.selectAvatar(data.id);
                                                });
                                            },
                                            error: reEnableSubmit
                                        });
                                    }
                                });
                                $el.find(".cancel").click(function() {
                                    instance.cropperDialog.hide();
                                });
                                ready($el);
                            }
                        });
                        instance.cropperDialog.bind("dialogContentReady", function() {
                            $(instance).trigger(JIRA.AvatarPicker.ImageEditor.LOADED);
                        });
                        instance.cropperDialog.bind("Dialog.hide", function() {
                            $(instance).trigger(JIRA.AvatarPicker.ImageEditor.DISMISSED);
                        });

                        instance.cropperDialog.show();
                    }
                },
                error: function () {
                    console.log(arguments);
                }
            });
        },

        /**
         * Gets avatar HTML element based on it's database id
         *
         * @param {String} id
         * @return {$}
         */
        getAvatarElById: function (id) {
            return this.element.find(".jira-avatar[data-id='" + id + "']");
        },

        /**
         * Selects avatar
         *
         * @param {String} id - avatar id
         */
        selectAvatar: function (id) {
            var avatar = this.avatarManager.getById(id);
            var instance = this;

            this.avatarManager.selectAvatar(this.avatarManager.getById(id), {
                error: function () {
                },
                success: function () {

                    instance.getAvatarElById(id).remove();

                    if (instance.selectCallback) {
                        instance.selectCallback.call(instance, avatar,
                                instance.avatarManager.getAvatarSrc(avatar, instance.size));
                    }
                }
            });
        },

        /**
         * Deletes avatar, shows confirmation before hand
         *
         * @param {String} id - avatar id
         */
        deleteAvatar: function (id) {

            var instance = this;

            if (confirm("Are you sure you want to delete avatar?")) {
                this.avatarManager.destroy(this.avatarManager.getById(id), {
                    error: function () {

                    },
                    success: function () {

                        var selectedAvatar = instance.avatarManager.getSelectedAvatar(),
                            $avatar = instance.getAvatarElById(id);

                        $avatar.fadeOut(function () {
                            $avatar.remove();
                        });

                        // if the avatar we have deleted is the selected avatar, then we want to set the selected avatar to be
                        // the default. This is done automagically in AvatarStore.
                        if (selectedAvatar.getId() !== id) {

                            instance.getAvatarElById(selectedAvatar.getId()).addClass("jira-selected-avatar");

                            instance.selectCallback.call(instance, selectedAvatar,
                                    instance.avatarManager.getAvatarSrc(selectedAvatar, instance.size), true);
                        }
                    }
                });
            }
        },

        _events: {
            uploader: {
                change: function (e, el) {
                    this.uploadTempAvatar(el);
                }
            },
            deleteAvatar: {
                click: function (e, el) {
                    this.deleteAvatar(el.attr("data-id"));
                }
            },
            selectAvatar: {
                click: function (e, el) {
                    // Don't select avatar if we click an overlay, such as delete icon
                    if (el[0].id === "select-avatar-button") {
                        this.selectAvatar(el.attr("data-id"));
                    }
                }
            }
        }
    });

    /**
     * Handles cropping of avatar
     *
     * @class JIRA.AvatarPicker.ImageEditor
     *
     */
    JIRA.AvatarPicker.ImageEditor = AJS.Control.extend({
        /**
         * Renders cropper
         *
         * @param {Object} data
         * ... {Number} cropperOffsetX
         * ... {Number} cropperOffsetY
         * ... {Number} cropperWidth
         */
        render: function (data) {
            this.element = $('<div id="avatar-picker-image-editor"/>').html(JIRA.Templates.AvatarPicker.imageEditor(data));
            return this.element;
        },

        /**
         * Initializes cropper
         *
         * @param {Object} options
         * ... {Function} confirm
         * ... {Function} cancel
         * ... {Function} ready
         */
        edit: function (options) {

            var instance = this,
                    avator = this.element.find(".avataror");

            options = options || {};

            avator.unbind();
            avator.bind("AvatarImageLoaded", function () {
                if (options.ready) {
                    options.ready();
                }
            });

            avator.find("img").load(function () {
                avator.avataror({
                    previewElement: instance.element.find(".jira-avatar-cropper-header"),
                    parent: instance.element
                });
            });

            this.element.find("#avataror").submit(function (e) {

                e.preventDefault();

                if (options.confirm) {
                    options.confirm({
                        cropperOffsetX: $("#avatar-offsetX").val(),
                        cropperOffsetY: $("#avatar-offsetY").val(),
                        cropperWidth: $("#avatar-width").val()
                    });
                }
            })
            .find(".cancel").click(function (e) {
                e.preventDefault();
                if (options.cancel) {
                    options.cancel();
                }
            });
        }

    });

    /**
     * Name of event fired when the image editor dialog is loaded and ready.
     */
    JIRA.AvatarPicker.ImageEditor.LOADED = "imageEditorLoaded";

    /**
     * Name of event fired when the image editor dialog is dismissed/actioned and unloaded.
     */
    JIRA.AvatarPicker.ImageEditor.DISMISSED = "imageEditorDismissed";


    /**
     * Creates project avatar picker
     *
     * @param options
     * ... {String} projectKey
     *
     * @return JIRA.AvatarPicker
     */
    JIRA.AvatarPicker.createUniversalAvatarPicker = function (options) {
        return new JIRA.AvatarPicker({
            avatarManager: JIRA.AvatarManager.createUniversalAvatarManager({
                projectKey: options.projectKey,
                projectId: options.projectId,
                defaultAvatarId: options.defaultAvatarId,
                avatarType: options.avatarType
            }),
            initialSelection: options.initialSelection,
            imageEditor: new JIRA.AvatarPicker.ImageEditor(),
            size: options.hasOwnProperty('avatarSize') ? options.avatarSize : JIRA.Avatar.LARGE,
            select: options.select
        });
    };

    /**
     * Creates project avatar picker
     *
     * @param options
     * ... {String} projectKey
     *
     * @return JIRA.AvatarPicker
     */
    JIRA.AvatarPicker.createProjectAvatarPicker = function (options) {
        return new JIRA.AvatarPicker({
            avatarManager: JIRA.AvatarManager.createProjectAvatarManager({
                projectKey: options.projectKey,
                projectId: options.projectId,
                defaultAvatarId: options.defaultAvatarId
            }),
            imageEditor: new JIRA.AvatarPicker.ImageEditor(),
            size: JIRA.Avatar.LARGE,
            select: options.select
        });
    };

    /**
     * Creates user avatar picker
     *
     * @param {Object} options
     * @param {String} options.username
     *
     * @return JIRA.AvatarPicker
     */
    JIRA.AvatarPicker.createUserAvatarPicker = function (options) {
        return new JIRA.AvatarPicker({
            avatarManager: JIRA.AvatarManager.createUserAvatarManager({
                username: options.username,
                defaultAvatarId: options.defaultAvatarId
            }),
            imageEditor: new JIRA.AvatarPicker.ImageEditor(),
            size: JIRA.Avatar.LARGE,
            select: options.select
        });
    };

    /**
     * Creates a project avatar picker dialog
     *
     * @param {Object} options
     * @param {HTMLElement | String} options.trigger - element that when clicked will bring up dialog
     * @param {String} options.projectKey
     * @param {String} options.projectId
     */
    JIRA.createUniversalAvatarPickerDialog = function (options) {
        var lastSelection = options.initialSelection || options.defaultAvatarId;

        var projectAvatarDialog = new JIRA.FormDialog({
            trigger: options.trigger,
            id: "project-avatar-picker",
            width: 600,
            stacked: true,
            content: function (ready) {

                var avatarPicker,
                        $dialogWrapper;

                $dialogWrapper = $('<div id="projectavatar-content-wrapper"/>');

                $("<h2 />").text( options.title || "Select a Project Avatar")
                        .appendTo($dialogWrapper);


                avatarPicker = JIRA.AvatarPicker.createUniversalAvatarPicker({
                    projectKey: options.projectKey,
                    projectId: options.projectId,
                    defaultAvatarId: options.defaultAvatarId,
                    initialSelection: lastSelection,
                    avatarType: options.avatarType,
                    avatarSize: options.avatarSize,
                    select: function (avatar, src, implicit) {
                        lastSelection = String(avatar.getId());

                        if (options.select) {
                            options.select.apply(this, arguments);
                        }
                        if (!implicit) {
                            projectAvatarDialog.hide();
                        }
                    }
                });

                avatarPicker.render(function (content) {
                    $dialogWrapper.append(content);
                    ready($dialogWrapper);
                });
            }
        });

        projectAvatarDialog._focusFirstField = function () {};
    };

    /**
     * Creates a project avatar picker dialog
     *
     * @param {Object} options
     * @param {HTMLElement | String} options.trigger - element that when clicked will bring up dialog
     * @param {String} options.projectKey
     * @param {String} options.projectId
     */
    JIRA.createProjectAvatarPickerDialog = function (options) {
        var projectAvatarDialog = new JIRA.FormDialog({
            trigger: options.trigger,
            id: "project-avatar-picker",
            width: 600,
            stacked: true,
            content: function (ready) {

                var avatarPicker,
                    $dialogWrapper;

                $dialogWrapper = $('<div id="projectavatar-content-wrapper"/>');

                $("<h2 />").text("Select a Project Avatar")
                        .appendTo($dialogWrapper);


                avatarPicker = JIRA.AvatarPicker.createProjectAvatarPicker({
                    projectKey: options.projectKey,
                    projectId: options.projectId,
                    defaultAvatarId: options.defaultAvatarId,
                    select: function (avatar, src, implicit) {
                        if (options.select) {
                            options.select.apply(this, arguments);
                        }
                        if (!implicit) {
                            projectAvatarDialog.hide();
                        }
                    }
                });

                avatarPicker.render(function (content) {
                    $dialogWrapper.append(content);
                    ready($dialogWrapper);
                });
            }
        });

        projectAvatarDialog._focusFirstField = function () {};
    };

    var avatarPickerData = WRM.data.claim("jira.webresources:avatar-picker.data");

    /**
     * Creates a project avatar picker dialog
     *
     * @param {Object} options
     * @param {HTMLElement | String} options.trigger - element that when clicked will bring up dialog
     * @param {String} options.projectKey
     * @param {String} options.projectId
     */
    JIRA.createUserAvatarPickerDialog = function (options) {

        if (avatarPickerData && avatarPickerData.isEnabled) {
            // SW-1977 - Defer and redirect to the Atlassian ID version.
            $(options.trigger).click(function(e) {
                var href = AJS.contextPath() + avatarPickerData.url;
                var separator = href.indexOf("?") > -1 ? "&" : "?";
                href += separator + "continue=" + encodeURIComponent(window.location.href);
                e.preventDefault();
                e.stopPropagation();
                AJS.reloadViaWindowLocation(href);
            });
            return;
        }

        var userAvatarDialog = new JIRA.FormDialog({
            trigger: options.trigger,
            id: "user-avatar-picker",
            width: 600,
            stacked: true,
            content: function (ready) {

                var avatarPicker,
                    $dialogWrapper;

                $dialogWrapper = $('<div id="useravatar-content-wrapper"/>');

                $("<h2 />").text("Select a User Avatar")
                        .appendTo($dialogWrapper);


                avatarPicker = JIRA.AvatarPicker.createUserAvatarPicker({
                    username: options.username,
                    defaultAvatarId: options.defaultAvatarId,
                    select: function (avatar, src, implicit) {

                        if (options.select) {
                            options.select.apply(this, arguments);
                        }

                        $(".avatar-image").attr("src", src);

                        if (!implicit) {
                            userAvatarDialog.hide();
                        }
                    }
                });

                avatarPicker.render(function (content) {
                    $dialogWrapper.append(content);
                    ready($dialogWrapper);
                });
            }
        });
    };

    // initialize user picker dialog
    $(function () {
        JIRA.createUserAvatarPickerDialog({
            trigger: "#user_avatar_image",
            username: $("#avatar-owner-id").text(),
            defaultAvatarId: $("#default-avatar-id").text()
        });
    });

})(window.jQuery);
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/GravatarUtil.js' */
/**
 * Helper methods for showing Gravatar-related help text.
 */
;(function() {
    AJS.namespace('JIRA.GravatarUtil');
    JIRA.GravatarUtil.showGravatarHelp = function(data) {
        // response is in the form of  { entry: [] }
        if (typeof(data) !== 'undefined' && typeof(data.entry) !== 'undefined') {
            // hide the "sign up" text and show the "log in" text
            AJS.$('.gravatar-signup-text').addClass('hidden');
            AJS.$('.gravatar-login-text').removeClass('hidden');
        }
    };

    var displayGravatarHelp = function() {
        var gravatarJsonUrl = AJS.$('#gravatar_json_url');
        if (gravatarJsonUrl.length) {
            // use JSONP to determine whether the user has a Gravatar
            AJS.$.ajax(gravatarJsonUrl.val(), {
                dataType: 'jsonp',
                success: JIRA.GravatarUtil.showGravatarHelp
            });
        }
    };

    AJS.$(document).ready(function() {
        if (AJS.$('#gravatar_help_params')) {
            displayGravatarHelp();
        }
    });
}());
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarPicker.soy' */
// This file was automatically generated from AvatarPicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.AvatarPicker.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.AvatarPicker == 'undefined') { JIRA.Templates.AvatarPicker = {}; }


JIRA.Templates.AvatarPicker.picker = function(opt_data, opt_ignored) {
  var output = '<form class="jira-avatar-upload-form aui top-label" action="#"><input name="id" value="10000" type="hidden" ><input name="pid" value="10000" type="hidden" ><div class="field-group"><label for="jira-avatar-uploader">' + soy.$$escapeHtml("Upload a new avatar") + '</label><input type="file" class="ignore-inline-attach" name="avatar" id="jira-avatar-uploader"/><div class="error"></div></div></form><div class="form-body"><ul class="jira-avatars">';
  var avatarList6 = opt_data.avatars.system;
  var avatarListLen6 = avatarList6.length;
  for (var avatarIndex6 = 0; avatarIndex6 < avatarListLen6; avatarIndex6++) {
    var avatarData6 = avatarList6[avatarIndex6];
    output += '<li class="jira-avatar jira-system-avatar ' + ((avatarData6.isSelected) ? 'jira-selected-avatar' : '') + '" title="Select this Avatar" data-id="' + soy.$$escapeHtml(avatarData6.id) + '"><button id="select-avatar-button" data-id="' + soy.$$escapeHtml(avatarData6.id) + '" class="jira-icon-button" title="' + soy.$$escapeHtml("Select this Avatar") + '"><img id="avatar-' + soy.$$escapeHtml(avatarData6.id) + '" src="' + soy.$$escapeHtml(avatarData6.src) + '" width="' + soy.$$escapeHtml(avatarData6.width) + '" height="' + soy.$$escapeHtml(avatarData6.height) + '" alt="' + soy.$$escapeHtml("Select this Avatar") + '"/></button></li>';
  }
  var avatarList29 = opt_data.avatars.custom;
  var avatarListLen29 = avatarList29.length;
  for (var avatarIndex29 = 0; avatarIndex29 < avatarListLen29; avatarIndex29++) {
    var avatarData29 = avatarList29[avatarIndex29];
    output += '<li class="jira-avatar jira-custom-avatar ' + ((avatarData29.isSelected) ? 'jira-selected-avatar' : '') + '" title="Select this avatar" data-id="' + soy.$$escapeHtml(avatarData29.id) + '"><button id="select-avatar-button" data-id="' + soy.$$escapeHtml(avatarData29.id) + '" class="jira-icon-button" title="' + soy.$$escapeHtml("Select this Avatar") + '"><img id="avatar-' + soy.$$escapeHtml(avatarData29.id) + '" src="' + soy.$$escapeHtml(avatarData29.src) + '" width="' + soy.$$escapeHtml(avatarData29.width) + '" height="' + soy.$$escapeHtml(avatarData29.height) + '" alt="' + soy.$$escapeHtml("Select this Avatar") + '" /></span><button class="jira-delete-avatar jira-icon-button" data-id="' + soy.$$escapeHtml(avatarData29.id) + '" title="' + soy.$$escapeHtml("Delete this Avatar") + '">' + soy.$$escapeHtml("Delete this Avatar") + '</button></li>';
  }
  output += '</ul></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.AvatarPicker.picker.soyTemplateName = 'JIRA.Templates.AvatarPicker.picker';
}


JIRA.Templates.AvatarPicker.imageEditor = function(opt_data, opt_ignored) {
  return '<form id="avataror" class="jira-avatar-cropper-form aui" action="/jira/secure/project/AvatarPicker.jspa"><input type="hidden" name="cropperOffsetX" id="avatar-offsetX" value="' + soy.$$escapeHtml(opt_data.cropperOffsetX) + '"><input type="hidden" name="cropperOffsetY" id="avatar-offsetY" value="' + soy.$$escapeHtml(opt_data.cropperOffsetY) + '"><input type="hidden" name="cropperWidth" id="avatar-width"  value="' + soy.$$escapeHtml(opt_data.cropperWidth) + '"><div class="jira-avatar-cropper-header"><p>' + soy.$$escapeHtml("Please select which part of the uploaded image you wish to use as the avatar.") + '</p></div><div class="form-body"><div class="avataror"><img src="' + soy.$$escapeHtml(opt_data.url) + '" height="300" /></div></div><div class="form-footer buttons-container"><div class="buttons"><input type="submit" class="aui-button aui-button-primary" value="' + soy.$$escapeHtml("Confirm") + '"><a class="aui-button aui-button-link cancel" href="#">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form>';
};
if (goog.DEBUG) {
  JIRA.Templates.AvatarPicker.imageEditor.soyTemplateName = 'JIRA.Templates.AvatarPicker.imageEditor';
}
;
;
/* module-key = 'jira.webresources:avatar-picker-trigger', location = '/includes/jira/admin/initAvatarPickerTrigger.js' */
(function () {


    var AvatarPickerContentRetriever = AJS.ContentRetriever.extend({

        init: function (avatarPicker) {
            this.avatarPicker = avatarPicker;
        },

        content: function (finished) {
            this.avatarPicker.render(function (el) {
                finished(jQuery("<div />").html(el));
            });
        },
        cache: function () {
            return false;
        },
        isLocked: function () {},
        startingRequest: function () {},
        finishedRequest: function () {}

    });


    var InlineAvatarPicker = AJS.InlineLayer.extend({

        init: function (options) {
            var instance = this;
            this.avatarPicker = JIRA.AvatarPicker.createProjectAvatarPicker({
                projectId: options.projectId,
                projectKey: options.projectKey,
                defaultAvatarId: options.defaultAvatarId,
                select: function (avatar, src, implicit) {
                    if (options.select) {
                        options.select.apply(this, arguments);
                    }
                    if (!implicit) {
                        instance.hide();
                    }

                    instance.offsetTarget().attr("src", src);
                    instance.offsetTarget().trigger("AvatarSelected");
                }
            });

            options.contentRetriever = new AvatarPickerContentRetriever(this.avatarPicker);

            jQuery(this.avatarPicker.imageEditor).bind(JIRA.AvatarPicker.ImageEditor.LOADED, function () {
                // todo: need to use prop() instead of attr() in master
                instance.setWidth(instance.layer().attr("scrollWidth"));
            });

            this._super(options);

            // Wrap the image in a little box to manage its appearance.
            var $triggerImg = this.offsetTarget();
            var $triggerContainer = jQuery("<span class='jira-avatar-picker-trigger'></span>");
            $triggerContainer.insertBefore($triggerImg).append($triggerImg);

            this._assignEvents("offsetTarget", $triggerContainer);

        },
        _events: {
            offsetTarget: {
                click: function (e) {
                    this.show();
                }
            }
        }
    });


    function initProjectAvatarPicker(ctx) {
        var trigger = jQuery(".jira-avatar-picker-trigger");
        var triggerImg = jQuery(".jira-avatar-picker-trigger img, img.jira-avatar-picker-trigger", ctx);
        var avatarIdField = jQuery(ctx).find("#avatar-picker-avatar-id");
        var avatarIconurlField = jQuery(ctx).find("#avatar-picker-iconurl");
        var avatarTypeElement = jQuery(ctx).find("#avatar-type");
        if ("" === avatarTypeElement.text()) return;
        JIRA.createUniversalAvatarPickerDialog({
            trigger: trigger,
            title: jQuery(ctx).find("#avatar-dialog-title").text(),
            projectId: jQuery(ctx).find("#avatar-owner-id").text(),
            projectKey: jQuery(ctx).find("#avatar-owner-key").text(),
            defaultAvatarId: jQuery(ctx).find("#default-avatar-id").text(),
            initialSelection: avatarIdField.val(),
            avatarSize: JIRA.Avatar.getSizeObjectFromName(jQuery(ctx).find("#avatar-size").text()),
            avatarType: avatarTypeElement.text(),
            select: function (avatar, src) {
                triggerImg.attr("src", src);
                avatarIconurlField.val(src);
                avatarIdField.val(avatar.getId());
            }
        });
    }

    function initProjectInlineAvatarPicker(ctx) {
        var $triggerImg = jQuery(".jira-inline-avatar-picker-trigger", ctx);

        if ($triggerImg.length) {
            new InlineAvatarPicker({
                offsetTarget: $triggerImg,
                projectId: jQuery(ctx).find("#avatar-owner-id").text(),
                projectKey: jQuery(ctx).find("#avatar-owner-key").text(),
                defaultAvatarId: jQuery(ctx).find("#default-avatar-id").text(),
                alignment: AJS.LEFT,
                width: 420, // Fits 7 avatars + the OSX choose file dialog min width.
                allowDownsize: true
            });
        }

    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initProjectAvatarPicker(context);
            initProjectInlineAvatarPicker(context);
        }
    });

})();;
;
/* module-key = 'jira.webresources:croneditor', location = '/includes/js/cron/croneditor.js' */
/*
Renders an element visible to the user
*/
function hideCronEdit(elementid)
{
    document.getElementById(elementid).style.display = 'none';
}

/*
Renders an element invisible to the user
*/
function showCronEdit(elementid)
{
    document.getElementById(elementid).style.display = '';
}

function toggleFrequencyControl(paramPrefix, setOriginal)
{
    var select = document.getElementById(paramPrefix + "interval");
    if(select.value == 0)
    {
        switchToOnce(paramPrefix, setOriginal);
    }
    else
    {
        switchToMany(paramPrefix, setOriginal);
    }
}

/*
Toggles the frequency controls to match 'once per day' mode
*/
function switchToOnce(paramPrefix, setOriginal)
{
    //make sure the frequency select is set correctly
    //set state
    hideCronEdit(paramPrefix + "runMany");
    showCronEdit(paramPrefix + "runOnce");
    if (setOriginal)
    {
        timesOnce[paramPrefix] = true;
    }
}

/*
Toggles the frequency controls to match 'many per day' mode
*/
function switchToMany(paramPrefix, setOriginal)
{
    //set state
    hideCronEdit(paramPrefix + "runOnce");
    showCronEdit(paramPrefix + "runMany");
    if (setOriginal)
    {
        timesOnce[paramPrefix] = false;
    }
}

function switchToDaysOfMonth(paramPrefix)
{
    hideCronEdit(paramPrefix + 'daysOfWeek');
    showCronEdit(paramPrefix + 'daysOfMonth');
    showCronEdit(paramPrefix + 'freqDiv');
    hideCronEdit(paramPrefix + 'innerFreqDiv');
    hideCronEdit(paramPrefix + 'advanced');
    switchToOnce(paramPrefix, false);
}

function switchToDaysOfWeek(paramPrefix)
{
    showCronEdit(paramPrefix + 'daysOfWeek');
    hideCronEdit(paramPrefix + 'daysOfMonth');
    showCronEdit(paramPrefix + 'freqDiv');
    showCronEdit(paramPrefix + 'innerFreqDiv');
    hideCronEdit(paramPrefix + 'advanced');
    switchToOriginal(paramPrefix);
}

function switchToDaily(paramPrefix)
{
    hideCronEdit(paramPrefix + 'daysOfWeek');
    hideCronEdit(paramPrefix + 'daysOfMonth');
    showCronEdit(paramPrefix + 'freqDiv');
    showCronEdit(paramPrefix + 'innerFreqDiv');
    hideCronEdit(paramPrefix + 'advanced');
    switchToOriginal(paramPrefix);
}

function switchToAdvanced(paramPrefix)
{
    hideCronEdit(paramPrefix + 'daysOfWeek');
    hideCronEdit(paramPrefix + 'daysOfMonth');
    hideCronEdit(paramPrefix + "runOnce");
    hideCronEdit(paramPrefix + "runMany");
    hideCronEdit(paramPrefix + 'freqDiv');
    showCronEdit(paramPrefix + 'advanced');

}

function switchToOriginal(paramPrefix)
{
    if (timesOnce[paramPrefix])
    {
        switchToOnce(paramPrefix, false);
    }
    else
    {
        switchToMany(paramPrefix, false);
    }
}
;
;
/* module-key = 'com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue-bootstrap', location = 'js/init/create-bootstrap-wrm.js' */
require([
    'jquery',
    'underscore',
    'wrm/require',
    'quick-edit/util/loading-indicator',
    'jira/ajs/keyboardshortcut/keyboard-shortcut-toggle'
], function (
    jQuery,
    _,
    wrmRequire,
    LoadingIndicator,
    KeyboardShortcutToggle
) {
    var showLoadingIndicator = function () {
        KeyboardShortcutToggle.disable();
        LoadingIndicator.showLoadingIndicator();
    };
    var hideLoadingIndicator = function () {
        LoadingIndicator.hideLoadingIndicator(true);
        KeyboardShortcutToggle.enable();
    };

    var subtaskTrigger;

    var createIssueDialogLoading = false;
    jQuery(document).on("simpleClick", ".create-issue, .create-issue-type", function(e) {
        e.preventDefault();
        if( !createIssueDialogLoading ) {
            createIssueDialogLoading = true;
            showLoadingIndicator();
            var resourceKey = 'wr!com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue';
            var wrmRequireDeferred = wrmRequire([resourceKey]);
            wrmRequireDeferred.then(onDone.bind(undefined, e), function onFail() {
                hideLoadingIndicator();
                createIssueDialogLoading = false;
            });
        }
    });
    var onDone = function (e) {
        var InitCreateDialogs = require('quick-edit/init/create');
        InitCreateDialogs.initIssueDialog(e);

        KeyboardShortcutToggle.enable();
        createIssueDialogLoading = false;
    };

jQuery(function () {
    subtaskTrigger = document.getElementById("stqc_show");

    // remove old subtask form
    if (subtaskTrigger) {
        subtaskTrigger.onclick = null;
    }
});

    var createSubtaskDialogLoading = false;
    jQuery(document).on("simpleClick", ".issueaction-create-subtask", function(e) {
        e.preventDefault();
        if (!createSubtaskDialogLoading) {
            createSubtaskDialogLoading = true;
            showLoadingIndicator();
            var resourceKey = 'wr!com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue';
            var wrmRequireDeferred = wrmRequire([resourceKey]);
            wrmRequireDeferred.then(onDoneSubtask, function onFail() {
                hideLoadingIndicator();
                createSubtaskDialogLoading = false;
            });
        }
    });
    var onDoneSubtask = function (e) {
        var InitCreateDialogs = require('quick-edit/init/create');
        InitCreateDialogs.initSubtaskDialog(e);

        KeyboardShortcutToggle.enable();
        createSubtaskDialogLoading = false;
    }
});
;
;
/* module-key = 'jira.webresources:jira-page-atl-prefetch', location = '/includes/jira/page/prefetch.js' */
define('jira/page/atl/prefetch', [
    'jira/util/data/meta',
    'jira/data/local-storage',
    'jira/ajs/dark-features',
    'jquery'
], function definePrefetchResource(meta,
    storage,
    darkFeatures,
    jQuery
) {
    /**
     * A module for pre-fetching resources for given page before it is really visited.
     * <link rel="prefetch" /> is used to instruct browser which resources to pre download.
     * Currently used to prefetch view issue resources.
     * @exports jira/issue/resources-prefetch
     */
    'use strict';

    var SESSION_KEY = 'jira.issue.prefetch.last.superbatch';
    var stateToken = _getStateToken();

    //
    // Private functions
    //
    function _getStateToken() {
        //lets use last super batch url as token with date as browser most probably removed entries from cache
        var now = new Date();
        var dateStr = now.getFullYear().toString() + now.getMonth().toString() + now.getDate().toString();
        var superbatch = jQuery('head > script').filter(function findSuperbatch(a, b) {return b.src.indexOf('/_super') > 0;});
        return (superbatch.length > 0 ? superbatch[0].src : 'empty') + dateStr;

    }

    function _addPrefetchTag(url) {
        jQuery('<link />', {
            rel: 'prefetch',
            href: url
        }).appendTo('head');
    }

    /**
     * @param {Object} issueMenuData - data for view issue menu.
     * @param {Object} [issueMenuData.sections] - optional section in view issue menu.
     */
    function _getLastIssueFromMenu(issueMenuData) {
        var sections = issueMenuData.sections;
        if (!sections) {
            return;
        }
        var recentIssues = sections.filter(function filterMenu(menuItem) {return menuItem.id === 'issues_history_main';});
        if (recentIssues.length && recentIssues[0].items.length !== 0) {
            var lastIssue = recentIssues[0].items[0];
            return lastIssue.url;
        }
    }

    function _addPrefetchForRegex(response, regex) {
        var matchResult;
        while (matchResult = regex.exec(response)) {
            var url = matchResult[1].replace(/&amp;/g, '&');
            _addPrefetchTag(url);
        }
    }

    function _rememberFetchState() {
        storage.setItem(SESSION_KEY, stateToken);

    }

    function _parsePageAndInsertLinks(data) {
        _addPrefetchForRegex(data, /<script.+?src="(.+?)".+?<\/script>/g);
        _addPrefetchForRegex(data, /<link.+?rel="stylesheet".+?href="(.+?)".+?>/g);
        _rememberFetchState();
    }

    function _shouldFetchResources() {
        if (!darkFeatures.isEnabled('jira.issue.prefetch')) {
            //don't fetch if dark feature is not enabled
            return false;
        }
        if (jQuery('#isNavigator').length === 1) {
            //don't fetch on navigator as this has the same resources as issue
            _rememberFetchState();
            return false;
        }
        else if (meta.get('issue-key')) {
            //don't fetch on issue page
            _rememberFetchState();
            return false;
        }
        else {
            //fetch if current state token is different for stored in local storage
            return stateToken !== storage.getItem(SESSION_KEY);
        }
    }
    function _prefetchResourcesForLastIssue(data) {
        var issueUrl = _getLastIssueFromMenu(data);
        if (issueUrl) {
            prefetchResourcesForUrl(issueUrl);
        }
    }
    //
    // Public API functions
    //

    function prefetchResourcesForUrl(url) {
        jQuery.get(url, _parsePageAndInsertLinks);
    }


    function prefetchViewIssueResources() {
        if (_shouldFetchResources()) {
            //only execute if we are on view issue context and
            jQuery.ajax(
                {
                    url: AJS.contextPath() + '/rest/api/1.0/menus/find_link?inAdminMode=false',
                    dataType: 'json'
                }).done(_prefetchResourcesForLastIssue);
        }
    }

    return {
        /**
         * Adds prefetch tags for resources included by page at given URL
         * @param {String} url
         */
        prefetchResourcesForUrl: prefetchResourcesForUrl,
        /**
         * Adds prefetch tags for view issue resources.
         * It will work only if user has visited any issue in the past so it is accessible from latest issues menu.
         */
        prefetchViewIssueResources: prefetchViewIssueResources
    };
});
;
;
/* module-key = 'jira.webresources:init-jira-page-atl-prefetch', location = '/includes/jira/page/initPrefetch.js' */
require(['jira/page/atl/prefetch', 'jquery'], function executePrefetch(resourcePrefetch, $) {
    $(window).on('load', resourcePrefetch.prefetchViewIssueResources.bind(resourcePrefetch));
});
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:update-plugin-banner-resources', location = 'js/banner/update-hipchat-link-banner.js' */
(function ($) {
    AJS.toInit(function () {

        var HIPCHAT_ADMIN_BANNER_COOKIE_KEY = "HIPCHAT_ADMIN_BANNER_DISMISS_2";
        var warningMsg;

        if (!isHipChatConfigurationPage() && AJS.Meta.get("is-admin") && !isAlreadyDismissed()) {

            $.ajax({
                url: AJS.contextPath() + '/rest/hipchat/integrations/1.0/configuration/status',
                dataType: 'json',
                cache: false
            }).done(function (data) {

                if (data.requiresManualInstallation || data.v1) {
                    warningMsg = showWarningMsg(data);
                }
            });

        }

        function showWarningMsg(data) {
            var html = JIRA.Templates.HipChat.Banner.updateHipChatLink({removeV1link: !data.v2 && data.v1});
            var warningMsg = JIRA.Messages.showWarningMsg(html);
            $(document).on("click", "#remove-hipchat-v1-link", removeHipChatLink);
            $(document).on("aui-flag-close", ".aui-flag", dismissPopUp);
            return warningMsg;
        }

        function isHipChatConfigurationPage() {
            return window.location.toString().indexOf("/plugins/servlet/hipchat/configure") > 0;
        }

        function dismissPopUp(e) {

            // The aui flag sends all the close events, that is why we need to filter
            // to the flag that has my container
            if ($(e.target).find(".hipchat-update-banner").length > 0) {
                AJS.Cookie.save(HIPCHAT_ADMIN_BANNER_COOKIE_KEY, true);
            }
        }

        function isAlreadyDismissed() {
            return AJS.Cookie.read(HIPCHAT_ADMIN_BANNER_COOKIE_KEY) == "true";
        }


        function removeHipChatLink(e) {
            e.preventDefault();

            $.ajax({
                url: AJS.contextPath() + '/rest/hipchat/integrations/1.0/configuration/v1',
                cache: false,
                type: "DELETE"
            }).error(function (error) {

                if(warningMsg){
                    warningMsg.hide();
                }

                JIRA.Messages.showErrorMsg(AJS.format("We couldn\'\'t find your integration. If the problem persists, contact Atlassian Support.\u003cbr/\u003e Error Status [{0}]", error.status));

            }).done(function (data) {

                if(warningMsg){
                    warningMsg.hide();
                }

                JIRA.Messages.showSuccessMsg("Integration has been removed successfully");
            });
        }
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:update-plugin-banner-resources', location = 'soy/banner/update-hipchat-link-banner.soy' */
// This file was automatically generated from update-hipchat-link-banner.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.Banner.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.Banner == 'undefined') { JIRA.Templates.HipChat.Banner = {}; }


JIRA.Templates.HipChat.Banner.updateHipChatLink = function(opt_data, opt_ignored) {
  return '<div class="hipchat-update-banner"><b>' + soy.$$escapeHtml("HipChat Integration is out of date") + '</b><p>' + soy.$$escapeHtml("Update to take full advantage of the latest features.") + '</p><p/><a href="' + soy.$$escapeHtml("/jira" + '/plugins/servlet/hipchat/configure') + '">' + soy.$$escapeHtml("Update Now!") + '</a>' + ((opt_data.removeV1link) ? '<a id="remove-hipchat-v1-link">' + soy.$$escapeHtml("Remove Integration") + '</a>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Banner.updateHipChatLink.soyTemplateName = 'JIRA.Templates.HipChat.Banner.updateHipChatLink';
}
;
;
/* module-key = 'com.atlassian.labs.plugins.quickreload.reloader:qr-batched-mode-twizzler', location = 'batchedmode/quickreload-batchedmode-switcher.js' */
;(function($, AJS) {
    if(!$) {
        console.warn("Could not find jQuery, QuickReload batch mode switcher not enabled");
        return;
    }
    if(!AJS) {
        console.warn("Could not find AJS, QuickReload batch mode switcher not enabled");
        return;
    }
    if(!$.isFunction(AJS.whenIType)) {
        console.warn("Could not find AJS.whenIType, QuickReload batch mode switcher not enabled");
        return;
    }

    //From underscore
    var debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;

        var later = function() {
            var last = Date.now() - timestamp;

            if (last < wait && last >= 0) {
                timeout = setTimeout(later, wait - last);
            } else {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                    if (!timeout) context = args = null;
                }
            }
        };

        return function() {
            context = this;
            args = arguments;
            timestamp = Date.now();
            var callNow = immediate && !timeout;
            if (!timeout) timeout = setTimeout(later, wait);
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }

            return result;
        };
    };

    var searchForContextPath = function() {
        if($.isFunction(AJS.contextPath)) {
            return AJS.contextPath();
        } else if (AJS.Meta && $.isFunction(AJS.Meta.get)) {
            try {
                return AJS.Meta.get("context-path");
            } catch(ignored) {}
        }

        return null;
    };

    var getCurrentBatchModeStateUrl = function(contextPath) {
        return contextPath + "/rest/qr/1.0/batching";
    };

    var getUpdateBatchModeUrl = function(contextPath, enableBatching) {
        return contextPath + "/rest/qr/1.0/batching/setState?enabled=" + !!enableBatching;
    };

    var tryGrabAuiFlag = function() {
        try {
            if($.isFunction(require)) {
                return require("aui/flag");
            }
        } catch(notFoundException) {}

        return null;
    };

    var getToastSuccessTitle = function(newBatchedModeState) {
        if(!!newBatchedModeState) {
            return "Production mode";
        } else {
            return "Dev mode";
        }
    };

    var getToastSuccessMessageHtml = function(newBatchedModeState) {
        if(!!newBatchedModeState) {
            return "Web resource batching and caching enabled";
        } else {
            return "Disabled web resource batching and caching";
        }
    };

    var toastSuccess = function(title, messageHtml) {
        toastMessage(title, messageHtml, true);
    };

    var toastError = function(title, messageHtml) {
        toastMessage(title, messageHtml, false);
    };

    var messageId = "quickreload-flag";
    var toastMessage = function(title, messageHtml, isSuccess) {
        var auiFlag = tryGrabAuiFlag();
        if(auiFlag) {
            auiFlag({
                type: !!isSuccess ? "success" : "error",
                title: title,
                body: messageHtml,
                persistent: false,
                close: "auto"
            });
        } else if(AJS.messages && $.isFunction(AJS.messages.success)) {
            var messageFunc;
            if(!!isSuccess) {
                messageFunc = AJS.messages.success;
            } else {
                messageFunc = AJS.messages.error;
            }

            var $message = $(messageFunc.call(AJS.messages, {
                title: title,
                body: messageHtml,
                id: messageId,
                fadeout: true,
                delay: 3000
            }));

            $("#" + messageId).remove();
            $("body").append($message);
        } else {
            alert(title);
        }
    };

    $(function() {
        var contextPath = searchForContextPath();
        if(!contextPath) {
            console.warn("Failed to determine context path, QuickReload batch mode switcher not enabled");
            return;
        }

        var batchingEnabledState = false;
        //Fetch initial state
        $.get(getCurrentBatchModeStateUrl(contextPath)).done(function(data) {
            batchingEnabledState = data.batchingEnabled;
        });

        var debouncedToggleBatchingCallback = debounce(function() {
            $.get(getUpdateBatchModeUrl(contextPath, !batchingEnabledState))
                .done(function(data) {
                    batchingEnabledState = data.batchingEnabled;
                    var successTitle = getToastSuccessTitle(batchingEnabledState);
                    var successMessageHtml = getToastSuccessMessageHtml(batchingEnabledState);
                    toastSuccess(successTitle, successMessageHtml);
                })
                .fail(function(xhr, textStatus) {
                    if(textStatus !== "abort") {
                        var batchingStateStr = batchingEnabledState ? "enabled" : "disabled";
                        toastError("Failed to update batch mode state (current state: " + batchingStateStr + ")");
                    }

                });
        }, 2000, true);

        AJS.whenIType("b").execute(debouncedToggleBatchingCallback);
    });
})((AJS && AJS.$) || $, AJS);;
;
/* module-key = 'com.atlassian.plugins.helptips.jira-help-tips:common', location = 'js/HelpTip.js' */
(function($) {
    function nope() { return false; }
    function yep() { return true; }

    var HELP_TIP_CLASSNAMES = 'jira-help-tip aui-help';

    var cidCounter = 0, seed = new Date().getTime();

    // to un-fuck graphite event names
    function cleanAnalyticsName(name) {
        name = "" + (name || "");
        return name.replace(/\./g, "-");
    }

    function analytics(eventId, model) {
        if (AJS.EventQueue && model && model.attributes.id) {
            var event = {};
            var cleanId = cleanAnalyticsName(model.attributes.id);
            var eventPrefix = "";

            if (model.attributes.eventPrefix) {
                eventPrefix = model.attributes.eventPrefix;
                // Ensure a dot at the end of the event prefix
                if (eventPrefix.charAt(eventPrefix.length - 1) !== ".") {
                    eventPrefix += ".";
                }
            }

            event.name = eventPrefix + "helptips." + cleanId + "." + eventId;
            event.properties = {};
            AJS.EventQueue.push(event);
        }
    }

    function getCid() {
        return "jira-help-tip-" + seed + (cidCounter++);
    }

    /**
     * @param attributes
     * @param attributes.id
     * @param attributes.callbacks callbacks used by helptip and passed into AJS.InlineDialog
     * @param attributes.callbacks.beforeShow {jQuery.Deferred() | Function} called before rendering the helptip
     * @param attributes.callbacks.init {Function} passed into AJS.InlineDialog as initCallback param
     * @param attributes.callbacks.hide {Function} passed into AJS.InlineDialog as hideCallback param
     * @param attributes.isSequence {Boolean} to indicate whether this helptip should be shown in sequence
     *        see https://developer.atlassian.com/design/latest/feature-discovery.html
     * @param attributes.weight {Integer} the weight of the helptip determining the order to be shown in sequence
     * @param attributes.body {String} the HTML body content of the helptip
     * @param attributes.bodyHtml {String} same as attributes.body
     * @param attributes.inlineDialogOpts {Map} passed into AJS.InlineDialog as options, This will replace all the defaults specified by HelpTip
     * @param attributes.eventPrefix {String} The prefix to use for all analytics events
     * @param attributes.nextButtonText {String} The text to be displayed on the 'next' button
     * @param attributes.closeButtonText {String} The text to be displayed on the 'close' button
     * @param attributes.showCloseButton {Boolean} Whether the 'close' button should be displayed on the helptip
     *
     * @type {Function}
     */
    var HelpTip = AJS.HelpTip = function(attributes) {
        var anchor;
        this.attributes = $.extend({}, attributes);
        this.attributes.id || (this.attributes.id = false);
        this.attributes.callbacks || (this.attributes.callbacks = {});

        //Allows the helptip to be shown in sequence via next button
        if (this.attributes.isSequence) {
            if(!this.attributes.weight) {
                this.attributes.weight = Number.MAX_VALUE;
            }
            AJS.HelpTip.Manager.sequences.push(this);
        }

        // Map renamed attribute body to bodyHtml
        if (this.attributes.body) {
            this.attributes.bodyHtml = this.attributes.body;
            delete this.attributes.body;
        }
        this.cid = getCid();
        anchor = this.attributes['anchor'];
        delete this.attributes['anchor'];

        this.view = (anchor) ? new AnchoredView(this, anchor) : new UnanchoredView(this);
    };

    $.extend(HelpTip.prototype, {
        /**
         * @param options.force render the helptip regardless of the display controller
         */
        show: function(options) {
            options = options || {};

            var self = this;
            var showDeferred = $.Deferred();
            if (this.attributes.callbacks.beforeShow) {
                var beforeShowDeferred = this.attributes.callbacks.beforeShow();
                if (beforeShowDeferred && _.isFunction(beforeShowDeferred.done)) {
                    beforeShowDeferred.done(showDeferred.resolve)
                } else {
                    showDeferred.resolve();
                }
            } else {
                showDeferred.resolve();
            }

            showDeferred.done(function() {
                AJS.HelpTip.Manager.show(function() {
                    if (!self.isDismissed()) {
                        if (!options.force && AJS.Popups && AJS.Popups.DisplayController) {
                            AJS.Popups.DisplayController.request({
                                name:self.id,
                                weight:1000,
                                show:function () {
                                    self.view.show();
                                }})
                        } else {
                            self.view.show();
                        }
                        analytics("shown", self);
                    }
                });
            });
        },
        dismiss: function() {
            var reason = cleanAnalyticsName(arguments[0] || "programmatically");
            this.view.dismiss();
            //Clicking close should stop other helptip in sequence from showing
            if (reason === "close-button" && this.attributes.isSequence) {
                AJS.HelpTip.Manager.clearSequences();
            }
            if (!this.isDismissed()) {
                AJS.HelpTip.Manager.dismiss(this);
                analytics("dismissed." + reason, this);
            }
        },
        isVisible: function() {
            return this.view.$el.is(":visible");
        },
        isDismissed: function() {
            return AJS.HelpTip.Manager.isDismissed(this);
        },

        /**
         * Redraws the help tip.
         *  - If a selector was passed as the anchor, it will check if the actual element has changed and reanchor
         *    if necessary
         *  - If the anchor is not visible, it will hide the help tip
         *  - If the anchor has moved, it will re-position the help tip
         */
        refresh: function() {
            if (!this.isDismissed()) {
                this.view.refresh();
            }
        },

        /**
         * Hide the help tip without dismissing it
         */
        hide: function() {
            if (!this.isDismissed()) {
                this.view.dismiss();
            }
        },

        /**
         * Advance to the next help tip if this help tip
         * is part of a sequence and is not the last help
         * tip in the sequence. Useful in the situation where
         * user can progress by performing some action in addition to
         * clicking the next button.
         */
        showNextHelpTipInSequence: function() {
            this.view.clickNext();
        }
    });

    var AnchoredView = function(model, anchor) {
        this.initialize(model, anchor);
    };

    $.extend(AnchoredView.prototype, {
        initialize: function(model, anchor) {
            this.model = model;
            this.anchorSelector = anchor;
            this.anchor = AJS.$(anchor);
            this._initDialog(anchor);
            AJS.$(document).bind("showLayer",function(e,type,layer) {
                if (type === "inlineDialog" && layer.id === model.cid) {
                    AJS.InlineDialog.current = null; // Tips shouldn't be considered InlineDialogs.
                    AJS.$(document.body).unbind("click."+model.cid+".inline-dialog-check");
                    layer._validateClickToClose = nope;
                    layer.hide = nope;
                }
            });
        },
        show: function() {
            this.beforeHide = nope;
            this.popup.show();
        },
        refresh: function() {
            var maybeNewAnchor = AJS.$(this.anchorSelector);
            if (!maybeNewAnchor.is(':visible')) {
                this.dismiss(); // hide
            } else if (maybeNewAnchor.get(0) !== this.anchor.get(0)) {
                this.changeAnchor(maybeNewAnchor);
            } else if (!this.isVisible()) {
                this.show();
            } else {
                this.popup.refresh();
            }
        },
        changeAnchor: function(anchor) {
            var wasVisible = this.isVisible();
            this.dismiss();
            this.$el.remove();
            this.anchor = anchor;
            this._initDialog(anchor);
            if (wasVisible) {
                this.show();
            }
        },
        dismiss: function() {
            this.beforeHide = yep;
            this._popupHide();
        },
        clickNext: function() {
            var nextButton = AJS.$(this.$el).find(".helptip-next");
            if (nextButton.length > 0) {
                nextButton.click();
            }
        },
        isVisible: function() {
            return this.$el.is(':visible');
        },
        _initDialog: function(anchor) {
            var self = this;
            var model = this.model;
            this.popup = AJS.InlineDialog($(anchor), model.cid, _.bind(this._createDialog, this), _.extend({
                // Use a container other than body, so that the positioning works when there are client-rendered banner messages
                container: "#content",
                noBind: true,
                preHideCallback: function() { return self.beforeHide() },
                calculatePositions: function(popup, targetPosition, mousePosition, opts) {
                    // Adjust positions relative to the container
                    var cssData = AJS.InlineDialog.opts.calculatePositions(popup, targetPosition, mousePosition, opts);
                    var $container = $(this.container);
                    var offset = $container.offset();
                    if (cssData.popupCss.left !== 'auto') {
                        cssData.popupCss.left -= offset.left;
                        // Inline dialog has a bug where in some scenarios both left and right pos of the popup is set.
                        cssData.popupCss.right = 'auto';
                    }
                    cssData.popupCss.top -= offset.top;
                    return cssData;
                },
                addActiveClass: false,
                initCallback: model.attributes.callbacks.init,
                hideCallback: model.attributes.callbacks.hide,
                persistent: true
            }, model.attributes.inlineDialogOpts));
            this._popupHide = this.popup.hide;
            this.popup.hide = nope;
            this.$el = $(this.popup[0]);
            this.$el.addClass(HELP_TIP_CLASSNAMES);
        },
        _createDialog: function(content, trigger, show) {
            var instance = this;
            var sequenceDialogs = AJS.HelpTip.Manager.sequences;
            var position = this.model.attributes.position;
            var isSequence = this.model.attributes.isSequence;

            content.removeClass('contents');

            content.html($(AJS.Templates.HelpTip.tipContent(_.extend({
                showNextButton: isSequence && (sequenceDialogs.length > 1 && (position+1 < sequenceDialogs.length)),
                length: sequenceDialogs.length,
                position: position,
                showCloseButton: true
            }, this.model.attributes))));

            content.unbind('mouseover mouseout');
            content.find(".helptip-link").click(function() {
                analytics("learn-more.clicked", instance.model);
            });
            content.find(".helptip-close").click(function(e) {
                e.preventDefault();
                instance.model.dismiss("close-button");
            });
            content.find(".helptip-next").click(function(e) {
                e.preventDefault();
                instance.model.dismiss("next-button");
                var next = position + 1;
                sequenceDialogs[next] && (sequenceDialogs[next].show({force: true}));
            });
            show();
        }
    });

    var UnanchoredView = function(model) {
        this.initialize(model);
    };

    $.extend(UnanchoredView.prototype, {
        initialize: function() {
            this.$el = $("<div></div>");
            this.$el.addClass(HELP_TIP_CLASSNAMES);
        },
        show: function() { },
        dismiss: function() { }
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.plugins.helptips.jira-help-tips:common', location = 'js/HelpTipManager.js' */
(function($) {
    var restUrl = AJS.contextPath() + "/rest/helptips/1.0/tips";
    var tipWRMData = undefined;
    if (WRM && WRM.data) {
        tipWRMData = WRM.data.claim("com.atlassian.plugins.helptips.jira-help-tips:common.JiraHelpTipData");
    }

    var Manager = {
        dismissedTipIds: [],
        sequences: [],
        loaded: $.Deferred(),
        url: function() { return restUrl; },
        sync: function(verb, data) {
            var result = $.Deferred();
            verb || (verb = "get");
            data || (data = null);
            if (verb === "get" && tipWRMData && tipWRMData.dismissed) {
                result.resolve(tipWRMData.dismissed);
            } else {
                $.ajax(this.url(), {
                    type: verb,
                    dataType: "json",
                    contentType: "application/json",
                    data: data && JSON.stringify(data),
                    processData: false
                })
                    .done(function(data) {
                        result.resolve(data);
                    })
                    .fail(function() {
                        result.reject();
                    });
            }
            return result.promise();
        },
        fetch: function() {
            var result = this.sync();
            result.done($.proxy(function(response) {
                $.merge(this.dismissedTipIds, response);
                this.loaded.resolve();
            }, this));
            return result.promise();
        },
        show: function(showFunction) {
            this.loaded.done(showFunction);
        },
        dismiss: function(tip) {
            var id = tip.attributes.id;
            if (!id) {
                tip._dismissed = true;
            } else {
                this.dismissedTipIds.push(id);
                this.sync("post", {id:id});
            }
        },
        undismiss: function(tip) {
            var id = tip.attributes.id;
            if (!id) {
                tip._dismissed = false;
            } else {
                this.dismissedTipIds.splice($.inArray(id, this.dismissedTipIds), 1);
                this.sync("delete", {id:id});
            }
        },
        isDismissed: function(tip) {
            var id = tip.attributes.id;
            return (id) ? $.inArray(id, this.dismissedTipIds) >= 0 : tip._dismissed;
        },
        /**
         * Clear the list of helptips that would be shown in sequence
         */
        clearSequences: function() {
            this.sequences = [];
        },
        /**
         * Hide all the helptips that would be shown in sequence
         */
        hideSequences: function() {
            _.each(this.sequences, function(helptip) {
                helptip.view.dismiss();
            });
        },
        /**
         * Initiate the rendering of helptips in sequence starting from the first one
         */
        showSequences: function() {
            if (!this._showStarted) {
                var instance = this;
                var index = 0;
                this._showStarted = true;
                $.when(this.loaded).done(function() {
                    //Sort by weight
                    instance.sequences.sort(function(a, b) {
                        return a.attributes.weight - b.attributes.weight;
                    });
                    //Remove any helptips that have already been dismissed
                    instance.sequences = _.filter(instance.sequences, function(dialog) {
                        var shouldShow = _.indexOf(instance.dismissedTipIds, dialog.attributes.id) === -1;
                        if (shouldShow) {
                            dialog.attributes.position = index++;
                        }
                        return shouldShow;
                    });
                    if (instance.sequences.length > 0) {
                        //SW-1740: Ensure the last tip part of a sequence always shows the close button. Filtering out already dismissed
                        // tips above may have changed the original last tip.
                        _.last(instance.sequences).attributes.showCloseButton = true;

                        instance.sequences[0].show({force: true});
                    }
                    instance._showStarted = false;
                });
            }
        }
    };

    // Check if the user is logged in, otherwise the REST resource will return a status of 401 (Unauthorized)
    if (!JIRA.Users.LoggedInUser.isAnonymous()) {
        AJS.HelpTip.Manager = Manager;
        // Load up the user's dismissed tips.
        Manager.fetch();
    }
})(AJS.$);;
;
/* module-key = 'com.atlassian.plugins.helptips.jira-help-tips:common', location = 'templates/HelpTip.soy' */
// This file was automatically generated from HelpTip.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace AJS.Templates.HelpTip.
 */

if (typeof AJS == 'undefined') { var AJS = {}; }
if (typeof AJS.Templates == 'undefined') { AJS.Templates = {}; }
if (typeof AJS.Templates.HelpTip == 'undefined') { AJS.Templates.HelpTip = {}; }


AJS.Templates.HelpTip.tipContent = function(opt_data, opt_ignored) {
  return ((opt_data.title) ? '<h2 class="helptip-title">' + soy.$$escapeHtml(opt_data.title) + '</h2>' : '') + '<p class="helptip-body">' + soy.$$filterNoAutoescape(opt_data.bodyHtml) + '</p>' + ((opt_data.url) ? '<p><a class="helptip-link" href="' + soy.$$escapeHtml(opt_data.url) + '" target="_blank">' + ((opt_data.linkText) ? soy.$$escapeHtml(opt_data.linkText) : soy.$$escapeHtml("Learn more")) + '</a></p>' : '') + AJS.Templates.HelpTip.tipFooter(opt_data);
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.tipContent.soyTemplateName = 'AJS.Templates.HelpTip.tipContent';
}


AJS.Templates.HelpTip.tipFooter = function(opt_data, opt_ignored) {
  return '<form class="tip-footer">' + AJS.Templates.HelpTip.nextButton(opt_data) + AJS.Templates.HelpTip.closeButton(opt_data) + AJS.Templates.HelpTip.sequencePaging(opt_data) + '</form>';
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.tipFooter.soyTemplateName = 'AJS.Templates.HelpTip.tipFooter';
}


AJS.Templates.HelpTip.nextButton = function(opt_data, opt_ignored) {
  return '' + ((opt_data.showNextButton) ? '<button class="aui-button helptip-next" type="button">' + ((opt_data.nextButtonText) ? soy.$$escapeHtml(opt_data.nextButtonText) : soy.$$escapeHtml("Next")) + '</button>' : '');
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.nextButton.soyTemplateName = 'AJS.Templates.HelpTip.nextButton';
}


AJS.Templates.HelpTip.closeButton = function(opt_data, opt_ignored) {
  return '' + ((opt_data.showCloseButton) ? '<button class="aui-button ' + ((opt_data.showNextButton) ? ' aui-button-link ' : '') + ' helptip-close" type="button">' + ((opt_data.closeButtonText) ? soy.$$escapeHtml(opt_data.closeButtonText) : soy.$$escapeHtml("Close")) + '</button>' : '');
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.closeButton.soyTemplateName = 'AJS.Templates.HelpTip.closeButton';
}


AJS.Templates.HelpTip.sequencePaging = function(opt_data, opt_ignored) {
  return '' + ((opt_data.isSequence && opt_data.length > 1) ? '<span class="helptip-sequence-paging">' + soy.$$escapeHtml(opt_data.position + 1) + '/' + soy.$$escapeHtml(opt_data.length) + '</span>' : '');
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.sequencePaging.soyTemplateName = 'AJS.Templates.HelpTip.sequencePaging';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:newsletter-signup-tip', location = 'static/components/newsletter/NewsletterSignup.soy' */
// This file was automatically generated from NewsletterSignup.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }


JIRA.Templates.newsletterSignupTip = function(opt_data, opt_ignored) {
  return '<div><p>' + soy.$$escapeHtml(opt_data.description) + '</p>' + aui.form.form({action: '#', isTopLabels: true, extraClasses: 'insiders-signup-form', content: '' + aui.form.textField({id: 'jira-newsletter-user-email', placeholderText: '' + soy.$$escapeHtml("Email address"), value: opt_data.userEmail}) + aui.form.buttons({content: '' + aui.form.submit({type: 'primary', text: '' + soy.$$filterNoAutoescape("Sign me up")}) + aui.form.linkButton({text: '' + soy.$$escapeHtml("No thanks")})})}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.newsletterSignupTip.soyTemplateName = 'JIRA.Templates.newsletterSignupTip';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:newsletter-signup-tip', location = 'static/components/newsletter/NewsletterSignup.js' */
define('jira/newsletter/signuptip', [
    'jquery'
], function(
    $
) {

    // taken from setup-mac-util.js
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address without &
    var emailRegex = /^[a-zA-Z0-9.!#$%'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

    function validateEmail(email) {
        if (email.length > 255) {
            return false;
        }
        return emailRegex.test(email);
    }

    return {
        render : function (newsletterFormDetails, helpTipOptions) {
            var defaults = {
                anchor: "#user-options",
                isSequence: false,
                showCloseButton: false
            };

            if (newsletterFormDetails.isBusinessOnly) {
                defaults.id = "business-newsletter-signup-tip";
                defaults.title = "Atlassian for Business Teams";
                defaults.bodyHtml = JIRA.Templates.newsletterSignupTip({
                    userEmail: newsletterFormDetails.userEmail,
                    description: "Atlassian gets down to business. Get our view on productivity for business teams. You\'ll get business-related content, best practices and product announcements to unleash the potential in your marketing, HR, finance, legal and sales teams."
                });
            } else {
                defaults.id = "newsletter-signup-tip";
                defaults.title = "JIRA Insiders";
                defaults.bodyHtml = JIRA.Templates.newsletterSignupTip({
                    userEmail: newsletterFormDetails.userEmail,
                    description: "Stay up-to-date with the latest JIRA tips, tricks, and exclusive inside jokes. All this and more in JIRA Insiders, delivered every month from our inbox to yours."
                });
            }
            var tip = new AJS.HelpTip($.extend(defaults, helpTipOptions));
            if(tip.isDismissed()) {
                return;
            }

            tip.show();

            AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.shown" });

            var $body = $("body");
            $body.on("submit", "form.aui.insiders-signup-form", function (e) {
                e.preventDefault();

                var $form = $(this);
                $form.find(".error").remove();

                var $emailInput = $form.find("#jira-newsletter-user-email");
                var email = $emailInput.val();
                if (validateEmail(email)) {
                    $.ajax({
                        type: 'POST',
                        url: AJS.format(newsletterFormDetails.formUrl, encodeURI(email)),
                        dataType: 'json'
                    }).success(function() {
                        AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.submitted" });
                    }).error(function(xhr) {
                        AJS.trigger('analyticsEvent', {
                            name: "jira.newsletter.signuptip.error",
                            data: {
                                statusCode: xhr.status
                            }
                        });
                    });

                    if(newsletterFormDetails.userEmail !== email) {
                        AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.email.changed" });
                    }

                    tip.dismiss("newslettersubscribed");
                }
                else {
                    AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.email.validationerror" });
                    $emailInput.after(aui.form.fieldError({message: "Please enter a valid e-mail address."}));
                }
            });

            $body.on("click", "form.aui.insiders-signup-form a.cancel", function (e) {
                e.preventDefault();
                AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.dismissed" });
                tip.dismiss("newslettercancelled");
            });
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:newsletter-signup-tip', location = 'static/components/newsletter/initNewsletterSignup.js' */
define('jira/newsletter/init-signup', [
    'jira/newsletter/signuptip'
], function (NewsletterSignup) {
    return function () {
        var newsletterSignupData = WRM.data.claim("com.atlassian.jira.jira-header-plugin:newsletter-signup-tip.newsletterSignup");

        if (newsletterSignupData && newsletterSignupData.showNewsletterTip) {
            NewsletterSignup.render({
                userEmail: newsletterSignupData.userEmail,
                formUrl: newsletterSignupData.formUrl,
                isBusinessOnly: newsletterSignupData.isBusinessOnly
            });
        }
    };
});

require([
    'jquery',
    'jira/newsletter/init-signup'
], function ($,
    InitNewsletterSignup) {
    $(InitNewsletterSignup);
});

;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/dialog.js' */
define('jira/admin-helper/dialog', [
    'jquery',
    'jira/dialog/dialog',
    'jira/focus/set-focus'
], function (
    $,
    Dialog,
    setFocus
) {

    return Dialog.extend({

        _getDefaultOptions: function () {
            return $.extend(this._super(), {
                cached: false,
                widthClass: "large",
                stacked: true
            });
        },

        defineResources: function() {
            this._super();
            this.requireResource("com.atlassian.jira.plugins.jira-admin-helper-plugin:whereismycf-resources");
        },

        decorateContent: function () {

            var instance = this;

            // init the close link
            this.get$popupContent().find(".cancel").click(function (e) {
                instance.hide();
                e.preventDefault();
            });
        },

        _onShowContent: function () {
            this._super();
            if (Dialog.current === this) {
                var triggerConfig = new setFocus.FocusConfiguration();
                triggerConfig.context = this.get$popup()[0];
                triggerConfig.parentElementSelectors = ['.form-body'];
                setFocus.pushConfiguration(triggerConfig);
                setFocus.triggerFocus();
            }
        },

        hide: function (undim) {

            if (this._super(undim) === false) {
                return false;
            }
            setFocus.popConfiguration();
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/notification-helper-init.js' */
require([
    'jquery',
    'jira/admin-helper/dialog',
    'jira/util/data/meta'
], function (
    $,
    Dialog,
    Meta
) {
    if (Meta.get("is-admin")) {

        $(document).delegate(".notificationhelper-trigger", "click", function (event) {
            event.preventDefault();
            new Dialog({
                id: "notification-helper-dialog",
                content: function content(callback) {
                    var dialog = this;
                    require(['jira/admin-helper/notification-helper/content-loader'],
                        function (ContentLoader) {
                            ContentLoader.loadContent(dialog, callback);
                        });
                }
            }).show();
        });
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/permission-helper-init.js' */
require([
    'jquery',
    'jira/admin-helper/dialog',
    'jira/util/data/meta'
], function (
    $,
    Dialog,
    Meta
) {
    if (Meta.get("is-admin")) {

        $(document).delegate(".permissionhelper-trigger", "click", function (event) {
            event.preventDefault();

            new Dialog({
                id: "permission-helper-dialog",
                content: function content(callback) {
                    var dialog = this;
                    require(['jira/admin-helper/permission-helper/content-loader'],
                        function (ContentLoader) {
                            ContentLoader.loadContent(dialog, callback);
                        });
                }
            }).show();
        });
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/whereismycf-init.js' */
require([
    'jquery',
    'jira/admin-helper/dialog',
    'jira/util/data/meta',
    'jira/dialog/dialog'
], function (
    $,
    Dialog,
    Meta,
    JiraDialog
) {
    if (Meta.get("is-admin")) {
        var LABEL = "Where is my field?";

        $(document).delegate(".whereismycf-trigger", "click", function (event) {
            event.preventDefault();
            new Dialog({
                id: "whereismycf-dialog",
                content: function content(callback) {
                    var dialog = this;
                    require(['jira/admin-helper/whereismycf/content-loader'],
                        function (ContentLoader) {
                            ContentLoader.loadContentForView(dialog, callback);
                        });
                }
            }).show();

        });
        // hook into the quick-edit
        $(document).bind("showLayer", function (event, control, hash) {
            if (control == "inlineDialog" && hash.popup.attr("id") == "inline-dialog-field_picker_popup") {
                if (hash.popup.find(".whereismycf-qfpicker-link").length == 0) {
                    var thelink = $("<a href='#' class='whereismycf-qfpicker-link'>" + LABEL + "</a>").appendTo(hash.popup.find(".qf-picker-header dl"));
                    thelink.click(function (event) {
                        event.preventDefault();
                        hash.hide();
                        eventsAndDecouplingInJavaScriptAreSoooAwesome();
                        var currentDialog = JiraDialog.current;
                        new Dialog({
                            id: "whereismycf-dialog",
                            content: function content(callback) {
                                var dialog = this;
                                require(['jira/admin-helper/whereismycf/content-loader'],
                                    function (ContentLoader) {
                                        ContentLoader.loadContentForEditAndCreate(dialog, currentDialog, callback);
                                    });
                            }
                        }).show();

                    });
                }
            }
        });

        function eventsAndDecouplingInJavaScriptAreSoooAwesome() {
            // we're doing this because LayerManager wants to outsmart the world by deciding what to hide and what not...
            // and InlineDialog (and everything else in AUI) wants to outsmart the world by applying stupid timeouts to everything...
            // but ultimately you can outsmart every smartass in the JS land just by setting global variables to null! BUAHAHAHAHAHAHA
            AJS.InlineDialog.current = null;
        }
    }
});;
;
/* module-key = 'com.atlassian.jira-core-project-templates:jira-core-project-templates-resources', location = '/soy/CoreProjectTemplates.soy' */
// This file was automatically generated from CoreProjectTemplates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.CoreTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }
if (typeof JIRA.Templates.ProjectTemplates.CoreTemplates == 'undefined') { JIRA.Templates.ProjectTemplates.CoreTemplates = {}; }


JIRA.Templates.ProjectTemplates.CoreTemplates.taskManagementInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Create simple tasks, organize them and get them done. You can use this project to manage your tasks or assign them to someone else.", projectTemplate: 'taskManagement'});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.taskManagementInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.taskManagementInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.projectManagementInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Create your tasks, organize and track their progress, and deliver your work on time. Estimations and time tracking allow you to report on where your project is at any stage.", projectTemplate: 'projectManagement'});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.projectManagementInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.projectManagementInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.processManagementInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Create your tasks and track them at every step, from start to finish. You can use this project to review documentation, approve expenses, or other processes.", projectTemplate: 'processManagement'});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.processManagementInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.processManagementInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.boardBetaInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Visualize work across your team with a board.", projectTemplate: 'projectManagement', issueTypesHtml: '' + JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType(null)});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.boardBetaInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.boardBetaInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog = function(opt_data, opt_ignored) {
  return '<div><div class="top-panel"><p>' + soy.$$escapeHtml(opt_data.description) + '</p></div><div class="left-panel"><h6>' + soy.$$escapeHtml("Issue Types") + '</h6><ul class="project-template-issuetype-list">' + ((opt_data.issueTypesHtml != null) ? soy.$$filterNoAutoescape(opt_data.issueTypesHtml) : JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType(null) + JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType(null)) + '</ul></div><div class="right-panel"><h6>' + soy.$$escapeHtml("Workflow") + '</h6><div class="workflow ' + soy.$$escapeHtml(opt_data.projectTemplate) + '"></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.issueType = function(opt_data, opt_ignored) {
  return '<li><span class="issuetype-list-label"><span class="issuetype-icon ' + soy.$$escapeHtml(opt_data.iconKey) + '"></span><span class="issuetype-name">' + soy.$$escapeHtml(opt_data.label) + '</span></span></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.issueType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.issueType';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.issueType({iconKey: 'task', label: "Task"});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.issueType({iconKey: 'subtask', label: "Sub-task"});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-confluence-plugin:issue-link-confluence-js', location = 'js/issuelink-confluence.js' */
/**
 * Initialises OAuth authentication for Confluence Application Links. Requires the following elements:
 * <div class="issue-link-applinks-authentication-message"></div>
 */
(function ($) {

    var settings = {
        getCurrentAppId: function (context) {
            return $("#issue-link-confluence-app-id", context).val();
        },
        shouldExecute: function (context) {
            return $("#confluence-page-link", context).length !== 0;
        },
        getIssueId: function (context) {
            return $("input[name=id]", context).val();
        }
    };

    JIRA.bind(JIRA.Events.NEW_PAGE_ADDED, function (e, context) {
        IssueLinkAppLinks.init(settings, context);
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-confluence-plugin:confluence-page-resource', location = 'js/ConfluencePageSearch.js' */
AJS.$(function ($) {
    var confluenceSearchDialog =  new JIRA.FormDialog({
        id: "confluence-page-search-dialog",
        trigger: "#confluence-page-link .confluence-search-trigger",
        widthClass: "large",
        height: "565px",
        content: function (render) {
            var dialog = this;
            JIRA.SmartAjax.makeRequest({
                url: contextPath + "/rest/confluenceIssueLink/1/confluence/applink",
                complete: function (xhr, textStatus, smartAjaxResult) {
                    if (smartAjaxResult.successful) {
                        var appLinks = smartAjaxResult.data.applicationLinks;
                        render(JIRA.Templates.ConfluencePageSearch.result({appLinks: appLinks}));

                        initAppLinks(dialog).done(function (context, helper) {
                            initSearchDialog(context, helper);
                            $("#link-search-text", context).focus();
                        });
                    } else {
                        AJS.messages.error("#search-results-table", {
                            body: "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.",
                            closeable: false
                        });
                        render();
                    }
                }
            });
        },
        submitHandler: function(e, callback){
            e.preventDefault();
            $("#search-panel-button").click().removeAttr("disabled");
            callback();
        }
    });

    function initSearchDialog($dialog, helper) {
        // Bind the select drop-down
        $("#confluence-app-link", $dialog).change(function () {
            var authenticationRequired = helper.selectServer($(this).val()).authenticationRequired;
            if (!authenticationRequired) {
                populateSpaces($dialog, $(this).val(), helper);
            }
            $("#search-results-table", $dialog).empty();

            // Any previous errors are not relevant to our new selection
            setSearchControlsEnabled(true, $dialog);
        });

        // Bind the search button
        $("#search-panel-button", $dialog).click(function () {
            $("#search-results-table", $dialog).empty();
            var searchText = $("#link-search-text", $dialog).val();
            searchText = $.trim(searchText);
            if (searchText) {
                doSearch(searchText, $dialog);
            } else {
                AJS.messages.info("#search-results-table", {
                    body: "Please enter search value.",
                    closeable: false
                });
            }

            return false;
        });
    }

    var spaceAjaxId = 0;
    function populateSpaces($context, appId, helper) {
        $("select#search-panel-space", $context).html(JIRA.Templates.ConfluencePageSearch.allSpacesOption());
        var myAjaxId = ++spaceAjaxId;
        JIRA.SmartAjax.makeRequest({
            url: contextPath + "/rest/confluenceIssueLink/1/confluence/space?appId=" + appId,
            complete: function (xhr, textStatus, smartAjaxResult) {
                if (myAjaxId !== spaceAjaxId) {
                    return;
                }
                if (smartAjaxResult.successful) {
                    var spaces = smartAjaxResult.data.spaces;
                    $("select#search-panel-space", $context).html(JIRA.Templates.ConfluencePageSearch.spaceOptions({spaces: spaces}));
                } else {
                    if (smartAjaxResult.status === 401) {
                        helper.setAuthenticationRequired(appId, true);
                    } else {
                        // Since we have an error, prevent the user from submitting a search
                        setSearchControlsEnabled(false, $context);

                        var msg;
                        if (smartAjaxResult.status === 403) {
                            msg = "Content on the Confluence site could not be accessed because the Confluence server\'s \'Remote API\' feature is disabled. The Confluence system administrator must enable this \'Remote API\' feature for JIRA to successfully access this content.";
                        } else {
                            msg = "Unable to gather information from the selected Confluence instance.";
                        }
                        AJS.messages.error("#search-results-table", {
                            body: msg,
                            closeable: false
                        });
                    }
                }
            }
        });
    }

    function setSearchControlsEnabled(enabled, $context) {
        if (enabled) {
            $("#link-search-text", $context).removeAttr("disabled");
            $("#search-panel-space", $context).removeAttr("disabled");
            $("#search-panel-button", $context).removeAttr("disabled");
        } else {
            $("#link-search-text", $context).attr("disabled", "disabled");
            $("#search-panel-space", $context).attr("disabled", "disabled");
            $("#search-panel-button", $context).attr("disabled", "disabled");
        }
    }

    function setLoadingIconVisible(visible, $context) {
        $("#link-search-loading", $context).toggleClass("hidden", !visible);
    }

    function doSearch(searchText, $context) {
        setLoadingIconVisible(true, $context);
        var appLinkId = $("#confluence-app-link", $context).val();
        var spaceKey = $("#search-panel-space option:selected", $context).val();
        JIRA.SmartAjax.makeRequest({
            url: contextPath + "/rest/confluenceIssueLink/1/confluence/search?query=" + searchText + "&appId=" + appLinkId + "&spaceKey=" + spaceKey + "&maxResults=10",
            complete: function (xhr, textStatus, smartAjaxResult) {
                setLoadingIconVisible(false, $context);
                if (smartAjaxResult.successful) {
                    var results = smartAjaxResult.data.result;
                    var resultHtml = JIRA.Templates.ConfluencePageSearch.resultsTable({results: results});
                    $("#search-results-table", $context).html(resultHtml);
                } else {
                    // This replicates the JIRA.SmartAjax.buildSimpleErrorContent method, but we can't use that because
                    // it mentions a JIRA instance.
                    var msg;
                    if (smartAjaxResult.hasData) {
                        msg = "The JIRA server was contacted but has returned an error response. We are unsure of the result of this operation.";
                    } else {
                        msg = "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.";
                    }
                    AJS.messages.error("#search-results-table", {
                        body: msg,
                        closeable: false
                    });
                }

                $("#confluence-searchresult tbody tr", $context).click(function () {
                    var linkUrl = $(this).children().first().data("url");
                    $("#confluence-page-url").val(linkUrl);

        ////        If we want to display the title in the 'description' area on the main dialog
        ////        var linkTitle = $(this).children().first().text();
        ////        $("#confluence-page-url").siblings(".description").text(linkTitle);

                    // Clear all error messages on the parent dialog, as we now have a newly selected URL
                    $("#link-issue-dialog .error").hide();

                    confluenceSearchDialog.hide();
                    $("#link-issue-dialog").show();
                    $("#confluence-page-url").focus().select();
                });
            }
        });
    }

    function initAppLinks(dialog) {
        var settings = {
            getCurrentAppId: function (context) {
                return $("#confluence-app-link", context).val();
            },
            shouldExecute: function (context) {
                return $("#confluence-app-link", context).length !== 0;
            },
            onAuthenticationSuccessCallback: function (context, currentAppId, helper) {
                populateSpaces(context, currentAppId, helper);
            },
            getIssueId: function (context) {
                return $("#confluence-page-link input[name=id]").val();
            }
        };

        return IssueLinkAppLinks.init(settings, dialog.$popup).done(function (context, helper) {
            populateSpaces(context, settings.getCurrentAppId(context), helper);
        });
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-confluence-plugin:confluence-page-resource', location = 'templates/dialog/searchresult.soy' */
// This file was automatically generated from searchresult.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ConfluencePageSearch.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ConfluencePageSearch == 'undefined') { JIRA.Templates.ConfluencePageSearch = {}; }


JIRA.Templates.ConfluencePageSearch.result = function(opt_data, opt_ignored) {
  var output = '<h2>' + soy.$$escapeHtml("Find a Confluence page") + '</h2><form class="aui search-form" id="confluence-page-search-form" action="#" method="post"><div class="field-group"><label for="confluence-app-link">' + soy.$$escapeHtml("Server") + ':</label>';
  if (opt_data.appLinks.length == 1) {
    output += '<span class="field-value">' + soy.$$escapeHtml(opt_data.appLinks[0].name) + '</span><input id="confluence-app-link" class="hidden" type="hidden" name="appId" value="' + soy.$$escapeHtml(opt_data.appLinks[0].id) + '"/>';
  } else {
    output += '<select id="confluence-app-link" class="select medium-field" name="appId">';
    var appLinkList17 = opt_data.appLinks;
    var appLinkListLen17 = appLinkList17.length;
    for (var appLinkIndex17 = 0; appLinkIndex17 < appLinkListLen17; appLinkIndex17++) {
      var appLinkData17 = appLinkList17[appLinkIndex17];
      output += '<option value="' + soy.$$escapeHtml(appLinkData17.id) + '">' + soy.$$escapeHtml(appLinkData17.name) + '</option>';
    }
    output += '</select>';
  }
  output += '</div><div class="issue-link-applinks-authentication-message applinks-message-bar"></div><div class="hidden"><input class="issue-link-applinks-application-type" type="hidden" value="com.atlassian.applinks.api.application.confluence.ConfluenceApplicationType"/></div><div class="issue-link-oauth-toggle field-group"><label for="link-search-text" id="linkSearch-label">' + soy.$$escapeHtml("Search") + ':</label><input id="link-search-text" type="text" tabindex="0" class="text" name="linkSearch" size="50" /> <select tabindex="0" class="search-space select" id="search-panel-space"><option value="">' + soy.$$escapeHtml("All Spaces") + '</option></select> <input type="submit" tabindex="0" class="aui-button" id="search-panel-button" value="' + soy.$$escapeHtml("Search") + '"/><span id="link-search-loading" class="icon loading throbber hidden"/></div><div class="message-panel hidden"></div><div id="search-results-table" class="data-table"></div><div class="buttons-container form-footer"><div class="buttons"><button class="aui-button aui-button-link cancel" id="confluence-link-cancel" title="' + soy.$$escapeHtml("Press Esc to close") + '">' + soy.$$escapeHtml("Close") + '</button></div></div></form>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.result.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.result';
}


JIRA.Templates.ConfluencePageSearch.resultsTable = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.results.length > 0) {
    output += '<table id="confluence-searchresult" class="aui"><thead><tr><th width="180px">' + soy.$$escapeHtml("Title") + '</th><th width="550px">' + soy.$$escapeHtml("Excerpt") + '</th></tr></thead><tbody>';
    var resultList44 = opt_data.results;
    var resultListLen44 = resultList44.length;
    for (var resultIndex44 = 0; resultIndex44 < resultListLen44; resultIndex44++) {
      var resultData44 = resultList44[resultIndex44];
      output += '<tr title="' + soy.$$escapeHtml(resultData44.title) + '"><td class="title" data-url="' + soy.$$escapeHtml(resultData44.url) + '">' + soy.$$escapeHtml(resultData44.title) + '</td><td class="excerpt">' + soy.$$escapeHtml(resultData44.excerpt) + '</td></tr>';
    }
    output += '</tbody></table>';
  } else {
    output += '<div class="aui-message info"><span class="aui-icon icon-info"></span><p>' + soy.$$escapeHtml("Search returned no results.") + '</p></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.resultsTable.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.resultsTable';
}


JIRA.Templates.ConfluencePageSearch.spaceOptions = function(opt_data, opt_ignored) {
  var output = '<option value="">' + soy.$$escapeHtml("All Spaces") + '</option>';
  var spaceList64 = opt_data.spaces;
  var spaceListLen64 = spaceList64.length;
  for (var spaceIndex64 = 0; spaceIndex64 < spaceListLen64; spaceIndex64++) {
    var spaceData64 = spaceList64[spaceIndex64];
    output += '<option value="' + soy.$$escapeHtml(spaceData64.key) + '">' + soy.$$escapeHtml(spaceData64.name) + '</option>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.spaceOptions.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.spaceOptions';
}


JIRA.Templates.ConfluencePageSearch.allSpacesOption = function(opt_data, opt_ignored) {
  return '<option value="">' + soy.$$escapeHtml("All Spaces") + '</option><option value="" disabled="disabled">' + soy.$$escapeHtml("Loading...") + '</option>';
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.allSpacesOption.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.allSpacesOption';
}
;
;
/* module-key = 'com.atlassian.administration.atlassian-admin-quicksearch-jira:admin-quicksearch-webresources', location = 'com/atlassian/administration/quicksearch/jira/js/adminQuickNav.js' */
/**
 * Shifter group for admin search
 */
require([
    'jquery',
    'underscore',
    'jira/ajs/ajax/smart-ajax',
    'jira/shifter',
    'wrm/context-path'
], function (jQuery,
             _,
             SmartAjax,
             Shifter,
             contextPath) {
    Shifter.register(function () {
        var suggestionsDeferred = jQuery.Deferred();

        function formatItem(item) {
            return {
                label: item.label,
                value: item.linkUrl,
                keywords: item.aliases
            };
        }

        function getItemsInSection(section) {
            return _.map(section.items, formatItem).concat(_.map(section.sections, getItemsInSection));
        }

        function formatResponse(data) {
            return _.flatten(getItemsInSection(data));
        }

        SmartAjax.makeRequest({
            dataType: 'json',
            url: contextPath() + '/rest/adminquicksearch/latest/links/default'
        })
            .pipe(formatResponse)
            .done(function (suggestions) {
                suggestionsDeferred.resolve(suggestions);
            })
            .fail(function () {
                suggestionsDeferred.reject();
            });

        return {
            id: 'admin',
            name: "Administration",
            weight: 500,
            getSuggestions: function () {
                return suggestionsDeferred;
            },
            onSelection: function (value) {
                window.location = value;
                return jQuery.Deferred();
            }
        };
    });
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-browser-metrics:sensors', location = 'sensors.js' */
require(["internal/browser-metrics", "jira/util/events"], function (internal_browser_metrics, jira_util_events) {
var sensors_application_menus = {}, sensors_util_safe_dialog_id = {}, sensors_dialogs = {}, sensors = {};
sensors_application_menus = function (exports, Events, metrics) {
  function init() {
    var KEYS = {
      'bonfire_top_menu_dropdown-content': 'jira.header.menu.capture',
      'browse_link-content': 'jira.header.menu.projects',
      'find_link-content': 'jira.header.menu.issues',
      'greenhopper_menu-content': 'jira.header.menu.agile',
      'home_link-content': 'jira.header.menu.dashboards',
      'plugins-jira-webitem-main-content': 'jira.header.menu.portfolio',
      'servicedesk-section-content': 'jira.header.menu.service-desk',
      'system-admin-menu-content': 'jira.header.menu.admin',
      'system-help-menu-content': 'jira.header.menu.help',
      'user-options-content': 'jira.header.menu.profile'
    };
    function getKey(dropdownId) {
      return KEYS.hasOwnProperty(dropdownId) ? KEYS[dropdownId] : null;
    }
    Events.bind('aui-dropdown2-show-before', function (event) {
      var target = event.target;
      var key = getKey(target && target.id);
      if (key) {
        metrics.start({
          key: key,
          isInitial: false,
          threshold: 250
        });
      }
    });
    Events.bind('aui-dropdown2-show-after', function (event) {
      var target = event.target;
      var key = getKey(target && target.id);
      if (key) {
        metrics.end({ key: key });
      }
    });
  }
  exports.init = init;
  return exports;
}(sensors_application_menus, jira_util_events, internal_browser_metrics);
sensors_util_safe_dialog_id = function (exports) {
  var SAFE_DIALOG_IDS = [
    'about-dialog',
    'add-basicuser-dialog',
    'add-developer-dialog',
    'add-field-configuration-dialog',
    'add-field-configuration-scheme-dialog',
    'add-field-dialog',
    'add-field-screen-dialog',
    'add-field-screen-scheme-dialog',
    'add-incoming-mail-handler-dialog',
    'add-issue-type-dialog',
    'add-issue-type-field-configuration-association-dialog',
    'add-issue-type-screen-scheme-configuration-association-dialog',
    'add-issue-type-screen-scheme-dialog',
    'add-new-issue-type-to-scheme-dialog',
    'add-screen-scheme-item-dialog',
    'add-subtask-type-dialog',
    'add-workflow-dialog',
    'add_workflowscheme-dialog',
    'assign-dialog',
    'assign-issue-types-dialog',
    'assign-to-me-link-handler',
    'attach-file-dialog',
    'attach-screenshot-dialog',
    'auditing-settings-dialog',
    'clone-issue-dialog',
    'comment-add-dialog',
    'configure_wallboard_dialog',
    'confluence-page-search-dialog',
    'copy_classic default workflow-dialog',
    'copy-filter-dialog',
    'copy_jira-dialog',
    'create-issue-dialog',
    'create-issue-dialog.issueType',
    'create-issue-dialog.projectId',
    'create-request-dialog',
    'create-service-desk-dialog',
    'create-status-dialog',
    'create-story-dialog',
    'create-story-dialog.issueType',
    'create-story-dialog.projectId',
    'create-subtask-dialog',
    'create-subtask-dialog.issueType',
    'create-team-dialog',
    'create_user-dialog',
    'credits-dialog',
    'delete-attachment-dialog',
    'delete-comment-dialog',
    'delete-dshboard',
    'delete-filter-dialog',
    'delete-issue-dialog',
    'delete-issue-link-dialog',
    'delete-log-work-dialog',
    'delete-metric',
    'delete-queue',
    'delete-status-dialog',
    'deleteuser_link-dialog',
    'devstatus-branch-detail-dialog',
    'devstatus-build-detail-dialog',
    'devstatus-commit-detail-dialog',
    'devstatus-cta-dialog',
    'devstatus-deployment-detail-dialog',
    'devstatus-pullrequest-detail-dialog',
    'devstatus-review-detail-dialog',
    'discard-draft-dialog',
    'discard_draft_workflow-dialog',
    'edit-attachments-dialog',
    'edit-comment',
    'editgroups_admin-dialog',
    'editgroups_link-dialog',
    'editgroups_sysadmin-dialog',
    'edit-issue-dialog',
    'edit-labels-dialog',
    'edit-log-work-dialog',
    'edit-status-dialog',
    'edituser_link_admin-dialog',
    'edit-workflow-dialog',
    'gh-rapidboard-dialog',
    'inline-issue-create-dialog',
    'invite_user-dialog',
    'issue-actions-dialog',
    'issue-tab-error-dialog',
    'jim-create-project-dialog',
    'keyboard-shortcuts-dialog',
    'link-issue-dialog',
    'log-work-dialog',
    'manage-attachment-dialog',
    'metric-pre-save-dialog',
    'modal-field-view',
    'permission-helper-dialog',
    'project-avatar-cropper',
    'project-avatar-picker',
    'project-config-details-project-category-dialog',
    'project-config-project-edit-dialog',
    'project-config-project-edit-lead-and-default-assignee-dialog',
    'project-email-dialog',
    'publish_draft_workflow-dialog',
    'queue-dirty-edits',
    'QuickCreateIssue.error',
    'QuickCreateIssue.success',
    'QuickCreateSubtask.error',
    'QuickCreateSubtask.success',
    'QuickEdit.error',
    'QuickEdit.success',
    'remote-jira-search-dialog',
    'rename-filter-dialog',
    'report-dirty-edits',
    'save-filter-dialog',
    'sd-add-default-value',
    'sd-add-remove-agent-dialog',
    'sd-remove-field-dialog',
    'server-error-dialog',
    'report-delete-confirm',
    'tempo-add-hours-issue-dialog',
    'tempo-add-internal-activity-form',
    'tempo-core-medium-form',
    'tempo-delete-form-dialog',
    'tempo-grace-form',
    'tempo-large-form',
    'tempo-medium-form',
    'tempo-move-form-dialog',
    'tempo-pdf-form',
    'tempo-small-form',
    'tempo-split-form-dialog',
    'tempo-user-settings-dialog',
    'user-avatar-picker',
    'user-defaults-edit-dialog',
    'versionsMergeDialog',
    'view-workflow-dialog',
    'view-workflow-dialog-project-admin',
    'view-workflow-dialog-workflow-schemes',
    'wait-migrate-dialog',
    'whereismycf-dialog',
    'workflow-text-view'
  ].reduce(function (previousValue, currentValue) {
    previousValue[currentValue] = true;
    return previousValue;
  }, {});
  var DIALOG_ID_NORMALISATIONS = [
    {
      dialogId: 'component-delete-dialog',
      pattern: /^component-\d+-delete-dialog$/i
    },
    {
      dialogId: 'version-delete-dialog',
      pattern: /^version-\d+-delete-dialog$/i
    },
    {
      dialogId: 'workflow-transition-dialog',
      pattern: /^workflow-transition-\d+-dialog$/i
    }
  ];
  function safeDialogId(dialogId) {
    var i;
    if (SAFE_DIALOG_IDS.hasOwnProperty(dialogId)) {
      return dialogId;
    }
    for (i = 0; i < DIALOG_ID_NORMALISATIONS.length; i++) {
      if (dialogId.match(DIALOG_ID_NORMALISATIONS[i].pattern)) {
        return DIALOG_ID_NORMALISATIONS[i].dialogId;
      }
    }
    return null;
  }
  return safeDialogId;
}(sensors_util_safe_dialog_id);
sensors_dialogs = function (exports, Events, metrics, safeDialogId) {
  function init() {
    Events.bind('beforeShow', function (event, dialogId) {
      if (typeof dialogId !== 'string') {
        return;
      }
      var key = safeDialogId(dialogId);
      if (key) {
        metrics.start({
          key: 'jira.dialog.open.' + key,
          isInitial: false,
          threshold: 1000
        });
      }
    });
    Events.bind('dialogContentReady', function (event, dialog) {
      if (typeof dialog.options.id !== 'string') {
        return;
      }
      var key = safeDialogId(dialog.options.id);
      if (key) {
        metrics.end({ key: 'jira.dialog.open.' + key });
      }
    });
  }
  exports.init = init;
  return exports;
}(sensors_dialogs, jira_util_events, internal_browser_metrics, sensors_util_safe_dialog_id);
sensors = function (exports, applicationMenusSensor, dialogsSensor) {
  applicationMenusSensor.init();
  dialogsSensor.init();
  return exports;
}(sensors, sensors_application_menus, sensors_dialogs);});
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher.soy' */
// This file was automatically generated from appswitcher.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.appswitcher.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.appswitcher == 'undefined') { navlinks.templates.appswitcher = {}; }


navlinks.templates.appswitcher.linkSection = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.list.length > 0) {
    output += '<div class="aui-nav-heading sidebar-section-header">' + soy.$$escapeHtml(opt_data.title) + '</div><ul class="aui-nav nav-links">';
    var linkList8 = opt_data.list;
    var linkListLen8 = linkList8.length;
    for (var linkIndex8 = 0; linkIndex8 < linkListLen8; linkIndex8++) {
      var linkData8 = linkList8[linkIndex8];
      output += navlinks.templates.appswitcher.applicationsItem(linkData8);
    }
    output += '</ul>';
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.linkSection.soyTemplateName = 'navlinks.templates.appswitcher.linkSection';
}


navlinks.templates.appswitcher.applicationsItem = function(opt_data, opt_ignored) {
  return '<li class="nav-link"><a href="' + soy.$$escapeHtml(opt_data.link) + '" ' + ((opt_data.self) ? 'class="checked"' : '') + ' title="' + soy.$$escapeHtml(opt_data.link) + '"><span class="nav-link-label">' + soy.$$escapeHtml(opt_data.label) + '</span></a></li>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.applicationsItem.soyTemplateName = 'navlinks.templates.appswitcher.applicationsItem';
}


navlinks.templates.appswitcher.shortcutsItem = function(opt_data, opt_ignored) {
  return '<li class="nav-link"><a href="' + soy.$$escapeHtml(opt_data.link) + '" ' + ((opt_data.self) ? 'class="checked"' : '') + ' title="' + soy.$$escapeHtml(opt_data.link) + '"><span class="nav-link-label">' + soy.$$escapeHtml(opt_data.label) + '</span>' + ((opt_data.showDescription && opt_data.description) ? '<span class="nav-link-description">' + soy.$$escapeHtml(opt_data.description) + '</span>' : '') + '</a></li>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.shortcutsItem.soyTemplateName = 'navlinks.templates.appswitcher.shortcutsItem';
}


navlinks.templates.appswitcher.error = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-error">' + soy.$$filterNoAutoescape("Something went wrong, please \x3cspan class\x3d\x22app-switcher-retry\x22\x3etry again\x3c/span\x3e.") + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.error.soyTemplateName = 'navlinks.templates.appswitcher.error';
}


navlinks.templates.appswitcher.sidebarContents = function(opt_data, opt_ignored) {
  return '<div class="aui-page-panel-nav"><nav class="aui-navgroup aui-navgroup-vertical"><div class="app-switcher-section app-switcher-applications"><div class="aui-nav-heading">' + soy.$$escapeHtml("Application Links") + '</div><div class="app-switcher-loading">' + soy.$$filterNoAutoescape("Loading\x26hellip;") + '</div></div><div class="app-switcher-section app-switcher-shortcuts"><div class="aui-nav-heading">' + soy.$$escapeHtml("Shortcuts") + '</div><div class="app-switcher-loading">' + soy.$$filterNoAutoescape("Loading\x26hellip;") + '</div></div></nav></div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.sidebarContents.soyTemplateName = 'navlinks.templates.appswitcher.sidebarContents';
}


navlinks.templates.appswitcher.trigger = function(opt_data, opt_ignored) {
  return '<span class="aui-icon aui-icon-small aui-iconfont-appswitcher">' + soy.$$escapeHtml("Linked Applications") + '</span>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.trigger.soyTemplateName = 'navlinks.templates.appswitcher.trigger';
}


navlinks.templates.appswitcher.projectHeaderSection = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-title">' + aui.avatar.avatar({size: 'large', avatarImageUrl: opt_data.avatarUrl, isProject: true, title: opt_data.name}) + '<div class="sidebar-project-name">' + soy.$$escapeHtml(opt_data.name) + '</div></div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.projectHeaderSection.soyTemplateName = 'navlinks.templates.appswitcher.projectHeaderSection';
}


navlinks.templates.appswitcher.cogDropdown = function(opt_data, opt_ignored) {
  var output = '';
  var dropdownList__soy74 = '' + navlinks.templates.appswitcher.dropdownList({list: opt_data.links});
  output += aui.dropdown2.dropdown2({menu: {id: opt_data.id, content: dropdownList__soy74, extraClasses: 'aui-style-default sidebar-customize-section'}, trigger: {showIcon: false, content: '<span class="aui-icon aui-icon-small aui-iconfont-configure"></span>', container: '#app-switcher'}});
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.cogDropdown.soyTemplateName = 'navlinks.templates.appswitcher.cogDropdown';
}


navlinks.templates.appswitcher.dropdownList = function(opt_data, opt_ignored) {
  var output = '<ul class="sidebar-admin-links">';
  var linkList82 = opt_data.list;
  var linkListLen82 = linkList82.length;
  for (var linkIndex82 = 0; linkIndex82 < linkListLen82; linkIndex82++) {
    var linkData82 = linkList82[linkIndex82];
    output += '<li class="nav-link"><a href="' + soy.$$escapeHtml(linkData82.href) + '" title="' + soy.$$escapeHtml(linkData82.title) + '"><span class="nav-link-label">' + soy.$$escapeHtml(linkData82.label) + '</span></a></li>';
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.dropdownList.soyTemplateName = 'navlinks.templates.appswitcher.dropdownList';
}


navlinks.templates.appswitcher.switcher = function(opt_data, opt_ignored) {
  var output = '';
  if (true) {
    if (AJS.DarkFeatures.isEnabled('rotp.sidebar')) {
      var sidebarContents__soy97 = '' + navlinks.templates.appswitcher.sidebarContents(null);
      var triggerContent__soy99 = '' + navlinks.templates.appswitcher.trigger(null);
      output += navlinks.templates.appswitcher.sidebar({sidebar: {id: 'app-switcher', content: sidebarContents__soy97}, trigger: {showIcon: false, content: triggerContent__soy99}}) + '<script>\n                (function (NL) {\n                    var initialise = function () {\n                        new NL.SideBar({\n                            sidebarContents: \'#app-switcher\'\n                        });\n                    };\n                    if (NL.SideBar) {\n                        initialise();\n                    } else {\n                        NL.onInit = initialise;\n                    }\n                }(window.NL = (window.NL || {})));\n                window.NL.isUserAdmin = ' + soy.$$escapeHtml(false) + '<\/script>';
    } else {
      output += navlinks.templates.appswitcher_old.switcher(null);
    }
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.switcher.soyTemplateName = 'navlinks.templates.appswitcher.switcher';
}


navlinks.templates.appswitcher.sidebar = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.sidebar.id) + '" class="sidebar-trigger app-switcher-trigger" aria-owns="' + soy.$$escapeHtml(opt_data.sidebar.id) + '" aria-haspopup="true">' + soy.$$filterNoAutoescape(opt_data.trigger.content) + '</a><div id=' + soy.$$escapeHtml(opt_data.sidebar.id) + ' class="app-switcher-sidebar aui-style-default sidebar-offscreen">' + soy.$$filterNoAutoescape(opt_data.sidebar.content) + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.sidebar.soyTemplateName = 'navlinks.templates.appswitcher.sidebar';
}
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher.js' */
(function ($, NL) {
    NL.SideBar = function (options) {
        var that = this;
        this.$sidebar = null;

        options = $.extend({
            sidebarContents: null
        }, options);

        this.getLinks = function () {
            return $.ajax({
                url: AJS.contextPath() + '/rest/menu/latest/appswitcher',
                cache: false,
                dataType: 'json'
            }).done(this.updateAppLinks).fail(this.showAppSwitcherError);
        };

        this.populateProjectHeader = function(name, avatarUrl) {
            that.getSidebar().find('.app-switcher-shortcuts .aui-nav-heading').after(navlinks.templates.appswitcher.projectHeaderSection({
                avatarUrl: avatarUrl,
                name: name
            }));
        };

        this.getProjectData = function(){
            var $projectData = $('.project-shortcut-dialog-trigger'),
                projectKey = $projectData.data('key'),
                projectEntityType = $projectData.data('entity-type');
            // if we have no project data, we are not in a project context, so delete the shortcuts section and return.
            if ($projectData.size() == 0 || !projectKey || !projectEntityType)
            {
                $('.app-switcher-shortcuts').remove();
                return;
            }

            var remote, local;

            local = $.ajax({
                url: AJS.contextPath() + '/rest/project-shortcuts/1.0/local/' + projectKey,
                cache: false,
                data: { entityType: projectEntityType },
                dataType: 'json'
            });

            remote = $.ajax({
                url: AJS.contextPath() + '/rest/project-shortcuts/1.0/remote/' + projectKey,
                cache: false,
                data: { entityType: projectEntityType },
                dataType: 'json'
            });

            // wrap a closure around updateProjectShortcuts so we can bind projectKey
            $.when(local, remote).then(function(localData, remoteData){
                that.updateProjectShortcuts(localData, remoteData, {
                    key: projectKey,
                    entityType: projectEntityType,
                    name: $projectData.data('name'),
                    avatarUrl: $projectData.find('img').prop('src')
                });
            }, that.showProjectShortcutsError);
        }

        this.getSidebar = function () {
            if (!this.$sidebar) {
                this.$sidebar = $(options.sidebarContents);
            }
            return this.$sidebar;
        };

        this.addApplicationsCog = function ()
        {
            $('.app-switcher-applications .aui-nav-heading').before(navlinks.templates.appswitcher.cogDropdown({
                id: 'sidebar-applications-admin-dropdown',
                links: [{
                    href: AJS.contextPath() + '/plugins/servlet/customize-application-navigator',
                    label: "Customize navigator",
                    title: "Add new entries, hide existing or restrict who sees what"
                }, {
                    href: AJS.contextPath() + '/plugins/servlet/applinks/listApplicationLinks',
                    label: "Manage application links",
                    title: "Link to more Atlassian applications"
                }]
            }));
        };

        this.addProjectShortcutsCog = function (projectKey, entityType)
        {
            var links = [{
                href: AJS.contextPath() + '/plugins/servlet/custom-content-links-admin?entityKey=' + projectKey,
                label: "Customize shortcuts",
                title: ""
            }];

            if (that.entityMappings[entityType]) {
                links.push({
                    href: that.generateEntityLinksUrl(projectKey, that.entityMappings[entityType]),
                    label: "Manage product links",
                    title: ""
                });
            }

            that.getSidebar().find('.app-switcher-shortcuts .aui-nav-heading').before(navlinks.templates.appswitcher.cogDropdown({
                id: 'sidebar-project-shortcuts-admin-dropdown',
                links: links
            }));
        };

        this.updateAppLinks = function (data) {
            $(function () {
                that.getSidebar().find('.app-switcher-applications').html(navlinks.templates.appswitcher.linkSection({
                    title: "Application Links",
                    list: data
                }));

                if(NL.isUserAdmin)
                {
                    that.addApplicationsCog();
                }

                that.bindAnalyticsHandlers(that.getSidebar(), data);
            });
        };

        this.updateProjectShortcuts = function (localData, remoteData, projectData) {
            var localLinks = localData[0].shortcuts,
                remoteLinks = remoteData[0].shortcuts

            that.getSidebar().find('.app-switcher-shortcuts').html(navlinks.templates.appswitcher.linkSection({
                title: "Shortcuts",
                list: localLinks.concat(remoteLinks)
            }));

            // if we're an admin, put some project admin links in too
            if(NL.isUserAdmin)
            {
                that.addProjectShortcutsCog(projectData.key, projectData.entityType);
            }

            that.populateProjectHeader(projectData.name, projectData.avatarUrl);

            that.bindAnalyticsHandlers(that.getSidebar(), data);
        };

        // Warning: ick.
        this.entityMappings = {
            'confluence.space': 'com.atlassian.applinks.api.application.confluence.ConfluenceSpaceEntityType',
            'jira.project': 'com.atlassian.applinks.api.application.jira.JiraProjectEntityType',
            'bamboo.project': 'com.atlassian.applinks.api.application.bamboo.BambooProjectEntityType',
            'stash.project': 'com.atlassian.applinks.api.application.stash.StashProjectEntityType'
        }
        this.generateEntityLinksUrl = function(projectKey, entityType) {
            // special case for confluence which has a much nicer entity links page
            if (entityType === that.entityMappings['confluence.space']) {
                return AJS.contextPath() + '/spaces/listentitylinks.action?typeId=' + entityType + '&key=' + projectKey;
            } else {
                return AJS.contextPath() + '/plugins/servlet/applinks/listEntityLinks/' + entityType + '/' + projectKey;
            }
        }

        this.showAppSwitcherError = function () {
            $(function () {
                var $sidebar = that.getSidebar();
                $sidebar.find('.app-switcher-applications .app-switcher-loading')
                        .replaceWith(navlinks.templates.appswitcher.error())
                $sidebar.off('.appswitcher')
                        .on('click.appswitcher', '.app-switcher-retry', $.proxy(that.retryLoading, that));
            });
        };

        this.showProjectShortcutsError = function () {
            $(function () {
                var $sidebar = that.getSidebar();
                $sidebar.find('.app-switcher-shortcuts .app-switcher-loading')
                    .replaceWith(navlinks.templates.appswitcher.error());
                $sidebar.off('.appswitcher')
                    .on('click.appswitcher', '.app-switcher-retry', $.proxy(that.retryLoading, that));
            });
        };

        this.retryLoading = function (e) {
            this.getSidebar().html(navlinks.templates.appswitcher.sidebarContents());
            this.getLinks();
            this.getProjectData();
            e && e.stopPropagation();
        };

        this.bindAnalyticsHandlers = function ($sidebar, apps) {
            // TODO: reconsider what we want to capture
        };

        this.getLinks();
        $(this.getProjectData);

        this.toggleSidebar = function(event){
            var sidebar = that.getSidebar(),
                body = $('body'), document = $(window.document);

            if (!body.hasClass('app-switcher-open')) {
                var header = $('#header');

                //append the sidebar to the body if this is the first toggle call.
                sidebar.css('left', -sidebar.width());
                sidebar.parent('body').length || sidebar.appendTo('body');
                sidebarStalk({data: sidebar});
                //Animation can be kicked off now that things are in position
                sidebar.animate({'left': 0}, 300);

                function closeSidebar(closeEvent){
                    var target = closeEvent.target && $(closeEvent.target),
                        keyCode = closeEvent.keyCode;

                    //shortcut out if this is the same even which bound the event to begin with
                    if( closeEvent.originalEvent === event.originalEvent ) {
                        return;
                    }

                    if (target && !keyCode && !(target.closest(sidebar).length || target.closest(header).length)
                            && event.which == 1 && !(closeEvent.shiftKey || closeEvent.ctrlKey || closeEvent.metaKey)){
                        //event is a click outside of the toolbar or header
                        that.toggleSidebar();
                    } else if (keyCode === 27) {
                        //event is the escape key
                        that.toggleSidebar();
                    }
                }
                document.on('click.appSwitcher', closeSidebar);
                document.on('keydown.appSwitcher', closeSidebar);
                document.on('scroll.appSwitcher', sidebar, sidebarStalk);
            } else {
                document.off('.appSwitcher');
            }
            body.toggleClass('app-switcher-open');
        }

        $('#header').on('click', '.app-switcher-trigger', this.toggleSidebar);
    };

    function sidebarStalk(event){
        var scrollPosition = $(document).scrollTop(),
            header = $('#header'),
            topOffset = (header.height() + header.offset().top) - scrollPosition;

        if ( topOffset >= 0 ) {
            event.data.css({top: topOffset, position: 'fixed'});
        } else {
            event.data.css({top: 0, left: 0, position: 'fixed'});
        }
    }

    if (NL.onInit) {
        NL.onInit();
    }
}(jQuery, window.NL = (window.NL || {})));
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher_old.js' */
var APPSWITCHER_TRIGGER_CLICK = "appswitcher.trigger.click";
var APPSWITCHER_DROPDOWN_SHOW = "appswitcher.dropdown.show";
var APPSWITCHER_DROPDOWN_DISPLAY_ERROR = "appswitcher.dropdown.display.error";
var APPSWITCHER_APP_LINK_CLICK = "appswitcher.app.link.click";
var APPSWITCHER_CONFIGURE_LINK_CLICK = "appswitcher.configure.link.click";

(function ($, NL) {
    NL.AppSwitcher = function (options) {
        var ADMIN_EDIT_PATH = AJS.contextPath() + "/plugins/servlet/customize-application-navigator";
        var GLOBAL_BILLING_SYSTEM_DARK_FEATURE_KEY = "unified.usermanagement";
        var that = this;
        this.$dropdown = null;

        options = $.extend({
            dropdownContents: null
        }, options);

        this.getLinks = function () {
            return $.ajax({
                url: AJS.contextPath() + '/rest/menu/latest/appswitcher',
                cache: false,
                dataType: 'json'
            }).done(this.updateDropdown).fail(this.showError);
        };

        this.getDropdown = function () {
            if (!this.$dropdown) {
                this.$dropdown = $(options.dropdownContents);
            }
            return this.$dropdown;
        };

        this.updateDropdown = function (data) {
            $(function () {
                that.getDropdown().html(navlinks.templates.appswitcher_old.applications({
                    apps: data,
                    showAdminLink: NL.environment.isUserAdmin,
                    adminLink: ADMIN_EDIT_PATH
                }));

                that.bindAnalyticsHandlers();
                if (NL.environment.isAppSuggestionAvailable === true) {
                    that.handleSuggestionApps(data);
                }
            });
        };

        this.bindAnalyticsHandlers = function () {
            $(".app-switcher-trigger").on("click", function() {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_TRIGGER_CLICK});
            });

            $("#app-switcher").on("aui-dropdown2-show", function() {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_DROPDOWN_SHOW});
            });

            $('#app-switcher .nav-link').on('click', function() {
                var product = "custom";
                var productLink = $(this).find("a");
                var url = productLink.attr("href");
                var hostname = window.location.hostname;

                if (url.indexOf(hostname + "/wiki") > -1) {
                    product = "confluence";
                } else if (url.indexOf(hostname + "/build") > -1) {
                    product = "bamboo";
                } else if (url.indexOf(hostname) > -1) {
                    product = "jira";
                }

                AJS.trigger("analyticsEvent", {
                    name: APPSWITCHER_APP_LINK_CLICK,
                    data: { product: product }
                });
            });

            $('.nav-link-edit-wrapper').on('click', function() {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_CONFIGURE_LINK_CLICK});
            })
        };

        this.isBillingSystemEnabled = function() {
            return (NL.environment.isSiteAdminUser === true) && AJS.DarkFeatures.isEnabled(GLOBAL_BILLING_SYSTEM_DARK_FEATURE_KEY);
        };

        this.handleSuggestionApps = function(data) {

            var installedApps = _.map(data, function (app) {
                return app.applicationType.toLowerCase();
            });

            var $suggestionApps = $("<div id='app-switcher-suggestion-apps' class='aui-dropdown2-section'/>");
            $suggestionApps.html(navlinks.templates.appswitcher_old.suggestionApps);

            var apps = $suggestionApps.find('.suggestion-apps');
            var hasSuggestionApps = false;
            _.each(suggestions, function(value) {
                if (!_.contains(installedApps, value.appName)) {
                    hasSuggestionApps = true;
                    apps.append(navlinks.templates.appswitcher_old.suggestionApp({
                        suggestionApp: value,
                        isBillingSystemEnabled:  that.isBillingSystemEnabled()
                    }));
                }
            });

            if (!hasSuggestionApps) return;

            $("#app-switcher").append($suggestionApps);

            $('.app-discovery-suggestion-app').click(function () {
                var $suggestionAppLink = $(this).find("a");
                var eventName;
                if (NL.environment.isSiteAdminUser) {
                    eventName = 'appswitcher.discovery.siteadmin.select.inproduct.';
                } else {
                    eventName = 'appswitcher.discovery.user.select.';
                }
                eventName = eventName + $suggestionAppLink.attr("id").toLowerCase();
                AJS.trigger("analytics", {name: eventName});
            });

            $('.app-discovery-suggestion-app').hover(function () {
                $(this).find("a").removeClass("active").removeClass("aui-dropdown2-active");
            });

            $('.app-discovery-cancel-button').click(function () {
                AJS.trigger("analytics", {name: "appswitcher.discovery.nothanks.button.click"});
                storeUserStorageData(KEY_NO_THANKS, "true");
                $suggestionApps.remove();
            });
        };

        this.showError = function () {
            $(function () {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_DROPDOWN_DISPLAY_ERROR});
                that.getDropdown()
                    .html(navlinks.templates.appswitcher_old.error())
                    .off('.appswitcher')
                    .on('click.appswitcher', '.app-switcher-retry', $.proxy(that.retryLoading, that));
            });
        };

        this.retryLoading = function (e) {
            this.getDropdown().html(navlinks.templates.appswitcher_old.loading());
            this.getLinks();
            e && e.stopPropagation();
        };

        this.getLinks();
    };

    var KEY_NO_THANKS = "key-no-thanks";
    var suggestions = [
        {
            appName: "jira",
            appDesc: "Issue & Project Tracking Software",
            discoveryUrl: 'https://www.atlassian.com/software/jira',
            billingSystemDiscoveryUrl: '/admin/billing/addapplication'
        },
        {
            appName: "confluence",
            appDesc: "Collaboration and content sharing",
            discoveryUrl: 'https://www.atlassian.com/software/confluence',
            billingSystemDiscoveryUrl: '/admin/billing/addapplication?product=confluence.ondemand'
        },
        {
            appName: "bamboo",
            appDesc: "Continuous integration",
            discoveryUrl: 'https://www.atlassian.com/software/bamboo',
            billingSystemDiscoveryUrl: '/admin/billing/addapplication?product=bamboo.ondemand'
        }];

    var storeUserStorageData = function (key, value) {
        $.ajax({
            url: AJS.contextPath() + '/rest/menu/latest/userdata/',
            type: "PUT",
            contentType: "application/json",
            data: JSON.stringify({
                key: key,
                value:value
            })
        });
    };

    if (NL.onInit) {
        NL.onInit();
    }


}(jQuery, window.NL = (window.NL || {})));;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher_old.soy' */
// This file was automatically generated from appswitcher_old.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.appswitcher_old.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.appswitcher_old == 'undefined') { navlinks.templates.appswitcher_old = {}; }


navlinks.templates.appswitcher_old.applications = function(opt_data, opt_ignored) {
  return '' + navlinks.templates.appswitcher_old.applicationsSection({list: opt_data.apps, listClass: 'nav-links', showDescription: opt_data.showDescription}) + ((opt_data.custom) ? navlinks.templates.appswitcher_old.applicationsSection({list: opt_data.custom, showDescription: opt_data.showDescription}) : '') + ((opt_data.showAdminLink) ? navlinks.templates.appswitcher_old.adminSection(opt_data) : '');
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.applications.soyTemplateName = 'navlinks.templates.appswitcher_old.applications';
}


navlinks.templates.appswitcher_old.applicationsSection = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.list.length > 0) {
    var param19 = '<ul' + ((opt_data.listClass) ? ' class="' + soy.$$escapeHtml(opt_data.listClass) + '"' : '') + '>';
    var linkList27 = opt_data.list;
    var linkListLen27 = linkList27.length;
    for (var linkIndex27 = 0; linkIndex27 < linkListLen27; linkIndex27++) {
      var linkData27 = linkList27[linkIndex27];
      param19 += navlinks.templates.appswitcher_old.applicationsItem(soy.$$augmentMap(linkData27, {showDescription: opt_data.showDescription}));
    }
    param19 += '</ul>';
    output += aui.dropdown2.section({content: param19});
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.applicationsSection.soyTemplateName = 'navlinks.templates.appswitcher_old.applicationsSection';
}


navlinks.templates.appswitcher_old.applicationsItem = function(opt_data, opt_ignored) {
  return '<li class="nav-link' + ((opt_data.self) ? ' nav-link-local' : '') + '"><a href="' + soy.$$escapeHtml(opt_data.link) + '" class="aui-dropdown2-radio ' + ((opt_data.self) ? 'aui-dropdown2-checked' : '') + '" title="' + soy.$$escapeHtml(opt_data.link) + '"><span class="nav-link-label">' + soy.$$escapeHtml(opt_data.label) + '</span>' + ((opt_data.showDescription && opt_data.description) ? '<span class="nav-link-description">' + soy.$$escapeHtml(opt_data.description) + '</span>' : '') + '</a></li>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.applicationsItem.soyTemplateName = 'navlinks.templates.appswitcher_old.applicationsItem';
}


navlinks.templates.appswitcher_old.adminSection = function(opt_data, opt_ignored) {
  return '' + aui.dropdown2.section({content: '<ul class="nav-links"><li><a class="nav-link-edit-wrapper" href="' + soy.$$escapeHtml(opt_data.adminLink) + '"><span class="nav-link-edit">' + soy.$$filterNoAutoescape("Configure\x26hellip;") + '</span></a></li></ul>'});
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.adminSection.soyTemplateName = 'navlinks.templates.appswitcher_old.adminSection';
}


navlinks.templates.appswitcher_old.error = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-error">' + soy.$$filterNoAutoescape("Something went wrong, please \x3cspan class\x3d\x22app-switcher-retry\x22\x3etry again\x3c/span\x3e.") + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.error.soyTemplateName = 'navlinks.templates.appswitcher_old.error';
}


navlinks.templates.appswitcher_old.loading = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-loading">' + soy.$$filterNoAutoescape("Loading\x26hellip;") + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.loading.soyTemplateName = 'navlinks.templates.appswitcher_old.loading';
}


navlinks.templates.appswitcher_old.trigger = function(opt_data, opt_ignored) {
  return '<span class="aui-icon aui-icon-small aui-iconfont-appswitcher">' + soy.$$escapeHtml("Linked Applications") + '</span>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.trigger.soyTemplateName = 'navlinks.templates.appswitcher_old.trigger';
}


navlinks.templates.appswitcher_old.switcher = function(opt_data, opt_ignored) {
  var output = '';
  if (true) {
    var loadingContent__soy81 = '' + navlinks.templates.appswitcher_old.loading(null);
    var triggerContent__soy83 = '' + navlinks.templates.appswitcher_old.trigger(null);
    output += aui.dropdown2.dropdown2({menu: {id: 'app-switcher', content: loadingContent__soy81, extraClasses: 'aui-style-default'}, trigger: {showIcon: false, content: triggerContent__soy83, extraClasses: 'app-switcher-trigger', extraAttributes: {href: '#app-switcher'}}}) + '<script>\n            (function (NL) {\n                var initialise = function () {\n                    // For some milestones of AUI, the atlassian soy namespace was renamed to aui. Handle that here by ensuring that window.atlassian is defined.\n                    window.atlassian = window.atlassian || window.aui;\n                    new NL.AppSwitcher({\n                        dropdownContents: \'#app-switcher\'\n                    });\n                };\n                if (NL.AppSwitcher) {\n                    initialise();\n                } else {\n                    NL.onInit = initialise;\n                }\n            }(window.NL = (window.NL || {})));\n            window.NL.environment = ' + soy.$$escapeHtml({}) + ';<\/script>';
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.switcher.soyTemplateName = 'navlinks.templates.appswitcher_old.switcher';
}


navlinks.templates.appswitcher_old.suggestionApp = function(opt_data, opt_ignored) {
  var output = '';
  var href__soy92 = opt_data.isBillingSystemEnabled == true ? opt_data.suggestionApp.billingSystemDiscoveryUrl : opt_data.suggestionApp.discoveryUrl;
  output += '<li class="app-discovery-suggestion-app"><a id="' + soy.$$escapeHtml(opt_data.suggestionApp.appName) + '" href="' + soy.$$escapeHtml(href__soy92) + '" class="app-discovery-link aui-icon-container app-discovery-' + soy.$$escapeHtml(opt_data.suggestionApp.appName) + '-product-icon" title="' + soy.$$escapeHtml(href__soy92) + '" target="_blank"/><div class="app-discovery-small">' + soy.$$escapeHtml(opt_data.suggestionApp.appDesc) + '</div></li>';
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.suggestionApp.soyTemplateName = 'navlinks.templates.appswitcher_old.suggestionApp';
}


navlinks.templates.appswitcher_old.suggestionApps = function(opt_data, opt_ignored) {
  return '<ul class=\'nav-links suggestion-apps\'><li><span class=\'app-discovery-suggest-title nav-link-label\'><h6>' + soy.$$escapeHtml("Try other Atlassian apps") + '</h6></span></li></ul><div class=\'buttons-container app-discovery-suggest-apps-buttons\'><div class=\'buttons\'><button class=\'aui-button aui-button-link app-discovery-cancel-button\' name=\'cancel\' accesskey=\'c\' href=\'#\'>' + soy.$$escapeHtml("Don\x27t show this again") + '</button></div></div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.suggestionApps.soyTemplateName = 'navlinks.templates.appswitcher_old.suggestionApps';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:jira-header', location = 'soy/headerDropdown.soy' */
// This file was automatically generated from headerDropdown.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Menu.Dropdowns.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Menu == 'undefined') { JIRA.Templates.Menu = {}; }
if (typeof JIRA.Templates.Menu.Dropdowns == 'undefined') { JIRA.Templates.Menu.Dropdowns = {}; }


JIRA.Templates.Menu.Dropdowns.dropdown2Fragment = function(opt_data, opt_ignored) {
  var output = '';
  var sectionList3 = opt_data.sections;
  var sectionListLen3 = sectionList3.length;
  for (var sectionIndex3 = 0; sectionIndex3 < sectionListLen3; sectionIndex3++) {
    var sectionData3 = sectionList3[sectionIndex3];
    var hasItems__soy4 = sectionData3.items && sectionData3.items.length > 0;
    output += '<div class="aui-dropdown2-section">' + ((hasItems__soy4 && sectionData3.label) ? '<strong>' + soy.$$escapeHtml(sectionData3.label) + '</strong>' : '') + '<ul class=\'aui-list-truncate\'' + ((sectionData3.id) ? ' id="' + soy.$$escapeHtml(sectionData3.id) + '"' : '') + ((sectionData3.style) ? ' class="' + soy.$$escapeHtml(sectionData3.style) + '"' : '') + '>';
    if (hasItems__soy4) {
      var itemList25 = sectionData3.items;
      var itemListLen25 = itemList25.length;
      for (var itemIndex25 = 0; itemIndex25 < itemListLen25; itemIndex25++) {
        var itemData25 = itemList25[itemIndex25];
        output += JIRA.Templates.Menu.Dropdowns.dropdown2Item(itemData25);
      }
    }
    output += '</ul></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Menu.Dropdowns.dropdown2Fragment.soyTemplateName = 'JIRA.Templates.Menu.Dropdowns.dropdown2Fragment';
}


JIRA.Templates.Menu.Dropdowns.dropdown2Item = function(opt_data, opt_ignored) {
  var output = '<li' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ((opt_data.style) ? ' class="' + soy.$$escapeHtml(opt_data.style) + '"' : '') + '><a href="' + soy.$$escapeHtml(opt_data.url) + '"' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '_lnk"' : '') + ((opt_data.title) ? ' title="' + soy.$$escapeHtml(opt_data.title) + '"' : '') + ' class="' + ((opt_data.iconUrl) ? 'aui-icon-container' : '') + ((opt_data.parameters && opt_data.parameters['class']) ? ' ' + soy.$$escapeHtml(opt_data.parameters['class']) : '') + '"';
  if (opt_data.parameters) {
    var keyList66 = soy.$$getMapKeys(opt_data.parameters);
    var keyListLen66 = keyList66.length;
    for (var keyIndex66 = 0; keyIndex66 < keyListLen66; keyIndex66++) {
      var keyData66 = keyList66[keyIndex66];
      output += (keyData66 != 'class') ? ' ' + soy.$$escapeHtml(keyData66) + '="' + soy.$$escapeHtml(opt_data.parameters[keyData66]) + '"' : '';
    }
  }
  output += '>' + ((opt_data.iconUrl) ? '<img class="icon" src="' + soy.$$escapeHtml(opt_data.iconUrl) + '" />' : '') + soy.$$escapeHtml(opt_data.label) + '</a></li>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Menu.Dropdowns.dropdown2Item.soyTemplateName = 'JIRA.Templates.Menu.Dropdowns.dropdown2Item';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:jira-header', location = 'js/init-dropdown2.js' */
/**
 * JIRA's implementation of AUI Dropdown2 remote API (https://extranet.atlassian.com/display/AUI/Dropdown2+remote+API).
 *
 * This predates AUI Dropdown2, and allows the application header menus to be dynamic and populated via AJAX. This is
 * required for menus that are dynamic (e.g. Issues or Projects).
 *
 * In addition to the normal `aui-dropdown2-show` event that is triggered on the dropdown, two extra events are
 * triggered to expose the asynchronous nature of the menus:
 *
 * - `aui-dropdown2-show-before` is triggered _before_ a dropdown is shown (due to implementation details, this is
 *    unfortunately triggered after `aui-dropdown2-show`).
 * - `aui-dropdown2-show-after` is triggered when the dropdown is populated and visible to the user. It is triggered for
 *    both remote dropdowns and normal dropdowns.
 *
 * The class `aui-dropdown2-loading` is added to the dropdown between `aui-dropdown2-show-before` and
 * `aui-dropdown2-show-after`.
 */
require(['jira/ajs/ajax/smart-ajax', 'jquery'], function (SmartAjax, $) {
    $(function () {
        $("nav.aui-header a.aui-dropdown2-trigger").each(function() {
            var $trigger = $(this);
            var $dropdown = $("#" + $trigger.attr("aria-owns"));
            var ajaxKey = $dropdown.data("aui-dropdown2-ajax-key");

            $dropdown.bind("aui-dropdown2-show", function (event, options) {
                $dropdown.trigger('aui-dropdown2-show-before');

                if (ajaxKey) {
                    // JIRA's own implementation of Dropdown2 remote API. This predates Dropdown2 remote, and should be
                    // removed when Dropdown2 remote API lands in AUI.
                    $dropdown.empty();
                    $dropdown.addClass("aui-dropdown2-loading");
                    SmartAjax.makeRequest({
                        url: AJS.contextPath() + "/rest/api/1.0/menus/" + ajaxKey,
                        data: {
                            inAdminMode: AJS.Meta.getBoolean("in-admin-mode")
                        },
                        dataType: "json",
                        cache: false,
                        success: function (data) {
                            $dropdown.removeClass("aui-dropdown2-loading");
                            $dropdown.html(JIRA.Templates.Menu.Dropdowns.dropdown2Fragment(data));

                            if (options && options.selectFirst) {
                                $dropdown.find("a:not(.disabled)").filter(":first").addClass("active");
                            }
                            $dropdown.trigger('aui-dropdown2-show-after');
                        }
                    });
                } else {
                    $dropdown.trigger('aui-dropdown2-show-after');
                }
            });
        });
    });
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/keymaster.js' */
//     keymaster.js
//     (c) 2011-2013 Thomas Fuchs
//     keymaster.js may be freely distributed under the MIT license.

;(function(global){
    var k,
            _handlers = {},
            _mods = { 16: false, 18: false, 17: false, 91: false },
            _scope = 'all',
    // modifier keys
            _MODIFIERS = {
                '⇧': 16, shift: 16,
                '⌥': 18, alt: 18, option: 18,
                '⌃': 17, ctrl: 17, control: 17,
                '⌘': 91, command: 91
            },
    // special keys
            _MAP = {
                backspace: 8, tab: 9, clear: 12,
                enter: 13, 'return': 13,
                esc: 27, escape: 27, space: 32,
                left: 37, up: 38,
                right: 39, down: 40,
                del: 46, 'delete': 46,
                home: 36, end: 35,
                pageup: 33, pagedown: 34,
                ',': 188, '.': 190, '/': 191,
                '`': 192, '-': 189, '=': 187,
                ';': 186, '\'': 222,
                '[': 219, ']': 221, '\\': 220
            },
            code = function(x){
                return _MAP[x] || x.toUpperCase().charCodeAt(0);
            },
            _downKeys = [];

    for(k=1;k<20;k++) _MAP['f'+k] = 111+k;

    // IE doesn't support Array#indexOf, so have a simple replacement
    function index(array, item){
        var i = array.length;
        while(i--) if(array[i]===item) return i;
        return -1;
    }

    // for comparing mods before unassignment
    function compareArray(a1, a2) {
        if (a1.length != a2.length) return false;
        for (var i = 0; i < a1.length; i++) {
            if (a1[i] !== a2[i]) return false;
        }
        return true;
    }

    var modifierMap = {
        16:'shiftKey',
        18:'altKey',
        17:'ctrlKey',
        91:'metaKey'
    };
    function updateModifierKey(event) {
        for(k in _mods) _mods[k] = event[modifierMap[k]];
    };

    // handle keydown event
    function dispatch(event) {
        var key, handler, k, i, modifiersMatch, scope;
        key = event.keyCode;

        if (index(_downKeys, key) == -1) {
            _downKeys.push(key);
        }

        // if a modifier key, set the key.<modifierkeyname> property to true and return
        if(key == 93 || key == 224) key = 91; // right command on webkit, command on Gecko
        if(key in _mods) {
            _mods[key] = true;
            // 'assignKey' from inside this closure is exported to window.key
            for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = true;
            return;
        }
        updateModifierKey(event);

        // see if we need to ignore the keypress (filter() can can be overridden)
        // by default ignore key presses if a select, textarea, or input is focused
        if(!assignKey.filter.call(this, event)) return;

        // abort if no potentially matching shortcuts found
        if (!(key in _handlers)) return;

        scope = getScope();

        // for each potential shortcut
        for (i = 0; i < _handlers[key].length; i++) {
            handler = _handlers[key][i];

            // see if it's in the current scope
            if(handler.scope == scope || handler.scope == 'all'){
                // check if modifiers match if any
                modifiersMatch = handler.mods.length > 0;
                for(k in _mods)
                    if((!_mods[k] && index(handler.mods, +k) > -1) ||
                            (_mods[k] && index(handler.mods, +k) == -1)) modifiersMatch = false;
                // call the handler and stop the event if neccessary
                if((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch){
                    if(handler.method(event, handler)===false){
                        if(event.preventDefault) event.preventDefault();
                        else event.returnValue = false;
                        if(event.stopPropagation) event.stopPropagation();
                        if(event.cancelBubble) event.cancelBubble = true;
                    }
                }
            }
        }
    };

    // unset modifier keys on keyup
    function clearModifier(event){
        var key = event.keyCode, k,
                i = index(_downKeys, key);

        // remove key from _downKeys
        if (i >= 0) {
            _downKeys.splice(i, 1);
        }

        if(key == 93 || key == 224) key = 91;
        if(key in _mods) {
            _mods[key] = false;
            for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = false;
        }
    };

    function resetModifiers() {
        for(k in _mods) _mods[k] = false;
        for(k in _MODIFIERS) assignKey[k] = false;
    };

    // parse and assign shortcut
    function assignKey(key, scope, method){
        var keys, mods;
        keys = getKeys(key);
        if (method === undefined) {
            method = scope;
            scope = 'all';
        }

        // for each shortcut
        for (var i = 0; i < keys.length; i++) {
            // set modifier keys if any
            mods = [];
            key = keys[i].split('+');
            if (key.length > 1){
                mods = getMods(key);
                key = [key[key.length-1]];
            }
            // convert to keycode and...
            key = key[0]
            key = code(key);
            // ...store handler
            if (!(key in _handlers)) _handlers[key] = [];
            _handlers[key].push({ shortcut: keys[i], scope: scope, method: method, key: keys[i], mods: mods });
        }
    };

    // unbind all handlers for given key in current scope
    function unbindKey(key, scope) {
        var multipleKeys, keys,
                mods = [],
                i, j, obj;

        multipleKeys = getKeys(key);

        for (j = 0; j < multipleKeys.length; j++) {
            keys = multipleKeys[j].split('+');

            if (keys.length > 1) {
                mods = getMods(keys);
                key = keys[keys.length - 1];
            }

            key = code(key);

            if (scope === undefined) {
                scope = getScope();
            }
            if (!_handlers[key]) {
                return;
            }
            for (i in _handlers[key]) {
                obj = _handlers[key][i];
                // only clear handlers if correct scope and mods match
                if (obj.scope === scope && compareArray(obj.mods, mods)) {
                    _handlers[key][i] = {};
                }
            }
        }
    };

    // Returns true if the key with code 'keyCode' is currently down
    // Converts strings into key codes.
    function isPressed(keyCode) {
        if (typeof(keyCode)=='string') {
            keyCode = code(keyCode);
        }
        return index(_downKeys, keyCode) != -1;
    }

    function getPressedKeyCodes() {
        return _downKeys.slice(0);
    }

    function filter(event){
        var tagName = (event.target || event.srcElement).tagName;
        // ignore keypressed in any elements that support keyboard data input
        return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');
    }

    // initialize key.<modifier> to false
    for(k in _MODIFIERS) assignKey[k] = false;

    // set current scope (default 'all')
    function setScope(scope){ _scope = scope || 'all' };
    function getScope(){ return _scope || 'all' };

    // delete all handlers for a given scope
    function deleteScope(scope){
        var key, handlers, i;

        for (key in _handlers) {
            handlers = _handlers[key];
            for (i = 0; i < handlers.length; ) {
                if (handlers[i].scope === scope) handlers.splice(i, 1);
                else i++;
            }
        }
    };

    // abstract key logic for assign and unassign
    function getKeys(key) {
        var keys;
        key = key.replace(/\s/g, '');
        keys = key.split(',');
        if ((keys[keys.length - 1]) == '') {
            keys[keys.length - 2] += ',';
        }
        return keys;
    }

    // abstract mods logic for assign and unassign
    function getMods(key) {
        var mods = key.slice(0, key.length - 1);
        for (var mi = 0; mi < mods.length; mi++)
            mods[mi] = _MODIFIERS[mods[mi]];
        return mods;
    }

    // cross-browser events
    function addEvent(object, event, method) {
        if (object.addEventListener)
            object.addEventListener(event, method, false);
        else if(object.attachEvent)
            object.attachEvent('on'+event, function(){ method(window.event) });
    };

    // set the handlers globally on document
    addEvent(document, 'keydown', function(event) { dispatch(event) }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48
    addEvent(document, 'keyup', clearModifier);

    // reset modifiers to false whenever the window is (re)focused.
    addEvent(window, 'focus', resetModifiers);

    // store previously defined key
    var previousKey = global.key;

    // restore previously defined key and return reference to our key object
    function noConflict() {
        var k = global.key;
        global.key = previousKey;
        return k;
    }

    // set window.key and window.key.set/get/deleteScope, and the default filter
    global.key = assignKey;
    global.key.setScope = setScope;
    global.key.getScope = getScope;
    global.key.deleteScope = deleteScope;
    global.key.filter = filter;
    global.key.isPressed = isPressed;
    global.key.getPressedKeyCodes = getPressedKeyCodes;
    global.key.noConflict = noConflict;
    global.key.unbind = unbindKey;

    if(typeof module !== 'undefined') module.exports = key;

})(this);;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/amd-wrappers.js' */
/* AMD wrappers for commonly used objects */

define('wiki-edit/aui', function() { return AJS; });
define('wiki-edit/JIRA', function() { return JIRA; });
define('wiki-edit/keymaster', ["wiki-edit/aui"], function(AJS) {
    if (AJS.Meta.get("keyboard-shortcuts-enabled") === false) {
        return function keyMasterNoop() {};
    }
    return key.noConflict();
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/templates/wiki-editor.soy' */
// This file was automatically generated from wiki-editor.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Plugins.WikiEditor.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Plugins == 'undefined') { JIRA.Templates.Plugins = {}; }
if (typeof JIRA.Templates.Plugins.WikiEditor == 'undefined') { JIRA.Templates.Plugins.WikiEditor = {}; }


JIRA.Templates.Plugins.WikiEditor.renderEditor = function(opt_data, opt_ignored) {
  var output = '<div id="wiki-edit-dropdown2-text-style-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="paragraph" title="' + soy.$$escapeHtml("Paragraph") + '">' + soy.$$escapeHtml("Paragraph") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h1" data-operation="h1" title="' + soy.$$escapeHtml("Heading 1") + '">' + soy.$$escapeHtml("Heading 1") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h2" data-operation="h2" title="' + soy.$$escapeHtml("Heading 2") + '">' + soy.$$escapeHtml("Heading 2") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h3" data-operation="h3" title="' + soy.$$escapeHtml("Heading 3") + '">' + soy.$$escapeHtml("Heading 3") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h4" data-operation="h4" title="' + soy.$$escapeHtml("Heading 4") + '">' + soy.$$escapeHtml("Heading 4") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h5" data-operation="h5" title="' + soy.$$escapeHtml("Heading 5") + '">' + soy.$$escapeHtml("Heading 5") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h6" data-operation="h6" title="' + soy.$$escapeHtml("Heading 6") + '">' + soy.$$escapeHtml("Heading 6") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-monospace" data-operation="monospace" title="' + soy.$$escapeHtml("Preformatted") + '">' + soy.$$escapeHtml("Preformatted") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="paragraph-quote" title="' + soy.$$escapeHtml("Paragraph quote") + '">' + soy.$$escapeHtml("Paragraph quote") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="block-quote" title="' + soy.$$escapeHtml("Block quote") + '">' + soy.$$escapeHtml("Block quote") + '</a></li></ul></div></div><div id="wiki-edit-dropdown2-more-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="delete" data-shortcut="ctrl+shift+s, command+shift+s" title="' + soy.$$escapeHtml("Strikethrough") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+Shift+S)">' + soy.$$escapeHtml("Strikethrough") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="superscript">' + soy.$$escapeHtml("Superscript") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="subscript">' + soy.$$escapeHtml("Subscript") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="cite">' + soy.$$escapeHtml("Citation") + '</a></li></ul></div></div><div id="wiki-edit-dropdown2-link-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown wiki-edit-dropdown-link"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="link" data-shortcut="ctrl+k, command+k" title="' + soy.$$escapeHtml("External link") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+K)">' + soy.$$escapeHtml("External link") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="link-mail">' + soy.$$escapeHtml("Mail link") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="link-anchor">' + soy.$$escapeHtml("Anchor link") + '</a></li>' + ((! opt_data.attachmentM2FeatureFlag) ? '<li><a href="#" class="wiki-edit-operation" data-operation="link-attachment">' + soy.$$escapeHtml("Attachment link") + '</a></li>' : '') + '</ul></div>' + ((! opt_data.attachmentM2FeatureFlag) ? '<div class="aui-dropdown2-section wiki-edit-insert-link"><strong>' + soy.$$escapeHtml("Attachment link") + '</strong><ul class="aui-list-truncate"><li><a href="#"></a></li></ul></div>' : '') + '</div>' + ((! opt_data.attachmentM2FeatureFlag) ? '<div id="wiki-edit-dropdown2-image-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown wiki-edit-dropdown-image"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="image" title="' + soy.$$escapeHtml("External image") + '">' + soy.$$escapeHtml("External image") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="image-attachment">' + soy.$$escapeHtml("Attached image") + '</a></li></ul></div><div class="aui-dropdown2-section wiki-edit-insert-image"><strong>' + soy.$$escapeHtml("Attached image") + '</strong><ul class="aui-list-truncate"><li><a href="#"></a></li></ul></div></div>' : '<div id="wiki-edit-dropdown2-attachment-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown wiki-edit-dropdown-attachment"><div class="aui-dropdown2-section wiki-edit-insert-attachment"><ul class="aui-list-truncate"><li><a href="#"></a></li></ul></div><div class="aui-dropdown2-section wiki-edit-browse-image"><ul class="aui-list-truncate"><li><a href="#" class="wiki-attachment-browse"><span class="aui-icon aui-icon-small aui-iconfont-add"></span>&nbsp;&nbsp;' + soy.$$escapeHtml("Browse") + '</a></li></ul></div></div>') + '<div id="wiki-edit-color-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-picker wiki-edit-color-picker" data-container="wiki-edit-color-picker-buttons-' + soy.$$escapeHtml(opt_data.editorId) + '">';
  var colors__soy108 = ['333333', '707070', 'cccccc', '205081', '59afe1', '14892c', '8eb021', 'd04437', 'f79232', 'f6c342', '654982', 'f691b2'];
  output += '<div class="aui-dropdown2-section"><ul>';
  var colorList110 = colors__soy108;
  var colorListLen110 = colorList110.length;
  for (var colorIndex110 = 0; colorIndex110 < colorListLen110; colorIndex110++) {
    var colorData110 = colorList110[colorIndex110];
    output += '<li><a href="#" style="background-color: #' + soy.$$escapeHtml(colorData110) + '" data-operation="color" data-color="#' + soy.$$escapeHtml(colorData110) + '">&nbsp;</a></li>';
  }
  output += '</ul></div></div><div id="wiki-edit-dropdown2-icon-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-picker wiki-edit-icon-picker" data-container="wiki-edit-icon-picker-buttons-' + soy.$$escapeHtml(opt_data.editorId) + '"><div class="aui-dropdown2-section"><ul><li><a href="#" class="wiki-edit-operation" title=":)" data-operation=":)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/smile.gif" alt="' + soy.$$escapeHtml("smile") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=":(" data-operation=":("><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/sad.gif" alt="' + soy.$$escapeHtml("sad") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=":P" data-operation=":P"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/tongue.gif" alt="' + soy.$$escapeHtml("tongue") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=":D" data-operation=":D"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/biggrin.gif" alt="' + soy.$$escapeHtml("biggrin") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=";)" data-operation=";)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/wink.gif" alt="' + soy.$$escapeHtml("wink") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(y)" data-operation="(y)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/thumbs_up.gif" alt="' + soy.$$escapeHtml("thumbs up") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(n)" data-operation="(n)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/thumbs_down.gif" alt="' + soy.$$escapeHtml("thumbs down") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(i)" data-operation="(i)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/information.gif" alt="' + soy.$$escapeHtml("information") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(/)" data-operation="(/)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/check.gif" alt="' + soy.$$escapeHtml("check") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(x)" data-operation="(x)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/error.gif" alt="' + soy.$$escapeHtml("error") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(!)" data-operation="(!)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/warning.gif" alt="' + soy.$$escapeHtml("warning") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(+)" data-operation="(+)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/add.gif" alt="' + soy.$$escapeHtml("add") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(-)" data-operation="(-)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/forbidden.gif" alt="' + soy.$$escapeHtml("forbidden") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(?)" data-operation="(?)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/help_16.gif" alt="' + soy.$$escapeHtml("help") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(on)" data-operation="(on)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/lightbulb_on.gif" alt="' + soy.$$escapeHtml("lightbulb on") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(off)" data-operation="(off)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/lightbulb.gif" alt="' + soy.$$escapeHtml("lightbulb") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*)" data-operation="(*)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_yellow.gif" alt="' + soy.$$escapeHtml("star yellow") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*r)" data-operation="(*r)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_red.gif" alt="' + soy.$$escapeHtml("star red") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*g)" data-operation="(*g)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_green.gif" alt="' + soy.$$escapeHtml("star green") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*b)" data-operation="(*b)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_blue.gif" alt="' + soy.$$escapeHtml("star blue") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*y)" data-operation="(*y)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_yellow.gif" alt="' + soy.$$escapeHtml("star yellow") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(flag)" data-operation="(flag)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/flag.gif" alt="' + soy.$$escapeHtml("flag") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(flagoff)" data-operation="(flagoff)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/flag_grey.gif" alt="' + soy.$$escapeHtml("flag off") + '" /></a></li></ul></div></div><div id="wiki-edit-dropdown2-other-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="mention">' + soy.$$escapeHtml("User mention") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="table">' + soy.$$escapeHtml("Table") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="code">' + soy.$$escapeHtml("Code") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="noformat">' + soy.$$escapeHtml("Preformatted") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="panel">' + soy.$$escapeHtml("Panel") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="hr">' + soy.$$escapeHtml("Horizontal ruler") + '</a></li><li class="wiki-edit-speech-item hidden"><a href="#" class="wiki-edit-operation" data-operation="speech">' + soy.$$escapeHtml("Speech recognition") + '</a></li></ul></div></div><div class="wiki-edit-toolbar" id="wiki-edit-' + soy.$$escapeHtml(opt_data.editorId) + '"><div class="aui-toolbar2"><div class="aui-toolbar2-inner"><div class="aui-toolbar2-primary"><div class="aui-buttons"><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-style-picker-trigger" aria-owns="wiki-edit-dropdown2-text-style-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-text-style-' + soy.$$escapeHtml(opt_data.editorId) + '">' + soy.$$escapeHtml("Style") + '</a></div><div class="aui-buttons wiki-edit-toolbar-section"><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="bold" data-shortcut="ctrl+b, command+b" title="' + soy.$$escapeHtml("Bold") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+B)"><span class="aui-icon aui-icon-small aui-iconfont-editor-bold">' + soy.$$escapeHtml("Bold") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="italic" data-shortcut="ctrl+i, command+i" title="' + soy.$$escapeHtml("Italic") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+I)"><span class="aui-icon aui-icon-small aui-iconfont-editor-italic">' + soy.$$escapeHtml("Italic") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="underline" data-shortcut="ctrl+u, command+u" title="' + soy.$$escapeHtml("Underline") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+U)"><span class="aui-icon aui-icon-small aui-iconfont-editor-underline">' + soy.$$escapeHtml("Underline") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation wiki-edit-operation-color" data-operation="color" data-color="red" title="' + soy.$$escapeHtml("Text color") + '"><span class="aui-icon aui-icon-small aui-iconfont-editor-color">' + soy.$$escapeHtml("Text color") + '</span><span class="wiki-edit-color-indicator"></span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-color-picker-trigger" data-operation="color-parameter" aria-owns="wiki-edit-color-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" title="' + soy.$$escapeHtml("More colors") + '"><span>' + soy.$$escapeHtml("More colors") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-more-picker-trigger" aria-owns="wiki-edit-dropdown2-more-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-more-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("More") + '"><span class="aui-icon aui-icon-small aui-iconfont-editor-styles">' + soy.$$escapeHtml("More") + '</span></a></div><div class="aui-buttons"><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-link-picker-trigger" aria-owns="wiki-edit-dropdown2-link-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-link-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Link") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+K)"><span class="aui-icon aui-icon-small aui-iconfont-link">' + soy.$$escapeHtml("Link") + '</span></a>' + ((! opt_data.attachmentM2FeatureFlag) ? '<a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-image-picker-trigger" aria-owns="wiki-edit-dropdown2-image-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-image-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Image") + '"><span class="aui-icon aui-icon-small aui-iconfont-image">' + soy.$$escapeHtml("Image") + '</span></a>' : '<a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-attachment-picker-trigger" aria-owns="wiki-edit-dropdown2-attachment-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-attachment-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Attachment") + '"><span class="aui-icon aui-icon-small aui-iconfont-file-generic">' + soy.$$escapeHtml("Attachment") + '</span></a>') + '</div><div class="aui-buttons wiki-edit-toolbar-section"><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="bullet-list" data-shortcut="ctrl+shift+b, command+shift+b" title="' + soy.$$escapeHtml("Bullet list") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+Shift+B)"><span class="aui-icon aui-icon-small aui-iconfont-editor-list-bullet">' + soy.$$escapeHtml("Bullet list") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="numbered-list" data-shortcut="ctrl+shift+n, command+shift+n" title="' + soy.$$escapeHtml("Numbered list") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+Shift+N)"><span class="aui-icon aui-icon-small aui-iconfont-editor-list-number">' + soy.$$escapeHtml("Numbered list") + '</span></a></div><div class="aui-buttons"><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-icon-picker-trigger wiki-edit-tooltip" aria-owns="wiki-edit-dropdown2-icon-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-icon-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Icons") + '"><span class="aui-icon aui-icon-small aui-iconfont-editor-emoticon">' + soy.$$escapeHtml("Icons") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-other-picker-trigger wiki-edit-tooltip" aria-owns="wiki-edit-dropdown2-other-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-other-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Other") + '"><span class="aui-icon aui-icon-small aui-iconfont-add">' + soy.$$escapeHtml("Other") + '</span></a></div><div class="aui-buttons wiki-edit-toolbar-last"><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-visible-toggle wiki-edit-tooltip" title="' + soy.$$escapeHtml("Toggle visibility") + '"><span class="aui-icon icon-toolbartoggle">Lock / Unlock</span></a></div></div></div><!-- .aui-toolbar-inner --></div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Plugins.WikiEditor.renderEditor.soyTemplateName = 'JIRA.Templates.Plugins.WikiEditor.renderEditor';
}


JIRA.Templates.Plugins.WikiEditor.renderListItem = function(opt_data, opt_ignored) {
  return '<li><a href="#" ' + soy.$$escapeHtml(opt_data.attachmentType ? 'data-attachment-type=' + opt_data.attachmentType : '') + '>' + ((opt_data.attachmentM2FeatureFlagEnabled) ? '<span class="wiki-edit-attachment-type-icon aui-icon aui-icon-small ' + soy.$$escapeHtml(((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.cssClass) != null ? ((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.cssClass) : 'aui-iconfont-file-txt') + '" title="' + soy.$$escapeHtml(((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.title) != null ? ((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.title) : 'File') + '"></span>&nbsp;&nbsp;' : '') + '<span class="wiki-edit-attachment-name">' + soy.$$escapeHtml(opt_data.text) + '</span></a></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.Plugins.WikiEditor.renderListItem.soyTemplateName = 'JIRA.Templates.Plugins.WikiEditor.renderListItem';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/Analytics.js' */
define('wiki-edit/analytics',[
    'wiki-edit/aui'
], function(AJS) {

    var triggerEvent = (AJS.Analytics && AJS.Analytics.triggerPrivacyPolicySafeEvent) ?
        (function triggerEvent(name, props) {
            AJS.Analytics.triggerPrivacyPolicySafeEvent('jira.wikieditor.' + name, props || {});
        }) :
        (function triggerEvent(name, props) {
            AJS.trigger("analytics", { name: 'jira.wikieditor.'+name, data: props || {} });
        });

    function hashCode (string) {
        var charCode;
        var hash = 0;
        if (!string) {
            return "";
        }

        for (var i = 0; i < string.length; i += 1) {
            charCode = string.charCodeAt(i);
            hash = ((hash * 32) - hash) + charCode;
            hash |= 0; // force 32-bit representation
        }

        return hash;
    }

    return {
        trigger: triggerEvent,
        hashCode: hashCode
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/KeyTester.js' */
define('wiki-edit/KeyTester', function() {

    return {
        getActionType: function(keyCode) {
            if (this.isNavigation(keyCode)) {
                return "navigating";
            } else if (this.isDeleting(keyCode)) {
                return "deleting";
            } else if (this.isReturn(keyCode)) {
                return "newline";
            } else if (this.isEscape(keyCode)) {
                return "escape";
            } else if (this.isTyping(keyCode)) {
                return "typing";
            }
        },
        isNavigation: function(keyCode) {
            // 33 - 40: page up/dn and arrow keys
            // 63232 - 63235: page up/dn and arrow keys on safari
            return (keyCode >= 33 && keyCode <= 40) || (keyCode >= 63232 && keyCode <= 63235);
        },
        isDeleting: function(keyCode) {
            // 8 - backspace
            // 46 - delete
            // 127 - delete
            return (keyCode == 8 || keyCode == 46 || keyCode == 127);
        },
        isReturn: function(keyCode) {
            return (keyCode == 13);
        },
        isEscape: function(keyCode) {
            return (keyCode == 27);
        },
// not needed at this stage but left for possible later use
//        isSpacebar: function(keyCode) {
//            return keyCode == 32; // spacebar
//        },
        isTyping: function(keyCode) {
            return (keyCode > 47 && keyCode < 58)   || // numbers
                   (keyCode > 95 && keyCode < 112)  || // numpad
                   (keyCode > 64 && keyCode < 91)   || // letters
                   (keyCode > 185 && keyCode < 193) || // ;=,-./`
                   (keyCode > 218 && keyCode < 223) || // [\]'
                    keyCode == 32                   || // spacebar
                    keyCode == 13;                     // return

        }
    };

});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/UndoManager.js' */
define('wiki-edit/UndoManager', function() {

    /**
     * Simple undo/redo manager.
     * Basically the structure is like [---undoList---][CURRENT][---redoList---].
     * All operations move the current element on that "concatenated" list.
     */
    var UndoManager =  function() {
        this._undoStack = [];
        this._redoStack = [];
        this._current = undefined;
    };

    UndoManager.prototype.MAX_STACK = 1000;
    /**
     * Sets the current state of the manager
     * @param {Anything} current - state
     * @param {Boolean} preserveRedo - if set to true existing redo entries will be preserved
     */
    UndoManager.prototype.updateCurrent = function(current, preserveRedo) {
        if (current != this._current) {
            this._current = current;
            if(!preserveRedo) {
                this._redoStack.length = 0; // reset the redo stack
            }
        }
    };

    /**
     * Add val to the undo stack and make it undoable
     * @param {Anything} val - state to be made undoable
     */
    UndoManager.prototype.push = function(val) {
        this._redoStack.length = 0; // reset the redo stack
        if (!this._undoStack.length || !_.isEqual(val, this._undoStack[this._undoStack.length - 1])) {
            this._undoStack.push(val);
            this._current = val;
        }
        if (this._undoStack.length > this.MAX_STACK) {
            this._undoStack.splice(0, this._undoStack.length - this.MAX_STACK)
        }
    };

    /**
     * Undo a value. Set it to be the current element and push the current element to the redo stack
     * @return {Anything} current value after the undo operation
     */
    UndoManager.prototype.undo = function() {
        if (!this.canUndo()) { return; }
        var val;
        do {
            val = this._undoStack.pop();
        } while (_.isEqual(val, this._current) && this.canUndo());
        this._redoStack.push(this._current);
        this._current = val;
        return val;
    };

    /**
     * Redo a value. Set it to be the current element and push the current element to the undo stack
     * @return {Anything} current value after the redo operation
     */
    UndoManager.prototype.redo = function() {
        if (!this.canRedo()) { return; }
    
        var val = this._redoStack.pop();
        this._undoStack.push(this._current);
        this._current = val;
        return val;
    };

    /**
     * Check if it is possible to undo
     * @return {Boolean}
     */
    UndoManager.prototype.canUndo = function() {
        return !!this._undoStack.length;
    };

    /**
     * Check if it is possible to redo
     * @return {Boolean}
     */
    UndoManager.prototype.canRedo = function() {
        return !!this._redoStack.length;
    };

    return UndoManager;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/UndoableTextarea.js' */
define('wiki-edit/UndoableTextarea', [
        'wiki-edit/UndoManager',
        'wiki-edit/KeyTester',
        'jquery'
], function(
    UndoManager,
    KeyTester,
    $
) {

    var CUT_PASTE_MODE = "cut-paste";
    var _lastEditMode = "";

    function _setEditMode(context, newMode) {
        if (newMode === CUT_PASTE_MODE || _lastEditMode != newMode) {
            if (_lastEditMode != "newline") {
                context.recordHistoryItem();
            }
            _lastEditMode = newMode;
        }
    }

    function _manipulateHistory(context, stateName) {
        if (context.undoManager["can" + stateName[0].toUpperCase() + stateName.substring(1)]()) {
            var state = context.undoManager[stateName]();
            context.element.value = state.value;
            context.element.selectionStart = state.selectionStart;
            context.element.selectionEnd = state.selectionEnd;
        }
    }

    var UndoableTextarea = function UndoableTextarea(element) {
        this.element = element;
        this.$el = $(element);
        this.undoManager = new UndoManager();
        this.undoManager.updateCurrent(this.getValue());
        this.undoManager.push(this.getValue());

        var handleKeyboardInput = (function handleChange(e) {
            var keyCode = e.keyCode;
            var keyCodeChar = String.fromCharCode(keyCode);

            if (keyCode) {
                if (!e.ctrlKey && !e.metaKey) {
                    this.undoManager.updateCurrent(this.getValue());
                    _setEditMode(this, KeyTester.getActionType(keyCode));
                } else if ((e.ctrlKey || e.metaKey) && !e.altKey) {
                    switch (keyCodeChar.toLowerCase()) {
                        case "y":
                            this.undoManager.updateCurrent(this.getValue(), true);
                            this.redo();
                            e.preventDefault();
                            break;

                        case "z":
                            this.undoManager.updateCurrent(this.getValue(), true);
                            if (!e.shiftKey) {
                                this.undo();
                            } else {
                                this.redo();
                            }
                            e.preventDefault();
                            break;
                    }
                }
            } else {
                this.undoManager.updateCurrent(this.getValue());
                _setEditMode(this, "other");
            }
        }).bind(this);

        this.$el.on("keydown", handleKeyboardInput);

        this.$el.on("paste cut", function handleCutAndPaste() {
            this.undoManager.updateCurrent(this.getValue());
            _setEditMode(this, CUT_PASTE_MODE);
        }.bind(this));
    };

    UndoableTextarea.prototype.getValue = function() {
        return {
            value: this.element.value,
            selectionStart: this.element.selectionStart,
            selectionEnd: this.element.selectionEnd
        };
    };

    UndoableTextarea.prototype.updateCurrent = function() {
        this.undoManager.updateCurrent(this.getValue());
    };

    UndoableTextarea.prototype.recordHistoryItem = function() {
        this.undoManager.push(this.getValue());
    };

    UndoableTextarea.prototype.undo = function() {
        _setEditMode(this, "undo");
        _manipulateHistory(this, "undo");
        this.element.scrollTop = this.element.scrollHeight;
    };

    UndoableTextarea.prototype.redo = function() {
        _manipulateHistory(this, "redo");
        this.element.scrollTop = this.element.scrollHeight;
    };

    return UndoableTextarea;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/TextareaManipulator.js' */
define('wiki-edit/TextareaManipulator', function() {

    var TextareaManipulator = function(element) {
        this.el = element;
    };
    
    TextareaManipulator.prototype.NEW_LINE_TOKEN = "\n";
    
    /**
     * Gets object containing selection info
     * @returns {{position: number, start: number, end: number, length: number, text: string}}
     */
    TextareaManipulator.prototype.getSelection = function() {
        return {
            start: this.el.selectionStart,
            end: this.el.selectionEnd,
            length: this.el.selectionEnd - this.el.selectionStart,
            text: this.el.value.substring(this.el.selectionStart, this.el.selectionEnd)
        };
    };
    
    /**
     * Sets selection
     * @param start {number} index in the string, start of the selection
     * @param end {number} index in the string, end of the selection
     */
    TextareaManipulator.prototype.setSelection = function(start, end) {
        if (arguments.length === 1) {
            end = start;
        }
        this.el.selectionStart = start;
        this.el.selectionEnd = end;
    };
    
    /**
     * Replaces selected text with a parameter, if no text is selected
     * it's inserted where the cursor is
     * @param text {string} text to replace selection with
     * @param selectReplaced {Boolean} indicates if inserted text should be selected
     */
    TextareaManipulator.prototype.replaceSelectionWith = function(text, selectReplaced) {
        var start = this.el.selectionStart;
        var val = this.el.value;
        this.el.value = val.substring(0, this.el.selectionStart) + text + val.substring(this.el.selectionEnd, val.length);
    
        this.el.selectionEnd = start + text.length;
        this.el.selectionStart = (selectReplaced) ? start : this.el.selectionEnd;
    };
    
    /**
     * Wraps selection with a prefix and a suffix but only if it isn't already wrapped
     * @param prefix {string}
     * @param suffix {string}
     * @param placeholder {string} text to put between prefix and suffix if no selection was made
     */
    TextareaManipulator.prototype.wrapSelectionWith = function(prefix, suffix, placeholder) {
        if (arguments.length < 3) {
            placeholder = "";
        }
        if (arguments.length === 1) {
            suffix = prefix;
        }
        var selection = this.getSelection();
        var val = this.el.value;
    
        if (val.substring(selection.start - prefix.length, selection.start) === prefix &&
            val.substring(selection.end, selection.end + suffix.length) === suffix) {
            return;
        }
    
        var middle = val.substring(selection.start, selection.end);
        if (middle.length == 0) {
            middle = placeholder;
        }
        this.el.value = val.substring(0, selection.start) + prefix + middle + suffix + val.substring(selection.end, val.length);
        var newSelectionStart = selection.start + prefix.length;
        this.setSelection(newSelectionStart, newSelectionStart + middle.length);
    };
    
    /**
     * Finds selected lines within the textarea and returns an object containing full contents of the object
     * as an array of lines and start and end indexes of the selected lines
     * @returns {{lines: Array, start: number, end: number}}
     * @private
     */
    TextareaManipulator.prototype._getSelectedLines = function() {
        var val = this.el.value;
        var selection = this.getSelection();
        var startLine = val.substring(0, selection.start).split(this.NEW_LINE_TOKEN).length - 1; // 0-based index
        var endLine = startLine + val.substring(selection.start, selection.end).split(this.NEW_LINE_TOKEN).length - 1; // 0-based index
        var lines = val.split(this.NEW_LINE_TOKEN);
        return {
            lines: lines,
            start: startLine,
            end: endLine
        }
    };
    
    /**
     * Returns line at which cursor is (or end of the selection)
     * @returns {string}
     */
    TextareaManipulator.prototype.getLineAtCursor = function() {
        var linesSelection = this._getSelectedLines();
        return linesSelection.lines[linesSelection.end];
    };

    /**
     * Return regexp match of the fist line in the selection
     * @param pattern {regexp} prefix to check against
     * @returns {string} matched string or {undefined}
     */
    TextareaManipulator.prototype.getFirstLineMatch = function(pattern) {
        var linesSelection = this._getSelectedLines();
        var match = linesSelection.lines[linesSelection.start].match(pattern);
        if (match) {
            return match[0];
        }
    };
    
    /**
     * Checks if any of the selected lines is prefixed with a given string
     * @param prefix {string} prefix to check against
     * @returns {boolean}
     */
    TextareaManipulator.prototype.areSelectedLinesPrefixed = function(prefix) {
        var linesSelection = this._getSelectedLines();
        var currentLine;
    
        for (currentLine = linesSelection.start; currentLine <= linesSelection.end; currentLine++) {
            if (linesSelection.lines[currentLine].indexOf(prefix) == 0) {
                return true;
            }
        }
        return false;
    };
    
    /**
     * Prefixes selected lines with a given parameter. Lines already containing the prefix remain unchanged
     * @param prefix {string}
     */
    TextareaManipulator.prototype.prefixSelectedLines = function(prefix) {
        var selection = this.getSelection();
        var linesSelection = this._getSelectedLines();
        var currentLine;
        var prefixedLines = 0;
        var firstLinePrefixed = true;
        for (currentLine = linesSelection.start; currentLine <= linesSelection.end; currentLine++) {
            if (linesSelection.lines[currentLine].indexOf(prefix) == 0) {
                if (currentLine == linesSelection.start) {
                    firstLinePrefixed = false;
                }
                continue; //don't prefix lines which already have ie
            }
            prefixedLines += 1;
            linesSelection.lines[currentLine] = prefix + linesSelection.lines[currentLine];
        }
        this.el.value = linesSelection.lines.join(this.NEW_LINE_TOKEN);
    
        var prefixesLength = prefix.length * prefixedLines;
        this.setSelection(selection.start + ((firstLinePrefixed) ? prefix.length : 0), selection.end + prefixesLength);
    };
    
    /**
     * Removes prefix from selected lines
     * @param prefix {string}
     */
    TextareaManipulator.prototype.unprefixSelectedLines = function(prefix) {
        var selection = this.getSelection();
        var linesSelection = this._getSelectedLines();
        var currentLine;
        var firstLinePrefix = false;
        var prefixedLines = 0;
    
        for (currentLine = linesSelection.start; currentLine <= linesSelection.end; currentLine++) {
            if (linesSelection.lines[currentLine].indexOf(prefix) == 0) {
                prefixedLines += 1;
                linesSelection.lines[currentLine] = linesSelection.lines[currentLine].substring(prefix.length);
                if (currentLine == linesSelection.start) {
                    firstLinePrefix = true;
                }
            }
        }
        this.el.value = linesSelection.lines.join(this.NEW_LINE_TOKEN);

        var prefixesLength = prefix.length * prefixedLines;
        this.setSelection(selection.start - ((firstLinePrefix) ? prefix.length : 0), selection.end - prefixesLength);
    };

    return TextareaManipulator;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/keymaster-setup.js' */
define('wiki-edit/keymaster-setup', [
    'jquery',
    'wiki-edit/keymaster'
], function($, key) {
    return {
        init: function () {
            // Set-up library handling key bindings to correctly set scopes for wiki editor
            key.filter = function(event) {
                var element = event.target || event.srcElement || false;
                var editor;
                if (element && (' ' + element.className + ' ').indexOf(' wiki-textfield ') > -1) {
                    editor = $(element).data("wikiEditor");
                    if (editor) {
                        key.setScope(editor.id);
                        return true;
                    }
                }
                return false;
            };
        }
    }
});


;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/WikiEnabledTextarea.js' */
define('wiki-edit/WikiEnabledTextarea', [
        'wiki-edit/TextareaManipulator',
        'wiki-edit/UndoableTextarea',
        'wiki-edit/keymaster',
        'wiki-edit/keymaster-setup',
        'featureflags/feature-manager',
        'wiki-edit/SpeechRecognition',
        'jquery'
], function(TextareaManipulator, UndoableTextarea, onKey, keymasterSetup, FeatureManager, speechRecognition, $) {
    keymasterSetup.init();

    var editorCount = 0;
    // matches any combination of "*" and "#" followed by space which is any list, no matter how deeply nested
    var autocontinuingPrefixMarkupRegexp = /^[#\*]+ /;

    var WikiEnabledTextarea = function(element) {
        this.el = element;
        this.$el = $(element);
        if (this.$el.data("wikiEditor")) {
            // this will be very rare so defensive caching of this value doesn't seem to make much sense
            return this.$el.data("wikiEditor");
        }

        this.id = "wikiEdit" + editorCount;
        editorCount += 1;
        this.manipulationEngine = new TextareaManipulator(this.el);
        this.undoRedoEl = new UndoableTextarea(element);

        var wikiEditor = this;
        // on enter, continue list if possible or discontinue it if current list item is empty
        onKey("enter", wikiEditor.id, function onEnterKey(e) {
            var selection = wikiEditor.manipulationEngine.getSelection();
            var prefix = wikiEditor.manipulationEngine.getFirstLineMatch(autocontinuingPrefixMarkupRegexp);
            if (prefix) {
                if (selection.length == 0 && wikiEditor.manipulationEngine.getLineAtCursor() === prefix) {
                    wikiEditor.manipulationEngine.unprefixSelectedLines(prefix);
                } else {
                    wikiEditor.manipulationEngine.replaceSelectionWith("\n" + prefix);
                }
                e.preventDefault();
            }
        });

        this.$el.data("wikiEditor", this);
    };

    /**
     * Standard wiki markup in the form of <prefix>text<suffix> like *bold*, _italic_ or [mailto:someone@example.com].
     * Every time such markup is inserted:
     *     - if user didn't select any text, the placeholder text will be inserted and selected,
     *     - if user selected some text, this text will be wrapped with prefix and suffix.
     *
     * Each of this properties gets a function on the prototype with the same name
     * that changes value of textarea to apply the markup.
     */
    var wrapperMarkup = {
        'bold': ["*", "*", "strong text"],
        'italic': ["_", "_", "emphasized text"],
        'underline': ["+", "+", "underlined text"],
        'delete': ["-", "-", "deleted text"],
        'superscript': ["^", "^", "superscript text"],
        'subscript': ["~", "~", "subscript text"],
        'monospace': ["{{", "}}", "monospaced text"],
        'cite': ["??", "??", "citation"],
        'block-quote': ["{quote}", "{quote}", "quoted text"],
        'color': ["{color:$1}", "{color}", "colored text", "red"], // 4th parameter is a default value to replace $
        'link': ["[", "]", "link title"+"|http://example.com"],
        'link-anchor': ["[#", "]", "anchor"],
        'link-mail': ["[mailto:", "]", "mail@example.com"],
        'image': ["!", "!", "http://example.com/image.png"],
        'mention': ["@", "", "Mention someone by typing their name..."],
        'code': ["\n{code:java}\n","\n{code}\n", "// Some comments here\npublic String getFoo()\n{\n    return foo;\n}"],
        'noformat': ["\n{noformat}\n", "\n{noformat}\n", "*no* further _formatting_ is done here"],
        'panel': ["\n{panel:title="+"My title"+"}\n", "\n{panel}\n", "Some text with a title"],
        'table': ["\n||"+"Heading"+" 1||"+"Heading"+" 2||\n|", "|"+"Col"+" A2|\n", "Col"+" A1"]
    };

    for(var key in wrapperMarkup) {
        WikiEnabledTextarea.prototype[key] = (function(args, operationKey) {
            var paramsNumber = 0;
            if (args.length > 3) {
                paramsNumber = args.length - 3;
            }
            return function() {

                var prefix = args[0];
                var suffix = args[1];
                var placeholder = args[2];

                var i;
                for (i = 1; i <= paramsNumber; i++) {
                    prefix = prefix.replace("$"+i, arguments[i-1] || args[2 + i]);
                    suffix = suffix.replace("$"+i, arguments[i-1] || args[2 + i]);
                }

                var value = this.el.value;
                var selection = this.manipulationEngine.getSelection();

                this.undoRedoEl.recordHistoryItem();

                // unwrap selection if needed
                if (value.substring(selection.start - prefix.length, selection.start) === prefix &&
                    value.substring(selection.end, selection.end + suffix.length) === suffix) {

                    this.el.value = value.substring(0,selection.start - prefix.length) +
                    value.substring(selection.start, selection.end) +
                    value.substring(selection.end + suffix.length, value.length);

                    this.manipulationEngine.setSelection(selection.start - prefix.length, selection.end - prefix.length);

                    // wrap selection with markup
                } else {
                    this.manipulationEngine.wrapSelectionWith.call(this.manipulationEngine, prefix, suffix, placeholder);
                }
                this.undoRedoEl.recordHistoryItem();
                this.$el.trigger("input");
            };
        })(wrapperMarkup[key], key);
    }

    /**
     * Markup that is always a prefix for entire line, like h1. or bullet lists "* ".
     * Those prefixes are mutually exclusive, which means each line can be only prefixed with one of them
     * and applying one of them will remove any other.
     *
     * Each of this properties gets a function on the prototype with the same name
     * that changes value of textarea to apply the markup.
     */
    var excludingLinePrefixMarkup = {
        'paragraph': "",
        'bullet-list': "* ",
        'numbered-list': "# ",
        'h1': 'h1. ',
        'h2': 'h2. ',
        'h3': 'h3. ',
        'h4': 'h4. ',
        'h5': 'h5. ',
        'h6': 'h6. ',
        'paragraph-quote': 'bq. '
    };

    for(var key in excludingLinePrefixMarkup) {
        WikiEnabledTextarea.prototype[key] = (function(prefix) {
            return function() {
                this.undoRedoEl.recordHistoryItem();
                // check if line is already prefixed with one of the prefixes there
                for(var prefixToRemove in excludingLinePrefixMarkup) {
                    if (this.manipulationEngine.areSelectedLinesPrefixed(excludingLinePrefixMarkup[prefixToRemove])) {
                        this.manipulationEngine.unprefixSelectedLines(excludingLinePrefixMarkup[prefixToRemove]);
                    }
                }

                this.manipulationEngine.prefixSelectedLines.call(this.manipulationEngine, prefix);
                this.undoRedoEl.recordHistoryItem();
                this.$el.trigger("input");
            };
        })(excludingLinePrefixMarkup[key]);
    }

    /**
     * Markup that is just inserted in place of cursor or selection. The cursor is then placed at the end of inserted text.
     *
     * Each of this properties gets a function on the prototype with the same name
     * that changes value of textarea to apply the markup.
     */
    var insertMarkupWithoutSelecting = {
        'hr': "\n----\n",
        ':)': ':)',
        ':(': ':(',
        ':P': ':P',
        ':D': ':D',
        ';)': ';)',
        '(y)': '(y)',
        '(n)': '(n)',
        '(i)': '(i)',
        '(/)': '(/)',
        '(x)': '(x)',
        '(!)': '(!)',
        '(+)': '(+)',
        '(-)': '(-)',
        '(?)': '(?)',
        '(on)': '(on)',
        '(off)': '(off)',
        '(*)': '(*)',
        '(*r)': '(*r)',
        '(*g)': '(*g)',
        '(*b)': '(*b)',
        '(*y)': '(*y)',
        '(flag)': '(flag)',
        '(flagoff)': '(flagoff)',
        'image-attachment': [" !$1|thumbnail! ", "attachment-name.jpg"],
        'image-attachment-full': [" !$1! ", "attachment-name.gif"],
        'link-attachment': [" [^$1] ", "attachment-name.zip"]
    };

    for(var key in insertMarkupWithoutSelecting) {
        WikiEnabledTextarea.prototype[key] = (function(toInsert) {
            var paramsNumber = 0;
            var defaultValues;
            if (_.isArray(toInsert)) {
                paramsNumber = toInsert.length - 1;
                defaultValues = toInsert.slice(1);
                toInsert = toInsert[0];
            }
            return function() {
                var i;
                var result = toInsert;
                for (i = 1; i <= paramsNumber; i++) {
                    result = toInsert.replace("$"+i, arguments[i-1] || defaultValues[i-1]);
                }
                this.undoRedoEl.recordHistoryItem();
                this.manipulationEngine.replaceSelectionWith.call(this.manipulationEngine, result, false);
                this.undoRedoEl.recordHistoryItem();
                this.$el.trigger("input");
            };
        })(insertMarkupWithoutSelecting[key]);
    }

    WikiEnabledTextarea.prototype.speech = function()
    {
        speechRecognition.start(this);
    };

    return WikiEnabledTextarea;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/WikiEditor.js' */
define('wiki-edit/WikiEditor', [
    'wiki-edit/WikiEnabledTextarea',
    'jquery',
    'underscore',
    'wiki-edit/JIRA',
    'wiki-edit/keymaster',
    'wiki-edit/analytics',
    'wiki-edit/WikiEditorUtil',
    'jira/util/events',
    'featureflags/feature-manager'
], function (
    WikiEnabledTextarea,
    $,
    _,
    JIRA,
    key,
    analytics,
    WikiEditorUtil,
    JIRAEvents,
    FeatureManager
) {

    var controlKey = 'Ctrl';
    if (navigator.platform.indexOf('Mac') != -1) {
        controlKey = '⌘';
    }

    // Check jira.unified.attachments.m2 dark feature toggle
    var unifiedAttachmentsM2IsEnabled = function() {
        return FeatureManager.isFeatureEnabled("jira.unified.attachments.m2");
    };

    var determineFileType = function (fileName) {
        return fileName.match(/\.(bmp|gif|jpg|jpeg|png|tiff|webp)$/i) ? 'image' : 'file';
    };

    var insertMarkup = function (wikiEditor, fileName, fileType) {
        // Gif attachments are rendered without thumbnail (eg: !lolcat.gif!) so they can animate properly
        if (unifiedAttachmentsM2IsEnabled()) {
            if (fileType == "image") {
                if (fileName.match(/\.gif$/i)) {
                    wikiEditor["image-attachment-full"](fileName);
                } else {
                    wikiEditor["image-attachment"](fileName);
                }

                analytics.trigger("operation.attachment.image");
            } else {
                wikiEditor["link-attachment"](fileName);
                analytics.trigger("operation.attachment.link");
            }
        } else {
            wikiEditor["image-attachment"](fileName);
            analytics.trigger("operation.attachment.image");
        }
    };

    return {
        create: function (element) {
            // disable plugin in IE <=8
            if (typeof element.selectionStart == "undefined") {
                return;
            }

            var $editorElement = $(element);

            if ($editorElement.data("wikiEditor")) {
                return;
            }

            // todo editor should initialize all html and events by itself
            var wikiEditor = new WikiEnabledTextarea(element);
            this.wikiEditor = wikiEditor;

            var $editorHtml = $(JIRA.Templates.Plugins.WikiEditor.renderEditor({
                editorId: wikiEditor.id,
                controlKey: controlKey,
                attachmentM2FeatureFlag: unifiedAttachmentsM2IsEnabled()
            }));
            var $editorToolbar = $editorHtml.filter(".wiki-edit-toolbar");

            // speech-capable browser?
            if ("webkitSpeechRecognition" in window) {
                $editorHtml.find(".wiki-edit-speech-item").removeClass("hidden");
            }

            $editorElement.parent().before($editorHtml);

            // detect if we are dealing with dialog
            var isDialog = $editorElement.closest(".jira-dialog").length > 0 || $editorElement.closest("form#issue-create").length > 0;
            var isCreateDialog = $editorElement.closest("#create-issue-dialog").length > 0;
            // detect if we are on view issue page
            var isViewIssue = $("#issue-content").length > 0;
            var isComment = $editorElement.closest("#addcomment").length > 0;

            var elementsWithTooltips = $editorHtml.find(".wiki-edit-operation[title], .aui-dropdown2-trigger, .wiki-edit-tooltip");
            var onWikiEditorHideEventName;
            if (isDialog) {
                onWikiEditorHideEventName = 'Dialog.beforeHide';
            } else {
                onWikiEditorHideEventName = JIRA.Events.BEFORE_INLINE_EDIT_CANCEL;
            }
            elementsWithTooltips.each(function () {
                var $this = $(this);
                var config = {
                    aria: true,
                    hideOnClick: true,
                    hoverable: false
                };
                if ($this.parent().is('li')) {
                    config.gravity = 'w';
                }
                $this.tooltip(config);
            });
            var hideAllTooltips = function (){
                elementsWithTooltips.each(function(){
                    $(this).tooltip('hide');
                });
            };
            JIRA.bind(onWikiEditorHideEventName, hideAllTooltips);

            var isDropdownEnabled = false;
            var $wikiDropdown = $editorHtml.filter(".aui-dropdown2");
            $wikiDropdown.on({
                'aui-dropdown2-show': function () {
                    isDropdownEnabled = true;

                    // focus on editorElement when dropdown opens so
                    // it can handle keyboard event (especially in dialogs)
                    $editorElement.focus();
                },
                'aui-dropdown2-hide': function () {
                    isDropdownEnabled = false;

                    hideAllTooltips();
                }
            });
            $editorElement.on('keydown', function checkEscapePressWhenDropdownIsEnabled(e) {
                if (isDropdownEnabled && e.keyCode === AJS.keyCode.ESCAPE) {
                    if (isDialog) {
                        JIRA.one("Dialog.beforeHide", function (e) {
                            e.preventDefault();
                        });
                    } else if (isViewIssue && !isComment) {
                        JIRA.one(JIRA.Events.BEFORE_INLINE_EDIT_CANCEL, function preventInlineEditCloseIfAnyDropdownIsEnabled(e) {
                            e.preventDefault();
                        });
                    }
                }
            });


            var $attachmentDropdown = $editorHtml.filter(
                ".wiki-edit-dropdown-image, " +
                ".wiki-edit-dropdown-attachment"
            );

            var $attachmentListContainer = $attachmentDropdown.find(
                ".wiki-edit-insert-image, " +
                ".wiki-edit-insert-attachment"
            );

            var $attachmentList = $attachmentDropdown.find(
                ".wiki-edit-insert-image ul, " +
                ".wiki-edit-insert-attachment ul"
            );

            // Attachment dropdown link click handler
            $attachmentList.on("click", "a", function (e) {
                e.preventDefault();

                var fileType = $(this).attr("data-attachment-type");
                if (typeof fileType === "undefined") {
                    fileType = "file";
                }

                var fileName = $(this).find('.wiki-edit-attachment-name').text();

                insertMarkup(wikiEditor, fileName, fileType);
            });

            // Build attachment links when attachment button is pressed
            $attachmentDropdown.on("aui-dropdown2-show", function () {
                var genericAttachments = [];

                // Add temporary attachments (those added before dialog is saved such as in create/edit dialog)
                if (isDialog) {
                    $(".upload-progress-bar:not(.upload-progress-bar__upload-error) span.upload-progress-bar__file-name").each(function(i,v){
                        genericAttachments.push(v);
                    });
                }

                // Add permanent attachments
                if (!isCreateDialog && isViewIssue) {
                    $("#attachment_thumbnails li.attachment-content, " +
                      "#file_attachments li.attachment-content").each(function(i,v){
                        genericAttachments.push(v);
                    });
                }

                $attachmentList.empty();
                $attachmentListContainer.addClass("hidden");

                if ((isDialog || isViewIssue) && genericAttachments.length) {
                    $attachmentListContainer.removeClass("hidden");

                    /**
                     * Contents of $genericAttachments (ie: "this") could be:
                     * - A thumbnails (gallery) view item
                     * - A list view item
                     * - Create / edit dialog entry
                     */
                    $(genericAttachments).each(function () {
                        // Handle various form of DOM structure a file name can appear in (create issue dialog,
                        // edit issue - list view, edit issue - thumbnail view
                        var fileName = $(this).is('span.upload-progress-bar__file-name') ?
                            $(this).text() :
                            $(this).find('a.attachment-title, .attachment-title a').first().text();

                        // Determine file type by 'data-attachment-type' attribute, or fall back by checking
                        // popular image file extension
                        var fileType = $(this).attr('data-attachment-type');
                        if (fileType === undefined) {
                            fileType = determineFileType(fileName);
                        }

                        // Try to figure out the attachment type icon using mime type. On thumbnail / list view mime-type
                        // can be looked up using data-downloadurl attribute. If mime-type not available let's fall back
                        // using file extension. And if that still doesn't work use aui-iconfont-file-txt.
                        var typeIcon = WikiEditorUtil.defaultAttachmentTypeIcon;
                        var dataDownloadUrl = $(this).attr('data-downloadurl');
                        if (dataDownloadUrl === undefined) {
                            dataDownloadUrl = $(this).find('[data-downloadurl]').attr('data-downloadurl');
                        }
                        if (dataDownloadUrl !== undefined && typeof dataDownloadUrl === 'string') {
                            var attrs = dataDownloadUrl.split(':');
                            if (attrs.length > 0) {
                                var mimeType = attrs[0];
                                typeIcon = WikiEditorUtil.translateMimeTypeToAttachmentTypeIcon(mimeType);
                            }
                        } else if (fileName !== undefined && typeof fileName === 'string') {
                            var matches = fileName.match(/\.(\w{1,5})$/i); // regex match exts such as .gz,.jpg,.docx,.3gp and discard the dot prefix
                            if (matches && matches.length > 1) {
                                var fileExtension = matches[1];
                                typeIcon = WikiEditorUtil.translateFileExtensionToAttachmentTypeIcon(fileExtension);
                            }
                        }

                        // If feature is disabled do not list non-image attachments
                        if (!unifiedAttachmentsM2IsEnabled() && fileType !== "image") {
                            return;
                        }

                        $attachmentList.append(
                            $(JIRA.Templates.Plugins.WikiEditor.renderListItem({
                                text: fileName,
                                attachmentType: fileType,
                                attachmentTypeIcon: typeIcon,
                                attachmentM2FeatureFlagEnabled: unifiedAttachmentsM2IsEnabled()
                            }))
                        );
                    });
                }
            });

            // dropdown2 fix so when item is selected using keyboard the container div scrolls
            // properly. This bug was fixed on AUI 5.8+ so only do this for older AUI versions
            if (WikiEditorUtil.compareVersion(AJS.version, '5.8.0') < 0) {
                $attachmentDropdown.on('aui-dropdown2-item-selected', function scrollContainerDivIfActiveItemIsOutOfView() {
                    var $active = $(this).find('.aui-dropdown2-active');
                    if (typeof $active !== 'object') {
                        return;
                    }
                    var $container = $active.closest('div');
                    if (typeof $container !== 'object') {
                        return;
                    }

                    // top/bottom limits are extreme points above/below which element will not / only be partially visible
                    var containerTopLimit = $container.offset().top;
                    var containerBottomLimit = containerTopLimit + $container.height();

                    var elementTop = $active.offset().top;
                    var elementBottom = elementTop + $active.height();

                    // Active element is (partially) above the container viewport, scroll up
                    if (elementTop < containerTopLimit) {
                        $container.scrollTop($container.scrollTop() - (containerTopLimit - elementTop));
                    }

                    // Active element is (partially) below the container viewport, scroll down
                    if (elementBottom > containerBottomLimit) {
                        $container.scrollTop($container.scrollTop() + (elementBottom - containerBottomLimit));
                    }
                });
            }

            // SUCCESS-198: Prevent attachments from being listed on links drop down
            if (!unifiedAttachmentsM2IsEnabled()) {
                var $linkDropdown = $editorHtml.filter(".wiki-edit-dropdown-link");
                var $linksList = $linkDropdown.find(".wiki-edit-insert-link");
                var $linkLinkDefault = $linkDropdown.find(".wiki-edit-operation[data-operation=link-attachment]");
                var $linkLinks = $linkDropdown.find(".wiki-edit-insert-link ul");
                $linkLinks.on("click", "a", function (e) {
                    e.preventDefault();
                    wikiEditor["link-attachment"]($(this).text());
                    analytics.trigger("operation.attachment.link");
                });

                $linkDropdown.on("aui-dropdown2-show", function () {
                    var $linkAttachments = $();
                    if (!isCreateDialog && isViewIssue) {
                        $linkAttachments = $linkAttachments.add("#attachment_thumbnails .attachment-title, #file_attachments .attachment-title a");
                    }
                    if (isDialog) {
                        $linkAttachments = $linkAttachments.add(".upload-progress-bar:not(.upload-progress-bar__upload-error) .upload-progress-bar__thumbnail + .upload-progress-bar__file-name");
                    }

                    var attachments = _.uniq($linkAttachments, false, function getValue(item) {
                        return $(item).text().trim();
                    });

                    $linkLinks.empty();
                    $linksList.addClass("hidden");
                    $linkLinkDefault.removeClass("hidden");

                    if ((isDialog || isViewIssue) && attachments.length) {
                        $linksList.removeClass("hidden");
                        $linkLinkDefault.addClass("hidden");
                        attachments.forEach(function (element) {
                            $linkLinks.append(
                                $(JIRA.Templates.Plugins.WikiEditor.renderListItem({
                                    text: $(element).text().trim(),
                                    attachmentM2FeatureFlagEnabled: unifiedAttachmentsM2IsEnabled()
                                }))
                            );
                        });
                    }
                });
            }

            $editorHtml.filter(".wiki-edit-dropdown, .wiki-edit-picker").on("mousedown", function (e) {
                e.preventDefault(); // prevent blurring textarea, needed for inline mode
            });

            // attach keyboard shortcuts
            $editorHtml.find(".wiki-edit-operation:not(.wiki-edit-operation-color)").each(function () {
                var $this = $(this);
                var handler = function (e) {
                    if (!e) {
                        return;
                    }
                    e.preventDefault && e.preventDefault();
                    $editorElement.focus();
                    wikiEditor[$this.data("operation")]();
                    analytics.trigger("operation", {
                        name: $this.data("operation"),
                        nameHash: analytics.hashCode($this.data("operation")),
                        trigger: e.type
                    });
                    analytics.trigger("operation." + $this.data("operation"), {trigger: e.type});
                };

                // todo event delegation, fool!
                $this.click(handler);
                if ($this.data("shortcut")) {
                    // todo shortcuts should be binded once, globally
                    key($this.data("shortcut"), wikiEditor.id, handler);
                }
            });

            // text color
            $editorHtml.find(".wiki-edit-operation-color").each(function () {
                var $this = $(this);
                var handler = function (e) {
                    if (!e) {
                        return;
                    }
                    e.preventDefault && e.preventDefault();
                    $editorElement.focus();
                    wikiEditor[$this.data("operation")]($this.data("color"));
                    analytics.trigger("operation", {
                        name: $this.data("operation"),
                        nameHash: analytics.hashCode($this.data("operation")),
                        trigger: e.type
                    });
                    analytics.trigger("operation." + $this.data("operation"), {trigger: e.type});
                };

                // todo event delegation, fool!
                $this.click(handler);
                if ($this.data("shortcut")) {
                    // todo shortcuts should be binded once, globally
                    key($this.data("shortcut"), wikiEditor.id, handler);
                }

            });

            var defaultColor = (window.localStorage.getItem("jira.wikieditor.last.color")) ? window.localStorage.getItem("jira.wikieditor.last.color") : "red";
            var $colorOperation = $editorHtml.find(".wiki-edit-operation-color");
            $colorOperation.data("color", defaultColor);
            var $colorIndicator = $editorToolbar.find(".wiki-edit-color-indicator");
            $colorIndicator.css("background-color", defaultColor);

            $editorHtml.filter(".wiki-edit-color-picker").on("click", "a", function (e) {
                e.preventDefault();
                $editorElement.focus();
                var color = $(this).data("color");
                wikiEditor.color(color);
                analytics.trigger("operation", {name: "color"});
                analytics.trigger("operation.color.picked", {color: color});
                $colorOperation.data("color", color);
                $colorIndicator.css("background-color", color);
                window.localStorage.setItem("jira.wikieditor.last.color", color);
            });

            var $visibilityToggle = $editorHtml.find('.wiki-edit-visible-toggle');
            var hideToolbar = (localStorage.getItem("jira.wikieditor.visibility" + element.name + '.' + element.id) === "true") ? true : false;
            if (hideToolbar) {
                $visibilityToggle.addClass("active");
                $editorToolbar.addClass("wiki-edit-toolbar-compact");
            }

            function toggleEditor(e) {
                e.preventDefault();
                e.stopPropagation();
                hideToolbar = !hideToolbar;
                $visibilityToggle.toggleClass("active", hideToolbar);
                $editorToolbar.toggleClass("wiki-edit-toolbar-compact", hideToolbar);
                localStorage.setItem("jira.wikieditor.visibility" + element.name + '.' + element.id, (hideToolbar) ? "true" : "false");
                analytics.trigger((hideToolbar) ? "hide" : "show")
            }

            $visibilityToggle.on("click", toggleEditor);
            $editorToolbar.parent().on("click", ".wiki-edit-toolbar-compact", toggleEditor);

            $(document).on("showWikiPreview", function (e, el) {
                if ($(el).find(element).length) {
                    $editorToolbar.addClass("hidden");
                }
            });
            $(document).on("showWikiInput", function (e, el) {
                if ($(el).find(element).length) {
                    $editorToolbar.removeClass("hidden");
                }
            });
        },

        initBrowseLink: function (element) {
            var wikiEditor = this.wikiEditor;

            if (unifiedAttachmentsM2IsEnabled()) {
                var $editorElement = $(element);

                var $browseButton = $editorElement.parent().siblings().find(".wiki-attachment-browse");
                var canAttach = $("#dnd-metadata-webpanel").data("can-attach");

                var isDialog = $editorElement.closest(".jira-dialog").length > 0 || $editorElement.closest("form#issue-create").length > 0;

                if (isDialog) {
                    // These are the dialogs we want to show the browse link in.
                    // The dialogs have an attachment dropzone that we can use to simulate a drop.
                    var supportedDialogSelectors = ['#create-issue-dialog:visible', '#create-subtask-dialog:visible', '#edit-issue-dialog:visible', '#create-linked-issue-dialog:visible'];
                    var supportedDialog = $(supportedDialogSelectors.join(","));
                    var isSupportedDialog = supportedDialog.length > 0;
                    canAttach = $(".jira-dialog fieldset span:contains('Attachment')").length > 0;

                    // If we did not find a dialog that we know can receive files, we search
                    // for other dialogs that explicitly state that they can receive files.
                    if (!isSupportedDialog) {
                        supportedDialog = $editorElement.closest(".dialog-can-receive-files:visible");
                        isSupportedDialog = supportedDialog.length > 0;
                        // If we do find such a dialog, we consume its can-attach (boolean) data attribute.
                        // If the dialog does not have that attribute, canAttach will be undefined and the
                        // browse link will not be shown.
                        canAttach = supportedDialog.data("can-attach");
                    }
                    var insertMarkupInDialog = supportedDialog.data("insert-markup-on-browse");
                }

                var $attachmentsDropdown = $editorElement.parent().siblings().find(".wiki-edit-attachment-picker-trigger");

                if (canAttach && (isDialog ? isSupportedDialog : true)) {
                    $browseButton.closest("div").removeClass("hidden");
                    $attachmentsDropdown.removeClass("hidden");
                    if (!$browseButton.data("initialised")) {
                        $browseButton.on('click', function (e) {
                            e.preventDefault();

                            var $tempFileInput = $("<input type=\"file\" multiple />");
                            $tempFileInput.change(function (event) {
                                var files = $tempFileInput[0].files;
                                if (isDialog) {
                                    var dropEvent = $.Event("drop");
                                    dropEvent.dataTransfer = {files: files};
                                    supportedDialog.find('.issue-drop-zone__target').trigger(dropEvent);
                                }
                                else {
                                    // This event comes from the JIRA Drag and Drop Plugin.
                                    JIRAEvents.trigger("attachmentForPageReceived", {
                                        files: files,
                                        isWikiTextfieldFocused: true
                                    });
                                }
                                if (isDialog ? insertMarkupInDialog : true) {
                                    for (var i = 0; i < files.length; i++) {
                                        var fileName = files[i].name;
                                        insertMarkup(wikiEditor, fileName, determineFileType(fileName));
                                    }
                                }
                            });
                            $tempFileInput.click();

                            analytics.trigger("attachment.dropdown.button.clicked.browse");
                        });
                        $browseButton.data("initialised", true);
                    }
                }
                else {
                    $browseButton.closest("div").addClass("hidden");

                    // Here we know the browse button will be hidden. If we will
                    // not show an attachments list, the attachment dropdown will be empty
                    // so we want to hide the attachment dropdown altogether.
                    var $genericAttachments = $("#attachment_thumbnails li.attachment-content, #file_attachments li.attachment-content");
                    var currentIssueHasAttachments = $genericAttachments.length > 0;

                    // Create issue/Create subtask dialogs are special because even if the current issue has attachments,
                    // we are not supposed to show these attachments in those two dialogs (because attachments are per issue).
                    var isCreateIssueOrSubtaskDialog = isDialog && isSupportedDialog &&
                        (supportedDialog.attr("id") === "create-issue-dialog" || supportedDialog.attr("id") === "create-subtask-dialog");

                    var willShowAttachmentsList = currentIssueHasAttachments &&  !isCreateIssueOrSubtaskDialog;

                    if (!willShowAttachmentsList) {
                        $attachmentsDropdown.addClass("hidden");
                    }
                }
            }
        }
    }
});

;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/WikiEditorUtil.js' */
define('wiki-edit/WikiEditorUtil', [
    'jquery',
    'underscore'
], function (
    $,
    _
) {

    var _defaultAttachmentTypeIcon = {
        cssClass : 'aui-iconfont-devtools-file',
        title : ''
    };

    var _fileExtToAttachmentTypeIconCssClass = {
        'pdf'   : 'aui-iconfont-file-pdf',

        'gif'   : 'aui-iconfont-image',
        'png'   : 'aui-iconfont-image',
        'jpeg'  : 'aui-iconfont-image',
        'jpg'   : 'aui-iconfont-image',

        'xml'   : 'aui-iconfont-file-code',
        'html'  : 'aui-iconfont-file-code',
        'htm'   : 'aui-iconfont-file-code',
        'txt'   : 'aui-iconfont-file-txt',

        'zip'   : 'aui-iconfont-file-zip',
        'gz'    : 'aui-iconfont-file-zip',
        'tar'   : 'aui-iconfont-file-zip',
        'rar'   : 'aui-iconfont-file-zip',
        '7z'    : 'aui-iconfont-file-zip',

        'doc'   : 'aui-iconfont-file-doc',
        'docx'  : 'aui-iconfont-file-doc',
        'xls'   : 'aui-iconfont-file-xls',
        'xlsx'  : 'aui-iconfont-file-xls',
        'xlsm'  : 'aui-iconfont-file-xls',
        'ppt'   : 'aui-iconfont-file-ppt',
        'pptx'  : 'aui-iconfont-file-ppt',

        'java'  : 'aui-iconfont-file-code',
        'c'     : 'aui-iconfont-file-code',
        'h'     : 'aui-iconfont-file-code',
        'cpp'   : 'aui-iconfont-file-code',
        'hpp'   : 'aui-iconfont-file-code',
        'scala' : 'aui-iconfont-file-code',
        'php'   : 'aui-iconfont-file-code',
        'css'   : 'aui-iconfont-file-code',
        'less'  : 'aui-iconfont-file-code',
        'soy'   : 'aui-iconfont-file-code',
        'js'    : 'aui-iconfont-file-code',
        'jar'   : 'aui-iconfont-file-zip',
        'war'   : 'aui-iconfont-file-zip',
        'obr'   : 'aui-iconfont-file-zip'
    };

    var _fileExtToAttachmentTypeIconTitle = {
        'pdf'   : "PDF File",

        'gif'   : "GIF File",
        'png'   : "PNG File",
        'jpeg'  : "JPEG File",
        'jpg'   : "JPEG File",

        'xml'   : "XML File",
        'html'  : "HTML File",
        'htm'   : "HTML File",
        'txt'   : "Text File",

        'zip'   : "Zip Archive",
        'gz'    : "GZip Archive",

        'doc'   : "Microsoft Word",
        'docx'  : "Microsoft Word",
        'xls'   : "Microsoft Excel",
        'xlsx'  : "Microsoft Excel",
        'xlsm'  : "Microsoft Excel",
        'ppt'   : "Microsoft PowerPoint",
        'pptx'  : "Microsoft PowerPoint",

        'java'  : "Java Source File",
        'jar'   : "Java Archive File",
        'war'   : "Java Archive File"
    };

    return {

        /**
         * Default attachment type icon, used as a fallback if type couldn't be determined
         */
        defaultAttachmentTypeIcon : _defaultAttachmentTypeIcon,

        /**
         * Used by attachments dropdown to determine what icon to put to the left of attachment name
         * Icon is decided by attachment mime type
         *
         * @param {string} mimeType attachment mime type (eg: image/jpg)
         *
         * @returns Object with cssClass and title attributes.
         *  If translation fails cssClass is aui-iconfont-devtools-file and title is empty string.
         */
        translateMimeTypeToAttachmentTypeIcon : function (mimeType) {
            return {
              cssClass : JIRA.Templates.ViewIssue.matchFileClass( { mimetype : mimeType } ),
              title : JIRA.Templates.ViewIssue.matchFileIconAlt( { mimetype : mimeType } )
            };
        },

        /**
         * Used by attachments dropdown to determine what icon to put to the left of attachment name
         * Icon is decided by file extension
         *
         * @param extension extension name, with or without dot prefix (eg: .pdf, doc)
         *
         * @returns Object with cssClass and title attributes.
         *  If translation fails cssClass is aui-iconfont-devtools-file and title is empty string.
         */
        translateFileExtensionToAttachmentTypeIcon : function (extension) {
            var result = _.clone(_defaultAttachmentTypeIcon);

            if (typeof extension !== 'string') {
                return result;
            }

            extension = extension.toLowerCase();
            extension = extension.replace(/^\.+/, '');

            var cssClass = _fileExtToAttachmentTypeIconCssClass[extension];
            if (typeof cssClass === 'string') {
                result.cssClass = cssClass;
            }

            var title = _fileExtToAttachmentTypeIconTitle[extension];
            if (typeof title === 'string') {
                result.title = title;
            }

            return result;
        },

        /**
         * Perform version number comparison. Returns a number less than 0 if version A is lower than B, greater than 0
         * if A is higher than B, 0 if both equals.
         *
         * Example:
         * - compareVersion('5.7.10', '5.8.0') // returns -1
         * - compareVersion('5.8.0', '5.8.0') // returns 0
         * - compareVersion('5.8.1', '5.8.0') // returns 1
         * - compareVersion('5.10.0', '5.8.0') // returns 1
         * - compareVersion('5.8', '5.8.0') // returns -1
         * - compareVersion('5.8', '5.8.0') // returns -1
         * - compareVersion('5.0a', '5.0') // returns NaN
         *
         * @param verA (string) version number (eg: 5.7.10)
         * @param verB (string) version number (eg: 5.7.10)
         *
         * @return (number) A number less than 0 if version A is lower than B, greater than 0 if A is higher than B,
         * 0 if both equals, NaN if version comparison can't be performed
         */
        compareVersion : function (verA, verB) {
            var partsA = verA.split('.');
            var partsB = verB.split('.');
            var result = NaN;

            $(partsA).each(function (i, e) {
                if (i >= partsB.length) {
                    return false;
                }
                var partA = Number(e);
                var partB = Number(partsB[i]);
                if (isNaN(partA) || isNaN(partB)) {
                    //noinspection JSUnusedAssignment
                    result = NaN;
                    return false;
                }
                if (partA < partB) {
                    //noinspection JSUnusedAssignment
                    result = -1;
                    return false;
                } else if (partA > partB) {
                    //noinspection JSUnusedAssignment
                    result = 1;
                    return false;
                }
                result = 0;
            });

            if (result == 0 && partsA.length != partsB.length) {
                return (partsA.length > partsB.length) ? 1 : -1;
            }

            return result;
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/SpeechRecognition.js' */
define('wiki-edit/SpeechRecognition', [
    'jquery',
    'aui/flag'
], function ($, auiFlag)
{
    function getIsFinal(results)
    {
        return results && results[0] && results[0].isFinal;
    }
    function getTranscript(results)
    {
        return results && results[0] && results[0][0] && results[0][0].transcript || '';
    }

    return {
        start: function (textareaInstance)
        {
            var self = this;
            var recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = true;
            // if lang is converted into something that Chrome does not understand, it defaults to the system language
            recognition.lang = AJS.Meta.get("user-locale").replace("_", "-");
            // stops any recognition in progress to start a new session
            recognition.stop();
            recognition.start();

            recognition.onstart = function()
            {
                self.showTimedMessage({title: "You can start speaking now :)"}, "info", 10);
                self.selectionStart = textareaInstance.manipulationEngine.getSelection().start;
            }
            recognition.onresult = function(event)
            {
                self.dismissCurrentMessage();
                var isFinal = getIsFinal(event.results);
                var speechResult = getTranscript(event.results);
                // capitalise first letter
                speechResult = speechResult.charAt(0).toUpperCase() + speechResult.slice(1);

                if (isFinal)
                {
                    textareaInstance.undoRedoEl.recordHistoryItem();
                }
                textareaInstance.manipulationEngine.replaceSelectionWith.call(textareaInstance.manipulationEngine, speechResult, false);
                var selectionEnd = self.selectionStart + speechResult.length;
                if (isFinal)
                {
                    // clears the selection
                    textareaInstance.manipulationEngine.setSelection(selectionEnd);
                    textareaInstance.undoRedoEl.recordHistoryItem();
                    textareaInstance.$el.trigger("input");
                    recognition.stop();
                }
                else
                {
                    textareaInstance.manipulationEngine.setSelection(self.selectionStart, selectionEnd);
                }
            }
            recognition.onerror = function(event)
            {
                recognition.stop();

                // this is a generic error message in case no specific error is raised
                var message = {
                    title: "Sorry, I can\'t hear you :(",
                    body: ''
                }
                switch (event.error)
                {
                    case "not-allowed":
                        message.title = "Speech recognition is currently disabled";
                        message.body = "Click the camera icon in the browser\'s address bar to enable it.";
                        break;
                    case "network":
                        message.title = "No internet connection";
                        message.body = "You need a working internet connection to use speech recognition.";
                        break;
                    case "no-speech":
                        message.title = "Sorry, I couldn\'t hear anything :(";
                        message.body = "Is your microphone working and unmuted?";
                        break;
                    // this only happens by user interaction, so there is no need to display a message
                    case "aborted":
                        return;
                }
                self.showTimedMessage(message, "warning", 5);
            }
            recognition.onend = function()
            {
                recognition.stop();
            }
        },

        /**
         * Shows a specific auiFlag and automatically hides it after the specified timeout
         *
         * @param message
         * @param flagType
         * @param duration in seconds
         */
        showTimedMessage: function(message, flagType, duration)
        {
            this.dismissCurrentMessage();
            this.speakFlag = auiFlag({
                type: flagType,
                title: message.title,
                body: message.body,
                persistent: true
            });

            clearTimeout(this.flagTimer);
            this.flagTimer = setTimeout(this.dismissCurrentMessage.bind(this), duration * 1000);
        },
        dismissCurrentMessage: function()
        {
            if (this.speakFlag && this.speakFlag.close)
            {
                this.speakFlag.close();
                this.speakFlag = null;
            }
        }
    }
})
;;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:skate', location = '/js/lib/skate.js' */
define('wiki-edit/skate', ['jira/skate'], function(skate) {
    return skate;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources-init', location = '/js/wiki-editor-init.js' */
require([
    'wiki-edit/WikiEditor',
    'wiki-edit/JIRA',
    'wiki-edit/skate',
    'jquery',
    'underscore'
], function(WikiEditor, JIRA, skate, $, _) {

    function createWikiTextfield(element) {
        var el = (this instanceof Element) ? this : element;
        var create = function(elem) {
            WikiEditor.create(elem);
            WikiEditor.initBrowseLink(elem);
            elem.wikiEnabled = true;
        };

        if (el.wikiEnabled === false) {
            if ($(el).is(':hidden')) {
                _.defer(create, el);
            } else {
                create(el);
            }
        }
    }

    function wikiEditorDefinition() {
        return {
            type: skate.type.CLASSNAME,
            attached: createWikiTextfield,
            prototype: {
                wikiEnabled: false
            }
        };
    }

    skate('wiki-textfield', wikiEditorDefinition());

    skate('wiki-enabled-textfield', wikiEditorDefinition());

    $(function() {
        if ($("#gh").length > 0) {
            JIRA.Dialogs.comment.options.width = 810;
            JIRA.Dialogs.assignIssue.options.width = 810;
            JIRA.Dialogs.attachFile.options.width = 810;
            JIRA.Dialogs.logWork.options.width = 810;
            JIRA.Dialogs.logWork.options.width = 810;
        }
    });

});
;
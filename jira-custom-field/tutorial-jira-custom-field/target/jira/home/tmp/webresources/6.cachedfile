;
/* module-key = 'com.atlassian.auiplugin:ajs-raf', location = 'js-vendor/raf/raf.js' */
/*
 * raf.js
 * https://github.com/ngryman/raf.js
 *
 * original requestAnimationFrame polyfill by Erik MÃ¶ller
 * inspired from paul_irish gist and post
 *
 * Copyright (c) 2013 ngryman
 * Licensed under the MIT license.
 */

(function(window) {
	var lastTime = 0,
		vendors = ['webkit', 'moz'],
		requestAnimationFrame = window.requestAnimationFrame,
		cancelAnimationFrame = window.cancelAnimationFrame,
		i = vendors.length;

	// try to un-prefix existing raf
	while (--i >= 0 && !requestAnimationFrame) {
		requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
		cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'];
	}

	// polyfill with setTimeout fallback
	// heavily inspired from @darius gist mod: https://gist.github.com/paulirish/1579671#comment-837945
	if (!requestAnimationFrame || !cancelAnimationFrame) {
		requestAnimationFrame = function(callback) {
			var now = Date.now(), nextTime = Math.max(lastTime + 16, now);
			return setTimeout(function() {
				callback(lastTime = nextTime);
			}, nextTime - now);
		};

		cancelAnimationFrame = clearTimeout;
	}

	// export to window
	window.requestAnimationFrame = requestAnimationFrame;
	window.cancelAnimationFrame = cancelAnimationFrame;
}(window));;
;
/* module-key = 'com.atlassian.auiplugin:modernizr-touch', location = 'js-vendor/modernizr/modernizr-touch.js' */
/* Modernizr 2.8.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-touch-mq-teststyles-prefixes
 */
;



window.Modernizr = (function( window, document, undefined ) {

    var version = '2.8.3',

    Modernizr = {},


    docElement = document.documentElement,

    mod = 'modernizr',
    modElem = document.createElement(mod),
    mStyle = modElem.style,

    inputElem  ,


    toString = {}.toString,

    prefixes = ' -webkit- -moz- -o- -ms- '.split(' '),



    tests = {},
    inputs = {},
    attrs = {},

    classes = [],

    slice = classes.slice,

    featureName, 


    injectElementWithStyles = function( rule, callback, nodes, testnames ) {

      var style, ret, node, docOverflow,
          div = document.createElement('div'),
                body = document.body,
                fakeBody = body || document.createElement('body');

      if ( parseInt(nodes, 10) ) {
                      while ( nodes-- ) {
              node = document.createElement('div');
              node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
              div.appendChild(node);
          }
      }

                style = ['&#173;','<style id="s', mod, '">', rule, '</style>'].join('');
      div.id = mod;
          (body ? div : fakeBody).innerHTML += style;
      fakeBody.appendChild(div);
      if ( !body ) {
                fakeBody.style.background = '';
                fakeBody.style.overflow = 'hidden';
          docOverflow = docElement.style.overflow;
          docElement.style.overflow = 'hidden';
          docElement.appendChild(fakeBody);
      }

      ret = callback(div, rule);
        if ( !body ) {
          fakeBody.parentNode.removeChild(fakeBody);
          docElement.style.overflow = docOverflow;
      } else {
          div.parentNode.removeChild(div);
      }

      return !!ret;

    },

    testMediaQuery = function( mq ) {

      var matchMedia = window.matchMedia || window.msMatchMedia;
      if ( matchMedia ) {
        return matchMedia(mq) && matchMedia(mq).matches || false;
      }

      var bool;

      injectElementWithStyles('@media ' + mq + ' { #' + mod + ' { position: absolute; } }', function( node ) {
        bool = (window.getComputedStyle ?
                  getComputedStyle(node, null) :
                  node.currentStyle)['position'] == 'absolute';
      });

      return bool;

     },
    _hasOwnProperty = ({}).hasOwnProperty, hasOwnProp;

    if ( !is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined') ) {
      hasOwnProp = function (object, property) {
        return _hasOwnProperty.call(object, property);
      };
    }
    else {
      hasOwnProp = function (object, property) { 
        return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
      };
    }


    if (!Function.prototype.bind) {
      Function.prototype.bind = function bind(that) {

        var target = this;

        if (typeof target != "function") {
            throw new TypeError();
        }

        var args = slice.call(arguments, 1),
            bound = function () {

            if (this instanceof bound) {

              var F = function(){};
              F.prototype = target.prototype;
              var self = new F();

              var result = target.apply(
                  self,
                  args.concat(slice.call(arguments))
              );
              if (Object(result) === result) {
                  return result;
              }
              return self;

            } else {

              return target.apply(
                  that,
                  args.concat(slice.call(arguments))
              );

            }

        };

        return bound;
      };
    }

    function setCss( str ) {
        mStyle.cssText = str;
    }

    function setCssAll( str1, str2 ) {
        return setCss(prefixes.join(str1 + ';') + ( str2 || '' ));
    }

    function is( obj, type ) {
        return typeof obj === type;
    }

    function contains( str, substr ) {
        return !!~('' + str).indexOf(substr);
    }


    function testDOMProps( props, obj, elem ) {
        for ( var i in props ) {
            var item = obj[props[i]];
            if ( item !== undefined) {

                            if (elem === false) return props[i];

                            if (is(item, 'function')){
                                return item.bind(elem || obj);
                }

                            return item;
            }
        }
        return false;
    }
    tests['touch'] = function() {
        var bool;

        if(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
          bool = true;
        } else {
          injectElementWithStyles(['@media (',prefixes.join('touch-enabled),('),mod,')','{#modernizr{top:9px;position:absolute}}'].join(''), function( node ) {
            bool = node.offsetTop === 9;
          });
        }

        return bool;
    };
    for ( var feature in tests ) {
        if ( hasOwnProp(tests, feature) ) {
                                    featureName  = feature.toLowerCase();
            Modernizr[featureName] = tests[feature]();

            classes.push((Modernizr[featureName] ? '' : 'no-') + featureName);
        }
    }



     Modernizr.addTest = function ( feature, test ) {
       if ( typeof feature == 'object' ) {
         for ( var key in feature ) {
           if ( hasOwnProp( feature, key ) ) {
             Modernizr.addTest( key, feature[ key ] );
           }
         }
       } else {

         feature = feature.toLowerCase();

         if ( Modernizr[feature] !== undefined ) {
                                              return Modernizr;
         }

         test = typeof test == 'function' ? test() : test;

         if (typeof enableClasses !== "undefined" && enableClasses) {
           docElement.className += ' ' + (test ? '' : 'no-') + feature;
         }
         Modernizr[feature] = test;

       }

       return Modernizr; 
     };


    setCss('');
    modElem = inputElem = null;


    Modernizr._version      = version;

    Modernizr._prefixes     = prefixes;

    Modernizr.mq            = testMediaQuery;
    Modernizr.testStyles    = injectElementWithStyles;
    return Modernizr;

})(this, this.document);
;;
;
/* module-key = 'com.atlassian.auiplugin:internal-aui-is-input', location = 'js/aui/internal/is-input.js' */
;(function (init) {
    'use strict';

    AJS._internal = AJS._internal || {};
    AJS._internal.isInput = init();
})(function () {
    'use strict';

    return function (el) {
        return 'value' in el || el.isContentEditable;
    };
});
;
;
/* module-key = 'com.atlassian.auiplugin:aui-sidebar', location = 'js/aui-sidebar.js' */
(function ($) {

    'use strict';

    var SUPPORTS_TRANSITIONS = (typeof document.documentElement.style['transition'] !== 'undefined') ||
            (typeof document.documentElement.style['webkitTransition'] !== 'undefined');

    function sidebarOffset (sidebar) {
        return sidebar.offset().top;
    }

    function Sidebar (selector) {
        this.$el = $(selector);
        if (!this.$el.length) {
            return;
        }
        this.$body = $('body');
        this.$wrapper = this.$el.children('.aui-sidebar-wrapper');
        this.submenus = new SubmenuManager();

        // Sidebar users should add class="aui-page-sidebar" to the
        // <body> in the rendered markup (to prevent any potential flicker),
        // so we add it just in case they forgot.
        this.$body.addClass('aui-page-sidebar');

        this._previousScrollTop = null;
        this._previousViewportHeight = null;
        this._previousViewportWidth = null;
        this._previousOffsetTop = null;

        initializeHandlers(this);
    }

    var FORCE_COLLAPSE_WIDTH = 1240;
    var EVENT_PREFIX = '_aui-internal-sidebar-';

    function namespaceEvents (events) {
        return $.map(events.split(' '), function (event) {
            return EVENT_PREFIX + event;
        }).join(' ');
    }

    Sidebar.prototype.on = function () {
        var events = arguments[0];
        var args = Array.prototype.slice.call(arguments, 1);
        var namespacedEvents = namespaceEvents(events);
        this.$el.on.apply(this.$el, [namespacedEvents].concat(args));
        return this;
    };

    Sidebar.prototype.off = function () {
        var events = arguments[0];
        var args = Array.prototype.slice.call(arguments, 1);
        var namespacedEvents = namespaceEvents(events);
        this.$el.off.apply(this.$el, [namespacedEvents].concat(args));
        return this;
    };

    Sidebar.prototype.setHeight = function (scrollTop, viewportHeight, headerHeight) {
        var visibleHeaderHeight = Math.max(0, headerHeight - scrollTop);
        this.$wrapper.height(viewportHeight - visibleHeaderHeight);
        return this;
    };

    Sidebar.prototype.setPosition = function (scrollTop) {
        scrollTop = scrollTop || window.pageYOffset;
        this.$wrapper.toggleClass('aui-is-docked', scrollTop > sidebarOffset(this.$el));
        return this;
    };

    Sidebar.prototype.setCollapsedState = function (viewportWidth) {
        // Reflow behaviour is implemented as a state machine (hence all
        // state transitions are enumerated). The rest of the state machine,
        // e.g., entering the expanded narrow (fly-out) state, is implemented
        // by the toggle() method.
        var transition = {collapsed: {}, expanded: {}};
        transition.collapsed.narrow = {
            narrow: $.noop,
            wide: function (s) {
                s._expand(viewportWidth, true);
            }
        };
        transition.collapsed.wide = {
            narrow: $.noop,  // Becomes collapsed narrow (no visual change).
            wide: $.noop
        };
        transition.expanded.narrow = {
            narrow: $.noop,
            wide: function (s) {
                s.$body.removeClass('aui-sidebar-collapsed');
                s.$el.removeClass('aui-sidebar-fly-out');
            }
        };
        transition.expanded.wide = {
            narrow: function (s) {
                s._collapse(true);
            },
            wide: $.noop
        };

        var collapseState = this.isCollapsed() ? 'collapsed' : 'expanded';
        var oldSize = this.isViewportNarrow(this._previousViewportWidth) ? 'narrow' : 'wide';
        var newSize = this.isViewportNarrow(viewportWidth) ? 'narrow' : 'wide';
        transition[collapseState][oldSize][newSize](this);
        return this;
    };

    Sidebar.prototype._collapse = function (isResponsive) {
        if (this.isCollapsed()) {
            return this;
        }

        var startEvent = $.Event(EVENT_PREFIX + 'collapse-start', {isResponsive: isResponsive});
        this.$el.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) {
            return this;
        }

        this.$body.addClass('aui-sidebar-collapsed');
        this.$el.attr('aria-expanded', 'false');
        this.$el.removeClass('aui-sidebar-fly-out');
        this.$el.find(this.submenuTriggersSelector).attr('tabindex', 0);

        if (!this.isAnimated()) {
            this.$el.trigger($.Event(EVENT_PREFIX + 'collapse-end', {isResponsive: isResponsive}));
        }
        return this;
    };

    Sidebar.prototype.collapse = function () {
        return this._collapse(false);
    };

    Sidebar.prototype._expand = function (viewportWidth, isResponsive) {
        var startEvent = $.Event(EVENT_PREFIX + 'expand-start', {isResponsive: isResponsive});
        this.$el.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) {
            return this;
        }

        var isViewportNarrow = this.isViewportNarrow(viewportWidth);
        this.$el.attr('aria-expanded', 'true');
        this.$body.toggleClass('aui-sidebar-collapsed', isViewportNarrow);
        this.$el.toggleClass('aui-sidebar-fly-out', isViewportNarrow);
        this.$el.find(this.submenuTriggersSelector).removeAttr('tabindex');

        if (!this.isAnimated()) {
            this.$el.trigger($.Event(EVENT_PREFIX + 'expand-end', {isResponsive: isResponsive}));
        }
        return this;
    };

    Sidebar.prototype.expand = function () {
        if (this.isCollapsed()) {
            this._expand(this._previousViewportWidth, false);
        }
        return this;
    };

    Sidebar.prototype.isAnimated = function () {
        return SUPPORTS_TRANSITIONS && this.$el.hasClass('aui-is-animated');
    };

    Sidebar.prototype.isCollapsed = function () {
        return this.$el.attr('aria-expanded') === 'false';
    };

    Sidebar.prototype.isViewportNarrow = function (viewportWidth) {
        viewportWidth = viewportWidth === undefined ? this._previousViewportWidth : viewportWidth;
        return viewportWidth < FORCE_COLLAPSE_WIDTH;
    };

    Sidebar.prototype._removeAllTooltips = function () {
        // tooltips are orphaned when sidebar is expanded, so if there are any visible on the page we remove them all.
        // Can't scope it to the Sidebar (this) because the tooltip div is a direct child of <body>
        $(this.tooltipSelector).remove();
    };

    Sidebar.prototype.reflow = function (scrollTop, viewportHeight, viewportWidth, scrollHeight) {
        scrollTop = scrollTop === undefined ? window.pageYOffset : scrollTop;
        viewportHeight = viewportHeight === undefined ? document.documentElement.clientHeight : viewportHeight;
        scrollHeight = scrollHeight === undefined ? document.documentElement.scrollHeight: scrollHeight;
        viewportWidth = viewportWidth === undefined ? window.innerWidth :viewportWidth;

        // Header height needs to be checked because in Stash it changes when the CSS "transform: translate3d" is changed.
        // If you called reflow() after this change then nothing happened because the scrollTop and viewportHeight hadn't changed.
        var offsetTop = sidebarOffset(this.$el);
        var isInitialPageLoad = this._previousViewportWidth === null;

        if (!(scrollTop === this._previousScrollTop && viewportHeight === this._previousViewportHeight && offsetTop === this._previousOffsetTop)) {
            if (this.isCollapsed() && !isInitialPageLoad && scrollTop !== this._previousScrollTop) {
                // hide submenu and tooltips on scroll
                this.submenus.hide();
                this._removeAllTooltips();
            }

            var isTouch = this.$body.hasClass('aui-page-sidebar-touch');
            var isTrackpadBounce = scrollTop !== this._previousScrollTop && (scrollTop < 0 || scrollTop + viewportHeight > scrollHeight);
            if (!isTouch && (isInitialPageLoad || !isTrackpadBounce)) {
                this.setHeight(scrollTop, viewportHeight, offsetTop);
                this.setPosition(scrollTop);
            }
        }

        var isResponsive = this.$el.attr('data-aui-responsive') !== 'false';
        if (isResponsive) {
            if (isInitialPageLoad) {
                if (!this.isCollapsed() && this.isViewportNarrow(viewportWidth)) {
                    var isAnimated = this.isAnimated();
                    if (isAnimated) {
                        this.$el.removeClass('aui-is-animated');
                    }
                    // This will trigger the "collapse" event before non-sidebar
                    // JS code has a chance to bind listeners; they'll need to
                    // check isCollapsed() if they care about the value at that
                    // time.
                    this.collapse();
                    if (isAnimated) {
                        // We must trigger a CSS reflow (by accessing
                        // offsetHeight) otherwise the transition still runs.
                        // jshint expr:true
                        this.$el[0].offsetHeight;
                        this.$el.addClass('aui-is-animated');
                    }
                }
            }
            else if (viewportWidth !== this._previousViewportWidth) {
                this.setCollapsedState(viewportWidth);
            }
        }
        else {
            var isFlyOut = !this.isCollapsed() && this.isViewportNarrow(viewportWidth);
            this.$el.toggleClass('aui-sidebar-fly-out', isFlyOut);
        }

        this._previousScrollTop = scrollTop;
        this._previousViewportHeight = viewportHeight;
        this._previousViewportWidth = viewportWidth;
        this._previousOffsetTop = offsetTop;
        return this;
    };

    Sidebar.prototype.toggle = function () {
        if (this.isCollapsed()) {
            if (this.submenus.isShowing()) {
                this.submenus.hide(this.expand.bind(this));
            }
            else {
                this.expand();
                this._removeAllTooltips();
            }
        }
        else {
            this.collapse();
        }
        return this;
    };

    /**
     * Returns a jQuery selector string for the trigger elements when the
     * sidebar is in a collapsed state, useful for delegated event binding.
     *
     * When using this selector in event handlers, the element ("this") will
     * either be an <a> (when the trigger was a tier-one menu item) or an
     * element with class "aui-sidebar-group" (for non-tier-one items).
     *
     * For delegated event binding you should bind to $el and check the value
     * of isCollapsed(), e.g.,
     *
     *     sidebar.$el.on('click', sidebar.collapsedTriggersSelector, function (e) {
     *         if (!sidebar.isCollapsed()) {
     *             return;
     *         }
     *     });
     *
     * @returns string
     */
    Sidebar.prototype.submenuTriggersSelector = '.aui-sidebar-group:not(.aui-sidebar-group-tier-one)';

    Sidebar.prototype.collapsedTriggersSelector = [
        Sidebar.prototype.submenuTriggersSelector,
        '.aui-sidebar-group.aui-sidebar-group-tier-one > .aui-nav > li > a',
        '.aui-sidebar-footer > .aui-sidebar-settings-button'
    ].join(', ');

    Sidebar.prototype.toggleSelector = '.aui-sidebar-footer > .aui-sidebar-toggle';

    Sidebar.prototype.tooltipSelector = '.aui-sidebar-section-tooltip';

    function SubmenuManager() {
        this.inlineDialog = AJS.InlineDialog($(), 'sidebar-submenu', this.inlineDialogShowHandler.bind(this), {
            noBind: true,
            addActiveClass: false,
            hideCallback: this.inlineDialogHideHandler.bind(this),
            gravity: 'w',
            hideDelay: 300,
            offsetY: function (popup, targetPosition) {
                var halfTriggerHeight = targetPosition.target.height() / 2;
                var halfPopupHeight = popup.height() / 2;
                return halfPopupHeight - halfTriggerHeight - this.submenuHeadingHeight();
            }.bind(this),
            arrowOffsetY: function (popup, targetPosition) {
                var halfTriggerHeight = targetPosition.target.height() / 2;
                var halfPopupHeight = popup.height() / 2;
                return -halfPopupHeight + this.submenuHeadingHeight() + halfTriggerHeight;
            }.bind(this)
        });

        this.$trigger = null;
        this.$placeholder = null;
        this.$placeholderSubmenu = null;
        this.postHideCallback = null;
    }

    SubmenuManager.prototype.inlineDialogSelector = '#inline-dialog-sidebar-submenu';

    SubmenuManager.prototype.submenu = function ($trigger) {
        return $trigger.is('a') ? $trigger.next('.aui-nav') : $trigger.children('.aui-nav, hr');
    };

    SubmenuManager.prototype.hasSubmenu = function ($trigger) {
        return this.submenu($trigger).length !== 0;
    };

    SubmenuManager.prototype.submenuHeadingHeight = function () {
        // At the time we want to measure the submenu heading (inside the
        // offsetY and arrowOffsetY functions), the submenu heading is not
        // visible in the page (since the sidebar is collapsed), so we don't
        // have a reliable way of measuring its height.
        return 34;
    };

    SubmenuManager.prototype.isShowing = function () {
        return this.$trigger !== null;
    };

    SubmenuManager.prototype.show = function (e, triggerEl) {
        var wasShowing = this.isShowing();
        this.inlineDialog.show(e, triggerEl);
        if (wasShowing) {
            // Redraw the inline dialog in its new position.
            this.inlineDialog.refresh();
        }
        return this;
    };

    SubmenuManager.prototype.hide = function (callback) {
        if (callback !== undefined) {
            this.postHideCallback = callback;
        }
        this.inlineDialog.hide();
        return this;
    };

    // We use a string (INLINE_DIALOG_HTML) rather than soy since AUI
    // components don't depend on AUI templates (for now).
    var INLINE_DIALOG_HTML =
        '<div class="aui-sidebar-submenu">' +
            '<div class="aui-navgroup aui-navgroup-vertical">' +
                '<div class="aui-navgroup-inner">' +
                    '<div class="aui-nav-heading"><strong></strong></div>' +
                '</div>' +
            '</div>' +
        '</div>';

    SubmenuManager.prototype.inlineDialogShowHandler = function ($content, triggerEl, showPopup) {
        if (this.isShowing()) {
            // If the inline dialog is showing we can't simply call
            // this.inlineDialog.hide() since its implementation queues the
            // hiding, i.e., uses setTimeout(0); we update the contents
            // instead.
            this.restoreSubmenu();
            this.$trigger.removeClass('active');
        }

        this.$trigger = $(triggerEl).is('.aui-sidebar-group') ? $(triggerEl) : $(triggerEl).closest('a');
        this.$trigger.addClass('active');

        // TODO The title here should use the same code as what we display
        //      in the tipsy tooltips for the triggers.
        var title = this.$trigger.is('a') ? this.$trigger.text() : this.$trigger.children('.aui-nav-heading').text();
        $content.html(INLINE_DIALOG_HTML);

        var $container = $content.find('.aui-navgroup-inner');
        $container.children('.aui-nav-heading')
            .attr('title', title)
            .children('strong')
                .text(title);

        this.moveSubmenuToInlineDialog(this.submenu(this.$trigger));
        showPopup();
    };

    SubmenuManager.prototype.inlineDialogHideHandler = function () {
        this.restoreSubmenu();
        this.$trigger.removeClass('active');
        this.$trigger = null;

        if (this.postHideCallback !== null) {
            this.postHideCallback();
            this.postHideCallback = null;
        }
    };

    SubmenuManager.prototype.moveSubmenuToInlineDialog = function ($submenu) {
        this.$placeholder = $('<!-- placholder -->');
        // copy submenu along with its events
        this.$placeholderSubmenu = $submenu.clone(true);
        $submenu.replaceWith(this.$placeholder);
        this.inlineDialog.find('.aui-navgroup-inner').append(this.$placeholderSubmenu);
        return this;
    };

    SubmenuManager.prototype.restoreSubmenu = function () {
        this.$placeholder.replaceWith(this.$placeholderSubmenu);
        this.$placeholder = null;
        this.$placeholderSubmenu = null;
        return this;
    };

    var tipsyOpts = {
        trigger: 'manual',
        gravity: 'w',
        className: 'aui-sidebar-section-tooltip',
        title: function () {
            var $item = $(this);
            if ($item.is('a')) {
                return $item.attr('title') || $item.find('.aui-nav-item-label').text() || $item.data('tooltip');
            }
            else {
                return $item.children('.aui-nav').attr('title') || $item.children('.aui-nav-heading').text();
            }
        }
    };

    function showTipsy($trigger) {
        $trigger.tipsy(tipsyOpts).tipsy('show');
        var $tip = $trigger.data('tipsy') && $trigger.data('tipsy').$tip;
        if ($tip) { // if .aui-sidebar-group does not have a title to display
            // Remove "opacity" inline style from Tipsy to allow the our own styles and transitions to be applied
            $tip.css({'opacity': ''}).addClass('tooltip-shown');
        }
    }

    function hideTipsy($trigger) {
        var $tip = $trigger.data('tipsy') && $trigger.data('tipsy').$tip;
        if ($tip) {
            var durationStr = $tip.css('transition-duration');

            if (durationStr) {
                // can be denominated in either s or ms
                var timeoutMs = (durationStr.indexOf('ms') >= 0) ?
                    parseInt(durationStr.substring(0, durationStr.length - 2), 10) :
                    1000 * parseInt(durationStr.substring(0, durationStr.length - 1), 10);

                // use a timeout because the transitionend event is not reliable (yet),
                // more details here: https://bitbucket.atlassian.net/browse/BB-11599
                // an example of this at http://labs.silverorange.com/files/webkit-bug/
                // further caveats here: https://developer.mozilla.org/en-US/docs/Web/Events/transitionend
                // "In the case where a transition is removed before completion,
                // such as if the transition-property is removed, then the event will not fire."
                setTimeout(function () {
                    $trigger.tipsy('hide');
                }, timeoutMs);
            }

            $tip.removeClass('tooltip-shown');
        }
    }

    function initializeHandlers(sidebar) {
        var $sidebar = $('.aui-sidebar');
        if (!$sidebar.length) {
            return;
        }

        // AUI-2542: only enter touch mode on small screen touchable devices
        if (Modernizr.touch && Modernizr.mq('only screen and (max-device-width:1024px)')) {
            $('body').addClass('aui-page-sidebar-touch');
        }

        var pendingReflow = null;
        $(window).on('scroll resize', function () {
            if (pendingReflow === null) {
                pendingReflow = requestAnimationFrame(function () {
                    sidebar.reflow();
                    pendingReflow = null;
                });
            }
        });
        sidebar.reflow();

        if (sidebar.isAnimated()) {
            sidebar.$el.on('transitionend webkitTransitionEnd', function () {
                sidebar.$el.trigger($.Event(EVENT_PREFIX + (sidebar.isCollapsed() ? 'collapse-end' : 'expand-end')));
            });
        }

        sidebar.$el.on('click', '.aui-sidebar-toggle', function (e) {
            e.preventDefault();
            sidebar.toggle();
        });

        $('.aui-page-panel').click(function (e) {
            if (!sidebar.isCollapsed() && sidebar.isViewportNarrow()) {
                sidebar.collapse();
            }
        });

        var toggleShortcutHandler = function (e) {
            if (isNormalSquareBracket(e)) {
                sidebar.toggle();
            }
        };

        //We use keypress because it captures the actual character that was typed and not the physical key that was pressed.
        //This accounts for other keyboard layouts

        $(document).on('keypress', toggleShortcutHandler);

        sidebar._remove = function () {
            this._removeAllTooltips();
            $(this.submenus.inlineDialogSelector).remove();
            this.$el.remove();
            $(document).off('keypress', toggleShortcutHandler);
        };

        sidebar.$el.on('touchend', function (e) {
            if (sidebar.isCollapsed()) {
                sidebar.expand();
                e.preventDefault();
            }
        });

        sidebar.$el.on('mouseenter focus', sidebar.collapsedTriggersSelector, function (e) {
            if (!sidebar.isCollapsed()) {
                return;
            }

            var $trigger = $(this);

            if (sidebar.submenus.hasSubmenu($trigger)) {
                e.preventDefault();
                sidebar.submenus.show(e, this);
            }
            else if ($trigger.hasClass('active') && sidebar.submenus.isShowing()) {
                // prevent triggering the same submenu again and hiding it
                e.stopImmediatePropagation();
            }
            else {
                sidebar.submenus.hide();
                showTipsy($trigger);
            }
        });

        sidebar.$el.on('click blur mouseleave', sidebar.collapsedTriggersSelector, function (e) {
            if (!sidebar.isCollapsed()) {
                return;
            }
            hideTipsy($(this));
        });

        sidebar.$el.on('click', sidebar.collapsedTriggersSelector, function (e) {
            if (sidebar.submenus.isShowing()) {
                // prevent hiding of the submenu if someone clicks on it, since it's already shown on hover
                e.stopImmediatePropagation();
            }
        });

        sidebar.$el.on('mouseenter focus', sidebar.toggleSelector, function () {
            var $trigger = $(this);
            if (sidebar.isCollapsed()) {
                $trigger.data('tooltip', "Expand sidebar ( [ )");
            }
            else {
                $trigger.data('tooltip', "Collapse sidebar ( [ )");
            }
            showTipsy($trigger);
        });

        sidebar.$el.on('click blur mouseleave', sidebar.toggleSelector, function () {
            hideTipsy($(this));
        });

        // workaround for https://ecosystem.atlassian.net/browse/AUI-2555
        // we manually hide the submenus when the mouse leaves the trigger and into the sidebar body
        sidebar.$el.on('mouseover', function (e) {
            var $target = $(e.target);
            if ($target.hasClass('aui-sidebar-wrapper') || $target.hasClass('aui-sidebar-body')) {
                sidebar.submenus.hide();
            }
        });

        function isNormalTab(e) {
            return e.keyCode === AJS.keyCode.TAB && !e.shiftKey && !e.altKey;
        }

        function isNormalSquareBracket(e) {
            return e.which === AJS.keyCode.LEFT_SQUARE_BRACKET && !e.shiftKey && !e.ctrlKey && !e.metaKey && !AJS._internal.isInput(e.target);
        }

        function isShiftTab(e) {
            return e.keyCode === AJS.keyCode.TAB && e.shiftKey;
        }

        function isFirstSubmenuItem(item) {
            return item === sidebar.submenus.$placeholderSubmenu.find(':aui-tabbable')[0];
        }

        function isLastSubmenuItem(item) {
            return item === sidebar.submenus.$placeholderSubmenu.find(':aui-tabbable').last()[0];
        }

        function isFirstTabbableSidebarItem(item) {
            return item === sidebar.$el.find(':aui-tabbable:visible')[0];
        }

        sidebar.$el.on('keydown', sidebar.collapsedTriggersSelector, function (e) {
            if (isNormalTab(e) && sidebar.submenus.isShowing()) {
                e.preventDefault();
                // don't use :aui-tabbable:first as it will select the first tabbable item in EACH nav group
                sidebar.submenus.$placeholderSubmenu.find(':aui-tabbable').first().focus();

                sidebar.submenus.$placeholderSubmenu.on('keydown', function (e) {
                    if (isShiftTab(e) && isFirstSubmenuItem(e.target) || isNormalTab(e) && isLastSubmenuItem(e.target)) {
                        sidebar.submenus.$trigger.focus();
                        // unbind event and close submenu as the focus is out of the submenu
                        $(this).off('keydown');
                        sidebar.submenus.hide();
                    }
                });
            }
            else if (isShiftTab(e) && isFirstTabbableSidebarItem(e.target)) {
                // workaround to hide inline dialog of the first collapsed trigger
                sidebar.submenus.hide();
            }
        });

    }
    AJS.sidebar = AJS._internal.widget('sidebar', Sidebar);

    $(function () {
        AJS.sidebar('.aui-sidebar');
    });

}(AJS.$));
;
;
/* module-key = 'com.atlassian.auiplugin:dialog2', location = 'js/dialog2.js' */
;(function (init) {
    'use strict';

    AJS.dialog2 = init(AJS.$, AJS.layer, AJS._internal.widget);
})(function ($, layerWidget, widget) {
    'use strict';


    var defaults = {
        'aui-focus': 'false', // do not focus by default as it's overridden below
        'aui-blanketed': 'true'
    };

    function applyDefaults($el) {
        $.each(defaults, function (key, value) {
            var dataKey = 'data-' + key;
            if (!$el[0].hasAttribute(dataKey)) {
                $el.attr(dataKey, value);
            }
        });
    }

    function Dialog2(selector) {
        if (selector) {
            this.$el = $(selector);
        }
        else {
            this.$el = $(aui.dialog.dialog2({}));
        }
        applyDefaults(this.$el);
    }

    Dialog2.prototype.on = function (event, fn) {
        layerWidget(this.$el).on(event, fn);
        return this;
    };

    Dialog2.prototype.off = function (event, fn) {
        layerWidget(this.$el).off(event, fn);
        return this;
    };

    Dialog2.prototype.show = function () {
        layerWidget(this.$el).show();
        return this;
    };

    Dialog2.prototype.hide = function () {
        layerWidget(this.$el).hide();
        return this;
    };

    Dialog2.prototype.remove = function () {
        layerWidget(this.$el).remove();
        return this;
    };

    Dialog2.prototype.isVisible = function () {
        return layerWidget(this.$el).isVisible();
    };

    var dialog2Widget = widget('dialog2', Dialog2);

    dialog2Widget.on = function (eventName, fn) {
        layerWidget.on(eventName, '.aui-dialog2', fn);
        return this;
    };

    dialog2Widget.off = function (eventName, fn) {
        layerWidget.off(eventName, '.aui-dialog2', fn);
        return this;
    };

    /* Live events */

    $(document).on('click', '.aui-dialog2-header-close', function (e) {
        e.preventDefault();
        dialog2Widget($(this).closest('.aui-dialog2')).hide();
    });

    dialog2Widget.on('show', function (e, $el) {
        var selectors = ['.aui-dialog2-content', '.aui-dialog2-footer', '.aui-dialog2-header'];
        var $selected;
        selectors.some(function (selector) {
            $selected = $el.find(selector + ' :aui-tabbable');
            return $selected.length;
        });
        $selected && $selected.first().focus();
    });

    dialog2Widget.on('hide', function (e,$el) {
        var layer = layerWidget($el);

        if ($el.data('aui-remove-on-hide')) {
            layer.remove();
        }
    });

    return dialog2Widget;
});
;
;
/* module-key = 'com.atlassian.auiplugin:dialog2', location = 'soy/dialog2.soy' */
// This file was automatically generated from dialog2.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace aui.dialog.
 */

if (typeof aui == 'undefined') { var aui = {}; }
if (typeof aui.dialog == 'undefined') { aui.dialog = {}; }


aui.dialog.dialog2 = function(opt_data, opt_ignored) {
  return '' + aui.dialog.dialog2Chrome({id: opt_data.id, titleId: opt_data.id ? opt_data.id + '-dialog-title' : null, modal: opt_data.modal, tagName: opt_data.tagName, removeOnHide: opt_data.removeOnHide, visible: opt_data.visible, size: opt_data.size, extraClasses: opt_data.extraClasses, extraAttributes: opt_data.extraAttributes, content: '' + aui.dialog.dialog2Content({id: null, titleText: opt_data.titleText, titleContent: opt_data.titleContent, headerActionContent: opt_data.headerActionContent, headerSecondaryContent: opt_data.headerSecondaryContent, modal: opt_data.modal, content: opt_data.content, footerHintText: opt_data.footerHintText, footerHintContent: opt_data.footerHintContent, footerActionContent: opt_data.footerActionContent})});
};
if (goog.DEBUG) {
  aui.dialog.dialog2.soyTemplateName = 'aui.dialog.dialog2';
}


aui.dialog.dialog2Chrome = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<' + soy.$$escapeHtml(opt_data.tagName ? opt_data.tagName : 'section') + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ((opt_data.titleId) ? ' aria-labelledby="' + soy.$$escapeHtml(opt_data.titleId) + '"' : '') + ' role="dialog" class=" aui-layer aui-dialog2 aui-dialog2-' + soy.$$escapeHtml(opt_data.size ? opt_data.size : 'medium') + aui.renderExtraClasses(opt_data) + '"' + ((opt_data.modal) ? 'data-aui-modal="true"' : '') + ((opt_data.removeOnHide) ? 'data-aui-remove-on-hide="true"' : '') + ((opt_data.visible != true) ? 'aria-hidden="true"' : '') + aui.renderExtraAttributes(opt_data) + '>' + ((opt_data.content) ? soy.$$filterNoAutoescape(opt_data.content) : '') + '</' + soy.$$escapeHtml(opt_data.tagName ? opt_data.tagName : 'section') + '>';
};
if (goog.DEBUG) {
  aui.dialog.dialog2Chrome.soyTemplateName = 'aui.dialog.dialog2Chrome';
}


aui.dialog.dialog2Content = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + aui.dialog.dialog2Header({titleId: opt_data.id ? opt_data.id + '-dialog-title' : null, titleText: opt_data.titleText, titleContent: opt_data.titleContent, actionContent: opt_data.headerActionContent, secondaryContent: opt_data.headerSecondaryContent, modal: opt_data.modal}) + aui.dialog.dialog2Panel(opt_data) + aui.dialog.dialog2Footer({hintText: opt_data.footerHintText, hintContent: opt_data.footerHintContent, actionContent: opt_data.footerActionContent});
};
if (goog.DEBUG) {
  aui.dialog.dialog2Content.soyTemplateName = 'aui.dialog.dialog2Content';
}


aui.dialog.dialog2Header = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<header' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ' class="aui-dialog2-header' + aui.renderExtraClasses(opt_data) + '"' + aui.renderExtraAttributes(opt_data) + '><h2 ' + ((opt_data.titleId) ? ' id="' + soy.$$escapeHtml(opt_data.titleId) + '"' : '') + ' class="aui-dialog2-header-main">' + ((opt_data.titleText) ? soy.$$escapeHtml(opt_data.titleText) : '') + ((opt_data.titleContent) ? soy.$$filterNoAutoescape(opt_data.titleContent) : '') + '</h2>' + ((opt_data.actionContent) ? '<div class="aui-dialog2-header-actions">' + soy.$$filterNoAutoescape(opt_data.actionContent) + '</div>' : '') + ((opt_data.secondaryContent) ? '<div class="aui-dialog2-header-secondary">' + soy.$$filterNoAutoescape(opt_data.secondaryContent) + '</div>' : '') + ((opt_data.modal != true) ? '<a class="aui-dialog2-header-close"><span class="aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Close") + '</span></a>' : '') + '</header>';
};
if (goog.DEBUG) {
  aui.dialog.dialog2Header.soyTemplateName = 'aui.dialog.dialog2Header';
}


aui.dialog.dialog2Footer = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<footer' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ' class="aui-dialog2-footer' + aui.renderExtraClasses(opt_data) + '"' + aui.renderExtraAttributes(opt_data) + '>' + ((opt_data.actionContent) ? '<div class="aui-dialog2-footer-actions">' + soy.$$filterNoAutoescape(opt_data.actionContent) + '</div>' : '') + ((opt_data.hintText || opt_data.hintContent) ? '<div class="aui-dialog2-footer-hint">' + ((opt_data.hintText) ? soy.$$escapeHtml(opt_data.hintText) : '') + ((opt_data.hintContent) ? soy.$$filterNoAutoescape(opt_data.hintContent) : '') + '</div>' : '') + '</footer>';
};
if (goog.DEBUG) {
  aui.dialog.dialog2Footer.soyTemplateName = 'aui.dialog.dialog2Footer';
}


aui.dialog.dialog2Panel = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ' class="aui-dialog2-content' + aui.renderExtraClasses(opt_data) + '"' + aui.renderExtraAttributes(opt_data) + '>' + ((opt_data.content) ? soy.$$filterNoAutoescape(opt_data.content) : '') + '</div>';
};
if (goog.DEBUG) {
  aui.dialog.dialog2Panel.soyTemplateName = 'aui.dialog.dialog2Panel';
}
;
;
/* module-key = 'jira.webresources:change-project-type-dialog', location = '/includes/jira/dialog/changeProjectTypeDialog.soy' */
// This file was automatically generated from changeProjectTypeDialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.project.ChangeType.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.project == 'undefined') { JIRA.Templates.project = {}; }
if (typeof JIRA.Templates.project.ChangeType == 'undefined') { JIRA.Templates.project.ChangeType = {}; }


JIRA.Templates.project.ChangeType.changeProjectTypeDialog = function(opt_data, opt_ignored) {
  return '<section role="dialog" id="change-project-type-dialog-' + soy.$$escapeHtml(opt_data.projectId) + '" class="aui-layer aui-dialog2 aui-dialog2-medium" aria-hidden="true"><header class="aui-dialog2-header"><h2 class="aui-dialog2-header-main">' + soy.$$escapeHtml("Change project type") + '</h2></header><div class="aui-dialog2-content"></div><footer class="aui-dialog2-footer"><div class="aui-dialog2-footer-actions form-footer"><div class="icon throbber"></div><button class="aui-button aui-button-primary dialog-change-button hidden">' + soy.$$escapeHtml("Change") + '</button><button class="aui-button aui-button-link dialog-close-button">' + soy.$$escapeHtml("Cancel") + '</button></div></footer></section>';
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.changeProjectTypeDialog.soyTemplateName = 'JIRA.Templates.project.ChangeType.changeProjectTypeDialog';
}


JIRA.Templates.project.ChangeType.changeProjectTypeForm = function(opt_data, opt_ignored) {
  var output = '<form class="aui change-project-type-form"><div class="form-body"><div class="aui-group project-type-change-group"><div class="aui-item">' + JIRA.Templates.project.ChangeType.projectAvatar(opt_data) + '</div><div class="aui-item project-type-select-group">' + JIRA.Templates.project.ChangeType.projectTypeDropdown({projectTypeKey: opt_data.project.projectTypeKey, projectTypes: opt_data.projectTypes}) + '</div></div></div></form><p>';
  var helpLinkAnchor__soy21 = '<a href=' + soy.$$escapeHtml(opt_data.helpLink) + ' target="_blank">';
  output += soy.$$filterNoAutoescape(AJS.format("If you change project type, you\x27\x27ll also change what your users can see and do with the project. {0}Check the differences here{1}.",helpLinkAnchor__soy21,'</a>')) + '</p>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.changeProjectTypeForm.soyTemplateName = 'JIRA.Templates.project.ChangeType.changeProjectTypeForm';
}


JIRA.Templates.project.ChangeType.projectTypeDropdown = function(opt_data, opt_ignored) {
  var output = '<select class="project-type-select select" name="project-type">';
  var projectTypeList30 = opt_data.projectTypes;
  var projectTypeListLen30 = projectTypeList30.length;
  for (var projectTypeIndex30 = 0; projectTypeIndex30 < projectTypeListLen30; projectTypeIndex30++) {
    var projectTypeData30 = projectTypeList30[projectTypeIndex30];
    output += '<option class="imagebacked" data-icon="data:image/svg+xml;base64, ' + soy.$$escapeHtml(projectTypeData30.icon) + '" value="' + soy.$$escapeHtml(projectTypeData30.key) + '" ' + ((projectTypeData30.key == opt_data.projectTypeKey) ? ' selected ' : '') + '>' + soy.$$escapeHtml(projectTypeData30.formattedKey) + '</option>';
  }
  output += '</select>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.projectTypeDropdown.soyTemplateName = 'JIRA.Templates.project.ChangeType.projectTypeDropdown';
}


JIRA.Templates.project.ChangeType.updateTargetElement = function(opt_data, opt_ignored) {
  return '<img src="data:image/svg+xml;base64,' + soy.$$escapeHtml(opt_data.icon) + '" class="project-type-icon" /><span>' + soy.$$escapeHtml(opt_data.formattedKey) + '</span>';
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.updateTargetElement.soyTemplateName = 'JIRA.Templates.project.ChangeType.updateTargetElement';
}


JIRA.Templates.project.ChangeType.projectAvatar = function(opt_data, opt_ignored) {
  return '<div class="project-avatar-header"><span class="aui-avatar aui-avatar-large aui-avatar-project"><span class="aui-avatar-inner"><img src="' + soy.$$escapeHtml(opt_data.project.avatarUrls['48x48']) + '" alt="' + soy.$$escapeHtml(opt_data.project.name) + '"></span></span><div class="project-header" title="' + soy.$$escapeHtml(opt_data.project.name) + '">' + soy.$$escapeHtml(opt_data.project.name) + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.projectAvatar.soyTemplateName = 'JIRA.Templates.project.ChangeType.projectAvatar';
}


JIRA.Templates.project.ChangeType.dialogSpinner = function(opt_data, opt_ignored) {
  return '<div class="dialog-spinner"></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.dialogSpinner.soyTemplateName = 'JIRA.Templates.project.ChangeType.dialogSpinner';
}


JIRA.Templates.project.ChangeType.successMsg = function(opt_data, opt_ignored) {
  return '' + soy.$$escapeHtml(AJS.format("You have just changed {0} to a {1} project type.",opt_data.projectName,opt_data.projectTypeName));
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.successMsg.soyTemplateName = 'JIRA.Templates.project.ChangeType.successMsg';
}
;
;
/* module-key = 'jira.webresources:change-project-type-dialog', location = '/includes/jira/dialog/changeProjectTypeDialog.js' */
define('jira/project/admin/change-project-type-dialog',[
    'jquery',
    'underscore',
    'jira/message',
    'jira/ajs/select/single-select',
    'wrm/context-path'
], function(
    $,
    _,
    message,
    SingleSelect,
    contextPath
) {
    function _getProjectInformation(projectId) {
        return $.ajax({
            url : contextPath() + "/rest/internal/2/projects/" + projectId + "/changetypedata",
            dataType: "json",
            contentType: "application/json",
            type:  "GET"
        });
    }

    function handleChangeProjectType(options){
        var $projectTypeSelect = $(".project-type-select", options.dialogBody);
        var selectedProjectTypeKey = $projectTypeSelect.val()[0];
        var selectedProjectType = _.findWhere(options.projectTypes, {key: selectedProjectTypeKey});
        $(".dialog-change-button", options.dialogBody).attr('disabled', 'disabled');

        $($.ajax({
            url : contextPath() + "/rest/api/2/project/" + options.projectId + "/type/" + selectedProjectTypeKey,
            dataType: "json",
            contentType: "application/json",
            type:  "PUT"
        }).done(function(){
            options.changeProjectTypeDialog.hide();

            if(options.onProjectTypeChanged) {
                options.onProjectTypeChanged(options.trigger, selectedProjectType);
            }

            message.showSuccessMsg(JIRA.Templates.project.ChangeType.successMsg({
                projectName:options.projectName,
                projectTypeName: selectedProjectType.formattedKey
            }));

            AJS.EventQueue.push({
                name: "administration.projecttype.change",
                properties: {
                    projectId: options.projectId,
                    sourceProjectType: _normalizeProjectTypeKey(options.sourceProjectType),
                    destinationProjectType: _normalizeProjectTypeKey(selectedProjectTypeKey)
                }
            });
        }).fail(function(){
            $(".aui-dialog2-content",options.dialogBody).prepend(aui.message.error({
                content: AJS.format("We haven\'\'t been able to complete the project conversion. You could refresh the page and try again. If this doesn\'\'t work, contact {0}Support{1}.", '<a href="https://support.atlassian.com/">', "</a>")
            }));
        })).throbber({target:$(".throbber", options.dialogBody)});
    }

    /**
     * Transform project type key to a format accepted as an analytics event property value
     * E.g. service_desk is not accepted as it contains _
     */
    function _normalizeProjectTypeKey(projectTypeKey) {
        return projectTypeKey && projectTypeKey.replace("_", "");
    }

    function toggleChangeButton(selectedType, currentType, $dialogBody){
        if(selectedType == currentType ){ // eslint-disable-line eqeqeq
            $dialogBody.find(".dialog-change-button").attr("disabled", "disabled");
        }else{
            $dialogBody.find(".dialog-change-button").removeAttr("disabled");
        }
    }
    /**
     * init the change project dialog
     * @param {Object} options
     * {projectIdOrKey: the project to be changed,
     * trigger: the link to trigger this dialog,
     * onProjectTypeChanged: the function to be called after project type is changed. }
     */
    function initDialog(options) {
        var $dialogBody = $(JIRA.Templates.project.ChangeType.changeProjectTypeDialog({projectId:options.projectId}));
        var changeProjectTypeDialog = AJS.dialog2($dialogBody);

        changeProjectTypeDialog.on("show", function() {
            $(".aui-dialog2-content", $dialogBody).html(JIRA.Templates.project.ChangeType.dialogSpinner());
            $(".dialog-spinner", $dialogBody).spin();

            $(".dialog-change-button", $dialogBody).unbind("click").addClass("hidden");
        });

        $(options.trigger).click(function(e) {
            e.preventDefault();

            changeProjectTypeDialog.show();

            _getProjectInformation(options.projectId).done(function(resp) {
                $dialogBody.find(".aui-dialog2-content").html(JIRA.Templates.project.ChangeType.changeProjectTypeForm(resp));
                new SingleSelect({
                    element: $(".project-type-select", $dialogBody),
                    revertOnInvalid: true,
                    width: 165
                });
                $dialogBody.find(".dialog-change-button").removeClass("hidden");

                toggleChangeButton($(".project-type-select", $dialogBody).val(), resp.project.projectTypeKey, $dialogBody) ;

                var $changeData = {
                    dialogBody: $dialogBody,
                    changeProjectTypeDialog: changeProjectTypeDialog,
                    projectName: resp.project.name,
                    projectTypes: resp.projectTypes,
                    trigger: options.trigger,
                    projectId: options.projectId,
                    onProjectTypeChanged: options.onProjectTypeChanged,
                    sourceProjectType: resp.project.projectTypeKey
                };

                $(".dialog-change-button", $dialogBody).click(function(e) {
                    e.preventDefault();
                    handleChangeProjectType($changeData);

                });

                $(".change-project-type-form", $dialogBody).on("submit", function(e) {
                    e.preventDefault();
                    handleChangeProjectType($changeData);
                });

                $(".project-type-select", $dialogBody).on("change", function(e) {
                    toggleChangeButton($(this).val(), resp.project.projectTypeKey, $dialogBody) ;
                });

            }).fail(function() {
                $(".aui-dialog2-content",$dialogBody).html(aui.message.error({
                    content: AJS.format("We were unable to load data required for the project type change. You could refresh the page and try again. If this doesn\'\'t work, contact {0}Support{1}.", '<a href="https://support.atlassian.com/">', "</a>")
                }));
            });
        });

        $(".dialog-close-button", $dialogBody).click(function(e) {
            e.preventDefault();
            changeProjectTypeDialog.hide();
        });
    }

    return function(options) {
        initDialog(options);
    };
});
;
;
/* module-key = 'jira.webresources:project-type-warning', location = '/static/projecttypes/warning/dialog/project-type-warning-dialog.js' */
define("jira/project/types/warning/dialog", [
    "require"
], function(
    require
) {
    "use strict";

    var jQuery = require("jquery");
    var wrmData = require("wrm/data");
    var InlineDialog = require("aui/inline-dialog");

    function attachDialog(dialogData, onProjectTypeChanged) {
        var trigger = jQuery(".project-type-warning-icon");
        InlineDialog(trigger, "uninstalled-warning-dialog", function (content, trigger, showPopup) {
            content.html(JIRA.Project.Types.Warning.dialog({
                title: dialogData.title,
                firstParagraph: dialogData.firstParagraph,
                secondParagraph: dialogData.secondParagraph,
                callToActionText: dialogData.callToActionText
            }));

            var ChangeProjectTypeDialog = require('jira/project/admin/change-project-type-dialog');
            ChangeProjectTypeDialog({
                trigger: jQuery(".warning-dialog-change-project-type"),
                projectId: dialogData.projectId,
                onProjectTypeChanged: onProjectTypeChanged
            });

            showPopup();
            return false;
        }, {
            width: 375,
            gravity: "w"
        });
    }

    var dialogData = wrmData.claim("project.type.warning.dialogs.data");

    return {
        init: function (options) {
            options = options || {};
            attachDialog(dialogData, options.onProjectTypeChanged);
        }
    };
});
;
;
/* module-key = 'jira.webresources:project-type-warning', location = '/static/projecttypes/warning/dialog/templates/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Project.Types.Warning.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Project == 'undefined') { JIRA.Project = {}; }
if (typeof JIRA.Project.Types == 'undefined') { JIRA.Project.Types = {}; }
if (typeof JIRA.Project.Types.Warning == 'undefined') { JIRA.Project.Types.Warning = {}; }


JIRA.Project.Types.Warning.dialog = function(opt_data, opt_ignored) {
  return '<div class="project-type-warning-dialog"><p class="header"><span>' + soy.$$escapeHtml(opt_data.title) + '</span></p><p class="type-not-accessible-message">' + soy.$$escapeHtml(opt_data.firstParagraph) + '</p><p class="available-functionality-message">' + soy.$$escapeHtml(opt_data.secondParagraph) + '</p><div class="actions"><a class="warning-dialog-change-project-type" href="#">' + soy.$$escapeHtml(opt_data.callToActionText) + '</a></div></div>';
};
if (goog.DEBUG) {
  JIRA.Project.Types.Warning.dialog.soyTemplateName = 'JIRA.Project.Types.Warning.dialog';
}
;
;
/* module-key = 'com.atlassian.plugin.jslibs:marionette-2.1.0-factory', location = 'factories/marionette/2.1.0/marionette-2.1.0-factory.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
  define('atlassian/libs/factories/marionette-2.1.0', function() {
    return function(_, Backbone) {
      var env = {
        _: _,
        Backbone: Backbone
      };
      factory.call(env);
      return env.Marionette.noConflict();
    }
  });
})(function(){
/////// End of Atlassian modification ///////

  // MarionetteJS (Backbone.Marionette)
  // ----------------------------------
  // v2.1.0
  //
  // Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.
  // Distributed under MIT license
  //
  // http://marionettejs.com


  /*!
   * Includes BabySitter
   * https://github.com/marionettejs/backbone.babysitter/
   *
   * Includes Wreqr
   * https://github.com/marionettejs/backbone.wreqr/
   */


  (function(root, factory) {

    if (typeof define === 'function' && define.amd) {
      define(['backbone', 'underscore'], function(Backbone, _) {
        return (root.Marionette = factory(root, Backbone, _));
      });
    } else if (typeof exports !== 'undefined') {
      var Backbone = require('backbone');
      var _ = require('underscore');
      module.exports = factory(root, Backbone, _);
    } else {
      root.Marionette = factory(root, root.Backbone, root._);
    }

  }(this, function(root, Backbone, _) {
    'use strict';

    // Backbone.BabySitter
    // -------------------
    // v0.1.4
    //
    // Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.
    // Distributed under MIT license
    //
    // http://github.com/marionettejs/backbone.babysitter
    (function(Backbone, _) {
      "use strict";
      var previousChildViewContainer = Backbone.ChildViewContainer;
      // BabySitter.ChildViewContainer
      // -----------------------------
      //
      // Provide a container to store, retrieve and
      // shut down child views.
      Backbone.ChildViewContainer = function(Backbone, _) {
        // Container Constructor
        // ---------------------
        var Container = function(views) {
          this._views = {};
          this._indexByModel = {};
          this._indexByCustom = {};
          this._updateLength();
          _.each(views, this.add, this);
        };
        // Container Methods
        // -----------------
        _.extend(Container.prototype, {
          // Add a view to this container. Stores the view
          // by `cid` and makes it searchable by the model
          // cid (and model itself). Optionally specify
          // a custom key to store an retrieve the view.
          add: function(view, customIndex) {
            var viewCid = view.cid;
            // store the view
            this._views[viewCid] = view;
            // index it by model
            if (view.model) {
              this._indexByModel[view.model.cid] = viewCid;
            }
            // index by custom
            if (customIndex) {
              this._indexByCustom[customIndex] = viewCid;
            }
            this._updateLength();
            return this;
          },
          // Find a view by the model that was attached to
          // it. Uses the model's `cid` to find it.
          findByModel: function(model) {
            return this.findByModelCid(model.cid);
          },
          // Find a view by the `cid` of the model that was attached to
          // it. Uses the model's `cid` to find the view `cid` and
          // retrieve the view using it.
          findByModelCid: function(modelCid) {
            var viewCid = this._indexByModel[modelCid];
            return this.findByCid(viewCid);
          },
          // Find a view by a custom indexer.
          findByCustom: function(index) {
            var viewCid = this._indexByCustom[index];
            return this.findByCid(viewCid);
          },
          // Find by index. This is not guaranteed to be a
          // stable index.
          findByIndex: function(index) {
            return _.values(this._views)[index];
          },
          // retrieve a view by its `cid` directly
          findByCid: function(cid) {
            return this._views[cid];
          },
          // Remove a view
          remove: function(view) {
            var viewCid = view.cid;
            // delete model index
            if (view.model) {
              delete this._indexByModel[view.model.cid];
            }
            // delete custom index
            _.any(this._indexByCustom, function(cid, key) {
              if (cid === viewCid) {
                delete this._indexByCustom[key];
                return true;
              }
            }, this);
            // remove the view from the container
            delete this._views[viewCid];
            // update the length
            this._updateLength();
            return this;
          },
          // Call a method on every view in the container,
          // passing parameters to the call method one at a
          // time, like `function.call`.
          call: function(method) {
            this.apply(method, _.tail(arguments));
          },
          // Apply a method on every view in the container,
          // passing parameters to the call method one at a
          // time, like `function.apply`.
          apply: function(method, args) {
            _.each(this._views, function(view) {
              if (_.isFunction(view[method])) {
                view[method].apply(view, args || []);
              }
            });
          },
          // Update the `.length` attribute on this container
          _updateLength: function() {
            this.length = _.size(this._views);
          }
        });
        // Borrowing this code from Backbone.Collection:
        // http://backbonejs.org/docs/backbone.html#section-106
        //
        // Mix in methods from Underscore, for iteration, and other
        // collection related features.
        var methods = [ "forEach", "each", "map", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "toArray", "first", "initial", "rest", "last", "without", "isEmpty", "pluck" ];
        _.each(methods, function(method) {
          Container.prototype[method] = function() {
            var views = _.values(this._views);
            var args = [ views ].concat(_.toArray(arguments));
            return _[method].apply(_, args);
          };
        });
        // return the public API
        return Container;
      }(Backbone, _);
      Backbone.ChildViewContainer.VERSION = "0.1.4";
      Backbone.ChildViewContainer.noConflict = function() {
        Backbone.ChildViewContainer = previousChildViewContainer;
        return this;
      };
      return Backbone.ChildViewContainer;
    })(Backbone, _);
    // Backbone.Wreqr (Backbone.Marionette)
    // ----------------------------------
    // v1.3.1
    //
    // Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.
    // Distributed under MIT license
    //
    // http://github.com/marionettejs/backbone.wreqr
    (function(Backbone, _) {
      "use strict";
      var previousWreqr = Backbone.Wreqr;
      var Wreqr = Backbone.Wreqr = {};
      Backbone.Wreqr.VERSION = "1.3.1";
      Backbone.Wreqr.noConflict = function() {
        Backbone.Wreqr = previousWreqr;
        return this;
      };
      // Handlers
      // --------
      // A registry of functions to call, given a name
      Wreqr.Handlers = function(Backbone, _) {
        "use strict";
        // Constructor
        // -----------
        var Handlers = function(options) {
          this.options = options;
          this._wreqrHandlers = {};
          if (_.isFunction(this.initialize)) {
            this.initialize(options);
          }
        };
        Handlers.extend = Backbone.Model.extend;
        // Instance Members
        // ----------------
        _.extend(Handlers.prototype, Backbone.Events, {
          // Add multiple handlers using an object literal configuration
          setHandlers: function(handlers) {
            _.each(handlers, function(handler, name) {
              var context = null;
              if (_.isObject(handler) && !_.isFunction(handler)) {
                context = handler.context;
                handler = handler.callback;
              }
              this.setHandler(name, handler, context);
            }, this);
          },
          // Add a handler for the given name, with an
          // optional context to run the handler within
          setHandler: function(name, handler, context) {
            var config = {
              callback: handler,
              context: context
            };
            this._wreqrHandlers[name] = config;
            this.trigger("handler:add", name, handler, context);
          },
          // Determine whether or not a handler is registered
          hasHandler: function(name) {
            return !!this._wreqrHandlers[name];
          },
          // Get the currently registered handler for
          // the specified name. Throws an exception if
          // no handler is found.
          getHandler: function(name) {
            var config = this._wreqrHandlers[name];
            if (!config) {
              return;
            }
            return function() {
              var args = Array.prototype.slice.apply(arguments);
              return config.callback.apply(config.context, args);
            };
          },
          // Remove a handler for the specified name
          removeHandler: function(name) {
            delete this._wreqrHandlers[name];
          },
          // Remove all handlers from this registry
          removeAllHandlers: function() {
            this._wreqrHandlers = {};
          }
        });
        return Handlers;
      }(Backbone, _);
      // Wreqr.CommandStorage
      // --------------------
      //
      // Store and retrieve commands for execution.
      Wreqr.CommandStorage = function() {
        "use strict";
        // Constructor function
        var CommandStorage = function(options) {
          this.options = options;
          this._commands = {};
          if (_.isFunction(this.initialize)) {
            this.initialize(options);
          }
        };
        // Instance methods
        _.extend(CommandStorage.prototype, Backbone.Events, {
          // Get an object literal by command name, that contains
          // the `commandName` and the `instances` of all commands
          // represented as an array of arguments to process
          getCommands: function(commandName) {
            var commands = this._commands[commandName];
            // we don't have it, so add it
            if (!commands) {
              // build the configuration
              commands = {
                command: commandName,
                instances: []
              };
              // store it
              this._commands[commandName] = commands;
            }
            return commands;
          },
          // Add a command by name, to the storage and store the
          // args for the command
          addCommand: function(commandName, args) {
            var command = this.getCommands(commandName);
            command.instances.push(args);
          },
          // Clear all commands for the given `commandName`
          clearCommands: function(commandName) {
            var command = this.getCommands(commandName);
            command.instances = [];
          }
        });
        return CommandStorage;
      }();
      // Wreqr.Commands
      // --------------
      //
      // A simple command pattern implementation. Register a command
      // handler and execute it.
      Wreqr.Commands = function(Wreqr) {
        "use strict";
        return Wreqr.Handlers.extend({
          // default storage type
          storageType: Wreqr.CommandStorage,
          constructor: function(options) {
            this.options = options || {};
            this._initializeStorage(this.options);
            this.on("handler:add", this._executeCommands, this);
            var args = Array.prototype.slice.call(arguments);
            Wreqr.Handlers.prototype.constructor.apply(this, args);
          },
          // Execute a named command with the supplied args
          execute: function(name, args) {
            name = arguments[0];
            args = Array.prototype.slice.call(arguments, 1);
            if (this.hasHandler(name)) {
              this.getHandler(name).apply(this, args);
            } else {
              this.storage.addCommand(name, args);
            }
          },
          // Internal method to handle bulk execution of stored commands
          _executeCommands: function(name, handler, context) {
            var command = this.storage.getCommands(name);
            // loop through and execute all the stored command instances
            _.each(command.instances, function(args) {
              handler.apply(context, args);
            });
            this.storage.clearCommands(name);
          },
          // Internal method to initialize storage either from the type's
          // `storageType` or the instance `options.storageType`.
          _initializeStorage: function(options) {
            var storage;
            var StorageType = options.storageType || this.storageType;
            if (_.isFunction(StorageType)) {
              storage = new StorageType();
            } else {
              storage = StorageType;
            }
            this.storage = storage;
          }
        });
      }(Wreqr);
      // Wreqr.RequestResponse
      // ---------------------
      //
      // A simple request/response implementation. Register a
      // request handler, and return a response from it
      Wreqr.RequestResponse = function(Wreqr) {
        "use strict";
        return Wreqr.Handlers.extend({
          request: function() {
            var name = arguments[0];
            var args = Array.prototype.slice.call(arguments, 1);
            if (this.hasHandler(name)) {
              return this.getHandler(name).apply(this, args);
            }
          }
        });
      }(Wreqr);
      // Event Aggregator
      // ----------------
      // A pub-sub object that can be used to decouple various parts
      // of an application through event-driven architecture.
      Wreqr.EventAggregator = function(Backbone, _) {
        "use strict";
        var EA = function() {};
        // Copy the `extend` function used by Backbone's classes
        EA.extend = Backbone.Model.extend;
        // Copy the basic Backbone.Events on to the event aggregator
        _.extend(EA.prototype, Backbone.Events);
        return EA;
      }(Backbone, _);
      // Wreqr.Channel
      // --------------
      //
      // An object that wraps the three messaging systems:
      // EventAggregator, RequestResponse, Commands
      Wreqr.Channel = function(Wreqr) {
        "use strict";
        var Channel = function(channelName) {
          /////////// Modified by Atlassian ///////////
          this.vent = new Wreqr.EventAggregator();
          this.reqres = new Wreqr.RequestResponse();
          this.commands = new Wreqr.Commands();
          /////// End of Atlassian modification ///////
          this.channelName = channelName;
        };
        _.extend(Channel.prototype, {
          // Remove all handlers from the messaging systems of this channel
          reset: function() {
            this.vent.off();
            this.vent.stopListening();
            this.reqres.removeAllHandlers();
            this.commands.removeAllHandlers();
            return this;
          },
          // Connect a hash of events; one for each messaging system
          connectEvents: function(hash, context) {
            this._connect("vent", hash, context);
            return this;
          },
          connectCommands: function(hash, context) {
            this._connect("commands", hash, context);
            return this;
          },
          connectRequests: function(hash, context) {
            this._connect("reqres", hash, context);
            return this;
          },
          // Attach the handlers to a given message system `type`
          _connect: function(type, hash, context) {
            if (!hash) {
              return;
            }
            context = context || this;
            var method = type === "vent" ? "on" : "setHandler";
            _.each(hash, function(fn, eventName) {
              this[type][method](eventName, _.bind(fn, context));
            }, this);
          }
        });
        return Channel;
      }(Wreqr);
      // Wreqr.Radio
      // --------------
      //
      // An object that lets you communicate with many channels.
      Wreqr.radio = function(Wreqr) {
        "use strict";
        var Radio = function() {
          this._channels = {};
          this.vent = {};
          this.commands = {};
          this.reqres = {};
          this._proxyMethods();
        };
        _.extend(Radio.prototype, {
          channel: function(channelName) {
            if (!channelName) {
              throw new Error("Channel must receive a name");
            }
            return this._getChannel(channelName);
          },
          _getChannel: function(channelName) {
            var channel = this._channels[channelName];
            if (!channel) {
              channel = new Wreqr.Channel(channelName);
              this._channels[channelName] = channel;
            }
            return channel;
          },
          _proxyMethods: function() {
            _.each([ "vent", "commands", "reqres" ], function(system) {
              _.each(messageSystems[system], function(method) {
                this[system][method] = proxyMethod(this, system, method);
              }, this);
            }, this);
          }
        });
        var messageSystems = {
          vent: [ "on", "off", "trigger", "once", "stopListening", "listenTo", "listenToOnce" ],
          commands: [ "execute", "setHandler", "setHandlers", "removeHandler", "removeAllHandlers" ],
          reqres: [ "request", "setHandler", "setHandlers", "removeHandler", "removeAllHandlers" ]
        };
        var proxyMethod = function(radio, system, method) {
          return function(channelName) {
            var messageSystem = radio._getChannel(channelName)[system];
            var args = Array.prototype.slice.call(arguments, 1);
            return messageSystem[method].apply(messageSystem, args);
          };
        };
        return new Radio();
      }(Wreqr);
      return Backbone.Wreqr;
    })(Backbone, _);

    /////////// Modified by Atlassian ///////////
    var BackboneChildViewContainer = Backbone.ChildViewContainer.noConflict();
    var BackboneWreqr = Backbone.Wreqr.noConflict();
    /////// End of Atlassian modification ///////

    var previousMarionette = root.Marionette;

    var Marionette = Backbone.Marionette = {};

    Marionette.VERSION = '2.1.0';

    Marionette.noConflict = function() {
      root.Marionette = previousMarionette;
      return this;
    };

    Backbone.Marionette = Marionette;

    // Get the Deferred creator for later use
    Marionette.Deferred = Backbone.$.Deferred;

    /* jshint unused: false */

    // Helpers
    // -------

    // For slicing `arguments` in functions
    var slice = Array.prototype.slice;

    function throwError(message, name) {
      var error = new Error(message);
      error.name = name || 'Error';
      throw error;
    }

    // Marionette.extend
    // -----------------

    // Borrow the Backbone `extend` method so we can use it as needed
    Marionette.extend = Backbone.Model.extend;

    // Marionette.getOption
    // --------------------

    // Retrieve an object, function or other value from a target
    // object or its `options`, with `options` taking precedence.
    Marionette.getOption = function(target, optionName) {
      if (!target || !optionName) { return; }
      var value;

      if (target.options && (target.options[optionName] !== undefined)) {
        value = target.options[optionName];
      } else {
        value = target[optionName];
      }

      return value;
    };

    // Proxy `Marionette.getOption`
    Marionette.proxyGetOption = function(optionName) {
      return Marionette.getOption(this, optionName);
    };

    // Marionette.normalizeMethods
    // ----------------------

    // Pass in a mapping of events => functions or function names
    // and return a mapping of events => functions
    Marionette.normalizeMethods = function(hash) {
      var normalizedHash = {};
      _.each(hash, function(method, name) {
        if (!_.isFunction(method)) {
          method = this[method];
        }
        if (!method) {
          return;
        }
        normalizedHash[name] = method;
      }, this);
      return normalizedHash;
    };


    // allows for the use of the @ui. syntax within
    // a given key for triggers and events
    // swaps the @ui with the associated selector
    Marionette.normalizeUIKeys = function(hash, ui) {
      if (typeof(hash) === 'undefined') {
        return;
      }

      _.each(_.keys(hash), function(v) {
        var pattern = /@ui\.[a-zA-Z_$0-9]*/g;
        if (v.match(pattern)) {
          hash[v.replace(pattern, function(r) {
            return ui[r.slice(4)];
          })] = hash[v];
          delete hash[v];
        }
      });

      return hash;
    };

    // Mix in methods from Underscore, for iteration, and other
    // collection related features.
    // Borrowing this code from Backbone.Collection:
    // http://backbonejs.org/docs/backbone.html#section-121
    Marionette.actAsCollection = function(object, listProperty) {
      var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
        'select', 'reject', 'every', 'all', 'some', 'any', 'include',
        'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
        'last', 'without', 'isEmpty', 'pluck'];

      _.each(methods, function(method) {
        object[method] = function() {
          var list = _.values(_.result(this, listProperty));
          var args = [list].concat(_.toArray(arguments));
          return _[method].apply(_, args);
        };
      });
    };

    // Trigger an event and/or a corresponding method name. Examples:
    //
    // `this.triggerMethod("foo")` will trigger the "foo" event and
    // call the "onFoo" method.
    //
    // `this.triggerMethod("foo:bar")` will trigger the "foo:bar" event and
    // call the "onFooBar" method.
    Marionette.triggerMethod = (function() {

      // split the event name on the ":"
      var splitter = /(^|:)(\w)/gi;

      // take the event section ("section1:section2:section3")
      // and turn it in to uppercase name
      function getEventName(match, prefix, eventName) {
        return eventName.toUpperCase();
      }

      // actual triggerMethod implementation
      var triggerMethod = function(event) {
        // get the method name from the event name
        var methodName = 'on' + event.replace(splitter, getEventName);
        var method = this[methodName];
        var result;

        // call the onMethodName if it exists
        if (_.isFunction(method)) {
          // pass all arguments, except the event name
          result = method.apply(this, _.tail(arguments));
        }

        // trigger the event, if a trigger method exists
        if (_.isFunction(this.trigger)) {
          this.trigger.apply(this, arguments);
        }

        return result;
      };

      return triggerMethod;
    })();

    // DOMRefresh
    // ----------
    //
    // Monitor a view's state, and after it has been rendered and shown
    // in the DOM, trigger a "dom:refresh" event every time it is
    // re-rendered.

    Marionette.MonitorDOMRefresh = (function(documentElement) {
      // track when the view has been shown in the DOM,
      // using a Marionette.Region (or by other means of triggering "show")
      function handleShow(view) {
        view._isShown = true;
        triggerDOMRefresh(view);
      }

      // track when the view has been rendered
      function handleRender(view) {
        view._isRendered = true;
        triggerDOMRefresh(view);
      }

      // Trigger the "dom:refresh" event and corresponding "onDomRefresh" method
      function triggerDOMRefresh(view) {
        if (view._isShown && view._isRendered && isInDOM(view)) {
          if (_.isFunction(view.triggerMethod)) {
            view.triggerMethod('dom:refresh');
          }
        }
      }

      function isInDOM(view) {
        return Backbone.$.contains(documentElement, view.el);
      }

      // Export public API
      return function(view) {
        view.listenTo(view, 'show', function() {
          handleShow(view);
        });

        view.listenTo(view, 'render', function() {
          handleRender(view);
        });
      };
    })(document.documentElement);


    /* jshint maxparams: 5 */

    // Marionette.bindEntityEvents & unbindEntityEvents
    // ---------------------------
    //
    // These methods are used to bind/unbind a backbone "entity" (collection/model)
    // to methods on a target object.
    //
    // The first parameter, `target`, must have a `listenTo` method from the
    // EventBinder object.
    //
    // The second parameter is the entity (Backbone.Model or Backbone.Collection)
    // to bind the events from.
    //
    // The third parameter is a hash of { "event:name": "eventHandler" }
    // configuration. Multiple handlers can be separated by a space. A
    // function can be supplied instead of a string handler name.

    (function(Marionette) {
      'use strict';

      // Bind the event to handlers specified as a string of
      // handler names on the target object
      function bindFromStrings(target, entity, evt, methods) {
        var methodNames = methods.split(/\s+/);

        _.each(methodNames, function(methodName) {

          var method = target[methodName];
          if (!method) {
            throwError('Method "' + methodName +
              '" was configured as an event handler, but does not exist.');
          }

          target.listenTo(entity, evt, method);
        });
      }

      // Bind the event to a supplied callback function
      function bindToFunction(target, entity, evt, method) {
        target.listenTo(entity, evt, method);
      }

      // Bind the event to handlers specified as a string of
      // handler names on the target object
      function unbindFromStrings(target, entity, evt, methods) {
        var methodNames = methods.split(/\s+/);

        _.each(methodNames, function(methodName) {
          var method = target[methodName];
          target.stopListening(entity, evt, method);
        });
      }

      // Bind the event to a supplied callback function
      function unbindToFunction(target, entity, evt, method) {
        target.stopListening(entity, evt, method);
      }


      // generic looping function
      function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {
        if (!entity || !bindings) { return; }

        // allow the bindings to be a function
        if (_.isFunction(bindings)) {
          bindings = bindings.call(target);
        }

        // iterate the bindings and bind them
        _.each(bindings, function(methods, evt) {

          // allow for a function as the handler,
          // or a list of event names as a string
          if (_.isFunction(methods)) {
            functionCallback(target, entity, evt, methods);
          } else {
            stringCallback(target, entity, evt, methods);
          }

        });
      }

      // Export Public API
      Marionette.bindEntityEvents = function(target, entity, bindings) {
        iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);
      };

      Marionette.unbindEntityEvents = function(target, entity, bindings) {
        iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);
      };

      // Proxy `bindEntityEvents`
      Marionette.proxyBindEntityEvents = function(entity, bindings) {
        return Marionette.bindEntityEvents(this, entity, bindings);
      };

      // Proxy `unbindEntityEvents`
      Marionette.proxyUnbindEntityEvents = function(entity, bindings) {
        return Marionette.unbindEntityEvents(this, entity, bindings);
      };
    })(Marionette);


    // Callbacks
    // ---------

    // A simple way of managing a collection of callbacks
    // and executing them at a later point in time, using jQuery's
    // `Deferred` object.
    Marionette.Callbacks = function() {
      this._deferred = Marionette.Deferred();
      this._callbacks = [];
    };

    _.extend(Marionette.Callbacks.prototype, {

      // Add a callback to be executed. Callbacks added here are
      // guaranteed to execute, even if they are added after the
      // `run` method is called.
      add: function(callback, contextOverride) {
        var promise = _.result(this._deferred, 'promise');

        this._callbacks.push({cb: callback, ctx: contextOverride});

        promise.then(function(args) {
          if (contextOverride){ args.context = contextOverride; }
          callback.call(args.context, args.options);
        });
      },

      // Run all registered callbacks with the context specified.
      // Additional callbacks can be added after this has been run
      // and they will still be executed.
      run: function(options, context) {
        this._deferred.resolve({
          options: options,
          context: context
        });
      },

      // Resets the list of callbacks to be run, allowing the same list
      // to be run multiple times - whenever the `run` method is called.
      reset: function() {
        var callbacks = this._callbacks;
        this._deferred = Marionette.Deferred();
        this._callbacks = [];

        _.each(callbacks, function(cb) {
          this.add(cb.cb, cb.ctx);
        }, this);
      }
    });

    // Marionette Controller
    // ---------------------
    //
    // A multi-purpose object to use as a controller for
    // modules and routers, and as a mediator for workflow
    // and coordination of other objects, views, and more.
    Marionette.Controller = function(options) {
      this.options = options || {};

      if (_.isFunction(this.initialize)) {
        this.initialize(this.options);
      }
    };

    Marionette.Controller.extend = Marionette.extend;

    // Controller Methods
    // --------------

    // Ensure it can trigger events with Backbone.Events
    _.extend(Marionette.Controller.prototype, Backbone.Events, {
      destroy: function() {
        var args = slice.call(arguments);
        this.triggerMethod.apply(this, ['before:destroy'].concat(args));
        this.triggerMethod.apply(this, ['destroy'].concat(args));

        this.stopListening();
        this.off();
        return this;
      },

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod,

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption

    });

    // Marionette Object
    // ---------------------
    //
    // A Base Class that other Classes should descend from.
    // Object borrows many conventions and utilities from Backbone.
    Marionette.Object = function(options) {

      this.options = _.extend({}, _.result(this, 'options'), options);

      this.initialize(this.options);
    };

    Marionette.Object.extend = Marionette.extend;

    // Object Methods
    // --------------

    _.extend(Marionette.Object.prototype, {

      //this is a noop method intended to be overridden by classes that extend from this base
      initialize: function() {},

      destroy: function() {
        this.triggerMethod('before:destroy');
        this.triggerMethod('destroy');
        this.stopListening();
      },

      // Import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod,

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption,

      // Proxy `unbindEntityEvents` to enable binding view's events from another entity.
      bindEntityEvents: Marionette.proxyBindEntityEvents,

      // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
      unbindEntityEvents: Marionette.proxyUnbindEntityEvents
    });

    // Ensure it can trigger events with Backbone.Events
    _.extend(Marionette.Object.prototype, Backbone.Events);

    /* jshint maxcomplexity: 10, maxstatements: 29 */

    // Region
    // ------
    //
    // Manage the visual regions of your composite application. See
    // http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/

    Marionette.Region = function(options) {
      this.options = options || {};
      this.el = this.getOption('el');

      // Handle when this.el is passed in as a $ wrapped element.
      this.el = this.el instanceof Backbone.$ ? this.el[0] : this.el;

      if (!this.el) {
        throwError('An "el" must be specified for a region.', 'NoElError');
      }

      this.$el = this.getEl(this.el);

      if (this.initialize) {
        var args = slice.apply(arguments);
        this.initialize.apply(this, args);
      }
    };


    // Region Class methods
    // -------------------

    _.extend(Marionette.Region, {

      // Build an instance of a region by passing in a configuration object
      // and a default region class to use if none is specified in the config.
      //
      // The config object should either be a string as a jQuery DOM selector,
      // a Region class directly, or an object literal that specifies both
      // a selector and regionClass:
      //
      // ```js
      // {
      //   selector: "#foo",
      //   regionClass: MyCustomRegion
      // }
      // ```
      //
      buildRegion: function(regionConfig, DefaultRegionClass) {
        if (_.isString(regionConfig)) {
          return this._buildRegionFromSelector(regionConfig, DefaultRegionClass);
        }

        if (regionConfig.selector || regionConfig.el || regionConfig.regionClass) {
          return this._buildRegionFromObject(regionConfig, DefaultRegionClass);
        }

        if (_.isFunction(regionConfig)) {
          return this._buildRegionFromRegionClass(regionConfig);
        }

        throwError('Improper region configuration type. Please refer ' +
          'to http://marionettejs.com/docs/marionette.region.html#region-configuration-types');
      },

      // Build the region from a string selector like '#foo-region'
      _buildRegionFromSelector: function(selector, DefaultRegionClass) {
        return new DefaultRegionClass({ el: selector });
      },

      // Build the region from a configuration object
      // ```js
      // { selector: '#foo', regionClass: FooRegion }
      // ```
      _buildRegionFromObject: function(regionConfig, DefaultRegionClass) {
        var RegionClass = regionConfig.regionClass || DefaultRegionClass;
        var options = _.omit(regionConfig, 'selector', 'regionClass');

        if (regionConfig.selector && !options.el) {
          options.el = regionConfig.selector;
        }

        var region = new RegionClass(options);

        // override the `getEl` function if we have a parentEl
        // this must be overridden to ensure the selector is found
        // on the first use of the region. if we try to assign the
        // region's `el` to `parentEl.find(selector)` in the object
        // literal to build the region, the element will not be
        // guaranteed to be in the DOM already, and will cause problems
        if (regionConfig.parentEl) {
          region.getEl = function(el) {
            if (_.isObject(el)) {
              return Backbone.$(el);
            }
            var parentEl = regionConfig.parentEl;
            if (_.isFunction(parentEl)) {
              parentEl = parentEl();
            }
            return parentEl.find(el);
          };
        }

        return region;
      },

      // Build the region directly from a given `RegionClass`
      _buildRegionFromRegionClass: function(RegionClass) {
        return new RegionClass();
      }

    });

    // Region Instance Methods
    // -----------------------

    _.extend(Marionette.Region.prototype, Backbone.Events, {

      // Displays a backbone view instance inside of the region.
      // Handles calling the `render` method for you. Reads content
      // directly from the `el` attribute. Also calls an optional
      // `onShow` and `onDestroy` method on your view, just after showing
      // or just before destroying the view, respectively.
      // The `preventDestroy` option can be used to prevent a view from
      // the old view being destroyed on show.
      // The `forceShow` option can be used to force a view to be
      // re-rendered if it's already shown in the region.

      show: function(view, options){
        this._ensureElement();

        var showOptions = options || {};
        var isDifferentView = view !== this.currentView;
        var preventDestroy =  !!showOptions.preventDestroy;
        var forceShow = !!showOptions.forceShow;

        // we are only changing the view if there is a view to change to begin with
        var isChangingView = !!this.currentView;

        // only destroy the view if we don't want to preventDestroy and the view is different
        var _shouldDestroyView = !preventDestroy && isDifferentView;

        if (_shouldDestroyView) {
          this.empty();
        }

        // show the view if the view is different or if you want to re-show the view
        var _shouldShowView = isDifferentView || forceShow;

        if (_shouldShowView) {

          // We need to listen for if a view is destroyed
          // in a way other than through the region.
          // If this happens we need to remove the reference
          // to the currentView since once a view has been destroyed
          // we can not reuse it.
          view.once('destroy', _.bind(this.empty, this));
          view.render();

          if (isChangingView) {
            this.triggerMethod('before:swap', view);
          }

          this.triggerMethod('before:show', view);

          if (_.isFunction(view.triggerMethod)) {
            view.triggerMethod('before:show');
          } else {
            this.triggerMethod.call(view, 'before:show');
          }

          this.attachHtml(view);
          this.currentView = view;

          if (isChangingView) {
            this.triggerMethod('swap', view);
          }

          this.triggerMethod('show', view);

          if (_.isFunction(view.triggerMethod)) {
            view.triggerMethod('show');
          } else {
            this.triggerMethod.call(view, 'show');
          }

          return this;
        }

        return this;
      },

      _ensureElement: function(){
        if (!_.isObject(this.el)) {
          this.$el = this.getEl(this.el);
          this.el = this.$el[0];
        }

        if (!this.$el || this.$el.length === 0) {
          throwError('An "el" ' + this.$el.selector + ' must exist in DOM');
        }
      },

      // Override this method to change how the region finds the
      // DOM element that it manages. Return a jQuery selector object.
      getEl: function(el) {
        return Backbone.$(el);
      },

      // Override this method to change how the new view is
      // appended to the `$el` that the region is managing
      attachHtml: function(view) {
        // empty the node and append new view
        this.el.innerHTML='';
        this.el.appendChild(view.el);
      },

      // Destroy the current view, if there is one. If there is no
      // current view, it does nothing and returns immediately.
      empty: function() {
        var view = this.currentView;

        // If there is no view in the region
        // we should not remove anything
        if (!view) { return; }

        this.triggerMethod('before:empty', view);
        this._destroyView();
        this.triggerMethod('empty', view);

        // Remove region pointer to the currentView
        delete this.currentView;
        return this;
      },

      // call 'destroy' or 'remove', depending on which is found
      // on the view (if showing a raw Backbone view or a Marionette View)
      _destroyView: function() {
        var view = this.currentView;

        if (view.destroy && !view.isDestroyed) {
          view.destroy();
        } else if (view.remove) {
          view.remove();
        }
      },

      // Attach an existing view to the region. This
      // will not call `render` or `onShow` for the new view,
      // and will not replace the current HTML for the `el`
      // of the region.
      attachView: function(view) {
        this.currentView = view;
        return this;
      },

      // Checks whether a view is currently present within
      // the region. Returns `true` if there is and `false` if
      // no view is present.
      hasView: function() {
        return !!this.currentView;
      },

      // Reset the region by destroying any existing view and
      // clearing out the cached `$el`. The next time a view
      // is shown via this region, the region will re-query the
      // DOM for the region's `el`.
      reset: function() {
        this.empty();

        if (this.$el) {
          this.el = this.$el.selector;
        }

        delete this.$el;
        return this;
      },

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption,

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod
    });

    // Copy the `extend` function used by Backbone's classes
    Marionette.Region.extend = Marionette.extend;

    // Marionette.RegionManager
    // ------------------------
    //
    // Manage one or more related `Marionette.Region` objects.
    Marionette.RegionManager = (function(Marionette) {

      var RegionManager = Marionette.Controller.extend({
        constructor: function(options) {
          this._regions = {};
          Marionette.Controller.call(this, options);
        },

        // Add multiple regions using an object literal or a
        // function that returns an object literal, where
        // each key becomes the region name, and each value is
        // the region definition.
        addRegions: function(regionDefinitions, defaults) {
          if (_.isFunction(regionDefinitions)) {
            regionDefinitions = regionDefinitions.apply(this, arguments);
          }

          var regions = {};

          _.each(regionDefinitions, function(definition, name) {
            if (_.isString(definition)) {
              definition = {selector: definition};
            }

            if (definition.selector) {
              definition = _.defaults({}, definition, defaults);
            }

            var region = this.addRegion(name, definition);
            regions[name] = region;
          }, this);

          return regions;
        },

        // Add an individual region to the region manager,
        // and return the region instance
        addRegion: function(name, definition) {
          var region;

          var isObject = _.isObject(definition);
          var isString = _.isString(definition);
          var hasSelector = !!definition.selector;

          if (isString || (isObject && hasSelector)) {
            region = Marionette.Region.buildRegion(definition, Marionette.Region);
          } else if (_.isFunction(definition)) {
            region = Marionette.Region.buildRegion(definition, Marionette.Region);
          } else {
            region = definition;
          }

          this.triggerMethod('before:add:region', name, region);

          this._store(name, region);

          this.triggerMethod('add:region', name, region);
          return region;
        },

        // Get a region by name
        get: function(name) {
          return this._regions[name];
        },

        // Gets all the regions contained within
        // the `regionManager` instance.
        getRegions: function(){
          return _.clone(this._regions);
        },

        // Remove a region by name
        removeRegion: function(name) {
          var region = this._regions[name];
          this._remove(name, region);

          return region;
        },

        // Empty all regions in the region manager, and
        // remove them
        removeRegions: function() {
          var regions = this.getRegions();
          _.each(this._regions, function(region, name) {
            this._remove(name, region);
          }, this);

          return regions;
        },

        // Empty all regions in the region manager, but
        // leave them attached
        emptyRegions: function() {
          var regions = this.getRegions();
          _.each(regions, function(region) {
            region.empty();
          }, this);

          return regions;
        },

        // Destroy all regions and shut down the region
        // manager entirely
        destroy: function() {
          this.removeRegions();
          return Marionette.Controller.prototype.destroy.apply(this, arguments);
        },

        // internal method to store regions
        _store: function(name, region) {
          this._regions[name] = region;
          this._setLength();
        },

        // internal method to remove a region
        _remove: function(name, region) {
          this.triggerMethod('before:remove:region', name, region);
          region.empty();
          region.stopListening();
          delete this._regions[name];
          this._setLength();
          this.triggerMethod('remove:region', name, region);
        },

        // set the number of regions current held
        _setLength: function() {
          this.length = _.size(this._regions);
        }

      });

      Marionette.actAsCollection(RegionManager.prototype, '_regions');

      return RegionManager;
    })(Marionette);


    // Template Cache
    // --------------

    // Manage templates stored in `<script>` blocks,
    // caching them for faster access.
    Marionette.TemplateCache = function(templateId) {
      this.templateId = templateId;
    };

    // TemplateCache object-level methods. Manage the template
    // caches from these method calls instead of creating
    // your own TemplateCache instances
    _.extend(Marionette.TemplateCache, {
      templateCaches: {},

      // Get the specified template by id. Either
      // retrieves the cached version, or loads it
      // from the DOM.
      get: function(templateId) {
        var cachedTemplate = this.templateCaches[templateId];

        if (!cachedTemplate) {
          cachedTemplate = new Marionette.TemplateCache(templateId);
          this.templateCaches[templateId] = cachedTemplate;
        }

        return cachedTemplate.load();
      },

      // Clear templates from the cache. If no arguments
      // are specified, clears all templates:
      // `clear()`
      //
      // If arguments are specified, clears each of the
      // specified templates from the cache:
      // `clear("#t1", "#t2", "...")`
      clear: function() {
        var i;
        var args = slice.call(arguments);
        var length = args.length;

        if (length > 0) {
          for (i = 0; i < length; i++) {
            delete this.templateCaches[args[i]];
          }
        } else {
          this.templateCaches = {};
        }
      }
    });

    // TemplateCache instance methods, allowing each
    // template cache object to manage its own state
    // and know whether or not it has been loaded
    _.extend(Marionette.TemplateCache.prototype, {

      // Internal method to load the template
      load: function() {
        // Guard clause to prevent loading this template more than once
        if (this.compiledTemplate) {
          return this.compiledTemplate;
        }

        // Load the template and compile it
        var template = this.loadTemplate(this.templateId);
        this.compiledTemplate = this.compileTemplate(template);

        return this.compiledTemplate;
      },

      // Load a template from the DOM, by default. Override
      // this method to provide your own template retrieval
      // For asynchronous loading with AMD/RequireJS, consider
      // using a template-loader plugin as described here:
      // https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs
      loadTemplate: function(templateId) {
        var template = Backbone.$(templateId).html();

        if (!template || template.length === 0) {
          throwError('Could not find template: "' + templateId + '"', 'NoTemplateError');
        }

        return template;
      },

      // Pre-compile the template before caching it. Override
      // this method if you do not need to pre-compile a template
      // (JST / RequireJS for example) or if you want to change
      // the template engine used (Handebars, etc).
      compileTemplate: function(rawTemplate) {
        return _.template(rawTemplate);
      }
    });

    // Renderer
    // --------

    // Render a template with data by passing in the template
    // selector and the data to render.
    Marionette.Renderer = {

      // Render a template with data. The `template` parameter is
      // passed to the `TemplateCache` object to retrieve the
      // template function. Override this method to provide your own
      // custom rendering and template handling for all of Marionette.
      render: function(template, data) {
        if (!template) {
          throwError('Cannot render the template since its false, null or undefined.',
            'TemplateNotFoundError');
        }

        var templateFunc;
        if (typeof template === 'function') {
          templateFunc = template;
        } else {
          templateFunc = Marionette.TemplateCache.get(template);
        }

        return templateFunc(data);
      }
    };


    /* jshint maxlen: 114, nonew: false */
    // Marionette.View
    // ---------------

    // The core view class that other Marionette views extend from.
    Marionette.View = Backbone.View.extend({

      constructor: function(options) {
        _.bindAll(this, 'render');

        // this exposes view options to the view initializer
        // this is a backfill since backbone removed the assignment
        // of this.options
        // at some point however this may be removed
        this.options = _.extend({}, _.result(this, 'options'), _.isFunction(options) ? options.call(this) : options);
        // parses out the @ui DSL for events
        this.events = this.normalizeUIKeys(_.result(this, 'events'));

        if (_.isObject(this.behaviors)) {
          new Marionette.Behaviors(this);
        }

        Backbone.View.apply(this, arguments);

        Marionette.MonitorDOMRefresh(this);
        this.listenTo(this, 'show', this.onShowCalled);
      },

      // Get the template for this view
      // instance. You can set a `template` attribute in the view
      // definition or pass a `template: "whatever"` parameter in
      // to the constructor options.
      getTemplate: function() {
        return this.getOption('template');
      },

      // Serialize a model by returning its attributes. Clones
      // the attributes to allow modification.
      serializeModel: function(model){
        return model.toJSON.apply(model, slice.call(arguments, 1));
      },

      // Mix in template helper methods. Looks for a
      // `templateHelpers` attribute, which can either be an
      // object literal, or a function that returns an object
      // literal. All methods and attributes from this object
      // are copies to the object passed in.
      mixinTemplateHelpers: function(target) {
        target = target || {};
        var templateHelpers = this.getOption('templateHelpers');
        if (_.isFunction(templateHelpers)) {
          templateHelpers = templateHelpers.call(this);
        }
        return _.extend(target, templateHelpers);
      },


      normalizeUIKeys: function(hash) {
        var ui = _.result(this, 'ui');
        var uiBindings = _.result(this, '_uiBindings');
        return Marionette.normalizeUIKeys(hash, uiBindings || ui);
      },

      // Configure `triggers` to forward DOM events to view
      // events. `triggers: {"click .foo": "do:foo"}`
      configureTriggers: function() {
        if (!this.triggers) { return; }

        var triggerEvents = {};

        // Allow `triggers` to be configured as a function
        var triggers = this.normalizeUIKeys(_.result(this, 'triggers'));

        // Configure the triggers, prevent default
        // action and stop propagation of DOM events
        _.each(triggers, function(value, key) {

          var hasOptions = _.isObject(value);
          var eventName = hasOptions ? value.event : value;

          // build the event handler function for the DOM event
          triggerEvents[key] = function(e) {

            // stop the event in its tracks
            if (e) {
              var prevent = e.preventDefault;
              var stop = e.stopPropagation;

              var shouldPrevent = hasOptions ? value.preventDefault : prevent;
              var shouldStop = hasOptions ? value.stopPropagation : stop;

              if (shouldPrevent && prevent) { prevent.apply(e); }
              if (shouldStop && stop) { stop.apply(e); }
            }

            // build the args for the event
            var args = {
              view: this,
              model: this.model,
              collection: this.collection
            };

            // trigger the event
            this.triggerMethod(eventName, args);
          };

        }, this);

        return triggerEvents;
      },

      // Overriding Backbone.View's delegateEvents to handle
      // the `triggers`, `modelEvents`, and `collectionEvents` configuration
      delegateEvents: function(events) {
        this._delegateDOMEvents(events);
        this.bindEntityEvents(this.model, this.getOption('modelEvents'));
        this.bindEntityEvents(this.collection, this.getOption('collectionEvents'));
        return this;
      },

      // internal method to delegate DOM events and triggers
      _delegateDOMEvents: function(events) {
        events = events || this.events;
        if (_.isFunction(events)) { events = events.call(this); }

        // normalize ui keys
        events = this.normalizeUIKeys(events);

        var combinedEvents = {};

        // look up if this view has behavior events
        var behaviorEvents = _.result(this, 'behaviorEvents') || {};
        var triggers = this.configureTriggers();

        // behavior events will be overriden by view events and or triggers
        _.extend(combinedEvents, behaviorEvents, events, triggers);

        Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
      },

      // Overriding Backbone.View's undelegateEvents to handle unbinding
      // the `triggers`, `modelEvents`, and `collectionEvents` config
      undelegateEvents: function() {
        var args = slice.call(arguments);
        Backbone.View.prototype.undelegateEvents.apply(this, args);
        this.unbindEntityEvents(this.model, this.getOption('modelEvents'));
        this.unbindEntityEvents(this.collection, this.getOption('collectionEvents'));
        return this;
      },

      // Internal method, handles the `show` event.
      onShowCalled: function() {},

      // Internal helper method to verify whether the view hasn't been destroyed
      _ensureViewIsIntact: function() {
        if (this.isDestroyed) {
          var err = new Error('Cannot use a view thats already been destroyed.');
          err.name = 'ViewDestroyedError';
          throw err;
        }
      },

      // Default `destroy` implementation, for removing a view from the
      // DOM and unbinding it. Regions will call this method
      // for you. You can specify an `onDestroy` method in your view to
      // add custom code that is called after the view is destroyed.
      destroy: function() {
        if (this.isDestroyed) { return; }

        var args = slice.call(arguments);

        this.triggerMethod.apply(this, ['before:destroy'].concat(args));

        // mark as destroyed before doing the actual destroy, to
        // prevent infinite loops within "destroy" event handlers
        // that are trying to destroy other views
        this.isDestroyed = true;
        this.triggerMethod.apply(this, ['destroy'].concat(args));

        // unbind UI elements
        this.unbindUIElements();

        // remove the view from the DOM
        this.remove();
        return this;
      },

      // This method binds the elements specified in the "ui" hash inside the view's code with
      // the associated jQuery selectors.
      bindUIElements: function() {
        if (!this.ui) { return; }

        // store the ui hash in _uiBindings so they can be reset later
        // and so re-rendering the view will be able to find the bindings
        if (!this._uiBindings) {
          this._uiBindings = this.ui;
        }

        // get the bindings result, as a function or otherwise
        var bindings = _.result(this, '_uiBindings');

        // empty the ui so we don't have anything to start with
        this.ui = {};

        // bind each of the selectors
        _.each(_.keys(bindings), function(key) {
          var selector = bindings[key];
          this.ui[key] = this.$(selector);
        }, this);
      },

      // This method unbinds the elements specified in the "ui" hash
      unbindUIElements: function() {
        if (!this.ui || !this._uiBindings) { return; }

        // delete all of the existing ui bindings
        _.each(this.ui, function($el, name) {
          delete this.ui[name];
        }, this);

        // reset the ui element to the original bindings configuration
        this.ui = this._uiBindings;
        delete this._uiBindings;
      },

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod,

      // Imports the "normalizeMethods" to transform hashes of
      // events=>function references/names to a hash of events=>function references
      normalizeMethods: Marionette.normalizeMethods,

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption,

      // Proxy `unbindEntityEvents` to enable binding view's events from another entity.
      bindEntityEvents: Marionette.proxyBindEntityEvents,

      // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
      unbindEntityEvents: Marionette.proxyUnbindEntityEvents
    });

    // Item View
    // ---------

    // A single item view implementation that contains code for rendering
    // with underscore.js templates, serializing the view's model or collection,
    // and calling several methods on extended views, such as `onRender`.
    Marionette.ItemView = Marionette.View.extend({

      // Setting up the inheritance chain which allows changes to
      // Marionette.View.prototype.constructor which allows overriding
      constructor: function() {
        Marionette.View.apply(this, arguments);
      },

      // Serialize the model or collection for the view. If a model is
      // found, the view's `serializeModel` is called. If a collection is found,
      // each model in the collection is serialized by calling
      // the view's `serializeCollection` and put into an `items` array in
      // the resulting data. If both are found, defaults to the model.
      // You can override the `serializeData` method in your own view definition,
      // to provide custom serialization for your view's data.
      serializeData: function(){
        var data = {};

        if (this.model) {
          data = _.partial(this.serializeModel, this.model).apply(this, arguments);
        }
        else if (this.collection) {
          data = { items: _.partial(this.serializeCollection, this.collection).apply(this, arguments) };
        }

        return data;
      },

      // Serialize a collection by serializing each of its models.
      serializeCollection: function(collection){
        return collection.toJSON.apply(collection, slice.call(arguments, 1));
      },

      // Render the view, defaulting to underscore.js templates.
      // You can override this in your view definition to provide
      // a very specific rendering for your view. In general, though,
      // you should override the `Marionette.Renderer` object to
      // change how Marionette renders views.
      render: function() {
        this._ensureViewIsIntact();

        this.triggerMethod('before:render', this);

        this._renderTemplate();
        this.bindUIElements();

        this.triggerMethod('render', this);

        return this;
      },

      // Internal method to render the template with the serialized data
      // and template helpers via the `Marionette.Renderer` object.
      // Throws an `UndefinedTemplateError` error if the template is
      // any falsely value but literal `false`.
      _renderTemplate: function() {
        var template = this.getTemplate();

        // Allow template-less item views
        if (template === false) {
          return;
        }

        if (!template) {
          throwError('Cannot render the template since it is null or undefined.',
            'UndefinedTemplateError');
        }

        // Add in entity data and template helpers
        var data = this.serializeData();
        data = this.mixinTemplateHelpers(data);

        // Render and add to el
        var html = Marionette.Renderer.render(template, data, this);
        this.attachElContent(html);

        return this;
      },

      // Attaches the content of a given view.
      // This method can be overriden to optimize rendering,
      // or to render in a non standard way.
      //
      // For example, using `innerHTML` instead of `$el.html`
      //
      // ```js
      // attachElContent: function(html) {
      //   this.el.innerHTML = html;
      //   return this;
      // }
      // ```
      attachElContent: function(html) {
        this.$el.html(html);

        return this;
      },

      // Override the default destroy event to add a few
      // more events that are triggered.
      destroy: function() {
        if (this.isDestroyed) { return; }

        return Marionette.View.prototype.destroy.apply(this, arguments);
      }
    });

    /* jshint maxstatements: 14 */

    // Collection View
    // ---------------

    // A view that iterates over a Backbone.Collection
    // and renders an individual child view for each model.
    Marionette.CollectionView = Marionette.View.extend({

      // used as the prefix for child view events
      // that are forwarded through the collectionview
      childViewEventPrefix: 'childview',

      // constructor
      // option to pass `{sort: false}` to prevent the `CollectionView` from
      // maintaining the sorted order of the collection.
      // This will fallback onto appending childView's to the end.
      constructor: function(options){
        var initOptions = options || {};
        this.sort = _.isUndefined(initOptions.sort) ? true : initOptions.sort;

        this._initChildViewStorage();

        Marionette.View.apply(this, arguments);

        this._initialEvents();
        this.initRenderBuffer();
      },

      // Instead of inserting elements one by one into the page,
      // it's much more performant to insert elements into a document
      // fragment and then insert that document fragment into the page
      initRenderBuffer: function() {
        this.elBuffer = document.createDocumentFragment();
        this._bufferedChildren = [];
      },

      startBuffering: function() {
        this.initRenderBuffer();
        this.isBuffering = true;
      },

      endBuffering: function() {
        this.isBuffering = false;
        this._triggerBeforeShowBufferedChildren();
        this.attachBuffer(this, this.elBuffer);
        this._triggerShowBufferedChildren();
        this.initRenderBuffer();
      },

      _triggerBeforeShowBufferedChildren: function() {
        if (this._isShown) {
          _.invoke(this._bufferedChildren, 'triggerMethod', 'before:show');
        }
      },

      _triggerShowBufferedChildren: function() {
        if (this._isShown) {
          _.each(this._bufferedChildren, function (child) {
            if (_.isFunction(child.triggerMethod)) {
              child.triggerMethod('show');
            } else {
              Marionette.triggerMethod.call(child, 'show');
            }
          });
          this._bufferedChildren = [];
        }
      },

      // Configured the initial events that the collection view
      // binds to.
      _initialEvents: function() {
        if (this.collection) {
          this.listenTo(this.collection, 'add', this._onCollectionAdd);
          this.listenTo(this.collection, 'remove', this._onCollectionRemove);
          this.listenTo(this.collection, 'reset', this.render);

          if (this.sort) {
            this.listenTo(this.collection, 'sort', this._sortViews);
          }
        }
      },

      // Handle a child added to the collection
      _onCollectionAdd: function(child) {
        this.destroyEmptyView();
        var ChildView = this.getChildView(child);
        var index = this.collection.indexOf(child);
        this.addChild(child, ChildView, index);
      },

      // get the child view by model it holds, and remove it
      _onCollectionRemove: function(model) {
        var view = this.children.findByModel(model);
        this.removeChildView(view);
        this.checkEmpty();
      },

      // Override from `Marionette.View` to trigger show on child views
      onShowCalled: function(){
        this.children.each(function(child){
          if (_.isFunction(child.triggerMethod)) {
            child.triggerMethod('show');
          } else {
            Marionette.triggerMethod.call(child, 'show');
          }
        });
      },

      // Render children views. Override this method to
      // provide your own implementation of a render function for
      // the collection view.
      render: function() {
        this._ensureViewIsIntact();
        this.triggerMethod('before:render', this);
        this._renderChildren();
        this.triggerMethod('render', this);
        return this;
      },

      // Render view after sorting. Override this method to
      // change how the view renders after a `sort` on the collection.
      // An example of this would be to only `renderChildren` in a `CompositeView`
      // rather than the full view.
      resortView: function() {
        this.render();
      },

      // Internal method. This checks for any changes in the order of the collection.
      // If the index of any view doesn't match, it will render.
      _sortViews: function() {
        // check for any changes in sort order of views
        var orderChanged = this.collection.find(function(item, index){
          var view = this.children.findByModel(item);
          return !view || view._index !== index;
        }, this);

        if (orderChanged) {
          this.resortView();
        }
      },

      // Internal method. Separated so that CompositeView can have
      // more control over events being triggered, around the rendering
      // process
      _renderChildren: function() {
        this.destroyEmptyView();
        this.destroyChildren();

        if (this.isEmpty(this.collection)) {
          this.showEmptyView();
        } else {
          this.triggerMethod('before:render:collection', this);
          this.startBuffering();
          this.showCollection();
          this.endBuffering();
          this.triggerMethod('render:collection', this);
        }
      },

      // Internal method to loop through collection and show each child view.
      showCollection: function() {
        var ChildView;
        this.collection.each(function(child, index) {
          ChildView = this.getChildView(child);
          this.addChild(child, ChildView, index);
        }, this);
      },

      // Internal method to show an empty view in place of
      // a collection of child views, when the collection is empty
      showEmptyView: function() {
        var EmptyView = this.getEmptyView();

        if (EmptyView && !this._showingEmptyView) {
          this.triggerMethod('before:render:empty');

          this._showingEmptyView = true;
          var model = new Backbone.Model();
          this.addEmptyView(model, EmptyView);

          this.triggerMethod('render:empty');
        }
      },

      // Internal method to destroy an existing emptyView instance
      // if one exists. Called when a collection view has been
      // rendered empty, and then a child is added to the collection.
      destroyEmptyView: function() {
        if (this._showingEmptyView) {
          this.destroyChildren();
          delete this._showingEmptyView;
        }
      },

      // Retrieve the empty view class
      getEmptyView: function() {
        return this.getOption('emptyView');
      },

      // Render and show the emptyView. Similar to addChild method
      // but "child:added" events are not fired, and the event from
      // emptyView are not forwarded
      addEmptyView: function(child, EmptyView){

        // get the emptyViewOptions, falling back to childViewOptions
        var emptyViewOptions = this.getOption('emptyViewOptions') ||
                              this.getOption('childViewOptions');

        if (_.isFunction(emptyViewOptions)){
          emptyViewOptions = emptyViewOptions.call(this);
        }

        // build the empty view
        var view = this.buildChildView(child, EmptyView, emptyViewOptions);

        // trigger the 'before:show' event on `view` if the collection view
        // has already been shown
        if (this._isShown){
          this.triggerMethod.call(view, 'before:show');
        }

        // Store the `emptyView` like a `childView` so we can properly
        // remove and/or close it later
        this.children.add(view);

        // Render it and show it
        this.renderChildView(view, -1);

        // call the 'show' method if the collection view
        // has already been shown
        if (this._isShown){
          this.triggerMethod.call(view, 'show');
        }
      },

      // Retrieve the `childView` class, either from `this.options.childView`
      // or from the `childView` in the object definition. The "options"
      // takes precedence.
      // This method receives the model that will be passed to the instance
      // created from this `childView`. Overriding methods may use the child
      // to determine what `childView` class to return.
      getChildView: function(child) {
        var childView = this.getOption('childView');

        if (!childView) {
          throwError('A "childView" must be specified', 'NoChildViewError');
        }

        return childView;
      },

      // Render the child's view and add it to the
      // HTML for the collection view at a given index.
      // This will also update the indices of later views in the collection
      // in order to keep the children in sync with the collection.
      addChild: function(child, ChildView, index) {
        var childViewOptions = this.getOption('childViewOptions');
        if (_.isFunction(childViewOptions)) {
          childViewOptions = childViewOptions.call(this, child, index);
        }

        var view = this.buildChildView(child, ChildView, childViewOptions);

        // increment indices of views after this one
        this._updateIndices(view, true, index);

        this._addChildView(view, index);

        return view;
      },

      // Internal method. This decrements or increments the indices of views after the
      // added/removed view to keep in sync with the collection.
      _updateIndices: function(view, increment, index) {
        if (!this.sort) {
          return;
        }

        if (increment) {
          // assign the index to the view
          view._index = index;

          // increment the index of views after this one
          this.children.each(function (laterView) {
            if (laterView._index >= view._index) {
              laterView._index++;
            }
          });
        }
        else {
          // decrement the index of views after this one
          this.children.each(function (laterView) {
            if (laterView._index >= view._index) {
              laterView._index--;
            }
          });
        }
      },


      // Internal Method. Add the view to children and render it at
      // the given index.
      _addChildView: function(view, index) {
        // set up the child view event forwarding
        this.proxyChildEvents(view);

        this.triggerMethod('before:add:child', view);

        // Store the child view itself so we can properly
        // remove and/or destroy it later
        this.children.add(view);
        this.renderChildView(view, index);

        if (this._isShown && !this.isBuffering){
          if (_.isFunction(view.triggerMethod)) {
            view.triggerMethod('show');
          } else {
            Marionette.triggerMethod.call(view, 'show');
          }
        }

        this.triggerMethod('add:child', view);
      },

      // render the child view
      renderChildView: function(view, index) {
        view.render();
        this.attachHtml(this, view, index);
        return view;
      },

      // Build a `childView` for a model in the collection.
      buildChildView: function(child, ChildViewClass, childViewOptions) {
        var options = _.extend({model: child}, childViewOptions);
        return new ChildViewClass(options);
      },

      // Remove the child view and destroy it.
      // This function also updates the indices of
      // later views in the collection in order to keep
      // the children in sync with the collection.
      removeChildView: function(view) {

        if (view) {
          this.triggerMethod('before:remove:child', view);
          // call 'destroy' or 'remove', depending on which is found
          if (view.destroy) { view.destroy(); }
          else if (view.remove) { view.remove(); }

          this.stopListening(view);
          this.children.remove(view);
          this.triggerMethod('remove:child', view);

          // decrement the index of views after this one
          this._updateIndices(view, false);
        }

        return view;
      },

      // check if the collection is empty
      isEmpty: function(collection) {
        return !this.collection || this.collection.length === 0;
      },

      // If empty, show the empty view
      checkEmpty: function() {
        if (this.isEmpty(this.collection)) {
          this.showEmptyView();
        }
      },

      // You might need to override this if you've overridden attachHtml
      attachBuffer: function(collectionView, buffer) {
        collectionView.$el.append(buffer);
      },

      // Append the HTML to the collection's `el`.
      // Override this method to do something other
      // than `.append`.
      attachHtml: function(collectionView, childView, index) {
        if (collectionView.isBuffering) {
          // buffering happens on reset events and initial renders
          // in order to reduce the number of inserts into the
          // document, which are expensive.
          collectionView.elBuffer.appendChild(childView.el);
          collectionView._bufferedChildren.push(childView);
        }
        else {
          // If we've already rendered the main collection, append
          // the new child into the correct order if we need to. Otherwise
          // append to the end.
          if (!collectionView._insertBefore(childView, index)){
            collectionView._insertAfter(childView);
          }
        }
      },

      // Internal method. Check whether we need to insert the view into
      // the correct position.
      _insertBefore: function(childView, index) {
        var currentView;
        var findPosition = this.sort && (index < this.children.length - 1);
        if (findPosition) {
          // Find the view after this one
          currentView = this.children.find(function (view) {
            return view._index === index + 1;
          });
        }

        if (currentView) {
          currentView.$el.before(childView.el);
          return true;
        }

        return false;
      },

      // Internal method. Append a view to the end of the $el
      _insertAfter: function(childView) {
        this.$el.append(childView.el);
      },

      // Internal method to set up the `children` object for
      // storing all of the child views
      _initChildViewStorage: function() {
        this.children = new BackboneChildViewContainer();
      },

      // Handle cleanup and other destroying needs for the collection of views
      destroy: function() {
        if (this.isDestroyed) { return; }

        this.triggerMethod('before:destroy:collection');
        this.destroyChildren();
        this.triggerMethod('destroy:collection');

        return Marionette.View.prototype.destroy.apply(this, arguments);
      },

      // Destroy the child views that this collection view
      // is holding on to, if any
      destroyChildren: function() {
        var childViews = this.children.map(_.identity);
        this.children.each(this.removeChildView, this);
        this.checkEmpty();
        return childViews;
      },

      // Set up the child view event forwarding. Uses a "childview:"
      // prefix in front of all forwarded events.
      proxyChildEvents: function(view) {
        var prefix = this.getOption('childViewEventPrefix');

        // Forward all child view events through the parent,
        // prepending "childview:" to the event name
        this.listenTo(view, 'all', function() {
          var args = slice.call(arguments);
          var rootEvent = args[0];
          var childEvents = this.normalizeMethods(_.result(this, 'childEvents'));

          args[0] = prefix + ':' + rootEvent;
          args.splice(1, 0, view);

          // call collectionView childEvent if defined
          if (typeof childEvents !== 'undefined' && _.isFunction(childEvents[rootEvent])) {
            childEvents[rootEvent].apply(this, args.slice(1));
          }

          this.triggerMethod.apply(this, args);
        }, this);
      }
    });

    /* jshint maxstatements: 17, maxlen: 117 */

    // Composite View
    // --------------

    // Used for rendering a branch-leaf, hierarchical structure.
    // Extends directly from CollectionView and also renders an
    // a child view as `modelView`, for the top leaf
    Marionette.CompositeView = Marionette.CollectionView.extend({

      // Setting up the inheritance chain which allows changes to
      // Marionette.CollectionView.prototype.constructor which allows overriding
      // option to pass '{sort: false}' to prevent the CompositeView from
      // maintaining the sorted order of the collection.
      // This will fallback onto appending childView's to the end.
      constructor: function() {
        Marionette.CollectionView.apply(this, arguments);
      },

      // Configured the initial events that the composite view
      // binds to. Override this method to prevent the initial
      // events, or to add your own initial events.
      _initialEvents: function() {

        // Bind only after composite view is rendered to avoid adding child views
        // to nonexistent childViewContainer
        this.once('render', function() {
          if (this.collection) {
            this.listenTo(this.collection, 'add', this._onCollectionAdd);
            this.listenTo(this.collection, 'remove', this._onCollectionRemove);
            this.listenTo(this.collection, 'reset', this._renderChildren);

            if (this.sort) {
              this.listenTo(this.collection, 'sort', this._sortViews);
            }
          }
        });

      },

      // Retrieve the `childView` to be used when rendering each of
      // the items in the collection. The default is to return
      // `this.childView` or Marionette.CompositeView if no `childView`
      // has been defined
      getChildView: function(child) {
        var childView = this.getOption('childView') || this.constructor;

        if (!childView) {
          throwError('A "childView" must be specified', 'NoChildViewError');
        }

        return childView;
      },

      // Serialize the collection for the view.
      // You can override the `serializeData` method in your own view
      // definition, to provide custom serialization for your view's data.
      serializeData: function() {
        var data = {};

        if (this.model){
          data = _.partial(this.serializeModel, this.model).apply(this, arguments);
        }

        return data;
      },

      // Renders the model once, and the collection once. Calling
      // this again will tell the model's view to re-render itself
      // but the collection will not re-render.
      render: function() {
        this._ensureViewIsIntact();
        this.isRendered = true;
        this.resetChildViewContainer();

        this.triggerMethod('before:render', this);

        this._renderTemplate();
        this._renderChildren();

        this.triggerMethod('render', this);
        return this;
      },

      _renderChildren: function() {
        if (this.isRendered) {
          Marionette.CollectionView.prototype._renderChildren.call(this);
        }
      },

      // Render the root template that the children
      // views are appended to
      _renderTemplate: function() {
        var data = {};
        data = this.serializeData();
        data = this.mixinTemplateHelpers(data);

        this.triggerMethod('before:render:template');

        var template = this.getTemplate();
        var html = Marionette.Renderer.render(template, data, this);
        this.attachElContent(html);

        // the ui bindings is done here and not at the end of render since they
        // will not be available until after the model is rendered, but should be
        // available before the collection is rendered.
        this.bindUIElements();
        this.triggerMethod('render:template');
      },

      // Attaches the content of the root.
      // This method can be overriden to optimize rendering,
      // or to render in a non standard way.
      //
      // For example, using `innerHTML` instead of `$el.html`
      //
      // ```js
      // attachElContent: function(html) {
      //   this.el.innerHTML = html;
      //   return this;
      // }
      // ```
      attachElContent: function(html) {
        this.$el.html(html);

        return this;
      },

      // You might need to override this if you've overridden attachHtml
      attachBuffer: function(compositeView, buffer) {
        var $container = this.getChildViewContainer(compositeView);
        $container.append(buffer);
      },

      // Internal method. Append a view to the end of the $el.
      // Overidden from CollectionView to ensure view is appended to
      // childViewContainer
      _insertAfter: function (childView) {
        var $container = this.getChildViewContainer(this);
        $container.append(childView.el);
      },

      // Internal method to ensure an `$childViewContainer` exists, for the
      // `attachHtml` method to use.
      getChildViewContainer: function(containerView) {
        if ('$childViewContainer' in containerView) {
          return containerView.$childViewContainer;
        }

        var container;
        var childViewContainer = Marionette.getOption(containerView, 'childViewContainer');
        if (childViewContainer) {

          var selector = _.isFunction(childViewContainer) ? childViewContainer.call(containerView) : childViewContainer;

          if (selector.charAt(0) === '@' && containerView.ui) {
            container = containerView.ui[selector.substr(4)];
          } else {
            container = containerView.$(selector);
          }

          if (container.length <= 0) {
            throwError('The specified "childViewContainer" was not found: ' +
              containerView.childViewContainer, 'ChildViewContainerMissingError');
          }

        } else {
          container = containerView.$el;
        }

        containerView.$childViewContainer = container;
        return container;
      },

      // Internal method to reset the `$childViewContainer` on render
      resetChildViewContainer: function() {
        if (this.$childViewContainer) {
          delete this.$childViewContainer;
        }
      }
    });

    // LayoutView
    // ----------

    // Used for managing application layoutViews, nested layoutViews and
    // multiple regions within an application or sub-application.
    //
    // A specialized view class that renders an area of HTML and then
    // attaches `Region` instances to the specified `regions`.
    // Used for composite view management and sub-application areas.
    Marionette.LayoutView = Marionette.ItemView.extend({
      regionClass: Marionette.Region,

      // Ensure the regions are available when the `initialize` method
      // is called.
      constructor: function(options) {
        options = options || {};

        this._firstRender = true;
        this._initializeRegions(options);

        Marionette.ItemView.call(this, options);
      },

      // LayoutView's render will use the existing region objects the
      // first time it is called. Subsequent calls will destroy the
      // views that the regions are showing and then reset the `el`
      // for the regions to the newly rendered DOM elements.
      render: function() {
        this._ensureViewIsIntact();

        if (this._firstRender) {
          // if this is the first render, don't do anything to
          // reset the regions
          this._firstRender = false;
        } else {
          // If this is not the first render call, then we need to
          // re-initialize the `el` for each region
          this._reInitializeRegions();
        }

        return Marionette.ItemView.prototype.render.apply(this, arguments);
      },

      // Handle destroying regions, and then destroy the view itself.
      destroy: function() {
        if (this.isDestroyed) { return this; }

        this.regionManager.destroy();
        return Marionette.ItemView.prototype.destroy.apply(this, arguments);
      },

      // Add a single region, by name, to the layoutView
      addRegion: function(name, definition) {
        this.triggerMethod('before:region:add', name);
        var regions = {};
        regions[name] = definition;
        return this._buildRegions(regions)[name];
      },

      // Add multiple regions as a {name: definition, name2: def2} object literal
      addRegions: function(regions) {
        this.regions = _.extend({}, this.regions, regions);
        return this._buildRegions(regions);
      },

      // Remove a single region from the LayoutView, by name
      removeRegion: function(name) {
        this.triggerMethod('before:region:remove', name);
        delete this.regions[name];
        return this.regionManager.removeRegion(name);
      },

      // Provides alternative access to regions
      // Accepts the region name
      // getRegion('main')
      getRegion: function(region) {
        return this.regionManager.get(region);
      },

      // Get all regions
      getRegions: function(){
        return this.regionManager.getRegions();
      },

      // internal method to build regions
      _buildRegions: function(regions) {
        var that = this;

        var defaults = {
          regionClass: this.getOption('regionClass'),
          parentEl: function() { return that.$el; }
        };

        return this.regionManager.addRegions(regions, defaults);
      },

      // Internal method to initialize the regions that have been defined in a
      // `regions` attribute on this layoutView.
      _initializeRegions: function(options) {
        var regions;
        this._initRegionManager();

        if (_.isFunction(this.regions)) {
          regions = this.regions(options);
        } else {
          regions = this.regions || {};
        }

        // Enable users to define `regions` as instance options.
        var regionOptions = this.getOption.call(options, 'regions');

        // enable region options to be a function
        if (_.isFunction(regionOptions)) {
          regionOptions = regionOptions.call(this, options);
        }

        _.extend(regions, regionOptions);

        this.addRegions(regions);
      },

      // Internal method to re-initialize all of the regions by updating the `el` that
      // they point to
      _reInitializeRegions: function() {
        this.regionManager.emptyRegions();
        this.regionManager.each(function(region) {
          region.reset();
        });
      },

      // Enable easy overiding of the default `RegionManager`
      // for customized region interactions and buisness specific
      // view logic for better control over single regions.
      getRegionManager: function() {
        return new Marionette.RegionManager();
      },

      // Internal method to initialize the region manager
      // and all regions in it
      _initRegionManager: function() {
        this.regionManager = this.getRegionManager();

        this.listenTo(this.regionManager, 'before:add:region', function(name) {
          this.triggerMethod('before:add:region', name);
        });

        this.listenTo(this.regionManager, 'add:region', function(name, region) {
          this[name] = region;
          this.triggerMethod('add:region', name, region);
        });

        this.listenTo(this.regionManager, 'before:remove:region', function(name) {
          this.triggerMethod('before:remove:region', name);
        });

        this.listenTo(this.regionManager, 'remove:region', function(name, region) {
          delete this[name];
          this.triggerMethod('remove:region', name, region);
        });
      }
    });


    // Behavior
    // -----------

    // A Behavior is an isolated set of DOM /
    // user interactions that can be mixed into any View.
    // Behaviors allow you to blackbox View specific interactions
    // into portable logical chunks, keeping your views simple and your code DRY.

    Marionette.Behavior = (function(_, Backbone) {
      function Behavior(options, view) {
        // Setup reference to the view.
        // this comes in handle when a behavior
        // wants to directly talk up the chain
        // to the view.
        this.view = view;
        this.defaults = _.result(this, 'defaults') || {};
        this.options  = _.extend({}, this.defaults, options);

        // proxy behavior $ method to the view
        // this is useful for doing jquery DOM lookups
        // scoped to behaviors view.
        this.$ = function() {
          return this.view.$.apply(this.view, arguments);
        };

        // Call the initialize method passing
        // the arguments from the instance constructor
        this.initialize.apply(this, arguments);
      }

      _.extend(Behavior.prototype, Backbone.Events, {
        initialize: function() {},

        // stopListening to behavior `onListen` events.
        destroy: function() {
          this.stopListening();
        },

        // import the `triggerMethod` to trigger events with corresponding
        // methods if the method exists
        triggerMethod: Marionette.triggerMethod,

        // Proxy `getOption` to enable getting options from this or this.options by name.
        getOption: Marionette.proxyGetOption,

        // Proxy `unbindEntityEvents` to enable binding view's events from another entity.
        bindEntityEvents: Marionette.proxyBindEntityEvents,

        // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
        unbindEntityEvents: Marionette.proxyUnbindEntityEvents
      });

      // Borrow Backbones extend implementation
      // this allows us to setup a proper
      // inheritence pattern that follow in suite
      // with the rest of Marionette views.
      Behavior.extend = Marionette.extend;

      return Behavior;
    })(_, Backbone);

    /* jshint maxlen: 143, nonew: false */
    // Marionette.Behaviors
    // --------

    // Behaviors is a utility class that takes care of
    // glueing your behavior instances to their given View.
    // The most important part of this class is that you
    // **MUST** override the class level behaviorsLookup
    // method for things to work properly.

    Marionette.Behaviors = (function(Marionette, _) {

      function Behaviors(view, behaviors) {
        // Behaviors defined on a view can be a flat object literal
        // or it can be a function that returns an object.
        behaviors = Behaviors.parseBehaviors(view, behaviors || _.result(view, 'behaviors'));

        // Wraps several of the view's methods
        // calling the methods first on each behavior
        // and then eventually calling the method on the view.
        Behaviors.wrap(view, behaviors, _.keys(methods));
      }

      var methods = {
        setElement: function(setElement, behaviors) {
          setElement.apply(this, _.tail(arguments, 2));

          // proxy behavior $el to the view's $el.
          // This is needed because a view's $el proxy
          // is not set until after setElement is called.
          _.each(behaviors, function(b) {
            b.$el = this.$el;
            b.el = this.el;
          }, this);

          return this;
        },

        destroy: function(destroy, behaviors) {
          var args = _.tail(arguments, 2);
          destroy.apply(this, args);

          // Call destroy on each behavior after
          // destroying the view.
          // This unbinds event listeners
          // that behaviors have registerd for.
          _.invoke(behaviors, 'destroy', args);
          return this;
        },

        bindUIElements: function(bindUIElements, behaviors) {
          bindUIElements.apply(this);
          _.invoke(behaviors, bindUIElements);
        },

        unbindUIElements: function(unbindUIElements, behaviors) {
          unbindUIElements.apply(this);
          _.invoke(behaviors, unbindUIElements);
        },

        triggerMethod: function(triggerMethod, behaviors) {
          var args = _.tail(arguments, 2);
          triggerMethod.apply(this, args);

          _.each(behaviors, function(b) {
            triggerMethod.apply(b, args);
          });
        },

        delegateEvents: function(delegateEvents, behaviors) {
          var args = _.tail(arguments, 2);
          delegateEvents.apply(this, args);

          _.each(behaviors, function(b) {
            Marionette.bindEntityEvents(b, this.model, Marionette.getOption(b, 'modelEvents'));
            Marionette.bindEntityEvents(b, this.collection, Marionette.getOption(b, 'collectionEvents'));
          }, this);

          return this;
        },

        undelegateEvents: function(undelegateEvents, behaviors) {
          var args = _.tail(arguments, 2);
          undelegateEvents.apply(this, args);

          _.each(behaviors, function(b) {
            Marionette.unbindEntityEvents(b, this.model, Marionette.getOption(b, 'modelEvents'));
            Marionette.unbindEntityEvents(b, this.collection, Marionette.getOption(b, 'collectionEvents'));
          }, this);

          return this;
        },

        behaviorEvents: function(behaviorEvents, behaviors) {
          var _behaviorsEvents = {};
          var viewUI = _.result(this, 'ui');

          _.each(behaviors, function(b, i) {
            var _events = {};
            var behaviorEvents = _.clone(_.result(b, 'events')) || {};
            var behaviorUI = _.result(b, 'ui');

            // Construct an internal UI hash first using
            // the views UI hash and then the behaviors UI hash.
            // This allows the user to use UI hash elements
            // defined in the parent view as well as those
            // defined in the given behavior.
            var ui = _.extend({}, viewUI, behaviorUI);

            // Normalize behavior events hash to allow
            // a user to use the @ui. syntax.
            behaviorEvents = Marionette.normalizeUIKeys(behaviorEvents, ui);

            _.each(_.keys(behaviorEvents), function(key) {
              // Append white-space at the end of each key to prevent behavior key collisions.
              // This is relying on the fact that backbone events considers "click .foo" the same as
              // "click .foo ".

              // +2 is used because new Array(1) or 0 is "" and not " "
              var whitespace = (new Array(i + 2)).join(' ');
              var eventKey   = key + whitespace;
              var handler    = _.isFunction(behaviorEvents[key]) ? behaviorEvents[key] : b[behaviorEvents[key]];

              _events[eventKey] = _.bind(handler, b);
            });

            _behaviorsEvents = _.extend(_behaviorsEvents, _events);
          });

          return _behaviorsEvents;
        }
      };

      _.extend(Behaviors, {

        // Placeholder method to be extended by the user.
        // The method should define the object that stores the behaviors.
        // i.e.
        //
        // ```js
        // Marionette.Behaviors.behaviorsLookup: function() {
        //   return App.Behaviors
        // }
        // ```
        behaviorsLookup: function() {
          throw new Error('You must define where your behaviors are stored.' +
            'See https://github.com/marionettejs/backbone.marionette' +
            '/blob/master/docs/marionette.behaviors.md#behaviorslookup');
        },

        // Takes care of getting the behavior class
        // given options and a key.
        // If a user passes in options.behaviorClass
        // default to using that. Otherwise delegate
        // the lookup to the users `behaviorsLookup` implementation.
        getBehaviorClass: function(options, key) {
          if (options.behaviorClass) {
            return options.behaviorClass;
          }

          // Get behavior class can be either a flat object or a method
          return _.isFunction(Behaviors.behaviorsLookup) ? Behaviors.behaviorsLookup.apply(this, arguments)[key] : Behaviors.behaviorsLookup[key];
        },

        // Iterate over the behaviors object, for each behavior
        // instantiate it and get its grouped behaviors.
        parseBehaviors: function(view, behaviors) {
          return _.chain(behaviors).map(function(options, key) {
            var BehaviorClass = Behaviors.getBehaviorClass(options, key);

            var behavior = new BehaviorClass(options, view);
            var nestedBehaviors = Behaviors.parseBehaviors(view, _.result(behavior, 'behaviors'));

            return [behavior].concat(nestedBehaviors);
          }).flatten().value();
        },

        // Wrap view internal methods so that they delegate to behaviors. For example,
        // `onDestroy` should trigger destroy on all of the behaviors and then destroy itself.
        // i.e.
        //
        // `view.delegateEvents = _.partial(methods.delegateEvents, view.delegateEvents, behaviors);`
        wrap: function(view, behaviors, methodNames) {
          _.each(methodNames, function(methodName) {
            view[methodName] = _.partial(methods[methodName], view[methodName], behaviors);
          });
        }
      });

      return Behaviors;

    })(Marionette, _);


    // AppRouter
    // ---------

    // Reduce the boilerplate code of handling route events
    // and then calling a single method on another object.
    // Have your routers configured to call the method on
    // your object, directly.
    //
    // Configure an AppRouter with `appRoutes`.
    //
    // App routers can only take one `controller` object.
    // It is recommended that you divide your controller
    // objects in to smaller pieces of related functionality
    // and have multiple routers / controllers, instead of
    // just one giant router and controller.
    //
    // You can also add standard routes to an AppRouter.

    Marionette.AppRouter = Backbone.Router.extend({

      constructor: function(options) {
        Backbone.Router.apply(this, arguments);

        this.options = options || {};

        var appRoutes = this.getOption('appRoutes');
        var controller = this._getController();
        this.processAppRoutes(controller, appRoutes);
        this.on('route', this._processOnRoute, this);
      },

      // Similar to route method on a Backbone Router but
      // method is called on the controller
      appRoute: function(route, methodName) {
        var controller = this._getController();
        this._addAppRoute(controller, route, methodName);
      },

      // process the route event and trigger the onRoute
      // method call, if it exists
      _processOnRoute: function(routeName, routeArgs) {
        // find the path that matched
        var routePath = _.invert(this.getOption('appRoutes'))[routeName];

        // make sure an onRoute is there, and call it
        if (_.isFunction(this.onRoute)) {
          this.onRoute(routeName, routePath, routeArgs);
        }
      },

      // Internal method to process the `appRoutes` for the
      // router, and turn them in to routes that trigger the
      // specified method on the specified `controller`.
      processAppRoutes: function(controller, appRoutes) {
        if (!appRoutes) { return; }

        var routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes

        _.each(routeNames, function(route) {
          this._addAppRoute(controller, route, appRoutes[route]);
        }, this);
      },

      _getController: function() {
        return this.getOption('controller');
      },

      _addAppRoute: function(controller, route, methodName) {
        var method = controller[methodName];

        if (!method) {
          throwError('Method "' + methodName + '" was not found on the controller');
        }

        this.route(route, methodName, _.bind(method, controller));
      },

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption
    });

    // Application
    // -----------

    // Contain and manage the composite application as a whole.
    // Stores and starts up `Region` objects, includes an
    // event aggregator as `app.vent`
    Marionette.Application = function(options) {
      this._initializeRegions(options);
      this._initCallbacks = new Marionette.Callbacks();
      this.submodules = {};
      _.extend(this, options);
      this._initChannel();
    };

    _.extend(Marionette.Application.prototype, Backbone.Events, {
      // Command execution, facilitated by Backbone.Wreqr.Commands
      execute: function() {
        this.commands.execute.apply(this.commands, arguments);
      },

      // Request/response, facilitated by Backbone.Wreqr.RequestResponse
      request: function() {
        return this.reqres.request.apply(this.reqres, arguments);
      },

      // Add an initializer that is either run at when the `start`
      // method is called, or run immediately if added after `start`
      // has already been called.
      addInitializer: function(initializer) {
        this._initCallbacks.add(initializer);
      },

      // kick off all of the application's processes.
      // initializes all of the regions that have been added
      // to the app, and runs all of the initializer functions
      start: function(options) {
        this.triggerMethod('before:start', options);
        this._initCallbacks.run(options, this);
        this.triggerMethod('start', options);
      },

      // Add regions to your app.
      // Accepts a hash of named strings or Region objects
      // addRegions({something: "#someRegion"})
      // addRegions({something: Region.extend({el: "#someRegion"}) });
      addRegions: function(regions) {
        return this._regionManager.addRegions(regions);
      },

      // Empty all regions in the app, without removing them
      emptyRegions: function() {
        return this._regionManager.emptyRegions();
      },

      // Removes a region from your app, by name
      // Accepts the regions name
      // removeRegion('myRegion')
      removeRegion: function(region) {
        return this._regionManager.removeRegion(region);
      },

      // Provides alternative access to regions
      // Accepts the region name
      // getRegion('main')
      getRegion: function(region) {
        return this._regionManager.get(region);
      },

      // Get all the regions from the region manager
      getRegions: function(){
        return this._regionManager.getRegions();
      },

      // Create a module, attached to the application
      module: function(moduleNames, moduleDefinition) {

        // Overwrite the module class if the user specifies one
        var ModuleClass = Marionette.Module.getClass(moduleDefinition);

        // slice the args, and add this application object as the
        // first argument of the array
        var args = slice.call(arguments);
        args.unshift(this);

        // see the Marionette.Module object for more information
        return ModuleClass.create.apply(ModuleClass, args);
      },

      // Enable easy overriding of the default `RegionManager`
      // for customized region interactions and business-specific
      // view logic for better control over single regions.
      getRegionManager: function() {
        return new Marionette.RegionManager();
      },

      // Internal method to initialize the regions that have been defined in a
      // `regions` attribute on the application instance
      _initializeRegions: function(options) {
        var regions = _.isFunction(this.regions) ? this.regions(options) : this.regions || {};

        this._initRegionManager();

        // Enable users to define `regions` in instance options.
        var optionRegions = Marionette.getOption(options, 'regions');

        // Enable region options to be a function
        if (_.isFunction(optionRegions)) {
          optionRegions = optionRegions.call(this, options);
        }

        // Overwrite current regions with those passed in options
        _.extend(regions, optionRegions);

        this.addRegions(regions);

        return this;
      },

      // Internal method to set up the region manager
      _initRegionManager: function() {
        this._regionManager = this.getRegionManager();

        this.listenTo(this._regionManager, 'before:add:region', function(name) {
          this.triggerMethod('before:add:region', name);
        });

        this.listenTo(this._regionManager, 'add:region', function(name, region) {
          this[name] = region;
          this.triggerMethod('add:region', name, region);
        });

        this.listenTo(this._regionManager, 'before:remove:region', function(name) {
          this.triggerMethod('before:remove:region', name);
        });

        this.listenTo(this._regionManager, 'remove:region', function(name, region) {
          delete this[name];
          this.triggerMethod('remove:region', name, region);
        });
      },

      // Internal method to setup the Wreqr.radio channel
      _initChannel: function() {
        this.channelName = _.result(this, 'channelName') || 'global';
        this.channel = _.result(this, 'channel') || BackboneWreqr.radio.channel(this.channelName);
        this.vent = _.result(this, 'vent') || this.channel.vent;
        this.commands = _.result(this, 'commands') || this.channel.commands;
        this.reqres = _.result(this, 'reqres') || this.channel.reqres;
      },

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod,

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption
    });

    // Copy the `extend` function used by Backbone's classes
    Marionette.Application.extend = Marionette.extend;

    /* jshint maxparams: 9 */

    // Module
    // ------

    // A simple module system, used to create privacy and encapsulation in
    // Marionette applications
    Marionette.Module = function(moduleName, app, options) {
      this.moduleName = moduleName;
      this.options = _.extend({}, this.options, options);
      // Allow for a user to overide the initialize
      // for a given module instance.
      this.initialize = options.initialize || this.initialize;

      // Set up an internal store for sub-modules.
      this.submodules = {};

      this._setupInitializersAndFinalizers();

      // Set an internal reference to the app
      // within a module.
      this.app = app;

      // By default modules start with their parents.
      this.startWithParent = true;

      if (_.isFunction(this.initialize)) {
        this.initialize(moduleName, app, this.options);
      }
    };

    Marionette.Module.extend = Marionette.extend;

    // Extend the Module prototype with events / listenTo, so that the module
    // can be used as an event aggregator or pub/sub.
    _.extend(Marionette.Module.prototype, Backbone.Events, {

      // Initialize is an empty function by default. Override it with your own
      // initialization logic when extending Marionette.Module.
      initialize: function() {},

      // Initializer for a specific module. Initializers are run when the
      // module's `start` method is called.
      addInitializer: function(callback) {
        this._initializerCallbacks.add(callback);
      },

      // Finalizers are run when a module is stopped. They are used to teardown
      // and finalize any variables, references, events and other code that the
      // module had set up.
      addFinalizer: function(callback) {
        this._finalizerCallbacks.add(callback);
      },

      // Start the module, and run all of its initializers
      start: function(options) {
        // Prevent re-starting a module that is already started
        if (this._isInitialized) { return; }

        // start the sub-modules (depth-first hierarchy)
        _.each(this.submodules, function(mod) {
          // check to see if we should start the sub-module with this parent
          if (mod.startWithParent) {
            mod.start(options);
          }
        });

        // run the callbacks to "start" the current module
        this.triggerMethod('before:start', options);

        this._initializerCallbacks.run(options, this);
        this._isInitialized = true;

        this.triggerMethod('start', options);
      },

      // Stop this module by running its finalizers and then stop all of
      // the sub-modules for this module
      stop: function() {
        // if we are not initialized, don't bother finalizing
        if (!this._isInitialized) { return; }
        this._isInitialized = false;

        this.triggerMethod('before:stop');

        // stop the sub-modules; depth-first, to make sure the
        // sub-modules are stopped / finalized before parents
        _.each(this.submodules, function(mod) { mod.stop(); });

        // run the finalizers
        this._finalizerCallbacks.run(undefined, this);

        // reset the initializers and finalizers
        this._initializerCallbacks.reset();
        this._finalizerCallbacks.reset();

        this.triggerMethod('stop');
      },

      // Configure the module with a definition function and any custom args
      // that are to be passed in to the definition function
      addDefinition: function(moduleDefinition, customArgs) {
        this._runModuleDefinition(moduleDefinition, customArgs);
      },

      // Internal method: run the module definition function with the correct
      // arguments
      _runModuleDefinition: function(definition, customArgs) {
        // If there is no definition short circut the method.
        if (!definition) { return; }

        // build the correct list of arguments for the module definition
        var args = _.flatten([
          this,
          this.app,
          Backbone,
          Marionette,
          Backbone.$, _,
          customArgs
        ]);

        definition.apply(this, args);
      },

      // Internal method: set up new copies of initializers and finalizers.
      // Calling this method will wipe out all existing initializers and
      // finalizers.
      _setupInitializersAndFinalizers: function() {
        this._initializerCallbacks = new Marionette.Callbacks();
        this._finalizerCallbacks = new Marionette.Callbacks();
      },

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod
    });

    // Class methods to create modules
    _.extend(Marionette.Module, {

      // Create a module, hanging off the app parameter as the parent object.
      create: function(app, moduleNames, moduleDefinition) {
        var module = app;

        // get the custom args passed in after the module definition and
        // get rid of the module name and definition function
        var customArgs = slice.call(arguments);
        customArgs.splice(0, 3);

        // Split the module names and get the number of submodules.
        // i.e. an example module name of `Doge.Wow.Amaze` would
        // then have the potential for 3 module definitions.
        moduleNames = moduleNames.split('.');
        var length = moduleNames.length;

        // store the module definition for the last module in the chain
        var moduleDefinitions = [];
        moduleDefinitions[length - 1] = moduleDefinition;

        // Loop through all the parts of the module definition
        _.each(moduleNames, function(moduleName, i) {
          var parentModule = module;
          module = this._getModule(parentModule, moduleName, app, moduleDefinition);
          this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs);
        }, this);

        // Return the last module in the definition chain
        return module;
      },

      _getModule: function(parentModule, moduleName, app, def, args) {
        var options = _.extend({}, def);
        var ModuleClass = this.getClass(def);

        // Get an existing module of this name if we have one
        var module = parentModule[moduleName];

        if (!module) {
          // Create a new module if we don't have one
          module = new ModuleClass(moduleName, app, options);
          parentModule[moduleName] = module;
          // store the module on the parent
          parentModule.submodules[moduleName] = module;
        }

        return module;
      },

      // ## Module Classes
      //
      // Module classes can be used as an alternative to the define pattern.
      // The extend function of a Module is identical to the extend functions
      // on other Backbone and Marionette classes.
      // This allows module lifecyle events like `onStart` and `onStop` to be called directly.
      getClass: function(moduleDefinition) {
        var ModuleClass = Marionette.Module;

        if (!moduleDefinition) {
          return ModuleClass;
        }

        // If all of the module's functionality is defined inside its class,
        // then the class can be passed in directly. `MyApp.module("Foo", FooModule)`.
        if (moduleDefinition.prototype instanceof ModuleClass) {
          return moduleDefinition;
        }

        return moduleDefinition.moduleClass || ModuleClass;
      },

      // Add the module definition and add a startWithParent initializer function.
      // This is complicated because module definitions are heavily overloaded
      // and support an anonymous function, module class, or options object
      _addModuleDefinition: function(parentModule, module, def, args) {
        var fn = this._getDefine(def);
        var startWithParent = this._getStartWithParent(def, module);

        if (fn) {
          module.addDefinition(fn, args);
        }

        this._addStartWithParent(parentModule, module, startWithParent);
      },

      _getStartWithParent: function(def, module) {
        var swp;

        if (_.isFunction(def) && (def.prototype instanceof Marionette.Module)) {
          swp = module.constructor.prototype.startWithParent;
          return _.isUndefined(swp) ? true : swp;
        }

        if (_.isObject(def)) {
          swp = def.startWithParent;
          return _.isUndefined(swp) ? true : swp;
        }

        return true;
      },

      _getDefine: function(def) {
        if (_.isFunction(def) && !(def.prototype instanceof Marionette.Module)) {
          return def;
        }

        if (_.isObject(def)) {
          return def.define;
        }

        return null;
      },

      _addStartWithParent: function(parentModule, module, startWithParent) {
        module.startWithParent = module.startWithParent && startWithParent;

        if (!module.startWithParent || !!module.startWithParentIsConfigured) {
          return;
        }

        module.startWithParentIsConfigured = true;

        parentModule.addInitializer(function(options) {
          if (module.startWithParent) {
            module.start(options);
          }
        });
      }
    });


    return Marionette;
  }));

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:marionette', location = '/sidebar/lib/backbone.marionette.adapter.js' */
define("jira/projects/libs/marionette", [
    "backbone",
    "underscore",
    "atlassian/libs/factories/marionette-2.1.0"
], function(Backbone, _, marionetteFactory) {
    "use strict";
    return marionetteFactory(_, Backbone);
});

AJS.namespace("JIRA.Projects.Libs.Marionette", null, require("jira/projects/libs/marionette"));
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:marionette', location = '/sidebar/lib/backbone.marionette.mixins.js' */
(function(){
    "use strict";

    /**
     * Triggers a preventable event.
     *
     * The event will include an EventObject, and the handler can call eventObject.preventDefault() to prevent the event.
     *
     * @param {string} eventName Name of the event being triggered.
     * @param {EventObject} [eventObject] EventObject used as template to construct the actual EventObject used in the event.
     *
     * @returns {EventObject} EventObject passed to the event.
     */
    function triggerPreventable(eventName, eventObject) {
        var instance = this;
        /**
         * EventObject passed to preventable events
         * @typedef {Object} EventObject
         * @property {Object} emitter Original emitter of the event.
         * @property {boolean} isPrevented Whether the event has been prevented by the event handler.
         * @property {Function} preventDefault Syntax sugar for set the `isPrevented` value.
         */
        var event = _.defaults({}, eventObject || {}, {
            isPrevented: false,
            emitter: this,
            preventDefault: function () {
                this.isPrevented = true;
                instance.trigger(eventName + ":prevented", this);
            }
        });

        this.trigger(eventName, event);
        return event;
    }

    function retriggerPreventable(eventName, eventObject) {
        var groupEvent = this.triggerPreventable(eventName, eventObject);
        if (groupEvent.isPrevented) {
            eventObject.preventDefault();
        }
    }

    _.extend(JIRA.Projects.Libs.Marionette.View.prototype, {
        /**
         * This method unwraps the Backbone.View.
         *
         * By default, Backbone will create a <div> and render the template inside. By calling this
         * method, you can get rid of that <div>, so the main element in your template will be the
         * root element in your template.
         */
        unwrapTemplate: function unwrapTemplate() {
            if (this.$el.parent().length) {
                // If the template is already rendered in the page
                var children = this.$el.children();
                this.$el.replaceWith(children);
                this.setElement(children);
            } else {
                // If the template is in memory
                this.setElement(this.$el.children());
            }
        },
        triggerPreventable: triggerPreventable,
        retriggerPreventable: retriggerPreventable
    });

    _.extend(JIRA.Projects.Libs.Marionette.Controller.prototype, {
        triggerPreventable: triggerPreventable,
        retriggerPreventable: retriggerPreventable
    });

    JIRA.Projects.Libs.Marionette.ViewManager = JIRA.Projects.Libs.Marionette.Controller.extend({
        constructor: function() {
            JIRA.Projects.Libs.Marionette.Controller.apply(this, arguments);
            this.views={};
        },

        hideView: function(viewName) {
            var view = this.views[viewName];
            if (view) {
                this.stopListening(view);
                if (!view.isDestroyed) {
                    view.destroy();
                }
                delete this.views[viewName];
            }
        },

        showView: function(viewName, factory) {
            var view = this.buildView(viewName, factory);
            view.render();
        },

        buildView: function(viewName, factory) {
            var view = this.views[viewName];
            if (!view) {
                view = factory.call(this);
                this.listenTo(view, "destroy", function() {
                    this.hideView(viewName);
                });
                this.views[viewName] = view;
            }
            return view;
        },

        getView: function(viewName) {
            return this.views[viewName];
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:data', location = 'data/web-resource-manager.js' */
define('jira/projects/data/WRM', window.WRM);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-component', location = '/sidebar/component/component.js' */
define('jira/projects/sidebar/component',
    ['jira/projects/data/WRM'],
    function(WRM) {
        'use strict';

        var isGlobalSidebar = Boolean(WRM.data.claim('is-global-sidebar'));

        return JIRA.Projects.Libs.Marionette.CompositeView.extend({
            childEvents: {
                'before:select': function(item, itemEvent) {
                    if (!this.hasASelectedItem()) {
                        itemEvent.isInitial = true;
                    }
                    this.retriggerPreventable('before:select', itemEvent);
                    if (!itemEvent.isPrevented) {
                        this.deselectAllGroups();
                    }
                },
                'select': function(child, ev) {
                    this.trigger('select', ev);
                },
                'before:deselect': function(item, itemEvent) {
                    this.retriggerPreventable('before:deselect', itemEvent);
                },
                'deselect': function(child, ev) {
                    this.trigger('deselect', ev);
                },
                'before:navigate': function(item, itemEvent) {
                    this.retriggerPreventable('before:navigate', itemEvent);
                },
                "before:navigate:prevented": function(item, itemEvent) {
                    this.trigger("before:navigate:prevented", itemEvent);
                }
            },

            initialize: function() {
                this.$('.aui-sidebar-group').each(_.bind(function(index, sidebarGroup) {
                    var navigationGroup = new JIRA.Projects.Sidebar.Component.NavigationGroup({
                        el: sidebarGroup
                    });
                    var alreadyExists = !!this.getGroup(navigationGroup.id);
                    if (alreadyExists && AJS.warn) {
                        AJS.warn('Duplicated IDs detected. There are more than one NavigationGroup with id data-id="' + navigationGroup.id + '"');
                    }

                    this.proxyChildEvents(navigationGroup);
                    this.children.add(navigationGroup, navigationGroup.id);
                }, this));
            },

            deselectAllGroups: function() {
                this.children.call('deselect');
            },

            replaceGroup: function(groupname, newGroup) {
                var oldGroup = this.getGroup(groupname);

                // Replace the DOM
                oldGroup.$el.replaceWith(newGroup.$el);

                // Replace the group in the internal list of groups. As we don't have a
                // replace method there, we need to remove the old group and add the new one
                // using the same `cid` to try to preserve the ordering.
                newGroup.cid = oldGroup.cid;
                this.children.remove(oldGroup);
                this.children.add(newGroup, newGroup.id);
            },

            getGroup: function(id) {
                return this.children.findByCustom(id);
            },

            getGroupAt: function(index) {
                return this.children.findByIndex(index);
            },

            getItem: function(id) {
                return this.getDefaultGroup().getItem(id);
            },

            /**
             * Returns HTML element representing sidebar.
             *
             * @returns {HTMLElement} HTML element representing sidebar.
             */
            getElement: function() {
                return this.el;
            },

            getDefaultGroup: function() {
                return this.getGroup('sidebar-navigation-panel');
            },

            isProjectSidebar: function() {
                return !isGlobalSidebar;
            },

            getSelectedScopeFilterId: function() {
                return this.$('.scope-filter a.scope-filter-trigger').attr('data-scope-filter-id');
            },

            setReportsItemLink: function(reportUrl) {
                var sidebarNavigationPanel = this.getGroup('sidebar-navigation-panel');

                // by default, tries to retrieve the project-centric link
                var reportLink = sidebarNavigationPanel.getItem('com.atlassian.jira.jira-projects-plugin:report-page');
                // in case it is not there (global board sidebar), let's get the one provided by Agile
                if (typeof reportLink === 'undefined') {
                    reportLink = sidebarNavigationPanel.getItem('com.pyxis.greenhopper.jira:global-sidebar-report');
                }

                if (reportLink) {
                    reportLink.ui.link.attr('href', reportUrl);
                }
            },

            getAUISidebar: function() {
                return AJS.sidebar('.aui-sidebar');
            },

            getContentContainer: function() {
                return this.$('.aui-sidebar-body .sidebar-content-container');
            },

            getSelectedNavigationItem: function() {
                return this.getDefaultGroup().getSelectedNavigationItem();
            },

            hasASelectedItem: function() {
                return this.getDefaultGroup().hasASelectedItem();
            }
        });
    });

AJS.namespace('JIRA.Projects.Sidebar.Component', null, require('jira/projects/sidebar/component'));;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-component', location = '/sidebar/component/navigation-item.js' */
(function () {
    "use strict";

    /** @namespace JIRA */
    /** @namespace JIRA.Projects */
    /** @namespace JIRA.Projects.Sidebar */
    /** @namespace JIRA.Projects.Sidebar.Component */
    AJS.namespace("JIRA.Projects.Sidebar.Component.NavigationItem");

    JIRA.Projects.Sidebar.Component.NavigationItem = JIRA.Projects.Libs.Marionette.CompositeView.extend(/** @lends JIRA.Projects.Sidebar.Component.NavigationItem# */{
        /**
         * @event JIRA.Projects.Sidebar.Component.NavigationItem#before:select
         * @type {EventObject}
         */

        /**
         * @event JIRA.Projects.Sidebar.Component.NavigationItem#select
         * @type {EventObject}
         */

        /**
         * @event JIRA.Projects.Sidebar.Component.NavigationItem#before:navigate
         * @type {EventObject}
         */

        /**
         * @event JIRA.Projects.Sidebar.Component.NavigationItem#before:deselect
         * @type {EventObject}
         */

        /**
         * @event JIRA.Projects.Sidebar.Component.NavigationItem#deselect
         * @type {EventObject}
         */

        ui: {
            link: "a.aui-nav-item"
        },

        events: {
            'simpleClick @ui.link:not([target="_blank"])': function (ev) {
                ev.preventDefault();
                this.navigate();
            }
        },

        /**
         * @classdesc Represents an individual item in a navigation group.
         *
         * @constructs
         * @extends JIRA.Projects.Libs.Marionette.CompositeView
         */
        initialize: function () {
            // Capture the ID of this item (if any).
            this.id = this.$el.find(">a").attr("data-link-id");

            // Ensure the `ui` and `events` hashes work as expected.
            this.bindUIElements();
        },

        /**
         * Returns HTML element representing sidebar item.
         *
         * @returns {HTMLElement} HTML element representing sidebar item.
         */
        getElement: function() {
            return this.el;
        },

        /**
         * Navigates to the URL specified in the item's href.
         *
         * This method will trigger the preventable event 'before:navigate'. If it is prevented,
         * no navigation will occur.
         *
         * @fires JIRA.Projects.Sidebar.Component.NavigationItem#before:navigate
         *
         * @returns {boolean} False if before:select were prevented, true otherwise.
         */
        navigate: function () {
            // Select the element first, so the consumer has an opportunity to prevent
            // before:select and/or before:deselect
            if (!this.select()) {
                return
            }

            // Trigger before:navigate
            var navigateEvent = this.triggerPreventable("before:navigate");
            if (navigateEvent.isPrevented) {
                return false;
            }

            // Navigate to HREF
            var href = this.ui.link.attr("href");
            if (href) {
                require('jira/util/browser').reloadViaWindowLocation(href);
            }

            return true;
        },

        /**
         * Selects the item.
         *
         * This method will throw two events, in this order:
         *
         *   * before:select (preventable)
         *   * select
         *
         * If the event 'before:select' is prevented, the element is not selected and the current selected item is not
         * deselected .
         *
         * @fires JIRA.Projects.Sidebar.Component.NavigationItem#before:select
         * @fires JIRA.Projects.Sidebar.Component.NavigationItem#select
         *
         * @returns {boolean} False if before:select were prevented, true otherwise.
         */
        select: function () {
            var selectEvent = this.triggerPreventable("before:select");
            if (selectEvent.isPrevented) {
                return false;
            }

            // Main operation
            this.$el.addClass("aui-nav-selected");

            // Trigger select
            this.trigger("select", selectEvent);

            return true;
        },

        /**
         * Deselects the item.
         *
         * This method will throw two events, in this order:
         *
         *   * before:deselect (preventable)
         *   * deselect
         *
         * If the event 'before:deselect' is prevented, the element is not deselected.
         *
         * @fires JIRA.Projects.Sidebar.Component.NavigationItem#before:deselect
         * @fires JIRA.Projects.Sidebar.Component.NavigationItem#deselect
         *
         * @returns {boolean} False if before:deselect was prevented, true otherwise.
         */
        deselect: function () {
            if (!this.isSelected()) {
                return true;
            }

            var event = this.triggerPreventable("before:deselect");
            if (event.isPrevented) {
                return false;
            }

            this.$el.removeClass("aui-nav-selected");
            this.$el.find('a').blur();
            this.trigger("deselect", event);
            return true;
        },

        /**
         * Checks if the element is selected.
         *
         * @returns {Boolean} Whether the element is selected.
         */
        isSelected: function () {
            return this.$el.hasClass("aui-nav-selected");
        },

        /**
         * Removes the badge of this navigation item
         */
        removeBadge: function() {
            this.$el.find('.aui-badge').remove();
        },

        getId: function() {
            return this.id;
        },

        getSelectedNavigationItem: function() {
            if (this.isSelected()) {
                return this;
            }
        },

        hasASelectedItem: function() {
            return this.isSelected();
        }
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-component', location = '/sidebar/component/navigation-group.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.Component.NavigationGroup");

    JIRA.Projects.Sidebar.Component.NavigationGroup = JIRA.Projects.Libs.Marionette.CompositeView.extend({
        childEvents: {
            "before:select": function (item, itemEvent) {
                this.retriggerPreventable("before:select", itemEvent);
                if (itemEvent.isPrevented) {
                    return;
                }

                // Deselect all the items. If they can't be deselected (i.e. someone prevented the before:deselect
                // event), force the before:select event to be prevented as well. This is useful in case someone else
                // is listening for this event.
                var itemWasDeselected = this.deselect();
                if (!itemWasDeselected) {
                    itemEvent.preventDefault();
                }
            },
            "select": function(child, ev) {
                this.trigger("select", ev);
            },
            "before:deselect": function(item, itemEvent) {
                this.retriggerPreventable("before:deselect", itemEvent);
            },
            "deselect": function(child, ev){
                this.trigger("deselect", ev);
            },
            "before:navigate": function(item, itemEvent) {
                this.retriggerPreventable("before:navigate", itemEvent);
            },
            "before:navigate:prevented": function(item, itemEvent) {
                this.trigger("before:navigate:prevented", itemEvent);
            }
        },

        initialize: function () {
            this.id = this.$el.attr("data-id");

            this.$(">ul>li").each(_.bind(function (index, li) {
                var navigationItem = JIRA.Projects.Sidebar.Component.NavigationGroup.build(li);

                var alreadyExists = !!this.getItem(navigationItem.id);
                if (alreadyExists && AJS.warn) {
                    AJS.warn("Duplicated IDs detected. There are more than one NavigationItem with id data-link-id='"+navigationItem.id+"'");
                }

                this.proxyChildEvents(navigationItem);
                this.children.add(navigationItem, navigationItem.id);
            }, this));
        },

        /**
         * Returns HTML element representing sidebar group.
         *
         * @returns {HTMLElement} HTML element representing sidebar group.
         */
        getElement: function() {
            return this.el;
        },

        /**
         * Deselect all the subviews.
         *
         * This method will call 'deselect()' for each item view.
         *
         * @returns {boolean} True if all the views where successfully deselected, false otherwise.
         */
        deselect: function () {
            var groupEvent = this.triggerPreventable("before:deselect");
            if (groupEvent.isPrevented) {
                return false;
            }

            // Can't use _.every() because it will stop the loop when the first 'false' value is found, and we still
            // want to call .deselect() in the rest of the views.
            var isSuccessful = true;
            this.children.each(function(view){
                isSuccessful = view.deselect() && isSuccessful;
            });
            return isSuccessful;
        },

        /**
         * Gets an item from the group.
         *
         * @param {string} id ID of the item to retrieve.
         * @returns {JIRA.Projects.Sidebar.Component.NavigationItem|JIRA.Projects.Sidebar.Component.NavigationSubgroup|undefined}
         */
        getItem: function (id) {
            return this.children.findByCustom(id);
        },

        /**
         * Gets an item based on its position.
         *
         * @param {number} index Position of the item.
         * @returns {JIRA.Projects.Sidebar.Component.NavigationItem|JIRA.Projects.Sidebar.Component.NavigationSubgroup|undefined}
         */
        getItemAt: function (index) {
            return this.children.findByIndex(index);
        },

        getSelectedNavigationItem: function() {
            var selectedItem = this.children.find(function(child) {
                return child.hasASelectedItem();
            });
            if (selectedItem) {
                return selectedItem.getSelectedNavigationItem();
            }
        },

        hasASelectedItem: function() {
            return this.children.any(function(child) {
                return child.hasASelectedItem();
            });
        }
    }, {
        build: function(element) {
            var instance;

            if (AJS.$(element).find("ul").length) {
                instance = new JIRA.Projects.Sidebar.Component.NavigationSubgroup({
                    el: element
                });
            } else {
                instance = new JIRA.Projects.Sidebar.Component.NavigationItem({
                    el: element
                });
            }

            return instance;
        }
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-component', location = '/sidebar/component/navigation-subgroup.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.Component.NavigationSubgroup");

    JIRA.Projects.Sidebar.Component.NavigationSubgroup = JIRA.Projects.Sidebar.Component.NavigationGroup.extend({
        childEvents: {
            "before:select": function (item, itemEvent) {
                JIRA.Projects.Sidebar.Component.NavigationGroup.prototype.childEvents["before:select"].apply(this, arguments);
                if (!itemEvent.isPrevented) {
                    this.expand();
                }
            }
        },

        initialize: function() {
            // Inherit childEvents
            this.childEvents = _.extend({}, JIRA.Projects.Sidebar.Component.NavigationGroup.prototype.childEvents, this.childEvents);

            JIRA.Projects.Sidebar.Component.NavigationGroup.prototype.initialize.apply(this, arguments);
            this.id = this.$el.find(">a[data-link-id]").attr("data-link-id");
        },

        expand: function () {
            // Most of the expand/collapse logic is already handled by AJS.sidebar(). As we can't detect all the
            // expansion events, it is better to not provide events for this action at all.
            this.$el.attr('aria-expanded', 'true');
        },

        collapse: function () {
            // Most of the expand/collapse logic is already handled by AJS.sidebar(). As we can't detect all the
            // expansion events, it is better to not provide events for this action at all.
            this.$el.attr('aria-expanded', 'false');
        },

        isExpanded: function() {
            return this.$el.attr('aria-expanded') === 'true';
        },

        isSelected: function() {
            return this.$el.hasClass("aui-nav-selected");
        },

        getId: function() {
            return this.id;
        },

        getSelectedNavigationItem: function() {
            if (this.isSelected()) {
                return this;
            }
            var selectedItem = this.children.find(function(child) {
                return child.hasASelectedItem();
            });
            if (selectedItem) {
                return selectedItem.getSelectedNavigationItem();
            }
        },

        hasASelectedItem: function() {
            if (this.isSelected()) {
                return true;
            }
            return this.children.any(function(child) {
                return child.hasASelectedItem();
            });
        }
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-api', location = '/sidebar/api.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar");
    AJS.namespace("JIRA.API");

    var sidebarDeferred = AJS.$.Deferred();

    JIRA.API.getSidebar = function() {
        return sidebarDeferred.promise();
    };

    JIRA.Projects.Sidebar.initAPI = function(sidebarComponent) {
        // TODO We should add a simple facade to the component, so we only expose a
        // subset of the component's methods
        JIRA.API.Sidebar = sidebarComponent;
        sidebarDeferred.resolve(JIRA.API.Sidebar);
    };
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-analytics', location = '/sidebar/analytics/analytics.js' */
(function ($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.Analytics");

    function hashedId(id) {
        return JIRA.Projects.Sidebar.Analytics.Hash.prefixedHash(id || "NONE");
    }

    function triggerAnalyticsEvent(eventName, data) {
        AJS.trigger('analyticsEvent', {
            name: "jira.project.centric.navigation.sidebar." + eventName,
            data: data
        });
    }

    /**
     * Sets up Analytics events to track the usage of the sidebar.
     *
     * This method will trigger two types of events:
     *
     *   * jira.project.centric.navigation.sidebar.load.*: whenever the sidebar (i.e. this file) is loaded
     *   * jira.project.centric.navigation.sidebar.click.link: whenever a a link in the sidebar is clicked.
     *
     * For the click events, the data-link-id attribute (if any exists) will be reported in the event, but
     * will be hashed first in case the id contains sensitive data. Known safe link id prefixes can be
     * excluded from the hash for easier tracking using {@link JIRA.Projects.Sidebar.Analytics.Hash.addPrefix}
     *
     * @param sidebarElement {Element|jQuery|string} the element or selector representing the sidebar
     */
    JIRA.Projects.Sidebar.Analytics = function(sidebarElement) {
        var sidebar = AJS.sidebar(sidebarElement);
        var $sidebar = $();
        $sidebar = $sidebar.add(sidebar.$el);
        $sidebar = $sidebar.add(sidebar.submenus.inlineDialog);

        if (!JIRA.API.Sidebar) {
            throw new Error('Error: cannot start analytics before JIRA.Projects.Sidebar.initAPI is called');
        }

        if (JIRA.API.Sidebar.isProjectSidebar()) {
            triggerAnalyticsEvent('load.project');
        } else {
            triggerAnalyticsEvent('load.global');
        }

        $sidebar.on('click', 'a', function() {
            var hashed = hashedId($(this).attr("data-link-id"));
            var data = {id: hashed.hash, prefix: hashed.prefix};

            var renderMode = AJS.Meta.get("sidebar-source-page");
            if (renderMode) {
                data.sidebarSourcePage = renderMode;
            } else {
                // Fall back to checking for a particular button if no meta is found (old versions of nav plugin)
                // probably this should be deleted eventually (around April/May 2016 once meta data is added).
                if ($(".issue-tools button.expand").length > 0) {
                    data.sidebarSourcePage = "search-el";
                } else if ($(".navigation-tools button.collapse").length > 0) {
                    data.sidebarSourcePage = "fullscreen-el";
                }
            }

            if (SOURCE_PAGE_WHITELIST.indexOf(data.sidebarSourcePage) === -1) {
                data.sidebarSourcePage = "unknown";
            }

            triggerAnalyticsEvent("click.link", data);
        });
    };

    var SOURCE_PAGE_WHITELIST = [
        "search-el",
        "fullscreen-el",
        "search",
        "fullscreen",
        "rapid-board",
        "service-desk"
    ];

})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-analytics', location = '/sidebar/analytics/hash.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.Analytics");

    var prefixes = [];

    function startsWith(string, prefix) {
        return string.indexOf(prefix) === 0;
    }

    function substringAfter(string, prefix) {
        return string.substring(startsWith(string, prefix) ? prefix.length : 0);
    }

    function hashCode (string) {
        var charCode;
        var hash = 0;
        if (!string) {
            return "";
        }

        for (var i = 0; i < string.length; i += 1) {
            charCode = string.charCodeAt(i);
            hash = ((hash * 32) - hash) + charCode;
            hash |= 0; // force 32-bit representation
        }

        return hash;
    }

    JIRA.Projects.Sidebar.Analytics.Hash = {
        /**
         * A hashed version of the provided string (for anonymising analytics data).
         *
         * If the id starts with a 'whitelisted' prefix, the prefix + the hashCode
         * of the remainder will be returned. e.g. "prefix-foo -> prefix-101574"
         *
         * Hashing uses the same algorithm as Java's String.hashCode
         * (good for anonymity, not suitable for security purposes)
         *
         * @param string The string to hash
         * @returns {String} The whitelisted prefix of the string, followed by
         * the 'hash code' of the remainder
         */
        prefixedHash: function (string) {
            var prefix = _.find(prefixes, _.partial(startsWith, string)) || "";
            return {
                prefix: prefix,
                hash: prefix + hashCode(substringAfter(string, prefix))
            };
        },

        /**
         * Register an id prefix as safe for exclusion from the hashing process.
         *
         * e.g. If the prefix "prefix-" is registered then "prefix-foo" will
         * hash to "prefix-101574"
         *
         * @param prefix The prefix to register as safe
         */
        addPrefix: function (prefix) {
            if (prefix && !_.contains(prefixes, prefix)) {
                prefixes.push(prefix);
            }
        },

        /**
         * Clear all whitelisted prefixes (see {@link addPrefix})
         */
        clearPrefixes: function () {
            prefixes.length = 0;
        }
    };

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-expansion-manager', location = '/sidebar/expansion-manager.js' */
(function() {
    "use strict";

    var STORAGE_KEY = 'jira-sidebar-collapsed';

    AJS.namespace('JIRA.Projects.Sidebar');

    /**
     * @param {AJS.sidebar} sidebar An AUI sidebar.
     * @param {Storage} [storage=window.localStorage] The object in which to
     *     persist `sidebar`'s expansion state.
     */
    JIRA.Projects.Sidebar.ExpansionManager = function(sidebar, storage) {
        storage || (storage = window.localStorage);

        var isSidebarCollapsedByDefault = !!WRM.data.claim('sidebar-collapsed-by-default');

        restoreCollapsedState();
        sidebar.on("expand-start", controlCollapsedStateOnResize);
        sidebar.on('expand-end collapse-end', persistCollapsedState);

        function controlCollapsedStateOnResize(event) {
            // prevent auto-expansion if user collapsed the sidebar before
            if (event.isResponsive && storage[STORAGE_KEY] === 'true') {
                event.preventDefault();
            }
        }

        function persistCollapsedState(event) {
            // remember the collapsed state only when it collapses on user's request
            // and viewport is not narrow at the moment
            if (!event.isResponsive && !sidebar.isViewportNarrow()) {
                storage[STORAGE_KEY] = sidebar.isCollapsed().toString();
            }
        }

        function restoreCollapsedState() {
            if (sidebar.reflow() && sidebar.isViewportNarrow()) {
                return;
            }

            if ((isSidebarCollapsedByDefault && storage[STORAGE_KEY] === undefined) || storage[STORAGE_KEY] === 'true') {
                sidebar.collapse();
            } else {
                sidebar.expand();
            }
        }
    };

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:projects-api', location = 'page/projects-api.js' */
define('jira/api/projects', ['jira/projects/data/WRM'], function (WRM) {
    'use strict';

    var projectKey = WRM.data.claim('project-key'),
        projectId = WRM.data.claim('project-id'),
        projectName = WRM.data.claim('project-name');

    return {
        getCurrentProjectId: function () {
            return projectId;
        },
        getCurrentProjectKey: function () {
            return projectKey;
        },
        getCurrentProjectName: function () {
            return projectName;
        }
    };
});

AJS.namespace('JIRA.API.Projects', null, require('jira/api/projects'));;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-last-visited', location = '/sidebar/lastvisited/last-visited-updater.js' */
define("jira/projects/sidebar/lastvisited/updater", [
    "jquery"
], function(
    $
) {
    "use strict";

    function updateLastViewedItem(projectKey, selectedItemId, callback) {
        callback = callback || function () {
            JIRA.trace("last.visited.item.saved");
        };
        $.ajax({
            url: AJS.contextPath() + "/rest/projects/1.0/project/" + encodeURIComponent(projectKey) + "/lastVisited",
            type: "PUT",
            contentType: "application/json",
            data: JSON.stringify({
                id: selectedItemId
            })
        }).done(callback);
    }


    return {
        start: function (sidebar, callback) {
            var currentProjectKey = (JIRA.API && JIRA.API.Projects && JIRA.API.Projects.getCurrentProjectKey()) || null;
            var selectedNavItem = sidebar.getSelectedNavigationItem();
            if (selectedNavItem) {
                updateLastViewedItem(currentProjectKey, selectedNavItem.getId(), callback);
            }
            sidebar.on("before:navigate:prevented", function (event) {
                updateLastViewedItem(currentProjectKey, event.emitter.id, callback);
            });
            sidebar.on("before:select", function (event) {
                if (event.isInitial) {
                    updateLastViewedItem(currentProjectKey, event.emitter.id, callback);
                }
            });
        }
    };
});

AJS.namespace("JIRA.Projects.Sidebar.LastVisited.Updater", null, require("jira/projects/sidebar/lastvisited/updater"));
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-init', location = '/sidebar/main.js' */
AJS.$(function() {
    "use strict";

    // Keep in sync with the list in com.atlassian.jira.projects.util.PageIdHasher
    var prefixWhitelist = [
        // The constant "NONE" will represent id-less links that were clicked
        "NONE",
        "com.atlassian.jira.jira-projects-plugin:project-issue-search-link",
        "com.atlassian.jira.jira-projects-plugin:components-page",
        "com.atlassian.jira.jira-projects-plugin:reports-panel",
        "com.atlassian.jira.jira-projects-plugin:summary-panel",
        "com.atlassian.jira.jira-projects-plugin:summary-page",
        "com.atlassian.jira.jira-projects-plugin:components-page",
        "com.atlassian.jira.jira-projects-plugin:release-page",
        "com.atlassian.jira.jira-projects-plugin:release-sidebar-version-",
        "com.atlassian.jira.jira-projects-plugin:report-page",
        "com.pyxis.greenhopper.jira:global-sidebar-report",
        "com.pyxis.greenhopper.jira:global-sidebar-plan-scrum",
        "com.pyxis.greenhopper.jira:global-sidebar-work-scrum",
        "com.pyxis.greenhopper.jira:global-sidebar-work-kanban",
        "com.pyxis.greenhopper.jira:project-sidebar-plan-scrum",
        "com.pyxis.greenhopper.jira:project-sidebar-work-scrum",
        "com.pyxis.greenhopper.jira:project-sidebar-work-kanban",
        "com.pyxis.greenhopper.jira:project-invite-users-link",
        "com.pyxis.greenhopper.jira:sidebar-feedback-link",
        "com.atlassian.jira.jira-projects-issue-navigator:embedded-issue-navigator-link",
        "com.atlassian.jira.jira-projects-issue-navigator:sidebar-issue-navigator",
        "com.atlassian.jira.jira-projects-plugin:project-invite-users-link",
        "com.atlassian.jira.jira-projects-plugin:sidebar-feedback-link"
    ];

    function initSidebarBadges(sidebar) {
        var badges = AJS.$('.aui-sidebar .aui-badge');
        badges.tooltip({ gravity: 'w' });

        if (sidebar.isCollapsed()) {
            badges.tooltip('disable');
        }

        sidebar.on('collapse-end expand-end', function () {
            AJS.$(".tipsy").remove();
            AJS.$('.aui-sidebar .aui-badge').tooltip('toggleEnabled');
        });
    }

    /**
     * Schedules a reflow of the sidebar, so its height is recomputed periodically.
     *
     * We need this to bring back the bottom of the sidebar, which gets lost when
     * banners get displayed on the top of the page after it's loaded.
     */
    function scheduleSidebarReflow() {
        function reflow() {
            JIRA.API.Sidebar.getAUISidebar().reflow();
        }

        setTimeout(reflow, 200);
        setInterval(reflow, 5 * 60 * 1000);
    }

    function initDropdownCloser(sidebar) {
        sidebar.on('collapse-start', function() {
            var dropdown = sidebar.$el.find(".scope-filter-trigger");
            if (dropdown.hasClass("aui-dropdown2-active")) {
                dropdown.trigger("aui-button-invoke");
            }
        });
    }

    function attachProjectTypesWarningDialog() {
        require("jira/project/types/warning/dialog").init({
            onProjectTypeChanged: function() {
                // we want to take the user to the summary page, just in case the project type
                // change happens from a page for which she will have no access to after the type has changed
                var projectKey = JIRA.API.Projects.getCurrentProjectKey();
                window.location.replace(AJS.contextPath() + "/projects/" + projectKey + "/summary");
            }
        });
        JIRA.trace("project.types.warning.messages.init");
    }

    if (AJS.$('.aui-sidebar').length) {
        var sidebar = AJS.sidebar('.aui-sidebar');

        JIRA.Projects.Sidebar.initAPI(new JIRA.Projects.Sidebar.Component({el: sidebar.$el[0]}));
        JIRA.Projects.Sidebar.ExpansionManager(sidebar);

        _(prefixWhitelist).each(JIRA.Projects.Sidebar.Analytics.Hash.addPrefix);
        JIRA.Projects.Sidebar.Analytics('.aui-sidebar');

        initDropdownCloser(sidebar);
        initSidebarBadges(sidebar);
        scheduleSidebarReflow();
        attachProjectTypesWarningDialog();

        JIRA.API.getSidebar().done(function(sidebar) {
            JIRA.Projects.Sidebar.LastVisited.Updater.start(sidebar);
        });
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:collapsed-scope-filter', location = '/sidebar/scopefilter/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.Sidebar.ScopeFilter.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.Sidebar == 'undefined') { JIRA.Projects.Sidebar = {}; }
if (typeof JIRA.Projects.Sidebar.ScopeFilter == 'undefined') { JIRA.Projects.Sidebar.ScopeFilter = {}; }
if (typeof JIRA.Projects.Sidebar.ScopeFilter.Templates == 'undefined') { JIRA.Projects.Sidebar.ScopeFilter.Templates = {}; }


JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedContainer = function(opt_data, opt_ignored) {
  return '<div class="aui-sidebar-group aui-sidebar-group-actions collapsed-scope-filter-container"></div>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedContainer.soyTemplateName = 'JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedContainer';
}


JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedScopeList = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  var output = '';
  if (opt_data.selectableScopes || opt_data.createActions) {
    output += '<div class="aui-nav-heading" title="' + soy.$$escapeHtml("Boards in this project") + '"><strong class="collapsed-scope-header">' + soy.$$escapeHtml("Boards in this project") + '</strong></div><ul class="aui-nav collapsed-scope-list" title="' + soy.$$escapeHtml("Select a board") + '">';
    if (opt_data.selectedScope) {
      output += '<li class="scope-filter selected-scope-filter" title="' + soy.$$escapeHtml(opt_data.selectedScope.label) + '">' + soy.$$escapeHtml(opt_data.selectedScope.label) + '</li>';
      var scopeFilterList21 = opt_data.selectableScopes;
      var scopeFilterListLen21 = scopeFilterList21.length;
      for (var scopeFilterIndex21 = 0; scopeFilterIndex21 < scopeFilterListLen21; scopeFilterIndex21++) {
        var scopeFilterData21 = scopeFilterList21[scopeFilterIndex21];
        output += JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedSelectableItem({itemClass: 'scope-filter', anchorClass: scopeFilterData21.styleClass, label: scopeFilterData21.label, link: scopeFilterData21.link});
      }
    }
    if (opt_data.createActions) {
      var createActionList30 = opt_data.createActions;
      var createActionListLen30 = createActionList30.length;
      for (var createActionIndex30 = 0; createActionIndex30 < createActionListLen30; createActionIndex30++) {
        var createActionData30 = createActionList30[createActionIndex30];
        output += JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedSelectableItem({itemClass: 'create-scope-action', anchorClass: createActionData30.styleClass, label: createActionData30.label, link: createActionData30.link});
      }
    }
    output += '</ul>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedScopeList.soyTemplateName = 'JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedScopeList';
}


JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedSelectableItem = function(opt_data, opt_ignored) {
  return '<li class="' + soy.$$escapeHtml(opt_data.itemClass) + '"><a href="' + soy.$$escapeHtml(opt_data.link) + '" title="' + soy.$$escapeHtml(opt_data.label) + '"' + ((opt_data.anchorClass) ? ' class="' + soy.$$escapeHtml(opt_data.anchorClass) + '"' : '') + '>' + soy.$$escapeHtml(opt_data.label) + '</a></li>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedSelectableItem.soyTemplateName = 'JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedSelectableItem';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:collapsed-scope-filter', location = '/sidebar/scopefilter/model.js' */
(function() {
    "use strict";

    AJS.namespace('JIRA.Projects.Sidebar.ScopeFilter');

    JIRA.Projects.Sidebar.ScopeFilter.Model = function(data) {
        this.selectedScope = data.selectedScope;
        this.createScopeActions = data.createScopeActions;

        if(this.selectedScope) {
            this.selectableScopes = _.reject(data.scopes, function(scope) {
                return scope.label === this.selectedScope.label && scope.link === this.selectedScope.link;
            }, this);
        } else {
            this.selectableScopes = data.scopes;
        }

        var userCanCreateAScope = this.createScopeActions.length > 0;
        var thereAreScopesToSelect = this.selectableScopes.length > 0;
        this.displayWhenSidebarIsCollapsed = userCanCreateAScope || thereAreScopesToSelect;
    };

    JIRA.Projects.Sidebar.ScopeFilter.Model.prototype.getSelectedScope = function() {
        return this.selectedScope
    };

    JIRA.Projects.Sidebar.ScopeFilter.Model.prototype.getSelectableScopes = function() {
        return this.selectableScopes;
    };

    JIRA.Projects.Sidebar.ScopeFilter.Model.prototype.getCreateScopeActions = function() {
        return this.createScopeActions;
    };

    JIRA.Projects.Sidebar.ScopeFilter.Model.prototype.shouldDisplayWhenSidebarIsCollapsed = function() {
        return this.displayWhenSidebarIsCollapsed;
    }
})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:collapsed-scope-filter', location = '/sidebar/scopefilter/collapsed-view.js' */
(function() {
    "use strict";

    AJS.namespace('JIRA.Projects.Sidebar.ScopeFilter');

    JIRA.Projects.Sidebar.ScopeFilter.CollapsedView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedScopeList,

        serializeData: function() {
            return {
                selectedScope: this.model.getSelectedScope(),
                selectableScopes: this.model.getSelectableScopes(),
                createActions: this.model.getCreateScopeActions()
            }
        },

        onRender: function() {
            this.unwrapTemplate();
        }
    });
})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:collapsed-scope-filter', location = '/sidebar/scopefilter/collapsed-controller.js' */
(function() {
    "use strict";

    AJS.namespace('JIRA.Projects.Sidebar.ScopeFilter');

    JIRA.Projects.Sidebar.ScopeFilter.CollapsedController = JIRA.Projects.Libs.Marionette.Controller.extend({
        initialize: function(options) {
            this.scopeFilter = options.scopeFilter;

            // This special Region uses view.$el (as opposed to view.el), so all the nodes in the child
            // view will be appended to our element.
            var MultiElementRegion = JIRA.Projects.Libs.Marionette.Region.extend({
                attachHtml: function(view) {
                    // empty the node and append new view
                    this.$el.empty().append(view.$el);
                }
            });

            this.collapsedScopeFilterContainer = new MultiElementRegion({
                el: options.collapsedScopeFilterContainer
            });
        },

        render: function() {
            var view = new JIRA.Projects.Sidebar.ScopeFilter.CollapsedView({
                model: this.scopeFilter
            });
            this.collapsedScopeFilterContainer.show(view);
        },

        remove: function() {
            this.collapsedScopeFilterContainer.empty();

            //Unfortunately, we also need to do this as well because the previous line might fail
            //due to AUI inline dialog moving elements around.
            this.collapsedScopeFilterContainer.$el.empty();
        }
    });
})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:collapsed-scope-filter', location = '/sidebar/scopefilter/collapsed-initializer.js' */
(function() {
    "use strict";

    AJS.namespace('JIRA.Projects.Sidebar.ScopeFilter');

    function createCollapsedScopeFilterContainer($sidebarContentContainer) {
        var $collapsedSidebarContainer = AJS.$(JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedContainer());
        $sidebarContentContainer.prepend($collapsedSidebarContainer);
        return $collapsedSidebarContainer;
    }

    function listenToSidebarEvents(sidebar, collapsedScopeFilterController) {
        sidebar.on('collapse-start', function() {
            collapsedScopeFilterController.render();
            JIRA.trace("sidebar.scopefilter.collapsed");
        });

        sidebar.on('expand-end', function() {
            collapsedScopeFilterController.remove();
        });
    }

    JIRA.Projects.Sidebar.ScopeFilter.CollapsedInitializer = JIRA.Projects.Libs.Marionette.Controller.extend({
        initialize: function(options) {
            this.sidebarAPI = options.sidebarAPI;
            this.scopeFilterData = options.scopeFilterData;
            this.sidebar = options.sidebar;
            this.$sidebarContentContainer = options.$sidebarContentContainer;
        },

        run: function() {
            if(!this.sidebarAPI.isProjectSidebar()) {
                return;
            }

            var scopeFilter = new JIRA.Projects.Sidebar.ScopeFilter.Model(this.scopeFilterData);
            if(!scopeFilter.shouldDisplayWhenSidebarIsCollapsed()) {
                return;
            }

            var $collapsedSidebarContainer = createCollapsedScopeFilterContainer(this.$sidebarContentContainer);
            var collapsedScopeFilterController = new JIRA.Projects.Sidebar.ScopeFilter.CollapsedController({
                scopeFilter: scopeFilter,
                collapsedScopeFilterContainer: $collapsedSidebarContainer
            });
            listenToSidebarEvents(this.sidebar, collapsedScopeFilterController);
            if (this.sidebar.isCollapsed()) {
                collapsedScopeFilterController.render();
            }
        }
    });
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:collapsed-scope-filter', location = '/sidebar/scopefilter/collapsed-init.js' */
(function() {
    "use strict";

    var scopeFilterData = WRM.data.claim('scope-filter-data');
    if (scopeFilterData) {
        JIRA.API.getSidebar().done(function(sidebarAPI) {
            var initializer = new JIRA.Projects.Sidebar.ScopeFilter.CollapsedInitializer({
                sidebarAPI: sidebarAPI,
                scopeFilterData: scopeFilterData,
                sidebar: sidebarAPI.getAUISidebar(),
                $sidebarContentContainer: sidebarAPI.getContentContainer()
            });
            initializer.run();
        });
    }
})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:feature-discovery', location = '/sidebar/feature-discovery/feature-discovery.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.FeatureDiscovery");

    function removeBadgesFor(navigationItems) {
        _.each(navigationItems, function(navigationItemId) {
            var navigationItem = JIRA.API.Sidebar.getItem(navigationItemId);
            if (navigationItem) {
                navigationItem.removeBadge();
            }
        });
    }

    JIRA.Projects.Sidebar.FeatureDiscovery = {
        /**
         * Updates the badges displayed next to the links on the sidebar.
         */
        updateBadges: function() {
            // a global board sidebar does not have a single project key to be used
            if (typeof JIRA.API.Projects.getCurrentProjectKey() === 'undefined') {
                return;
            }

            AJS.$.ajax({
                url: AJS.contextPath() + '/rest/projects/1.0/project/' + encodeURIComponent(JIRA.API.Projects.getCurrentProjectKey()) + '/badges',
                type: "PUT",
                contentType:"application/json"
            }).done(function(response) {
                removeBadgesFor(response.badgesToRemove || []);
            });
        }
    }
}());
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:subnavigator', location = '/static/components/subnavigator/Subnavigator.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.Subnavigator");

    /**
     * Thin wrapper around AUI's dropdown2 that renders a list of items to choose from.
     * The component is initialized like this:
     *
     * var items = JIRA.Projects.Subnavigator({
     *     id: someId,
     *     triggerPlaceholder: cssSelector,
     *     contentPlaceholder: cssSelector,
     *     itemGroups: [...],
     *     selectedItem: itemId
     * });
     *
     * On the initialization object:
     * @param {string} id An identifier for the component, just in case there are more than one on the same page
     * @param {string} triggerPlaceholder A css selector or DOM element where the dropdown2 trigger will be placed
     * @param {string} contentPlaceholder A css selector or DOM element where the dropdown2 content (aka the options) will be placed
     * @param {string} titlePlaceholder A css selector or DOM element where the dropdown2 title will be placed (optional).
     *                                  If not provided, the component will not handle the title.
     * @param {Object[]} itemGroups An array with the list of items to choose from
     * @param {string} selectedItem The identifier of the item that will appear as selected
     * @param {string} changeViewText Text used for the trigger (optinal). If not provided, it will show the selected item.
     * @param {boolean} hideSelectedItem Whether we should hide the selected item from the dropdown2 (defaults to true)
     *
     * The items passed to itemGroups are an object as follows:
     *
     * {
     *     id: "some-id", // The identifier of the item
     *     label: "A label", // The label used to display the item
     *     description: "A description", // A description that will be shown as a tooltip on mouseover [Optional]
     *     link: "example.com", // The link to go to if the item is selected [Optional]
     * }
     *
     * The array of itemGroups passed to the component should contain an array for each section of items that
     * needs to be rendered. For example, if we pass in
     * [
     *      [
     *          { id: "1", label: "First"},
     *          { id: "2", label: "Second"}
     *      ],
     *      [
     *          { id: "3", label: "Third"}
     *      ]
     * ]
     *
     * the component will render the options in two option sections (one containing First and Second and another one containing Third).
     *
     * For convenience, if you only want to render one section, you can pass the items a simple array, like so:
     *
     * [
     *    { id: "1", label: "First"},
     *    { id: "2", label: "Second"}
     * ]
     *
     * This component triggers a "itemSelected" event every time an item is selected.
     * The event object passed on to listeners to this event will contain the item selected.
     * Preventing the default action for that event is also possible:
     *
     * items.on("itemSelected", function(e) {
     *     e.preventDefault();
     *     console.log(e.item);
     * });
     *
     */
    JIRA.Projects.Subnavigator = JIRA.Projects.Libs.Marionette.Controller.extend({
        _shouldShow: function() {
            return !this.model.isEmpty();
        },

        _shouldShowTriggerView: function() {
            if (this.options.changeViewText) {
                var numberOfItems = this.model.getAllItems().length;
                return numberOfItems > 1;
            } else {
                return true;
            }
        },

        _sanitizeItems: function() {
            var items = this.options.itemGroups;

            if (items && items[0]) {
                if (!_.isArray(items[0])) {
                    return [items];
                }
            }

            return items;
        },

        _buildModel: function() {
            this.model = new JIRA.Projects.Subnavigator.Entities.Items({
                itemGroups: this._sanitizeItems()
            });
            this.model.selectItem(this.options.selectedItem);
            this.listenTo(this.model, "change:selectedItem", this.show);
        },

        _buildTitleView: function() {
            this.titleView = new JIRA.Projects.Subnavigator.Views.Title({
                model: this.model
            });
            this.titleView.setElement(AJS.$(this.options.titlePlaceholder));
        },

        _buildTriggerView: function() {
            if (this.options.changeViewText) {
                this.triggerView = new JIRA.Projects.Subnavigator.Views.StaticTrigger({
                    model: this.model,
                    id: this.options.id,
                    label: this.options.changeViewText
                });
            } else {
                this.triggerView = new JIRA.Projects.Subnavigator.Views.Trigger({
                    model: this.model,
                    id: this.options.id
                });
            }
            this.triggerView.setElement(AJS.$(this.options.triggerPlaceholder));
        },

        _buildContentView: function() {
            this.contentView = new JIRA.Projects.Subnavigator.Views.Content({
                model: this.model,
                id: this.options.id,
                hideSelectedItem: this.options.hideSelectedItem
            });
            this.contentView.setElement(AJS.$(this.options.contentPlaceholder));

            this.listenTo(this.contentView, 'click', function(itemId) {
                this.contentView.$el.on({
                    "aui-dropdown2-hide": _.bind(function() {
                        this.model.selectItem(itemId);
                        var item = this.model.get("selectedItem");
                        var event = this.triggerPreventable("itemSelected", {
                            item: item
                        });

                        if (event.isPrevented) {
                            return;
                        }
                        if (item.link) {
                            require('jira/util/browser').reloadViaWindowLocation(item.link);
                        }
                    }, this)
                });
            });
        },

        initialize: function() {
            this._buildModel();
            if (this._shouldShow()) {
                this._buildTriggerView();
                this._buildContentView();
                if (this.options.titlePlaceholder) {
                    this._buildTitleView();
                }
            }
        },

        show: function() {
            if (this._shouldShow()) {
                if (this._shouldShowTriggerView()) {
                    this.triggerView.render();
                    this.contentView.render();
                }
                if (this.titleView) {
                    this.titleView.render();
                }
            }
        },

        selectItem: function(itemId) {
            if (this._shouldShow()) {
                this.model.selectItem(itemId);
            }
        }
    });

}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:subnavigator', location = '/static/components/subnavigator/templates/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.Subnavigator.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.Subnavigator == 'undefined') { JIRA.Projects.Subnavigator = {}; }
if (typeof JIRA.Projects.Subnavigator.Templates == 'undefined') { JIRA.Projects.Subnavigator.Templates = {}; }


JIRA.Projects.Subnavigator.Templates.content = function(opt_data, opt_ignored) {
  var output = '<div id="subnav-opts' + ((opt_data.idSuffix) ? '-' + soy.$$escapeHtml(opt_data.idSuffix) : '') + '" class="subnav-opts subnavigator-content aui-dropdown2 aui-style-default">';
  var itemGroupList9 = opt_data.itemGroups;
  var itemGroupListLen9 = itemGroupList9.length;
  for (var itemGroupIndex9 = 0; itemGroupIndex9 < itemGroupListLen9; itemGroupIndex9++) {
    var itemGroupData9 = itemGroupList9[itemGroupIndex9];
    output += JIRA.Projects.Subnavigator.Templates.itemSection({items: itemGroupData9});
  }
  output += '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Subnavigator.Templates.content.soyTemplateName = 'JIRA.Projects.Subnavigator.Templates.content';
}


JIRA.Projects.Subnavigator.Templates.itemSection = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.items.length > 0) {
    output += '<div class="aui-dropdown2-section"><ul class="subnav-section">';
    var itemList18 = opt_data.items;
    var itemListLen18 = itemList18.length;
    for (var itemIndex18 = 0; itemIndex18 < itemListLen18; itemIndex18++) {
      var itemData18 = itemList18[itemIndex18];
      output += JIRA.Projects.Subnavigator.Templates.item({item: itemData18});
    }
    output += '</ul></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Subnavigator.Templates.itemSection.soyTemplateName = 'JIRA.Projects.Subnavigator.Templates.itemSection';
}


JIRA.Projects.Subnavigator.Templates.item = function(opt_data, opt_ignored) {
  return '<li' + ((opt_data.item.description) ? ' title="' + soy.$$escapeHtml(opt_data.item.description) + '"' : '') + ' ' + ((opt_data.item.selected) ? ' class="aui-nav-selected"' : '') + '><a data-item-id="' + soy.$$escapeHtml(opt_data.item.id) + '" href="' + ((opt_data.item.link) ? soy.$$escapeHtml(opt_data.item.link) : '#') + '">' + soy.$$escapeHtml(opt_data.item.label) + '</a></li>';
};
if (goog.DEBUG) {
  JIRA.Projects.Subnavigator.Templates.item.soyTemplateName = 'JIRA.Projects.Subnavigator.Templates.item';
}


JIRA.Projects.Subnavigator.Templates.trigger = function(opt_data, opt_ignored) {
  return '' + ((opt_data.renderAsButton) ? '<button id="subnav-trigger' + ((opt_data.idSuffix) ? '-' + soy.$$escapeHtml(opt_data.idSuffix) : '') + '" class="subnav-trigger subnavigator-trigger aui-button aui-button-link aui-dropdown2-trigger" aria-owns="subnav-opts' + ((opt_data.idSuffix) ? '-' + soy.$$escapeHtml(opt_data.idSuffix) : '') + '" role="menu" aria-haspopup="true">' + soy.$$escapeHtml(opt_data.label) + '</button>' : '<span id="subnav-trigger' + ((opt_data.idSuffix) ? '-' + soy.$$escapeHtml(opt_data.idSuffix) : '') + '" class="subnav-trigger subnavigator-trigger">' + soy.$$escapeHtml(opt_data.label) + '</button>');
};
if (goog.DEBUG) {
  JIRA.Projects.Subnavigator.Templates.trigger.soyTemplateName = 'JIRA.Projects.Subnavigator.Templates.trigger';
}


JIRA.Projects.Subnavigator.Templates.title = function(opt_data, opt_ignored) {
  return '<span class="subnavigator-title" title="' + soy.$$escapeHtml(opt_data.title) + '">' + soy.$$escapeHtml(opt_data.title) + '</span>';
};
if (goog.DEBUG) {
  JIRA.Projects.Subnavigator.Templates.title.soyTemplateName = 'JIRA.Projects.Subnavigator.Templates.title';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:subnavigator', location = '/static/components/subnavigator/views/Content.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.Subnavigator.Views.Content");

    JIRA.Projects.Subnavigator.Views.Content = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Subnavigator.Templates.content,
        tooltipTimer: null,
        ui: {
            item: "li"
        },

        initialize: function() {
            this.tooltipTimeout = this.options.tooltipTimeout || 600;
            this.hideSelectedItem = this.options.hideSelectedItem === false;
        },

        _hideTooltips: function() {
            clearTimeout(this.tooltipTimer);
            AJS.$(".tipsy").remove();
        },

        events: {
            "click a": function(e) {
                e.preventDefault();
                this._hideTooltips();
                var item = AJS.$(e.target).attr("data-item-id");
                this.trigger("click", item);
            },
            "mouseenter @ui.item": function(ev) {
                this._hideTooltips();
                this.tooltipTimer = setTimeout(function() {
                    AJS.$(ev.currentTarget).tipsy("show");
                }, this.tooltipTimeout);
            },
            "mouseleave @ui.item": "_hideTooltips",
            "aui-dropdown2-hide": "_hideTooltips"
        },

        serializeData: function() {
            var selectedItem = this.model.get("selectedItem");
            var itemGroups = this.model.get("itemGroups");
            var hideSelectedItem = this.hideSelectedItem;

            if (selectedItem) {
                itemGroups = _.map(itemGroups, function(itemGroup) {
                    if (hideSelectedItem) {
                        return _.map(itemGroup, function(item) {
                            var response = _.clone(item);
                            if (response.id === selectedItem.id) {
                                response.selected = true;
                            }
                            return response;
                        });
                    } else {
                        return _.reject(itemGroup, function(item) {
                            return item.id === selectedItem.id;
                        });
                    }
                });
            }

            return {
                itemGroups: itemGroups,
                idSuffix: this.options.id || ""
            };
        },

        onRender: function() {
            this.unwrapTemplate();
            this._hideTooltips();
            /*
             * AUI's tooltip shows automatically by default.
             * On that mode, whenever the mouse enters the DOM element, a timeout will be scheduled to show the tooltip.
             * The problem with that is that they don't provide any way for us to cancel the timer once the mouse leaves.
             *
             * To solve this problem we are going to use AUI's tooltip in manual mode and we are going to be
             * in control of scheduling the tooltips and canceling them when the mouse enters/leaves the different options.
             */
            AJS.$(this.ui.item).tooltip({gravity: "w", trigger: "manual"});
        }
    });

}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:subnavigator', location = '/static/components/subnavigator/views/Trigger.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.Subnavigator.Views.Trigger");

    JIRA.Projects.Subnavigator.Views.Trigger = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Subnavigator.Templates.trigger,

        serializeData: function() {
            return {
                label: this.model.get("selectedItem").label,
                renderAsButton: this.model.getAllItems().length > 1,
                idSuffix: this.options.id || ""
            };
        },

        onRender: function() {
            this.unwrapTemplate();
        }
    });

}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:subnavigator', location = '/static/components/subnavigator/views/StaticTrigger.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.Subnavigator.Views.StaticTrigger");

    JIRA.Projects.Subnavigator.Views.StaticTrigger = JIRA.Projects.Subnavigator.Views.Trigger.extend({
        serializeData: function() {
            return {
                label: this.options.label,
                renderAsButton: true,
                idSuffix: this.options.id || ""
            };
        },

        onRender: function() {
            this.unwrapTemplate();
            this.$el.removeClass("subnav-trigger");
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:subnavigator', location = '/static/components/subnavigator/views/Title.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.Subnavigator.Views.Title");

    JIRA.Projects.Subnavigator.Views.Title = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Subnavigator.Templates.title,

        serializeData: function() {
            var selectedItem = this.model.get("selectedItem");

            return {
                title: selectedItem.label
            };
        }
    });

}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:subnavigator', location = '/static/components/subnavigator/entities/Items.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.Subnavigator.Entities.Items");

    JIRA.Projects.Subnavigator.Entities.Items = Backbone.Model.extend({
        defaults: {
            itemGroups: [],
            selectedItem: null
        },

        isEmpty: function() {
            return _.isEmpty(this.getAllItems());
        },

        selectItem: function(itemId) {
            var items = this.getAllItems();
            this.set("selectedItem",  _.find(items, function(item) { return item.id === itemId; }) || _.first(items));
        },

        getAllItems: function() {
            return _.flatten(this.get("itemGroups"));
        }
    });

}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/PinnableNavigator.js' */
(function($){
    "use strict";
    /**
     * This will create a dropdown component which can be pinned somewhere
     * The component is initialized like this:
     *
     * var items = JIRA.Projects.PinnableNavigator({
     *     id: someId,
     *     triggerView: view object,
     *     unpinnedView: view object,
     *     pinnedView: view object,
     *     pinnedHolderId: cssSelector,
     *     isPinned: boolean,
     *     manageDialogControl: manageDialogControl,
     *     model: model,
     *     triggerHolderId: myOptions.triggerHolderId,
     *     unpinnedHolderId: myOptions.unpinnedHolderId
     * });
     *
     * On the initialization object:
     * @param {string} id An identifier for the component, just in case there are more than one on the same page
     * @param {object} triggerView A view object which content the template of button to open the dropdown.
     * @param {object} unpinnedView A view object which content the template of dropdown.
     * @param {object} pinnedView A view object which content the template of pinned panel.   
     * @param {string} pinnedHolderId A ID selector where the dropdown2 will be pinned
     * @param {boolean} isPinned Pin or unpin the navigator at the first time
     * @param {object} manageDialogControl control of manage view
     * @param {object} model model of the views (pinned, unpinned, trigger and manage view)
     * @param {string} triggerHolderId An identifier for the trigger view
     * @param {string} unpinnedHolderId An identifier for the unpinned view
     *
     * The items passed to itemGroups are an object as follows:
     *
     * {
     *     id: "some-id", // The identifier of the item
     *     label: "A label", // The label used to display the item
     *     description: "A description", // A description that will be shown as a tooltip on mouseover [Optional]
     *     link: "example.com", // The link to go to if the item is selected [Optional]
     *     count: number, // The number need to show [Optional]
     * }
     *
     * The array of itemGroups passed to the component should contain an array for each section of items that
     * needs to be rendered. For example, if we pass in
     * [
     *      [
     *          { id: "1", label: "First"},
     *          { id: "2", label: "Second", count: 5}
     *      ],
     *      [
     *          { id: "3", label: "Third"}
     *      ]
     * ]
     *
     * the component will render the options in two option sections (one containing First and Second and another one containing Third).
     *
     * For convenience, if you only want to render one section, you can pass the items a simple array, like so:
     *
     * [
     *    { id: "1", label: "First"},
     *    { id: "2", label: "Second"}
     * ]
     *
     * This component triggers a "itemSelected" event every time an item is selected.
     * The event object passed on to listeners to this event will contain the item selected.
     * Preventing the default action for that event is also possible:
     *
     * items.on("itemSelected", function(e) {
     *     e.preventDefault();
     *     console.log(e.item);
     * });
     *
     */
    JIRA.Projects.PinnableNavigator = JIRA.Projects.Libs.Marionette.Controller.extend({
        _renderPinned: function() {
            if (this.options.pinnedView.isAttachedToDom() && !this.options.searchView.isSearchable() && this.options.searchView.isExisted()) {
                this.options.pinnedView.$el.show();
                this.options.pinnedView.renderList();
            } else {
                this.saveState('pin');
                this.options.isPinned = true;
                this.options.triggerView.$el.empty().hide();
                this.options.unpinnedView.$el.empty();

                $('#'+this.options.pinnedHolderId).prepend(this.options.pinnedView.render().$el);
                this.options.pinnedView.renderSearch();

                this.options.pinnedView.putListintoView();
                this.trigger("navigatorPinned");
            }
        },

        _renderUnpinned: function() {
            if (AJS.$("#" + this.options.triggerHolderId).length) {
                // We want to expose the show method for developers as a way they can re-evaluate the container elements
                // for the case where the original dom elements have been removed and a re-render is needed. To do so we
                // re-evaluate the elements for each method call.
                this.options.triggerView.setElement(AJS.$("#" + this.options.triggerHolderId));
                this.options.unpinnedView.setElement(AJS.$("#" + this.options.unpinnedHolderId));
            }
            this.saveState('unpin');
            this.options.isPinned = false;
            this.options.triggerView.render().$el.show();
            this.options.unpinnedView.render();
            this.options.pinnedView.unpin();
            this.options.unpinnedView.renderSearch();
            this.options.unpinnedView.putListintoView();
            this.trigger("navigatorUnPinned");
        },

        _openManageDialog: function () {
            this.options.manageDialogControl.show();
        },
        /**
         * Update the model of Pin, Trigger, Unpin view.
         * @param {Array} itemGroups - The group of items to render
         * @param {Array} selectedItem - The id of the time to select (optional)
         */
        update: function (itemGroups, selectedItem) {
            this.options.model.set("itemGroups", itemGroups);
            if (selectedItem) {
                this.options.model.selectItem(selectedItem);
            }
            this.show();
        },
        /**
         * Set selected item of model
         * @param {int} id
         */
        setSelectedItem: function(id){
            this.options.model.selectItem(id);
        },
        saveState: function (state) {
            AJS.$.ajax({
                url: this.url + '/' + state,
                type: "PUT",
                contentType:"application/json"
            }).error(function () {
                // Do something to let user know there is an error here
            }).done(function () {
                JIRA.trace("jira.projects.pinnablenavigator.state.updated");
            });
        },

        initialize: function() {

            this.url = AJS.contextPath() + '/rest/projects/1.0/subnav/' + this.options.id;

            this.listenTo(this.options.unpinnedView, {
                "navigatorPinned": this._renderPinned,
                "manageDialogOpenned": this._openManageDialog,
                "itemSelected": function(e) {
                    this.trigger("itemSelected", e);
                },
                "aui-dropdown2-show": function() {
                    this.trigger("aui-dropdown2-show");
                },
                "aui-dropdown2-hide": function() {
                    this.trigger("aui-dropdown2-hide");
                }
            });
            this.listenTo(this.options.pinnedView, {
                "navigatorUnPinned": this._renderUnpinned,
                "manageDialogOpenned": this._openManageDialog,
                "itemSelected": function(e) {
                    this.trigger("itemSelected", e);
                }
            });

            if (this.options.manageDialogControl) {
                this.listenTo(this.options.manageDialogControl, {
                    "itemsUpdated": this.update,
                    "manageDialogShown": _.bind(function(){
                        this.trigger("manageDialogShown");
                    },this),
                    "itemDeleted": function () {
                        this.trigger("itemDeleted");
                    },
                    "itemReordered": function () {
                        this.trigger("itemReordered");
                    }
                });
            }
        },

        show: function () {
            if (this.options.isPinned) {
                this._renderPinned();
            } else {
                this._renderUnpinned();
            }
        },
        hide: function () {
            // hide all view elements
            this.options.triggerView.$el.hide();
            this.options.unpinnedView.$el.hide();
            this.options.pinnedView.$el.hide();
        }
    });
}(AJS.$));

/**
 * This creates a Pinnable Navigator by creating and wiring together all the Views & Models required.
 *
 * A pinnable Navigator has to modes:
 *
 * Pinned - this means that the navigator and all it's contents are visible all the time. The contents of this
 * view is usually more variable to that of the Unpinned view as there is more screen real estate to play with, 
 * as such we allow the developer to specify a custom view to render the content. The pinned view is 
 * prepended to the element with the id options.pinnedHolderId. It is rendered by the Backbone.View options.pinnedView.
 *
 * UnPinned - this means the navigator contents are in a dropdown (AUI dropdown2). Unlike the pinned view, the
 * renderer is fixed as dropdown contents are more predicatable. The trigger for this dropdown is rendered to
 * options.unpinnedHolderId.
 *
 * @param {Object} options
 * ... {String) id - Unique id for this navigator, used for persistence of state & identifiying dom nodes.
 * ... {Backbone.View} pinnedView - the renderer for the pinned View
 * ... {Array[Array[Object]]} itemGroups - The groups of items to render
 * ... {String} selectedItem - The id of the item to be selected (one of the items in the itemGroups)
 * ... {String} pinnedHolderId - The id of the element where the pinned view is rendered
 * ... {String} unpinnedHolderId - The id of the element where the unpinned view is rendered
 * ... {String} triggerHolderId - The id of the element where the trigger view is rendered
 * ... {String} title - The title of manage component
 * ... {String} manageText - The title of manage button and manage Diaglog
 * ... {Function} save - The function will be executed when user press save button
 * ... {String} emptyText - The message will be shown when there is no item in navigator
 *
 * @returns {JIRA.Projects.PinnableNavigator}
 */

JIRA.Projects.PinnableNavigator.create = function (options) {

    var myOptions = {};
    var defaultOptions = {
        title: "",
        manageText: "",
        emptyText: "You have no item to view"
    };

    _.defaults(myOptions, options, defaultOptions);

    var model = new JIRA.Projects.PinnableNavigator.Entities.Items.create({
        itemGroups: myOptions.itemGroups,
        selectedItem: myOptions.selectedItem
    }, myOptions);

    var searchView = new JIRA.Projects.PinnableNavigator.Views.Search.Search({
        searchPlaceHolder: myOptions.searchPlaceHolder,
        el: myOptions.searchHolder || ".js-subnav-search-block",
        model: model
    });

    var triggerView = new JIRA.Projects.PinnableNavigator.Views.Trigger({
        model: model,
        el: AJS.$("#" + myOptions.triggerHolderId),
        id: myOptions.id,
        label: options.title
    });

    var unpinnedView = new JIRA.Projects.PinnableNavigator.Views.NavigatorView.UnpinnedView({
        model: model,
        el: AJS.$("#" + myOptions.unpinnedHolderId),
        id: myOptions.id,
        title: myOptions.title,
        manageText: myOptions.manageText,
        emptyText: myOptions.emptyText,
        searchView: searchView
    });

    var pinnedView = new JIRA.Projects.PinnableNavigator.Views.NavigatorView.PinnedView({
        model: model,
        id: myOptions.id,
        title: myOptions.title,
        manageText: myOptions.manageText,
        emptyText: myOptions.emptyText,
        searchView: searchView
    });

    var manageDialogControl = JIRA.Projects.PinnableNavigator.ManageDialog.create({
        model: model,
        title: myOptions.title,
        manageText: myOptions.manageText,
        emptyText: "This will remove all your items."
    });

    return new JIRA.Projects.PinnableNavigator({
        id: myOptions.id,
        isPinned: !!myOptions.isPinned,
        pinnedHolderId: myOptions.pinnedHolderId,
        triggerView: triggerView,
        pinnedView: pinnedView,
        unpinnedView: unpinnedView,
        manageDialogControl: manageDialogControl,
        model: model,
        triggerHolderId: myOptions.triggerHolderId,
        unpinnedHolderId: myOptions.unpinnedHolderId,
        searchView: searchView
    });
};
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/managedialog/ManageDialog.js' */
(function(){
    "use strict";
    
    /**
    * This will create a manage component which can be shown when user click on manage button
    * The component is initialized like this:
    *
    * var manageControl = JIRA.Projects.PinnableNavigator.ManageDialog({
    *     manageDialogView: manageDialogView
    * });
    *
    * On the initialization object:
    * @param {object} : A view object which content the template of dialog 2.
    *
    */

    JIRA.Projects.PinnableNavigator.ManageDialog = JIRA.Projects.Libs.Marionette.Controller.extend({

        initialize: function() {
            this.dialog = AJS.dialog2(this.options.manageDialogView.$el, {
                closeOnOutsideClick: false
            });

            this.listenTo(this.dialog, "hide", _.bind(function() {
                this.options.manageDialogView.stopLoading();
            }, this));

            this.listenTo(this.options.manageDialogView, {
                "closePopup": function () {
                    this.dialog.hide();
                },
                "itemsUpdated": function (newData) {
                    this.trigger("itemsUpdated", newData);
                },
                "itemDeleted": function () {
                    this.trigger("itemDeleted");
                },
                "itemReordered": function () {
                    this.trigger("itemReordered");
                }
            });

            this.dialog.on("show", _.bind(function() {
                JIRA.trace("jira.projects.manage.dialog.shown");
                this.trigger("manageDialogShown");
            },this));
        },

        show: function () {
            this.options.manageDialogView.render();
            this.dialog.show();
        }
    });
    /**
    * This creates a manage dialog control by creating and wiring together all the Views & Models required.
    *
    * @param {Object} options
    * ... {Object) model - Model which contain data of the view.
    * ... {String} title - The title of manage component
    * ... {String} manageText - The title of manage button and manage Diaglog
    *
    * @returns {JIRA.Projects.PinnableNavigator.ManageDialog}
    */
    JIRA.Projects.PinnableNavigator.ManageDialog.create = function (options) {

        var myOptions = {};
        var defaultOptions = {
            ManageDialogView: JIRA.Projects.PinnableNavigator.ManageDialog.Views.Dialog
        };

        _.defaults(myOptions, options, defaultOptions);

        var manageDialogView = new myOptions.ManageDialogView({
            model: myOptions.model,
            title: myOptions.title,
            manageText: myOptions.manageText,
            emptyText: myOptions.emptyText
        });

        return new JIRA.Projects.PinnableNavigator.ManageDialog({
            manageDialogView: manageDialogView
        });
    };

}(AJS.$));
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/templates/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.PinnableNavigator.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.PinnableNavigator == 'undefined') { JIRA.Projects.PinnableNavigator = {}; }
if (typeof JIRA.Projects.PinnableNavigator.Templates == 'undefined') { JIRA.Projects.PinnableNavigator.Templates = {}; }


JIRA.Projects.PinnableNavigator.Templates.unpinned = function(opt_data, opt_ignored) {
  return '<div id="subnav-opts' + ((opt_data.idSuffix) ? '-' + soy.$$escapeHtml(opt_data.idSuffix) : '') + '" class="subnav-opts aui-dropdown2 aui-style-default js-dropdown"><div class="subnav-search-block js-subnav-search-block"></div><div class="js-unpinned-items-list"></div>' + ((opt_data.isManageable && ! opt_data.isEmpty) ? '<div class="aui-dropdown2-section button-holder"><ul class="subnav-section">' + ((opt_data.manageText) ? JIRA.Projects.PinnableNavigator.Templates.unPinnedManageButton(opt_data) : JIRA.Projects.PinnableNavigator.Templates.unPinnedManageButton({manageText: "Manage" + ' ' + opt_data.title})) + '</ul></div>' : '') + '<div class="aui-dropdown2-section button-holder"><ul class="subnav-section">' + JIRA.Projects.PinnableNavigator.Templates.item({id: 'pinned', label: "Keep menu open", styleClass: 'js-pin-toggler'}) + '</ul></div></div>';
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.unpinned.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.unpinned';
}


JIRA.Projects.PinnableNavigator.Templates.unpinnedListItems = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.itemGroups && opt_data.itemGroups.length) {
    var itemGroupList29 = opt_data.itemGroups;
    var itemGroupListLen29 = itemGroupList29.length;
    for (var itemGroupIndex29 = 0; itemGroupIndex29 < itemGroupListLen29; itemGroupIndex29++) {
      var itemGroupData29 = itemGroupList29[itemGroupIndex29];
      output += (itemGroupData29.items.length) ? JIRA.Projects.PinnableNavigator.Templates.dropdownItemSection({items: itemGroupData29.items, selectedItem: opt_data.selectedItem, groupId: itemGroupData29.id}) : '';
    }
  } else {
    output += '<p class="subnav-empty-message">' + soy.$$escapeHtml(opt_data.emptyText) + '</p>';
  }
  if (opt_data.buttonGroups && opt_data.buttonGroups.length) {
    var buttonGroupList43 = opt_data.buttonGroups;
    var buttonGroupListLen43 = buttonGroupList43.length;
    for (var buttonGroupIndex43 = 0; buttonGroupIndex43 < buttonGroupListLen43; buttonGroupIndex43++) {
      var buttonGroupData43 = buttonGroupList43[buttonGroupIndex43];
      output += (buttonGroupData43.items.length) ? JIRA.Projects.PinnableNavigator.Templates.dropdownItemSection({items: buttonGroupData43.items, selectedItem: opt_data.selectedItem, groupId: buttonGroupData43.id}) : '';
    }
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.unpinnedListItems.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.unpinnedListItems';
}


JIRA.Projects.PinnableNavigator.Templates.unPinnedManageButton = function(opt_data, opt_ignored) {
  return '' + JIRA.Projects.PinnableNavigator.Templates.item({id: 'manageButton', label: opt_data.manageText, styleClass: 'js-manage-button'});
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.unPinnedManageButton.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.unPinnedManageButton';
}


JIRA.Projects.PinnableNavigator.Templates.pinnedNav = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div id="pinnednav-opts' + ((opt_data.idSuffix) ? '-' + soy.$$escapeHtml(opt_data.idSuffix) : '') + '" class=\'aui-page-panel-nav aui-style-default subnav-pinned\'><div class="subnav-header"><div class="subnav-header-buttons">' + ((opt_data.isManageable) ? JIRA.Projects.PinnableNavigator.Templates.pinnedManageButton({manageText: '' + ((opt_data.manageText) ? soy.$$escapeHtml(opt_data.manageText) : soy.$$escapeHtml("Manage" + ' ' + opt_data.title))}) : '') + '<button class="aui-button aui-button-link aui-icon aui-icon-small aui-iconfont-remove-label js-unpin-button" type="button"></button></div></div><div class="subnav-search-block js-subnav-search-block"></div><div class="js-pinned-items-list"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.pinnedNav.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.pinnedNav';
}


JIRA.Projects.PinnableNavigator.Templates.searchBlock = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<form class="aui search-form"><input type="text" ' + ((opt_data.searchPlaceHolder) ? 'placeholder="' + soy.$$escapeHtml(opt_data.searchPlaceHolder) + '"' : '') + ' class="js-subnav-filter-text text" ' + ((opt_data.searchValue) ? 'value="' + soy.$$escapeHtml(opt_data.searchValue) + '"' : '') + '><span class="aui-icon aui-icon-small aui-iconfont-search-small js-search-icon ' + ((opt_data.searchValue) ? 'hidden' : '') + '"></span><span class="aui-icon aui-icon-small aui-iconfont-remove subnav-clear-query js-clear-query ' + ((! opt_data.searchValue) ? 'hidden' : '') + '">Remove</span></form>';
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.searchBlock.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.searchBlock';
}


JIRA.Projects.PinnableNavigator.Templates.pinnedListItems = function(opt_data, opt_ignored) {
  var output = '<div class="aui-navgroup aui-navgroup-vertical"><div class="aui-navgroup-inner">';
  if (opt_data.itemGroups && opt_data.itemGroups.length) {
    var itemGroupList99 = opt_data.itemGroups;
    var itemGroupListLen99 = itemGroupList99.length;
    for (var itemGroupIndex99 = 0; itemGroupIndex99 < itemGroupListLen99; itemGroupIndex99++) {
      var itemGroupData99 = itemGroupList99[itemGroupIndex99];
      output += JIRA.Projects.PinnableNavigator.Templates.pinnedItemSection({selectedItem: opt_data.selectedItem, section: itemGroupData99, emptyText: opt_data.emptyText});
    }
  } else {
    output += '<div class="empty-group">' + soy.$$escapeHtml(opt_data.emptyText) + '</div>';
  }
  if (opt_data.buttonGroups && opt_data.buttonGroups.length) {
    var buttonGroupList111 = opt_data.buttonGroups;
    var buttonGroupListLen111 = buttonGroupList111.length;
    for (var buttonGroupIndex111 = 0; buttonGroupIndex111 < buttonGroupListLen111; buttonGroupIndex111++) {
      var buttonGroupData111 = buttonGroupList111[buttonGroupIndex111];
      output += (buttonGroupData111.items.length) ? JIRA.Projects.PinnableNavigator.Templates.buttonItemSection({items: buttonGroupData111.items, styleClass: 'isSelectable'}) : '';
    }
  }
  output += '</div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.pinnedListItems.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.pinnedListItems';
}


JIRA.Projects.PinnableNavigator.Templates.pinnedManageButton = function(opt_data, opt_ignored) {
  return '<button class="aui-button aui-button-link manage-button js-manage-button" type="button" title="' + soy.$$escapeHtml(opt_data.manageText) + '">' + soy.$$escapeHtml("Manage") + '</button>';
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.pinnedManageButton.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.pinnedManageButton';
}


JIRA.Projects.PinnableNavigator.Templates.pinnedItemSection = function(opt_data, opt_ignored) {
  return '' + ((opt_data.section.heading) ? '<div class="aui-nav-heading pinned-nav-title nav-group-items" data-group-id="' + soy.$$escapeHtml(opt_data.section.id) + '"><strong>' + soy.$$escapeHtml(opt_data.section.heading) + '</strong></div>' : '') + ((opt_data.section.items.length) ? JIRA.Projects.PinnableNavigator.Templates.navItemSection({items: opt_data.section.items, selectedItem: opt_data.selectedItem, groupId: opt_data.section.id}) : '<div class="empty-group">' + soy.$$escapeHtml(opt_data.emptyText) + '</div>');
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.pinnedItemSection.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.pinnedItemSection';
}


JIRA.Projects.PinnableNavigator.Templates.navItemSection = function(opt_data, opt_ignored) {
  var output = '<ul class="aui-nav nav-group-items" data-group-id="' + soy.$$escapeHtml(opt_data.groupId) + '">';
  var itemList147 = opt_data.items;
  var itemListLen147 = itemList147.length;
  for (var itemIndex147 = 0; itemIndex147 < itemListLen147; itemIndex147++) {
    var itemData147 = itemList147[itemIndex147];
    output += JIRA.Projects.PinnableNavigator.Templates.item({isSelected: opt_data.selectedItem == itemData147.id, id: itemData147.id, label: itemData147.label, content: itemData147.content, styleClass: itemData147.styleClass + ' isSelectable', description: itemData147.description, count: itemData147.count, link: itemData147.link});
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.navItemSection.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.navItemSection';
}


JIRA.Projects.PinnableNavigator.Templates.buttonItemSection = function(opt_data, opt_ignored) {
  var output = '<ul class="button-list">';
  var itemList161 = opt_data.items;
  var itemListLen161 = itemList161.length;
  for (var itemIndex161 = 0; itemIndex161 < itemListLen161; itemIndex161++) {
    var itemData161 = itemList161[itemIndex161];
    output += '<li>';
    var itemContent__soy163 = '' + ((itemData161.iconClass) ? '<span class="aui-icon aui-icon-small ' + soy.$$escapeHtml(itemData161.iconClass) + '"></span>' : '') + soy.$$escapeHtml(itemData161.label);
    var itemAttributes__soy170 = 'title="' + soy.$$escapeHtml(itemData161.label) + '" data-item-id="' + soy.$$escapeHtml(itemData161.id) + '" class="aui-button aui-button-subtle js-item-link ' + ((opt_data.styleClass) ? soy.$$escapeHtml(opt_data.styleClass) : '') + ' ' + ((itemData161.styleClass) ? soy.$$escapeHtml(itemData161.styleClass) : '') + '"';
    output += ((itemData161.link) ? '<a href="' + soy.$$escapeHtml(itemData161.link) + '" ' + soy.$$filterNoAutoescape(itemAttributes__soy170) + '>' + soy.$$filterNoAutoescape(itemContent__soy163) + '</a>' : '<button type="button" ' + soy.$$filterNoAutoescape(itemAttributes__soy170) + '>' + soy.$$filterNoAutoescape(itemContent__soy163) + '</button>') + '</li>';
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.buttonItemSection.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.buttonItemSection';
}


JIRA.Projects.PinnableNavigator.Templates.dropdownItemSection = function(opt_data, opt_ignored) {
  var output = '<div class="aui-dropdown2-section nav-group-items" data-group-id="' + soy.$$escapeHtml(opt_data.groupId) + '"><ul class="subnav-section">';
  var itemList210 = opt_data.items;
  var itemListLen210 = itemList210.length;
  for (var itemIndex210 = 0; itemIndex210 < itemListLen210; itemIndex210++) {
    var itemData210 = itemList210[itemIndex210];
    output += JIRA.Projects.PinnableNavigator.Templates.item({isSelected: opt_data.selectedItem == itemData210.id, id: itemData210.id, label: itemData210.label, content: itemData210.content, styleClass: itemData210.styleClass ? itemData210.styleClass + ' isSelectable' : 'isSelectable', description: itemData210.description, count: itemData210.count, link: itemData210.link});
  }
  output += '</ul></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.dropdownItemSection.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.dropdownItemSection';
}


JIRA.Projects.PinnableNavigator.Templates.item = function(opt_data, opt_ignored) {
  return '<li' + ((opt_data.description) ? ' title="' + soy.$$escapeHtml(opt_data.description) + '"' : '') + ' class="' + ((opt_data.isSelected) ? 'aui-nav-selected' : '') + '"><a class="aui-nav-item js-item-link ' + ((opt_data.styleClass) ? soy.$$escapeHtml(opt_data.styleClass) : '') + '" title="' + soy.$$escapeHtml(opt_data.label) + '" data-item-id="' + soy.$$escapeHtml(opt_data.id) + '" href="' + ((opt_data.link) ? soy.$$escapeHtml(opt_data.link) : '#') + '">' + ((opt_data.count >= 0) ? '<span class="navigator-item-label">' + soy.$$escapeHtml(opt_data.label) + '</span><span class="navigator-item-count-number" title="' + soy.$$escapeHtml(opt_data.count) + '">' + soy.$$escapeHtml(opt_data.count) + '</span>' : (opt_data.content) ? soy.$$filterNoAutoescape(opt_data.content) : soy.$$escapeHtml(opt_data.label)) + '</a></li>';
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.item.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.item';
}


JIRA.Projects.PinnableNavigator.Templates.unpinnedTrigger = function(opt_data, opt_ignored) {
  return '<button id="subnav-trigger' + ((opt_data.idSuffix) ? '-' + soy.$$escapeHtml(opt_data.idSuffix) : '') + '" class="subnav-trigger aui-button aui-dropdown2-trigger aui-button-link" aria-owns="subnav-opts' + ((opt_data.idSuffix) ? '-' + soy.$$escapeHtml(opt_data.idSuffix) : '') + '" role="menu" aria-haspopup="true">' + soy.$$escapeHtml(opt_data.label) + '</button>';
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Templates.unpinnedTrigger.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Templates.unpinnedTrigger';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/templates/search.soy' */
// This file was automatically generated from search.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.PinnableNavigator.Search.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.PinnableNavigator == 'undefined') { JIRA.Projects.PinnableNavigator = {}; }
if (typeof JIRA.Projects.PinnableNavigator.Search == 'undefined') { JIRA.Projects.PinnableNavigator.Search = {}; }
if (typeof JIRA.Projects.PinnableNavigator.Search.Templates == 'undefined') { JIRA.Projects.PinnableNavigator.Search.Templates = {}; }


JIRA.Projects.PinnableNavigator.Search.Templates.searchBlock = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<form class="aui search-form"><input type="text" ' + ((opt_data.searchPlaceHolder) ? 'placeholder="' + soy.$$escapeHtml(opt_data.searchPlaceHolder) + '"' : '') + ' class="js-subnav-filter-text text" ' + ((opt_data.searchValue) ? 'value="' + soy.$$escapeHtml(opt_data.searchValue) + '"' : '') + '><span class="aui-icon aui-icon-small aui-iconfont-search-small js-search-icon ' + ((opt_data.searchValue) ? 'hidden' : '') + '"></span><span class="aui-icon aui-icon-small aui-iconfont-remove subnav-clear-query js-clear-query ' + ((! opt_data.searchValue) ? 'hidden' : '') + '">Remove</span></form>';
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.Search.Templates.searchBlock.soyTemplateName = 'JIRA.Projects.PinnableNavigator.Search.Templates.searchBlock';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/managedialog/templates/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.PinnableNavigator.ManageDialog.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.PinnableNavigator == 'undefined') { JIRA.Projects.PinnableNavigator = {}; }
if (typeof JIRA.Projects.PinnableNavigator.ManageDialog == 'undefined') { JIRA.Projects.PinnableNavigator.ManageDialog = {}; }
if (typeof JIRA.Projects.PinnableNavigator.ManageDialog.Templates == 'undefined') { JIRA.Projects.PinnableNavigator.ManageDialog.Templates = {}; }


JIRA.Projects.PinnableNavigator.ManageDialog.Templates.dialog = function(opt_data, opt_ignored) {
  var output = '<!-- Dialog header --><header class="aui-dialog2-header"><!-- The dialog\'s title --><h2 class="aui-dialog2-header-main">' + ((opt_data.manageText) ? soy.$$escapeHtml(opt_data.manageText) : soy.$$escapeHtml("Manage" + ' ' + opt_data.title)) + '</h2><!-- Close icon --><a class="aui-dialog2-header-close"><span class="aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Close") + '</span></a></header><!-- Main dialog content --><div class="aui-dialog2-content pinnable-navigator-manage-items js-manage-contents"><div class="error-wrapper"></div>';
  var itemGroupList12 = opt_data.itemGroups;
  var itemGroupListLen12 = itemGroupList12.length;
  for (var itemGroupIndex12 = 0; itemGroupIndex12 < itemGroupListLen12; itemGroupIndex12++) {
    var itemGroupData12 = itemGroupList12[itemGroupIndex12];
    if (itemGroupData12.items.length > 0) {
      output += '<table class="aui js-item-section" data-id="' + soy.$$escapeHtml(itemGroupData12.id) + '"><tbody ' + ((itemGroupData12.allowReorder) ? ' class="js-sortable-items" ' : '') + '>';
      var itemList22 = itemGroupData12.items;
      var itemListLen22 = itemList22.length;
      for (var itemIndex22 = 0; itemIndex22 < itemListLen22; itemIndex22++) {
        var itemData22 = itemList22[itemIndex22];
        output += '<tr class="item-row js-manage-item" data-label="' + soy.$$escapeHtml(itemData22.label) + '" data-id="' + soy.$$escapeHtml(itemData22.id) + '">' + ((itemGroupData12.allowReorder) ? '<td class="item-icon"><span class="dialog-item-grip"></span></td>' : '') + '<td class="item-label"><span>' + soy.$$escapeHtml(itemData22.label) + '</span></td><td class="item-count">' + ((itemData22.count >= 0) ? '<span>' + soy.$$escapeHtml(itemData22.count) + '</span>' : '') + '</td>' + ((itemGroupData12.allowDelete) ? '<td class="item-action js-manage-item-delete-button">' + aui.buttons.button({extraClasses: 'subnav-item-delete', text: "Delete", type: 'link'}) + '</td>' : '') + '</tr>';
      }
      output += '</tbody></table>';
    }
  }
  output += '</div><!-- Dialog footer --><footer class="aui-dialog2-footer"><!-- Actions to render on the right of the footer --><div class="aui-dialog2-footer-actions"><div class="manage-spinner js-manage-save-spinner"></div>' + aui.buttons.button({text: "Save", extraClasses: 'js-manage-save-button'}) + aui.buttons.button({text: "Cancel", type: 'link', extraClasses: 'js-manage-cancel-button'}) + '</div></footer>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.ManageDialog.Templates.dialog.soyTemplateName = 'JIRA.Projects.PinnableNavigator.ManageDialog.Templates.dialog';
}


JIRA.Projects.PinnableNavigator.ManageDialog.Templates.emptyText = function(opt_data, opt_ignored) {
  return '<p class=\'js-empty\'>' + soy.$$escapeHtml(opt_data.text) + '</p>';
};
if (goog.DEBUG) {
  JIRA.Projects.PinnableNavigator.ManageDialog.Templates.emptyText.soyTemplateName = 'JIRA.Projects.PinnableNavigator.ManageDialog.Templates.emptyText';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/views/navigatorview/NavigatorView.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.PinnableNavigator.Views.NavigatorView.NavigatorView");

    JIRA.Projects.PinnableNavigator.Views.NavigatorView.NavigatorView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        ui: {
            manageButton: ".js-manage-button",
            unPinToggler: ".js-unpin-button",
            pinToggler: ".js-pin-toggler"
        },

        triggers: {
            "click @ui.unPinToggler": {
                event: "navigatorUnPinned",
                preventDefault: true,
                stopPropagation: false
            },
            "click @ui.pinToggler": {
                event: "navigatorPinned",
                preventDefault: true,
                stopPropagation: false
            },
            "click @ui.manageButton": {
                event: "manageDialogOpenned",
                preventDefault: true,
                stopPropagation: false
            }
        },

        renderSearch: function () {
            if (this.options.searchView && this.options.searchView.isSearchable()) {
                this.options.searchView.setElement(AJS.$(this.options.searchView.options.el));
                this.options.searchView.render();
            }
        },

        //Just update the list, no need to re-render hold control
        renderList: function(){
            this.listItemsView.render();
        },

        isAttachedToDom: function () {
            return !!this.$el.closest("body").length;
        },

        serializeData: function() {
            return {
                idSuffix: this.options.id || "",
                isManageable: this.model.isManageable(),
                title: this.options.title,
                manageText: this.options.manageText,
                emptyText: this.options.emptyText
            };
        },

        onRender: function() {
            this.unwrapTemplate();
        }
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/views/navigatorview/PinnedView.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.PinnableNavigator.Views.NavigatorView.PinnedView");

    JIRA.Projects.PinnableNavigator.Views.NavigatorView.PinnedView = JIRA.Projects.PinnableNavigator.Views.NavigatorView.NavigatorView.extend({
        template: JIRA.Projects.PinnableNavigator.Templates.pinnedNav,

        initialize: function() {
            this.listItemsView = new JIRA.Projects.PinnableNavigator.Views.ListView.PinnedListView({
                model: this.options.model,
                id: this.options.id || "",
                title: this.options.title,
                manageText: this.options.manageText,
                emptyText: this.options.emptyText,
                tooltipTimeout: this.options.tooltipTimeout,
                searchView: this.options.searchView
            });

            this.listenTo(this.listItemsView, "itemSelected", function(data){
                this.trigger("itemSelected", data);
            });
        },
        //Add the list to this component
        putListintoView: function(){
            this.listItemsView.setElement(this.$(".js-pinned-items-list"));
            this.renderList();
        },

        unpin: function() {
            this.$el.remove();
        }
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/views/navigatorview/UnpinnedView.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.PinnableNavigator.Views.NavigatorView.UnpinnedView");

    JIRA.Projects.PinnableNavigator.Views.NavigatorView.UnpinnedView = JIRA.Projects.PinnableNavigator.Views.NavigatorView.NavigatorView.extend({
        template: JIRA.Projects.PinnableNavigator.Templates.unpinned,

        initialize: function() {
            this.listItemsView = new JIRA.Projects.PinnableNavigator.Views.ListView.UnpinnedListView({
                model: this.options.model,
                id: this.options.id || "",
                title: this.options.title,
                manageText: this.options.manageText,
                emptyText: this.options.emptyText,
                tooltipTimeout: this.options.tooltipTimeout,
                searchView: this.options.searchView
            });

            this.listenTo(this.listItemsView, "itemSelected", function(data){
                this.trigger("itemSelected", data);
            });
        },
        //Add the list to this component
        putListintoView: function(){
            this.listItemsView.setElement(this.$(".js-unpinned-items-list"));
            this.renderList();
        }
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/views/listview/ListView.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.PinnableNavigator.Views.ListView.ListView");

    JIRA.Projects.PinnableNavigator.Views.ListView.ListView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        tooltipTimer: null,
        ui: {
            item: "li",
            link: ".js-item-link.isSelectable",
            dropdownTwoHide: "aui-dropdown2-hide"
        },

        events: {
            "click @ui.link": function(e) {
                this._hideTooltips();
                var item = AJS.$(e.currentTarget).data("item-id");
                this._processNavItem(item, e);
            },
            "mouseenter @ui.item": function(ev) {
                this._hideTooltips();
                this.tooltipTimer = setTimeout(function() {
                    AJS.$(ev.currentTarget).tipsy("show");
                }, this.tooltipTimeout);
            },
            "mouseleave @ui.item": "_hideTooltips",
            "@ui.dropdownTwoHide": "_hideTooltips"
        },

        initialize: function () {
            this.tooltipTimeout = this.options.tooltipTimeout || 600;

            if (this.options.searchView) {
                this.listenTo(this.options.searchView, {
                    "doQuery": this.render
                });
            }
        },

        _hideTooltips: function () {
            clearTimeout(this.tooltipTimer);
            AJS.$(".tipsy").remove();
        },

        _processNavItem: function(itemId, e){
            this.model.selectItem(itemId);

            var item = this.model.get("selectedItem");
            var event = this.triggerPreventable("itemSelected", {
                item: item
            });
            if (event.isPrevented) {
                e.preventDefault();
            }
        },

        serializeData: function () {
            var selectedItem = this.model.get("selectedItem");

            var searchValue;
            if (this.options.searchView) {
                searchValue = this.options.searchView.getQuery();
            } else {
                searchValue = "";
            }

            var groups = _.groupBy(this.model.getAllItemsWithName(searchValue), function(group) {
                return group.type;
            });

            var currentId = null;
            if(selectedItem){
                currentId = selectedItem.id;
            }

            return {
                itemGroups: groups["undefined"],
                buttonGroups: groups.buttons,
                selectedItem: currentId,
                emptyText: this.options.emptyText
            };
        },

        onRender: function () {
            this._hideTooltips();
            /*
             * AUI's tooltip shows automatically by default.
             * On that mode, whenever the mouse enters the DOM element, a timeout will be scheduled to show the tooltip.
             * The problem with that is that they don't provide any way for us to cancel the timer once the mouse leaves.
             *
             * To solve this problem we are going to use AUI's tooltip in manual mode and we are going to be
             * in control of scheduling the tooltips and canceling them when the mouse enters/leaves the different options.
             */
            AJS.$(this.ui.item).tooltip({gravity: "w", trigger: "manual"});
        }
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/views/listview/PinnedListView.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.PinnableNavigator.Views.ListView.PinnedListView");

    JIRA.Projects.PinnableNavigator.Views.ListView.PinnedListView = JIRA.Projects.PinnableNavigator.Views.ListView.ListView.extend({
        template: JIRA.Projects.PinnableNavigator.Templates.pinnedListItems
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/views/listview/UnpinnedListView.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.PinnableNavigator.Views.ListView.UnpinnedListView");

    JIRA.Projects.PinnableNavigator.Views.ListView.UnpinnedListView = JIRA.Projects.PinnableNavigator.Views.ListView.ListView.extend({
        template: JIRA.Projects.PinnableNavigator.Templates.unpinnedListItems
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/views/search/Search.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.PinnableNavigator.Views.Search.Search");

    JIRA.Projects.PinnableNavigator.Views.Search.Search = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.PinnableNavigator.Search.Templates.searchBlock,
        ui: {
            searchInput: "input.js-subnav-filter-text",
            searchIcon: ".js-search-icon",
            clearIcon: ".js-clear-query"
        },

        events: {
            "keydown @ui.searchInput": "query",
            "click @ui.clearIcon": "clearQuery"
        },

        _numberIsNeededToShowTheList: 10,

        _searchValue: "",

        isSearchable: function () {
            return JIRA.Projects.PinnableNavigator.Search.isEnabled() && this.model.getAllItemsExceptButtons().length >= this._numberIsNeededToShowTheList;
        },

        isExisted: function () {
            return this.$el.closest("body").length;
        },

        getQuery: function () {
            if (this.isExisted()) {
                this._searchValue = AJS.$.trim(this.ui.searchInput.val());
            } else {
                this._searchValue = "";
            }

            return this._searchValue;
        },

        clearQuery: function () {
            if (this.isExisted()) {
                this._searchValue = "";
                this.ui.searchInput.val(this._searchValue).trigger("keydown");
            }
        },

        query: function () {
            setTimeout(_.bind(function(){
                this._searchValue = this.getQuery();
                if (this._searchValue !== "") {
                    this.ui.clearIcon.removeClass("hidden");
                    this.ui.searchIcon.addClass("hidden");
                } else {
                    this.ui.clearIcon.addClass("hidden");
                    this.ui.searchIcon.removeClass("hidden");
                }
                this.trigger("doQuery", this._searchValue);
            }, this), 0);
        },

        serializeData: function() {
            return {
                searchValue: this._searchValue,
                searchPlaceHolder: this.options.searchPlaceHolder
            };
        }
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/views/Trigger.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.PinnableNavigator.Views.Trigger");

    JIRA.Projects.PinnableNavigator.Views.Trigger = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.PinnableNavigator.Templates.unpinnedTrigger,

        serializeData: function() {
            // Always show the button, so user can open dropdown menu and add more items
            var selectedItem = this.model.get("selectedItem");
            var switchText = "Switch";
            var label = selectedItem ? selectedItem.label : switchText;
            if (this.options.label) {
                label = switchText + ' ' + this.options.label;
            }
            return {
                label: label,
                idSuffix: this.options.id || ""
            };
        },
        onRender: function() {
            this.unwrapTemplate();
        }
    });

}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/managedialog/views/Dialog.js' */
(function($){
    "use strict";

    AJS.namespace("JIRA.Projects.PinnableNavigator.ManageDialog.Views.Dialog");

    JIRA.Projects.PinnableNavigator.ManageDialog.Views.Dialog = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.PinnableNavigator.ManageDialog.Templates.dialog,
        tagName: "section",
        attributes: {
            "class": "aui-layer aui-dialog2 aui-dialog2-small manage-subnav-dialog",
            "aria-hidden": true,
            "role": "dialog",
            "data-aui-modal": true
        },
        ui: {
            loading: ".js-manage-save-spinner",
            saveButton: ".js-manage-save-button",
            cancelButton: ".js-manage-cancel-button",
            deleteButton: ".js-manage-item-delete-button button",
            manageItem: ".js-manage-item",
            manageDialogContents: ".js-manage-contents",
            itemSections: ".js-item-section"
        },
        triggers: {
            "click @ui.cancelButton": {
                event: "closePopup",
                preventDefault: true,
                stopPropagation: false
            }
        },
        events: {
            // event used for testing
            "moveToEnd @ui.manageItem" : function (e) {
                var $target = this.$(e.currentTarget);
                $target.appendTo($target.parent());
            },

            "click @ui.deleteButton": function(e) {
                e.preventDefault();
                var $currentEl = this.$(e.currentTarget);
                var $elNeedToBeDeleted = $currentEl.parents("tr");
                //Remove out of DOM
                $elNeedToBeDeleted.addClass("js-deleted hidden");
                this.checkRemainItems();
            },
            "click @ui.saveButton": function(e) {

                this.showLoading();

                var itemDeleted = false;
                var itemReOrdered = false;

                var modifications = this.ui.itemSections.map(function () {
                    var $this = $(this);

                    // Get the deleted items list
                    var deletedItems = _.map($this.find(".js-deleted"), function(item){
                        return $(item).data("id");
                    });
                    // Get the remained items list after deleting some items
                    var itemOrder = _.map($this.find("tr:not(.js-deleted)"), function (item) {
                        return $(item).data("id");
                    });

                    return {
                        id: $this.data("id"),
                        deleted: deletedItems,
                        order: itemOrder
                    };
                });

                if (_.find(modifications, function(group) {return group.deleted.length;})) {
                    itemDeleted = true;
                }
                if (_.find(modifications, function(group) {return group.order.length;})) {
                    itemReOrdered = true;
                }

                this.model.save(modifications)
                    .done(_.bind(function(newData){
                        this.trigger("closePopup", newData);
                        if (itemDeleted) {
                            this.trigger("itemDeleted");
                        }
                        if (itemReOrdered) {
                            this.trigger("itemReordered");
                        }
                    },this))
                    .fail(_.bind(function(error){
                        var errorHolder = this.$(".error-wrapper");
                        errorHolder.html("");
                        AJS.messages.error(errorHolder, {
                            "closeable": false,
                            "body": error.statusText
                        });
                    },this)).always(_.bind(function(){
                        this.stopLoading();
                    },this));

                e.preventDefault();
            }
        },
        onRender: function(){
            this.$(".js-sortable-items").sortable({
                placeholder: "item-holder-highlight item-row js-manage-item",
                sort: function( event, ui ) {
                    ui.placeholder.html(ui.helper.html());
                }
            });
        },
        checkRemainItems: function(){
            if(this.$(".js-manage-item").length <= this.$(".js-deleted").length) {
                this.ui.manageDialogContents.append(JIRA.Projects.PinnableNavigator.ManageDialog.Templates.emptyText({
                    text: this.options.emptyText
                }));
            } else {
                this.$(".js-empty").remove();
            }
        },
        showLoading: function(){
            this.ui.loading.spin();
        },
        stopLoading: function(){
            this.ui.loading.spinStop();
        },
        serializeData: function() {
            var itemGroups = this.model.getManageableItemGroups();
            return {
                itemGroups: itemGroups,
                title: this.options.title,
                manageText: this.options.manageText
            };
        }
    });
}(AJS.$));
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/dark-feature.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.PinnableNavigator.Search");

    JIRA.Projects.PinnableNavigator.Search.isEnabled = function ()  {
        return AJS.DarkFeatures.isEnabled("com.atlassian.jira.projects.PinnableNavigator.Search");
    };
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:pinnablenavigator', location = '/static/components/pinnablenavigator/entities/Items.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Projects.PinnableNavigator.Entities.Items");

    JIRA.Projects.PinnableNavigator.Entities.Items = Backbone.Model.extend({
        defaults: {
            itemGroups: [],
            selectedItem: null
        },

        initialize: function() {
            if(this.attributes.selectedItem) {
                this.selectItem(this.attributes.selectedItem);
            }
        },

        hasDisplayableGroups: function (itemGroups) {
            itemGroups = itemGroups || this.get("itemGroups");
            return _.any(itemGroups, function (group) {
                if (group.type === "buttons") {
                    return false;
                } else {
                    return group.emptyText || group.items && group.items.length;
                }
            });
        },

        isManageable: function () {
            return !!_.flatten(_.pluck(this.getManageableItemGroups(), "items")).length;
        },

        getManageableItemGroups: function () {
            return _.filter(this.get("itemGroups"), function (group) {
                return group.allowDelete || group.allowReorder;
            });
        },

        isEmpty: function() {
            return _.isEmpty(this.getAllItems());
        },

        selectItem: function(itemId) {
            var items = this.getAllItems();
            this.set("selectedItem",  this.getItemById(itemId) || _.first(items));
        },

        getItemById: function (itemId) {
            return _.findWhere(this.getAllItems(), {id: itemId});
        },

        getAllItems: function() {
            return _.flatten(_.map(this.get("itemGroups"), function (group) {
                return group.items;
            }));
        },

        getAllItemsExceptButtons: function() {
            return _.compact(_.flatten(_.map(this.get("itemGroups"), function (group) {
                return group.type === "buttons"? null: group.items;
            })));
        },

        getAllItemsWithName: function(searchedValue) {
            // Clone new object, so we can save the orginal and do filter on clone one
            var itemGroups = AJS.$.extend(true, {}, this.get("itemGroups"));

            return _.compact(_.map(itemGroups, function (group) {
                if (group.type !== "buttons") {
                    group.items = _.filter(group.items, function (item) {
                        return item.label.toUpperCase().indexOf(searchedValue.toUpperCase()) > -1;
                    });
                }
                if (!group.items.length) {
                    return null;
                }
                return group;
            }));
        },

        getGroup: function (id) {
            return _.findWhere(this.get("itemGroups"), {id: id});
        },

        applyModifications: function (modifications) {
            _.each(modifications, function (group) {
                var currentGroup = this.getGroup(group.id);
                currentGroup.items = _.map(group.order, function (id) {
                    return this.getItemById(id);
                }, this);
            }, this);
        }
    });

    JIRA.Projects.PinnableNavigator.Entities.Items.create = function (props, options) {
        var model = new JIRA.Projects.PinnableNavigator.Entities.Items(props);
        if (options.save) {
            model.save = function (modifications) {
                return options.save(modifications).done(function () {
                    model.applyModifications(modifications);
                    JIRA.trace("jira.projects.items.updated");
                });
            };
        }
        return model;
    };

}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:reports-page-subnavigator', location = '/page/project/report/subnavigator-init.js' */
(function($) {
    "use strict";

    function emitAnalyticsEvent(reportId, initialLoad) {
        AJS.trigger('analyticsEvent', {
            name: "jira.project.sidebar.report.select",
            data: {
                reportId: reportId,
                initialLoad: initialLoad
            }
        });
    }

    $(function() {
        var triggerPlaceholder = $("#reports-subnav-trigger");
        var contentPlaceholder = $("#reports-subnav-opts");
        var titlePlaceholder = $("#reports-subnav-title");
        var agileReports = _.map(WRM.data.claim("agile-reports"), function(report) {
            return {
                id: report.key,
                label: report.label,
                description: report.description,
                link: AJS.contextPath() + report.url
            };
        });

        var subnavigator = new JIRA.Projects.Subnavigator({
            id: "reports",
            triggerPlaceholder: triggerPlaceholder,
            contentPlaceholder: contentPlaceholder,
            itemGroups: [agileReports, [{
                id: "com.atlassian.jira.jira-projects-plugin:report-page",
                label: "All reports",
                description: "Show the reports overview page, which lists all available reports"
            }]],
            selectedItem: "com.atlassian.jira.jira-projects-plugin:report-page",
            titlePlaceholder: titlePlaceholder,
            hideSelectedItem: true,
            changeViewText: "Switch report"
        });
        subnavigator.on('itemSelected', function(e) {
            emitAnalyticsEvent(e.item.id, false);
        });

        subnavigator.show();

        emitAnalyticsEvent('com.atlassian.jira.jira-projects-plugin:report-page', true);

        JIRA.API.getSidebar().done(function() {
            JIRA.Projects.Sidebar.Reports.storeLastViewedReportLink(window.location.href);
        });
    });

}(AJS.$));
;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/rpc.js' */
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Remote procedure call library for gadget-to-container,
 * container-to-gadget, and gadget-to-gadget (thru container) communication.
 *
 *
 */

var gadgets = gadgets || {};

/**
 * @static
 * @class Provides operations for making rpc calls.
 * @name gadgets.rpc
 */
gadgets.rpc = function() {
  // General constants.
  var CALLBACK_NAME = '__cb';
  var DEFAULT_NAME = '';

  // Consts for FrameElement.
  var FE_G2C_CHANNEL = '__g2c_rpc';
  var FE_C2G_CHANNEL = '__c2g_rpc';

  var services = {};
  var iframePool = [];
  var relayUrl = {};
  var useLegacyProtocol = {};
  var authToken = {};
  var callId = 0;
  var callbacks = {};
  var setup = {};
  var sameDomain = {};

  var params = {};

  // Load the authentication token for speaking to the container
  // from the gadget's parameters, or default to '0' if not found.
  if (gadgets.util) {
    params = gadgets.util.getUrlParameters();
  }

  authToken['..'] = params.rpctoken || params.ifpctok || 0;

  /*
   * Return a short code representing the best available cross-domain
   * message transport available to the browser.
   *
   * + For those browsers that support native messaging (various implementations
   *   of the HTML5 postMessage method), use that. Officially defined at
   *   http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html.
   *
   *   postMessage is a native implementation of XDC. A page registers that
   *   it would like to receive messages by listening the the "message" event
   *   on the window (document in DPM) object. In turn, another page can
   *   raise that event by calling window.postMessage (document.postMessage
   *   in DPM) with a string representing the message and a string
   *   indicating on which domain the receiving page must be to receive
   *   the message. The target page will then have its "message" event raised
   *   if the domain matches and can, in turn, check the origin of the message
   *   and process the data contained within.
   *
   *     wpm: postMessage on the window object.
   *        - Internet Explorer 8+
   *        - Safari (latest nightlies as of 26/6/2008)
   *        - Firefox 3+
   *        - Opera 9+
   *
   *     dpm: postMessage on the document object.
   *        - Opera 8+
   *
   * + For Gecko-based browsers, the security model allows a child to call a
   *   function on the frameElement of the iframe, even if the child is in
   *   a different domain. This method is dubbed "frameElement" (fe).
   *
   *   The ability to add and call such functions on the frameElement allows
   *   a bidirectional channel to be setup via the adding of simple function
   *   references on the frameElement object itself. In this implementation,
   *   when the container sets up the authentication information for that gadget
   *   (by calling setAuth(...)) it as well adds a special function on the
   *   gadget's iframe. This function can then be used by the gadget to send
   *   messages to the container. In turn, when the gadget tries to send a
   *   message, it checks to see if this function has its own function stored
   *   that can be used by the container to call the gadget. If not, the
   *   function is created and subsequently used by the container.
   *   Note that as a result, FE can only be used by a container to call a
   *   particular gadget *after* that gadget has called the container at
   *   least once via FE.
   *
   *     fe: Gecko-specific frameElement trick.
   *        - Firefox 1+
   *
   * + For all others, we have a fallback mechanism known as "ifpc". IFPC
   *   exploits the fact that while same-origin policy prohibits a frame from
   *   accessing members on a window not in the same domain, that frame can,
   *   however, navigate the window heirarchy (via parent). This is exploited by
   *   having a page on domain A that wants to talk to domain B create an iframe
   *   on domain B pointing to a special relay file and with a message encoded
   *   after the hash (#). This relay, in turn, finds the page on domain B, and
   *   can call a receipt function with the message given to it. The relay URL
   *   used by each caller is set via the gadgets.rpc.setRelayUrl(..) and
   *   *must* be called before the call method is used.
   *
   *     ifpc: Iframe-based method, utilizing a relay page, to send a message.
   */
  function getRelayChannel() {
    return typeof window.postMessage === 'function' ? 'wpm' :
        typeof document.postMessage === 'function' ? 'dpm' :
            navigator.product === 'Gecko' ? 'fe' :
                'ifpc';
  }

  /**
   * Conducts any initial global work necessary to setup the
   * channel type chosen.
   */
  function setupChannel() {
    // If the channel type is one of the native
    // postMessage based ones, setup the handler to receive
    // messages.
    if (relayChannel === 'dpm' || relayChannel === 'wpm') {
      window.addEventListener('message', function(packet) {
        // JRA-36335: Anyone could be publishing a 'message' so need to make sure
        // we handle errors more gracefully in case the packet doesn't contain what
        // was expected
        try {
          if (packet && packet.origin && packet.origin !== "null" && typeof packet.data === 'string' ) {
            AJS.$.get(AJS.contextPath() + '/rest/whitelist/1/check', {url: packet.origin})
                .done(function (result) {
                  if (result && result.inbound && result.inbound === true) {
                    process(gadgets.json.parse(packet.data));
                  }
                  else {
                    if(AJS.debug) {
                      AJS.log("RPC: request rejected (bad origin): " + (packet && packet.origin ? packet.origin : "undefined origin"));
                    }
                  }
                })
                .fail(function (jqXHR, textStatus, errorThrown) {
                  AJS.log('RPC: REST ' + textStatus, errorThrown);
                });
          } else {
            if(AJS.debug) {
              AJS.log("RPC: request rejected (bad origin): " + (packet && packet.origin ? packet.origin : "undefined origin"));
            }
          }
        } catch (e) {
          if (AJS.debug) {
            var origin = packet && packet.origin ? packet.origin : "undefined origin";
            AJS.log("Error processing gadget rpc message from '" + origin + "': " + e);
          }
        }
      }, false);
    }
  }

  // Pick the most efficient RPC relay mechanism
  var relayChannel = getRelayChannel();

  // Conduct any setup necessary for the chosen channel.
  setupChannel();

  // Create the Default RPC handler.
  services[DEFAULT_NAME] = function() {
    throw new Error('Unknown RPC service: ' + this.s);
  };

  // Create a Special RPC handler for callbacks.
  services[CALLBACK_NAME] = function(callbackId, result) {
    var callback = callbacks[callbackId];
    if (callback) {
      delete callbacks[callbackId];
      callback(result);
    }
  };

  /**
   * Conducts any frame-specific work necessary to setup
   * the channel type chosen. This method is called when
   * the container page first registers the gadget in the
   * RPC mechanism. Gadgets, in turn, will complete the setup
   * of the channel once they send their first messages.
   */
  function setupFrame(frameId) {
    if (setup[frameId]) {
      return;
    }

    if (relayChannel === 'fe') {
      try {
        var frame = document.getElementById(frameId);
        frame[FE_G2C_CHANNEL] = function(args) {
          process(gadgets.json.parse(args));
        };
      } catch (e) {
        // Something went wrong. System will fallback to
        // IFPC.
      }
    }

    setup[frameId] = true;
  }

  /**
   * Encodes arguments for the legacy IFPC wire format.
   *
   * @param {Object} args
   * @return {String} the encoded args
   */
  function encodeLegacyData(args) {
    var stringify = gadgets.json.stringify;
    var argsEscaped = [];
    for(var i = 0, j = args.length; i < j; ++i) {
      argsEscaped.push(encodeURIComponent(stringify(args[i])));
    }
    return argsEscaped.join('&');
  }

  /**
   * Helper function to process an RPC request
   * @param {Object} rpc RPC request object
   * @private
   */
  function process(rpc) {
    //
    // RPC object contents:
    //   s: Service Name
    //   f: From
    //   c: The callback ID or 0 if none.
    //   a: The arguments for this RPC call.
    //   t: The authentication token.
    //
    if (rpc && typeof rpc.s === 'string' && typeof rpc.f === 'string' &&
        rpc.a instanceof Array) {

      // Validate auth token.
      if (authToken[rpc.f]) {
        // We allow type coercion here because all the url params are strings.
        if (authToken[rpc.f] != rpc.t) {
          if (AJS.debug) {
            console.log('Invalid auth token received for operation: ' + rpc.s);
          }
          return;
        }
      }

      // If there is a callback for this service, attach a callback function
      // to the rpc context object for asynchronous rpc services.
      //
      // Synchronous rpc request handlers should simply ignore it and return a
      // value as usual.
      // Asynchronous rpc request handlers, on the other hand, should pass its
      // result to this callback function and not return a value on exit.
      //
      // For example, the following rpc handler passes the first parameter back
      // to its rpc client with a one-second delay.
      //
      // function asyncRpcHandler(param) {
      //   var me = this;
      //   setTimeout(function() {
      //     me.callback(param);
      //   }, 1000);
      // }
      if (rpc.c) {
        rpc.callback = function(result) {
          gadgets.rpc.call(rpc.f, CALLBACK_NAME, null, rpc.c, result);
        };
      }

      // Call the requested RPC service.
      var result = (services[rpc.s] ||
      services[DEFAULT_NAME]).apply(rpc, rpc.a);

      // If the rpc request handler returns a value, immediately pass it back
      // to the callback. Otherwise, do nothing, assuming that the rpc handler
      // will make an asynchronous call later.
      if (rpc.c && typeof result != 'undefined') {
        gadgets.rpc.call(rpc.f, CALLBACK_NAME, null, rpc.c, result);
      }
    }
  }

  /**
   * Attempts to conduct an RPC call to the specified
   * target with the specified data via the FrameElement
   * method. If this method fails, the system attempts again
   * using the known default of IFPC.
   *
   * @param {String} targetId Module Id of the RPC service provider.
   * @param {String} serviceName Service name to call.
   * @param {String} from Module Id of the calling provider.
   * @param {Object} rpcData The RPC data for this call.
   * @param {Array.<Object>} callArgs Original arguments to call()
   */
  function callFrameElement(targetId, serviceName, from, rpcData, callArgs) {
    try {
      if (from != '..') {
        // Call from gadget to the container.
        var fe = window.frameElement;

        if (typeof fe[FE_G2C_CHANNEL] === 'function') {
          // Complete the setup of the FE channel if need be.
          if (typeof fe[FE_G2C_CHANNEL][FE_C2G_CHANNEL] !== 'function') {
            fe[FE_G2C_CHANNEL][FE_C2G_CHANNEL] = function(args) {
              process(gadgets.json.parse(args));
            };
          }

          // Conduct the RPC call.
          fe[FE_G2C_CHANNEL](rpcData);
          return;
        }
      } else {
        // Call from container to gadget[targetId].
        var frame = document.getElementById(targetId);

        if (typeof frame[FE_G2C_CHANNEL] === 'function' &&
            typeof frame[FE_G2C_CHANNEL][FE_C2G_CHANNEL] === 'function') {

          // Conduct the RPC call.
          frame[FE_G2C_CHANNEL][FE_C2G_CHANNEL](rpcData);
          return;
        }
      }
    } catch (e) {
    }

    // If we have reached this point, something has failed
    // with the FrameElement method, so we default to using
    // IFPC for this call.
    callIfpc(targetId, serviceName, from, rpcData, callArgs);
  }

  /**
   * Conducts an RPC call to the specified
   * target with the specified data via the IFPC
   * method.
   *
   * @param {String} targetId Module Id of the RPC service provider.
   * @param {String} serviceName Service name to call.
   * @param {String} from Module Id of the calling provider.
   * @param {Object} rpcData The RPC data for this call.
   * @param {Array.<Object>} callArgs Original arguments to call()
   */
  function callIfpc(targetId, serviceName, from, rpcData, callArgs) {
    // Retrieve the relay file used by IFPC. Note that
    // this must be set before the call, and so we conduct
    // an extra check to ensure it is not blank.
    var relay = gadgets.rpc.getRelayUrl(targetId);

    if (!relay) {
      throw new Error('No relay file assigned for IFPC');
    }

    // The RPC mechanism supports two formats for IFPC (legacy and current).
    var src = null;
    if (useLegacyProtocol[targetId]) {
      // Format: #iframe_id&callId&num_packets&packet_num&block_of_data
      src = [relay, '#', encodeLegacyData([from, callId, 1, 0,
        encodeLegacyData([from, serviceName, '', '', from].concat(
            callArgs))])].join('');
    } else {
      // Format: #targetId & sourceId@callId & packetNum & packetId & packetData
      src = [relay, '#', targetId, '&', from, '@', callId,
        '&1&0&', encodeURIComponent(rpcData)].join('');
    }

    // Conduct the IFPC call by creating the Iframe with
    // the relay URL and appended message.
    emitInvisibleIframe(src);
  }


  /**
   * Helper function to emit an invisible IFrame.
   * @param {String} src SRC attribute of the IFrame to emit.
   * @private
   */
  function emitInvisibleIframe(src) {
    var iframe;
    // Recycle IFrames
    for (var i = iframePool.length - 1; i >=0; --i) {
      var ifr = iframePool[i];
      try {
        if (ifr && (ifr.recyclable || ifr.readyState === 'complete')) {
          ifr.parentNode.removeChild(ifr);
          if (window.ActiveXObject) {
            // For MSIE, delete any iframes that are no longer being used. MSIE
            // cannot reuse the IFRAME because a navigational click sound will
            // be triggered when we set the SRC attribute.
            // Other browsers scan the pool for a free iframe to reuse.
            iframePool[i] = ifr = null;
            iframePool.splice(i, 1);
          } else {
            ifr.recyclable = false;
            iframe = ifr;
            break;
          }
        }
      } catch (e) {
        // Ignore; IE7 throws an exception when trying to read readyState and
        // readyState isn't set.
      }
    }
    // Create IFrame if necessary
    if (!iframe) {
      iframe = document.createElement('iframe');
      iframe.style.border = iframe.style.width = iframe.style.height = '0px';
      iframe.style.visibility = 'hidden';
      iframe.style.position = 'absolute';
      iframe.onload = function() { this.recyclable = true; };
      iframePool.push(iframe);
    }
    iframe.src = src;
    setTimeout(function() { document.body.appendChild(iframe); }, 0);
  }

  /**
   * Attempts to make an rpc by calling the target's receive method directly.
   * This works when gadgets are rendered on the same domain as their container,
   * a potentially useful optimization for trusted content which keeps
   * RPC behind a consistent interface.
   * @param {String} target Module id of the rpc service provider
   * @param {String} from Module id of the caller (this)
   * @param {String} callbackId Id of the call
   * @param {String} rpcData JSON-encoded RPC payload
   * @return
   */
  function callSameDomain(target, rpc) {
    if (typeof sameDomain[target] === 'undefined') {
      // Seed with a negative, typed value to avoid
      // hitting this code path repeatedly
      sameDomain[target] = false;
      var targetEl = null;
      if (target === '..') {
        targetEl = parent;
      } else {
        targetEl = frames[target];
      }
      try {
        // If this succeeds, then same-domain policy applied
        sameDomain[target] = targetEl.gadgets.rpc.receiveSameDomain;
      } catch (e) {
        // Usual case: different domains
      }
    }

    if (typeof sameDomain[target] === 'function') {
      // Call target's receive method
      sameDomain[target](rpc);
      return true;
    }

    return false;
  }

  // gadgets.config might not be available, such as when serving container js.
  if (gadgets.config) {
    /**
     * Initializes RPC from the provided configuration.
     */
    function init(config) {
      // Allow for wild card parent relay files as long as it's from a
      // white listed domain. This is enforced by the rendering servlet.
      if (config.rpc.parentRelayUrl.substring(0, 7) === 'http://') {
        relayUrl['..'] = config.rpc.parentRelayUrl;
      } else {
        // It's a relative path, and we must append to the parent.
        // We're relying on the server validating the parent parameter in this
        // case. Because of this, parent may only be passed in the query, not
        // the fragment.
        var params = document.location.search.substring(0).split("&");
        var parentParam = "";
        for (var i = 0, param; param = params[i]; ++i) {
          // Only the first parent can be validated.
          if (param.indexOf("parent=") === 0) {
            parentParam = decodeURIComponent(param.substring(7));
            break;
          }
        }
        relayUrl['..'] = parentParam + config.rpc.parentRelayUrl;
      }
      useLegacyProtocol['..'] = !!config.rpc.useLegacyProtocol;
    }

    var requiredConfig = {
      parentRelayUrl : gadgets.config.NonEmptyStringValidator
    };
    gadgets.config.register("rpc", requiredConfig, init);
  }

  return /** @scope gadgets.rpc */ {
    /**
     * Registers an RPC service.
     * @param {String} serviceName Service name to register.
     * @param {Function} handler Service handler.
     *
     * @member gadgets.rpc
     */
    register: function(serviceName, handler) {
      if (serviceName == CALLBACK_NAME) {
        throw new Error("Cannot overwrite callback service");
      }

      if (serviceName == DEFAULT_NAME) {
        throw new Error("Cannot overwrite default service:"
            + " use registerDefault");
      }

      services[serviceName] = handler;
    },

    /**
     * Unregisters an RPC service.
     * @param {String} serviceName Service name to unregister.
     *
     * @member gadgets.rpc
     */
    unregister: function(serviceName) {
      if (serviceName == CALLBACK_NAME) {
        throw new Error("Cannot delete callback service");
      }

      if (serviceName == DEFAULT_NAME) {
        throw new Error("Cannot delete default service:"
            + " use unregisterDefault");
      }

      delete services[serviceName];
    },

    /**
     * Registers a default service handler to processes all unknown
     * RPC calls which raise an exception by default.
     * @param {Function} handler Service handler.
     *
     * @member gadgets.rpc
     */
    registerDefault: function(handler) {
      services[''] = handler;
    },

    /**
     * Unregisters the default service handler. Future unknown RPC
     * calls will fail silently.
     *
     * @member gadgets.rpc
     */
    unregisterDefault: function() {
      delete services[''];
    },

    /**
     * Calls an RPC service.
     * @param {String} targetId Module Id of the RPC service provider.
     *                          Empty if calling the parent container.
     * @param {String} serviceName Service name to call.
     * @param {Function|null} callback Callback function (if any) to process
     *                                 the return value of the RPC request.
     * @param {*} var_args Parameters for the RPC request.
     *
     * @member gadgets.rpc
     */
    call: function(targetId, serviceName, callback, var_args) {
      ++callId;
      targetId = targetId || '..';
      if (callback) {
        callbacks[callId] = callback;
      }

      // Default to the container calling.
      var from = '..';

      if (targetId === '..') {
        from = window.name;
      }

      // Not used by legacy, create it anyway...
      var rpc = {
        s: serviceName,
        f: from,
        c: callback ? callId : 0,
        a: Array.prototype.slice.call(arguments, 3),
        t: authToken[targetId]
      };

      // If target is on the same domain, call method directly
      if (callSameDomain(targetId, rpc)) {
        return;
      }

      var rpcData = gadgets.json.stringify(rpc);

      var channelType = relayChannel;

      // If we are told to use the legacy format, then we must
      // default to IFPC.
      if (useLegacyProtocol[targetId]) {
        channelType = 'ifpc';
      }

      switch (channelType) {
        case 'dpm': // use document.postMessage.
          var targetDoc = targetId === '..' ? parent.document :
              frames[targetId].document;
          targetDoc.postMessage(rpcData);
          break;

        case 'wpm': // use window.postMessage.
          var targetWin = targetId === '..' ? parent : frames[targetId];
          targetWin.postMessage(rpcData, relayUrl[targetId]);
          break;

        case 'fe': // use FrameElement.
          callFrameElement(targetId, serviceName, from, rpcData, rpc.a);
          break;

        default: // use 'ifpc' as a fallback mechanism.
          callIfpc(targetId, serviceName, from, rpcData, rpc.a);
          break;
      }
    },

    /**
     * Gets the relay URL of a target frame.
     * @param {String} targetId Name of the target frame.
     * @return {String|undefined} Relay URL of the target frame.
     *
     * @member gadgets.rpc
     */
    getRelayUrl: function(targetId) {
      return relayUrl[targetId];
    },

    /**
     * Sets the relay URL of a target frame.
     * @param {String} targetId Name of the target frame.
     * @param {String} url Full relay URL of the target frame.
     * @param {Boolean} opt_useLegacy True if this relay needs the legacy IFPC
     *     wire format.
     *
     * @member gadgets.rpc
     */
    setRelayUrl: function(targetId, url, opt_useLegacy) {
      relayUrl[targetId] = url;
      useLegacyProtocol[targetId] = !!opt_useLegacy;
    },

    /**
     * Sets the auth token of a target frame.
     * @param {String} targetId Name of the target frame.
     * @param {String} token The authentication token to use for all
     *     calls to or from this target id.
     *
     * @member gadgets.rpc
     */
    setAuthToken: function(targetId, token) {
      authToken[targetId] = token;
      setupFrame(targetId);
    },

    /**
     * Gets the RPC relay mechanism.
     * @return {String} RPC relay mechanism. See above for
     *   a list of supported types.
     *
     * @member gadgets.rpc
     */
    getRelayChannel: function() {
      return relayChannel;
    },

    /**
     * Receives and processes an RPC request. (Not to be used directly.)
     * @param {Array.<String>} fragment An RPC request fragment encoded as
     *        an array. The first 4 elements are target id, source id & call id,
     *        total packet number, packet id. The last element stores the actual
     *        JSON-encoded and URI escaped packet data.
     *
     * @member gadgets.rpc
     */
    receive: function(fragment) {
      if (fragment.length > 4) {
        // TODO parse fragment[1..3] to merge multi-fragment messages
        process(gadgets.json.parse(
            decodeURIComponent(fragment[fragment.length - 1])));
      }
    },

    /**
     * Receives and processes an RPC request sent via the same domain.
     * (Not to be used directly). Converts the inbound rpc object's
     * Array into a local Array to pass the process() Array test.
     * @param {Object} rpc RPC object containing all request params
     */
    receiveSameDomain: function(rpc) {
      // Pass through to local process method but converting to a local Array
      rpc.a = Array.prototype.slice.call(rpc.a);
      window.setTimeout(function() { process(rpc) }, 0);
    }
  };
}();

;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/util.js' */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Utility functions for the Open Gadget Container
 */

Function.prototype.inherits = function(parentCtor) {
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  this.superClass_ = parentCtor.prototype;
  this.prototype = new tempCtor();
  this.prototype.constructor = this;
};;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/json.js' */
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * @fileoverview
 * The global object gadgets.json contains two methods.
 *
 * gadgets.json.stringify(value) takes a JavaScript value and produces a JSON
 * text. The value must not be cyclical.
 *
 * gadgets.json.parse(text) takes a JSON text and produces a JavaScript value.
 * It will return false if there is an error.
*/

var gadgets = gadgets || {};

/**
 * @static
 * @class Provides operations for translating objects to and from JSON.
 * @name gadgets.json
 */

/**
 * Port of the public domain JSON library by Douglas Crockford.
 * See: http://www.json.org/json2.js
 */
gadgets.json = function () {

  /**
   * Formats integers to 2 digits.
   * @param {Number} n
   */
  function f(n) {
    return n < 10 ? '0' + n : n;
  }

  Date.prototype.toJSON = function () {
    return [this.getUTCFullYear(), '-',
           f(this.getUTCMonth() + 1), '-',
           f(this.getUTCDate()), 'T',
           f(this.getUTCHours()), ':',
           f(this.getUTCMinutes()), ':',
           f(this.getUTCSeconds()), 'Z'].join("");
  };

  // table of character substitutions
  var m = {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '"' : '\\"',
    '\\': '\\\\'
  };

  /**
   * Converts a json object into a string.
   */
  function stringify(value) {
    var a,          // The array holding the partial texts.
        i,          // The loop counter.
        k,          // The member key.
        l,          // Length.
        r = /["\\\x00-\x1f\x7f-\x9f]/g,
        v;          // The member value.

    switch (typeof value) {
    case 'string':
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe ones.
      return r.test(value) ?
          '"' + value.replace(r, function (a) {
            var c = m[a];
            if (c) {
              return c;
            }
            c = a.charCodeAt();
            return '\\u00' + Math.floor(c / 16).toString(16) +
                (c % 16).toString(16);
            }) + '"'
          : '"' + value + '"';
    case 'number':
    // JSON numbers must be finite. Encode non-finite numbers as null.
      return isFinite(value) ? String(value) : 'null';
    case 'boolean':
    case 'null':
      return String(value);
    case 'object':
    // Due to a specification blunder in ECMAScript,
    // typeof null is 'object', so watch out for that case.
      if (!value) {
        return 'null';
      }
      // toJSON check removed; re-implement when it doesn't break other libs.
      a = [];
      if (typeof value.length === 'number' &&
          !(value.propertyIsEnumerable('length'))) {
        // The object is an array. Stringify every element. Use null as a
        // placeholder for non-JSON values.
        l = value.length;
        for (i = 0; i < l; i += 1) {
          a.push(stringify(value[i]) || 'null');
        }
        // Join all of the elements together and wrap them in brackets.
        return '[' + a.join(',') + ']';
      }
      // Otherwise, iterate through all of the keys in the object.
      for (k in value) if (value.hasOwnProperty(k)) {
        if (typeof k === 'string') {
          v = stringify(value[k]);
          if (v) {
            a.push(stringify(k) + ':' + v);
          }
        }
      }
      // Join all of the member texts together and wrap them in braces.
      return '{' + a.join(',') + '}';
    }
  }

  return {
    stringify: stringify,
    parse: function (text) {
// Parsing happens in three stages. In the first stage, we run the text against
// regular expressions that look for non-JSON patterns. We are especially
// concerned with '()' and 'new' because they can cause invocation, and '='
// because it can cause mutation. But just to be safe, we want to reject all
// unexpected forms.

// We split the first stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace all backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

      if (/^[\],:{}\s]*$/.test(text.replace(/\\["\\\/b-u]/g, '@').
          replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
          replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
        return eval('(' + text + ')');
      }
      // If the text is not JSON parseable, then return false.

      return false;
    }
  };
}();

;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/gadgets-core.js' */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

var gadgets = gadgets || {};

gadgets.error = {};
gadgets.error.SUBCLASS_RESPONSIBILITY = 'subclass responsibility';
gadgets.error.TO_BE_DONE = 'to be done';

gadgets.log = function(message) {
  if (window.console && console.log) {
    console.log(message);
  } else {
    var logEntry = document.createElement('div');
    logEntry.className = 'gadgets-log-entry';
    logEntry.innerHTML = message;
    document.body.appendChild(logEntry);
  }
};


//----------
//Extensible

gadgets.Extensible = function() {
};

/**
* Sets the dependencies.
* @param {Object} dependencies Object whose properties are set on this
*     container as dependencies
*/
gadgets.Extensible.prototype.setDependencies = function(dependencies) {
    for (var p in dependencies) {
        this[p] = dependencies[p];
    }
};

/**
* Returns a dependency given its name.
* @param {String} name Name of dependency
* @return {Object} Dependency with that name or undefined if not found
*/
gadgets.Extensible.prototype.getDependencies = function(name) {
    return this[name];
};


//-------------
//UserPrefStore

/**
* User preference store interface.
* @constructor
*/
gadgets.UserPrefStore = function() {
};

/**
* Gets all user preferences of a gadget.
* @param {Object} gadget Gadget object
* @return {Object} All user preference of given gadget
*/
gadgets.UserPrefStore.prototype.getPrefs = function(gadget) {
throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

/**
* Saves user preferences of a gadget in the store.
* @param {Object} gadget Gadget object
* @param {Object} prefs User preferences
*/
gadgets.UserPrefStore.prototype.savePrefs = function(gadget) {
throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};


//-------------
//DefaultUserPrefStore

/**
* User preference store implementation.
* TODO: Turn this into a real implementation that is production safe
* @constructor
*/
gadgets.DefaultUserPrefStore = function() {
gadgets.UserPrefStore.call(this);
};
gadgets.DefaultUserPrefStore.inherits(gadgets.UserPrefStore);

gadgets.DefaultUserPrefStore.prototype.getPrefs = function(gadget) { };

gadgets.DefaultUserPrefStore.prototype.savePrefs = function(gadget) { };


//-------------
//GadgetService

/**
* Interface of service provided to gadgets for resizing gadgets,
* setting title, etc.
* @constructor
*/
gadgets.GadgetService = function() {
};

gadgets.GadgetService.prototype.setHeight = function(elementId, height) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

gadgets.GadgetService.prototype.setTitle = function(gadget, title) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

gadgets.GadgetService.prototype.setUserPref = function(id) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

//----------------
//IfrGadgetService

/**
* Base implementation of GadgetService.  This implementation does not implement setting the title or user prefs as it
* is meant for gadgets that are standalone on a page.  
* @constructor
*/
gadgets.IfrGadgetService = function() {
    gadgets.GadgetService.call(this);
    
    /**
     * This is a bit funky looking but we need to be sure we always call the right method, even if the implementation
     * has been overridden after an IfrGadgetService is instantiated.
     */
    var service = this;
    gadgets.rpc.register('resize_iframe', function() { service.setHeight.apply(this, arguments); });
    gadgets.rpc.register('set_pref', function() { service.setUserPref.apply(this, arguments); });
    gadgets.rpc.register('set_title', function() { service.setTitle.apply(this, arguments); });
    gadgets.rpc.register('requestNavigateTo', function() { service.requestNavigateTo.apply(this, arguments); });
};

gadgets.IfrGadgetService.inherits(gadgets.GadgetService);

gadgets.IfrGadgetService.prototype.setHeight = function(height) {
    if (height > gadgets.container.maxheight_) {
        height = gadgets.container.maxheight_;
    }

    var element = document.getElementById(this.f);
    if (element) {
        element.style.height = height + 'px';
    }
};
    
/**
* Navigates the page to a new url based on a gadgets requested view and
* parameters.
*/
gadgets.IfrGadgetService.prototype.requestNavigateTo = function(view, opt_params) {
    var id = this.getGadgetIdFromModuleId(this.f);
    var url = this.getUrlForView(view);

    if (opt_params) {
        var paramStr = JSON.stringify(opt_params);
        if (paramStr.length > 0) {
            url += '&appParams=' + encodeURIComponent(paramStr);
        }
    }

    if (url && document.location.href.indexOf(url) == -1) {
        document.location.href = url;
    }
};

/**
* This is a silly implementation that will need to be overriden by almost all
* real containers.
* TODO: Find a better default for this function
*
* @param view The view name to get the url for
*/
gadgets.IfrGadgetService.prototype.getUrlForView = function(view) {
    if (view === 'canvas') {
        return '/canvas';
    } else if (view === 'profile') {
        return '/profile';
    } else {
        return null;
    }
};

gadgets.IfrGadgetService.prototype.getGadgetIdFromModuleId = function(moduleId) {
    // Quick hack to extract the gadget id from module id
    return parseInt(moduleId.match(/_([0-9]+)$/)[1], 10);
};

//-------------
//LayoutManager

/**
* Layout manager interface.
* @constructor
*/
gadgets.LayoutManager = function() {
};

/**
* Gets the HTML element that is the chrome of a gadget into which the content
* of the gadget can be rendered.
* @param {Object} gadget Gadget instance
* @return {Object} HTML element that is the chrome for the given gadget
*/
gadgets.LayoutManager.prototype.getGadgetChrome = function(gadget) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

//-------------------
//StaticLayoutManager

/**
* Static layout manager where gadget ids have a 1:1 mapping to chrome ids.
* @constructor
*/
gadgets.StaticLayoutManager = function() {
    gadgets.LayoutManager.call(this);
};

gadgets.StaticLayoutManager.inherits(gadgets.LayoutManager);

/**
* Sets chrome ids, whose indexes are gadget instance ids (starting from 0).
* @param {Array} gadgetIdToChromeIdMap Gadget id to chrome id map
*/
gadgets.StaticLayoutManager.prototype.setGadgetChromeIds = function(gadgetChromeIds) {
    this.gadgetChromeIds_ = gadgetChromeIds;
};

gadgets.StaticLayoutManager.prototype.getGadgetChrome = function(gadget) {
    var chromeId = this.gadgetChromeIds_[gadget.id];
    return chromeId ? document.getElementById(chromeId) : null;
};


//----------------------
//FloatLeftLayoutManager

/**
* FloatLeft layout manager where gadget ids have a 1:1 mapping to chrome ids.
* @constructor
* @param {String} layoutRootId Id of the element that is the parent of all
*     gadgets.
*/
gadgets.FloatLeftLayoutManager = function(layoutRootId) {
    gadgets.LayoutManager.call(this);
    this.layoutRootId_ = layoutRootId;
};

gadgets.FloatLeftLayoutManager.inherits(gadgets.LayoutManager);

gadgets.FloatLeftLayoutManager.prototype.getGadgetChrome = function(gadget) {
    var layoutRoot = document.getElementById(this.layoutRootId_);
    if (layoutRoot) {
        var chrome = document.createElement('div');
        chrome.className = 'gadgets-gadget-chrome';
        chrome.style.cssFloat = 'left';
        layoutRoot.appendChild(chrome);
        return chrome;
    } else {
        return null;
    }
};

;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-container-resources', location = 'js/gadgets-container.js' */
// ---------
// Container

/**
 * Container interface.
 * @constructor
 */
gadgets.Container = function() {
  this.parentUrl_ = 'http://' + document.location.host;
  this.country_ = 'ALL';
  this.language_ = 'ALL';
  this.view_ = 'default';
  this.nocache_ = 1;

  // signed max int
  this.maxheight_ = 0x7FFFFFFF;
};

gadgets.Container.inherits(gadgets.Extensible);

/**
 * Known dependencies:
 *     userPrefStore: instance of a subclass of gadgets.UserPrefStore
 *     gadgetService: instance of a subclass of gadgets.GadgetService
 *     layoutManager: instance of a subclass of gadgets.LayoutManager
 */

gadgets.Container.prototype.userPrefStore = new gadgets.DefaultUserPrefStore();

gadgets.Container.prototype.gadgetService = new gadgets.GadgetService();

gadgets.Container.prototype.layoutManager =
    new gadgets.StaticLayoutManager();

gadgets.Container.prototype.setParentUrl = function(url) {
  this.parentUrl_ = url;
};

gadgets.Container.prototype.setCountry = function(country) {
  this.country_ = country;
};

gadgets.Container.prototype.setNoCache = function(nocache) {
  this.nocache_ = nocache;
};

gadgets.Container.prototype.setLanguage = function(language) {
  this.language_ = language;
};

gadgets.Container.prototype.setView = function(view) {
  this.view_ = view;
};

gadgets.Container.prototype.setMaxHeight = function(maxheight) {
  this.maxheight_ = maxheight;
};

gadgets.Container.prototype.getGadgetKey_ = function(instanceId) {
  return 'gadget_' + instanceId;
};


// ------------
// IfrContainer

/**
 * Container that renders gadget using ifr.
 * @constructor
 */
gadgets.IfrContainer = function() {
  gadgets.Container.call(this);
};

gadgets.IfrContainer.inherits(gadgets.Container);

gadgets.IfrContainer.prototype.gadgetService = new gadgets.IfrGadgetService();

gadgets.IfrContainer.prototype.setParentUrl = function(url) {
  if (!url.match(/^http[s]?:\/\//)) {
    url = document.location.href.match(/^[^?#]+\//)[0] + url;
  }

  this.parentUrl_ = url;
};

/**
 * Default container.
 */
gadgets.container = new gadgets.IfrContainer();
;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-standalone-resources', location = 'js/gadgets-standalone.js' */
// implementations of setTitle and setPrefs would go here

new gadgets.IfrGadgetService();

gadgets.IfrGadgetService.prototype.setTitle = function(title) {
    //Ignore this call silently to avoid javascript exceptions & errors! (AG-1289)
};;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:feedback-issue-collector', location = '/static/page/sidebar/ancillary/feedback/issue-collector.js' */
(function($) {
    "use strict";

    var loadingIndicator = require('jira/loading/loading');
    var loading = false;
    var initializeIssueCollector = downloadResources;

    function downloadResources() {
        if (loading) {
            return;
        }

        loadingStarts();
        // once all the issue collector resources are downloaded and evaluated, there is a call to window.ATL_JQ_PAGE_PROPS.triggerFunction
        window.ATL_JQ_PAGE_PROPS =  {
            "triggerFunction": function(showIssueCollectorDialog) {
                initializeIssueCollector = showIssueCollectorDialog;
                // The downloaded issue collector resources call this method and then create a DOM node to use as the container for the dialog.
                // We need to defer this call so the container is already on the page before showing the dialog.
                _.defer(function() {
                    loadingEnds(true);
                    showIssueCollectorDialog();
                });
            }
        };

        $.ajax({
            url: "https://jira.atlassian.com/s/d41d8cd98f00b204e9800998ecf8427e/en_UK-3tj2he/6322/131/1.4.11/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector-embededjs/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector-embededjs.js?collectorId=55320d27",
            type: "get",
            cache: true,
            timeout: 10000, // timeout before error function will be called - this is needed for errors like bad gateway where jQuery will not reject the promise
            dataType: "script"
        })
            .fail(function(xhr) {
                loadingEnds();
                JIRA.Messages.showErrorMsg(JIRA.SmartAjax.buildSimpleErrorContent(xhr), {
                    closeable: true
                });
            });
    }

    function loadingStarts() {
        loading = true;
        AJS.dim();
        loadingIndicator.showLoadingIndicator();
    }

    function loadingEnds(success) {
        loading = false;
        // remove transition from the dim so there is no "blink" when issue collector gets displayed
        // do not do it on failure, so the layer is disabled smoothly then
        if (success) {
            AJS.dim.$dim.css("transition", "none");
        }
        AJS.undim();

        //Some pages (I'm looking at you, IssueNav) provide a different implementation of AJS.undim()
        //that removes AJS.dim.$dim, so we have to check for that special case here.
        if (success && AJS.dim.$dim) {
            AJS.dim.$dim.css("transition", "");
        }
        loadingIndicator.hideLoadingIndicator();
    }

    var feedbackCollectorData = WRM.data.claim("com.atlassian.jira.jira-projects-plugin:feedback-issue-collector.data");
    if (feedbackCollectorData && feedbackCollectorData.isFeedbackButtonEnabled) {
        $(function() {
            JIRA.API.getSidebar().done(function(Sidebar) {
                var AUISidebar = Sidebar.getAUISidebar();
                var feedbackGroup = Sidebar.getGroup("jira-projects-ancillary-group");

                if (feedbackGroup === undefined) {
                    return;
                }

                var feedbackItem = feedbackGroup.getItem("com.atlassian.jira.jira-projects-plugin:sidebar-feedback-link") || feedbackGroup.getItem("com.pyxis.greenhopper.jira:sidebar-feedback-link");

                var $feedbackLink = feedbackItem.ui.link;

                // Setting the tooltip value here until the NavigationItem can support custom tooltips / descriptions.
                $feedbackLink.data("custom-tooltip", "We\'d love to hear your thoughts on JIRA.");

                var tipsyOpts = {
                    trigger: 'manual',
                    gravity: 'w',
                    className: 'aui-sidebar-section-tooltip',
                    title: function () {
                        return $(this).data("custom-tooltip");
                    }
                };
                function showTipsy(trigger) {
                    var $trigger = $(trigger);
                    $trigger.tipsy(tipsyOpts).tipsy('show');
                    var $tip = $trigger.data('tipsy') && $trigger.data('tipsy').$tip;
                    // Remove "opacity" inline style from Tipsy to allow the our own styles and transitions to be applied
                    $tip.css({'opacity': ''}).addClass('tooltip-shown');
                }

                function hideTipsy(trigger, andDestroy) {
                    var $trigger = $(trigger);
                    var $tip = $trigger.data('tipsy') && $trigger.data('tipsy').$tip;
                    if ($tip) {
                        $tip.on('transitionend', function () {
                            $trigger.tipsy('hide');
                        });
                        $tip.removeClass('tooltip-shown');
                        if (andDestroy) {
                            $tip.remove();
                            $trigger.removeData('tipsy');
                        }
                    }
                }

                AUISidebar.on('expand-end collapse-end', function () {
                    hideTipsy($feedbackLink, true);
                });

                $feedbackLink.on('mouseenter focus', function (e) {
                    showTipsy(e.currentTarget); // using currentTarget to avoid accidentally tipsy-ing child <span>s.
                });

                $feedbackLink.on('click blur mouseleave', function (e) {
                    hideTipsy(e.currentTarget); // using currentTarget to avoid accidentally tipsy-ing child <span>s.
                });

                feedbackItem.on("before:select", function(e) {
                    e.preventDefault();
                });
            });
        });

        $(document).on("click", ".jira-projects-feedback-collector", function(e) {
            e.preventDefault();
            initializeIssueCollector();
        });
    }

})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:project-page', location = '/sidebar/navigation/items.js' */
AJS.$(function($) {
    $(document).on('click', '.aui-nav > [aria-expanded] > a.aui-nav-item[href="#"]', function(e) {
        e.preventDefault();

        AJS.navigation($(this).siblings('.aui-nav')).toggle();
    });
});;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.Sidebar.ProjectShortcuts.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.Sidebar == 'undefined') { JIRA.Projects.Sidebar = {}; }
if (typeof JIRA.Projects.Sidebar.ProjectShortcuts == 'undefined') { JIRA.Projects.Sidebar.ProjectShortcuts = {}; }
if (typeof JIRA.Projects.Sidebar.ProjectShortcuts.Templates == 'undefined') { JIRA.Projects.Sidebar.ProjectShortcuts.Templates = {}; }


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.content = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.canManage || opt_data.numberOfShortcuts > 0) {
    output += '<div class="aui-sidebar-group jira-sidebar-group-with-divider project-shortcuts-group' + ((opt_data.numberOfShortcuts == 0) ? ' project-shortcuts-group_empty' : '') + '" data-id="project-shortcuts-group"><div class="aui-nav-heading">' + soy.$$escapeHtml("Project shortcuts") + '</div>' + ((opt_data.canManage) ? '<p class="project-shortcuts-group__description' + ((opt_data.numberOfShortcuts > 0) ? ' hidden' : '') + '">' + soy.$$escapeHtml("Add a link to useful information for your whole team to see.") + '</p>' : '') + '<ul class="aui-nav project-shortcuts-list">';
    if (opt_data.shortcuts) {
      var shortcutList24 = opt_data.shortcuts;
      var shortcutListLen24 = shortcutList24.length;
      for (var shortcutIndex24 = 0; shortcutIndex24 < shortcutListLen24; shortcutIndex24++) {
        var shortcutData24 = shortcutList24[shortcutIndex24];
        output += JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcut({id: shortcutData24.id, name: shortcutData24.name, url: shortcutData24.url, icon: shortcutData24.icon, canManage: opt_data.canManage, iconsMap: opt_data.iconsMap, isWithIcon: opt_data.isWithIcons});
      }
    }
    output += ((opt_data.canManage) ? '<li><a class="aui-nav-item project-shortcuts-group__add" href="#" data-link-id="project-shortcut-add"><span class="aui-icon aui-icon-large aui-iconfont-add-small"></span><span class="aui-nav-item-label">' + soy.$$escapeHtml("Add link") + '</span></a></li>' : '') + '</ul></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.content.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.content';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcut = function(opt_data, opt_ignored) {
  return '<li class="project-shortcut"><a class="aui-nav-item project-shortcuts-group__link" href="' + soy.$$escapeHtml(opt_data.url) + '" title="' + soy.$$escapeHtml(opt_data.name) + '" target="_blank" data-shortcut-id="' + soy.$$escapeHtml(opt_data.id) + '" data-link-id="project-shortcut-' + soy.$$escapeHtml(opt_data.id) + '">' + ((opt_data.isWithIcon) ? '<span class="aui-icon aui-icon-large ' + JIRA.Projects.Sidebar.ProjectShortcuts.Templates.icon({iconId: opt_data.icon, iconsMap: opt_data.iconsMap}) + '" data-project-shortcuts-icon-id="' + soy.$$escapeHtml(opt_data.icon) + '">' + soy.$$escapeHtml("Project shortcut icon") + '</span>' : '') + '<span class="aui-nav-item-label">' + soy.$$escapeHtml(opt_data.name) + '</span></a>' + ((opt_data.canManage) ? '<a href="#project-shortcuts-dropdown_' + soy.$$escapeHtml(opt_data.id) + '" aria-owns="project-shortcuts-dropdown_' + soy.$$escapeHtml(opt_data.id) + '" aria-haspopup="true" class="aui-dropdown2-trigger project-shortcuts-group__actions"><span>' + soy.$$escapeHtml("Actions") + '</span></a><div id="project-shortcuts-dropdown_' + soy.$$escapeHtml(opt_data.id) + '" class="aui-dropdown2 aui-style-default project-shortcuts-group__dropdown"><ul class="aui-list-truncate"><li><a class="project-shortcuts-group__actions__edit" href="#">' + soy.$$escapeHtml("Edit") + '</a></li><li><a class="project-shortcuts-group__actions__delete  " href="#">' + soy.$$escapeHtml("Delete") + '</a></li></ul></div>' : '') + '</li>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcut.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcut';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.icon = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  var output = '';
  if (opt_data.iconsMap) {
    var id__soy83 = opt_data.iconId && opt_data.iconsMap[opt_data.iconId] ? opt_data.iconId : '1';
    output += (opt_data.iconsMap[id__soy83]) ? soy.$$escapeHtml(opt_data.iconsMap[id__soy83].className) : '';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.icon.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.icon';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcutFormFields = function(opt_data, opt_ignored) {
  return '<div class="project-shortcuts-field-group">' + aui.form.textField({name: 'project-shortcuts-url-' + opt_data.action, id: 'project-shortcuts-url-' + opt_data.action, labelContent: "Web address", placeholderText: "e.g. http://www.atlassian.com", extraClasses: 'project-shortcuts-url', value: opt_data.url ? opt_data.url : '', errorTexts: opt_data.errors.urlError ? [opt_data.errors.urlError] : []}) + '<div class="field-group project-shortcuts-name">' + aui.form.label({forField: 'project-shortcuts-name-' + opt_data.action, content: "Label"}) + '<div class="project-shortcuts-name-icon-block"><div class="project-shortcuts-icon-picker-block"></div>' + aui.form.input({name: 'project-shortcuts-name-' + opt_data.action, id: 'project-shortcuts-name-' + opt_data.action, placeholderText: "e.g. Atlassian website", extraClasses: 'project-shortcuts-name-input' + (opt_data.isWithIcon ? ' project-shortcuts-name-input-with-icon' : ''), value: opt_data.name ? opt_data.name : '', type: 'text'}) + '</div>' + ((opt_data.errors.iconError) ? aui.form.fieldError({message: opt_data.errors.iconError}) : '') + ((opt_data.errors.nameError) ? aui.form.fieldError({message: opt_data.errors.nameError}) : '') + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcutFormFields.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcutFormFields';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsPicker = function(opt_data, opt_ignored) {
  return '<span>' + JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsList(opt_data) + '</span>' + aui.dropdown2.trigger({menu: {id: 'project-shortcuts-icons-list-' + opt_data.cid}, extraClasses: 'aui-button project-shortcuts-icons-picker', iconClasses: 'aui-icon aui-icon-large  ' + soy.$$escapeHtml(opt_data.icon.className), extraAttributes: {href: '#'}});
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsPicker.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsPicker';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsList = function(opt_data, opt_ignored) {
  var output = '<div id="project-shortcuts-icons-list-' + soy.$$escapeHtml(opt_data.cid) + '" aria-hidden="true" class="aui-style-default aui-dropdown2 project-shortcuts-icons-list aui-dropdown2-section"><ul>';
  var iconList136 = opt_data.iconsList;
  var iconListLen136 = iconList136.length;
  for (var iconIndex136 = 0; iconIndex136 < iconListLen136; iconIndex136++) {
    var iconData136 = iconList136[iconIndex136];
    output += '<li><a class="project-shortcuts-icons-icon" data-project-shortcuts-icons-id="' + soy.$$escapeHtml(iconData136.name) + '"><span class="aui-icon aui-icon-large ' + soy.$$escapeHtml(iconData136.className) + '">' + soy.$$escapeHtml("Project shortcut icon") + '</span></a></li>';
  }
  output += '</ul></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsList.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsList';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.addDialog = function(opt_data, opt_ignored) {
  return '<form action="" method="post" class="aui"><h3>' + soy.$$escapeHtml("Add link") + '</h3><fieldset>' + JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcutFormFields(soy.$$augmentMap(opt_data, {action: 'add'})) + '<div class="buttons-container"><div class="buttons"><button class="aui-button project-shortcuts-submit">' + soy.$$escapeHtml("Add") + '</button><button class="aui-button aui-button-link project-shortcuts-cancel">' + soy.$$escapeHtml("Cancel") + '</button></div></div></fieldset></form>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.addDialog.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.addDialog';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialogChrome = function(opt_data, opt_ignored) {
  return '<section role="dialog" id="edit-project-shortcut-dialog" class="aui-layer aui-dialog2 aui-dialog2-small" aria-hidden="true" data-aui-remove-on-hide="true"><header class="aui-dialog2-header"><h2 class="aui-dialog2-header-main">' + soy.$$escapeHtml("Edit link") + '</h2></header></section>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialogChrome.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialogChrome';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialog = function(opt_data, opt_ignored) {
  return '<div class="aui-dialog2-content"><form class="aui" method="post">' + JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcutFormFields(soy.$$augmentMap(opt_data, {action: 'edit'})) + '<button type="submit" class="project-shortcuts-hidden-submit"></button></form></div><footer class="aui-dialog2-footer"><div class="aui-dialog2-footer-actions"><button class="aui-button aui-button-primary project-shortcuts-submit">' + soy.$$escapeHtml("Save") + '</button><button class="aui-button aui-button-link project-shortcuts-cancel">' + soy.$$escapeHtml("Cancel") + '</button></div></footer>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialog.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialog';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.deleteDialog = function(opt_data, opt_ignored) {
  return '<section role="dialog" id="delete-project-shortcut-dialog" class="aui-layer aui-dialog2 aui-dialog2-small" aria-hidden="true" data-aui-remove-on-hide="true"><header class="aui-dialog2-header"><h2 class="aui-dialog2-header-main">' + soy.$$escapeHtml("Delete shortcut") + '</h2></header><div class="aui-dialog2-content"><p>' + soy.$$escapeHtml("Are you sure you want to delete this shortcut?") + '</p></div><footer class="aui-dialog2-footer"><div class="aui-dialog2-footer-actions"><button class="aui-button aui-button-primary project-shortcuts-submit">' + soy.$$escapeHtml("Delete") + '</button><button class="aui-button aui-button-link project-shortcuts-cancel">' + soy.$$escapeHtml("Cancel") + '</button></div></footer></section>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.deleteDialog.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.deleteDialog';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/aui-sidebar-overrides.js' */
(function () {
    "use strict";
    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.SidebarOverrides");
    JIRA.Projects.Sidebar.ProjectShortcuts.SidebarOverrides.init = function () {
        // Override to sidebar so it doesn't break the DOM that is managed by Marionette.
        // This can be removed when we upgrade to AUI 5.7.900.
        var manager = AJS.sidebar('.aui-sidebar').submenus;
        manager.moveSubmenuToInlineDialog = function ($submenu) {
            this.$placeholderSubmenu = $submenu.clone(true);
            this.inlineDialog.find('.aui-navgroup-inner').append(this.$placeholderSubmenu);
            return this;
        };

        manager.restoreSubmenu = function () {
            delete this.$placeholderSubmenu;
            return this;
        };
    };
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/services/AvailableIcons.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons");
    var _iconsList = [];
    var _iconsMap = {};
    var _isWithIcons = false;

    /**
     * Class to manage set of icons that are available for user.
     * Single icon class contains unique icon name and css class which should be rendered.
     */
    JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons = {
        initialize: function(iconList) {
            _iconsList = iconList || _iconsList;
            /**
             * Fix for bug [HIROL-582] Backlog is failing to load for admin when shortcut icons are enabled
             * _.indexBy is available in underscore >= 1.5.2, using 1.4.4 currently
             */
            _iconsMap = {};
            _.each(iconList, function(element) {
                _iconsMap[element.name] = element;
            });
        },
        getIconsList: function() {
            return _iconsList;
        },

        getIconsMap: function() {
            return _iconsMap;
        },

        getAllIconsClasses: function() {
            return _.reduce(_iconsList, function(memo, current){
                return memo + current.className + " ";
            }, "");
        },

        /**
         * Return single icon class from icons set, based on icon name.
         * If icon does not exists (e.g. icons set changed or icon name is empty), returns first icon from set.
         */
        getIconFromName: function(name) {
            if (this.getIconsMap()[name]){
                return this.getIconsMap()[name];
            }
            if (this.getIconsList()[0]) {
                return this.getIconsList()[0];
            }
            return {};
        },

        setWithIcons: function(isWithIcons) {
            _isWithIcons = isWithIcons;
        },
        isWithIcons: function() {
            return _isWithIcons;
        }
    };

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/entities/Shortcut.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcut");

    function failedResponseToData(response) {
        var data;
        try {
            data = JSON.parse(response.responseText);
        } catch (e) {
            data = {
                message: "We couldnt complete the action as there seems to be a communication issue."
            };
        }

        return data;
    }

    JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcut = Backbone.Model.extend({
        defaults: {
            url: "",
            name: "",
            icon: ""
        },
        initialize: function (data, options) {
            if (!options || !options.projectKey) {
                throw "Project key is required";
            }
            this.projectKey = options.projectKey;
        },
        urlRoot: function urlRoot() {
            return AJS.contextPath() + '/rest/projects/1.0/project/' + encodeURIComponent(this.projectKey) + '/shortcut'
        },
        clear: function clear() {
            this.unset("id");
            this.set("url", this.defaults.url);
            this.set("name", this.defaults.name);
            this.set("icon", this.defaults.icon);
        },

        save: function () {
            if (this.saving == true) {
                return;
            }
            this.saving = true;
            var model = this;
            model.trigger("save:start");
            var method = this.isNew() ? "create" : "update";
            this.sync(method, model)
                .always(function requestFinished() {
                    model.saving = false;
                    model.trigger("save:finish");
                })
                .done(function requestDone(savedModel) {
                    model.set(savedModel, {silent: true});
                    JIRA.trace("jira.projects.shortcuts." + method + ".success");
                    model.trigger("save:success");
                })
                .fail(function requestFailed(response) {
                    var data = failedResponseToData(response);
                    JIRA.trace("jira.projects.shortcuts." + method + ".fail");
                    model.trigger("save:failure", data);
                });
        },
        destroy: function () {
            if (this.saving == true) {
                return;
            }
            this.saving = true;
            var model = this;
            model.trigger("remove:start");
            var result = Backbone.Model.prototype.destroy.apply(this, arguments);
            result
                .always(function () {
                    model.saving = false;
                    model.trigger("remove:finish");
                })
                .done(function requestDone() {
                    model.trigger("remove:success");
                })
                .fail(function requestFailed(response) {
                    var data = failedResponseToData(response);
                    model.trigger("remove:failure", data);
                });
            return result;
        }

    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/entities/ShortcutErrors.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Entities.ShortcutErrors");
    JIRA.Projects.Sidebar.ProjectShortcuts.Entities.ShortcutErrors = Backbone.Model.extend({
        defaults: {
            "urlError": "",
            "nameError": "",
            "iconError": "",
            "generalError": ""
        },
        initialize: function initialize(data, options) {
            var model = options.model;

            this.listenTo(model, "save:failure remove:failure", function failure(errorData) {
                this.set({
                    urlError: errorData.errors && errorData.errors.url,
                    nameError: errorData.errors && errorData.errors.name,
                    iconError: errorData.errors && errorData.errors.icon,
                    generalError: (errorData.message || (errorData.errorMessages && errorData.errorMessages.length > 0))
                        ? errorData.message || errorData.errorMessages[0]
                        : undefined
                });
            });
            this.listenTo(model, "save:success remove:success", this.clear);
        }
    });


})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/entities/Shortcuts.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcuts");

    JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcuts = Backbone.Collection.extend({
        model: JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcut,
        initialize: function(data, options) {
            this.projectKey = options.projectKey;
        }
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/views/IconPickerContent.js' */
(function ($) {
    "use strict";

    var dataIconId = 'projectShortcutsIconsId';
    var activeAUIDropdown2ElementClass = 'active aui-dropdown2-active';

    function changeIconSelectionOnKeyboardEvent(instance, event) {
        var elementsInRow = 5;

        var active = instance.ui.iconList.find('.active');
        var iconsListLength = instance.ui.iconList.find('li').size();
        var step;

        switch (event.keyCode) {
            case AJS.keyCode.LEFT:
                step = -1;
                break;
            case AJS.keyCode.RIGHT:
                step = 1;
                break;
            case AJS.keyCode.DOWN:
                step = elementsInRow;
                break;
            case AJS.keyCode.UP:
                step = -elementsInRow;
                break;
            default :
                step = 0;
        }

        var newActiveElementIndex = active.closest('li').index() + step;
        if (newActiveElementIndex < 0 || newActiveElementIndex >= iconsListLength) {
            newActiveElementIndex += iconsListLength;
            newActiveElementIndex %= iconsListLength;
        }

        active.removeClass(activeAUIDropdown2ElementClass);
        instance.ui.icon.eq(newActiveElementIndex).addClass(activeAUIDropdown2ElementClass);
    }

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Views.IconPickerContent");
    JIRA.Projects.Sidebar.ProjectShortcuts.Views.IconPickerContent = JIRA.Projects.Libs.Marionette.ItemView.extend({

        template: JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsPicker,

        ui: {
            icon: ".project-shortcuts-icons-icon",
            iconList: ".project-shortcuts-icons-list",
            iconPicker: ".project-shortcuts-icons-picker"
        },

        modelEvents: {
            "change:icon": function changeCurrentIcon() {
                var icon = this._modelIcon();
                var children = this.ui.iconPicker.children();

                children.removeClass(this.iconFactory.getAllIconsClasses());
                children.addClass(icon.className);
                this.ui.iconPicker.data(dataIconId, icon.name);
            },

            "save:start": function saveStarted() {
                this.ui.iconPicker.attr("aria-disabled", true);
            },

            "save:finish": function saveFinish() {
                this.ui.iconPicker.attr("aria-disabled", false);
            }
        },

        events: {
            "keydown @ui.iconPicker": function pickerMovement(e) {
                if (!this.isPickerActive()) {
                    return;
                }

                switch(e.keyCode) {
                    case AJS.keyCode.LEFT:
                    case AJS.keyCode.RIGHT:
                    case AJS.keyCode.DOWN:
                    case AJS.keyCode.UP:
                        changeIconSelectionOnKeyboardEvent(this, e);
                        e.stopPropagation();
                        e.preventDefault();

                        this.ui.iconList.trigger("aui-dropdown2-item-selected");
                        break;

                    case AJS.keyCode.ESCAPE:
                        this.hideIconPicker();

                        e.stopPropagation();
                        e.preventDefault();

                        break;
                }
            }
        },

        initialize: function(options) {
            this.iconFactory = JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons;
            this.analytics = JIRA.Projects.Sidebar.ProjectShortcuts.Analytics;
        },

        onRender: function() {
            var instance = this;

            this.ui.icon.on("click", function iconClicked() {
                var iconName = $(this).data(dataIconId);

                instance.analytics.iconChangeConfirmed(instance.model, iconName);
                instance.analyticsOldIconId = '';
                instance.analyticsIconClicked = true;
                instance.model.set("icon", iconName);

                instance.ui.iconPicker.focus();
            });

            this.ui.iconList.on("aui-dropdown2-show", function () {
                instance.ui.iconPicker.focus();
                instance.analyticsIconClicked = false;
                instance.analytics.iconPickerOpened(instance.model);
            });

            this.ui.iconList.on("aui-dropdown2-hide", function() {
                instance.analytics.iconPickerClosed(instance.model, instance.analyticsIconClicked);
            });

            // analytics on icon change - include old icon
            this.analyticsOldIconId = '';
            this.ui.iconList.on("aui-dropdown2-item-selected", function(e) {
                var id = AJS.$(this).find(".active").data(dataIconId);
                if (instance.analyticsOldIconId && instance.analyticsOldIconId !== id) {
                    instance.analytics.iconChanged(instance.model, id, instance.analyticsOldIconId);
                }
                instance.analyticsOldIconId = id;
            });

            this.ui.iconPicker.data(dataIconId, this.model.get("icon"));
        },

        hideIconPicker: function() {
            if (this.isPickerActive()) {
                this.ui.iconPicker.trigger('aui-button-invoke');
            }
        },

        isPickerActive: function () {
            return this.ui.iconPicker.hasClass('active');
        },

        _modelIcon: function getIconElement() {
            return this.iconFactory.getIconFromName(this.model.get('icon'));
        },

        onFormSubmit: function setIconInModel() {
            this.model.set("icon", this.ui.iconPicker.data(dataIconId) || "");
        },

        focus: function focusOnPicker() {
            this.ui.iconPicker.focus();
        },

        serializeData: function() {
            return {
                iconsList: this.iconFactory.getIconsList(),
                icon: this._modelIcon(),
                cid: this.cid
            }
        }

    });
})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/views/DialogContent.js' */
(function ($) {
    "use strict";

    function formSubmit(e) {
        e.preventDefault();
        this.ensureProtocolPrefix();
        this.tryToAutomagicallyDeriveNameFromUrl();
        if (this.iconPickerContent) {
            this.iconPickerContent.onFormSubmit();
        }

        this.model.set("url", this.ui.url.val());
        this.model.set("name", this.ui.name.val());
        this.model.save();
    }

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent");
    JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent = JIRA.Projects.Libs.Marionette.LayoutView.extend({
        ui: {
            form: "form",
            inputs: "input, button",
            submit: ".project-shortcuts-submit",
            cancel: ".project-shortcuts-cancel",
            url: ".project-shortcuts-url input",
            name: ".project-shortcuts-name input"
        },

        regions: {
            iconPicker: ".project-shortcuts-icon-picker-block"
        },

        events: {
            "click @ui.cancel": function cancel(e) {
                e.preventDefault();
                this.model.clear();
                this.setNameAutomagically = true;
                this.errorModel.clear();
                this.trigger("cancel");
            },
            "click @ui.submit": formSubmit,
            "submit @ui.form": formSubmit,
            "blur @ui.url": function ensureProtocol() {
                this.ensureProtocolPrefix();
                this.tryToAutomagicallyDeriveNameFromUrl();
            },
            "input @ui.url": function urlChange() {
                this.model.set("url", this.ui.url.val());
                this.tryToAutomagicallyDeriveNameFromUrl();
            },
            "input @ui.name": function nameChange() {
                this.setNameAutomagically = false;
                this.model.set("name", this.ui.name.val());
            },
            "keydown @ui.name": function nameKeydown(e) {
                if (!this.iconPickerContent) return;

                // tabindex doesn't work on Mac when Full Keyboard Access is disabled
                if (e.shiftKey && e.keyCode === AJS.keyCode.TAB) {
                    e.preventDefault();
                    this.iconPickerContent.focus();
                }
            },
            "keydown @ui.url": function nameKeydown(e) {
                if (!this.iconPickerContent) return;

                // tabindex doesn't work on Mac when Full Keyboard Access is disabled
                if (!e.shiftKey && e.keyCode === AJS.keyCode.TAB) {
                    e.preventDefault();
                    this.iconPickerContent.focus();
                }
            }
        },

        modelEvents: {
            "save:start": function saveStarted() {
                this.ui.inputs.prop("disabled", true);
                this.ui.submit.addClass("loading");
                this.ui.submit.spin({className: "spinner"});
            },
            "save:finish": function saveFinish() {
                this.ui.inputs.prop("disabled", false);
                this.ui.submit.removeClass("loading");
                this.ui.submit.spinStop({className: "spinner"});
            },
            "save:failure": function renderWithErrors() {
                this.render();
                if (this.errorModel.get("generalError")) {
                    var flag = require('aui/flag');
                    flag({
                        type: "error",
                        title: "We couldn\'t save the link for you",
                        close: "auto",
                        body: this.errorModel.get("generalError")
                    });
                }
                if (this.errorModel.get("nameError")) {
                    this.ui.name.focus();
                }
                if (this.errorModel.get("urlError")) {
                    this.ui.url.focus();
                }

                return this;
            },
            "save:success": function saveSuccess() {
                this.setNameAutomagically = true;
            }
        },

        initialize: function initialize(options) {
            this.errorModel = options.errorModel;
            var currentName = this.model.get("name");
            this.setNameAutomagically = (currentName.length == 0);
            this.iconFactory = JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons;
        },

        serializeData: function serializeData() {
            return _.extend(this.model.toJSON(), {
                errors: this.errorModel.toJSON(),
                action: this.action,
                isWithIcon: this.iconFactory.isWithIcons()
            });
        },

        onRender: function () {
            if (this.iconFactory.isWithIcons()) {
                this.iconPickerContent = new JIRA.Projects.Sidebar.ProjectShortcuts.Views.IconPickerContent({
                    model: this.model,
                    action: this.action,
                    observable: this
                });

                this.getRegion("iconPicker").show(this.iconPickerContent);
            } else {
                delete this.iconPickerContent;
            }
        },

        hideIconPicker: function() {
            if (!this.iconPickerContent) return;
            
            this.iconPickerContent.hideIconPicker();
        },

        setName: function setName(name) {
            this.ui.name.val(name);
            this.model.set("name", name);
        },
        setUrl: function setUrl(url) {
            this.ui.url.val(url);
            this.model.set("url", url);
        },
        ensureProtocolPrefix: function ensureProtocolPrefix() {
            var currentUrl = this.ui.url.val().trim();
            if (currentUrl.length > 0 && !JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent.urlPattern.test(currentUrl)) {
                this.setUrl('http://' + currentUrl);
            }
        },
        tryToAutomagicallyDeriveNameFromUrl: function tryToAutomagicallyDeriveNameFromUrl() {
            var currentUrl = this.ui.url.val().trim();
            if (this.setNameAutomagically) {
                if (JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent.urlOptionalProtocolPattern.test(currentUrl)) {
                    var matches = JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent.urlOptionalProtocolPattern.exec(currentUrl);
                    this.setName(matches[3]);
                } else {
                    this.setName(currentUrl);
                }
            }
        }
    }, {
        urlPattern: /^[a-zA-Z0-9]+:(\/\/)?([^\/]*).*/,
        urlOptionalProtocolPattern: /^([a-zA-Z0-9]+:(\/\/)?)?([^\/]*).*/
    });
})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/views/AddDialogContent.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Views.AddDialogContent");
    JIRA.Projects.Sidebar.ProjectShortcuts.Views.AddDialogContent = JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent.extend({
        template: JIRA.Projects.Sidebar.ProjectShortcuts.Templates.addDialog
    });
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/views/EditDialogContent.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Views.EditDialogContent");
    JIRA.Projects.Sidebar.ProjectShortcuts.Views.EditDialogContent = JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent.extend({
        template: JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialog
    });
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/views/Shortcut.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Views.Shortcut");
    JIRA.Projects.Sidebar.ProjectShortcuts.Views.Shortcut = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcut,
        initialize: function initialize() {
            _.bindAll(this, 'toggleDropdown');
            this.iconFactory = JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons;
        },
        ui: {
            del: '.project-shortcuts-group__actions__delete',
            edit: '.project-shortcuts-group__actions__edit',
            trigger: '.project-shortcuts-group__actions',
            dropdown: '.project-shortcuts-group__dropdown',
            link: '.project-shortcuts-group__link'
        },
        modelEvents: {
            'change': 'render'
        },
        events: {
            'click @ui.link': function onLinkClick() {
                this.trigger('click:link', this.model);
            }
        },
        onRender: function() {
            var instance = this;
            this.unwrapTemplate();
            var $window = $(window);
            var $sidebarBody = $('.aui-sidebar-body');

            this.ui.edit.on('click', function onEdit(e) {
                e.preventDefault();
                instance.ui.trigger.blur();
                var editDialog = new JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Edit({
                    model: instance.model
                });
                instance.trigger('edit:open', instance.model);
                
                instance.listenToOnce(editDialog, 'dialog:close', function onDialogClosed(isSave) {
                    instance.trigger('edit:close', instance.model, isSave);
                });
            });
            this.ui.del.on('click', function onDelete(e) {
                e.preventDefault();
                instance.ui.trigger.blur();
                var deleteDialog = new JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Delete({
                    model: instance.model
                });
            });
            this.ui.dropdown.on({
                "aui-dropdown2-show": function() {
                    instance.$el.addClass('aui-nav-selected');
                    $sidebarBody.one('scroll', instance.toggleDropdown);
                    $window.one('scroll', instance.toggleDropdown);
                    // focus on trigger, so it handle all keyboard events
                    instance.ui.trigger.focus();
                },
                "aui-dropdown2-hide": function() {
                    instance.$el.removeClass('aui-nav-selected');
                    $sidebarBody.off('scroll', instance.toggleDropdown);
                    $window.off('scroll', instance.toggleDropdown);
                }
            });
        },

        serializeData: function () {
            var data = _.extend(this.model.toJSON(), {
                canManage: true,
                isWithIcon: this.iconFactory.isWithIcons()
            });
            if (this.iconFactory.isWithIcons()) {
                data = _.extend(data, {
                    iconsMap: JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons.getIconsMap()
                });
            }

            return data;
        },
        toggleDropdown: function toggleDropdown() {
            this.ui.trigger.trigger("aui-button-invoke");
        }
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/views/ShortcutsList.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Views.List");
    JIRA.Projects.Sidebar.ProjectShortcuts.Views.List = JIRA.Projects.Libs.Marionette.CompositeView.extend({
        template: JIRA.Projects.Sidebar.ProjectShortcuts.Templates.content,
        childView: JIRA.Projects.Sidebar.ProjectShortcuts.Views.Shortcut,
        ui: {
            itemsContainer: '.aui-nav',
            description: '.project-shortcuts-group__description',
            add: '.project-shortcuts-group__add'
        },
        collectionEvents: {
            /**
             * Show/hide extra description message when collection goes
             * from 0 to n items or from n to 0 items.
             */
           'add remove': function onCollectionLengthChange() {
               if (this.collection.length == 0 && this.lastCollectionLength != 0
                   || this.collection.length != 0 && this.lastCollectionLength == 0) {
                   this.lastCollectionLength = this.collection.length;
                   this.ui.description.toggleClass("hidden", this.collection.length > 0);
                   this.$el.toggleClass("project-shortcuts-group_empty", this.collection.length == 0)
               }
           }
        },
        initialize: function initialize() {
            /**
             * When sidebar is collapsed we want to hide any of the action dropdowns that
             * might be visible on the page. We do this here to attach only one event handler.
             */
            var instance = this;
            AJS.sidebar('.aui-sidebar').on('collapse-start', function hideDropdownOnSidebarCollapse() {
                instance.$(".project-shortcuts-group__actions.aui-dropdown2-active").trigger("aui-button-invoke");
            });

            this.lastCollectionLength = this.collection.length;
        },

        attachElContent: function(html) {
            var navigationGroup = new JIRA.Projects.Sidebar.Component.NavigationGroup({
                el: html
            });
            JIRA.API.Sidebar.replaceGroup(this.options.targetGroup, navigationGroup);
            this.$el = $(navigationGroup.getElement());
            return this;
        },

        onRender: function onRender() {
            var addDialog = new JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Add({
                sidebarItem: JIRA.API.Sidebar.getGroup('project-shortcuts-group').getItem('project-shortcut-add'),
                projectKey: this.collection.projectKey,
                collection: this.collection
            });
            
            this.listenTo(addDialog, "dialog:open", function propagateOpenEvent() {
                this.trigger("add:open");
            });
            this.listenTo(addDialog, "dialog:close", function propagateCloseEvent(isSave) {
                this.trigger("add:close", isSave);
            });
        },
        serializeData: function serializeData() {
            return {
                canManage: true,
                numberOfShortcuts: this.collection.length
            }
        },
        attachBuffer: function(collectionView, buffer) {
            this.ui.itemsContainer.prepend(buffer);
        },
        onAddChild: function onAddChild(childView){
            this.ui.add.parent().before(childView.$el);
        }
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/dialogs/Delete.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Delete");

    JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Delete = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Sidebar.ProjectShortcuts.Templates.deleteDialog,
        ui: {
            inputs: "input, button",
            submit: ".project-shortcuts-submit",
            cancel: ".project-shortcuts-cancel"
        },
        events: {
            "click @ui.cancel": function cancel(e) {
                e.preventDefault();
                this.dialog.hide();
            },
            "click @ui.submit": function formSubmit(e) {
                e.preventDefault();
                this.model.destroy({wait: true});
            }
        },
        modelEvents: {
            "remove:start": function removeStart() {
                this.ui.inputs.prop("disabled", true);
                this.ui.submit.addClass("loading");
                this.ui.submit.spin({className: "spinner"});
            },
            "remove:finish": function removeFinish() {
                this.ui.inputs.prop("disabled", false);
                this.ui.submit.removeClass("loading");
                this.ui.submit.spinStop({className: "spinner"});
                this.dialog.hide();
                JIRA.trace("jira.projects.shortcuts.deleted");
            },
            "remove:failure": function removeFailure(errorData) {
                if (errorData.message || (errorData.errorMessages && errorData.errorMessages.length > 0)) {
                    var flag = require('aui/flag');
                    flag({
                        type: "error",
                        title: "We couldn\'t delete the link for you",
                        close: "auto",
                        body: errorData.message || errorData.errorMessages[0]
                    });
                }
            }
        },
        initialize: function initialize() {
            this.render();
            this.$el.appendTo("body");

            this.dialog = AJS.dialog2(this.$el);
            this.dialog.show();
            var instance = this;
            this.dialog.on("hide", function() {
                _.defer(function () {
                    instance.destroy();
                });
            });
        },
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });
})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/dialogs/Edit.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Edit");

    JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Edit = JIRA.Projects.Libs.Marionette.Controller.extend({
        initialize: function(options) {
            var instance = this;
            _.bindAll(this, "hide");

            this.model = new JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcut(options.model.toJSON(), {
                projectKey: options.model.projectKey || options.model.collection.projectKey
            });
            this.errorModel = new JIRA.Projects.Sidebar.ProjectShortcuts.Entities.ShortcutErrors(undefined, {
                model: this.model
            });
            this.view = new JIRA.Projects.Sidebar.ProjectShortcuts.Views.EditDialogContent({
                model: this.model,
                errorModel: this.errorModel
            });
            this.analyticsSave = false;

            this.view.render();
            var $dialogElement = $(JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialogChrome({}));
            this.view.$el.appendTo($dialogElement);
            this.dialog = AJS.dialog2($dialogElement);
            this.dialog.show();
            this.view.ui.url.focus();

            this._onResizeWindow = function() {
                instance.hideIconPicker();
            };
            $(window).on('resize', this._onResizeWindow);

            this.listenTo(this.view, 'cancel', this.hide);
            this.listenTo(this.model, 'save:success', function onSave() {
                this.analyticsSave = true;
                this.hide();
                options.model.set(instance.model.toJSON());
            });
            this.dialog.on("hide", function onDialogHide() {
                instance.trigger("dialog:close", instance.analyticsSave);
            });
        },

        hideIconPicker: function() {
            this.view.hideIconPicker();
        },

        hide: function hide() {
            this.dialog.hide();
            $(window).off('resize', this._onResizeWindow);
        }
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/dialogs/Add.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Add");

    JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Add = JIRA.Projects.Libs.Marionette.Controller.extend({
        initialize: function(options) {
            _.bindAll(this, "hide", "refresh", "focusForm");
            var instance = this;

            this.analyticsSave = false;

            this.sidebarItem = options.sidebarItem;
            this.projectKey = options.projectKey;
            this.collection = options.collection;
            this.model = new JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcut(null, {
                projectKey: this.projectKey
            });
            this.errorModel = new JIRA.Projects.Sidebar.ProjectShortcuts.Entities.ShortcutErrors(null, {
                model: this.model
            });
            this.view = new JIRA.Projects.Sidebar.ProjectShortcuts.Views.AddDialogContent({
                model: this.model,
                errorModel: this.errorModel
            });
            this.view.render();

            var $window = $(window);
            var $document = $(document);
            var $sidebarBody = $('.aui-sidebar-body');

            this.dialog = AJS.InlineDialog(this.sidebarItem.ui.link, 'project-shortcuts-group__add-dialog',
                function(content, trigger, showPopup) {
                    instance.sidebarItem.$el.addClass('aui-nav-selected');
                    instance.view.render();
                    instance.view.$el.appendTo(content);
                    instance.view.ui.url.focus();
                    $window.on('scroll.project-shortcuts', function windowScroll() {
                        instance.refresh();
                    });
                    $sidebarBody.on('scroll.project-shortcuts', function sidebarScroll() {
                        instance.hide();
                    });

                    $document.on("showLayer", instance.focusForm);
                    $window.on("resize", instance.refresh);

                    showPopup();
                    return false;
                }, {
                    gravity: 'w',
                    autoWidth: true,
                    initCallback: function initCallback() {
                        instance.trigger("dialog:open");
                        instance.analyticsSave = false;
                    },
                    hideCallback: function hideCallback() {
                        instance.sidebarItem.$el.removeClass('aui-nav-selected');
                        instance.sidebarItem.ui.link.blur();
                        $window.off('scroll.project-shortcuts');
                        $sidebarBody.off('scroll.project-shortcuts');
                        $document.off("showLayer", instance.focusForm);

                        instance.trigger("dialog:close", instance.analyticsSave);
                    },
                    persistent: true,
                    closeOnTriggerClick: true,
                    offsetY: function offsetY(popup, targetPosition) {
                        var halfTriggerHeight = targetPosition.target.height();
                        var halfPopupHeight = popup.height() / 2;
                        return halfPopupHeight - halfTriggerHeight - 10;
                    },
                    arrowOffsetY: function arrowOffsetY(popup, targetPosition) {
                        var halfTriggerHeight = targetPosition.target.height() / 2;
                        var halfPopupHeight = popup.height() / 2;
                        return -halfPopupHeight + 22 + halfTriggerHeight;
                    }
                }
            );

            this.listenTo(this.view, 'render', this.refresh);
            this.listenTo(this.view, 'cancel', this.hideAndRender);
            this.listenTo(this.model, 'save:success', function onModelSaved() {
                var createdModel = new JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcut(this.model.toJSON(), {
                    projectKey: this.projectKey
                });
                this.model.clear();
                this.collection.add(createdModel);

                this.analyticsSave = true;
                this.hide();
            });
            this.listenTo(this.sidebarItem, 'before:select', function(e) {
                e.preventDefault();
            });

            AJS.sidebar('.aui-sidebar').on('collapse-start', this.hide);
            $('.project-shortcuts-group').on('click', 'li', this.hide);
        },
        hide: function hide() {
            this.view.hideIconPicker();
            this.dialog.hide();
        },
        refresh: function refresh() {
            this.view.hideIconPicker();
            this.dialog.refresh();
        },
        hideAndRender: function hideAndRender() {
            this.hide();
        },
        focusForm: function focusForm() {
            this.view.ui.url.focus();
        }
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts-init', location = '/sidebar/project-shortcuts/project-shortcuts-analytics.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Analytics");

    var shortcutLinkSelector = "a.project-shortcuts-group__link";
    var isWithIcons = AJS.DarkFeatures.isEnabled("com.atlassian.jira.projects.ProjectCentricNavigation.ProjectShortcutIcons");

    JIRA.Projects.Sidebar.ProjectShortcuts.Analytics = {
        initialize: function(projectId) {
            this.projectId = projectId;
        },
        
        initShortcutClick: function (shortcutsElement, sidebarElement) {
            var sidebar = AJS.sidebar(sidebarElement);
            var shortcuts = AJS.$(shortcutsElement);
            var instance = this;

            shortcuts.on("click", shortcutLinkSelector, function (e) {
                var shortcutsList = shortcuts.find(shortcutLinkSelector);
                var clickedElement = AJS.$(this);

                AJS.trigger('analyticsEvent', {
                    name: "jira.projects.shortcut.clicked",
                    data: {
                        shortcutId: clickedElement.data("shortcutId"),
                        shortcutPosition: clickedElement.closest("li").index() + 1,
                        shortcutIconName: isWithIcons ? clickedElement.find(".aui-icon").data("projectShortcutsIconId") : "",
                        shortcutCount: shortcutsList.size(),
                        isWithIcons: isWithIcons,
                        isSidebarCollapsed: sidebar.isCollapsed(),
                        projectId: instance.projectId
                    }
                });
            });
        },
        
        initDialogActions: function (shortcutsList) {
            var instance = this;
            
            shortcutsList.on("childview:edit:open", function (view, model) {
                var index = model.collection.indexOf(model) + 1;
                AJS.trigger('analyticsEvent', {
                    name: "jira.projects.shortcut.edit.dialog.opened",
                    data: {
                        isWithIcons: isWithIcons,
                        shortcutId: model.get("id"),
                        shortcutPosition: index,
                        shortcutCount: model.collection.size(),
                        projectId: instance.projectId
                    }
                });
            });
            shortcutsList.on("childview:edit:close", function (view, model, save) {
                var index = model.collection.indexOf(model) + 1;
                AJS.trigger('analyticsEvent', {
                    name: "jira.projects.shortcut.edit.dialog.closed",
                    data: {
                        isWithIcons: isWithIcons,
                        isSave: save,
                        shortcutId: model.get("id"),
                        shortcutPosition: index,
                        shortcutCount: model.collection.size(),
                        projectId: instance.projectId
                    }
                });
            });
            
            shortcutsList.on("add:open", function () {
                AJS.trigger('analyticsEvent', {
                    name: "jira.projects.shortcut.add.dialog.opened",
                    data: {
                        isWithIcons: isWithIcons,
                        projectId: instance.projectId
                    }
                });
            });
            shortcutsList.on("add:close", function (save) {
                AJS.trigger('analyticsEvent', {
                    name: "jira.projects.shortcut.add.dialog.closed",
                    data: {
                        isWithIcons: isWithIcons,
                        isSave: save,
                        projectId: instance.projectId
                    }
                });            
            });
        },

        iconChanged: function (model, iconName, oldIconName) {
            AJS.trigger('analyticsEvent', {
                name: "jira.projects.shortcut.icon.changed",
                data: {
                    iconName: iconName,
                    oldIconName: oldIconName,
                    shortcutId: model.isNew() ? "" : model.get("id"),
                    isNew: model.isNew(),
                    cid: model.cid,
                    projectId: this.projectId
                }
            });
        },

        iconChangeConfirmed: function (model, iconName) {
            AJS.trigger('analyticsEvent', {
                name: "jira.projects.shortcut.icon.confirmed",
                data: {
                    oldIconName: model.get("icon"),
                    iconName: iconName,
                    shortcutId: model.isNew() ? "" : model.get("id"),
                    isNew: model.isNew(),
                    cid: model.cid,
                    projectId: this.projectId
                }
            });
        },

        iconPickerOpened: function (model) {
            AJS.trigger('analyticsEvent', {
                name: "jira.projects.shortcut.icon.picker.opened",
                data: {
                    shortcutId: model.isNew() ? "" : model.get("id"),
                    isNew: model.isNew(),
                    cid: model.cid,
                    projectId: this.projectId
                }
            });
        },

        iconPickerClosed: function (model, save) {
            AJS.trigger('analyticsEvent', {
                name: "jira.projects.shortcut.icon.picker.closed",
                data: {
                    shortcutId: model.isNew() ? "" : model.get("id"),
                    isNew: model.isNew(),
                    cid: model.cid,
                    isSave: save,
                    projectId: this.projectId
                }
            });
        }
    };
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts-init', location = '/sidebar/project-shortcuts/project-shortcuts-init.js' */
AJS.$(function ($) {
    JIRA.API.getSidebar().done(function() {

        var projectId = WRM.data.claim('com.atlassian.jira.projects.shortcuts:project-id');
        JIRA.Projects.Sidebar.ProjectShortcuts.Analytics.initialize(projectId);

        // Start everything up only if user can manage project shortcuts
        if (WRM.data.claim('com.atlassian.jira.projects.shortcuts:can-manage')) {
            JIRA.Projects.Sidebar.ProjectShortcuts.SidebarOverrides.init();

            var isWithIcons = WRM.data.claim('com.atlassian.jira.projects.shortcuts:with-icons');

            if (isWithIcons) {
                JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons.initialize(
                        WRM.data.claim('com.atlassian.jira.projects.shortcuts:icons-list'));
            }
            JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons.setWithIcons(isWithIcons);

            var projectKey = JIRA.API.Projects.getCurrentProjectKey();

            var shortcutsCollection = new JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcuts(
                WRM.data.claim('com.atlassian.jira.projects.shortcuts:shortcuts'),
                { projectKey: projectKey }
            );

            var shortcutsView = new JIRA.Projects.Sidebar.ProjectShortcuts.Views.List({
                collection: shortcutsCollection,
                targetGroup: 'project-shortcuts-group'
            });
            shortcutsView.render();

            JIRA.Projects.Sidebar.ProjectShortcuts.Analytics.initDialogActions(shortcutsView);
        }

        JIRA.Projects.Sidebar.ProjectShortcuts.Analytics.initShortcutClick('.project-shortcuts-list', '.aui-sidebar');
    });
});;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:summary-page-assets', location = '/page/project/summary/main.js' */
AJS.$(function ($) {
    $(".most-active-help").tooltip({aria: true});
    $(".project-meta-most-active .user-hover").mouseenter(
            function triggerEventOnEnter() {
                AJS.trigger('analyticsEvent', {
                    name: "jira.projects.mostactive.hovered",
                    data: {
                        index: $(".project-meta-most-active .user-hover").index(this)
                    }
                });
            }
    );
});;
;
/* module-key = 'com.atlassian.plugin.jslibs:backbone.paginator-2.0.2-factory', location = 'factories/backbone.paginator/2.0.2/backbone.paginator-2.0.2-factory.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
    define('atlassian/libs/factories/backbone.paginator-2.0.2', function() {
        return function(_, Backbone) {
            var env = {
                _: _,
                Backbone: Backbone
            };
            factory.call(env);
            var PageableCollection = Backbone.PageableCollection.noConflict();
            PageableCollection.VERSION = "2.0.2";
            return PageableCollection;
        }
    });
})(function(){
/////// End of Atlassian modification ///////

    /*
     backbone.paginator 2.0.2
     http://github.com/backbone-paginator/backbone.paginator

     Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
     Licensed under the MIT @license.
     */

    (function (factory) {
/////////// Modified by Atlassian ///////////
        var root = this;
        var _ = root._;
        var Backbone = root.Backbone;
/////// End of Atlassian modification ///////

        // CommonJS
        if (typeof exports == "object") {
            module.exports = factory(require("underscore"), require("backbone"));
        }
        // AMD
        else if (typeof define == "function" && define.amd) {
            define(["underscore", "backbone"], factory);
        }
        // Browser
        else if (typeof _ !== "undefined" && typeof Backbone !== "undefined") {
            var oldPageableCollection = Backbone.PageableCollection;
            var PageableCollection = factory(_,Backbone);

            /**
             __BROWSER ONLY__

             If you already have an object named `PageableCollection` attached to the
             `Backbone` module, you can use this to return a local reference to this
             Backbone.PageableCollection class and reset the name
             Backbone.PageableCollection to its previous definition.

             // The left hand side gives you a reference to this
             // Backbone.PageableCollection implementation, the right hand side
             // resets Backbone.PageableCollection to your other
             // Backbone.PageableCollection.
             var PageableCollection = Backbone.PageableCollection.noConflict();

             @static
             @member Backbone.PageableCollection
             @return {Backbone.PageableCollection}
             */
            Backbone.PageableCollection.noConflict = function () {
                Backbone.PageableCollection = oldPageableCollection;
                return PageableCollection;
            };
        }

/////////// Modified by Atlassian ///////////
    }).call(this, (function (_, Backbone)
    {
/////// End of Atlassian modification ///////

        "use strict";

        var _extend = _.extend;
        var _omit = _.omit;
        var _clone = _.clone;
        var _each = _.each;
        var _pick = _.pick;
        var _contains = _.contains;
        var _isEmpty = _.isEmpty;
        var _pairs = _.pairs;
        var _invert = _.invert;
        var _isArray = _.isArray;
        var _isFunction = _.isFunction;
        var _isObject = _.isObject;
        var _keys = _.keys;
        var _isUndefined = _.isUndefined;
        var ceil = Math.ceil;
        var floor = Math.floor;
        var max = Math.max;

        var BBColProto = Backbone.Collection.prototype;

        function finiteInt (val, name) {
            if (!_.isNumber(val) || _.isNaN(val) || !_.isFinite(val) || ~~val !== val) {
                throw new TypeError("`" + name + "` must be a finite integer");
            }
            return val;
        }

        function queryStringToParams (qs) {
            var kvp, k, v, ls, params = {}, decode = decodeURIComponent;
            var kvps = qs.split('&');
            for (var i = 0, l = kvps.length; i < l; i++) {
                var param = kvps[i];
                kvp = param.split('='), k = kvp[0], v = kvp[1] || true;
                k = decode(k), v = decode(v), ls = params[k];
                if (_isArray(ls)) ls.push(v);
                else if (ls) params[k] = [ls, v];
                else params[k] = v;
            }
            return params;
        }

        // hack to make sure the whatever event handlers for this event is run
        // before func is, and the event handlers that func will trigger.
        function runOnceAtLastHandler (col, event, func) {
            var eventHandlers = col._events[event];
            if (eventHandlers && eventHandlers.length) {
                var lastHandler = eventHandlers[eventHandlers.length - 1];
                var oldCallback = lastHandler.callback;
                lastHandler.callback = function () {
                    try {
                        oldCallback.apply(this, arguments);
                        func();
                    }
                    catch (e) {
                        throw e;
                    }
                    finally {
                        lastHandler.callback = oldCallback;
                    }
                };
            }
            else func();
        }

        var PARAM_TRIM_RE = /[\s'"]/g;
        var URL_TRIM_RE = /[<>\s'"]/g;

        /**
         Drop-in replacement for Backbone.Collection. Supports server-side and
         client-side pagination and sorting. Client-side mode also support fully
         multi-directional synchronization of changes between pages.

         @class Backbone.PageableCollection
         @extends Backbone.Collection
         */
        var PageableCollection = Backbone.PageableCollection = Backbone.Collection.extend({

            /**
             The container object to store all pagination states.

             You can override the default state by extending this class or specifying
             them in an `options` hash to the constructor.

             @property {Object} state

             @property {0|1} [state.firstPage=1] The first page index. Set to 0 if
             your server API uses 0-based indices. You should only override this value
             during extension, initialization or reset by the server after
             fetching. This value should be read only at other times.

             @property {number} [state.lastPage=null] The last page index. This value
             is __read only__ and it's calculated based on whether `firstPage` is 0 or
             1, during bootstrapping, fetching and resetting. Please don't change this
             value under any circumstances.

             @property {number} [state.currentPage=null] The current page index. You
             should only override this value during extension, initialization or reset
             by the server after fetching. This value should be read only at other
             times. Can be a 0-based or 1-based index, depending on whether
             `firstPage` is 0 or 1. If left as default, it will be set to `firstPage`
             on initialization.

             @property {number} [state.pageSize=25] How many records to show per
             page. This value is __read only__ after initialization, if you want to
             change the page size after initialization, you must call #setPageSize.

             @property {number} [state.totalPages=null] How many pages there are. This
             value is __read only__ and it is calculated from `totalRecords`.

             @property {number} [state.totalRecords=null] How many records there
             are. This value is __required__ under server mode. This value is optional
             for client mode as the number will be the same as the number of models
             during bootstrapping and during fetching, either supplied by the server
             in the metadata, or calculated from the size of the response.

             @property {string} [state.sortKey=null] The model attribute to use for
             sorting.

             @property {-1|0|1} [state.order=-1] The order to use for sorting. Specify
             -1 for ascending order or 1 for descending order. If 0, no client side
             sorting will be done and the order query parameter will not be sent to
             the server during a fetch.
             */
            state: {
                firstPage: 1,
                lastPage: null,
                currentPage: null,
                pageSize: 25,
                totalPages: null,
                totalRecords: null,
                sortKey: null,
                order: -1
            },

            /**
             @property {"server"|"client"|"infinite"} [mode="server"] The mode of
             operations for this collection. `"server"` paginates on the server-side,
             `"client"` paginates on the client-side and `"infinite"` paginates on the
             server-side for APIs that do not support `totalRecords`.
             */
            mode: "server",

            /**
             A translation map to convert Backbone.PageableCollection state attributes
             to the query parameters accepted by your server API.

             You can override the default state by extending this class or specifying
             them in `options.queryParams` object hash to the constructor.

             @property {Object} queryParams
             @property {string} [queryParams.currentPage="page"]
             @property {string} [queryParams.pageSize="per_page"]
             @property {string} [queryParams.totalPages="total_pages"]
             @property {string} [queryParams.totalRecords="total_entries"]
             @property {string} [queryParams.sortKey="sort_by"]
             @property {string} [queryParams.order="order"]
             @property {string} [queryParams.directions={"-1": "asc", "1": "desc"}] A
             map for translating a Backbone.PageableCollection#state.order constant to
             the ones your server API accepts.
             */
            queryParams: {
                currentPage: "page",
                pageSize: "per_page",
                totalPages: "total_pages",
                totalRecords: "total_entries",
                sortKey: "sort_by",
                order: "order",
                directions: {
                    "-1": "asc",
                    "1": "desc"
                }
            },

            /**
             __CLIENT MODE ONLY__

             This collection is the internal storage for the bootstrapped or fetched
             models. You can use this if you want to operate on all the pages.

             @property {Backbone.Collection} fullCollection
             */

            /**
             Given a list of models or model attributues, bootstraps the full
             collection in client mode or infinite mode, or just the page you want in
             server mode.

             If you want to initialize a collection to a different state than the
             default, you can specify them in `options.state`. Any state parameters
             supplied will be merged with the default. If you want to change the
             default mapping from #state keys to your server API's query parameter
             names, you can specifiy an object hash in `option.queryParams`. Likewise,
             any mapping provided will be merged with the default. Lastly, all
             Backbone.Collection constructor options are also accepted.

             See:

             - Backbone.PageableCollection#state
             - Backbone.PageableCollection#queryParams
             - [Backbone.Collection#initialize](http://backbonejs.org/#Collection-constructor)

             @param {Array.<Object>} [models]

             @param {Object} [options]

             @param {function(*, *): number} [options.comparator] If specified, this
             comparator is set to the current page under server mode, or the #fullCollection
             otherwise.

             @param {boolean} [options.full] If `false` and either a
             `options.comparator` or `sortKey` is defined, the comparator is attached
             to the current page. Default is `true` under client or infinite mode and
             the comparator will be attached to the #fullCollection.

             @param {Object} [options.state] The state attributes overriding the defaults.

             @param {string} [options.state.sortKey] The model attribute to use for
             sorting. If specified instead of `options.comparator`, a comparator will
             be automatically created using this value, and optionally a sorting order
             specified in `options.state.order`. The comparator is then attached to
             the new collection instance.

             @param {-1|1} [options.state.order] The order to use for sorting. Specify
             -1 for ascending order and 1 for descending order.

             @param {Object} [options.queryParam]
             */
            constructor: function (models, options) {

                BBColProto.constructor.apply(this, arguments);

                options = options || {};

                var mode = this.mode = options.mode || this.mode || PageableProto.mode;

                var queryParams = _extend({}, PageableProto.queryParams, this.queryParams,
                                options.queryParams || {});

                queryParams.directions = _extend({},
                        PageableProto.queryParams.directions,
                        this.queryParams.directions,
                                queryParams.directions || {});

                this.queryParams = queryParams;

                var state = this.state = _extend({}, PageableProto.state, this.state,
                                options.state || {});

                state.currentPage = state.currentPage == null ?
                        state.firstPage :
                        state.currentPage;

                if (!_isArray(models)) models = models ? [models] : [];
                models = models.slice();

                if (mode != "server" && state.totalRecords == null && !_isEmpty(models)) {
                    state.totalRecords = models.length;
                }

                this.switchMode(mode, _extend({fetch: false,
                    resetState: false,
                    models: models}, options));

                var comparator = options.comparator;

                if (state.sortKey && !comparator) {
                    this.setSorting(state.sortKey, state.order, options);
                }

                if (mode != "server") {
                    var fullCollection = this.fullCollection;

                    if (comparator && options.full) {
                        this.comparator = null;
                        fullCollection.comparator = comparator;
                    }

                    if (options.full) fullCollection.sort();

                    // make sure the models in the current page and full collection have the
                    // same references
                    if (models && !_isEmpty(models)) {
                        this.reset(models, _extend({silent: true}, options));
                        this.getPage(state.currentPage);
                        models.splice.apply(models, [0, models.length].concat(this.models));
                    }
                }

                this._initState = _clone(this.state);
            },

            /**
             Makes a Backbone.Collection that contains all the pages.

             @private
             @param {Array.<Object|Backbone.Model>} models
             @param {Object} options Options for Backbone.Collection constructor.
             @return {Backbone.Collection}
             */
            _makeFullCollection: function (models, options) {

                var properties = ["url", "model", "sync", "comparator"];
                var thisProto = this.constructor.prototype;
                var i, length, prop;

                var proto = {};
                for (i = 0, length = properties.length; i < length; i++) {
                    prop = properties[i];
                    if (!_isUndefined(thisProto[prop])) {
                        proto[prop] = thisProto[prop];
                    }
                }

                var fullCollection = new (Backbone.Collection.extend(proto))(models, options);

                for (i = 0, length = properties.length; i < length; i++) {
                    prop = properties[i];
                    if (this[prop] !== thisProto[prop]) {
                        fullCollection[prop] = this[prop];
                    }
                }

                return fullCollection;
            },

            /**
             Factory method that returns a Backbone event handler that responses to
             the `add`, `remove`, `reset`, and the `sort` events. The returned event
             handler will synchronize the current page collection and the full
             collection's models.

             @private

             @param {Backbone.PageableCollection} pageCol
             @param {Backbone.Collection} fullCol

             @return {function(string, Backbone.Model, Backbone.Collection, Object)}
             Collection event handler
             */
            _makeCollectionEventHandler: function (pageCol, fullCol) {

                return function collectionEventHandler (event, model, collection, options) {

                    var handlers = pageCol._handlers;
                    _each(_keys(handlers), function (event) {
                        var handler = handlers[event];
                        pageCol.off(event, handler);
                        fullCol.off(event, handler);
                    });

                    var state = _clone(pageCol.state);
                    var firstPage = state.firstPage;
                    var currentPage = firstPage === 0 ?
                            state.currentPage :
                            state.currentPage - 1;
                    var pageSize = state.pageSize;
                    var pageStart = currentPage * pageSize, pageEnd = pageStart + pageSize;

                    if (event == "add") {
                        var pageIndex, fullIndex, addAt, colToAdd, options = options || {};
                        if (collection == fullCol) {
                            fullIndex = fullCol.indexOf(model);
                            if (fullIndex >= pageStart && fullIndex < pageEnd) {
                                colToAdd = pageCol;
                                pageIndex = addAt = fullIndex - pageStart;
                            }
                        }
                        else {
                            pageIndex = pageCol.indexOf(model);
                            fullIndex = pageStart + pageIndex;
                            colToAdd = fullCol;
                            var addAt = !_isUndefined(options.at) ?
                                    options.at + pageStart :
                                    fullIndex;
                        }

                        if (!options.onRemove) {
                            ++state.totalRecords;
                            delete options.onRemove;
                        }

                        pageCol.state = pageCol._checkState(state);

                        if (colToAdd) {
                            colToAdd.add(model, _extend({}, options || {}, {at: addAt}));
                            var modelToRemove = pageIndex >= pageSize ?
                                    model :
                                            !_isUndefined(options.at) && addAt < pageEnd && pageCol.length > pageSize ?
                                    pageCol.at(pageSize) :
                                    null;
                            if (modelToRemove) {
                                runOnceAtLastHandler(collection, event, function () {
                                    pageCol.remove(modelToRemove, {onAdd: true});
                                });
                            }
                        }
                    }

                    // remove the model from the other collection as well
                    if (event == "remove") {
                        if (!options.onAdd) {
                            // decrement totalRecords and update totalPages and lastPage
                            if (!--state.totalRecords) {
                                state.totalRecords = null;
                                state.totalPages = null;
                            }
                            else {
                                var totalPages = state.totalPages = ceil(state.totalRecords / pageSize);
                                state.lastPage = firstPage === 0 ? totalPages - 1 : totalPages || firstPage;
                                if (state.currentPage > totalPages) state.currentPage = state.lastPage;
                            }
                            pageCol.state = pageCol._checkState(state);

                            var nextModel, removedIndex = options.index;
                            if (collection == pageCol) {
                                if (nextModel = fullCol.at(pageEnd)) {
                                    runOnceAtLastHandler(pageCol, event, function () {
                                        pageCol.push(nextModel, {onRemove: true});
                                    });
                                }
                                else if (!pageCol.length && state.totalRecords) {
                                    pageCol.reset(fullCol.models.slice(pageStart - pageSize, pageEnd - pageSize),
                                            _extend({}, options, {parse: false}));
                                }
                                fullCol.remove(model);
                            }
                            else if (removedIndex >= pageStart && removedIndex < pageEnd) {
                                if (nextModel = fullCol.at(pageEnd - 1)) {
                                    runOnceAtLastHandler(pageCol, event, function() {
                                        pageCol.push(nextModel, {onRemove: true});
                                    });
                                }
                                pageCol.remove(model);
                                if (!pageCol.length && state.totalRecords) {
                                    pageCol.reset(fullCol.models.slice(pageStart - pageSize, pageEnd - pageSize),
                                            _extend({}, options, {parse: false}));
                                }
                            }
                        }
                        else delete options.onAdd;
                    }

                    if (event == "reset") {
                        options = collection;
                        collection = model;

                        // Reset that's not a result of getPage
                        if (collection == pageCol && options.from == null &&
                                options.to == null) {
                            var head = fullCol.models.slice(0, pageStart);
                            var tail = fullCol.models.slice(pageStart + pageCol.models.length);
                            fullCol.reset(head.concat(pageCol.models).concat(tail), options);
                        }
                        else if (collection == fullCol) {
                            if (!(state.totalRecords = fullCol.models.length)) {
                                state.totalRecords = null;
                                state.totalPages = null;
                            }
                            if (pageCol.mode == "client") {
                                state.lastPage = state.currentPage = state.firstPage;
                            }
                            pageCol.state = pageCol._checkState(state);
                            pageCol.reset(fullCol.models.slice(pageStart, pageEnd),
                                    _extend({}, options, {parse: false}));
                        }
                    }

                    if (event == "sort") {
                        options = collection;
                        collection = model;
                        if (collection === fullCol) {
                            pageCol.reset(fullCol.models.slice(pageStart, pageEnd),
                                    _extend({}, options, {parse: false}));
                        }
                    }

                    _each(_keys(handlers), function (event) {
                        var handler = handlers[event];
                        _each([pageCol, fullCol], function (col) {
                            col.on(event, handler);
                            var callbacks = col._events[event] || [];
                            callbacks.unshift(callbacks.pop());
                        });
                    });
                };
            },

            /**
             Sanity check this collection's pagination states. Only perform checks
             when all the required pagination state values are defined and not null.
             If `totalPages` is undefined or null, it is set to `totalRecords` /
             `pageSize`. `lastPage` is set according to whether `firstPage` is 0 or 1
             when no error occurs.

             @private

             @throws {TypeError} If `totalRecords`, `pageSize`, `currentPage` or
             `firstPage` is not a finite integer.

             @throws {RangeError} If `pageSize`, `currentPage` or `firstPage` is out
             of bounds.

             @return {Object} Returns the `state` object if no error was found.
             */
            _checkState: function (state) {

                var mode = this.mode;
                var links = this.links;
                var totalRecords = state.totalRecords;
                var pageSize = state.pageSize;
                var currentPage = state.currentPage;
                var firstPage = state.firstPage;
                var totalPages = state.totalPages;

                if (totalRecords != null && pageSize != null && currentPage != null &&
                        firstPage != null && (mode == "infinite" ? links : true)) {

                    totalRecords = finiteInt(totalRecords, "totalRecords");
                    pageSize = finiteInt(pageSize, "pageSize");
                    currentPage = finiteInt(currentPage, "currentPage");
                    firstPage = finiteInt(firstPage, "firstPage");

                    if (pageSize < 1) {
                        throw new RangeError("`pageSize` must be >= 1");
                    }

                    totalPages = state.totalPages = ceil(totalRecords / pageSize);

                    if (firstPage < 0 || firstPage > 1) {
                        throw new RangeError("`firstPage must be 0 or 1`");
                    }

                    state.lastPage = firstPage === 0 ? max(0, totalPages - 1) : totalPages || firstPage;

                    if (mode == "infinite") {
                        if (!links[currentPage + '']) {
                            throw new RangeError("No link found for page " + currentPage);
                        }
                    }
                    else if (currentPage < firstPage ||
                            (totalPages > 0 &&
                                    (firstPage ? currentPage > totalPages : currentPage >= totalPages))) {
                        throw new RangeError("`currentPage` must be firstPage <= currentPage " +
                                (firstPage ? ">" : ">=") +
                                " totalPages if " + firstPage + "-based. Got " +
                                currentPage + '.');
                    }
                }

                return state;
            },

            /**
             Change the page size of this collection.

             Under most if not all circumstances, you should call this method to
             change the page size of a pageable collection because it will keep the
             pagination state sane. By default, the method will recalculate the
             current page number to one that will retain the current page's models
             when increasing the page size. When decreasing the page size, this method
             will retain the last models to the current page that will fit into the
             smaller page size.

             If `options.first` is true, changing the page size will also reset the
             current page back to the first page instead of trying to be smart.

             For server mode operations, changing the page size will trigger a #fetch
             and subsequently a `reset` event.

             For client mode operations, changing the page size will `reset` the
             current page by recalculating the current page boundary on the client
             side.

             If `options.fetch` is true, a fetch can be forced if the collection is in
             client mode.

             @param {number} pageSize The new page size to set to #state.
             @param {Object} [options] {@link #fetch} options.
             @param {boolean} [options.first=false] Reset the current page number to
             the first page if `true`.
             @param {boolean} [options.fetch] If `true`, force a fetch in client mode.

             @throws {TypeError} If `pageSize` is not a finite integer.
             @throws {RangeError} If `pageSize` is less than 1.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            setPageSize: function (pageSize, options) {
                pageSize = finiteInt(pageSize, "pageSize");

                options = options || {first: false};

                var state = this.state;
                var totalPages = ceil(state.totalRecords / pageSize);
                var currentPage = totalPages ?
                        max(state.firstPage, floor(totalPages * state.currentPage / state.totalPages)) :
                        state.firstPage;

                state = this.state = this._checkState(_extend({}, state, {
                    pageSize: pageSize,
                    currentPage: options.first ? state.firstPage : currentPage,
                    totalPages: totalPages
                }));

                return this.getPage(state.currentPage, _omit(options, ["first"]));
            },

            /**
             Switching between client, server and infinite mode.

             If switching from client to server mode, the #fullCollection is emptied
             first and then deleted and a fetch is immediately issued for the current
             page from the server. Pass `false` to `options.fetch` to skip fetching.

             If switching to infinite mode, and if `options.models` is given for an
             array of models, #links will be populated with a URL per page, using the
             default URL for this collection.

             If switching from server to client mode, all of the pages are immediately
             refetched. If you have too many pages, you can pass `false` to
             `options.fetch` to skip fetching.

             If switching to any mode from infinite mode, the #links will be deleted.

             @param {"server"|"client"|"infinite"} [mode] The mode to switch to.

             @param {Object} [options]

             @param {boolean} [options.fetch=true] If `false`, no fetching is done.

             @param {boolean} [options.resetState=true] If 'false', the state is not
             reset, but checked for sanity instead.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this if `options.fetch` is `false`.
             */
            switchMode: function (mode, options) {

                if (!_contains(["server", "client", "infinite"], mode)) {
                    throw new TypeError('`mode` must be one of "server", "client" or "infinite"');
                }

                options = options || {fetch: true, resetState: true};

                var state = this.state = options.resetState ?
                        _clone(this._initState) :
                        this._checkState(_extend({}, this.state));

                this.mode = mode;

                var self = this;
                var fullCollection = this.fullCollection;
                var handlers = this._handlers = this._handlers || {}, handler;
                if (mode != "server" && !fullCollection) {
                    fullCollection = this._makeFullCollection(options.models || [], options);
                    fullCollection.pageableCollection = this;
                    this.fullCollection = fullCollection;
                    var allHandler = this._makeCollectionEventHandler(this, fullCollection);
                    _each(["add", "remove", "reset", "sort"], function (event) {
                        handlers[event] = handler = _.bind(allHandler, {}, event);
                        self.on(event, handler);
                        fullCollection.on(event, handler);
                    });
                    fullCollection.comparator = this._fullComparator;
                }
                else if (mode == "server" && fullCollection) {
                    _each(_keys(handlers), function (event) {
                        handler = handlers[event];
                        self.off(event, handler);
                        fullCollection.off(event, handler);
                    });
                    delete this._handlers;
                    this._fullComparator = fullCollection.comparator;
                    delete this.fullCollection;
                }

                if (mode == "infinite") {
                    var links = this.links = {};
                    var firstPage = state.firstPage;
                    var totalPages = ceil(state.totalRecords / state.pageSize);
                    var lastPage = firstPage === 0 ? max(0, totalPages - 1) : totalPages || firstPage;
                    for (var i = state.firstPage; i <= lastPage; i++) {
                        links[i] = this.url;
                    }
                }
                else if (this.links) delete this.links;

                return options.fetch ?
                        this.fetch(_omit(options, "fetch", "resetState")) :
                        this;
            },

            /**
             @return {boolean} `true` if this collection can page backward, `false`
             otherwise.
             */
            hasPreviousPage: function () {
                var state = this.state;
                var currentPage = state.currentPage;
                if (this.mode != "infinite") return currentPage > state.firstPage;
                return !!this.links[currentPage - 1];
            },

            /**
             @return {boolean} `true` if this collection can page forward, `false`
             otherwise.
             */
            hasNextPage: function () {
                var state = this.state;
                var currentPage = this.state.currentPage;
                if (this.mode != "infinite") return currentPage < state.lastPage;
                return !!this.links[currentPage + 1];
            },

            /**
             Fetch the first page in server mode, or reset the current page of this
             collection to the first page in client or infinite mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getFirstPage: function (options) {
                return this.getPage("first", options);
            },

            /**
             Fetch the previous page in server mode, or reset the current page of this
             collection to the previous page in client or infinite mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getPreviousPage: function (options) {
                return this.getPage("prev", options);
            },

            /**
             Fetch the next page in server mode, or reset the current page of this
             collection to the next page in client mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getNextPage: function (options) {
                return this.getPage("next", options);
            },

            /**
             Fetch the last page in server mode, or reset the current page of this
             collection to the last page in client mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getLastPage: function (options) {
                return this.getPage("last", options);
            },

            /**
             Given a page index, set #state.currentPage to that index. If this
             collection is in server mode, fetch the page using the updated state,
             otherwise, reset the current page of this collection to the page
             specified by `index` in client mode. If `options.fetch` is true, a fetch
             can be forced in client mode before resetting the current page. Under
             infinite mode, if the index is less than the current page, a reset is
             done as in client mode. If the index is greater than the current page
             number, a fetch is made with the results **appended** to #fullCollection.
             The current page will then be reset after fetching.

             @param {number|string} index The page index to go to, or the page name to
             look up from #links in infinite mode.
             @param {Object} [options] {@link #fetch} options or
             [reset](http://backbonejs.org/#Collection-reset) options for client mode
             when `options.fetch` is `false`.
             @param {boolean} [options.fetch=false] If true, force a {@link #fetch} in
             client mode.

             @throws {TypeError} If `index` is not a finite integer under server or
             client mode, or does not yield a URL from #links under infinite mode.

             @throws {RangeError} If `index` is out of bounds.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getPage: function (index, options) {

                var mode = this.mode, fullCollection = this.fullCollection;

                options = options || {fetch: false};

                var state = this.state,
                        firstPage = state.firstPage,
                        currentPage = state.currentPage,
                        lastPage = state.lastPage,
                        pageSize = state.pageSize;

                var pageNum = index;
                switch (index) {
                    case "first": pageNum = firstPage; break;
                    case "prev": pageNum = currentPage - 1; break;
                    case "next": pageNum = currentPage + 1; break;
                    case "last": pageNum = lastPage; break;
                    default: pageNum = finiteInt(index, "index");
                }

                this.state = this._checkState(_extend({}, state, {currentPage: pageNum}));

                options.from = currentPage, options.to = pageNum;

                var pageStart = (firstPage === 0 ? pageNum : pageNum - 1) * pageSize;
                var pageModels = fullCollection && fullCollection.length ?
                        fullCollection.models.slice(pageStart, pageStart + pageSize) :
                        [];
                if ((mode == "client" || (mode == "infinite" && !_isEmpty(pageModels))) &&
                        !options.fetch) {
                    this.reset(pageModels, _omit(options, "fetch"));
                    return this;
                }

                if (mode == "infinite") options.url = this.links[pageNum];

                return this.fetch(_omit(options, "fetch"));
            },

            /**
             Fetch the page for the provided item offset in server mode, or reset the current page of this
             collection to the page for the provided item offset in client mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getPageByOffset: function (offset, options) {
                if (offset < 0) {
                    throw new RangeError("`offset must be > 0`");
                }
                offset = finiteInt(offset);

                var page = floor(offset / this.state.pageSize);
                if (this.state.firstPage !== 0) page++;
                if (page > this.state.lastPage) page = this.state.lastPage;
                return this.getPage(page, options);
            },

            /**
             Overidden to make `getPage` compatible with Zepto.

             @param {string} method
             @param {Backbone.Model|Backbone.Collection} model
             @param {Object} [options]

             @return {XMLHttpRequest}
             */
            sync: function (method, model, options) {
                var self = this;
                if (self.mode == "infinite") {
                    var success = options.success;
                    var currentPage = self.state.currentPage;
                    options.success = function (resp, status, xhr) {
                        var links = self.links;
                        var newLinks = self.parseLinks(resp, _extend({xhr: xhr}, options));
                        if (newLinks.first) links[self.state.firstPage] = newLinks.first;
                        if (newLinks.prev) links[currentPage - 1] = newLinks.prev;
                        if (newLinks.next) links[currentPage + 1] = newLinks.next;
                        if (success) success(resp, status, xhr);
                    };
                }

                return (BBColProto.sync || Backbone.sync).call(self, method, model, options);
            },

            /**
             Parse pagination links from the server response. Only valid under
             infinite mode.

             Given a response body and a XMLHttpRequest object, extract pagination
             links from them for infinite paging.

             This default implementation parses the RFC 5988 `Link` header and extract
             3 links from it - `first`, `prev`, `next`. Any subclasses overriding this
             method __must__ return an object hash having only the keys
             above. However, simply returning a `next` link or an empty hash if there
             are no more links should be enough for most implementations.

             @param {*} resp The deserialized response body.
             @param {Object} [options]
             @param {XMLHttpRequest} [options.xhr] The XMLHttpRequest object for this
             response.
             @return {Object}
             */
            parseLinks: function (resp, options) {
                var links = {};
                var linkHeader = options.xhr.getResponseHeader("Link");
                if (linkHeader) {
                    var relations = ["first", "prev", "next"];
                    _each(linkHeader.split(","), function (linkValue) {
                        var linkParts = linkValue.split(";");
                        var url = linkParts[0].replace(URL_TRIM_RE, '');
                        var params = linkParts.slice(1);
                        _each(params, function (param) {
                            var paramParts = param.split("=");
                            var key = paramParts[0].replace(PARAM_TRIM_RE, '');
                            var value = paramParts[1].replace(PARAM_TRIM_RE, '');
                            if (key == "rel" && _contains(relations, value)) links[value] = url;
                        });
                    });
                }

                return links;
            },

            /**
             Parse server response data.

             This default implementation assumes the response data is in one of two
             structures:

             [
             {}, // Your new pagination state
             [{}, ...] // An array of JSON objects
             ]

             Or,

             [{}] // An array of JSON objects

             The first structure is the preferred form because the pagination states
             may have been updated on the server side, sending them down again allows
             this collection to update its states. If the response has a pagination
             state object, it is checked for errors.

             The second structure is the
             [Backbone.Collection#parse](http://backbonejs.org/#Collection-parse)
             default.

             **Note:** this method has been further simplified since 1.1.7. While
             existing #parse implementations will continue to work, new code is
             encouraged to override #parseState and #parseRecords instead.

             @param {Object} resp The deserialized response data from the server.
             @param {Object} the options for the ajax request

             @return {Array.<Object>} An array of model objects
             */
            parse: function (resp, options) {
                var newState = this.parseState(resp, _clone(this.queryParams), _clone(this.state), options);
                if (newState) this.state = this._checkState(_extend({}, this.state, newState));
                return this.parseRecords(resp, options);
            },

            /**
             Parse server response for server pagination state updates. Not applicable
             under infinite mode.

             This default implementation first checks whether the response has any
             state object as documented in #parse. If it exists, a state object is
             returned by mapping the server state keys to this pageable collection
             instance's query parameter keys using `queryParams`.

             It is __NOT__ neccessary to return a full state object complete with all
             the mappings defined in #queryParams. Any state object resulted is merged
             with a copy of the current pageable collection state and checked for
             sanity before actually updating. Most of the time, simply providing a new
             `totalRecords` value is enough to trigger a full pagination state
             recalculation.

             parseState: function (resp, queryParams, state, options) {
                 return {totalRecords: resp.total_entries};
               }

             If you want to use header fields use:

             parseState: function (resp, queryParams, state, options) {
                   return {totalRecords: options.xhr.getResponseHeader("X-total")};
               }

             This method __MUST__ return a new state object instead of directly
             modifying the #state object. The behavior of directly modifying #state is
             undefined.

             @param {Object} resp The deserialized response data from the server.
             @param {Object} queryParams A copy of #queryParams.
             @param {Object} state A copy of #state.
             @param {Object} [options] The options passed through from
             `parse`. (backbone >= 0.9.10 only)

             @return {Object} A new (partial) state object.
             */
            parseState: function (resp, queryParams, state, options) {
                if (resp && resp.length === 2 && _isObject(resp[0]) && _isArray(resp[1])) {

                    var newState = _clone(state);
                    var serverState = resp[0];

                    _each(_pairs(_omit(queryParams, "directions")), function (kvp) {
                        var k = kvp[0], v = kvp[1];
                        var serverVal = serverState[v];
                        if (!_isUndefined(serverVal) && !_.isNull(serverVal)) newState[k] = serverState[v];
                    });

                    if (serverState.order) {
                        newState.order = _invert(queryParams.directions)[serverState.order] * 1;
                    }

                    return newState;
                }
            },

            /**
             Parse server response for an array of model objects.

             This default implementation first checks whether the response has any
             state object as documented in #parse. If it exists, the array of model
             objects is assumed to be the second element, otherwise the entire
             response is returned directly.

             @param {Object} resp The deserialized response data from the server.
             @param {Object} [options] The options passed through from the
             `parse`. (backbone >= 0.9.10 only)

             @return {Array.<Object>} An array of model objects
             */
            parseRecords: function (resp, options) {
                if (resp && resp.length === 2 && _isObject(resp[0]) && _isArray(resp[1])) {
                    return resp[1];
                }

                return resp;
            },

            /**
             Fetch a page from the server in server mode, or all the pages in client
             mode. Under infinite mode, the current page is refetched by default and
             then reset.

             The query string is constructed by translating the current pagination
             state to your server API query parameter using #queryParams. The current
             page will reset after fetch.

             @param {Object} [options] Accepts all
             [Backbone.Collection#fetch](http://backbonejs.org/#Collection-fetch)
             options.

             @return {XMLHttpRequest}
             */
            fetch: function (options) {

                options = options || {};

                var state = this._checkState(this.state);

                var mode = this.mode;

                if (mode == "infinite" && !options.url) {
                    options.url = this.links[state.currentPage];
                }

                var data = options.data || {};

                // dedup query params
                var url = options.url || this.url || "";
                if (_isFunction(url)) url = url.call(this);
                var qsi = url.indexOf('?');
                if (qsi != -1) {
                    _extend(data, queryStringToParams(url.slice(qsi + 1)));
                    url = url.slice(0, qsi);
                }

                options.url = url;
                options.data = data;

                // map params except directions
                var queryParams = this.mode == "client" ?
                        _pick(this.queryParams, "sortKey", "order") :
                        _omit(_pick(this.queryParams, _keys(PageableProto.queryParams)),
                                "directions");

                var i, kvp, k, v, kvps = _pairs(queryParams), thisCopy = _clone(this);
                for (i = 0; i < kvps.length; i++) {
                    kvp = kvps[i], k = kvp[0], v = kvp[1];
                    v = _isFunction(v) ? v.call(thisCopy) : v;
                    if (state[k] != null && v != null) {
                        data[v] = state[k];
                    }
                }

                // fix up sorting parameters
                if (state.sortKey && state.order) {
                    var o = _isFunction(queryParams.order) ?
                            queryParams.order.call(thisCopy) :
                            queryParams.order;
                    data[o] = this.queryParams.directions[state.order + ""];
                }
                else if (!state.sortKey) delete data[queryParams.order];

                // map extra query parameters
                var extraKvps = _pairs(_omit(this.queryParams,
                        _keys(PageableProto.queryParams)));
                for (i = 0; i < extraKvps.length; i++) {
                    kvp = extraKvps[i];
                    v = kvp[1];
                    v = _isFunction(v) ? v.call(thisCopy) : v;
                    if (v != null) data[kvp[0]] = v;
                }

                if (mode != "server") {
                    var self = this, fullCol = this.fullCollection;
                    var success = options.success;
                    options.success = function (col, resp, opts) {

                        // make sure the caller's intent is obeyed
                        opts = opts || {};
                        if (_isUndefined(options.silent)) delete opts.silent;
                        else opts.silent = options.silent;

                        var models = col.models;
                        if (mode == "client") fullCol.reset(models, opts);
                        else {
                            fullCol.add(models, _extend({at: fullCol.length},
                                    _extend(opts, {parse: false})));
                            self.trigger("reset", self, opts);
                        }

                        if (success) success(col, resp, opts);
                    };

                    // silent the first reset from backbone
                    return BBColProto.fetch.call(this, _extend({}, options, {silent: true}));
                }

                return BBColProto.fetch.call(this, options);
            },

            /**
             Convenient method for making a `comparator` sorted by a model attribute
             identified by `sortKey` and ordered by `order`.

             Like a Backbone.Collection, a Backbone.PageableCollection will maintain
             the __current page__ in sorted order on the client side if a `comparator`
             is attached to it. If the collection is in client mode, you can attach a
             comparator to #fullCollection to have all the pages reflect the global
             sorting order by specifying an option `full` to `true`. You __must__ call
             `sort` manually or #fullCollection.sort after calling this method to
             force a resort.

             While you can use this method to sort the current page in server mode,
             the sorting order may not reflect the global sorting order due to the
             additions or removals of the records on the server since the last
             fetch. If you want the most updated page in a global sorting order, it is
             recommended that you set #state.sortKey and optionally #state.order, and
             then call #fetch.

             @protected

             @param {string} [sortKey=this.state.sortKey] See `state.sortKey`.
             @param {number} [order=this.state.order] See `state.order`.
             @param {(function(Backbone.Model, string): Object) | string} [sortValue] See #setSorting.

             See [Backbone.Collection.comparator](http://backbonejs.org/#Collection-comparator).
             */
            _makeComparator: function (sortKey, order, sortValue) {
                var state = this.state;

                sortKey = sortKey || state.sortKey;
                order = order || state.order;

                if (!sortKey || !order) return;

                if (!sortValue) sortValue = function (model, attr) {
                    return model.get(attr);
                };

                return function (left, right) {
                    var l = sortValue(left, sortKey), r = sortValue(right, sortKey), t;
                    if (order === 1) t = l, l = r, r = t;
                    if (l === r) return 0;
                    else if (l < r) return -1;
                    return 1;
                };
            },

            /**
             Adjusts the sorting for this pageable collection.

             Given a `sortKey` and an `order`, sets `state.sortKey` and
             `state.order`. A comparator can be applied on the client side to sort in
             the order defined if `options.side` is `"client"`. By default the
             comparator is applied to the #fullCollection. Set `options.full` to
             `false` to apply a comparator to the current page under any mode. Setting
             `sortKey` to `null` removes the comparator from both the current page and
             the full collection.

             If a `sortValue` function is given, it will be passed the `(model,
             sortKey)` arguments and is used to extract a value from the model during
             comparison sorts. If `sortValue` is not given, `model.get(sortKey)` is
             used for sorting.

             @chainable

             @param {string} sortKey See `state.sortKey`.
             @param {number} [order=this.state.order] See `state.order`.
             @param {Object} [options]
             @param {"server"|"client"} [options.side] By default, `"client"` if
             `mode` is `"client"`, `"server"` otherwise.
             @param {boolean} [options.full=true]
             @param {(function(Backbone.Model, string): Object) | string} [options.sortValue]
             */
            setSorting: function (sortKey, order, options) {

                var state = this.state;

                state.sortKey = sortKey;
                state.order = order = order || state.order;

                var fullCollection = this.fullCollection;

                var delComp = false, delFullComp = false;

                if (!sortKey) delComp = delFullComp = true;

                var mode = this.mode;
                options = _extend({side: mode == "client" ? mode : "server", full: true},
                        options);

                var comparator = this._makeComparator(sortKey, order, options.sortValue);

                var full = options.full, side = options.side;

                if (side == "client") {
                    if (full) {
                        if (fullCollection) fullCollection.comparator = comparator;
                        delComp = true;
                    }
                    else {
                        this.comparator = comparator;
                        delFullComp = true;
                    }
                }
                else if (side == "server" && !full) {
                    this.comparator = comparator;
                }

                if (delComp) this.comparator = null;
                if (delFullComp && fullCollection) fullCollection.comparator = null;

                return this;
            }

        });

        var PageableProto = PageableCollection.prototype;

        return PageableCollection;

/////////// Modified by Atlassian ///////////
    }));

});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:backbone-paginator', location = '/sidebar/lib/backbone.paginator.adapter.js' */
define("jira/projects/libs/backbone.paginator", [
    "backbone",
    "underscore",
    "atlassian/libs/factories/backbone.paginator-2.0.2"
], function(Backbone, _, paginatorFactory) {
    "use strict";
    return paginatorFactory(_, Backbone);
});

AJS.namespace("Backbone.PageableCollection", null, require("jira/projects/libs/backbone.paginator"));
;
;
/* module-key = 'com.atlassian.plugin.jslibs:uri-1.14.1', location = 'libs/uri/1.14.1/uri-1.14.1.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
    define('atlassian/libs/uri-1.14.1', function() {
        var env = {};
        factory.call(env);
        return env.URI.noConflict();
    });
})(function(){
/////// End of Atlassian modification ///////

    /*!
     * URI.js - Mutating URLs
     *
     * Version: 1.14.1
     *
     * Author: Rodney Rehm
     * Web: http://medialize.github.io/URI.js/
     *
     * Licensed under
     *   MIT License http://www.opensource.org/licenses/mit-license
     *   GPL v3 http://opensource.org/licenses/GPL-3.0
     *
     */
    (function (root, factory) {
        'use strict';
        // https://github.com/umdjs/umd/blob/master/returnExports.js

        /////////// Modified by Atlassian ///////////
        //if (typeof exports === 'object') {
        //    // Node
        //    module.exports = factory(require('./punycode'), require('./IPv6'), require('./SecondLevelDomains'));
        //} else if (typeof define === 'function' && define.amd) {
        //    // AMD. Register as an anonymous module.
        //    define(['./punycode', './IPv6', './SecondLevelDomains'], factory);
        //} else {
        //    // Browser globals (root is window)
        //    root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
        //}
        // Bypassing in-library AMD
        root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
        /////// End of Atlassian modification ///////

    }(this, function (punycode, IPv6, SLD, root) {
        'use strict';
        /*global location, escape, unescape */
        // FIXME: v2.0.0 renamce non-camelCase properties to uppercase
        /*jshint camelcase: false */

        // save current URI variable, if any
        var _URI = root && root.URI;

        function URI(url, base) {
            // Allow instantiation without the 'new' keyword
            if (!(this instanceof URI)) {
                return new URI(url, base);
            }

            if (url === undefined) {
                if (typeof location !== 'undefined') {
                    url = location.href + '';
                } else {
                    url = '';
                }
            }

            this.href(url);

            // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor
            if (base !== undefined) {
                return this.absoluteTo(base);
            }

            return this;
        }

        URI.version = '1.14.1';

        var p = URI.prototype;
        var hasOwn = Object.prototype.hasOwnProperty;

        function escapeRegEx(string) {
            // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963
            return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
        }

        function getType(value) {
            // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value
            if (value === undefined) {
                return 'Undefined';
            }

            return String(Object.prototype.toString.call(value)).slice(8, -1);
        }

        function isArray(obj) {
            return getType(obj) === 'Array';
        }

        function filterArrayValues(data, value) {
            var lookup = {};
            var i, length;

            if (isArray(value)) {
                for (i = 0, length = value.length; i < length; i++) {
                    lookup[value[i]] = true;
                }
            } else {
                lookup[value] = true;
            }

            for (i = 0, length = data.length; i < length; i++) {
                if (lookup[data[i]] !== undefined) {
                    data.splice(i, 1);
                    length--;
                    i--;
                }
            }

            return data;
        }

        function arrayContains(list, value) {
            var i, length;

            // value may be string, number, array, regexp
            if (isArray(value)) {
                // Note: this can be optimized to O(n) (instead of current O(m * n))
                for (i = 0, length = value.length; i < length; i++) {
                    if (!arrayContains(list, value[i])) {
                        return false;
                    }
                }

                return true;
            }

            var _type = getType(value);
            for (i = 0, length = list.length; i < length; i++) {
                if (_type === 'RegExp') {
                    if (typeof list[i] === 'string' && list[i].match(value)) {
                        return true;
                    }
                } else if (list[i] === value) {
                    return true;
                }
            }

            return false;
        }

        function arraysEqual(one, two) {
            if (!isArray(one) || !isArray(two)) {
                return false;
            }

            // arrays can't be equal if they have different amount of content
            if (one.length !== two.length) {
                return false;
            }

            one.sort();
            two.sort();

            for (var i = 0, l = one.length; i < l; i++) {
                if (one[i] !== two[i]) {
                    return false;
                }
            }

            return true;
        }

        URI._parts = function() {
            return {
                protocol: null,
                username: null,
                password: null,
                hostname: null,
                urn: null,
                port: null,
                path: null,
                query: null,
                fragment: null,
                // state
                duplicateQueryParameters: URI.duplicateQueryParameters,
                escapeQuerySpace: URI.escapeQuerySpace
            };
        };
        // state: allow duplicate query parameters (a=1&a=1)
        URI.duplicateQueryParameters = false;
        // state: replaces + with %20 (space in query strings)
        URI.escapeQuerySpace = true;
        // static properties
        URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
        URI.idn_expression = /[^a-z0-9\.-]/i;
        URI.punycode_expression = /(xn--)/i;
        // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?
        URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
        // credits to Rich Brown
        // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096
        // specification: http://www.ietf.org/rfc/rfc4291.txt
        URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
        // expression used is "gruber revised" (@gruber v2) determined to be the
        // best solution in a regex-golf we did a couple of ages ago at
        // * http://mathiasbynens.be/demo/url-regex
        // * http://rodneyrehm.de/t/url-regex.html
        URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?Â«Â»ââââ]))/ig;
        URI.findUri = {
            // valid "scheme://" or "www."
            start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
            // everything up to the next whitespace
            end: /[\s\r\n]|$/,
            // trim trailing punctuation captured by end RegExp
            trim: /[`!()\[\]{};:'".,<>?Â«Â»âââââ]+$/
        };
        // http://www.iana.org/assignments/uri-schemes.html
        // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports
        URI.defaultPorts = {
            http: '80',
            https: '443',
            ftp: '21',
            gopher: '70',
            ws: '80',
            wss: '443'
        };
        // allowed hostname characters according to RFC 3986
        // ALPHA DIGIT "-" "." "_" "~" "!" "$" "&" "'" "(" ")" "*" "+" "," ";" "=" %encoded
        // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . -
        URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/;
        // map DOM Elements to their URI attribute
        URI.domAttributes = {
            'a': 'href',
            'blockquote': 'cite',
            'link': 'href',
            'base': 'href',
            'script': 'src',
            'form': 'action',
            'img': 'src',
            'area': 'href',
            'iframe': 'src',
            'embed': 'src',
            'source': 'src',
            'track': 'src',
            'input': 'src', // but only if type="image"
            'audio': 'src',
            'video': 'src'
        };
        URI.getDomAttribute = function(node) {
            if (!node || !node.nodeName) {
                return undefined;
            }

            var nodeName = node.nodeName.toLowerCase();
            // <input> should only expose src for type="image"
            if (nodeName === 'input' && node.type !== 'image') {
                return undefined;
            }

            return URI.domAttributes[nodeName];
        };

        function escapeForDumbFirefox36(value) {
            // https://github.com/medialize/URI.js/issues/91
            return escape(value);
        }

        // encoding / decoding according to RFC3986
        function strictEncodeURIComponent(string) {
            // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent
            return encodeURIComponent(string)
                .replace(/[!'()*]/g, escapeForDumbFirefox36)
                .replace(/\*/g, '%2A');
        }
        URI.encode = strictEncodeURIComponent;
        URI.decode = decodeURIComponent;
        URI.iso8859 = function() {
            URI.encode = escape;
            URI.decode = unescape;
        };
        URI.unicode = function() {
            URI.encode = strictEncodeURIComponent;
            URI.decode = decodeURIComponent;
        };
        URI.characters = {
            pathname: {
                encode: {
                    // RFC3986 2.1: For consistency, URI producers and normalizers should
                    // use uppercase hexadecimal digits for all percent-encodings.
                    expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
                    map: {
                        // -._~!'()*
                        '%24': '$',
                        '%26': '&',
                        '%2B': '+',
                        '%2C': ',',
                        '%3B': ';',
                        '%3D': '=',
                        '%3A': ':',
                        '%40': '@'
                    }
                },
                decode: {
                    expression: /[\/\?#]/g,
                    map: {
                        '/': '%2F',
                        '?': '%3F',
                        '#': '%23'
                    }
                }
            },
            reserved: {
                encode: {
                    // RFC3986 2.1: For consistency, URI producers and normalizers should
                    // use uppercase hexadecimal digits for all percent-encodings.
                    expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
                    map: {
                        // gen-delims
                        '%3A': ':',
                        '%2F': '/',
                        '%3F': '?',
                        '%23': '#',
                        '%5B': '[',
                        '%5D': ']',
                        '%40': '@',
                        // sub-delims
                        '%21': '!',
                        '%24': '$',
                        '%26': '&',
                        '%27': '\'',
                        '%28': '(',
                        '%29': ')',
                        '%2A': '*',
                        '%2B': '+',
                        '%2C': ',',
                        '%3B': ';',
                        '%3D': '='
                    }
                }
            }
        };
        URI.encodeQuery = function(string, escapeQuerySpace) {
            var escaped = URI.encode(string + '');
            if (escapeQuerySpace === undefined) {
                escapeQuerySpace = URI.escapeQuerySpace;
            }

            return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
        };
        URI.decodeQuery = function(string, escapeQuerySpace) {
            string += '';
            if (escapeQuerySpace === undefined) {
                escapeQuerySpace = URI.escapeQuerySpace;
            }

            try {
                return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
            } catch(e) {
                // we're not going to mess with weird encodings,
                // give up and return the undecoded original string
                // see https://github.com/medialize/URI.js/issues/87
                // see https://github.com/medialize/URI.js/issues/92
                return string;
            }
        };
        URI.recodePath = function(string) {
            var segments = (string + '').split('/');
            for (var i = 0, length = segments.length; i < length; i++) {
                segments[i] = URI.encodePathSegment(URI.decode(segments[i]));
            }

            return segments.join('/');
        };
        URI.decodePath = function(string) {
            var segments = (string + '').split('/');
            for (var i = 0, length = segments.length; i < length; i++) {
                segments[i] = URI.decodePathSegment(segments[i]);
            }

            return segments.join('/');
        };
        // generate encode/decode path functions
        var _parts = {'encode':'encode', 'decode':'decode'};
        var _part;
        var generateAccessor = function(_group, _part) {
            return function(string) {
                try {
                    return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
                        return URI.characters[_group][_part].map[c];
                    });
                } catch (e) {
                    // we're not going to mess with weird encodings,
                    // give up and return the undecoded original string
                    // see https://github.com/medialize/URI.js/issues/87
                    // see https://github.com/medialize/URI.js/issues/92
                    return string;
                }
            };
        };

        for (_part in _parts) {
            URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
        }

        URI.encodeReserved = generateAccessor('reserved', 'encode');

        URI.parse = function(string, parts) {
            var pos;
            if (!parts) {
                parts = {};
            }
            // [protocol"://"[username[":"password]"@"]hostname[":"port]"/"?][path]["?"querystring]["#"fragment]

            // extract fragment
            pos = string.indexOf('#');
            if (pos > -1) {
                // escaping?
                parts.fragment = string.substring(pos + 1) || null;
                string = string.substring(0, pos);
            }

            // extract query
            pos = string.indexOf('?');
            if (pos > -1) {
                // escaping?
                parts.query = string.substring(pos + 1) || null;
                string = string.substring(0, pos);
            }

            // extract protocol
            if (string.substring(0, 2) === '//') {
                // relative-scheme
                parts.protocol = null;
                string = string.substring(2);
                // extract "user:pass@host:port"
                string = URI.parseAuthority(string, parts);
            } else {
                pos = string.indexOf(':');
                if (pos > -1) {
                    parts.protocol = string.substring(0, pos) || null;
                    if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
                        // : may be within the path
                        parts.protocol = undefined;
                    } else if (string.substring(pos + 1, pos + 3) === '//') {
                        string = string.substring(pos + 3);

                        // extract "user:pass@host:port"
                        string = URI.parseAuthority(string, parts);
                    } else {
                        string = string.substring(pos + 1);
                        parts.urn = true;
                    }
                }
            }

            // what's left must be the path
            parts.path = string;

            // and we're done
            return parts;
        };
        URI.parseHost = function(string, parts) {
            // extract host:port
            var pos = string.indexOf('/');
            var bracketPos;
            var t;

            if (pos === -1) {
                pos = string.length;
            }

            if (string.charAt(0) === '[') {
                // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6
                // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts
                // IPv6+port in the format [2001:db8::1]:80 (for the time being)
                bracketPos = string.indexOf(']');
                parts.hostname = string.substring(1, bracketPos) || null;
                parts.port = string.substring(bracketPos + 2, pos) || null;
                if (parts.port === '/') {
                    parts.port = null;
                }
            } else if (string.indexOf(':') !== string.lastIndexOf(':')) {
                // IPv6 host contains multiple colons - but no port
                // this notation is actually not allowed by RFC 3986, but we're a liberal parser
                parts.hostname = string.substring(0, pos) || null;
                parts.port = null;
            } else {
                t = string.substring(0, pos).split(':');
                parts.hostname = t[0] || null;
                parts.port = t[1] || null;
            }

            if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
                pos++;
                string = '/' + string;
            }

            return string.substring(pos) || '/';
        };
        URI.parseAuthority = function(string, parts) {
            string = URI.parseUserinfo(string, parts);
            return URI.parseHost(string, parts);
        };
        URI.parseUserinfo = function(string, parts) {
            // extract username:password
            var firstSlash = string.indexOf('/');
            var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
            var t;

            // authority@ must come before /path
            if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
                t = string.substring(0, pos).split(':');
                parts.username = t[0] ? URI.decode(t[0]) : null;
                t.shift();
                parts.password = t[0] ? URI.decode(t.join(':')) : null;
                string = string.substring(pos + 1);
            } else {
                parts.username = null;
                parts.password = null;
            }

            return string;
        };
        URI.parseQuery = function(string, escapeQuerySpace) {
            if (!string) {
                return {};
            }

            // throw out the funky business - "?"[name"="value"&"]+
            string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');

            if (!string) {
                return {};
            }

            var items = {};
            var splits = string.split('&');
            var length = splits.length;
            var v, name, value;

            for (var i = 0; i < length; i++) {
                v = splits[i].split('=');
                name = URI.decodeQuery(v.shift(), escapeQuerySpace);
                // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
                value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;

                if (hasOwn.call(items, name)) {
                    if (typeof items[name] === 'string') {
                        items[name] = [items[name]];
                    }

                    items[name].push(value);
                } else {
                    items[name] = value;
                }
            }

            return items;
        };

        URI.build = function(parts) {
            var t = '';

            if (parts.protocol) {
                t += parts.protocol + ':';
            }

            if (!parts.urn && (t || parts.hostname)) {
                t += '//';
            }

            t += (URI.buildAuthority(parts) || '');

            if (typeof parts.path === 'string') {
                if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {
                    t += '/';
                }

                t += parts.path;
            }

            if (typeof parts.query === 'string' && parts.query) {
                t += '?' + parts.query;
            }

            if (typeof parts.fragment === 'string' && parts.fragment) {
                t += '#' + parts.fragment;
            }
            return t;
        };
        URI.buildHost = function(parts) {
            var t = '';

            if (!parts.hostname) {
                return '';
            } else if (URI.ip6_expression.test(parts.hostname)) {
                t += '[' + parts.hostname + ']';
            } else {
                t += parts.hostname;
            }

            if (parts.port) {
                t += ':' + parts.port;
            }

            return t;
        };
        URI.buildAuthority = function(parts) {
            return URI.buildUserinfo(parts) + URI.buildHost(parts);
        };
        URI.buildUserinfo = function(parts) {
            var t = '';

            if (parts.username) {
                t += URI.encode(parts.username);

                if (parts.password) {
                    t += ':' + URI.encode(parts.password);
                }

                t += '@';
            }

            return t;
        };
        URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
            // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html
            // being Â»-._~!$&'()*+,;=:@/?Â« %HEX and alnum are allowed
            // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!
            // URI.js treats the query string as being application/x-www-form-urlencoded
            // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type

            var t = '';
            var unique, key, i, length;
            for (key in data) {
                if (hasOwn.call(data, key) && key) {
                    if (isArray(data[key])) {
                        unique = {};
                        for (i = 0, length = data[key].length; i < length; i++) {
                            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
                                t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
                                if (duplicateQueryParameters !== true) {
                                    unique[data[key][i] + ''] = true;
                                }
                            }
                        }
                    } else if (data[key] !== undefined) {
                        t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
                    }
                }
            }

            return t.substring(1);
        };
        URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
            // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded
            // don't append "=" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization
            return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
        };

        URI.addQuery = function(data, name, value) {
            if (typeof name === 'object') {
                for (var key in name) {
                    if (hasOwn.call(name, key)) {
                        URI.addQuery(data, key, name[key]);
                    }
                }
            } else if (typeof name === 'string') {
                if (data[name] === undefined) {
                    data[name] = value;
                    return;
                } else if (typeof data[name] === 'string') {
                    data[name] = [data[name]];
                }

                if (!isArray(value)) {
                    value = [value];
                }

                data[name] = (data[name] || []).concat(value);
            } else {
                throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
            }
        };
        URI.removeQuery = function(data, name, value) {
            var i, length, key;

            if (isArray(name)) {
                for (i = 0, length = name.length; i < length; i++) {
                    data[name[i]] = undefined;
                }
            } else if (typeof name === 'object') {
                for (key in name) {
                    if (hasOwn.call(name, key)) {
                        URI.removeQuery(data, key, name[key]);
                    }
                }
            } else if (typeof name === 'string') {
                if (value !== undefined) {
                    if (data[name] === value) {
                        data[name] = undefined;
                    } else if (isArray(data[name])) {
                        data[name] = filterArrayValues(data[name], value);
                    }
                } else {
                    data[name] = undefined;
                }
            } else {
                throw new TypeError('URI.addQuery() accepts an object, string as the first parameter');
            }
        };
        URI.hasQuery = function(data, name, value, withinArray) {
            if (typeof name === 'object') {
                for (var key in name) {
                    if (hasOwn.call(name, key)) {
                        if (!URI.hasQuery(data, key, name[key])) {
                            return false;
                        }
                    }
                }

                return true;
            } else if (typeof name !== 'string') {
                throw new TypeError('URI.hasQuery() accepts an object, string as the name parameter');
            }

            switch (getType(value)) {
                case 'Undefined':
                    // true if exists (but may be empty)
                    return name in data; // data[name] !== undefined;

                case 'Boolean':
                    // true if exists and non-empty
                    var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
                    return value === _booly;

                case 'Function':
                    // allow complex comparison
                    return !!value(data[name], name, data);

                case 'Array':
                    if (!isArray(data[name])) {
                        return false;
                    }

                    var op = withinArray ? arrayContains : arraysEqual;
                    return op(data[name], value);

                case 'RegExp':
                    if (!isArray(data[name])) {
                        return Boolean(data[name] && data[name].match(value));
                    }

                    if (!withinArray) {
                        return false;
                    }

                    return arrayContains(data[name], value);

                case 'Number':
                    value = String(value);
                /* falls through */
                case 'String':
                    if (!isArray(data[name])) {
                        return data[name] === value;
                    }

                    if (!withinArray) {
                        return false;
                    }

                    return arrayContains(data[name], value);

                default:
                    throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
            }
        };


        URI.commonPath = function(one, two) {
            var length = Math.min(one.length, two.length);
            var pos;

            // find first non-matching character
            for (pos = 0; pos < length; pos++) {
                if (one.charAt(pos) !== two.charAt(pos)) {
                    pos--;
                    break;
                }
            }

            if (pos < 1) {
                return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
            }

            // revert to last /
            if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
                pos = one.substring(0, pos).lastIndexOf('/');
            }

            return one.substring(0, pos + 1);
        };

        URI.withinString = function(string, callback, options) {
            options || (options = {});
            var _start = options.start || URI.findUri.start;
            var _end = options.end || URI.findUri.end;
            var _trim = options.trim || URI.findUri.trim;
            var _attributeOpen = /[a-z0-9-]=["']?$/i;

            _start.lastIndex = 0;
            while (true) {
                var match = _start.exec(string);
                if (!match) {
                    break;
                }

                var start = match.index;
                if (options.ignoreHtml) {
                    // attribut(e=["']?$)
                    var attributeOpen = string.slice(Math.max(start - 3, 0), start);
                    if (attributeOpen && _attributeOpen.test(attributeOpen)) {
                        continue;
                    }
                }

                var end = start + string.slice(start).search(_end);
                var slice = string.slice(start, end).replace(_trim, '');
                if (options.ignore && options.ignore.test(slice)) {
                    continue;
                }

                end = start + slice.length;
                var result = callback(slice, start, end, string);
                string = string.slice(0, start) + result + string.slice(end);
                _start.lastIndex = start + result.length;
            }

            _start.lastIndex = 0;
            return string;
        };

        URI.ensureValidHostname = function(v) {
            // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)
            // they are not part of DNS and therefore ignored by URI.js

            if (v.match(URI.invalid_hostname_characters)) {
                // test punycode
                if (!punycode) {
                    throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-] and Punycode.js is not available');
                }

                if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
                    throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
                }
            }
        };

        // noConflict
        URI.noConflict = function(removeAll) {
            if (removeAll) {
                var unconflicted = {
                    URI: this.noConflict()
                };

                if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
                    unconflicted.URITemplate = root.URITemplate.noConflict();
                }

                if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
                    unconflicted.IPv6 = root.IPv6.noConflict();
                }

                if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
                    unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
                }

                return unconflicted;
            } else if (root.URI === this) {
                root.URI = _URI;
            }

            return this;
        };

        p.build = function(deferBuild) {
            if (deferBuild === true) {
                this._deferred_build = true;
            } else if (deferBuild === undefined || this._deferred_build) {
                this._string = URI.build(this._parts);
                this._deferred_build = false;
            }

            return this;
        };

        p.clone = function() {
            return new URI(this);
        };

        p.valueOf = p.toString = function() {
            return this.build(false)._string;
        };


        function generateSimpleAccessor(_part){
            return function(v, build) {
                if (v === undefined) {
                    return this._parts[_part] || '';
                } else {
                    this._parts[_part] = v || null;
                    this.build(!build);
                    return this;
                }
            };
        }

        function generatePrefixAccessor(_part, _key){
            return function(v, build) {
                if (v === undefined) {
                    return this._parts[_part] || '';
                } else {
                    if (v !== null) {
                        v = v + '';
                        if (v.charAt(0) === _key) {
                            v = v.substring(1);
                        }
                    }

                    this._parts[_part] = v;
                    this.build(!build);
                    return this;
                }
            };
        }

        p.protocol = generateSimpleAccessor('protocol');
        p.username = generateSimpleAccessor('username');
        p.password = generateSimpleAccessor('password');
        p.hostname = generateSimpleAccessor('hostname');
        p.port = generateSimpleAccessor('port');
        p.query = generatePrefixAccessor('query', '?');
        p.fragment = generatePrefixAccessor('fragment', '#');

        p.search = function(v, build) {
            var t = this.query(v, build);
            return typeof t === 'string' && t.length ? ('?' + t) : t;
        };
        p.hash = function(v, build) {
            var t = this.fragment(v, build);
            return typeof t === 'string' && t.length ? ('#' + t) : t;
        };

        p.pathname = function(v, build) {
            if (v === undefined || v === true) {
                var res = this._parts.path || (this._parts.hostname ? '/' : '');
                return v ? URI.decodePath(res) : res;
            } else {
                this._parts.path = v ? URI.recodePath(v) : '/';
                this.build(!build);
                return this;
            }
        };
        p.path = p.pathname;
        p.href = function(href, build) {
            var key;

            if (href === undefined) {
                return this.toString();
            }

            this._string = '';
            this._parts = URI._parts();

            var _URI = href instanceof URI;
            var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
            if (href.nodeName) {
                var attribute = URI.getDomAttribute(href);
                href = href[attribute] || '';
                _object = false;
            }

            // window.location is reported to be an object, but it's not the sort
            // of object we're looking for:
            // * location.protocol ends with a colon
            // * location.query != object.search
            // * location.hash != object.fragment
            // simply serializing the unknown object should do the trick
            // (for location, not for everything...)
            if (!_URI && _object && href.pathname !== undefined) {
                href = href.toString();
            }

            if (typeof href === 'string' || href instanceof String) {
                this._parts = URI.parse(String(href), this._parts);
            } else if (_URI || _object) {
                var src = _URI ? href._parts : href;
                for (key in src) {
                    if (hasOwn.call(this._parts, key)) {
                        this._parts[key] = src[key];
                    }
                }
            } else {
                throw new TypeError('invalid input');
            }

            this.build(!build);
            return this;
        };

        // identification accessors
        p.is = function(what) {
            var ip = false;
            var ip4 = false;
            var ip6 = false;
            var name = false;
            var sld = false;
            var idn = false;
            var punycode = false;
            var relative = !this._parts.urn;

            if (this._parts.hostname) {
                relative = false;
                ip4 = URI.ip4_expression.test(this._parts.hostname);
                ip6 = URI.ip6_expression.test(this._parts.hostname);
                ip = ip4 || ip6;
                name = !ip;
                sld = name && SLD && SLD.has(this._parts.hostname);
                idn = name && URI.idn_expression.test(this._parts.hostname);
                punycode = name && URI.punycode_expression.test(this._parts.hostname);
            }

            switch (what.toLowerCase()) {
                case 'relative':
                    return relative;

                case 'absolute':
                    return !relative;

                // hostname identification
                case 'domain':
                case 'name':
                    return name;

                case 'sld':
                    return sld;

                case 'ip':
                    return ip;

                case 'ip4':
                case 'ipv4':
                case 'inet4':
                    return ip4;

                case 'ip6':
                case 'ipv6':
                case 'inet6':
                    return ip6;

                case 'idn':
                    return idn;

                case 'url':
                    return !this._parts.urn;

                case 'urn':
                    return !!this._parts.urn;

                case 'punycode':
                    return punycode;
            }

            return null;
        };

        // component specific input validation
        var _protocol = p.protocol;
        var _port = p.port;
        var _hostname = p.hostname;

        p.protocol = function(v, build) {
            if (v !== undefined) {
                if (v) {
                    // accept trailing ://
                    v = v.replace(/:(\/\/)?$/, '');

                    if (!v.match(URI.protocol_expression)) {
                        throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
                    }
                }
            }
            return _protocol.call(this, v, build);
        };
        p.scheme = p.protocol;
        p.port = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v !== undefined) {
                if (v === 0) {
                    v = null;
                }

                if (v) {
                    v += '';
                    if (v.charAt(0) === ':') {
                        v = v.substring(1);
                    }

                    if (v.match(/[^0-9]/)) {
                        throw new TypeError('Port "' + v + '" contains characters other than [0-9]');
                    }
                }
            }
            return _port.call(this, v, build);
        };
        p.hostname = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v !== undefined) {
                var x = {};
                URI.parseHost(v, x);
                v = x.hostname;
            }
            return _hostname.call(this, v, build);
        };

        // compound accessors
        p.host = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined) {
                return this._parts.hostname ? URI.buildHost(this._parts) : '';
            } else {
                URI.parseHost(v, this._parts);
                this.build(!build);
                return this;
            }
        };
        p.authority = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined) {
                return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
            } else {
                URI.parseAuthority(v, this._parts);
                this.build(!build);
                return this;
            }
        };
        p.userinfo = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined) {
                if (!this._parts.username) {
                    return '';
                }

                var t = URI.buildUserinfo(this._parts);
                return t.substring(0, t.length -1);
            } else {
                if (v[v.length-1] !== '@') {
                    v += '@';
                }

                URI.parseUserinfo(v, this._parts);
                this.build(!build);
                return this;
            }
        };
        p.resource = function(v, build) {
            var parts;

            if (v === undefined) {
                return this.path() + this.search() + this.hash();
            }

            parts = URI.parse(v);
            this._parts.path = parts.path;
            this._parts.query = parts.query;
            this._parts.fragment = parts.fragment;
            this.build(!build);
            return this;
        };

        // fraction accessors
        p.subdomain = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            // convenience, return "www" from "www.example.org"
            if (v === undefined) {
                if (!this._parts.hostname || this.is('IP')) {
                    return '';
                }

                // grab domain and add another segment
                var end = this._parts.hostname.length - this.domain().length - 1;
                return this._parts.hostname.substring(0, end) || '';
            } else {
                var e = this._parts.hostname.length - this.domain().length;
                var sub = this._parts.hostname.substring(0, e);
                var replace = new RegExp('^' + escapeRegEx(sub));

                if (v && v.charAt(v.length - 1) !== '.') {
                    v += '.';
                }

                if (v) {
                    URI.ensureValidHostname(v);
                }

                this._parts.hostname = this._parts.hostname.replace(replace, v);
                this.build(!build);
                return this;
            }
        };
        p.domain = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (typeof v === 'boolean') {
                build = v;
                v = undefined;
            }

            // convenience, return "example.org" from "www.example.org"
            if (v === undefined) {
                if (!this._parts.hostname || this.is('IP')) {
                    return '';
                }

                // if hostname consists of 1 or 2 segments, it must be the domain
                var t = this._parts.hostname.match(/\./g);
                if (t && t.length < 2) {
                    return this._parts.hostname;
                }

                // grab tld and add another segment
                var end = this._parts.hostname.length - this.tld(build).length - 1;
                end = this._parts.hostname.lastIndexOf('.', end -1) + 1;
                return this._parts.hostname.substring(end) || '';
            } else {
                if (!v) {
                    throw new TypeError('cannot set domain empty');
                }

                URI.ensureValidHostname(v);

                if (!this._parts.hostname || this.is('IP')) {
                    this._parts.hostname = v;
                } else {
                    var replace = new RegExp(escapeRegEx(this.domain()) + '$');
                    this._parts.hostname = this._parts.hostname.replace(replace, v);
                }

                this.build(!build);
                return this;
            }
        };
        p.tld = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (typeof v === 'boolean') {
                build = v;
                v = undefined;
            }

            // return "org" from "www.example.org"
            if (v === undefined) {
                if (!this._parts.hostname || this.is('IP')) {
                    return '';
                }

                var pos = this._parts.hostname.lastIndexOf('.');
                var tld = this._parts.hostname.substring(pos + 1);

                if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
                    return SLD.get(this._parts.hostname) || tld;
                }

                return tld;
            } else {
                var replace;

                if (!v) {
                    throw new TypeError('cannot set TLD empty');
                } else if (v.match(/[^a-zA-Z0-9-]/)) {
                    if (SLD && SLD.is(v)) {
                        replace = new RegExp(escapeRegEx(this.tld()) + '$');
                        this._parts.hostname = this._parts.hostname.replace(replace, v);
                    } else {
                        throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
                    }
                } else if (!this._parts.hostname || this.is('IP')) {
                    throw new ReferenceError('cannot set TLD on non-domain host');
                } else {
                    replace = new RegExp(escapeRegEx(this.tld()) + '$');
                    this._parts.hostname = this._parts.hostname.replace(replace, v);
                }

                this.build(!build);
                return this;
            }
        };
        p.directory = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined || v === true) {
                if (!this._parts.path && !this._parts.hostname) {
                    return '';
                }

                if (this._parts.path === '/') {
                    return '/';
                }

                var end = this._parts.path.length - this.filename().length - 1;
                var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');

                return v ? URI.decodePath(res) : res;

            } else {
                var e = this._parts.path.length - this.filename().length;
                var directory = this._parts.path.substring(0, e);
                var replace = new RegExp('^' + escapeRegEx(directory));

                // fully qualifier directories begin with a slash
                if (!this.is('relative')) {
                    if (!v) {
                        v = '/';
                    }

                    if (v.charAt(0) !== '/') {
                        v = '/' + v;
                    }
                }

                // directories always end with a slash
                if (v && v.charAt(v.length - 1) !== '/') {
                    v += '/';
                }

                v = URI.recodePath(v);
                this._parts.path = this._parts.path.replace(replace, v);
                this.build(!build);
                return this;
            }
        };
        p.filename = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined || v === true) {
                if (!this._parts.path || this._parts.path === '/') {
                    return '';
                }

                var pos = this._parts.path.lastIndexOf('/');
                var res = this._parts.path.substring(pos+1);

                return v ? URI.decodePathSegment(res) : res;
            } else {
                var mutatedDirectory = false;

                if (v.charAt(0) === '/') {
                    v = v.substring(1);
                }

                if (v.match(/\.?\//)) {
                    mutatedDirectory = true;
                }

                var replace = new RegExp(escapeRegEx(this.filename()) + '$');
                v = URI.recodePath(v);
                this._parts.path = this._parts.path.replace(replace, v);

                if (mutatedDirectory) {
                    this.normalizePath(build);
                } else {
                    this.build(!build);
                }

                return this;
            }
        };
        p.suffix = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined || v === true) {
                if (!this._parts.path || this._parts.path === '/') {
                    return '';
                }

                var filename = this.filename();
                var pos = filename.lastIndexOf('.');
                var s, res;

                if (pos === -1) {
                    return '';
                }

                // suffix may only contain alnum characters (yup, I made this up.)
                s = filename.substring(pos+1);
                res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
                return v ? URI.decodePathSegment(res) : res;
            } else {
                if (v.charAt(0) === '.') {
                    v = v.substring(1);
                }

                var suffix = this.suffix();
                var replace;

                if (!suffix) {
                    if (!v) {
                        return this;
                    }

                    this._parts.path += '.' + URI.recodePath(v);
                } else if (!v) {
                    replace = new RegExp(escapeRegEx('.' + suffix) + '$');
                } else {
                    replace = new RegExp(escapeRegEx(suffix) + '$');
                }

                if (replace) {
                    v = URI.recodePath(v);
                    this._parts.path = this._parts.path.replace(replace, v);
                }

                this.build(!build);
                return this;
            }
        };
        p.segment = function(segment, v, build) {
            var separator = this._parts.urn ? ':' : '/';
            var path = this.path();
            var absolute = path.substring(0, 1) === '/';
            var segments = path.split(separator);

            if (segment !== undefined && typeof segment !== 'number') {
                build = v;
                v = segment;
                segment = undefined;
            }

            if (segment !== undefined && typeof segment !== 'number') {
                throw new Error('Bad segment "' + segment + '", must be 0-based integer');
            }

            if (absolute) {
                segments.shift();
            }

            if (segment < 0) {
                // allow negative indexes to address from the end
                segment = Math.max(segments.length + segment, 0);
            }

            if (v === undefined) {
                /*jshint laxbreak: true */
                return segment === undefined
                    ? segments
                    : segments[segment];
                /*jshint laxbreak: false */
            } else if (segment === null || segments[segment] === undefined) {
                if (isArray(v)) {
                    segments = [];
                    // collapse empty elements within array
                    for (var i=0, l=v.length; i < l; i++) {
                        if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {
                            continue;
                        }

                        if (segments.length && !segments[segments.length -1].length) {
                            segments.pop();
                        }

                        segments.push(v[i]);
                    }
                } else if (v || typeof v === 'string') {
                    if (segments[segments.length -1] === '') {
                        // empty trailing elements have to be overwritten
                        // to prevent results such as /foo//bar
                        segments[segments.length -1] = v;
                    } else {
                        segments.push(v);
                    }
                }
            } else {
                if (v) {
                    segments[segment] = v;
                } else {
                    segments.splice(segment, 1);
                }
            }

            if (absolute) {
                segments.unshift('');
            }

            return this.path(segments.join(separator), build);
        };
        p.segmentCoded = function(segment, v, build) {
            var segments, i, l;

            if (typeof segment !== 'number') {
                build = v;
                v = segment;
                segment = undefined;
            }

            if (v === undefined) {
                segments = this.segment(segment, v, build);
                if (!isArray(segments)) {
                    segments = segments !== undefined ? URI.decode(segments) : undefined;
                } else {
                    for (i = 0, l = segments.length; i < l; i++) {
                        segments[i] = URI.decode(segments[i]);
                    }
                }

                return segments;
            }

            if (!isArray(v)) {
                v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
            } else {
                for (i = 0, l = v.length; i < l; i++) {
                    v[i] = URI.decode(v[i]);
                }
            }

            return this.segment(segment, v, build);
        };

        // mutating query string
        var q = p.query;
        p.query = function(v, build) {
            if (v === true) {
                return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            } else if (typeof v === 'function') {
                var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                var result = v.call(this, data);
                this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
                this.build(!build);
                return this;
            } else if (v !== undefined && typeof v !== 'string') {
                this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
                this.build(!build);
                return this;
            } else {
                return q.call(this, v, build);
            }
        };
        p.setQuery = function(name, value, build) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);

            if (typeof name === 'string' || name instanceof String) {
                data[name] = value !== undefined ? value : null;
            } else if (typeof name === 'object') {
                for (var key in name) {
                    if (hasOwn.call(name, key)) {
                        data[key] = name[key];
                    }
                }
            } else {
                throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
            }

            this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            if (typeof name !== 'string') {
                build = value;
            }

            this.build(!build);
            return this;
        };
        p.addQuery = function(name, value, build) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            URI.addQuery(data, name, value === undefined ? null : value);
            this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            if (typeof name !== 'string') {
                build = value;
            }

            this.build(!build);
            return this;
        };
        p.removeQuery = function(name, value, build) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            URI.removeQuery(data, name, value);
            this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            if (typeof name !== 'string') {
                build = value;
            }

            this.build(!build);
            return this;
        };
        p.hasQuery = function(name, value, withinArray) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return URI.hasQuery(data, name, value, withinArray);
        };
        p.setSearch = p.setQuery;
        p.addSearch = p.addQuery;
        p.removeSearch = p.removeQuery;
        p.hasSearch = p.hasQuery;

        // sanitizing URLs
        p.normalize = function() {
            if (this._parts.urn) {
                return this
                    .normalizeProtocol(false)
                    .normalizeQuery(false)
                    .normalizeFragment(false)
                    .build();
            }

            return this
                .normalizeProtocol(false)
                .normalizeHostname(false)
                .normalizePort(false)
                .normalizePath(false)
                .normalizeQuery(false)
                .normalizeFragment(false)
                .build();
        };
        p.normalizeProtocol = function(build) {
            if (typeof this._parts.protocol === 'string') {
                this._parts.protocol = this._parts.protocol.toLowerCase();
                this.build(!build);
            }

            return this;
        };
        p.normalizeHostname = function(build) {
            if (this._parts.hostname) {
                if (this.is('IDN') && punycode) {
                    this._parts.hostname = punycode.toASCII(this._parts.hostname);
                } else if (this.is('IPv6') && IPv6) {
                    this._parts.hostname = IPv6.best(this._parts.hostname);
                }

                this._parts.hostname = this._parts.hostname.toLowerCase();
                this.build(!build);
            }

            return this;
        };
        p.normalizePort = function(build) {
            // remove port of it's the protocol's default
            if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
                this._parts.port = null;
                this.build(!build);
            }

            return this;
        };
        p.normalizePath = function(build) {
            if (this._parts.urn) {
                return this;
            }

            if (!this._parts.path || this._parts.path === '/') {
                return this;
            }

            var _was_relative;
            var _path = this._parts.path;
            var _leadingParents = '';
            var _parent, _pos;

            // handle relative paths
            if (_path.charAt(0) !== '/') {
                _was_relative = true;
                _path = '/' + _path;
            }

            // resolve simples
            _path = _path
                .replace(/(\/(\.\/)+)|(\/\.$)/g, '/')
                .replace(/\/{2,}/g, '/');

            // remember leading parents
            if (_was_relative) {
                _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
                if (_leadingParents) {
                    _leadingParents = _leadingParents[0];
                }
            }

            // resolve parents
            while (true) {
                _parent = _path.indexOf('/..');
                if (_parent === -1) {
                    // no more ../ to resolve
                    break;
                } else if (_parent === 0) {
                    // top level cannot be relative, skip it
                    _path = _path.substring(3);
                    continue;
                }

                _pos = _path.substring(0, _parent).lastIndexOf('/');
                if (_pos === -1) {
                    _pos = _parent;
                }
                _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
            }

            // revert to relative
            if (_was_relative && this.is('relative')) {
                _path = _leadingParents + _path.substring(1);
            }

            _path = URI.recodePath(_path);
            this._parts.path = _path;
            this.build(!build);
            return this;
        };
        p.normalizePathname = p.normalizePath;
        p.normalizeQuery = function(build) {
            if (typeof this._parts.query === 'string') {
                if (!this._parts.query.length) {
                    this._parts.query = null;
                } else {
                    this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
                }

                this.build(!build);
            }

            return this;
        };
        p.normalizeFragment = function(build) {
            if (!this._parts.fragment) {
                this._parts.fragment = null;
                this.build(!build);
            }

            return this;
        };
        p.normalizeSearch = p.normalizeQuery;
        p.normalizeHash = p.normalizeFragment;

        p.iso8859 = function() {
            // expect unicode input, iso8859 output
            var e = URI.encode;
            var d = URI.decode;

            URI.encode = escape;
            URI.decode = decodeURIComponent;
            this.normalize();
            URI.encode = e;
            URI.decode = d;
            return this;
        };

        p.unicode = function() {
            // expect iso8859 input, unicode output
            var e = URI.encode;
            var d = URI.decode;

            URI.encode = strictEncodeURIComponent;
            URI.decode = unescape;
            this.normalize();
            URI.encode = e;
            URI.decode = d;
            return this;
        };

        p.readable = function() {
            var uri = this.clone();
            // removing username, password, because they shouldn't be displayed according to RFC 3986
            uri.username('').password('').normalize();
            var t = '';
            if (uri._parts.protocol) {
                t += uri._parts.protocol + '://';
            }

            if (uri._parts.hostname) {
                if (uri.is('punycode') && punycode) {
                    t += punycode.toUnicode(uri._parts.hostname);
                    if (uri._parts.port) {
                        t += ':' + uri._parts.port;
                    }
                } else {
                    t += uri.host();
                }
            }

            if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
                t += '/';
            }

            t += uri.path(true);
            if (uri._parts.query) {
                var q = '';
                for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {
                    var kv = (qp[i] || '').split('=');
                    q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)
                            .replace(/&/g, '%26');

                    if (kv[1] !== undefined) {
                        q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)
                                .replace(/&/g, '%26');
                    }
                }
                t += '?' + q.substring(1);
            }

            t += URI.decodeQuery(uri.hash(), true);
            return t;
        };

        // resolving relative and absolute URLs
        p.absoluteTo = function(base) {
            var resolved = this.clone();
            var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
            var basedir, i, p;

            if (this._parts.urn) {
                throw new Error('URNs do not have any generally defined hierarchical components');
            }

            if (!(base instanceof URI)) {
                base = new URI(base);
            }

            if (!resolved._parts.protocol) {
                resolved._parts.protocol = base._parts.protocol;
            }

            if (this._parts.hostname) {
                return resolved;
            }

            for (i = 0; (p = properties[i]); i++) {
                resolved._parts[p] = base._parts[p];
            }

            if (!resolved._parts.path) {
                resolved._parts.path = base._parts.path;
                if (!resolved._parts.query) {
                    resolved._parts.query = base._parts.query;
                }
            } else if (resolved._parts.path.substring(-2) === '..') {
                resolved._parts.path += '/';
            }

            if (resolved.path().charAt(0) !== '/') {
                basedir = base.directory();
                resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
                resolved.normalizePath();
            }

            resolved.build();
            return resolved;
        };
        p.relativeTo = function(base) {
            var relative = this.clone().normalize();
            var relativeParts, baseParts, common, relativePath, basePath;

            if (relative._parts.urn) {
                throw new Error('URNs do not have any generally defined hierarchical components');
            }

            base = new URI(base).normalize();
            relativeParts = relative._parts;
            baseParts = base._parts;
            relativePath = relative.path();
            basePath = base.path();

            if (relativePath.charAt(0) !== '/') {
                throw new Error('URI is already relative');
            }

            if (basePath.charAt(0) !== '/') {
                throw new Error('Cannot calculate a URI relative to another relative URI');
            }

            if (relativeParts.protocol === baseParts.protocol) {
                relativeParts.protocol = null;
            }

            if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
                return relative.build();
            }

            if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
                return relative.build();
            }

            if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
                relativeParts.hostname = null;
                relativeParts.port = null;
            } else {
                return relative.build();
            }

            if (relativePath === basePath) {
                relativeParts.path = '';
                return relative.build();
            }

            // determine common sub path
            common = URI.commonPath(relative.path(), base.path());

            // If the paths have nothing in common, return a relative URL with the absolute path.
            if (!common) {
                return relative.build();
            }

            var parents = baseParts.path
                .substring(common.length)
                .replace(/[^\/]*$/, '')
                .replace(/.*?\//g, '../');

            relativeParts.path = parents + relativeParts.path.substring(common.length);

            return relative.build();
        };

        // comparing URIs
        p.equals = function(uri) {
            var one = this.clone();
            var two = new URI(uri);
            var one_map = {};
            var two_map = {};
            var checked = {};
            var one_query, two_query, key;

            one.normalize();
            two.normalize();

            // exact match
            if (one.toString() === two.toString()) {
                return true;
            }

            // extract query string
            one_query = one.query();
            two_query = two.query();
            one.query('');
            two.query('');

            // definitely not equal if not even non-query parts match
            if (one.toString() !== two.toString()) {
                return false;
            }

            // query parameters have the same length, even if they're permuted
            if (one_query.length !== two_query.length) {
                return false;
            }

            one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
            two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);

            for (key in one_map) {
                if (hasOwn.call(one_map, key)) {
                    if (!isArray(one_map[key])) {
                        if (one_map[key] !== two_map[key]) {
                            return false;
                        }
                    } else if (!arraysEqual(one_map[key], two_map[key])) {
                        return false;
                    }

                    checked[key] = true;
                }
            }

            for (key in two_map) {
                if (hasOwn.call(two_map, key)) {
                    if (!checked[key]) {
                        // two contains a parameter not present in one
                        return false;
                    }
                }
            }

            return true;
        };

        // state
        p.duplicateQueryParameters = function(v) {
            this._parts.duplicateQueryParameters = !!v;
            return this;
        };

        p.escapeQuerySpace = function(v) {
            this._parts.escapeQuerySpace = !!v;
            return this;
        };

        return URI;
    }));
/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.AbstractList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.AbstractList == 'undefined') { JIRA.Projects.AbstractList = {}; }
if (typeof JIRA.Projects.AbstractList.Templates == 'undefined') { JIRA.Projects.AbstractList.Templates = {}; }


JIRA.Projects.AbstractList.Templates.pagination = function(opt_data, opt_ignored) {
  var output = '<ol data-total="' + soy.$$escapeHtml(opt_data.totalPages) + '" class="aui-nav aui-nav-pagination' + ((opt_data.cssClass) ? ' ' + soy.$$escapeHtml(opt_data.cssClass) : '') + '">';
  if (opt_data.firstPage < opt_data.lastPage) {
    output += '<li class="aui-nav-previous"><a href="' + soy.$$escapeHtml(opt_data.url) + '&amp;page=' + ((opt_data.currentPage == opt_data.firstPage) ? '0' : soy.$$escapeHtml(opt_data.currentPage - 1)) + '" ' + ((opt_data.currentPage == opt_data.firstPage) ? 'aria-disabled="true"' : 'data-page="' + ((opt_data.currentPage == opt_data.firstPage) ? '0' : soy.$$escapeHtml(opt_data.currentPage - 1)) + '"') + '>' + soy.$$escapeHtml("Previous") + '</a></li>';
    var pageInit36 = opt_data.firstPage;
    var pageLimit36 = opt_data.lastPage + 1;
    for (var page36 = pageInit36; page36 < pageLimit36; page36++) {
      output += (page36 == opt_data.currentPage) ? '<li class="aui-nav-page aui-nav-selected">' + soy.$$escapeHtml(page36) + '</li>' : '<li><a href="' + soy.$$escapeHtml(opt_data.url) + '&amp;page=' + soy.$$escapeHtml(page36) + '" data-page="' + soy.$$escapeHtml(page36) + '">' + soy.$$escapeHtml(page36) + '</a></li>';
    }
    output += '<li class="aui-nav-next"><a href="' + soy.$$escapeHtml(opt_data.url) + '&amp;page=' + ((opt_data.currentPage == opt_data.lastPage) ? soy.$$escapeHtml(opt_data.lastPage) : soy.$$escapeHtml(opt_data.currentPage + 1)) + '"' + ((opt_data.currentPage == opt_data.lastPage) ? 'aria-disabled="true"' : 'data-page="' + ((opt_data.currentPage == opt_data.lastPage) ? soy.$$escapeHtml(opt_data.lastPage) : soy.$$escapeHtml(opt_data.currentPage + 1)) + '"') + '>' + soy.$$escapeHtml("Next") + '</a></li>';
  }
  output += '</ol>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.AbstractList.Templates.pagination.soyTemplateName = 'JIRA.Projects.AbstractList.Templates.pagination';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/queryStringParam.js' */
(function() {
    "use strict";

    /**
     * Get query sting param's value from the url. Optionally hash can be included in the search.
     *
     * @param name {string} The name of the parameter we're retrieving the value for.
     * @param includeHash {boolean} Whether to search for the parameter also in the hash fragment.
     *
     * @returns {string} The value of the parameter (preferring the one in the hash fragment if we're searching there, too).
     * or <tt>undefined</tt> if the parameter is not present.
     */
    function getQueryStringParam(name, includeHash, location) {
        location = location || window.location;
        if (!name) {
            return;
        }
        var params = location.search.substr(1).split('&');
        if (includeHash) {
            params = params.concat(location.hash.substr(1).split('&'));
        }
        for (var i = params.length - 1; i >= 0; i--) {
            var param = params[i].split('=');
            if (param.length != 2) continue;
            if (name === param[0]) {
                return decodeURIComponent(param[1].replace(/\+/g, " "));
            }
        }
    }

    AJS.namespace("JIRA.Projects.AbstractList.NavigationUtils");
    JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam = getQueryStringParam;
})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/NavigationUtils.js' */
(function() {
    "use strict";
    var URI = require('atlassian/libs/uri-1.14.1');

    AJS.namespace("JIRA.Projects.AbstractList.NavigationUtils");
    JIRA.Projects.AbstractList.NavigationUtils.pushStateSupported = !!history.pushState;
    JIRA.Projects.AbstractList.NavigationUtils.getBackboneHistoryRoot = function getRoot() {
        return (JIRA.Projects.AbstractList.NavigationUtils.pushStateSupported)
                ? ""
                : JIRA.Projects.AbstractList.NavigationUtils.getRoot();
    };
    JIRA.Projects.AbstractList.NavigationUtils.getRoot = function getRoot() {
        return document.location.pathname + "?selectedItem=" + JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("selectedItem");
    };
    JIRA.Projects.AbstractList.NavigationUtils.navigate = function navigate(location) {
        if (JIRA.Projects.AbstractList.NavigationUtils.pushStateSupported) {
            location = JIRA.Projects.AbstractList.NavigationUtils.getRoot() + location;
        }
        Backbone.history.navigate(location);
    };
    JIRA.Projects.AbstractList.NavigationUtils.append = function append(name, value) {
        var uri = new URI(location.href);
        uri = uri.addSearch(name, value);

        history.replaceState(null, "", uri.href());
    };
})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/FilterModel.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.AbstractList.FilterModel");
    JIRA.Projects.AbstractList.FilterModel = Backbone.Model.extend({
        filterAttributes: [],
        initialize: function initialize(options) {
            this.pageableCollection = options.pageableCollection;
            delete this.attributes.pageableCollection; // silently get rid of the set model attribute
        },
        filterCollection: function filterCollection() {
            var filtered = this.pageableCollection.originalCollection;
            this.pageableCollection.fullCollection.reset(filtered);
            this.pageableCollection.getPage("first");
        },
        navigate: function navigate() {
            JIRA.Projects.AbstractList.NavigationUtils.navigate(this.getFilterQueryStringParams());
            this.trigger("navigate");
        },
        getFilterQueryStringParams: function getFilterQueryStringParams() {
            var filter = this.filterAttributes
                    .reduce(function (previous, current) {
                        var param = this.get(current);
                        if (param) {
                            return previous + "&" + encodeURIComponent(current) + "=" + encodeURIComponent(param);
                        }
                        return previous;
                    }.bind(this), "");
            if (!JIRA.Projects.AbstractList.NavigationUtils.pushStateSupported) {
                filter = filter.substr(1)
            }
            return filter;
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/ItemModel.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.AbstractList.ItemModel");
    JIRA.Projects.AbstractList.ItemModel = Backbone.Model.extend({});

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/Layout.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.AbstractList.Layout");
    JIRA.Projects.AbstractList.Layout = JIRA.Projects.Libs.Marionette.LayoutView.extend({
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/PageableItemCollection.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.AbstractList.PageableItemCollection");
    JIRA.Projects.AbstractList.PageableItemCollection = Backbone.PageableCollection.extend({
        model: JIRA.Projects.AbstractList.ItemModel,
        initialize: function initialize(items) {
            this.originalCollection = items;
        }
    });
})();

;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/PaginationView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.AbstractList.PaginationView");
    JIRA.Projects.AbstractList.PaginationView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.AbstractList.Templates.pagination,
        ui: {
            page: "li a"
        },
        events: {
            "click @ui.page": "clickPage"
        },
        collectionEvents: {
            reset: "render"
        },
        modelEvents: {
            change: "render"
        },
        onRender: function onRender() {
            this.unwrapTemplate();
        },
        serializeData: function() {
            var url = JIRA.Projects.AbstractList.NavigationUtils.getRoot() + this.model.getFilterQueryStringParams();
            var data =_.extend({
                url: url
            }, this.collection.state);
            data.firstPage = Math.max(data.currentPage - 5, data.firstPage);
            data.totalPages = data.lastPage;
            data.lastPage = Math.min(data.currentPage + 5, data.lastPage);
            return data;
        },
        clickPage: function clickPage(e) {
            e.preventDefault();
            var pageNumber = +AJS.$(e.target).attr("data-page");
            if (pageNumber) {
                JIRA.Projects.AbstractList.NavigationUtils.navigate(this.model.getFilterQueryStringParams() + "&page=" + pageNumber);
                this.collection.getPage(pageNumber);
                this.trigger("navigate", pageNumber);
            }
        }
    });
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/Router.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.AbstractList.Router");
    JIRA.Projects.AbstractList.Router = Backbone.Router.extend({
        initialize: function() {
            this.route(/(.*)/, 'any');
        },
        any: function any() {
            // Intentionally left empty, so we have an event to bind to.
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.Release.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.Release == 'undefined') { JIRA.Projects.Release = {}; }
if (typeof JIRA.Projects.Release.Templates == 'undefined') { JIRA.Projects.Release.Templates = {}; }


JIRA.Projects.Release.Templates.page = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + JIRA.Projects.Release.Templates.whatsnew(opt_data) + aui.page.pageHeader({content: '<h1>' + soy.$$escapeHtml(opt_data.releaseTitle) + '</h1>' + ((opt_data.adminLink) ? aui.page.pageHeaderActions({content: '' + aui.buttons.button({text: "Manage Versions", href: soy.$$escapeHtml("/jira") + '/' + soy.$$escapeHtml(opt_data.adminLink)})}) : ''), extraClasses: 'aui-page-header-fixed'}) + '<div id="release-page"><div id="filter-container"></div>' + aui.page.pagePanelContent({content: '<div id="content-container"></div><div id="pagination-container"></div>', extraClasses: 'aui-page-panel-content-no-table'}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.page.soyTemplateName = 'JIRA.Projects.Release.Templates.page';
}


JIRA.Projects.Release.Templates.whatsnew = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + ((opt_data.learnMoreURL) ? '<div class="whats-new-container"><div class="whats-new"><div class="logo"></div><h2>' + soy.$$escapeHtml("Get the status of a version at a glance or go deeper") + '</h2><p>' + soy.$$escapeHtml("These are the versions in your project. Hover over the progress bar for a summary or click a version to see the complete status, including the issues, development data, and potential problems.") + '</p><p><a href="' + soy.$$escapeHtml(opt_data.learnMoreURL) + '" title="' + soy.$$escapeHtml(opt_data.learnMoreTitle) + '">' + soy.$$escapeHtml("Learn more") + '</a></p></div></div>' : '');
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.whatsnew.soyTemplateName = 'JIRA.Projects.Release.Templates.whatsnew';
}


JIRA.Projects.Release.Templates.filter = function(opt_data, opt_ignored) {
  var output = '';
  var isReleasedPressed__soy43 = opt_data.status == 'all' || opt_data.status == 'released';
  var isUnreleasedPressed__soy44 = opt_data.status == 'all' || opt_data.status == 'unreleased';
  output += '<form id="version-filter" class="version-filter aui ajs-dirty-warning-exempt"><div class="version-filter-text-container"><div class="version-filter-search-container ' + ((opt_data.contains) ? 'version-filter-search-opened' : '') + '"><input type="text" id="version-filter-text" class="version-filter-text text" value="' + soy.$$escapeHtml(opt_data.contains) + '" /><span class="aui-icon aui-icon-small aui-iconfont-search-small"></span></div><div class="version-filter-status-text" title="' + soy.$$escapeHtml("Use Quick Filters to view a subset of versions.") + '">' + soy.$$escapeHtml("Quick filters:") + '</div></div><div class="version-filter-status-container">' + JIRA.Projects.Release.Templates.button({buttonName: 'released', isPressed: isReleasedPressed__soy43, text: "Released"}) + JIRA.Projects.Release.Templates.button({buttonName: 'unreleased', isPressed: isUnreleasedPressed__soy44, text: "Unreleased"}) + '</div></form>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.filter.soyTemplateName = 'JIRA.Projects.Release.Templates.filter';
}


JIRA.Projects.Release.Templates.button = function(opt_data, opt_ignored) {
  return '<a class="version-filter-status-' + soy.$$escapeHtml(opt_data.buttonName) + ' version-filter-status-button ' + ((opt_data.isPressed) ? 'version-filter-status-pressed' : '') + '" href="#" data-version-type="' + soy.$$escapeHtml(opt_data.buttonName) + '">' + soy.$$escapeHtml(opt_data.text) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.button.soyTemplateName = 'JIRA.Projects.Release.Templates.button';
}


JIRA.Projects.Release.Templates.table = function(opt_data, opt_ignored) {
  return '' + aui.table({extraClasses: 'versions-table', theadContent: '<tr><th>' + soy.$$escapeHtml("Version") + '</th><th>' + soy.$$escapeHtml("Status") + '</th><th>' + soy.$$escapeHtml("Progress") + '</th><th class="versions-table__date">' + soy.$$escapeHtml("Start date") + '</th><th class="versions-table__date">' + soy.$$escapeHtml("Release date") + '</th><th>' + soy.$$escapeHtml("Description") + '</th></tr>', content: '', cssClass: 'versions-table', id: 'versions-table'});
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.table.soyTemplateName = 'JIRA.Projects.Release.Templates.table';
}


JIRA.Projects.Release.Templates.row = function(opt_data, opt_ignored) {
  return '<tr><td class="versions-table__name">' + ((opt_data.url) ? '<a href="' + soy.$$escapeHtml(opt_data.url) + '">' + soy.$$escapeHtml(opt_data.name) + '</a>' : soy.$$escapeHtml(opt_data.name)) + '</td><td class="versions-table__status">' + ((opt_data.released) ? aui.lozenges.lozenge({text: "Released", type: 'success', isSubtle: true}) : aui.lozenges.lozenge({text: "Unreleased", type: 'current', isSubtle: true})) + '</td><td class="versions-table__progress">' + JIRA.Projects.Release.Templates.status(opt_data.status) + '</td><td class="versions-table__date">' + JIRA.Projects.Release.Templates.date(opt_data.startDate) + '</td><td class="versions-table__date">' + JIRA.Projects.Release.Templates.date(opt_data.releaseDate) + '</td><td class="versions-table__description">' + soy.$$escapeHtml(opt_data.description) + '</td></tr>';
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.row.soyTemplateName = 'JIRA.Projects.Release.Templates.row';
}


JIRA.Projects.Release.Templates.emptyRow = function(opt_data, opt_ignored) {
  return '<tr class="versions-table__row-empty"><td colspan="6"><div class="jira-adbox jira-adbox-medium no-results"><h3>' + soy.$$escapeHtml("No versions were found that match your search") + '</h3><p class="no-results-hint">' + soy.$$escapeHtml("Try modifying your filter criteria.") + '</p></div></td></tr>';
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.emptyRow.soyTemplateName = 'JIRA.Projects.Release.Templates.emptyRow';
}


JIRA.Projects.Release.Templates.status = function(opt_data, opt_ignored) {
  var output = '';
  var totalCount__soy137 = opt_data.unmapped.count + opt_data.toDo.count + opt_data.inProgress.count + opt_data.complete.count;
  output += '<div class="progressbar-container">' + ((totalCount__soy137) ? '<div class="progressbar progressbar_full">' + JIRA.Projects.Release.Templates.progressBarEntry({entry: opt_data.complete, totalCount: totalCount__soy137, type: 'complete', name: "Done"}) + JIRA.Projects.Release.Templates.progressBarEntry({entry: opt_data.inProgress, totalCount: totalCount__soy137, type: 'in-progress', name: "In Progress"}) + JIRA.Projects.Release.Templates.progressBarEntry({entry: opt_data.toDo, totalCount: totalCount__soy137, type: 'to-do', name: "To Do"}) + JIRA.Projects.Release.Templates.progressBarEntry({entry: opt_data.unmapped, totalCount: totalCount__soy137, type: 'undefined', name: "No Category"}) + '</div>' : soy.$$escapeHtml("No issues")) + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.status.soyTemplateName = 'JIRA.Projects.Release.Templates.status';
}


JIRA.Projects.Release.Templates.progressBarEntry = function(opt_data, opt_ignored) {
  var output = '';
  var percentage__soy167 = opt_data.entry.count / opt_data.totalCount * 100;
  output += (percentage__soy167) ? '<div class="progressbar__entry progressbar__entry progressbar__entry progressbar__entry_' + soy.$$escapeHtml(opt_data.type) + '" data-type="' + soy.$$escapeHtml(opt_data.type) + '" data-title="' + soy.$$escapeHtml(opt_data.name) + '" data-count="' + soy.$$escapeHtml(opt_data.entry.count) + '" data-url="' + soy.$$escapeHtml(opt_data.entry.jqlUrl) + '" style="width: ' + soy.$$escapeHtml(percentage__soy167) + '%"></div>' : '';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.progressBarEntry.soyTemplateName = 'JIRA.Projects.Release.Templates.progressBarEntry';
}


JIRA.Projects.Release.Templates.progressBarDialog = function(opt_data, opt_ignored) {
  var output = '<div class="progress-statuses">' + soy.$$escapeHtml("Version") + ': ' + soy.$$escapeHtml(opt_data.name) + '<br />' + soy.$$escapeHtml(AJS.format("{0,choice,0#{0} issues|1#{0} issue|1\x3c{0} issues} in total",opt_data.totalCount)) + '<br /><table class="progress-statuses__table"><tbody>';
  var entryList191 = opt_data.entries;
  var entryListLen191 = entryList191.length;
  for (var entryIndex191 = 0; entryIndex191 < entryListLen191; entryIndex191++) {
    var entryData191 = entryList191[entryIndex191];
    output += '<tr><td>' + soy.$$escapeHtml(entryData191.name) + '</td><td><a href="' + soy.$$escapeHtml(entryData191.url) + '">' + aui.badges.badge({text: entryData191.count, extraClasses: 'progress-statuses__table__badge progress-statuses__table__badge_' + soy.$$escapeHtml(entryData191.type)}) + '</a></td></tr>';
  }
  output += '</tbody><tfoot><td colspan="2"><a href="' + soy.$$escapeHtml(opt_data.url) + '">' + soy.$$escapeHtml("All issues") + '</a></td></tfoot></table></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.progressBarDialog.soyTemplateName = 'JIRA.Projects.Release.Templates.progressBarDialog';
}


JIRA.Projects.Release.Templates.date = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + ((opt_data.formatted) ? '<time class="date" datetime="' + soy.$$escapeHtml(opt_data.iso) + '">' + soy.$$escapeHtml(opt_data.formatted) + '</time>' : '');
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.date.soyTemplateName = 'JIRA.Projects.Release.Templates.date';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/FilterModel.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Release.FilterModel");
    JIRA.Projects.Release.FilterModel = JIRA.Projects.AbstractList.FilterModel.extend({
        filterAttributes: ['status', 'contains'],
        defaults: {
            status: "unreleased",
            contains: ""
        },
        initialize: function initialize(options) {
            JIRA.Projects.AbstractList.FilterModel.prototype.initialize.call(this, options);

            this.on("change:status change:contains", this.filterCollection);
            this.on("change:status change:contains", this.navigate);
        },
        filterCollection: function filterCollection() {
            var status = this.get("status") || "no-filter";
            var filtered = this.pageableCollection.originalCollection;
            if (status !== "all" && status !== "no-filter") {
                filtered = filtered.filter(function filterByStatus(arrayElement) {
                    return ((status === "released" && arrayElement.released) || (status === "unreleased" && !arrayElement.released));
                });
            }

            var contains = (this.get("contains") || "").toLowerCase();
            if (contains !== "") {
                filtered = filtered.filter(function filterText(arrayElement) {
                    return (
                        arrayElement.name.toLowerCase().indexOf(contains) > -1 ||
                        arrayElement.description.toLowerCase().indexOf(contains) > -1 ||
                        arrayElement.startDate.formatted.toLowerCase().indexOf(contains) > -1 ||
                        arrayElement.releaseDate.formatted.toLowerCase().indexOf(contains) > -1
                    );
                });
            }
            this.pageableCollection.fullCollection.reset(filtered);
            this.pageableCollection.getPage("first");
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/FilterView.js' */
define("jira/projects/page/release/view/filter", [
    "jira/projects/libs/marionette",
    "underscore"
], function(
    Marionette,
    _
) {
    "use strict";
    var Templates = JIRA.Projects.Release.Templates;
    var trace = _.bind(JIRA.trace, JIRA);

    var CLASSES = {
        CONTAINS_OPENED: "version-filter-search-opened",
        STATUS_PRESSED: "version-filter-status-pressed"
    };

    return Marionette.ItemView.extend({
        template: Templates.filter,
        ui: {
            "form": "form",
            "unreleased": ".version-filter-status-unreleased",
            "released": ".version-filter-status-released",
            "contains": ".text",
            "quickFilter": ".version-filter-status-text",
            "searchContainer": ".version-filter-search-container"
        },
        events: {
            // Prevent the form from being submitted when user hits enter
            "submit @ui.form": function formSubmit(e) {
                e.preventDefault();
            },
            "input @ui.contains": "inputContains",
            "change @ui.contains": "inputContains",
            "click @ui.released": "clickStatusReleased",
            "click @ui.unreleased": "clickStatusUnreleased",
            "focus @ui.contains": function() {
                this.ui.searchContainer.addClass(CLASSES.CONTAINS_OPENED);
            },
            "blur @ui.contains": function() {
                if (this._isContainsEmpty()) {
                    this.ui.searchContainer.removeClass(CLASSES.CONTAINS_OPENED);
                }
            }
        },
        modelEvents: {
            "change:status": function onStatusChange() {
                var isReleasedPressed = this._getReleased();
                var isUnreleasedPressed = this._getUnreleased();

                var hasReleasedPressedClass = this.ui.released.hasClass(CLASSES.STATUS_PRESSED);
                var hasUnreleasedPressedClass = this.ui.unreleased.hasClass(CLASSES.STATUS_PRESSED);

                if (isReleasedPressed && !hasReleasedPressedClass) {
                    this.ui.released.addClass(CLASSES.STATUS_PRESSED);
                }

                if (!isReleasedPressed && hasReleasedPressedClass) {
                    this.ui.released.removeClass(CLASSES.STATUS_PRESSED);
                }

                if (isUnreleasedPressed && !hasUnreleasedPressedClass) {
                    this.ui.unreleased.addClass(CLASSES.STATUS_PRESSED);
                }

                if (!isUnreleasedPressed && hasUnreleasedPressedClass) {
                    this.ui.unreleased.removeClass(CLASSES.STATUS_PRESSED);
                }

                trace("project.release.status.changed");
            }
        },
        onRender: function() {
            this.ui.quickFilter.tooltip({
                gravity: "w"
            });
        },
        clickStatusReleased: function (e) {
            this._clickStatus(e, !this._getReleased(), this._getUnreleased());
        },
        clickStatusUnreleased: function (e) {
            this._clickStatus(e, this._getReleased(), !this._getUnreleased());
        },
        _clickStatus: function (e, released, unreleased) {
            e.preventDefault();
            this.model.set("status", this._getCurrentStatus(released, unreleased));
        },
        _isContainsEmpty: function() {
            return _.isEmpty(this.ui.contains.val());
        },
        searchContainerResize: function() {
            if (!this._isContainsEmpty()) {
                this.ui.searchContainer.addClass(CLASSES.CONTAINS_OPENED);
            } else {
                if (!this.ui.contains.is(":focus")) {
                    this.ui.searchContainer.removeClass(CLASSES.CONTAINS_OPENED);
                }
            }
        },
        _inputContains: _.debounce(function inputContains(e) {
            var filter = this.ui.contains.val();
            this.model.set("contains", filter);
        }, 100),
        inputContains: function inputContains(e) {
            this.searchContainerResize();
            this._inputContains();
        },
        _getReleased: function() {
            var status = this.model.get("status");
            return status === 'all' || status === 'released';
        },
        _getUnreleased: function() {
            var status = this.model.get("status");
            return status === 'all' || status === 'unreleased';
        },
        _getCurrentStatus: function getCurrentStatus(released, unreleased) {
            if (released && unreleased) {
                return "all";
            } else if (unreleased) {
                return "unreleased";
            } else if (released) {
                return "released";
            } else {
                return "no-filter";
            }
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/EmptyItemView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Release");
    JIRA.Projects.Release.EmptyItemView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Release.Templates.emptyRow,
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/ItemView.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Release.ItemView");
    JIRA.Projects.Release.ItemView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Release.Templates.row,
        ui: {
            progressbar:  ".progressbar"
        },
        onRender: function onRender() {
            this.unwrapTemplate();
            this.initializeProgressDialog();
        },
        initializeProgressDialog: function initializeProgressDialog() {
            var instance = this;
            var versionInlineDialog = AJS.InlineDialog(this.ui.progressbar, "version-progress-" + this.cid,
                    function(content, trigger, showPopup) {
                        var $trigger = AJS.$(trigger);
                        var $row = $trigger.closest("tr");
                        var $versionName = $row.find("td:first-child a");
                        var entries = [];
                        var totalCount = 0;
                        $trigger.find(".progressbar__entry").each(function(i, el){
                            var $el = $(el);
                            var count = +$el.attr("data-count");
                            totalCount += +count;
                            entries.push({
                                name: $el.attr("data-title"),
                                type: $el.attr("data-type"),
                                url: $el.attr("data-url"),
                                count: count
                            });
                        });
                        content.html(JIRA.Projects.Release.Templates.progressBarDialog({
                            name: $versionName.text(),
                            url: $versionName.attr("href"),
                            totalCount: totalCount,
                            entries: entries
                        }));
                        showPopup();
                        versionInlineDialog.refresh();

                        return false;
                    },
                    {
                        gravity: 'w',
                        autoWidth: true,
                        onHover: true,
                        hideDelay: 500
                    }
            );
            versionInlineDialog.on("click", "a", function () {
                instance.trigger("progressDialogClicked");
            });
        }
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/ItemCollectionView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Release.ItemCollectionView");
    JIRA.Projects.Release.ItemCollectionView = JIRA.Projects.Libs.Marionette.CompositeView.extend({
        childView: JIRA.Projects.Release.ItemView,
        childViewContainer: "tbody",
        emptyView: JIRA.Projects.Release.EmptyItemView,
        template: JIRA.Projects.Release.Templates.table
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/ReleasePageApp.js' */
define("jira/projects/page/release/release-page-app", [
    "jira/projects/libs/marionette",
    "jira/api/projects",
    "jira/projects/page/release/view/filter",
    "jira/data/local-storage",
    "wrm/data",
    "backbone"
], function(
    Marionette,
    Projects,
    FilterView,
    localStorage,
    WRMData,
    Backbone
) {
    "use strict";

    var App = new Marionette.Application();

    function isOnProject() {
        return Projects.getCurrentProjectId() !== undefined;
    }

    App.on("start", function(options) {
        if (!isOnProject()) {
            return;
        }
        var projectId = Projects.getCurrentProjectId();
        var storageStatusKey = "jira-projects:release-page-status-" + projectId;

        var $el = options.container;
        var data = WRMData.claim('com.atlassian.jira.projects.page.release:versions');


        function saveStatus(status) {
            try {
                localStorage.setItem(storageStatusKey, status);
            } catch (exc) {
                // local storage may be disabled or full, do not do anything in this case
                console.warn(exc);
            }
        }

        App.pageableItems = new JIRA.Projects.AbstractList.PageableItemCollection(data, {
            mode: "client",
            state: {
                pageSize: (data.length > 50) ? 25 : 50,
                currentPage: 1
            }
        });

        App.filter = new JIRA.Projects.Release.FilterModel({
            pageableCollection: App.pageableItems,
            status: "unreleased",
            contains: ""
        });
        App.filter.filterCollection();
        App.filter.on("change:status", function(child, value) {
            saveStatus(value);
        });

        App.layout = new JIRA.Projects.AbstractList.Layout({
            model: App.filter,
            el: $el,
            regions: {
                filter: "#filter-container",
                main: "#content-container",
                pagination: "#pagination-container"
            }
        });

        App.layout.filter.show(new FilterView({
            model: App.filter
        }));

        App.layout.main.show(new JIRA.Projects.Release.ItemCollectionView({
            collection: App.pageableItems
        }));

        App.layout.pagination.show(new JIRA.Projects.AbstractList.PaginationView({
            collection: App.pageableItems,
            model: App.filter
        }));

        App.router = new JIRA.Projects.AbstractList.Router();
        App.router.on("route:any", function() {
            var status = JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("status", true) || "unreleased";
            var contains = JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("contains", true) || "";
            var page = +JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("page", true) || 1;

            App.filter.set("status", status, {silent: true});
            saveStatus(status);
            App.filter.set("contains", contains, {silent: true});
            App.filter.filterCollection();
            App.pageableItems.getPage(page);
            App.layout.filter.currentView.render();
        });

        function onNavigate() {
            App.trigger("navigate");
        }
        App.layout.pagination.currentView.on("navigate", onNavigate);
        App.filter.on("navigate", onNavigate);
        App.router.on("route:any", onNavigate);
        App.layout.main.currentView.on("childview:progressDialogClicked", function() {
            App.trigger("progressDialogClicked");
        });

        try {
            var storedStatus = localStorage.getItem(storageStatusKey);
            if (!JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("status", true) && isOnProject() && !!storedStatus) {
                App.filter.set("status", storedStatus, {silent: true});
                JIRA.Projects.AbstractList.NavigationUtils.append("status", storedStatus);
            }
        } catch (exc) {
            // local storage may be disabled or full, do not do anything in this case
            console.warn(exc);
        }


        if (Backbone.history && Backbone.History && !Backbone.History.started) {
            Backbone.history.start({
                root: JIRA.Projects.AbstractList.NavigationUtils.getBackboneHistoryRoot(),
                pushState: JIRA.Projects.AbstractList.NavigationUtils.pushStateSupported
            });
        }
    });

    return App;
});

AJS.namespace("JIRA.Projects.Release.App", null, require("jira/projects/page/release/release-page-app"));;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/Analytics.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Release.Analytics");
    JIRA.Projects.Release.Analytics = JIRA.Projects.Libs.Marionette.Controller.extend({
        progressDialogClick: function () {
            AJS.trigger('analyticsEvent', {
                name: "jira.projects.release.progress.dialog.click"
            });
        },
        navigate: function navigate() {
            var status = JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("status", true) || "unreleased";
            var contains = JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("contains", true) || "";
            var page = +JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("page", true) || 1;

            AJS.trigger('analyticsEvent', {
                name: "jira.projects.release.navigate",
                data: {
                    status: status,
                    containsLength: contains.length,
                    page: page
                }
            });
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/release-page-init.js' */
require([
    "jquery",
    "jira/projects/page/release/release-page-app"
], function(
    $,
    ReleasePageApp
) {
    "use strict";

    var analytics = new JIRA.Projects.Release.Analytics();
    ReleasePageApp.on("navigate", analytics.navigate);
    ReleasePageApp.on("progressDialogClicked", analytics.progressDialogClick);

    $(function() {
        var $releaseContainer = $("#release-page");
        if ($releaseContainer.length) {
            ReleasePageApp.start({
                container: $releaseContainer
            });
        }
    });

});;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.Components.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.Components == 'undefined') { JIRA.Projects.Components = {}; }
if (typeof JIRA.Projects.Components.Templates == 'undefined') { JIRA.Projects.Components.Templates = {}; }


JIRA.Projects.Components.Templates.page = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return aui.page.pageHeader({content: '<h1>' + soy.$$escapeHtml("Components") + '</h1>' + ((opt_data.adminLink) ? aui.page.pageHeaderActions({content: '' + aui.buttons.button({text: "Manage components", href: soy.$$escapeHtml("/jira") + '/' + soy.$$escapeHtml(opt_data.adminLink), id: 'add_component'})}) : ''), extraClasses: 'aui-page-header-fixed'}) + '<div id="components-page"><div id="filter-container"></div>' + aui.page.pagePanelContent({content: '<div id="content-container"></div><div id="pagination-container"></div>', extraClasses: 'aui-page-panel-content-no-table'}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Projects.Components.Templates.page.soyTemplateName = 'JIRA.Projects.Components.Templates.page';
}


JIRA.Projects.Components.Templates.table = function(opt_data, opt_ignored) {
  return '' + aui.table({extraClasses: 'components-table', theadContent: '<tr><th>' + soy.$$escapeHtml("Component") + '</th><th>' + soy.$$escapeHtml("Issues") + '</th><th>' + soy.$$escapeHtml("Lead") + '</th><th>' + soy.$$escapeHtml("Description") + '</th></tr>', content: '', cssClass: 'components-table', id: 'components-table'});
};
if (goog.DEBUG) {
  JIRA.Projects.Components.Templates.table.soyTemplateName = 'JIRA.Projects.Components.Templates.table';
}


JIRA.Projects.Components.Templates.row = function(opt_data, opt_ignored) {
  return '<tr><td class="components-table__name"><a href="' + soy.$$escapeHtml(opt_data.issuesUrl) + '">' + soy.$$escapeHtml(opt_data.name) + '</a></td><td class="components-table__issues-count"><a href="' + soy.$$escapeHtml(opt_data.issuesUrl) + '">' + soy.$$escapeHtml(AJS.format("{0,choice,0#{0} Issues|1#{0} Issue|1\x3c{0} Issues}",opt_data.issuesCount)) + '</a></td><td class="components-table__lead">' + soy.$$filterNoAutoescape(opt_data.leadUserProfileLinkHtml) + '</td><td class="components-table__description">' + ((opt_data.description) ? soy.$$escapeHtml(opt_data.description) : '') + '</td></tr>';
};
if (goog.DEBUG) {
  JIRA.Projects.Components.Templates.row.soyTemplateName = 'JIRA.Projects.Components.Templates.row';
}


JIRA.Projects.Components.Templates.emptyRow = function(opt_data, opt_ignored) {
  return '<tr class="components-table__row-empty"><td colspan="6"><div class="jira-adbox jira-adbox-medium no-results"><h3>' + soy.$$escapeHtml("No components were found that match your search") + '</h3><p class="no-results-hint">' + soy.$$escapeHtml("Try modifying your filter criteria.") + '</p></div></td></tr>';
};
if (goog.DEBUG) {
  JIRA.Projects.Components.Templates.emptyRow.soyTemplateName = 'JIRA.Projects.Components.Templates.emptyRow';
}


JIRA.Projects.Components.Templates.filter = function(opt_data, opt_ignored) {
  return '<form id="component-filter" class="component-filter aui ajs-dirty-warning-exempt"><div class="component-filter-text-container"><input type="text" id="component-filter-text" placeholder="' + soy.$$escapeHtml("Contains text...") + '" class="component-filter-text text" value="' + soy.$$escapeHtml(opt_data.contains) + '" /><span class="aui-icon aui-icon-small aui-iconfont-search-small"></span></div></form>';
};
if (goog.DEBUG) {
  JIRA.Projects.Components.Templates.filter.soyTemplateName = 'JIRA.Projects.Components.Templates.filter';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/FilterModel.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.FilterModel");
    JIRA.Projects.Components.FilterModel = JIRA.Projects.AbstractList.FilterModel.extend({
        filterAttributes: ['contains'],
        defaults: {
            contains: ""
        },
        initialize: function initialize(options) {
            JIRA.Projects.AbstractList.FilterModel.prototype.initialize.call(this, options);

            this.on("change:contains", this.filterCollection);
            this.on("change:contains", this.navigate);
        },
        filterCollection: function filterCollection() {
            var filtered = this.pageableCollection.originalCollection;
            var contains = (this.get("contains") || "").toLowerCase();
            if (contains !== "") {
                filtered = filtered.filter(function filterText(arrayElement) {
                    return (
                            (arrayElement.name && arrayElement.name.toLowerCase().indexOf(contains) > -1) ||
                            (arrayElement.description && arrayElement.description.toLowerCase().indexOf(contains) > -1) ||
                            (arrayElement.leadUserDisplayName && arrayElement.leadUserDisplayName.toLowerCase().indexOf(contains) > -1)
                    );
                });
            }
            this.pageableCollection.fullCollection.reset(filtered);
            this.pageableCollection.getPage("first");
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/FilterView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.FilterView");
    JIRA.Projects.Components.FilterView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Components.Templates.filter,
        ui: {
            "form": "form",
            "contains": ".text"
        },
        events: {
            "submit @ui.form": "formSubmit",
            "input @ui.contains": "inputContains",
            "change @ui.contains": "inputContains"
        },
        formSubmit: function formSubmit(e) {
            e.preventDefault();
        },
        inputContains: _.debounce(function inputContains(e) {
            var filter = this.ui.contains.val();
            this.model.set("contains", filter);
        }, 300)
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/EmptyItemView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.EmptyItemView");
    JIRA.Projects.Components.EmptyItemView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Components.Templates.emptyRow,
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/ItemView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.ItemView");
    JIRA.Projects.Components.ItemView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Components.Templates.row,
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/ItemCollectionView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.ItemCollectionView");
    JIRA.Projects.Components.ItemCollectionView = JIRA.Projects.Libs.Marionette.CompositeView.extend({
        childView: JIRA.Projects.Components.ItemView,
        childViewContainer: "tbody",
        emptyView: JIRA.Projects.Components.EmptyItemView,
        template: JIRA.Projects.Components.Templates.table
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/ComponentsPageApp.js' */
(function componentsPage() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.App");
    var App = JIRA.Projects.Components.App = new JIRA.Projects.Libs.Marionette.Application();

    App.on("start", function(options) {
        var $el = options.container;
        var data = WRM.data.claim("com.atlassian.jira.projects.page.components:components");

        App.pageableItems = new JIRA.Projects.AbstractList.PageableItemCollection(data, {
            mode: "client",
            state: {
                pageSize: (data.length > 50) ? 25 : 50,
                currentPage: 1
            }
        });

        App.filter = new JIRA.Projects.Components.FilterModel({
            pageableCollection: App.pageableItems,
            contains: ""
        });
        App.filter.filterCollection();

        App.layout = new JIRA.Projects.AbstractList.Layout({
            model: App.filter,
            el: $el,
            regions: {
                filter: "#filter-container",
                main: "#content-container",
                pagination: "#pagination-container"
            }
        });

        App.layout.filter.show(new JIRA.Projects.Components.FilterView({
            model: App.filter
        }));

        App.layout.main.show(new JIRA.Projects.Components.ItemCollectionView({
            collection: App.pageableItems
        }));

        App.layout.pagination.show(new JIRA.Projects.AbstractList.PaginationView({
            collection: App.pageableItems,
            model: App.filter
        }));

        App.router = new JIRA.Projects.AbstractList.Router();
        App.router.on("route:any", function() {
            var contains = JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("contains", true) || "";
            var page = +JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("page", true) || 1;

            App.filter.set("contains", contains, {silent: true});
            App.filter.filterCollection();
            App.pageableItems.getPage(page);
            App.layout.filter.currentView.render();
        });

        function onNavigate() {
            App.trigger("navigate");
        }
        App.layout.pagination.currentView.on("navigate", onNavigate);
        App.filter.on("navigate", onNavigate);
        App.router.on("route:any", onNavigate);

        if (Backbone.history && Backbone.History && !Backbone.History.started) {
            Backbone.history.start({
                root: JIRA.Projects.AbstractList.NavigationUtils.getBackboneHistoryRoot(),
                pushState: JIRA.Projects.AbstractList.NavigationUtils.pushStateSupported
            });
        }
    });

}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/Analytics.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.Analytics");
    JIRA.Projects.Components.Analytics = JIRA.Projects.Libs.Marionette.Controller.extend({
        navigate: function navigate() {
            var contains = JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("contains", true) || "";
            var page = +JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("page", true) || 1;

            AJS.trigger('analyticsEvent', {
                name: "jira.projects.components.navigate",
                data: {
                    containsLength: contains.length,
                    page: page
                }
            });
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/components-page-init.js' */
(function componentsPage($) {
    "use strict";

    var analytics = new JIRA.Projects.Components.Analytics();
    JIRA.Projects.Components.App.on("navigate", analytics.navigate);

    $(function() {
        var $componentsContainer = $("#components-page");
        if ($componentsContainer.length) {
            JIRA.Projects.Components.App.start({
                container: $componentsContainer
            });
        }
    });
}(AJS.$));;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:report-page-assets', location = '/page/project/report/analytics.js' */
(function reportsPageAnalytics($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Report");

    JIRA.Projects.Report.Analytics = function() {

        $('.reports .reports__list__report').on('click', function(e) {
            var $this = $(this);

            AJS.trigger('analyticsEvent', {
                name: "jira.projects.report.clicked",
                data: {
                    report: $this.attr("data-report-key"),
                    category: $this.closest('ul').attr("data-category-key"),
                    listPosition: $this.closest('li').prevAll().length + 1
                }
            });
        });
    };

    $(JIRA.Projects.Report.Analytics);
}(AJS.$));;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:reports-link-storage', location = '/sidebar/reports/reports-link-storage.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.Reports");

    JIRA.Projects.Sidebar.Reports = {
        storeLastViewedReportLink: function(reportUrl) {
            if (JIRA.API.Sidebar.isProjectSidebar()) {
                var key = this._createLastViewedReportKey();
                require("jira/data/local-storage").setItem(key, reportUrl);
                this._setReportsItemLink(reportUrl);
            }
            JIRA.trace("jira.projects.sidebar.reports.link.stored");
        },

        restoreLastViewedReportLink: function() {
            if (JIRA.API.Sidebar.isProjectSidebar()) {
                var key = this._createLastViewedReportKey();
                var reportUrl = require("jira/data/local-storage").getItem(key);
                if (reportUrl) {
                    this._setReportsItemLink(reportUrl);
                }
            }
            JIRA.trace("jira.projects.sidebar.reports.link.restored");
        },

        _createLastViewedReportKey: function() {
            var scopeFilterId = JIRA.API.Sidebar.getSelectedScopeFilterId();
            var projectKey = JIRA.API.Projects.getCurrentProjectKey();

            var key = "last.viewed.report." + projectKey;
            if (scopeFilterId) {
                key += "." + scopeFilterId;
            }
            return key;
        },

        _setReportsItemLink: function(reportUrl) {
            JIRA.API.Sidebar.setReportsItemLink(reportUrl);
        }
    };

}());
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:reports-link-init', location = '/sidebar/reports/reports-link-init.js' */
AJS.$(function() {
    "use strict";

    JIRA.API.getSidebar().done(function() {
        JIRA.Projects.Sidebar.Reports.restoreLastViewedReportLink();
    });
});
;
;
/* module-key = 'com.atlassian.plugins.helptips.jira-help-tips:common', location = 'js/HelpTip.js' */
(function($) {
    function nope() { return false; }
    function yep() { return true; }

    var HELP_TIP_CLASSNAMES = 'jira-help-tip aui-help';

    var cidCounter = 0, seed = new Date().getTime();

    // to un-fuck graphite event names
    function cleanAnalyticsName(name) {
        name = "" + (name || "");
        return name.replace(/\./g, "-");
    }

    function analytics(eventId, model) {
        if (AJS.EventQueue && model && model.attributes.id) {
            var event = {};
            var cleanId = cleanAnalyticsName(model.attributes.id);
            var eventPrefix = "";

            if (model.attributes.eventPrefix) {
                eventPrefix = model.attributes.eventPrefix;
                // Ensure a dot at the end of the event prefix
                if (eventPrefix.charAt(eventPrefix.length - 1) !== ".") {
                    eventPrefix += ".";
                }
            }

            event.name = eventPrefix + "helptips." + cleanId + "." + eventId;
            event.properties = {};
            AJS.EventQueue.push(event);
        }
    }

    function getCid() {
        return "jira-help-tip-" + seed + (cidCounter++);
    }

    /**
     * @param attributes
     * @param attributes.id
     * @param attributes.callbacks callbacks used by helptip and passed into AJS.InlineDialog
     * @param attributes.callbacks.beforeShow {jQuery.Deferred() | Function} called before rendering the helptip
     * @param attributes.callbacks.init {Function} passed into AJS.InlineDialog as initCallback param
     * @param attributes.callbacks.hide {Function} passed into AJS.InlineDialog as hideCallback param
     * @param attributes.isSequence {Boolean} to indicate whether this helptip should be shown in sequence
     *        see https://developer.atlassian.com/design/latest/feature-discovery.html
     * @param attributes.weight {Integer} the weight of the helptip determining the order to be shown in sequence
     * @param attributes.body {String} the HTML body content of the helptip
     * @param attributes.bodyHtml {String} same as attributes.body
     * @param attributes.inlineDialogOpts {Map} passed into AJS.InlineDialog as options, This will replace all the defaults specified by HelpTip
     * @param attributes.eventPrefix {String} The prefix to use for all analytics events
     * @param attributes.nextButtonText {String} The text to be displayed on the 'next' button
     * @param attributes.closeButtonText {String} The text to be displayed on the 'close' button
     * @param attributes.showCloseButton {Boolean} Whether the 'close' button should be displayed on the helptip
     *
     * @type {Function}
     */
    var HelpTip = AJS.HelpTip = function(attributes) {
        var anchor;
        this.attributes = $.extend({}, attributes);
        this.attributes.id || (this.attributes.id = false);
        this.attributes.callbacks || (this.attributes.callbacks = {});

        //Allows the helptip to be shown in sequence via next button
        if (this.attributes.isSequence) {
            if(!this.attributes.weight) {
                this.attributes.weight = Number.MAX_VALUE;
            }
            AJS.HelpTip.Manager.sequences.push(this);
        }

        // Map renamed attribute body to bodyHtml
        if (this.attributes.body) {
            this.attributes.bodyHtml = this.attributes.body;
            delete this.attributes.body;
        }
        this.cid = getCid();
        anchor = this.attributes['anchor'];
        delete this.attributes['anchor'];

        this.view = (anchor) ? new AnchoredView(this, anchor) : new UnanchoredView(this);
    };

    $.extend(HelpTip.prototype, {
        /**
         * @param options.force render the helptip regardless of the display controller
         */
        show: function(options) {
            options = options || {};

            var self = this;
            var showDeferred = $.Deferred();
            if (this.attributes.callbacks.beforeShow) {
                var beforeShowDeferred = this.attributes.callbacks.beforeShow();
                if (beforeShowDeferred && _.isFunction(beforeShowDeferred.done)) {
                    beforeShowDeferred.done(showDeferred.resolve)
                } else {
                    showDeferred.resolve();
                }
            } else {
                showDeferred.resolve();
            }

            showDeferred.done(function() {
                AJS.HelpTip.Manager.show(function() {
                    if (!self.isDismissed()) {
                        if (!options.force && AJS.Popups && AJS.Popups.DisplayController) {
                            AJS.Popups.DisplayController.request({
                                name:self.id,
                                weight:1000,
                                show:function () {
                                    self.view.show();
                                }})
                        } else {
                            self.view.show();
                        }
                        analytics("shown", self);
                    }
                });
            });
        },
        dismiss: function() {
            var reason = cleanAnalyticsName(arguments[0] || "programmatically");
            this.view.dismiss();
            //Clicking close should stop other helptip in sequence from showing
            if (reason === "close-button" && this.attributes.isSequence) {
                AJS.HelpTip.Manager.clearSequences();
            }
            if (!this.isDismissed()) {
                AJS.HelpTip.Manager.dismiss(this);
                analytics("dismissed." + reason, this);
            }
        },
        isVisible: function() {
            return this.view.$el.is(":visible");
        },
        isDismissed: function() {
            return AJS.HelpTip.Manager.isDismissed(this);
        },

        /**
         * Redraws the help tip.
         *  - If a selector was passed as the anchor, it will check if the actual element has changed and reanchor
         *    if necessary
         *  - If the anchor is not visible, it will hide the help tip
         *  - If the anchor has moved, it will re-position the help tip
         */
        refresh: function() {
            if (!this.isDismissed()) {
                this.view.refresh();
            }
        },

        /**
         * Hide the help tip without dismissing it
         */
        hide: function() {
            if (!this.isDismissed()) {
                this.view.dismiss();
            }
        },

        /**
         * Advance to the next help tip if this help tip
         * is part of a sequence and is not the last help
         * tip in the sequence. Useful in the situation where
         * user can progress by performing some action in addition to
         * clicking the next button.
         */
        showNextHelpTipInSequence: function() {
            this.view.clickNext();
        }
    });

    var AnchoredView = function(model, anchor) {
        this.initialize(model, anchor);
    };

    $.extend(AnchoredView.prototype, {
        initialize: function(model, anchor) {
            this.model = model;
            this.anchorSelector = anchor;
            this.anchor = AJS.$(anchor);
            this._initDialog(anchor);
            AJS.$(document).bind("showLayer",function(e,type,layer) {
                if (type === "inlineDialog" && layer.id === model.cid) {
                    AJS.InlineDialog.current = null; // Tips shouldn't be considered InlineDialogs.
                    AJS.$(document.body).unbind("click."+model.cid+".inline-dialog-check");
                    layer._validateClickToClose = nope;
                    layer.hide = nope;
                }
            });
        },
        show: function() {
            this.beforeHide = nope;
            this.popup.show();
        },
        refresh: function() {
            var maybeNewAnchor = AJS.$(this.anchorSelector);
            if (!maybeNewAnchor.is(':visible')) {
                this.dismiss(); // hide
            } else if (maybeNewAnchor.get(0) !== this.anchor.get(0)) {
                this.changeAnchor(maybeNewAnchor);
            } else if (!this.isVisible()) {
                this.show();
            } else {
                this.popup.refresh();
            }
        },
        changeAnchor: function(anchor) {
            var wasVisible = this.isVisible();
            this.dismiss();
            this.$el.remove();
            this.anchor = anchor;
            this._initDialog(anchor);
            if (wasVisible) {
                this.show();
            }
        },
        dismiss: function() {
            this.beforeHide = yep;
            this._popupHide();
        },
        clickNext: function() {
            var nextButton = AJS.$(this.$el).find(".helptip-next");
            if (nextButton.length > 0) {
                nextButton.click();
            }
        },
        isVisible: function() {
            return this.$el.is(':visible');
        },
        _initDialog: function(anchor) {
            var self = this;
            var model = this.model;
            this.popup = AJS.InlineDialog($(anchor), model.cid, _.bind(this._createDialog, this), _.extend({
                // Use a container other than body, so that the positioning works when there are client-rendered banner messages
                container: "#content",
                noBind: true,
                preHideCallback: function() { return self.beforeHide() },
                calculatePositions: function(popup, targetPosition, mousePosition, opts) {
                    // Adjust positions relative to the container
                    var cssData = AJS.InlineDialog.opts.calculatePositions(popup, targetPosition, mousePosition, opts);
                    var $container = $(this.container);
                    var offset = $container.offset();
                    if (cssData.popupCss.left !== 'auto') {
                        cssData.popupCss.left -= offset.left;
                        // Inline dialog has a bug where in some scenarios both left and right pos of the popup is set.
                        cssData.popupCss.right = 'auto';
                    }
                    cssData.popupCss.top -= offset.top;
                    return cssData;
                },
                addActiveClass: false,
                initCallback: model.attributes.callbacks.init,
                hideCallback: model.attributes.callbacks.hide,
                persistent: true
            }, model.attributes.inlineDialogOpts));
            this._popupHide = this.popup.hide;
            this.popup.hide = nope;
            this.$el = $(this.popup[0]);
            this.$el.addClass(HELP_TIP_CLASSNAMES);
        },
        _createDialog: function(content, trigger, show) {
            var instance = this;
            var sequenceDialogs = AJS.HelpTip.Manager.sequences;
            var position = this.model.attributes.position;
            var isSequence = this.model.attributes.isSequence;

            content.removeClass('contents');

            content.html($(AJS.Templates.HelpTip.tipContent(_.extend({
                showNextButton: isSequence && (sequenceDialogs.length > 1 && (position+1 < sequenceDialogs.length)),
                length: sequenceDialogs.length,
                position: position,
                showCloseButton: true
            }, this.model.attributes))));

            content.unbind('mouseover mouseout');
            content.find(".helptip-link").click(function() {
                analytics("learn-more.clicked", instance.model);
            });
            content.find(".helptip-close").click(function(e) {
                e.preventDefault();
                instance.model.dismiss("close-button");
            });
            content.find(".helptip-next").click(function(e) {
                e.preventDefault();
                instance.model.dismiss("next-button");
                var next = position + 1;
                sequenceDialogs[next] && (sequenceDialogs[next].show({force: true}));
            });
            show();
        }
    });

    var UnanchoredView = function(model) {
        this.initialize(model);
    };

    $.extend(UnanchoredView.prototype, {
        initialize: function() {
            this.$el = $("<div></div>");
            this.$el.addClass(HELP_TIP_CLASSNAMES);
        },
        show: function() { },
        dismiss: function() { }
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.plugins.helptips.jira-help-tips:common', location = 'js/HelpTipManager.js' */
(function($) {
    var restUrl = AJS.contextPath() + "/rest/helptips/1.0/tips";
    var tipWRMData = undefined;
    if (WRM && WRM.data) {
        tipWRMData = WRM.data.claim("com.atlassian.plugins.helptips.jira-help-tips:common.JiraHelpTipData");
    }

    var Manager = {
        dismissedTipIds: [],
        sequences: [],
        loaded: $.Deferred(),
        url: function() { return restUrl; },
        sync: function(verb, data) {
            var result = $.Deferred();
            verb || (verb = "get");
            data || (data = null);
            if (verb === "get" && tipWRMData && tipWRMData.dismissed) {
                result.resolve(tipWRMData.dismissed);
            } else {
                $.ajax(this.url(), {
                    type: verb,
                    dataType: "json",
                    contentType: "application/json",
                    data: data && JSON.stringify(data),
                    processData: false
                })
                    .done(function(data) {
                        result.resolve(data);
                    })
                    .fail(function() {
                        result.reject();
                    });
            }
            return result.promise();
        },
        fetch: function() {
            var result = this.sync();
            result.done($.proxy(function(response) {
                $.merge(this.dismissedTipIds, response);
                this.loaded.resolve();
            }, this));
            return result.promise();
        },
        show: function(showFunction) {
            this.loaded.done(showFunction);
        },
        dismiss: function(tip) {
            var id = tip.attributes.id;
            if (!id) {
                tip._dismissed = true;
            } else {
                this.dismissedTipIds.push(id);
                this.sync("post", {id:id});
            }
        },
        undismiss: function(tip) {
            var id = tip.attributes.id;
            if (!id) {
                tip._dismissed = false;
            } else {
                this.dismissedTipIds.splice($.inArray(id, this.dismissedTipIds), 1);
                this.sync("delete", {id:id});
            }
        },
        isDismissed: function(tip) {
            var id = tip.attributes.id;
            return (id) ? $.inArray(id, this.dismissedTipIds) >= 0 : tip._dismissed;
        },
        /**
         * Clear the list of helptips that would be shown in sequence
         */
        clearSequences: function() {
            this.sequences = [];
        },
        /**
         * Hide all the helptips that would be shown in sequence
         */
        hideSequences: function() {
            _.each(this.sequences, function(helptip) {
                helptip.view.dismiss();
            });
        },
        /**
         * Initiate the rendering of helptips in sequence starting from the first one
         */
        showSequences: function() {
            if (!this._showStarted) {
                var instance = this;
                var index = 0;
                this._showStarted = true;
                $.when(this.loaded).done(function() {
                    //Sort by weight
                    instance.sequences.sort(function(a, b) {
                        return a.attributes.weight - b.attributes.weight;
                    });
                    //Remove any helptips that have already been dismissed
                    instance.sequences = _.filter(instance.sequences, function(dialog) {
                        var shouldShow = _.indexOf(instance.dismissedTipIds, dialog.attributes.id) === -1;
                        if (shouldShow) {
                            dialog.attributes.position = index++;
                        }
                        return shouldShow;
                    });
                    if (instance.sequences.length > 0) {
                        //SW-1740: Ensure the last tip part of a sequence always shows the close button. Filtering out already dismissed
                        // tips above may have changed the original last tip.
                        _.last(instance.sequences).attributes.showCloseButton = true;

                        instance.sequences[0].show({force: true});
                    }
                    instance._showStarted = false;
                });
            }
        }
    };

    // Check if the user is logged in, otherwise the REST resource will return a status of 401 (Unauthorized)
    if (!JIRA.Users.LoggedInUser.isAnonymous()) {
        AJS.HelpTip.Manager = Manager;
        // Load up the user's dismissed tips.
        Manager.fetch();
    }
})(AJS.$);;
;
/* module-key = 'com.atlassian.plugins.helptips.jira-help-tips:common', location = 'templates/HelpTip.soy' */
// This file was automatically generated from HelpTip.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace AJS.Templates.HelpTip.
 */

if (typeof AJS == 'undefined') { var AJS = {}; }
if (typeof AJS.Templates == 'undefined') { AJS.Templates = {}; }
if (typeof AJS.Templates.HelpTip == 'undefined') { AJS.Templates.HelpTip = {}; }


AJS.Templates.HelpTip.tipContent = function(opt_data, opt_ignored) {
  return ((opt_data.title) ? '<h2 class="helptip-title">' + soy.$$escapeHtml(opt_data.title) + '</h2>' : '') + '<p class="helptip-body">' + soy.$$filterNoAutoescape(opt_data.bodyHtml) + '</p>' + ((opt_data.url) ? '<p><a class="helptip-link" href="' + soy.$$escapeHtml(opt_data.url) + '" target="_blank">' + ((opt_data.linkText) ? soy.$$escapeHtml(opt_data.linkText) : soy.$$escapeHtml("Learn more")) + '</a></p>' : '') + AJS.Templates.HelpTip.tipFooter(opt_data);
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.tipContent.soyTemplateName = 'AJS.Templates.HelpTip.tipContent';
}


AJS.Templates.HelpTip.tipFooter = function(opt_data, opt_ignored) {
  return '<form class="tip-footer">' + AJS.Templates.HelpTip.nextButton(opt_data) + AJS.Templates.HelpTip.closeButton(opt_data) + AJS.Templates.HelpTip.sequencePaging(opt_data) + '</form>';
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.tipFooter.soyTemplateName = 'AJS.Templates.HelpTip.tipFooter';
}


AJS.Templates.HelpTip.nextButton = function(opt_data, opt_ignored) {
  return '' + ((opt_data.showNextButton) ? '<button class="aui-button helptip-next" type="button">' + ((opt_data.nextButtonText) ? soy.$$escapeHtml(opt_data.nextButtonText) : soy.$$escapeHtml("Next")) + '</button>' : '');
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.nextButton.soyTemplateName = 'AJS.Templates.HelpTip.nextButton';
}


AJS.Templates.HelpTip.closeButton = function(opt_data, opt_ignored) {
  return '' + ((opt_data.showCloseButton) ? '<button class="aui-button ' + ((opt_data.showNextButton) ? ' aui-button-link ' : '') + ' helptip-close" type="button">' + ((opt_data.closeButtonText) ? soy.$$escapeHtml(opt_data.closeButtonText) : soy.$$escapeHtml("Close")) + '</button>' : '');
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.closeButton.soyTemplateName = 'AJS.Templates.HelpTip.closeButton';
}


AJS.Templates.HelpTip.sequencePaging = function(opt_data, opt_ignored) {
  return '' + ((opt_data.isSequence && opt_data.length > 1) ? '<span class="helptip-sequence-paging">' + soy.$$escapeHtml(opt_data.position + 1) + '/' + soy.$$escapeHtml(opt_data.length) + '</span>' : '');
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.sequencePaging.soyTemplateName = 'AJS.Templates.HelpTip.sequencePaging';
}
;
;
/* module-key = 'jira.webresources:version-blocks', location = '/includes/jira/versionblocks/VersionBlocks.js' */
JIRA.VersionBlocks = {};
JIRA.VersionBlocks.ClassNames = {
    VERSION_LIST: "versions-list",
    VERSION_CONTAINER: "version-block-container",
    EXPANDED_CONTENT_CONTAINER: "version-issue-table"
};
JIRA.VersionBlocks.init = (function () {
    var classNames = JIRA.VersionBlocks.ClassNames;
    var dataElement = AJS.$("."+classNames.VERSION_LIST).first();
    var urlEndpoint = getUrl();

    AJS.$(document).on("click", "a[data-version-block]", function(e) {
        var $a = AJS.$(this),
                $root = $a.closest("."+classNames.VERSION_CONTAINER);
        var isActive = $root.data("expanded");
        var $container = $root.find("."+classNames.EXPANDED_CONTENT_CONTAINER);
        var $spinner = AJS.$("<span class='icon loading'></span>");

        if (!$container.size()) {
            $container = AJS.$("<div/>").addClass(classNames.EXPANDED_CONTENT_CONTAINER).hide().appendTo($root);
        }

        // Tell the server about the state we want this version to be in now
        var extraParams = {};
        extraParams[(isActive) ? "collapseVersion" : "expandVersion"] = $root.find('[data-version-id]').data("version-id");

        // Make our request for data
        var request = AJS.$.ajax({
            url: urlEndpoint,
            data: getUrlParams(extraParams),
            dataType: "json",
            beforeSend: function() {
                $a.closest("ul").append(AJS.$("<li/>").append($spinner));
            }
        });

        request.always(function() {
            $spinner.parent("li").remove();
        });

        // Handle any errors in transmission or translation
        request.fail(function(jqXHR, textStatus, errorThrown) {
            console.log("Failed to load issues for version. User-facing error to do, sorry :(", arguments);
        });

        // Update our DOM with the result of the toggle
        if (!isActive) {
            request.done(function(data, textStatus, jqXHR) {
                var html = AJS.$("<div/>").html(data.content);
                var content = html.find("."+classNames.EXPANDED_CONTENT_CONTAINER);
                $container.hide().replaceWith(content).show();
            });
        } else {
            request.done(function() {
                $container.hide();
            });
        }

        // Toggle our state
        request.done(function() {
            $root.data("expanded", !isActive);
        });

        e.preventDefault();
    });

    /**
     * The URL we need to hit to get the list of issues we want, sans parameters.
     * Ideally this would be a REST endpoint and it'd return an array of issues.
     * Unfortunately I'm stuck with hitting a crappy overloaded URL that gets its
     * data crappily and renders crappy markup.
     * @private
     */
    function getUrl() {
        var href;
        href = document.location.href;
        href = href.replace(document.location.hash,"");
        href = href.replace(document.location.search,"");

        return href;
    }

    function getUrlParams(opts) {
        var params = {
            decorator: "none",
            contentOnly: true,
            noTitle: true,
            selectedTab: getSelectedTab(),
            pid: dataElement.data("project-id"),
            component: dataElement.data("component-id")
        };

        return jQuery.extend(params, opts);
    }

    function getSelectedTab() {
        var selectedTab = dataElement.data("selected-tab");
        var paramString = "" + document.location.search + document.location.hash;
        if (paramString.indexOf("selectedTab=") > -1) {
            selectedTab = paramString.replace(/^.*selectedTab=(.*?)(?:&.*$|$)/, "$1"); // a regex-ish substringer -- basically, discard everything before and after the value of the selectedTab param.
            selectedTab = decodeURIComponent(selectedTab);
        }
        return selectedTab;
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/lib/backbone.queryparams.js' */
/*! THIS FILE HAS BEEN MODIFIED BY ATLASSIAN, SEE https://github.com/jhudson8/backbone-query-parameters/pull/63/files */
(function (root, factory) {
   if (typeof exports === 'object' && root.require) {
     module.exports = factory(require("underscore"), require("backbone"));
   } else if (typeof define === "function" && define.amd) {
      // AMD. Register as an anonymous module.
      define(["underscore","backbone"], function(_, Backbone) {
        // Use global variables if the locals are undefined.
        return factory(_ || root._, Backbone || root.Backbone);
      });
   } else {
      // RequireJS isn't being used. Assume underscore and backbone are loaded in <script> tags
      factory(_, Backbone);
   }
}(this, function(_, Backbone) {

var queryStringParam = /^\?(.*)/,
    optionalParam = /\((.*?)\)/g,
    namedParam    = /(\(\?)?:\w+/g,
    splatParam    = /\*\w+/g,
    escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g,
    fragmentStrip = /^([^\?]*)/,
    namesPattern = /[\:\*]([^\:\?\/]+)/g,
    routeStripper = /^[#\/]|\s+$/g,
    trailingSlash = /\/$/;
Backbone.Router.arrayValueSplit = '|';

var _getFragment = function(fragment, forcePushState) {
  if (fragment == null) {
    if (this._hasPushState || !this._wantsHashChange || forcePushState) {
      fragment = this.location.pathname;
      var root = this.root.replace(trailingSlash, '');
      var search = this.location.search;
      if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
      if (search) fragment += search;
    } else {
      fragment = this.getHash();
    }
  }
  return fragment.replace(routeStripper, '');
};

function proxy(source, proxy, name) {
  _.each(Array.prototype.slice.call(arguments, 2), function (name) {
    Object.defineProperty(proxy, name, {
      get: function () { return source[name]; },
      set: function (value) { source[name] = value; }
    });
  });
}

proxy.isSupported = (function () {
  try {
    Object.defineProperty({}, 'x', {})
    return true;
  } catch (e) {
    return false;
  }
})();

function LocationRewriter(history) {
  var original = history.location,
      replacement = {};

  proxy(original, replacement, "assign", "ancestorOrigins",
      "origin", "hash", "search", "pathname", "port", "hostname", "host",
      "protocol", "href", "reload");

  replacement.replace = function() {
    original.replace(history.root + '#' + history.fragment);
  };

  replacement.unPatch = function() {
    return history.location = original;
  };

  history.location = replacement;
}

function HistoryRewriter(history) {
  var original = history.history,
      replacement = {};

  proxy(original, replacement, "length", "state", "back", "forward", "go",
      "pushState");

  replacement.replaceState = function(state, title, url) {
    url = history.root + history.fragment;
    return original.replaceState(state, title, url);
  };

  replacement.unPatch = function () {
    history.history = original;
  };

  history.history = replacement;
}

var _start = Backbone.History.prototype.start,
    _loadUrl = Backbone.History.prototype.loadUrl;

_.extend(Backbone.History.prototype, {
  getFragment: _getFragment,

  // this will not perform custom query param serialization specific to the router
  // but will return a map of key/value pairs (the value is a string or array)
  getQueryParameters: function(fragment, forcePushState) {
    fragment = _getFragment.apply(this, arguments);
    // if no query string exists, this will still be the original fragment
    var queryString = fragment.replace(fragmentStrip, '');
    var match = queryString.match(queryStringParam);
    if (match) {
      queryString = match[1];
      var rtn = {};
      iterateQueryString(queryString, function(name, value) {
        // decodeURIComponent doesn't touch '+'
        value = value.replace(/\+/g, '%20');
        value = decodeURIComponent(value);
        if (!rtn[name]) {
          rtn[name] = value;
        } else if (_.isString(rtn[name])) {
          rtn[name] = [rtn[name], value];
        } else {
          rtn[name].push(value);
        }
      });
      return rtn;
    } else {
      // no values
      return {};
    }
  },

  start: function() {
    if (proxy.isSupported) {
      LocationRewriter(this);
      HistoryRewriter(this);
    }
    try {
      return _start.apply(this, arguments);
    } finally {
      this.location.unPatch && this.location.unPatch();
      this.history.unPatch && this.history.unPatch();
    }
  },

  loadUrl: function () {
    this.location && this.location.unPatch && this.location.unPatch();
    this.history && this.history.unPatch && this.history.unPatch();
    return _loadUrl.apply(this, arguments);
  }
});

_.extend(Backbone.Router.prototype, {
  initialize: function(options) {
    this.encodedSplatParts = options && options.encodedSplatParts;
  },

  getFragment: _getFragment,

  _routeToRegExp: function(route) {
    var splatMatch = (splatParam.exec(route) || {index: -1}),
        namedMatch = (namedParam.exec(route) || {index: -1}),
        paramNames = route.match(namesPattern) || [];

    route = route.replace(escapeRegExp, '\\$&')
                 .replace(optionalParam, '(?:$1)?')
                 .replace(namedParam, function(match, optional){
                   return optional ? match : '([^\\/\\?]+)';
                 })
                 // `[^??]` is hacking around a regular expression bug under iOS4.
                 // If only `[^?]` is used then paths like signin/photos will fail
                 // while paths with `?` anywhere, like `signin/photos?`, will succeed.
                 .replace(splatParam, '([^??]*?)');
    route += '(\\?.*)?';
    var rtn = new RegExp('^' + route + '$');

    // use the rtn value to hold some parameter data
    if (splatMatch.index >= 0) {
      // there is a splat
      if (namedMatch >= 0) {
        // negative value will indicate there is a splat match before any named matches
        rtn.splatMatch = splatMatch.index - namedMatch.index;
      } else {
        rtn.splatMatch = -1;
      }
    }
    rtn.paramNames = _.map(paramNames, function(name) { return name.substring(1); });
    rtn.namedParameters = this.namedParameters;

    return rtn;
  },

  /**
   * Given a route, and a URL fragment that it matches, return the array of
   * extracted parameters.
   */
  _extractParameters: function(route, fragment) {
    var params = route.exec(fragment).slice(1),
        namedParams = {};
    if (params.length > 0 && _.isUndefined(params[params.length - 1])) {
    	// remove potential invalid data from query params match
    	params.splice(params.length - 1, 1);
    }

    // do we have an additional query string?
    var match = params.length && params[params.length-1] && params[params.length-1].match(queryStringParam);
    if (match) {
      var queryString = match[1];
      var data = {};
      if (queryString) {
        var self = this;
        iterateQueryString(queryString, function(name, value) {
          self._setParamValue(name, value, data);
        });
      }
      params[params.length-1] = data;
      _.extend(namedParams, data);
    }

    // decode params
    var length = params.length;
    if (route.splatMatch && this.encodedSplatParts) {
      if (route.splatMatch < 0) {
        // splat param is first
        return params;
      } else {
        length = length - 1;
      }
    }

    for (var i=0; i<length; i++) {
      if (_.isString(params[i])) {
        params[i] = decodeURIComponent(params[i]);
        if (route.paramNames && route.paramNames.length >= i-1) {
          namedParams[route.paramNames[i]] = params[i];
        }
      }
    }

    return (Backbone.Router.namedParameters || route.namedParameters) ? [namedParams] : params;
  },

  /**
   * Set the parameter value on the data hash
   */
  _setParamValue: function(key, value, data) {
    // use '.' to define hash separators
    key = key.replace('[]', '');
    var parts = key.split('.');
    var _data = data;
    for (var i=0; i<parts.length; i++) {
      var part = parts[i];
      if (i === parts.length-1) {
        // set the value
        _data[part] = this._decodeParamValue(value, _data[part]);
      } else {
        _data = _data[part] = _data[part] || {};
      }
    }
  },

  /**
   * Decode an individual parameter value (or list of values)
   * @param value the complete value
   * @param currentValue the currently known value (or list of values)
   */
  _decodeParamValue: function(value, currentValue) {
    // decodeURIComponent doesn't translate '+'
    value = value.replace(/\+/g, '%20');

    // '|' will indicate an array.  Array with 1 value is a=|b - multiple values can be a=b|c
    var splitChar = Backbone.Router.arrayValueSplit;
    if (splitChar && value.indexOf(splitChar) >= 0) {
      var values = value.split(splitChar);
      // clean it up
      for (var i=values.length-1; i>=0; i--) {
        if (!values[i]) {
          values.splice(i, 1);
        } else {
          values[i] = decodeURIComponent(values[i]);
        }
      }
      return values;
    }
    value = decodeURIComponent(value);
    if (!currentValue) {
      return value;
    } else if (_.isArray(currentValue)) {
      currentValue.push(value);
      return currentValue;
    } else {
      return [currentValue, value];
    }
  },

  /**
   * Return the route fragment with queryParameters serialized to query parameter string
   */
  toFragment: function(route, queryParameters) {
    if (queryParameters) {
      if (!_.isString(queryParameters)) {
        queryParameters = this._toQueryString(queryParameters);
      }
      if(queryParameters) {
        route += '?' + queryParameters;
      }
    }
    return route;
  },

  /**
   * Serialize the val hash to query parameters and return it.  Use the namePrefix to prefix all param names (for recursion)
   */
  _toQueryString: function(val, namePrefix) {
    var splitChar = Backbone.Router.arrayValueSplit;
    function encodeSplit(val) { return String(val).replace(splitChar, encodeURIComponent(splitChar)); }

    if (!val) return '';
    namePrefix = namePrefix || '';
    var rtn = '';
    for (var name in val) {
      var _val = val[name];
      if (_.isString(_val) || _.isNumber(_val) || _.isBoolean(_val) || _.isDate(_val)) {
        // primitive type
        _val = this._toQueryParam(_val);
        if (_.isBoolean(_val) || _.isNumber(_val) || _.isString(_val) || _val) {
          rtn += (rtn ? '&' : '') + this._toQueryParamName(name, namePrefix) + '=' + encodeSplit(encodeURIComponent(_val));
        }
      } else if (_.isArray(_val)) {
        // arrays use Backbone.Router.arrayValueSplit separator
        var str = '';
        for (var i = 0; i < _val.length; i++) {
          var param = this._toQueryParam(_val[i]);
          if (_.isBoolean(param) || param !== null) {
            str += splitChar + encodeSplit(param);
          }
        }
        if (str) {
          rtn += (rtn ? '&' : '') + this._toQueryParamName(name, namePrefix) + '=' + str;
        }
      } else {
        // dig into hash
        var result = this._toQueryString(_val, this._toQueryParamName(name, namePrefix, true));
        if (result) {
          rtn += (rtn ? '&' : '') + result;
        }
      }
    }
    return rtn;
  },

  /**
   * return the actual parameter name
   * @param name the parameter name
   * @param namePrefix the prefix to the name
   * @param createPrefix true if we're creating a name prefix, false if we're creating the name
   */
  _toQueryParamName: function(name, prefix, isPrefix) {
    return (prefix + name + (isPrefix ? '.' : ''));
  },

  /**
   * Return the string representation of the param used for the query string
   */
  _toQueryParam: function (param) {
    if (_.isNull(param) || _.isUndefined(param)) {
      return null;
    }
    return param;
  }
});

function iterateQueryString(queryString, callback) {
  var keyValues = queryString.split('&');
  _.each(keyValues, function(keyValue) {
    var arr = keyValue.split('=');
    callback(arr.shift(), arr.join('='));
  });
}

}));
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/components/TabLoader/entities/TabModel.js' */
AJS.namespace("JIRA.Projects");

JIRA.Projects.TabModel = Backbone.Model.extend({

    parse: function (data) {
        return {
            html: data || ""
        };
    },

    url: function () {
        return this._url + "&decorator=none&contentOnly=true";
    },

    newTabRequested: function (tabUrl) {
        var model = this,
            oldUrl = this._url;
        this._url = tabUrl;
        this.fetch({
            dataType: "text",
            statusCode: {
                // Need to do this instead of passing in a 'success' handler
                // because we don't get access to the request object otherwise
                200: function(body, statusText, request) {
                    if (request.getResponseHeader('X-Atlassian-Dialog-Control') === 'permissionviolation') {
                        // We've been logged out
                        model.trigger("switch-error", { loggedOut: true }, tabUrl);
                    } else {
                        model.trigger("switch", tabUrl);
                    }
                }
            },
            error: function (model, response) {
                model._url = oldUrl;
                model.trigger("switch-error", response, tabUrl);
            }
        });
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/components/TabLoader/views/TabView.js' */
AJS.namespace("JIRA.Projects");

JIRA.Projects.TabView = Backbone.View.extend({
    initialize: function () {
        var model = this.model;
        this.$stage = this.$el.find("#project-tab");
        this.$sidebarLinks = this.$el.find(".aui-page-panel-nav a");

        this.listenTo(model, 'switch', this.render);

        this.$sidebarLinks.click(function (e) {
            model.newTabRequested(AJS.$(this).attr('href'));
            e.preventDefault();
        });
    },

    render: function () {
        this.$stage.html(this.model.get("html"));
        this.updateTabSelection();
        JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [this.$stage, JIRA.CONTENT_ADDED_REASON.tabUpdated]);
    },

    updateTabSelection: function () {
        var tabFrom = JIRA.Projects.Util.extractSelectedTab;
        var newTab = tabFrom(this.model._url);

        this.$sidebarLinks.parent().removeClass("active");
        var $linkForNewTab = this.$sidebarLinks.filter(function () {
            return tabFrom(AJS.$(this).attr('href')) === newTab;
        });

        $linkForNewTab.parent().addClass("active");
    }
});

;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/components/TabLoader/services/TabPanelRouter.js' */
AJS.namespace("JIRA.Projects");

JIRA.Projects.TabPanelRouter = Backbone.Router.extend({

    /**
     *
     * @param {JIRA.Projects.TabModel} tabModel
     * @param location the window.location object
     */
    initialize: function(tabModel, location) {
        this.route(/[&?]selectedTab=(.*)(&|$)/, 'loadTab');
        this.tabModel = tabModel;
        this.location = location;
    },

    /**
     *
     * @param tabKey the key of the tab to be loaded
     */
    loadTab: function (tabKey) {
        var OLD_PLUGIN_KEY = "com.atlassian.jira.plugin.system.project",
            NEW_PLUGIN_KEY = "com.atlassian.jira.jira-projects-plugin";

        //redirect to load the correct tab panel in case users have bookmarked the old browse project pages.
        tabKey = tabKey.replace(OLD_PLUGIN_KEY, NEW_PLUGIN_KEY);
        this.tabModel.newTabRequested(this.location.pathname + JIRA.Projects.Util.setSelectedTab(this.location.search, tabKey));
    }

});;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/components/TabLoader/main.js' */
AJS.namespace("JIRA.Projects");

JIRA.Projects.TabLoader = {

    init: function ($el, history, location, pushState) {

        var tab = new JIRA.Projects.TabModel();

        tab.on("switch", function (url) {
            var newTabKey = JIRA.Projects.Util.extractSelectedTab(url);
            var newTabQueryString = JIRA.Projects.Util.setSelectedTab(location.href, newTabKey);
            history.navigate(newTabQueryString, false);
        });

        tab.on("switch-error", function (response, target) {
            var msg = JIRA.Messages.showErrorMsg;

            if (response.loggedOut) {
                var login = AJS.contextPath() + "/login.jsp?permissionViolation=true&os_destination=" + target;
                return location.replace(login);
            } else if (response.statusText === "timeout") {
                msg(JIRA.Projects.ErrorMessages.timeout());
            } else if (response.status === 404) {
                msg(JIRA.Projects.ErrorMessages.notFound());
            } else {
                msg(JIRA.Projects.ErrorMessages.genericError());
            }
        });

        new JIRA.Projects.TabView({
            model: tab,
            el: $el
        });

        new JIRA.Projects.TabPanelRouter(tab, location);
        var hasFragment = location.href.indexOf("#") > -1;

        history.start({
            pushState: pushState,
            hashChange: !pushState,
            silent: !hasFragment,
            root: location.pathname
        });

        // Put the tab selection into the url if it isn't there already, so we can get back to it with the 'Back' button
        // We need to update the url if there is no selected tab in the url, or we don't have push state and there's no fragment
        if (!JIRA.Projects.Util.extractSelectedTab(location.href) || !(hasFragment || pushState)) {
            var tabHref = $el.find(".aui-page-panel-nav li.active > a.browse-tab").attr("href");
            var newTab = JIRA.Projects.Util.extractSelectedTab(tabHref);
            var newTabQueryString = JIRA.Projects.Util.setSelectedTab(location.href, newTab);
            history.navigate(newTabQueryString, {trigger: false, replace: true});
        }
    }
};
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/util/selectedTab.js' */
AJS.namespace("JIRA.Projects.Util");

(function () {
    var queryStringFrom = function (url) {
        return url.split('?')[1] || '';
    };

    var accumulateQueryParameter = function(parsedQuery, keyAndValueString) {
        var keyAndValue = keyAndValueString.split('=');
        parsedQuery[keyAndValue[0]] = keyAndValue[1];
        return parsedQuery;
    };

    var queryStringToObject = function (url) {
        var queryStringKeyAndValues = _.compact(queryStringFrom(url).split('&'));
        return _(queryStringKeyAndValues).reduce(accumulateQueryParameter, {});
    };

    /**
     * Transforms the provided url to point to the new selected tab.
     *
     * @param {string} url
     * @return the id of the selected tab from the url's query string, or null if there is none in the query string
     */
    JIRA.Projects.Util.extractSelectedTab = function (url) {
        return queryStringToObject(url).selectedTab || null;
    };

    /**
     * @param {string} url
     * @param {JIRA.Projects.TabModel} selectedTabValue
     * @return string url pointing to the selected tab value specified, with other parameters left intact
     */
    JIRA.Projects.Util.setSelectedTab = function (url, selectedTabValue) {
        var query = queryStringToObject(url);
        query.selectedTab = selectedTabValue;
        return '?' + decodeURIComponent(AJS.$.param(query));
    };
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/util/errorMessages.js' */
AJS.namespace("JIRA.Projects");

JIRA.Projects.ErrorMessages = {
    notFound: function () {
        return "The requested project tab could not be found for display.";
    },
    genericError: function () {
        return "The JIRA server was contacted but has returned an error response. We are unsure of the result of this operation.";
    },
    timeout : function () {
        return "The connection timed out while trying to load the requested tab.";
    }
};
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject-init', location = '/static/page/initTabLoader.js' */
AJS.$(function($) {
    if (!AJS.$(".aui-sidebar").length) {
        JIRA.Projects.TabLoader.init($(".aui-page-panel"), Backbone.history, window.location, window.history.pushState);
    }
});
;
;
/* module-key = 'jira.webresources:field-templates', location = '/includes/jira/field/templates/singleUserPicker.soy' */
// This file was automatically generated from singleUserPicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Fields.Pickers.User.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Fields == 'undefined') { JIRA.Templates.Fields = {}; }
if (typeof JIRA.Templates.Fields.Pickers == 'undefined') { JIRA.Templates.Fields.Pickers = {}; }
if (typeof JIRA.Templates.Fields.Pickers.User == 'undefined') { JIRA.Templates.Fields.Pickers.User = {}; }


JIRA.Templates.Fields.Pickers.User.single = function(opt_data, opt_ignored) {
  var output = '<select id="' + soy.$$escapeHtml(opt_data.field.id) + '" name="' + soy.$$escapeHtml(opt_data.field.name) + '" class="single-user-picker js-' + ((opt_data.type) ? soy.$$escapeHtml(opt_data.type) : 'default-user-picker') + '"' + ((opt_data.inputText) ? ' data-input-text="' + soy.$$escapeHtml(opt_data.inputText) + '"' : '') + ((opt_data.editValue) ? ' data-edit-value="' + soy.$$escapeHtml(opt_data.editValue) + '"' : '') + ((opt_data.showDropdownButton) ? ' data-show-dropdown-button="true"' : '') + ((opt_data.userType) ? ' data-user-type="' + soy.$$escapeHtml(opt_data.userType) + '"' : '') + ((opt_data.containerClass) ? ' data-container-class="' + soy.$$escapeHtml(opt_data.containerClass) + '"' : '') + '>';
  var optionList38 = opt_data.options;
  var optionListLen38 = optionList38.length;
  for (var optionIndex38 = 0; optionIndex38 < optionListLen38; optionIndex38++) {
    var optionData38 = optionList38[optionIndex38];
    if (optionData38.optionGroup) {
      output += '<optgroup id="' + soy.$$escapeHtml(opt_data.field.id) + '-group-' + soy.$$escapeHtml(optionData38.id) + '" label="' + soy.$$escapeHtml(optionData38.display) + '"' + ((optionData38.footer) ? ' data-footer-text="' + soy.$$escapeHtml(optionData38.footer) + '"' : '') + ((optionData38.weight != -1) ? ' data-weight="' + soy.$$escapeHtml(optionData38.weight) + '"' : '') + '>';
      var groupOptionList59 = optionData38.groupOptions;
      var groupOptionListLen59 = groupOptionList59.length;
      for (var groupOptionIndex59 = 0; groupOptionIndex59 < groupOptionListLen59; groupOptionIndex59++) {
        var groupOptionData59 = groupOptionList59[groupOptionIndex59];
        output += JIRA.Templates.Fields.Pickers.User.option(groupOptionData59);
      }
      output += '</optgroup>';
    } else {
      output += JIRA.Templates.Fields.Pickers.User.option(optionData38);
    }
  }
  output += '</select>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.Pickers.User.single.soyTemplateName = 'JIRA.Templates.Fields.Pickers.User.single';
}


JIRA.Templates.Fields.Pickers.User.option = function(opt_data, opt_ignored) {
  return '<option ' + ((opt_data.loggedInUser) ? 'class="current-user" ' : '') + ((opt_data.selected) ? 'selected="selected" ' : '') + 'value="' + soy.$$escapeHtml(opt_data.optionName) + '" data-field-text="' + soy.$$escapeHtml(opt_data.displayName) + '" data-field-label="' + soy.$$escapeHtml(opt_data.displayName) + ((opt_data.emailAddress) ? ' - ' + soy.$$escapeHtml(opt_data.emailAddress) : '') + ((opt_data.optionName && opt_data.optionName != '-1') ? ' (' + soy.$$escapeHtml(opt_data.optionName) + ')' : '') + '" data-icon="' + soy.$$escapeHtml(opt_data.avatarURL) + '" >' + soy.$$escapeHtml(opt_data.displayName) + '</option>';
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.Pickers.User.option.soyTemplateName = 'JIRA.Templates.Fields.Pickers.User.option';
}
;
;
/* module-key = 'jira.webresources:field-templates', location = '/includes/jira/field/templates/assigneeField.soy' */
// This file was automatically generated from assigneeField.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Fields.Pickers.User.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Fields == 'undefined') { JIRA.Templates.Fields = {}; }
if (typeof JIRA.Templates.Fields.Pickers == 'undefined') { JIRA.Templates.Fields.Pickers = {}; }
if (typeof JIRA.Templates.Fields.Pickers.User == 'undefined') { JIRA.Templates.Fields.Pickers.User = {}; }


JIRA.Templates.Fields.Pickers.User.assignee = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.Fields.Pickers.User.single(soy.$$augmentMap(opt_data, {options: opt_data.assigneeOptions.options, showDropdownButton: true, userType: 'assignee', type: 'assignee-picker', containerClass: 'long-field'})) + ((opt_data.isLoggedInUserAssignable) ? '<a href="#' + soy.$$escapeHtml(opt_data.field.id) + '" id="assign-to-me-trigger">' + soy.$$escapeHtml("Assign to me") + '</a>' : '') + '<fieldset class="hidden parameters"><input type="hidden" title="projectKeys" value="' + soy.$$escapeHtml(opt_data.projectKeys) + '"/>' + ((opt_data.issueKey) ? '<input type="hidden" title="assigneeEditIssueKey" value="' + soy.$$escapeHtml(opt_data.issueKey) + '"/>' : '') + ((opt_data.actionDescriptorId) ? '<input type="hidden" title="actionDescriptorId" value="' + soy.$$escapeHtml(opt_data.actionDescriptorId) + '"/>' : '') + '</fieldset>';
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.Pickers.User.assignee.soyTemplateName = 'JIRA.Templates.Fields.Pickers.User.assignee';
}
;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/userPickerUtil.js' */
(function ($) {

    JIRA.UserPickerUtil = {

        formatResponse: function (data) {

            var ret = [];

            $(data).each(function(i, suggestions) {

                var groupDescriptor = new AJS.GroupDescriptor({
                    weight: i, // order or groups in suggestions dropdown
                    label: suggestions.footer
                });

                $(suggestions.users).each(function(){
                    groupDescriptor.addItem(new AJS.ItemDescriptor({
                        value: this.name, // value of item added to select
                        label: this.displayName, // title of lozenge
                        html: this.html,
                        icon: this.avatarUrl,
                        allowDuplicate: false,
                        highlighted: true
                    }));
                });
                ret.push(groupDescriptor);
            });
            return ret;
        }

    };

})(AJS.$);

;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/initSingleUserPickers.js' */
(function ($) {

    function createSingleUserPickers(ctx) {

        var restPath = "/rest/api/1.0/users/picker";

        $(".js-default-user-picker", ctx).each(function () {
            var $this = $(this);
            if ($this.data("aui-ss")) return;
            var data = {showAvatar: true},
                inputText = $this.data('inputValue');

            new AJS.SingleSelect({
                element: $this,
                submitInputVal: true,
                showDropdownButton: !!$this.data('show-dropdown-button'),
                errorMessage: AJS.format("There is no user \'\'{0}\'\'.", "'{0}'"),
                ajaxOptions: {
                    url: contextPath + restPath,
                    query: true, // keep going back to the sever for each keystroke
                    data: data,
                    formatResponse: JIRA.UserPickerUtil.formatResponse
                },
                inputText: inputText
            });
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            createSingleUserPickers(context);
        }
    });

})(AJS.$);



;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/NoBrowseUserNamePicker.js' */
    /**
     * Caters for addition of users in frotherized MultiSelect inputs when the user
     * does not have the Browse User permission.
     *
     * Whilst this control could potentially give away valid usernames it is not new in this behaviour.
     * The old-style user picker used in the Edit Issue form will reveal if a particular username is invalid or not.
     * @class
     * @extends MultiSelect
     */
    AJS.NoBrowseUserNamePicker = AJS.MultiSelect.extend({

        /**
         * Use the User REST interface to attempt to get a user by username.
         */
        _getDefaultOptions: function () {
            return AJS.$.extend(true, this._super(), {
                errorMessage: "The requested user does not exist.",
                showDropdownButton: false,
                removeOnUnSelect: true,
                itemAttrDisplayed: "label"
            });
        },

        /**
         * Override to prevent requesting per keypress.
         *
         * NoBrowseUserNamePicker does not send a request per keypress.
         * Instead it will request for validity when enter or space is pressed
         * or when the field is blurred.
         */
        _handleCharacterInput: function() {
            //this.hideErrorMessage();
        },

        /**
         * Prevents the display of Suggestions for this control.
         *
         * We don't want any suggestions for the NoBrowseUserNamePicker
         * as the user using doesn't have access to see a list of users.
         * Also, using this REST enpoint will not retrieve a list of users anyway.
         */
        _setSuggestions: function() {},

        /**
         * Handles an error from the REST endpoint.
         *
         * The REST endpoint used for this operation returns a 404 if the user requested
         * does not exist. This situation is handled here.
         *
         * If any other error is returned the parent's error handler will be used.
         *
         * @param smartAjaxResult The error.
         */
        _handleServerError: function(smartAjaxResult) {
            if (smartAjaxResult.status === 404) {
                this.showErrorMessage();
            } else {
                this._super();
            }
        },

        /**
         * Called when the field is blurred.
         *
         * When the field is deactivated (i.e. blurred) we want to issue a
         * request to check if the currently entered username (if any) is valid or not.
         */
        _deactivate: function() {
            this.validateAndAdd();
        },

        /**
         * Issues a request to the User REST endpoint with the current field value.
         *
         * Hides any existing error messages before issuing a request to the User endpoint
         * to determine the validity of the current input.
         */
        validateAndAdd: function() {
            var instance = this;
            if (AJS.$.trim(this.$field.val()) === "") {
                this.hideErrorMessage();
            } else {
                jQuery.ajax({
                    url: contextPath + "/rest/api/2/user",
                    data: {
                        username: AJS.$.trim(instance.getQueryVal())
                    },
                    success: function (user) {
                        instance.hideErrorMessage();
                        instance.$field.val("");
                        instance.addItem(new AJS.ItemDescriptor({
                            label: user.displayName,
                            value: user.name
                        }));
                    },
                    error: function () {
                        instance.showErrorMessage();
                    }
                });
            }
        },

        /**
         * Sends a request to the REST endpoint using the currently entered username (if any)
         * when space is pressed.
         *
         * This allows for quick entry of usernames.
         *
         * If the username is not valid the space keypress event is prevented and an error message
         * displayed.
         */
        _handleSpace: function() {
            this.validate();
        },

        /**
         * Transforms the successfully returned username into a Lozenge.
         *
         * @param data The successfully selected username.
         */
        _handleServerSuggestions: function() {
            this.hideErrorMessage();
            this.handleFreeInput();
        },

        /**
         * Adds the current user input as a lozenge.
         *
         * By this time the input has been validated as a username.
         * If the input is not a valid username the response comes back as a
         * 404 triggering _handleServerError.
         */
        handleFreeInput: function() {
            var value = AJS.$.trim(this.$field.val());

            if (value !== "") {
                this.addItem({ value: value, label: value });
                this.model.$element.trigger("change");
            }

            this.$field.val("");
        },

        keys: {
            /**
             * Issue a request for the currently entered username when Return is pressed.
             *
             * @param event The aui:keypress event.
             */
            "Return": function(event) {
                event.preventDefault();
                this.validateAndAdd();
            },

            /**
             * Issue a request for the currently entered username when the Spacebar is pressed.
             *
             * @param event The aui:keypress event.
             */
            "Spacebar": function(event) {
                event.preventDefault();
                this.validateAndAdd();
            }
        }
    });
;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/initMultiUserPickers.js' */
(function () {

    function initMultiUserPicker(ctx) {
        ctx.find(".js-default-multi-user-picker").each(function () {
            var $el = jQuery(this);
            if (AJS.params.currentUserCanBrowseUsers) {
                new AJS.MultiSelect({
                    element: this,
                    itemAttrDisplayed: "label",
                    showDropdownButton: false,
                    removeOnUnSelect: true,
                    submitInputVal: true,
                    ajaxOptions: {
                        url: contextPath + "/rest/api/1.0/users/picker",
                        query: true, // keep going back to the sever for each keystroke
                        data: function (query) {
                            return {
                                showAvatar: true,
                                query: query,
                                exclude: $el.val()
                            };
                        },
                        formatResponse: JIRA.UserPickerUtil.formatResponse
                    }
                });
            } else {
                new AJS.NoBrowseUserNamePicker({
                    element: this
                });
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initMultiUserPicker(context);
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/lib/jquery.dotdotdot-1.5.7.js' */
/*	
 *	jQuery dotdotdot 1.5.7
 *	
 *	Copyright (c) 2013 Fred Heusschen
 *	www.frebsite.nl
 *
 *	Plugin website:
 *	dotdotdot.frebsite.nl
 *
 *	Dual licensed under the MIT and GPL licenses.
 *	http://en.wikipedia.org/wiki/MIT_License
 *	http://en.wikipedia.org/wiki/GNU_General_Public_License
 */

(function( $ )
{
	if ( $.fn.dotdotdot )
	{
		return;
	}

	$.fn.dotdotdot = function( o )
	{
		if ( this.length == 0 )
		{
			if ( !o || o.debug !== false )
			{
				debug( true, 'No element found for "' + this.selector + '".' );				
			}
			return this;
		}
		if ( this.length > 1 )
		{
			return this.each(
				function()
				{
					$(this).dotdotdot( o );
				}
			);
		}


		var $dot = this;

		if ( $dot.data( 'dotdotdot' ) )
		{
			$dot.trigger( 'destroy.dot' );
		}

		$dot.bind_events = function()
		{
			$dot.bind(
				'update.dot',
				function( e, c )
				{
					e.preventDefault();
					e.stopPropagation();

					opts.maxHeight = ( typeof opts.height == 'number' ) 
						? opts.height 
						: getTrueInnerHeight( $dot );

					opts.maxHeight += opts.tolerance;

					if ( typeof c != 'undefined' )
					{
						if ( typeof c == 'string' || c instanceof HTMLElement )
						{
					 		c = $('<div />').append( c ).contents();
						}
						if ( c instanceof $ )
						{
							orgContent = c;
						}
					}

					$inr = $dot.wrapInner( '<div class="dotdotdot" />' ).children();
					$inr.empty()
						.append( orgContent.clone( true ) )
						.css({
							'height'	: 'auto',
							'width'		: 'auto',
							'border'	: 'none',
							'padding'	: 0,
							'margin'	: 0
						});

					var after = false,
						trunc = false;

					if ( conf.afterElement )
					{
						after = conf.afterElement.clone( true );
						conf.afterElement.remove();
					}
					if ( test( $inr, opts ) )
					{
						if ( opts.wrap == 'children' )
						{
							trunc = children( $inr, opts, after );
						}
						else
						{
							trunc = ellipsis( $inr, $dot, $inr, opts, after );
						}
					}
					$inr.replaceWith( $inr.contents() );
					$inr = null;
					
					if ( $.isFunction( opts.callback ) )
					{
						opts.callback.call( $dot[ 0 ], trunc, orgContent );
					}

					conf.isTruncated = trunc;
					return trunc;
				}

			).bind(
				'isTruncated.dot',
				function( e, fn )
				{
					e.preventDefault();
					e.stopPropagation();

					if ( typeof fn == 'function' )
					{
						fn.call( $dot[ 0 ], conf.isTruncated );
					}
					return conf.isTruncated;
				}

			).bind(
				'originalContent.dot',
				function( e, fn )
				{
					e.preventDefault();
					e.stopPropagation();

					if ( typeof fn == 'function' )
					{
						fn.call( $dot[ 0 ], orgContent );
					}
					return orgContent;
				}

			).bind(
				'destroy.dot',
				function( e )
				{
					e.preventDefault();
					e.stopPropagation();

					$dot.unwatch()
						.unbind_events()
						.empty()
						.append( orgContent )
						.data( 'dotdotdot', false );
				}
			);
			return $dot;
		};	//	/bind_events

		$dot.unbind_events = function()
		{
			$dot.unbind('.dot');
			return $dot;
		};	//	/unbind_events

		$dot.watch = function()
		{
			$dot.unwatch();
			if ( opts.watch == 'window' )
			{
				var $window = $(window),
					_wWidth = $window.width(),
					_wHeight = $window.height(); 

				$window.bind(
					'resize.dot' + conf.dotId,
					function()
					{
						if ( _wWidth != $window.width() || _wHeight != $window.height() || !opts.windowResizeFix )
						{
							_wWidth = $window.width();
							_wHeight = $window.height();
	
							if ( watchInt )
							{
								clearInterval( watchInt );
							}
							watchInt = setTimeout(
								function()
								{
									$dot.trigger( 'update.dot' );
								}, 10
							);
						}
					}
				);
			}
			else
			{
				watchOrg = getSizes( $dot );
				watchInt = setInterval(
					function()
					{
						var watchNew = getSizes( $dot );
						if ( watchOrg.width  != watchNew.width ||
							 watchOrg.height != watchNew.height )
						{
							$dot.trigger( 'update.dot' );
							watchOrg = getSizes( $dot );
						}
					}, 100
				);
			}
			return $dot;
		};
		$dot.unwatch = function()
		{
			$(window).unbind( 'resize.dot' + conf.dotId );
			if ( watchInt )
			{
				clearInterval( watchInt );
			}
			return $dot;
		};

		var	orgContent	= $dot.contents(),
			opts 		= $.extend( true, {}, $.fn.dotdotdot.defaults, o ),
			conf		= {},
			watchOrg	= {},
			watchInt	= null,
			$inr		= null;

		conf.afterElement	= getElement( opts.after, $dot );
		conf.isTruncated	= false;
		conf.dotId			= dotId++;


		$dot.data( 'dotdotdot', true )
			.bind_events()
			.trigger( 'update.dot' );

		if ( opts.watch )
		{
			$dot.watch();
		}

		return $dot;
	};


	//	public
	$.fn.dotdotdot.defaults = {
		'ellipsis'	: '... ',
		'wrap'		: 'word',
		'lastCharacter': {
			'remove'		: [ ' ', ',', ';', '.', '!', '?' ],
			'noEllipsis'	: []
		},
		'tolerance'	: 0,
		'callback'	: null,
		'after'		: null,
		'height'	: null,
		'watch'		: false,
		'windowResizeFix': true,
		'debug'		: false
	};
	

	//	private
	var dotId = 1;

	function children( $elem, o, after )
	{
		var $elements 	= $elem.children(),
			isTruncated	= false;

		$elem.empty();

		for ( var a = 0, l = $elements.length; a < l; a++ )
		{
			var $e = $elements.eq( a );
			$elem.append( $e );
			if ( after )
			{
				$elem.append( after );
			}
			if ( test( $elem, o ) )
			{
				$e.remove();
				isTruncated = true;
				break;
			}
			else
			{
				if ( after )
				{
					after.remove();
				}
			}
		}
		return isTruncated;
	}
	function ellipsis( $elem, $d, $i, o, after )
	{
		var $elements 	= $elem.contents(),
			isTruncated	= false;

		$elem.empty();

		var notx = 'table, thead, tbody, tfoot, tr, col, colgroup, object, embed, param, ol, ul, dl, select, optgroup, option, textarea, script, style';
		for ( var a = 0, l = $elements.length; a < l; a++ )
		{

			if ( isTruncated )
			{
				break;
			}

			var e	= $elements[ a ],
				$e	= $(e);

			if ( typeof e == 'undefined' )
			{
				continue;
			}

			$elem.append( $e );
			if ( after )
			{
				$elem[ ( $elem.is( notx ) ) ? 'after' : 'append' ]( after );
			}
			if ( e.nodeType == 3 )
			{
				if ( test( $i, o ) )
				{
					isTruncated = ellipsisElement( $e, $d, $i, o, after );
				}
			}
			else
			{
				isTruncated = ellipsis( $e, $d, $i, o, after );
			}

			if ( !isTruncated )
			{
				if ( after )
				{
					after.remove();
				}
			}
		}
		return isTruncated;
	}
	function ellipsisElement( $e, $d, $i, o, after )
	{
		var isTruncated	= false,
			e = $e[ 0 ];

		if ( typeof e == 'undefined' )
		{
			return false;
		}

		var seporator	= ( o.wrap == 'letter' ) ? '' : ' ',
			textArr		= getTextContent( e ).split( seporator ),
			position 	= -1,
			midPos		= -1,
			startPos	= 0,
			endPos		= textArr.length - 1;

		while ( startPos <= endPos )
		{
			var m = Math.floor( ( startPos + endPos ) / 2 );
			if ( m == midPos ) 
			{
				break;
			}
			midPos = m;

			setTextContent( e, textArr.slice( 0, midPos + 1 ).join( seporator ) + o.ellipsis );

			if ( !test( $i, o ) )
			{
				position = midPos;
				startPos = midPos; 
			}
			else
			{
				endPos = midPos;
			}				
		}	
	
		if ( position != -1 && !( textArr.length == 1 && textArr[ 0 ].length == 0 ) )
		{
			var txt = addEllipsis( textArr.slice( 0, position + 1 ).join( seporator ), o );
			isTruncated = true;
			setTextContent( e, txt );
		}
		else
		{
			var $w = $e.parent();
			$e.remove();

			var afterLength = ( after ) ? after.length : 0 ;

			if ( $w.contents().size() > afterLength )
			{
				var $n = $w.contents().eq( -1 - afterLength );
				isTruncated = ellipsisElement( $n, $d, $i, o, after );
			}
			else
			{
				var e = $w.prev().contents().eq( -1 )[ 0 ];

				if ( typeof e != 'undefined' )
				{
					var txt = addEllipsis( getTextContent( e ), o );
					setTextContent( e, txt );
					$w.remove();
					isTruncated = true;
				}

			}
		}

		return isTruncated;
	}
	function test( $i, o )
	{
		return $i.innerHeight() > o.maxHeight;
	}
	function addEllipsis( txt, o )
	{
		while( $.inArray( txt.slice( -1 ), o.lastCharacter.remove ) > -1 )
		{
			txt = txt.slice( 0, -1 );
		}
		if ( $.inArray( txt.slice( -1 ), o.lastCharacter.noEllipsis ) < 0 )
		{
			txt += o.ellipsis;
		}
		return txt;
	}
	function getSizes( $d )
	{
		return {
			'width'	: $d.innerWidth(),
			'height': $d.innerHeight()
		};
	}
	function setTextContent( e, content )
	{
		if ( e.innerText )
		{
			e.innerText = content;
		}
		else if ( e.nodeValue )
		{
			e.nodeValue = content;
		}
		else if (e.textContent)
		{
			e.textContent = content;
		}

	}
	function getTextContent( e )
	{
		if ( e.innerText )
		{
			return e.innerText;
		}
		else if ( e.nodeValue )
		{
			return e.nodeValue;
		}
		else if ( e.textContent )
		{
			return e.textContent;
		}
		else
		{
			return "";
		}
	}
	function getElement( e, $i )
	{
		if ( typeof e == 'undefined' )
		{
			return false;
		}
		if ( !e )
		{
			return false;
		}
		if ( typeof e == 'string' )
		{
			e = $(e, $i);
			return ( e.length )
				? e 
				: false;
		}
		if ( typeof e == 'object' )
		{
			return ( typeof e.jquery == 'undefined' )
				? false
				: e;
		}
		return false;
	}
	function getTrueInnerHeight( $el )
	{
		var h = $el.innerHeight(),
			a = [ 'paddingTop', 'paddingBottom' ];

		for ( var z = 0, l = a.length; z < l; z++ ) {
			var m = parseInt( $el.css( a[ z ] ), 10 );
			if ( isNaN( m ) )
			{
				m = 0;
			}
			h -= m;
		}
		return h;
	}
	function debug( d, m )
	{
		if ( !d )
		{
			return false;
		}
		if ( typeof m == 'string' )
		{
			m = 'dotdotdot: ' + m;
		}
		else
		{
			m = [ 'dotdotdot:', m ];
		}

		if ( typeof window.console != 'undefined' )
		{
			if ( typeof window.console.log != 'undefined' )
			{
				window.console.log( m );
			}
		}
		return false;
	}
	

	//	override jQuery.html
	var _orgHtml = $.fn.html;
    $.fn.html = function( str ) {
		if ( typeof str != 'undefined' )
		{
			if ( this.data( 'dotdotdot' ) )
			{
				if ( typeof str != 'function' )
				{
					return this.trigger( 'update', [ str ] );
				}
			}
			return _orgHtml.call( this, str );
		}
		return _orgHtml.call( this );
    };


	//	override jQuery.text
	var _orgText = $.fn.text;
    $.fn.text = function( str ) {
		if ( typeof str != 'undefined' )
		{
			if ( this.data( 'dotdotdot' ) )
			{
				var temp = $( '<div />' );
				temp.text( str );
				str = temp.html();
				temp.remove();
				return this.trigger( 'update', [ str ] );
			}
			return _orgText.call( this, str );
		}
        return _orgText.call( this );
    };


})( require('jquery') );
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/soy/ProjectTemplatesList.soy' */
// This file was automatically generated from ProjectTemplatesList.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }


JIRA.Templates.ProjectTemplates.renderProjectTemplates = function(opt_data, opt_ignored) {
  return '' + ((soy.$$getMapKeys(opt_data.projectTemplates).length == 0) ? JIRA.Templates.errorMsg({closeable: false, msg: "No project templates could be found."}) : JIRA.Templates.ProjectTemplates.renderTemplates(opt_data));
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderProjectTemplates.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderProjectTemplates';
}


JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.projectTemplatesByType.length == 0) {
    output += JIRA.Templates.errorMsg({closeable: false, msg: "No project templates could be found."});
  } else {
    var projectTypeTemplatesGroupList18 = opt_data.projectTemplatesByType;
    var projectTypeTemplatesGroupListLen18 = projectTypeTemplatesGroupList18.length;
    for (var projectTypeTemplatesGroupIndex18 = 0; projectTypeTemplatesGroupIndex18 < projectTypeTemplatesGroupListLen18; projectTypeTemplatesGroupIndex18++) {
      var projectTypeTemplatesGroupData18 = projectTypeTemplatesGroupList18[projectTypeTemplatesGroupIndex18];
      output += '<div class="template-group" id="project-template-group-' + soy.$$escapeHtml(projectTypeTemplatesGroupData18.projectTypeBean.projectTypeKey) + '"><div class="template-group-header"><h6><img class="project-type-icon" src="data:image/svg+xml;base64, ' + soy.$$escapeHtml(projectTypeTemplatesGroupData18.projectTypeBean.icon) + ' "/><span>' + soy.$$escapeHtml(projectTypeTemplatesGroupData18.projectTypeBean.projectTypeDisplayKey) + '</span></h6></div>' + JIRA.Templates.ProjectTemplates.renderTemplates({projectTemplates: projectTypeTemplatesGroupData18.projectTemplates}) + '</div>';
    }
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType';
}


JIRA.Templates.ProjectTemplates.renderTemplates = function(opt_data, opt_ignored) {
  return '<div class="pt-templates-list">' + JIRA.Templates.ProjectTemplates.renderItems(opt_data) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderTemplates.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderTemplates';
}


JIRA.Templates.ProjectTemplates.renderItems = function(opt_data, opt_ignored) {
  var output = '<ol class="templates" tabindex="100">';
  var templateList37 = opt_data.projectTemplates;
  var templateListLen37 = templateList37.length;
  for (var templateIndex37 = 0; templateIndex37 < templateListLen37; templateIndex37++) {
    var templateData37 = templateList37[templateIndex37];
    output += '<li class="template"' + ((templateData37.itemModuleCompleteKey) ? 'data-item-module-complete-key="' + soy.$$escapeHtml(templateData37.itemModuleCompleteKey) + '"' : '') + ((templateData37.projectTemplateModuleCompleteKey) ? 'data-project-template-module-complete-key="' + soy.$$escapeHtml(templateData37.projectTemplateModuleCompleteKey) + '"' : '') + ((templateData37.createProject) ? 'data-create-project="' + soy.$$escapeHtml(templateData37.createProject) + '"' : '') + ((templateData37.demoProject) ? 'data-demo-project="' + soy.$$escapeHtml(templateData37.demoProject) + '"' : '') + ((templateData37.backgroundIconUrl) ? 'data-background-icon-url="' + soy.$$escapeHtml(templateData37.backgroundIconUrl) + '"' : '') + ((templateData37.name) ? 'data-name="' + soy.$$escapeHtml(templateData37.name) + '"' : '') + ((templateData37.description) ? 'data-description="' + soy.$$escapeHtml(templateData37.description) + '"' : '') + ((templateData37.longDescriptionContent) ? 'data-long-description-content="' + soy.$$escapeHtml(templateData37.longDescriptionContent) + '"' : '') + ((templateData37.infoSoyPath) ? 'data-info-soy-path="' + soy.$$escapeHtml(templateData37.infoSoyPath) + '"' : '') + '><img class="template-preview" src="' + soy.$$escapeHtml(templateData37.iconUrl) + '" /><div class="template-meta"><div class="template-name" title="' + soy.$$escapeHtml(templateData37.name) + '">' + soy.$$escapeHtml(templateData37.name) + '</div><div class="template-description" title="' + soy.$$escapeHtml(templateData37.description) + '">' + soy.$$escapeHtml(templateData37.description) + '</div></div></li>';
  }
  output += '</ol>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderItems.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderItems';
}


JIRA.Templates.ProjectTemplates.loadingTemplatesList = function(opt_data, opt_ignored) {
  return '<div class="wait-container"><img class="wait-icon" src="' + soy.$$escapeHtml("/jira") + '/images/icons/wait.gif"><span class="wait-text">' + soy.$$escapeHtml("Loading project templates") + '&hellip;</span></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.loadingTemplatesList.soyTemplateName = 'JIRA.Templates.ProjectTemplates.loadingTemplatesList';
}


JIRA.Templates.ProjectTemplates.footerLinks = function(opt_data, opt_ignored) {
  return '<div class="footer-links"><a class="import-project-trigger button-panel-link" href="' + soy.$$escapeHtml("/jira") + '/secure/admin/views/ExternalImport1.jspa">' + soy.$$escapeHtml("Import a project") + '</a>|<a class="create-with-shared-config button-panel-link" href="#"><span class="aui-icon aui-icon-create-shared">' + soy.$$escapeHtml("Create with shared configuration") + '</span> ' + soy.$$escapeHtml("Create with shared configuration") + '</a>' + ((opt_data.showDemoLink) ? '| <a class="add-demo-project-trigger button-panel-link" href="#">' + soy.$$escapeHtml("Create sample data") + '</a>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.footerLinks.soyTemplateName = 'JIRA.Templates.ProjectTemplates.footerLinks';
}


JIRA.Templates.ProjectTemplates.addWorkflowsLink = function(opt_data, opt_ignored) {
  return '<a class="add-workflow-link" href="' + soy.$$escapeHtml(opt_data.baseUrl) + '/plugins/servlet/wfshare-import?src=projecttemplates" tabindex="-1">' + soy.$$escapeHtml("View Marketplace Workflows") + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.addWorkflowsLink.soyTemplateName = 'JIRA.Templates.ProjectTemplates.addWorkflowsLink';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/soy/AddProject.soy' */
// This file was automatically generated from AddProject.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }


JIRA.Templates.ProjectTemplates.addProjectForm = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.errors.errorMessages) {
    var errorList5 = opt_data.errors.errorMessages;
    var errorListLen5 = errorList5.length;
    for (var errorIndex5 = 0; errorIndex5 < errorListLen5; errorIndex5++) {
      var errorData5 = errorList5[errorIndex5];
      output += JIRA.Templates.errorMsg({closeable: false, msg: errorData5});
    }
  }
  output += '<div class="add-project-wrapper"><div class="add-project-form-wrapper">' + aui.form.form({content: '' + aui.form.fieldset({legendContent: '', content: '' + JIRA.Templates.ProjectTemplates.longTextField({id: 'name', name: 'name', isRequired: false, maxLength: opt_data.maxNameLength, labelContent: "Name", descriptionText: AJS.format("Max. {0} characters.",opt_data.maxNameLength), value: opt_data.currentName ? opt_data.currentName : '', errorTexts: opt_data.errors.errors.projectName ? [opt_data.errors.errors.projectName] : []}) + JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon({id: 'key', name: 'key', isRequired: false, maxLength: opt_data.maxKeyLength, labelContent: "Key", descriptionText: AJS.format("Max. {0} characters.",opt_data.maxKeyLength), helpTitle: "What\x27s a project key?", value: opt_data.currentKey ? opt_data.currentKey : '', errorTexts: opt_data.errors.errors.projectKey ? [opt_data.errors.errors.projectKey] : []}) + ((opt_data.shouldShowLead) ? JIRA.Templates.ProjectTemplates.projectLeadField({field: opt_data.projectLeadPickerField, isRequired: false, errorTexts: opt_data.errors.errors.projectLead ? [opt_data.errors.errors.projectLead] : [], options: opt_data.leadOptions}) : '') + ((opt_data.addUserToLicense.displayCheckbox) ? JIRA.Templates.ProjectTemplates.addUserToLicense({fieldId: opt_data.addUserToLicense.fieldId, fieldName: opt_data.addUserToLicense.fieldName, applicationName: opt_data.addUserToLicense.applicationName, usedSeats: opt_data.addUserToLicense.usedSeats, totalSeats: opt_data.addUserToLicense.totalSeats, disableCheckbox: opt_data.addUserToLicense.disableCheckbox, licensingUrl: opt_data.addUserToLicense.licensingUrl}) : '') + '<input type="hidden" name="keyEdited" id="keyEdited" value="false"><input type="hidden" name="projectTemplateWebItemKey" value="' + soy.$$escapeHtml(opt_data.projectTemplateWebItemKey) + '"><input type="hidden" name="projectTemplateModuleKey" value="' + soy.$$escapeHtml(opt_data.projectTemplateModuleKey) + '"><input type="submit" class="pt-hidden-submit offscreen-left">'}), id: 'add-project-form'}) + '</div>' + ((opt_data.projectTemplateDescriptionContent) ? '<div class="add-project-description-wrapper"><div class="project-template-title"><h3>' + soy.$$escapeHtml(opt_data.projectTemplateTitle) + '</h3></div><div class="project-template-description">' + soy.$$filterNoAutoescape(opt_data.projectTemplateDescriptionContent) + '</div></div>' : '') + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.addProjectForm.soyTemplateName = 'JIRA.Templates.ProjectTemplates.addProjectForm';
}


JIRA.Templates.ProjectTemplates.keyHelp = function(opt_data, opt_ignored) {
  return '<div class="project-key-help"><p><b>' + soy.$$escapeHtml("What\x27s a project key?") + '</b></p><ul><li>' + soy.$$escapeHtml("It prefixes each issue in the project") + '</li><li>' + soy.$$escapeHtml("It can be changed, but this is not a trivial task") + '</li></ul></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.keyHelp.soyTemplateName = 'JIRA.Templates.ProjectTemplates.keyHelp';
}


JIRA.Templates.ProjectTemplates.projectLeadField = function(opt_data, opt_ignored) {
  var param77 = '' + aui.form.label({forField: opt_data.field.name + '-field', isRequired: opt_data.isRequired, content: "Project Lead"}) + JIRA.Templates.Fields.Pickers.User.single({field: opt_data.field, options: opt_data.options, editValue: opt_data.value}) + aui.form.fieldDescription({message: "Enter the username of the Project Lead."});
  if (opt_data.errorTexts) {
    var errorList90 = opt_data.errorTexts;
    var errorListLen90 = errorList90.length;
    for (var errorIndex90 = 0; errorIndex90 < errorListLen90; errorIndex90++) {
      var errorData90 = errorList90[errorIndex90];
      param77 += aui.form.fieldError({message: errorData90});
    }
  }
  var output = '' + aui.form.fieldGroup({content: param77});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.projectLeadField.soyTemplateName = 'JIRA.Templates.ProjectTemplates.projectLeadField';
}


JIRA.Templates.ProjectTemplates.addUserToLicense = function(opt_data, opt_ignored) {
  var output = '';
  var labelMessage__soy96 = '' + soy.$$escapeHtml(AJS.format("Give me a {0} license so I can access this project.",opt_data.applicationName)) + ((opt_data.totalSeats > 0) ? '<br/>' + soy.$$escapeHtml(AJS.format("({0} of {1} licenses now used)",opt_data.usedSeats,opt_data.totalSeats)) : '');
  output += aui.form.fieldGroup({content: '' + aui.form.label({forField: opt_data.fieldName, content: 'License'}) + ((opt_data.disableCheckbox) ? aui.form.field({id: opt_data.fieldId, name: opt_data.fieldName, value: 'true', type: 'checkbox', isChecked: false, labelContent: labelMessage__soy96, isDisabled: true, descriptionContent: AJS.format("We can\x27\x27t give you access to {0} automatically. You can {1}manage application access{2} to work on {0} projects.",opt_data.applicationName,'<a href="' + "/jira" + opt_data.licensingUrl + '">','</a>')}) : aui.form.field({id: opt_data.fieldId, name: opt_data.fieldName, value: 'true', type: 'checkbox', isChecked: false, labelContent: labelMessage__soy96, isDisabled: false}))});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.addUserToLicense.soyTemplateName = 'JIRA.Templates.ProjectTemplates.addUserToLicense';
}


JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon = function(opt_data, opt_ignored) {
  var param128 = '' + aui.form.label({forField: opt_data.name, isRequired: opt_data.isRequired, content: opt_data.labelContent}) + aui.form.input({id: opt_data.id, name: opt_data.name, type: 'text', maxLength: opt_data.maxLength, value: opt_data.value}) + '<a class="help-lnk" title="' + soy.$$escapeHtml(opt_data.helpTitle) + '" id="' + soy.$$escapeHtml(opt_data.id) + '-help-icon"><span class="aui-icon aui-icon-help">' + soy.$$escapeHtml(opt_data.helpTitle) + '</span></a>' + ((opt_data.descriptionText) ? aui.form.fieldDescription({message: opt_data.descriptionText}) : '');
  if (opt_data.errorTexts) {
    var errorList152 = opt_data.errorTexts;
    var errorListLen152 = errorList152.length;
    for (var errorIndex152 = 0; errorIndex152 < errorListLen152; errorIndex152++) {
      var errorData152 = errorList152[errorIndex152];
      param128 += aui.form.fieldError({message: errorData152});
    }
  }
  var output = '' + aui.form.fieldGroup({content: param128});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon.soyTemplateName = 'JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon';
}


JIRA.Templates.ProjectTemplates.longTextField = function(opt_data, opt_ignored) {
  var param158 = '' + aui.form.label({forField: opt_data.name, isRequired: opt_data.isRequired, content: opt_data.labelContent}) + aui.form.input({id: opt_data.id, name: opt_data.name, type: 'text', maxLength: opt_data.maxLength, value: opt_data.value, extraClasses: 'long-field'}) + ((opt_data.descriptionText) ? aui.form.fieldDescription({message: opt_data.descriptionText}) : '');
  if (opt_data.errorTexts) {
    var errorList176 = opt_data.errorTexts;
    var errorListLen176 = errorList176.length;
    for (var errorIndex176 = 0; errorIndex176 < errorListLen176; errorIndex176++) {
      var errorData176 = errorList176[errorIndex176];
      param158 += aui.form.fieldError({message: errorData176});
    }
  }
  var output = '' + aui.form.fieldGroup({content: param158});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.longTextField.soyTemplateName = 'JIRA.Templates.ProjectTemplates.longTextField';
}


JIRA.Templates.ProjectTemplates.spinner = function(opt_data, opt_ignored) {
  return '<span id=\'' + soy.$$escapeHtml(opt_data.id) + '\' class=\'icon throbber loading\'/>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.spinner.soyTemplateName = 'JIRA.Templates.ProjectTemplates.spinner';
}


JIRA.Templates.ProjectTemplates.formatAnchor = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.href) + '"' + ((opt_data.title) ? ' title="' + soy.$$escapeHtml(opt_data.title) + '"' : '') + '>' + soy.$$escapeHtml(opt_data.body) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.formatAnchor.soyTemplateName = 'JIRA.Templates.ProjectTemplates.formatAnchor';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/soy/CreateSharedProject.soy' */
// This file was automatically generated from CreateSharedProject.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }


JIRA.Templates.ProjectTemplates.createSharedProjectForm = function(opt_data, opt_ignored) {
  return '<div class="create-shared-project-wrapper"><div class="create-shared-project-form-wrapper">' + aui.form.form({content: '' + aui.form.fieldset({content: '<p>' + soy.$$escapeHtml("Select the existing project that you\x27d like to share configurations with.") + '<a class="help-lnk" title="' + soy.$$escapeHtml("What will be shared?") + '" id="shared-help-icon"><span class="aui-icon aui-icon-help">' + soy.$$escapeHtml("What will be shared?") + '</span></a></p>' + aui.form.fieldGroup({extraClasses: 'project-picker-group', content: '' + aui.form.label({forField: 'project-picker', isRequired: false, content: "Choose a project"}) + aui.form.input({id: 'project-picker', name: 'project', type: 'text'}) + '<div id="project-picker-options" data-suggestions="' + soy.$$escapeHtml(opt_data.projectSuggestions) + '"></div>'}) + '<p class="create-shared-info">' + soy.$$escapeHtml("When a configuration is shared with several projects, it means that any changes made to the configuration will affect all the projects.") + '</p>'}), id: 'create-shared-project-form'}) + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.createSharedProjectForm.soyTemplateName = 'JIRA.Templates.ProjectTemplates.createSharedProjectForm';
}


JIRA.Templates.ProjectTemplates.loading = function(opt_data, opt_ignored) {
  return '<div><div class="dialog-spinner"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.loading.soyTemplateName = 'JIRA.Templates.ProjectTemplates.loading';
}


JIRA.Templates.ProjectTemplates.noProjects = function(opt_data, opt_ignored) {
  return '<p>' + soy.$$escapeHtml("Looks like no other projects exist yet. Please create a brand new project first before trying to share an existing project\x27s configuration.") + '</p>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.noProjects.soyTemplateName = 'JIRA.Templates.ProjectTemplates.noProjects';
}


JIRA.Templates.ProjectTemplates.sharedHelp = function(opt_data, opt_ignored) {
  return '<div class="shared-help"><p><strong>' + soy.$$escapeHtml("What will be shared?") + '</strong></p><p>' + soy.$$escapeHtml("Configuration refers to the set of schemes used by a project") + '</p><ul><li>' + soy.$$escapeHtml("Permission Scheme") + '</li><li>' + soy.$$escapeHtml("Notification Scheme") + '</li><li>' + soy.$$escapeHtml("Issue Security Scheme") + '</li><li>' + soy.$$escapeHtml("Workflow Scheme") + '</li><li>' + soy.$$escapeHtml("Issue Type Scheme") + '</li><li>' + soy.$$escapeHtml("Issue Type Screen Scheme") + '</li><li>' + soy.$$escapeHtml("Field Configuration Scheme") + '</li></ul></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.sharedHelp.soyTemplateName = 'JIRA.Templates.ProjectTemplates.sharedHelp';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/Config.js' */
define('jira/project-templates/config', {
    model: {}
});
AJS.namespace('JPT.ConfigModel', null, require('jira/project-templates/config'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/ProjectKeyGenerator.js' */
define('jira/project-templates/project-key-generator', [
    'jquery',
    'underscore'
], function(
    $,
    _
){
    var ProjectKeyGenerator = {};
    ProjectKeyGenerator.IGNORED_WORDS = ["THE", "A", "AN", "AS", "AND", "OF", "OR"];

    // The (non-ascii) characters used as keys will be replaced with their (ascii) value.
    ProjectKeyGenerator.CHARACTER_MAP = {};
    ProjectKeyGenerator.CHARACTER_MAP[199] = "C"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[231] = "c"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[252] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[251] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[250] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[249] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[233] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[234] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[235] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[232] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[226] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[228] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[224] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[229] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[225] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[239] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[238] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[236] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[237] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[196] = "A"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[197] = "A"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[201] = "E"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[230] = "ae"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[198] = "Ae"; // Â®
    ProjectKeyGenerator.CHARACTER_MAP[244] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[246] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[242] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[243] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[220] = "U"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[255] = "Y"; // Ã
    ProjectKeyGenerator.CHARACTER_MAP[214] = "O"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[241] = "n"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[209] = "N"; // ?

    ProjectKeyGenerator.desiredKeyLength = 4;
    ProjectKeyGenerator.maxKeyLength = 10;

    ProjectKeyGenerator.getTotalLength = function getTotalLength(words) {
        return words.join("").length;
    };

    ProjectKeyGenerator.removeIgnoredWords = function removeIgnoredWords(words) {
        return _.reject(words, function(word) {
            return $.inArray(word, ProjectKeyGenerator.IGNORED_WORDS) !== -1;
        });
    };

    ProjectKeyGenerator.createAcronym = function createAcronym(words) {
        var result = "";
        $.each(words, function(i, word) {
            result += word.charAt(0);
        });
        return result;
    };

    ProjectKeyGenerator.getFirstSyllable = function getFirstSyllable(word) {
        // Best guess at getting the first syllable
        // Returns the substring up to and including the first consonant to appear after a vowel
        var pastVowel = false;
        var i;
        for (i = 0; i < word.length; i++) {
            if (ProjectKeyGenerator.isVowelOrY(word[i])) {
                pastVowel = true;
            } else {
                if (pastVowel) {
                    return word.substring(0, i + 1);
                }
            }
        }
        return word;
    };

    ProjectKeyGenerator.isVowelOrY = function isVowelOrY(c) {
        return c && c.length === 1 && c.search("[AEIOUY]") !== -1;
    };

    ProjectKeyGenerator.init = function init(desiredKeyLength, maxKeyLength) {
        ProjectKeyGenerator.desiredKeyLength = desiredKeyLength;
        ProjectKeyGenerator.maxKeyLength = maxKeyLength;
    };

    ProjectKeyGenerator.generate = function generate(name) {
        name = $.trim(name);
        if (!name) {
            return "";
        }

        // Brute-force chunk-by-chunk substitution and filtering.
        var filtered = [];
        for(var i=0, ii=name.length; i<ii; i++) {
            var sub = ProjectKeyGenerator.CHARACTER_MAP[name.charCodeAt(i)];
            filtered.push(sub ? sub : name[i]);
        }
        name = filtered.join('');

        // Split into words
        var words = [];
        $.each(name.split(/\s+/), function(i, word) {
            if (word) {
                // Remove whitespace and punctuation characters (i.e. anything not A-Z)
                word = word.replace(/[^a-zA-Z]/g, "");
                // uppercase the word (NOTE: JavaScript attempts to convert characters like Â§ in to SS)
                word = word.toUpperCase();
                // add the word, should it be worthy.
                word.length && words.push(word);
            }
        });

        // Remove ignored words
        if (ProjectKeyGenerator.desiredKeyLength && ProjectKeyGenerator.getTotalLength(words) > ProjectKeyGenerator.desiredKeyLength) {
            words = ProjectKeyGenerator.removeIgnoredWords(words);
        }

        var key;

        if (words.length == 0) {
            // No words were worthy!
            key = "";
        } else if (words.length == 1) {
            // If we have one word, and it is longer than a desired key, get the first syllable
            var word = words[0];
            if (ProjectKeyGenerator.desiredKeyLength && word.length > ProjectKeyGenerator.desiredKeyLength) {
                key = ProjectKeyGenerator.getFirstSyllable(word);
            } else {
                // The word is short enough to use as a key
                key = word;
            }
        } else {
            // If we have more than one word, just take the first letter from each
            key = ProjectKeyGenerator.createAcronym(words);
        }

        // Limit the length of the key
        if (ProjectKeyGenerator.maxKeyLength && key.length > ProjectKeyGenerator.maxKeyLength) {
            key = key.substr(0, ProjectKeyGenerator.maxKeyLength);
        }

        return key;
    };
    return ProjectKeyGenerator;
});
AJS.namespace('JPT.ProjectKeyGenerator', null, require('jira/project-templates/project-key-generator'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/DialogView.js' */
// Warning!
//This module has a hidden circular dependency -> jira/project-templates/dialog-controller
define('jira/project-templates/dialog-view-impl', [
    'require',
    'backbone',
    'underscore'
], function(
    require,
    Backbone,
    _
){
    var Dialog = AJS.Dialog;
    var Trigger = AJS.trigger;

    return Backbone.View.extend({
        events: {
            "click   .add-project-trigger": "_onClickAddProject",
            "click   .add-demo-project-trigger": "_onClickAddDemoProject",
            "click   .add-workflow-link": "_onClickViewMarketplaceWorkflows",
            "click   #add-project-dialog .add-demo-project-trigger": "_onCreateProjectAddDemoProjectClick",
            "click   #add-project-dialog .import-project-trigger": "_onClickImportProject",
            "click   #add-project-dialog .create-with-shared-config": "_onClickCreateShared",
            "keydown #add-project-dialog .pt-templates-list": "_onKeydownInTemplatesList"
        },

        draw: function() {
            var dialog = new Dialog({
                width: 840,
                height: 400,
                id: "add-project-dialog",
                closeOnOutsideClick: false,
                keypressListener: _.bind(this._onKeyPressed, this)
            });

            var $dialog = dialog.popup.element;

            dialog.addPage("project-templates-page");

            dialog.addHeader("Create project", "add-project-dialog-header");

            dialog.addPanel("ProjectTemplatesListPanel", JIRA.Templates.ProjectTemplates.loadingTemplatesList(), "pt-content");

            this._dialog = dialog;
            this._$dialogElement = $dialog;

            dialog.show();

            return dialog;
        },

        /**
         * Removes this DialogView.
         *
         * @return {*}
         */
        remove: function() {
            this._dialog && this._dialog.remove();
        },

        showErrorMessage: function(message) {
            this._dialog.getPanel(1, 0).html(JIRA.Templates.errorMsg({
                closable: false,
                msg: message
            }));
        },

        get$PTContent: function getPTContent() {
            return this.getDialogController().$dialogElement.find(".pt-content");
        },

        /**
         * Removes this dialog when ESC is pressed. Note that this is called on keydown anywhere within the dialog,
         * including all steps of the wizard, so you want to be careful about what you do in here.
         *
         * @param {jQuery.Event} e the keydown Event
         * @returns {boolean}
         * @private
         */
        _onKeyPressed: function(e) {
            var escapeKey = 27;
            if (this._dialog) {
                if (e.keyCode === escapeKey) {
                    this.getDialogController().hideDialogFromNewUser("dismissed");
                    this._dialog.remove();
                    return false; // preventDefault, don't propagate.
                }
            }

            return true;
        },

        /**
         * Proceeds to the next step of the wizard when the user presses ENTER in the project templates list.
         * Unfortunately in this case we can't rely on browser auto-submit of forms because the focus is not inside a
         * text input/
         *
         * @param {jQuery.Event} e
         * @returns {boolean}
         * @private
         */
        _onKeydownInTemplatesList: function(e) {
            var enterKey = 13;
            if (this._dialog) {
                if (e.keyCode === enterKey) {
                    this._$dialogElement.find(".pt-submit-button:visible").click();
                    return false;
                }
            }

            return true;
        },

        _onClickAddProject: function(event) {
            event.preventDefault();
            this.getDialogController().handleProjectTemplateTriggered();
        },

        _onCreateProjectAddDemoProjectClick: function() {
            Trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.demo.create.project.clicked'});
        },

        _onClickViewMarketplaceWorkflows: function () {
            Trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.viewmarketplaceworkflows.clicked'});
        },

        _onClickAddDemoProject: function(event) {
            event.preventDefault();
            var dialog = this.getDialogController().dialog;
            if (dialog && dialog.popup && dialog.popup.element) {
                dialog.remove();
            }
            this.getDialogController().handleDemoProjectTemplateTriggered();
        },

        _onClickImportProject: function(event) {
            this.getDialogController().hideDialogFromNewUser("importproject");
        },

        _onClickCreateShared: function(event) {
            this.getDialogController().handleCreateShared();
        },

        getDialogController: function() {
            return require('jira/project-templates/dialog-controller');
        }
    });
});

define('jira/project-templates/dialog-view', [
    'jira/project-templates/dialog-view-impl',
    'jquery'
], function(
    DialogViewImpl,
    $
){
    return new DialogViewImpl({ el: $(document) });
});
AJS.namespace('JPT.DialogView', null, require('jira/project-templates/dialog-view'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/DialogController.js' */
// Warning!
// This module has a hidden circular dependencies -> jira/project-templates/select-project-template-controller
//                                                -> jira/project-templates/create-shared-controller
define('jira/project-templates/dialog-controller', [
    'jira/project-templates/dialog-view',
    'jira/project-templates/config',
    'jira/ajs/ajax/smart-ajax',
    'jira/util/data/meta',
    'jira/lib/class',
    'jquery',
    'underscore',
    'wrm/data'
], function(
    DialogView,
    Config,
    SmartAjax,
    Meta,
    Class,
    $,
    _,
    wrmData
){
    var contextPath = AJS.contextPath();
    var isDevMode = AJS.isDevMode;
    var log = AJS.log;

    function triggerAnalytics(name, params) {
        AJS.trigger('analyticsEvent', {name: name, data: params});
    }

    var ptAnalyticsData;
    var getPtAnalyticsData = function () {
        if( !ptAnalyticsData ) {
            ptAnalyticsData = wrmData.claim('com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources.ptAnalyticsData') || {};
        }
        return ptAnalyticsData;
    };

    var DialogController = Class.extend({
        WELCOME_REST_URL: contextPath + "/rest/welcome/1.0/show/welcome",

        initialize: function() {
            _.bindAll(this, 'handleProjectTemplateTriggered', 'hideDialogFromNewUser');

            if (Meta.getBoolean('show-welcome-screen')) {
                this.handleProjectTemplateTriggered();
            }
        },

        handleProjectTemplateTriggered: function() {
            this.demoProject = false;
            triggerAnalytics('jira.project.templates.dialog.create.show');
            this.openWithFirstProjectTemplateOfTypePreSelected();
        },

        handleDemoProjectTemplateTriggered: function() {
            this.demoProject = true;
            var projectTemplatesDeferred = this.getTemplateController().loadDemoProjectTemplatesData();
            this.openWithFirstProjectTemplateOfTypePreSelected(null, projectTemplatesDeferred);
            this._addAnalyticsToCreateDemoShow(projectTemplatesDeferred);
        },

        _addAnalyticsToCreateDemoShow: function (projectTemplatesDeferred) {
            projectTemplatesDeferred.done(function (data) {
                var params = {};

                var getDemoSets = function (data) {
                    return data.projectTemplatesGroupedByType.map(
                        function (ptGroup) {
                            return ptGroup.projectTemplates.map(
                                function (pt) {
                                    return pt.itemModuleCompleteKey
                                }).join();
                        }).join();
                };

                params.demoSets = getDemoSets(data);
                params.instanceCreatedDate = getPtAnalyticsData().instanceCreatedDate;

                triggerAnalytics('jira.project.templates.dialog.create.demo.show', params);
            }.bind(this));
        },

        openWithFirstProjectTemplateOfTypePreSelected: function(projectTypeKey, projectTemplatesDeferred) {
            projectTemplatesDeferred = projectTemplatesDeferred || this.getTemplateController().loadProjectTemplatesData();
            //draw dialog with spinner
            this.dialog  = DialogView.draw();

            projectTemplatesDeferred.fail(_.bind(function (jqXHR) {
                this._handleUnknownErrorOfPTRetrieval();
            }, this));

            projectTemplatesDeferred.done(_.bind(function (data) {
                this.$dialogElement = this.dialog.popup.element;

                // Persist the selected template (e.g. after coming back from a GH installation)
                var selectedTemplate;
                if (!_.isUndefined(Config.model.selectedTemplate)) {
                    selectedTemplate = Config.model.selectedTemplate;
                }
                Config.model = data;
                Config.model.selectedTemplate = selectedTemplate;
                this.getTemplateController().init(data, projectTypeKey);
            }, this));
        },

        handleCreateShared: function() {
            triggerAnalytics('jira.project.templates.dialog.create.shared.clicked');
            this.demoProject = false;
            this.openWithCreateShared();
        },

        openWithCreateShared: function() {
            var CreateSharedController = require('jira/project-templates/create-shared-controller');
            CreateSharedController.initCreateShared();
        },

        callbackWithResize: function(callback) {
            return _.bind(_.wrap(callback, function(originalCallback) {
                originalCallback.call(this);
                this.dialog.updateHeight();
            }), this);
        },

        addPage: function(pageConfig) {
            var page = this.dialog.addPage(pageConfig.name).page[this.dialog.curpage];
            this.dialog.addHeader(pageConfig.title, "add-project-dialog-header");
            this.dialog.addPanel(pageConfig.panelName, "", "pt-content");

            if (pageConfig.backButton) {
                this._addBackButton(page);
            }

            this.dialog.addButton(
                pageConfig.submitButtonText,
                this.callbackWithResize(pageConfig.submitButtonCallback),
                pageConfig.submitButtonClass + " pt-submit-button"
            );
            var $submitButton = this.$dialogElement.find("." + pageConfig.submitButtonClass);
            $submitButton.removeClass("button-panel-button").addClass("aui-button aui-button-primary"); /* button-panel-button class doesn't have disabled styles, using .aui-button instead */
            $submitButton.focus();

            this.dialog.addCancel("Cancel", _.bind(function(event) {
                this.hideDialogFromNewUser("dismissed");

                this.dialog.remove();
            }, this));

            return page;
        },

        _backButtonOnClickCallback: function(page) {
            return _.bind(function() {
                if (this.demoProject) {
                    triggerAnalytics("jira.project.templates.dialog.demo.back");
                } else {
                    triggerAnalytics("jira.project.templates.dialog.create.back");
                }
                var $addProjectWrapper = DialogView.get$PTContent();
                $addProjectWrapper.css('background-image', 'none');

                this.dialog.prevPage();
                page.remove();
                this.dialog.page.pop();
            }, this);
        },

        _addBackButton: function(page) {
            this.dialog.addButton(
                "Back",
                this.callbackWithResize(this._backButtonOnClickCallback(page)),
                "add-project-back-button"
            );
            var $backButton = this.$dialogElement.find(".add-project-back-button");
            $backButton.removeClass("button-panel-button").addClass("aui-button");
        },

        _handleUnknownErrorOfPTRetrieval: function() {
            DialogView.showErrorMessage("An error occurred while trying to contact JIRA");
        },

        hideDialogFromNewUser: function(reason) {
            if (reason === "dismissed") {
                if (this.demoProject) {
                    triggerAnalytics("jira.project.templates.dialog.demo.dismissed");
                } else {
                    triggerAnalytics("jira.project.templates.dialog.create.dismissed");
                }
            } else if (reason === "importproject") {
                triggerAnalytics('jira.project.templates.dialog.import.clicked');
            } else if (reason === "templateselected") {
                if (this.demoProject) {
                    triggerAnalytics("jira.project.templates.dialog.demo.templateselected");
                } else {
                    triggerAnalytics("jira.project.templates.dialog.create.templateselected");
                }
            }

            if (Meta.getBoolean('show-welcome-screen')) {
                $.ajax({
                    url: this.WELCOME_REST_URL + "/" + reason,
                    type: "DELETE",
                    success: function () {
                        if (isDevMode && isDevMode()) {
                            log("don't show project template dialog anymore");
                        }
                    }
                });
            }
        },

        getTemplateController: function() {
            return require('jira/project-templates/select-project-template-controller');
        }
    });

    return new DialogController();
});
AJS.namespace('JPT.DialogController', null, require('jira/project-templates/dialog-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/AddProjectView.js' */
// WARNING
// This module has a hidden circular dependency -> jira/project-templates/add-project-controller
define('jira/project-templates/add-project-view-impl', [
    'jira/project-templates/dialog-controller',
    'jira/project-templates/config',
    'jira/util/events',
    'jira/util/events/types',
    'require',
    'backbone',
    'jquery',
    'underscore'
], function(
    DialogController,
    Config,
    Events,
    EventTypes,
    require,
    Backbone,
    $,
    _
){
    var InlineDialog = AJS.InlineDialog;

    return Backbone.View.extend({
        TIMEOUT_MS: 100,

        postDrawCallbacks: [],

        events: {
            "submit #add-project-form": "onSubmitForm"
        },

        page: undefined,
        isSubmitting: false,

        initialize: function(options) {
            _.bindAll(this, "bindHook");
        },

        addPostDrawCallback: function(callback) {
            this.postDrawCallbacks.push(callback);
        },

        /**
         * Prepare the Dialog to hold the Add Project form; this should only be called once for a selected Project Template.
         * The actual form could be rendered multiple times after unsuccessful validations.
         */
        prepareDialog: function(title) {
            this.page = DialogController.addPage({
                name: "add-project",
                title: title,
                panelName: "add-project",
                backButton: true,
                submitButtonText: "Submit",
                submitButtonCallback: this.onSubmitForm.bind(this),
                submitButtonClass: "add-project-dialog-create-button"
            });
        },

        /**
         * Draw the Add Project form into the passed dialog, as a new screen.
         *
         * This will be triggered on clicking "Next", so should render on the second page.
         */
        draw: function(params) {
            function fixErrorObject(errors) {
                if (!errors.errors) {
                    errors.errors = {}
                }
                return errors;
            }
            this.isSubmitting = false;

            DialogController.dialog.gotoPage(this.page.id);

            var projectTemplateModuleCompleteKey = params.webItemData.projectTemplateModuleCompleteKey;
            var templateGroup = _.find(Config.model.projectTemplatesGroupedByType, function(templateGroup){
                return _.any(templateGroup.projectTemplates, function(template) {
                    return template.itemModuleCompleteKey == projectTemplateModuleCompleteKey
                });
            });
            var applicationName = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.applicationName) || '';
            var usedSeats = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.licenseUsedSeats) || 0;
            var totalSeats = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.licenseTotalSeats) || 0;
            var canUserBeAddedToApplication = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.canUserBeAddedToApplication) || false;
            var canUserUseApplication = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.canUserUseApplication) || false;
            var isOnDemand = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.ondemand) || false;
            var displayCheckbox;
            if (!templateGroup || !templateGroup.applicationInfo) {
                displayCheckbox = false;
            } else {
                displayCheckbox = !canUserUseApplication;
            }

            var soyParameters = {
                maxNameLength: Config.model.maxNameLength,
                maxKeyLength: Config.model.maxKeyLength,
                shouldShowLead: Config.model.shouldShowProjectLead,
                projectTemplateWebItemKey: Config.model.selectedTemplate || params.webItemData.itemModuleCompleteKey,
                projectTemplateModuleKey: projectTemplateModuleCompleteKey,
                projectTemplateTitle: params.webItemData.name,
                projectTemplateDescriptionContent: params.webItemData.longDescriptionContent,
                currentKey: params.currentKey || "",
                currentName: params.currentName || "",
                errors: fixErrorObject(params.errors),
                projectLeadPickerField: {
                    id: 'lead',
                    name: 'lead'
                },
                addUserToLicense: {
                    displayCheckbox: displayCheckbox,
                    disableCheckbox: !canUserBeAddedToApplication,
                    applicationName: applicationName,
                    usedSeats: usedSeats,
                    totalSeats: totalSeats,
                    fieldId: 'licenseUser',
                    fieldName: 'licenseUser',
                    licensingUrl: isOnDemand? '/admin/accessconfig' : '/plugins/servlet/applications/versions-licenses'
                },
                leadOptions: [
                    {
                        selected: true,
                        displayName: params.currentUserDisplayName,
                        optionName: params.currentUserName,
                        avatarURL: params.currentUserAvatarUrl
                    }
                ]
            };
            var addProjectForm = JIRA.Templates.ProjectTemplates.addProjectForm(soyParameters);

            DialogController.dialog.getPanel(this.page.id, 0).html(addProjectForm);

            if (params.webItemData && params.webItemData.backgroundIconUrl) {
                var $addProjectWrapper = DialogController.$dialogElement.find(".pt-content");
                $addProjectWrapper.css('background-image', 'url("' + params.webItemData.backgroundIconUrl + '")');
            }

            var $addProjectForm = $("#add-project-form");
            // fire event to create the Single User Picker
            Events.trigger(EventTypes.NEW_CONTENT_ADDED, [$addProjectForm]);

            this.nameElement = DialogController.$dialogElement.find("#name");
            this.keyElement = DialogController.$dialogElement.find("#key");
            this.keyEditedElement = DialogController.$dialogElement.find("#keyEdited");
            this.leadDisplayElement = DialogController.$dialogElement.find("#lead-field");
            this.leadValueElement = DialogController.$dialogElement.find("#lead");

            var $keyHelpElement = this.keyElement.parent().find(".aui-icon-help");
            if ($keyHelpElement.length) {
                new InlineDialog($keyHelpElement, "project-key-help-popup",
                    function(contents, trigger, show) {
                        contents.html(JIRA.Templates.ProjectTemplates.keyHelp());
                        show();
                    }, {
                        width: 330,
                        offsetX: -30
                    });
            }

            // Input restrictions
            this.keyElement.attr("style", "text-transform: uppercase");

            var AddProjectController = require('jira/project-templates/add-project-controller');

            this.nameElement.focus(_.bind(function(e) {
                this.bindHook(e, AddProjectController.nameTimeout);
            }, this));

            var self = this;
            this.nameElement.change(function (e){
                AddProjectController.validateName();
                self.unbindHook(e);
            });

            this.nameElement.focus();

            this.keyElement.focus(_.bind(function(e) {
                var el = $(e.target);
                el.data("lastValue", el.val());
                this.bindHook(e, AddProjectController.keyTimeout);
            }, this));

            this.keyElement.blur(_.bind(function(e) {
                this.unbindHook(e);
            }, this));

            this.keyElement.change(function() {
                AddProjectController.validateKey();
                AddProjectController.autofillKeyIfNeeded();
            });
            if (!_.isEmpty(this.postDrawCallbacks)) {
                _.each(this.postDrawCallbacks, function(callback) {
                    callback();
                });
            }
            DialogController.dialog.updateHeight();
        },

        /**
         * Submits the "Add Project" form.
         *
         * @param {jQuery.Event} e the submit event
         * @returns {boolean}
         */
        onSubmitForm: function(e) {
            var AddProjectController = require('jira/project-templates/add-project-controller');
            AddProjectController.submit();
            return false;
        },

        get$SubmitButton: function() {
            return DialogController.$dialogElement.find(".add-project-dialog-create-button");
        },

        get$BackButton: function() {
            return DialogController.$dialogElement.find(".add-project-back-button");
        },

        bindHook: function bindHook(e, func) {
            var el = $(e.target), hook;
            hook = _.bind(function() {
                this.unbindHook(e);
                func.apply();
                if (el.is(":visible")) {
                    el.data("checkHook", setTimeout(hook, this.TIMEOUT_MS));
                }
            }, this);
            if (!el.data("checkHook")) {
                el.data("checkHook", setTimeout(hook, 0));
            }
        },

        unbindHook: function(e) {
            var el = $(e.target);
            clearTimeout(el.data("checkHook"));
            el.removeData("checkHook");
        },

        /**
         * Show an error for an input element, in the place of its description.
         *
         * @param $element
         * @param msg
         */
        showInlineError: function($element, msg) {
            if (this.isSubmitting) {
                // while the form is being submitted, don't show any late validation errors
                return;
            }
            var $errorElement = $element.parent().find(".error");
            if (!$errorElement.length) {
                $errorElement = $("<div class='error'></div>");
                $element.parent().append($errorElement);
            }
            $errorElement.text(msg);
            $errorElement.show();
        },

        showInlineErrorForName: function showInlineErrorForName(msg) {
            this.showInlineError(this.nameElement, msg);
        },

        showInlineErrorForKey: function showInlineErrorForKey(msg) {
            this.showInlineError(this.keyElement, msg);
        },

        /**
         * Hide any errors for an input field shown by showInlineError, and its description.
         *
         * @param $element
         */
        hideInlineError: function hideInlineError($element) {
            $element.parent().find(".error").hide();
        },

        hideInlineErrorForName: function hideInlineErrorForName() {
            this.hideInlineError(this.nameElement);
        },

        hideInlineErrorForKey: function hideInlineErrorForKey() {
            this.hideInlineError(this.keyElement);
        },

        setName: function setName(value) {
            this.nameElement.val(value);
        },

        getName: function getName() {
            return this.nameElement.val();
        },

        setKey: function setKey(value) {
            this.keyElement.val(value);
        },

        getKey: function getKey() {
            return this.keyElement.val().toUpperCase();
        },

        getLeadDisplayName: function getLeadDisplayName() {
            return this.leadDisplayElement.val();
        },

        getLeadUserName: function getLeadUserName() {
            return this.leadValueElement.val();
        },

        getAvatarUrlOfSelectedLead: function getAvatarUrlOfSelectedLead() {
            var userAvatarBackGroundProperty = DialogController.$dialogElement.find("#lead-single-select .aui-ss-entity-icon").css('background-image');
            if (!_.isUndefined(userAvatarBackGroundProperty)) {
                var userAvatarUrl = userAvatarBackGroundProperty.match(/^url\((.+)\)$/);
                return (userAvatarUrl && userAvatarUrl[1]) ? userAvatarUrl[1] : "";
            } else {
                return "";
            }
        },

        setKeyEdited: function setKeyEdited(value) {
            this.keyEditedElement.val(value);
        },

        getKeyEdited: function getKeyEdited() {
            return this.keyEditedElement.val();
        },

        setKeyEdited: function setKeyEdited() {
            var key = this.getKey();
            // If the key is manually edited, do not suggest automatically generated keys anymore
            // If the key field is cleared, resume suggesting automatically generated keys
            if (this.keyElement.data("lastValue") !== key) {
                this.keyEditedElement.val((key) ? "true" : "false");
            }
            this.keyElement.data("lastValue", key);
        },

        hasNameErrors: function hasNameErrors() {
            return this.nameElement.parent().find(".error").size() > 0;
        },

        getAddProjectForm: function getAddProjectForm() {
            return $("#add-project-form");
        },

        get$FormFields: function getFormFields() {
            return DialogController.$dialogElement.find(":input");
        },

        enterLoadingState: function showLoadingState() {
            $submitButton = this.get$SubmitButton();
            if (!$submitButton.attr("disabled")) {
                $backButton = this.get$BackButton();
                $submitButton.attr("disabled", "disabled");
                $backButton.attr("disabled", "disabled");
                $backButton.before(
                    JIRA.Templates.ProjectTemplates.spinner({
                        id: "addproject-loading"
                    }));
                this.get$FormFields().attr('disabled', 'disabled');

                this.isSubmitting = true;

                return true;
            } else {
                return false;
            }
        },

        hideLoadingState: function hideLoadingState() {
            DialogController.$dialogElement.find("#addproject-loading").remove();
            this.get$SubmitButton().removeAttr('disabled');
            this.get$BackButton().removeAttr('disabled');
            this.get$FormFields().removeAttr('disabled');
        },

        avoidDirtyFormWarning: function avoidDirtyFormWarning() {
            if ($.fn.removeDirtyWarning) {
                this.getAddProjectForm().removeDirtyWarning();
            }
        },

        hasInlineErrors: function hasInlineErrors() {
            return DialogController.$dialogElement.find(".field-group .error:visible").length != 0;
        }

    });
});
define('jira/project-templates/add-project-view', [
    'jira/project-templates/add-project-view-impl',
    'jira/project-templates/dialog-view',
    'jquery'
], function(
    AddProjectViewImpl,
    DialogView,
    $
) {
    return new AddProjectViewImpl({
        el: $(document),
        dialogView: DialogView
    });
});

AJS.namespace('JPT.AddProjectView', null, require('jira/project-templates/add-project-view'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/AddProjectController.js' */
define('jira/project-templates/add-project-controller-impl', [
    'jira/project-templates/add-project-view',
    'jira/project-templates/project-key-generator',
    'jira/project-templates/dialog-controller',
    'jira/project-templates/config',
    'jira/lib/class',
    'jquery',
    'underscore'
], function (
    AddProjectView,
    ProjectKeyGenerator,
    DialogController,
    Config,    
    Class,
    $,
    _
){
    var contextPath = AJS.contextPath();
    var trigger = AJS.trigger;

    return Class.extend({
        postProjectCreationCallbacks: [],
        projectKeyValidationCallbacks: [],
        projectNamesUpperCased: [],

        init: function (options) {
            this._window = options.window || window; // used for mocking 'window' in QUnit
            _.bindAll(this, "projectCreatedHandler", "projectValidationFailedHandler", "nameTimeout", "keyTimeout", "submit");
        },

        initCreateShared: function (existingProjectData) {
            this.existingProjectData = existingProjectData;
            this._initAddProject("Create with shared configuration");
        },

        initProjectTemplate: function (webItemData) {
            this.existingProjectData = undefined;
            this.webItemData = webItemData;
            this._initAddProject(webItemData.name);
        },

        _initAddProject: function (title) {
            this.desiredKeyLength = 4;
            this.lastKeyValidated = "";

            this._getExistingProjects();
            ProjectKeyGenerator.init(this.desiredKeyLength, Config.model.maxKeyLength);

            AddProjectView.prepareDialog(title);
            AddProjectView.draw({
                webItemData: this.webItemData || {},
                maxKeyLength: Config.model.maxKeyLength,
                maxNameLength: Config.model.maxNameLength,
                currentUserName: Config.model.currentUserName,
                currentUserDisplayName: Config.model.currentUserDisplayName,
                currentUserAvatarUrl: Config.model.currentUserAvatarUrl,
                errors: {}
            });
        },

        _resetProjectLeadValues: function () {
            Config.model.currentUserDisplayName = "";
            Config.model.currentUserName = "";
            Config.model.currentUserAvatarUrl = "";
        },

        _hasFullyConfiguredProjectLead: function () {
            return AddProjectView.getLeadDisplayName() && AddProjectView.getAvatarUrlOfSelectedLead() != "";
        },

        submit: function (event) {
            // This data is retrieved before the input fields are disabled (in enterLoadingState()) to avoid null-pointer exceptions when the fields are empty.
            var formData;
            if (this.existingProjectData) {
                formData = {
                    "key": AddProjectView.getKey(),
                    "name": AddProjectView.getName(),
                    "lead": AddProjectView.getLeadUserName() && AddProjectView.getLeadUserName()[0]
                };
            } else {
                formData = jQuery.param(AddProjectView.getAddProjectForm().serializeArray().map(function(param) {
                    // upper case is "visually" enforced by text-transform: uppercase
                    if (param.name === "key") {
                        param.value = param.value.toUpperCase();
                    }
                    return param
                }));
            }

            if (AddProjectView.hasInlineErrors()) {
                return;
            }

            if (AddProjectView.enterLoadingState()) {
                // store lead so we can repopulate the user picker for when the submit fails
                if (this._hasFullyConfiguredProjectLead()) {
                    Config.model.currentUserDisplayName = AddProjectView.getLeadDisplayName();
                    Config.model.currentUserName = Config.model.currentUserDisplayName ? AddProjectView.getLeadUserName() : "";
                    Config.model.currentUserAvatarUrl = AddProjectView.getAvatarUrlOfSelectedLead();
                } else {
                    this._resetProjectLeadValues();
                }

                if (this.existingProjectData) {
                    $.ajax({
                        url: contextPath + "/rest/project-templates/1.0/createshared/" + this.existingProjectData.existingProjectId,
                        type: "POST",
                        contentType: "application/json",
                        data: JSON.stringify(formData)
                    }).then(this.projectCreatedHandler, this.projectValidationFailedHandler);
                } else {
                    $.ajax({
                        url: contextPath +
                            (this.webItemData.demoProject ?
                                "/rest/jira-importers-plugin/1.0/demo/create" :
                                "/rest/project-templates/1.0/templates"),
                        type: "POST",
                        data: formData,
                        headers: {
                            "X-Atlassian-Token": "nocheck"
                        }
                    }).then(this.projectCreatedHandler, this.projectValidationFailedHandler);
                }
            }
        },

        registerPostProjectCreationCallback: function (callback) {
            this.postProjectCreationCallbacks.push(callback);
        },

        registerProjectKeyValidationCallback: function (callback) {
            this.projectKeyValidationCallbacks.push(callback);
        },

        localStoragePrefix: "jira.projecttemplates.",

        projectCreatedHandler: function (data) {
            if (this.existingProjectData) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.shared.project.create.success'});
            } else if (this.webItemData.demoProject) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.demo.success'});
            } else {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.project.success'});
            }
            AddProjectView.avoidDirtyFormWarning();

            // Put the created projects into local storage
            var localStoragePrefix = this.localStoragePrefix;
            var remoteProjectTypes = ["confluenceProject", "fisheyeProject", "crucibleProject", "bambooProject"];
            _.map(remoteProjectTypes, function (remoteProject) {
                if (data.remoteProjectLinks && data.remoteProjectLinks[remoteProject]) {
                    localStorage.setItem(localStoragePrefix + remoteProject, data.remoteProjectLinks[remoteProject]);
                }
            });


            // If there are any post Project Created callbacks registered, call these. Otherwise redirect to the desired return URL.
            if (!_.isEmpty(this.postProjectCreationCallbacks)) {
                DialogController.dialog.addPage("post-project-created-page");
                _.each(this.postProjectCreationCallbacks, function (callback) {
                    callback(DialogController.dialog, data.returnUrl, data.projectId, data.projectKey, data.projectName);
                });
            } else {
                this._window.location = contextPath + data.returnUrl;
            }
        },

        projectValidationFailedHandler: function (jqXhr, textStatus) {
            if (this.existingProjectData) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.shared.project.create.failure'});
            } else if (this.webItemData.demoProject) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.demo.failure'});
            } else {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.project.failure'});
            }

            var errors = {};
            if (this.isBadRequest(jqXhr)) {
                errors = JSON.parse(jqXhr.responseText);
            } else if (this.isUnDefinedServerSideError(jqXhr)) {
                errors = {"errorMessages": ["Hmm... we couldn\'t create your project due to an unknown error. Try refreshing the page to start again."]}
            } else if (this.isDefinedServerSideError(jqXhr)) {
                var errorResponse = JSON.parse(jqXhr.responseText);
                // Project template configuration threw an exception: Project has been created but the template hasn't been configured
                JIRA.Messages.showReloadErrorMsg(errorResponse.message);
                AddProjectView.avoidDirtyFormWarning();
                this._window.location = contextPath + errorResponse.returnUrl;
                // Remain in loading state while refreshing.
                return;
            } else if (this.isTimeoutError(textStatus)) {
                errors = {"errorMessages": ["Request timeout when creating project"]}
            } else {
                // Different kind of error. Let's generate an errors object with a general error that contains the right information
                errors = {"errorMessages": [AJS.format("Error creating project, {0}", jqXhr.responseText)]}
            }

            AddProjectView.draw({
                webItemData: this.webItemData || {},
                errors: errors,
                currentName: AddProjectView.getName(),
                currentKey: AddProjectView.getKey(),
                currentUserDisplayName: Config.model.currentUserDisplayName,
                currentUserName: Config.model.currentUserName,
                currentUserAvatarUrl: Config.model.currentUserAvatarUrl
            });

            AddProjectView.hideLoadingState();
        },

        isBadRequest: function(jqXhr) {
            return (jqXhr.status === 400) ;
        },

        isUnDefinedServerSideError: function(jqXhr){
            if (jqXhr.status === 500) {
                try {
                    JSON.parse(jqXhr.responseText);
                } catch(e) {
                    return true;
                }
            }
            return false;
        },

        isDefinedServerSideError: function(jqXhr) {
            return jqXhr.status === 500 && !_.isUndefined(JSON.parse(jqXhr.responseText).message) ;
        },

        isTimeoutError: function(textStatus) {
            return textStatus === "timeout" ;
        },

        _updateAndValidateKey: function updateKey(key) {
            AddProjectView.setKey(key);
            this.validateKey();
        },

        _shouldUpdateKey: function _shouldUpdateKey() {
            return (AddProjectView.getKeyEdited() != "true");
        },

        autofillKeyIfNeeded: function autofillKeyIfNeeded() {
            if (this._shouldUpdateKey()) {
                var key = ProjectKeyGenerator.generate(AddProjectView.getName());
                // JRADEV-10797 - Rather than validate the key,
                // we'll pretend that a key is always invalid if it's less than 1 character long.
                if (key.length > 1) {
                    this._updateAndValidateKey(key);
                } else {
                    // Blank the key without validation.
                    AddProjectView.setKey("");
                }
            }
        },

        _doesProjectNameExists: function (name) {
            var x;
            for (x in this.projectNamesUpperCased) {
                if (name.toUpperCase() == this.projectNamesUpperCased[x]) {
                    return true;
                }
            }

            return false;
        },

        validateName: function () {
            var name = $.trim(AddProjectView.getName());

            if (!name) {
                return;
            }

            if (name.length < Config.model.minNameLength) {
                AddProjectView.showInlineErrorForName(AJS.format("The project name should be at least {0} characters in length.", Config.model.minNameLength));
                return;
            }

            if (name.length > Config.model.maxNameLength) {
                AddProjectView.showInlineErrorForName(AJS.format("The project name must not exceed {0} characters in length.", Config.model.maxNameLength));
                return;
            }

            if (this._doesProjectNameExists(name)) {
                AddProjectView.showInlineErrorForName("A project with that name already exists.");
                return;
            }

            AddProjectView.hideInlineErrorForName();
        },

        _performKeyValidationChecks: function (key) {
            var validationChecksDeferred = $.ajax({
                url: contextPath + "/rest/api/latest/projectvalidate/key?key=" + key.toUpperCase()
            });

            validationChecksDeferred.done(_.bind(function (errors) {
                if (errors.errors && errors.errors["projectKey"]) {
                    AddProjectView.showInlineErrorForKey(errors.errors["projectKey"]);
                } else {
                    var foundError = false;
                    _.each(this.projectKeyValidationCallbacks, function (callback) {
                        var errors = callback(key.toUpperCase());
                        if (errors.errors && errors.errors["projectKey"]) {
                            foundError = true;
                            AddProjectView.showInlineErrorForKey(errors.errors["projectKey"]);
                        }
                    });
                    if (!foundError) {
                        AddProjectView.hideInlineErrorForKey();
                    }
                }
            }, this));
        },

        validateKey: function validateKey() {
            var key = AddProjectView.getKey();

            // Only validate the key if it has changed since the last time we validated it
            if (this.lastKeyValidated === key) {
                return;
            }

            if (key) {
                this.lastKeyValidated = key;
                this._performKeyValidationChecks(key);
            } else {
                AddProjectView.hideInlineErrorForKey();
            }
        },

        nameTimeout: function nameTimeout() {
            this.autofillKeyIfNeeded();
        },

        keyTimeout: function keyTimeout() {
            AddProjectView.setKeyEdited();
        },

        _getExistingProjects: function () {
            // Avoid retrieving the list twice (e.g. after hitting the 'Back' button and selecting new template)
            if (this.projectNamesUpperCased.length > 0) {
                return this.projectNamesUpperCased;
            }

            var existingProjectsDeferred = $.ajax({
                url: contextPath + "/rest/api/latest/project"
            });

            existingProjectsDeferred.done(_.bind(function (projects) {
                this.projectNamesUpperCased = _.map(projects, function (project) {
                    return project.name.toUpperCase();
                });
            }, this));
        }
    });
});
define('jira/project-templates/add-project-controller', [
    'jira/project-templates/add-project-controller-impl',
    'jquery'
], function(
    AddProjectControllerImpl,
    $
){
    return new AddProjectControllerImpl({el: $(document)});
});
AJS.namespace('JPT.AddProjectController', null, require('jira/project-templates/add-project-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/TemplateInfoView.js' */
// Warning!
// This module has a hidden circular dependency -> jira/project-templates/template-info-controller
define('jira/project-templates/template-info-view', [
    'jira/project-templates/dialog-controller',
    'require',
    'backbone',
    'jquery',
    'underscore'
], function(
    DialogController,
    require,
    Backbone,
    $,
    _
){
    var trigger = AJS.trigger;

    return Backbone.View.extend({

        initialize: function(options) {
            _.bindAll(this, "draw", "onNext")
        },

        draw: function(templatePath, name) {
            var page = DialogController.addPage({
                name: "template-info",
                title: name,
                panelName: "template-info",
                backButton: true,
                submitButtonText: "Select",
                submitButtonCallback: this.onNext,
                submitButtonClass: "template-info-dialog-create-button"
            });

            var templateInfoPanel = this._nameToObj(templatePath)();
            DialogController.dialog.getPanel(page.id, 0).html(templateInfoPanel);

            DialogController.dialog.gotoPage(page.id);
        },

        _nameToObj: function(name) {
            return _.reduce(name.split('.'), function(obj, name) { if (obj) return obj[name]; }, window);
        },

        onNext: function(e) {
            trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.templateinfo.next'});
            // This is a workaround to resolve circular dependencies between these two modules.
            var TemplateInfoController = require('jira/project-templates/template-info-controller');
            TemplateInfoController.next();
            return false;
        }
    });
});
AJS.namespace('JPT.TemplateInfoView', null, require('jira/project-templates/template-info-view'));
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/TemplateInfoController.js' */

define('jira/project-templates/template-info-controller', [
    'jira/project-templates/template-info-view',
    'jira/lib/class',
    'require',
    'underscore'
], function(
    TemplateInfoView,
    Class,
    require,
    _
){
    var TemplateInfoController = Class.extend({

        init: function(options) {
            _.bindAll(this, "initTemplateInfo", "next");
        },

        initTemplateInfo: function(projectTemplateData) {
            this.projectTemplateData = projectTemplateData;

            var infoView = new TemplateInfoView();
            infoView.draw(projectTemplateData.infoSoyPath, projectTemplateData.name);
        },

        next: function() {
            var SelectProjectTemplateController = require('jira/project-templates/select-project-template-controller');
            SelectProjectTemplateController.openAddProjectPage(this.projectTemplateData);
        }
    });
    return new TemplateInfoController();
});
AJS.namespace('JPT.TemplateInfoControllerImpl', null, require('jira/project-templates/template-info-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/SelectProjectTemplateView.js' */
// Warning!
// This module has a hidden circular dependency -> jira/project-templates/select-project-template-controller
define('jira/project-templates/select-project-template-view', [
    'jira/project-templates/dialog-controller',
    'jira/project-templates/config',
    'jira/featureflags/feature-manager',
    'require',
    'backbone',
    'jquery',
    'underscore'
], function(
    DialogController,
    Config,
    featureManager,
    require,
    Backbone,
    $,
    _
){
    var contextPath = AJS.contextPath();
    var preventDefault = AJS.preventDefault;

    return {
        ROW_LENGTH: 2,
        DIALOG_BODY_CLASS: "select-project-templates-page",
        DIALOG_WIDTH: 800,

        draw: function(data, projectType) {
            var SelectProjectTemplateController = require('jira/project-templates/select-project-template-controller');
            this.page = DialogController.addPage({
                name: this.DIALOG_BODY_CLASS,
                title: data.demoProjects ? "Create project with sample data" : "Create project",
                panelName: "ProjectTemplatesListPanel",
                backButton: false,
                submitButtonText: "Next",
                submitButtonCallback: SelectProjectTemplateController.dialogSubmitted,
                submitButtonClass: "create-project-dialog-create-button"
            });

            function getHtml() {
                if (SelectProjectTemplateController.isProjectTypesEnabled(data)) {
                    return JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType({
                        projectTemplatesByType: data.projectTemplatesGroupedByType
                    });
                }
                return JIRA.Templates.ProjectTemplates.renderProjectTemplates({
                    projectTemplates: data.projectTemplates
                });
            }

            DialogController.dialog.getPanel(this.page.id, 0).html(getHtml());

            if (Config.model.projectCount >= 2 && !data.demoProjects) {
                $(JIRA.Templates.ProjectTemplates.addWorkflowsLink({
                    baseUrl : contextPath
                })).appendTo(DialogController.$dialogElement.find(".dialog-title"));
            }

            var $nextButton = DialogController.$dialogElement.find(".create-project-dialog-create-button");
            var self = this;
            this.getTemplateItems().click(function() {
                var $this = $(this);
                $this.addClass("selected");
                self.getTemplateItems().not(this).removeClass("selected");
            }).dblclick(function() {
                $nextButton.click();
            }).focus(function () {
                $(this).click();
            });

            var $templatesContainer = this.get$TemplatesContainer();

            if (!data.demoProjects) {
                $(JIRA.Templates.ProjectTemplates.footerLinks({
                    showDemoLink: featureManager.isFeatureEnabled("jira.onboarding.cyoa")
                }))
                        .prependTo(DialogController.$dialogElement.find(".dialog-button-panel"));
            }

            this.bindKeyboardEvents($templatesContainer);

            if(SelectProjectTemplateController.isProjectTypesEnabled(data)) {
                if((data.projectTemplatesGroupedByType).length == 0) $nextButton.attr("disabled", "disabled");
            } else {
                if((data.projectTemplates).length == 0) $nextButton.attr("disabled", "disabled");
            }

            this.focusOnFirstTemplate($templatesContainer, projectType);

            DialogController.dialog.updateHeight();
            this.truncateTemplateDescriptions();
            this.resizeTemplateWidths();
        },

        get$TemplatesContainer: function() {
            return DialogController.$dialogElement.find('.templates');
        },

        focusOnFirstTemplate: function($templatesContainer, projectType) {
            if (projectType) {
                this.getFirstTemplateItemOfProjectType(projectType).click();
            } else {
                this.getFirstTemplateItem().click();
            }
            // Make sure me don't loose the focus because of any other interactions
            setTimeout(function (){
                $templatesContainer.focus();
            }, 0);
        },

        getSelectedTemplateData: function() {
            var $selectedTemplate = DialogController.$dialogElement.find(".template.selected");

            return $selectedTemplate.data();
        },

        /**
         * Converts arrow directions into sibling movement amounts in a grid.
         * @param which - the code of the key pressed
         * @return {Number} the amount to move, or 0 if no move should occur for this key code
         */
        getMoveDeltaForKey: function (which) {
            switch (which) {
                case 37: return -1; // left
                case 39: return +1; // right
                case 38: return -this.ROW_LENGTH; // up
                case 40: return +this.ROW_LENGTH; // down
            }
            return 0;
        },

        /**
         * Key-bindings on arrow-keys to change the selected template in the template container.
         */
        bindKeyboardEvents: function ($container) {
            $container.bind("keydown", _.bind(function (e) {
                var delta = this.getMoveDeltaForKey(e.which);
                if (delta) {
                    this.moveSelection($container, delta);
                    return preventDefault(e);
                }
            }, this));
        },

        /**
         * Move the selection in the template container forward or backward by a specified number of templates
         * @param container the template container jQuery object
         * @param delta - positive to move forward, negative to move backward
         */
        moveSelection: function (container, delta) {
            var $results = container.find('.template');
            var $selected = $results.filter('.selected');
            var index = $results.index($selected) + delta;
            if (index < $results.length && index >= 0) {
                var $next = $results.eq(index);
                $next.click().focus();

                this.scrollToSelectedElement($next);
            }
        },

        scrollToSelectedElement: function($selected) {
            var $itemContainer = $(".dialog-panel-body.pt-content");
            var itemContainerTopPosition = $itemContainer.offset().top;
            var nextTopPosition = $selected.offset().top;
            var nextBottomPosition = nextTopPosition + $selected.height();
            var itemContainerBottomPosition = itemContainerTopPosition + $itemContainer.height();

            if (nextTopPosition < itemContainerTopPosition) {
                $itemContainer.scrollTop($itemContainer.scrollTop() - (itemContainerTopPosition - nextTopPosition));
            } else if(nextBottomPosition > (itemContainerTopPosition + $itemContainer.height())) {
                $itemContainer.scrollTop($itemContainer.scrollTop() + nextBottomPosition - itemContainerBottomPosition);
            }
        },

        get$NextButton: function() {
            return DialogController.$dialogElement.find(".create-project-dialog-create-button");
        },

        disableNextButton: function() {
            this.get$NextButton().attr('disabled','disabled');
        },

        truncateTemplateDescriptions: function() {
            var locale = AJS.Meta.get("user-locale");
            var wrap = "word";
            if (locale === "ja_JP") {
                wrap = "letter";
            }
            DialogController.$dialogElement.find(".template-description").each(function() {
                $(this).dotdotdot({
                    'wrap': wrap,
                    'lastCharacter': {
                        'remove'		: [ ' ', ',', ';', '.', '!', '?', 'ã' ],
                        'noEllipsis'	: []
                    }
                });
            });
        },

        getTemplatesDialogContainer: function() {
            return DialogController.$dialogElement
                    .find("." + this.DIALOG_BODY_CLASS)
                    .find(".dialog-panel-body.pt-content")
                    .get(0);
        },

        getFirstTemplateItem: function() {
            return this.getTemplateItems().first();
        },

        getFirstTemplateItemOfProjectType: function(projectType) {
            return this.getTemplateItems().filter("#project-template-group-" + projectType + " *").first();
        },

        getTemplateItems: function() {
            return DialogController.$dialogElement.find(".template");
        },

        widthOfScrollbarForElement: function(el) {
            var visibleWidth = el.offsetWidth;
            var visibleWidthWithoutBorders = el.clientWidth;

            return visibleWidth - visibleWidthWithoutBorders;
        },

        widthOfDialogAvailableForTemplateList: function() {
            var dialogScrollbarWidth = this.widthOfScrollbarForElement(this.getTemplatesDialogContainer());

            return this.DIALOG_WIDTH - dialogScrollbarWidth;
        },

        widthOfTemplateItem: function() {
            var maxWidthForEachItem = this.widthOfDialogAvailableForTemplateList() / this.ROW_LENGTH;

            return maxWidthForEachItem - this.borderWidthOfTemplateItem();
        },

        borderWidthOfTemplateItem: function() {
            var templateItemBorderWidthString = this.getFirstTemplateItem().css("border-top-width");

            return parseInt(templateItemBorderWidthString, 10);
        },

        resizeTemplateWidths: function() {
            this.getTemplateItems().each(_.bind(function(index, el) {
                $(el).css("width", this.widthOfTemplateItem());
            }, this));
        }
    };
});
AJS.namespace('JPT.SelectProjectTemplateView', null, require('jira/project-templates/select-project-template-view'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/SelectProjectTemplateController.js' */
define('jira/project-templates/select-project-template-controller', [
    'jira/project-templates/select-project-template-view',
    'jira/project-templates/template-info-controller',
    'jira/project-templates/add-project-controller',
    'jira/project-templates/dialog-controller',
    'jira/project-templates/dialog-view',
    'jira/project-templates/config',
    'wrm/context-path',
    'jquery',
    'underscore'
], function(
    SelectProjectTemplateView,
    TemplateInfoController,
    AddProjectController,
    DialogController,
    DialogView,
    Config,
    ContextPath,
    $,
    _
){
    var contextPath = ContextPath();
    var SelectProjectTemplateController = {
        init: function init(data, projectTypeKey) {
            SelectProjectTemplateView.draw(data, projectTypeKey);
        },

        /**
         * Returns true if project types have been enabled on the server.
         * @param data the model returned by the server
         * @returns {boolean} true if project types have been enabled on the server.
         */
        isProjectTypesEnabled: function isProjectTypesEnabled(data) {
            return data.projectTemplatesGroupedByType != null;
        },

        /**
         * Return a Promise that others can hook into that returns the data required.
         */
        loadProjectTemplatesData: function loadProjectTemplatesData() {
            // Perform AJAX request for web items in the dialog and return them.
            return $.ajax({
                url: contextPath + "/rest/project-templates/1.0/templates",
                type: "GET"
            });
        },

        loadDemoProjectTemplatesData: function loadProjectTemplatesData() {
            // Perform AJAX request for web items in the dialog and return them.
            return $.ajax({
                url: contextPath + "/rest/project-templates/1.0/templates/demo-projects",
                type: "GET"
            }).then(function(result) {
                result.demoProjects = true;
                return result;
            });
        },

        dialogSubmitted: function dialogSubmitted() {
            var projectTemplateData = SelectProjectTemplateView.getSelectedTemplateData();

            DialogController.hideDialogFromNewUser("templateselected");

            SelectProjectTemplateController.raiseAtlassianEvent(projectTemplateData.itemModuleCompleteKey);

            if (!_.isUndefined(projectTemplateData.infoSoyPath)) {
                TemplateInfoController.initTemplateInfo(projectTemplateData);
            } else {
                SelectProjectTemplateController.openAddProjectPage(projectTemplateData);
            }
        },

        openAddProjectPage: function openAddProjectPage(projectTemplateData) {
            if (!projectTemplateData) {
                // Null data? How did you get here? It should be impossible to have no selected item.
                DialogView.showErrorMessage("An error occurred while trying to contact JIRA");
                return;
            }

            // Should the template key be missing, go to the project configuration step
            if (projectTemplateData.createProject) {
                AddProjectController.initProjectTemplate(projectTemplateData);
                // Otherwise, no template key provided: fire an event passing the dialog, so the plugin can choose what to do next
            } else {
                DialogController.dialog.addPage("blank-template-page");
                $("body").trigger(projectTemplateData.itemModuleCompleteKey, DialogController.dialog);
            }
        },

        raiseAtlassianEvent: function raiseAtlassianEvent(projectTemplateModuleKey) {
            Config.model.selectedTemplate = projectTemplateModuleKey;
            if (AJS.EventQueue) {
                AJS.EventQueue.push({
                    name: "projecttemplates.templateselected",
                    properties: {
                        selectedTemplate: projectTemplateModuleKey
                    }
                });
            }
        }
    };
    return SelectProjectTemplateController;
});
AJS.namespace('JPT.SelectProjectTemplateController', null, require('jira/project-templates/select-project-template-controller'));
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/CreateSharedView.js' */
// Warning!
// This module has a hidden circular dependency -> jira/project-templates/create-shared-controller
define('jira/project-templates/create-shared-view', [
    'jira/project-templates/dialog-controller',
    'jira/project-templates/dialog-view',
    'jira/ajs/select/scrollable-single-select',
    'jira/ajs/select/suggestion-collection-model',
    'require',
    'backbone',
    'jquery'
], function(
    DialogController,
    DialogView,
    ScrollableSingleSelect,
    SuggestionCollectionModel,
    require,
    Backbone,
    $
){
    "use strict";

    var InlineDialog = AJS.InlineDialog;
    var trigger = AJS.trigger;

    var CreateSharedView = Backbone.View.extend({
        events: {
            "submit #create-shared-project-form": "onSubmitForm"
        },

        page: undefined,

        /**
         * Prepare the Dialog to hold the Create Shared Project form; this should only be called once.
         */
        prepareDialog: function(title) {
            var CreateSharedController = require('jira/project-templates/create-shared-controller');
            this.page = DialogController.addPage({
                name: "create-shared-project",
                title: title,
                panelName: "create-shared-project",
                backButton: true,
                submitButtonText: "Next",
                submitButtonCallback: CreateSharedController.dialogSubmitted,
                submitButtonClass: "create-shared-dialog-button"
            });
        },

        /**
         * Draw the Add Project form into the passed dialog, as a new screen.
         *
         * This will be triggered on clicking "Next", so should render on the second page.
         */
        draw: function(params) {
            DialogController.dialog.gotoPage(this.page.id);

            var createSharedForm = JIRA.Templates.ProjectTemplates.createSharedProjectForm({
                "projectSuggestions": JSON.stringify(params.projectSuggestions)
            });

            DialogController.dialog.getPanel(this.page.id, 0).html(createSharedForm);

            this._createProjectPicker();

            var $sharedHelpElement = DialogController.$dialogElement.find("#shared-help-icon");
            if ($sharedHelpElement.length) {
                new InlineDialog($sharedHelpElement, "shared-project-help-popup",
                        function(contents, trigger, show) {
                            contents.html(JIRA.Templates.ProjectTemplates.sharedHelp());
                            show();
                        }, {
                            width: 330,
                            offsetX: -30
                        });
            }

            DialogController.$dialogElement.find(".dialog-button-panel button").removeAttr("disabled");
        },

        showProjectMissingError: function () {
            this._clearFormErrors();

            this._getProjectPickerInput().after(aui.form.fieldError({
                extraClasses: 'project-picker-missing-error',
                message: "Please select an existing project first."
            }));
        },

        drawEmptyInfo: function() {
            var noProjects = JIRA.Templates.ProjectTemplates.noProjects();
            DialogController.dialog.getPanel(this.page.id, 0).html(noProjects);

            DialogController.$dialogElement.find(".dialog-button-panel button").hide();
        },

        drawError: function(message) {
            DialogController.dialog.getPanel(this.page.id, 0).html(JIRA.Templates.errorMsg({
                closable: false,
                msg: message
            }));
        },

        drawLoading: function() {
            DialogController.dialog.gotoPage(this.page.id);

            var addProjectForm = JIRA.Templates.ProjectTemplates.loading();

            DialogController.dialog.getPanel(this.page.id, 0).html(addProjectForm);

            DialogController.$dialogElement.find(".dialog-spinner").spin();
            DialogController.$dialogElement.find(".dialog-button-panel button").attr("disabled", "disabled");
        },

        _clearFormErrors: function() {
            DialogController.$dialogElement.find(".project-picker-missing-error").remove();
        },

        _getProjectPickerInput: function() {
            return DialogController.$dialogElement.find("#project-picker");
        },

        onSubmitForm: function(e) {
            this._clearFormErrors();
            var CreateSharedController = require('jira/project-templates/create-shared-controller');
            CreateSharedController.dialogSubmitted();
            return false;
        },

        _getExtraInfoMessage: function() {
            return DialogController.$dialogElement.find(".create-shared-info");
        },

        _createProjectPicker: function() {
            this._getExtraInfoMessage().hide();
            this.projectSelect = new ScrollableSingleSelect({
                element: this._getProjectPickerInput(),
                revertOnInvalid: true,
                pageSize: 50,
                pagingThreshold: 100,
                model: SuggestionCollectionModel
            });

            this.projectSelect.$field.focus();

            var self = this;
            this._getProjectPickerInput().on("selected", function(e, selected) {
                if(selected.value()) {
                    trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.shared.project.selected'});
                    self._getExtraInfoMessage().show();
                }
            });
        },

        getSelectedProject: function() {
            return this.projectSelect.getSelectedDescriptor() && this.projectSelect.getSelectedDescriptor().value();
        }
    });

    return new CreateSharedView({
        el: $(document),
        dialogView: DialogView
    });
});
AJS.namespace('JPT.CreateSharedView', null, require('jira/project-templates/create-shared-view'));
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/CreateSharedController.js' */
define('jira/project-templates/create-shared-controller-impl', [
    'jira/project-templates/add-project-controller',
    'jira/project-templates/create-shared-view',
    'jira/lib/class',
    'jquery',
    'underscore'
], function(
    AddProjectController,
    CreateSharedView,
    Class,
    $,
    _
) {
    "use strict";

    var contextPath = AJS.contextPath();

    return Class.extend({

        init: function (options) {
            this._window = options.window || window; // used for mocking 'window' in QUnit
            _.bindAll(this, "dialogSubmitted");
        },

        initCreateShared: function () {
            CreateSharedView.prepareDialog("Create with shared configuration");

            var self = this;
            this._getProjectSuggestions().done(function (resp) {
                if (self._hasSuggestions(resp)) {
                    CreateSharedView.draw({projectSuggestions: resp});
                } else {
                    CreateSharedView.drawEmptyInfo();
                }
            }).fail(function () {
                CreateSharedView.drawError("An error occurred while trying to contact JIRA");
            });

            CreateSharedView.drawLoading();
        },

        _hasSuggestions: function (projectSuggestions) {
            var hasSuggestions = false;
            $.each(projectSuggestions, function (i, group) {
                if (group && group.items && group.items.length > 0) {
                    hasSuggestions = true;
                }
            });
            return hasSuggestions;
        },

        _getProjectSuggestions: function () {
            return $.ajax({
                url: contextPath + "/rest/project-templates/1.0/createshared"
            });
        },

        dialogSubmitted: function () {
            var selectedProject = CreateSharedView.getSelectedProject();
            if (selectedProject) {
                AddProjectController.initCreateShared({existingProjectId: selectedProject});
            } else {
                CreateSharedView.showProjectMissingError();
            }
        }
    });
});
define('jira/project-templates/create-shared-controller', [
    'jira/project-templates/create-shared-controller-impl',
    'jquery'
], function(
    CreateSharedControllerImpl,
    $
){
    return new CreateSharedControllerImpl({el: $(document)});
});
AJS.namespace('JPT.CreateSharedController', null, require('jira/project-templates/create-shared-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/RemoteProjectsCreatedMessage.js' */
var $ = require('jquery');
$(function () {

    var format = AJS.format;
    var AddProjectController = require('jira/project-templates/add-project-controller');

    var confluenceProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "confluenceProject");
    var fishEyeProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "fisheyeProject");
    var crucibleProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "crucibleProject");
    var bambooProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "bambooProject");

    localStorage.removeItem(AddProjectController.localStoragePrefix + "confluenceProject");
    localStorage.removeItem(AddProjectController.localStoragePrefix + "fisheyeProject");
    localStorage.removeItem(AddProjectController.localStoragePrefix + "crucibleProject");
    localStorage.removeItem(AddProjectController.localStoragePrefix + "bambooProject");

    var message;
    function formatAnchor(link, label) {
        return JIRA.Templates.ProjectTemplates.formatAnchor({
            href: link,
            body: label,
            title: label
        });
    }
    function createProjectLinks(confluenceProjectLink, fecruProjectLink, crucibleProjectLink, bambooProjectLink) {
        var links = [];
        links.push("a JIRA project");
        if (confluenceProjectLink) {
            links.push(formatAnchor(confluenceProjectLink, "a Confluence space"));
        }
        if (fecruProjectLink) {
            links.push(formatAnchor(fecruProjectLink, "a FishEye repository"));
        }
        if (crucibleProjectLink) {
            links.push(formatAnchor(crucibleProjectLink, "a Crucible project"));
        }
        if (bambooProjectLink) {
            links.push(formatAnchor(bambooProjectLink, "a Bamboo project"));
        }
        return links;
    }
    function createMessage(confluenceProjectLink, fecruProjectLink, crucibleProjectLink, bambooProjectLink) {
        var title = "The following entities were created: {0} and {1}.";
        var projectLinks = createProjectLinks(confluenceProjectLink, fecruProjectLink, crucibleProjectLink, bambooProjectLink);
        var lastLink = projectLinks.pop();
        return (projectLinks.length > 0) ? format(title, projectLinks.join(", "), lastLink) : null;
    }
    function scrollTo(selector) {
        var settingsOffset = $(selector).offset();
        if (settingsOffset) {
            window.scrollTo(settingsOffset.left, settingsOffset.top);
        }
    }

    if (confluenceProjectLink || fishEyeProjectLink || crucibleProjectLink || bambooProjectLink) {
        message = createMessage(confluenceProjectLink, fishEyeProjectLink, crucibleProjectLink, bambooProjectLink);
        if (message) {
            JIRA.Messages.showSuccessMsg(message, {
                closeable:true
            });
        }
        scrollTo("#project-config-webpanel-summary-settings");
    }
});;
;
/* module-key = 'com.atlassian.plugins.jira-project-creation:project-creation-resources', location = '/js/lib/ajaxHooks/xdr.js' */
/**
 Copyright 2012 Julian Aubourg <j@ubourg.net>

 https://github.com/jaubourg/ajaxHooks

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
if ( window.XDomainRequest ) {
    jQuery.ajaxTransport(function( s ) {
        if ( s.crossDomain && s.async ) {
            if ( s.timeout ) {
                s.xdrTimeout = s.timeout;
                delete s.timeout;
            }
            var xdr;
            return {
                send: function( _, complete ) {
                    function callback( status, statusText, responses, responseHeaders ) {
                        xdr.onload = xdr.onerror = xdr.ontimeout = jQuery.noop;
                        xdr = undefined;
                        complete( status, statusText, responses, responseHeaders );
                    }
                    xdr = new XDomainRequest();
                    xdr.onload = function() {
                        callback( 200, "OK", { text: xdr.responseText }, "Content-Type: " + xdr.contentType );
                    };
                    xdr.onerror = function() {
                        callback( 404, "Not Found" );
                    };
                    xdr.onprogress = jQuery.noop;
                    xdr.ontimeout = function() {
                        callback( 0, "timeout" );
                    };
                    xdr.timeout = s.xdrTimeout || Number.MAX_VALUE;
                    xdr.open( s.type, s.url );
                    xdr.send( ( s.hasContent && s.data ) || null );
                },
                abort: function() {
                    if ( xdr ) {
                        xdr.onerror = jQuery.noop;
                        xdr.abort();
                    }
                }
            };
        }
    });
};
;
/* module-key = 'com.atlassian.plugins.jira-project-creation:project-creation-resources', location = '/js/project-creation.js' */
ATLAS_PROJECT_CREATE = {};

(function ($) {

    AJS.EventQueue = AJS.EventQueue || [];

    var JIRA_PROJECT_CAPABILITY_KEY = 'jira.project';

    //This will most likely be added to the SPI in future versions
    var CAPABILITY_WEIGHT = {
        "confluence.space" : 30,
        "bamboo.project" : 20,
        "ondemand.svn-repository" : 10
    };

    ATLAS_PROJECT_CREATE.getFilteredRootTypes = function getFilteredRootTypes(response) {
        var types = {};
        for (var key in response.types) {
            if (key !== JIRA_PROJECT_CAPABILITY_KEY) {
                types[key] = response.types[key];
            }
        }
        return types;
    };

    ATLAS_PROJECT_CREATE.loadRemoteRoots = function loadRemoteRoots(capabilities) {
        var deferred = jQuery.Deferred(),
            innerPromises = [],
            rootTypes = [];

        // map each capability to the promise of an ajax call, when they're all done innerpromises will contain an array of promises, one for each
        // inner ajax call made. Once this outer mega-promise is resolved, we can create a new mega-promise out of the contents of innerPromises.
        // Once that mega-promise is resolved we can resolve the outside visible promise (projectCreationPromise), passing in the gathered root types.
        mapToPromise(capabilities,function (capability) {
            var baseUrl = capability.capabilitiesUrl;
            return AJS.$.ajax(baseUrl + '/aggregate-root', {
                success: function (response) {
                    var types = ATLAS_PROJECT_CREATE.getFilteredRootTypes(response);
                    innerPromises = innerPromises.concat(_.map(types, function (type, key) {
                        return AJS.$.ajax(type.href, {
                            xhrFields: {
                                withCredentials: true
                            },
                            success: function (rootType) {
                                rootTypes.push(ATLAS_PROJECT_CREATE.constructFullRootType(rootType, type.label, key, baseUrl, capability.id));
                            },
                            error: function (xhr, status, errorThrown) {
                                AJS.log('Got ' + errorThrown + ' from aggregate root type ' + type.href);
                            }
                        }).promise();
                    }));
                }, error: function (xhr, status, errorThrown) {
                    // TODO ROTP-1146 ROTP-1147: handle 401, 403 better
                    AJS.log('Got ' + errorThrown + ' from aggregate roots capapbility for ' + baseUrl);
                }
            }).promise();
        }).done(function () {
                promiseFromPromiseList(innerPromises).done(function () {
                    deferred.resolve(rootTypes);
                });
            });
        return deferred.promise();
    };

    ATLAS_PROJECT_CREATE.constructFullRootType = function constructFullRootType(rootType, label, capabilityKey, baseUrl, instanceId) {
        return {
            keys: rootType.keys,
            url: rootType.links.self,
            label: label,
            capabilityKey: capabilityKey,
            baseUrl: baseUrl,
            instanceId: instanceId
        };
    };

    ATLAS_PROJECT_CREATE.createLink = function createLink(linkDetails, complete) {
        console.log("creating link from " + linkDetails.entityType + " to " + linkDetails.remoteEntityType);
        var linkRequest = JSON.stringify({
            "local": linkDetails.baseUrl + "/aggregate-root/" + linkDetails.entityType + "/" + linkDetails.entityKey,
            "target": linkDetails.remoteInstanceBaseUrl + "/aggregate-root/" + linkDetails.remoteEntityType + "/" + linkDetails.remoteEntityKey
        });
        AJS.$.ajax(linkDetails.baseUrl + "/aggregate-root-link", {
            type: "POST",
            contentType: "application/json",
            data: linkRequest,
            timeout: 8000,
            complete: complete
        });
    };


    ATLAS_PROJECT_CREATE.linkAllTheThings = function linkAllTheThings(dialog, createdThings, projectKey, projectCreationPage, acknowledgeButton) {

        var linksToCreate = [];
        $.each(createdThings, function createLinks(idx, entity) {
            linksToCreate.push({
                baseUrl: entity.type.baseUrl,
                entityType: entity.type.capabilityKey,
                entityKey: entity.data.key,
                remoteInstanceBaseUrl: getAppBaseUrl() + "/rest/capabilities",
                remoteEntityType: JIRA_PROJECT_CAPABILITY_KEY,
                remoteEntityKey: projectKey
            });

            linksToCreate.push({
                baseUrl: getAppBaseUrl() + "/rest/capabilities",
                entityType: JIRA_PROJECT_CAPABILITY_KEY,
                entityKey: projectKey,
                remoteInstanceBaseUrl: entity.type.baseUrl,
                remoteEntityType: entity.type.capabilityKey,
                remoteEntityKey: entity.data.key
            });

            AJS.$.each(createdThings, function createLinkBetweenRemoteEntities(targetIdx, targetEntity) {
                //first check we are not trying to link something to itself or something else in the same instance
                if (targetEntity !== entity) {
                    linksToCreate.push({
                        baseUrl: entity.type.baseUrl,
                        entityType: entity.type.capabilityKey,
                        entityKey: entity.data.key,
                        remoteInstanceBaseUrl: targetEntity.type.baseUrl,
                        remoteEntityType: targetEntity.type.capabilityKey,
                        remoteEntityKey: targetEntity.data.key
                    });
                }
            });
        });

        //TODO ROTP-992 : Doesn't need to be serialized once applinks fixes up race condition
        var numErrors = 0;

        function createNext(xhr, status) {
            if (status !== "success") {
                numErrors++;
                // render the error message
                var errorMessage = xhr.statusText;
                try {
                    var data = JSON.parse(xhr.responseText);
                    if (data && data.message) {
                        errorMessage = data.message;
                    }
                } catch (err) {

                }
                AJS.messages.error(".li-linking-status", {
                    title: "Could not create links between created projects",
                    body: errorMessage
                });
                dialog.updateHeight();
            }
            if (linksToCreate.length > 0) {
                ATLAS_PROJECT_CREATE.createLink(linksToCreate.pop(), createNext);
            } else {
                if (numErrors > 0) {
                    projectCreationPage.find(".linking-status").html('<span class="aui-icon aui-icon-small aui-iconfont-error">' + "Error" + '</span>');
                } else {
                    projectCreationPage.find(".linking-status").html('<span class="aui-icon aui-icon-small aui-iconfont-success">' + "Success" + '</span>');
                }
                acknowledgeButton.prop("disabled", false);
                acknowledgeButton.attr('aria-disabled', 'false');
            }
        }

        createNext(null, "success");
    };

    var remoteRootsPromise;

    function bindRemoteRootsPromise(promise, getDialog, onCheckboxChange) {
        var dialog = getDialog();
        $.when(promise).then(
            // success handler
            function (types) {
                dialog.getCurPanel().body.find('.field-group.loading').remove();

                types.sort(sortCapabilities);
                if (types.length !== 0) {
                    var projectCreateForm = dialog.getCurPanel().body.find('form');
                    projectCreateForm.append(project.creation.remoteRootsCheckboxes({rootTypes: types}));
                    if (onCheckboxChange) {
                        projectCreateForm.find('input[type="checkbox"]').filter('.remote-root').change(onCheckboxChange);
                    }

                    dialog.updateHeight();
                }

                enableSubmitBtn(dialog, true);
            },
            // fail handler
            function () {
                dialog.getCurPanel().body.find('.field-group.loading').remove();
                enableSubmitBtn(dialog, true);
                dialog.updateHeight();
                // the provided promise only ever resolves. This shouldn't happen, but if something explodes it should
                // be enough to just revert back to default JIRA behaviour.
            }
        );
    }

    var panel;

    function setupProjectCreationIntegration(getDialog, onCheckboxChange) {
        var dialog = getDialog();
        //Store a ref to the panel for use in some promises
        panel = dialog.getCurPanel();
        // Attach some info and a spinner below Project Create name & key entry
        panel.body.find('form').append(project.creation.remoteRootsLoading({}));

        enableSubmitBtn(dialog, false);
        dialog.updateHeight();

        //Make sure the height is good again when the user hits back
        panel.page.element.find(".add-project-back-button").click(function() {
            dialog.updateHeight();
        });


        initRemoteRoots(bindRemoteRootsPromise, getDialog, onCheckboxChange);
    }

    function getSelectedTypes(types) {
        var selectedCheckboxes = _.filter(panel.body.find("input.remote-root.checkbox"), function (checkbox) {
            return checkbox.checked === true;
        });
        var selectedTypeIds = _.map(selectedCheckboxes,
            function (input) {
                return input.id;
            });
        return _.filter(types, function (type) {
            return _.contains(selectedTypeIds, 'capability_' + type.capabilityKey);
        });
    }

    var userMetaTag = AJS.$('meta[name="ajs-remote-user"]');
    // if we neither got a user tag, or it had no content then bail out.
    if (!userMetaTag || !userMetaTag[0] || !userMetaTag[0].content) {
        console.log("Project create didn't get a user META tag, or it had no content.  Bailing out");
        return;
    }

    // if the dark feature is disabled, return here.
    if (!AJS.DarkFeatures.isEnabled("rotp.project.create")) {
        return;
    }

    var postProjectCreationCallback = function postProjectCreationCallback(dialog, redirectFn, projectId, projectKey, projectName) {
        var callRedirectFn = function callRedirectFn(redirectFn, acknowledgeButton) {
            acknowledgeButton.prop("disabled", true);
            acknowledgeButton.attr('aria-disabled', 'true');
            acknowledgeButton.before('<span class="aui-icon aui-icon-wait project-creation-acknowledge-spinner">' + "Loading, please wait" + '</span>');
            redirectFn();
        };

        $.when(remoteRootsPromise).then(
            function (types) {
                var selectedTypes = getSelectedTypes(types);
                sendAnalytics(selectedTypes);

                if (selectedTypes.length === 0) {
                    //Make sure we don't show empty next page which is the default of project templates
                    dialog.prevPage();
                    redirectFn();
                    return;
                }

                createProjectCreationResultPanel(dialog, callRedirectFn, redirectFn);

                var templateData = [];
                var createdThings = [];
                mapToPromise(selectedTypes, function (type) {
                    var statusId = "creation_status_" + type.capabilityKey.replace(".", "_") + "_" + type.instanceId;
                    templateData.push({
                        statusId: statusId,
                        label: type.label
                    });

                    return AJS.$.ajax(type.url + "/" + projectKey, {
                        type: "PUT",
                        data: JSON.stringify({
                            label: projectName
                        }),
                        xhrFields: {
                            withCredentials: true
                        },
                        success: function (data) {
                            createdThings = createdThings.concat(processCreatedRoots(data, type));
                            renderCreatedRoots(data, statusId);
                        },
                        error: function (xhr, textStatus, errorThrown) {
                            renderErrorDuringRootCreation(statusId, type, xhr, errorThrown);
                        },
                        contentType: "application/json",
                        dataType: "json"
                    }).promise();
                }).always(function () {
                    renderErrorHeaderInCaseOfErrors(dialog);
                    console.log("about to begin linking created objects");
                    ATLAS_PROJECT_CREATE.linkAllTheThings(dialog,
                                                            createdThings,
                                                            projectKey,
                                                            AJS.$(".post-project-created-page-content"),
                                                            AJS.$(".project-create-acknowledge-button"));
                });

                AJS.$(".post-project-created-page-content").append(project.creation.remoteRootsSuccess({rootTypes: templateData}));
            }
        );
    };


    var checkIfKeyExists = function checkIfKeyExists(projectKey) {
        var duplicateFound;
        $.when(remoteRootsPromise).then(
            function (types) {
                var selectedTypes = getSelectedTypes(types);
                _.each(selectedTypes, function (type) {
                    if (type.keys) {
                        for (var key in type.keys) {
                            if (type.keys.hasOwnProperty(key)) {
                                if (projectKey.toUpperCase() === key.toUpperCase()) {
                                    duplicateFound = type;
                                }
                            }
                        }
                    }
                });
            });
        var response = {errors: {}};
        if (duplicateFound) {
            response.errors.projectKey = AJS.format("{0} with that key already exists in the remote instance", duplicateFound.label);
        }
        return response;
    };


    function getOrigin() {
        return window.location.origin ? window.location.origin : (window.location.protocol + '//' + window.location.host);
    }

    function getAppBaseUrl() {
        var baseUrl = getOrigin();
        return baseUrl + AJS.contextPath();
    }

    /**
     * Parse and return some components of a URL.
     * @param {string} url A URL, e.g. "http://google.com:80/a/b/c"
     * @returns {{host: string, protocol: string, port: string}}
     */
    function parseUrl(url) {
        var a = document.createElement('a');
        a.href = url;
        return {
            host: a.hostname,
            port: a.port,
            protocol: a.protocol.replace(':', '')
        };
    }

    /**
     * Determine if making a request from one URL to another would represent a security downgrade, and
     * as such be blocked by the browser.
     *
     * @param {string} origin The URL from which a request to *destination* is to be made.
     * @param {string} destination The destination URL.
     * @returns {boolean} true if origin uses https: and destination uses http:
     */
    function isSecurityDowngrade(origin, destination) {
        var aParts = parseUrl(origin);
        var bParts = parseUrl(destination);
        return aParts.protocol === "https" && bParts.protocol === "http";
    }

    function initRemoteRoots(fn, getDialog, onCheckboxChange) {
        AJS.$.ajax(getAppBaseUrl() + '/rest/capabilities/awareness', {
            type: "GET",

            /**
             * @param {{applications: object, links: {selfInstanceId: string} }} data
             */
            success: function parseAwarenessResponse(data) {
                // We need to be careful with what requests we make. Making a request from a HTTPS page to a HTTP
                // page will be blocked by the browser and will only fail after the timeout period has elapsed.
                var willTimeout = _.partial(isSecurityDowngrade, getOrigin());
                var capabilities = _
                    .chain(data.applications)
                    .map(function (details, url) {
                        return _.extend(details, {capabilitiesUrl: url});
                    })
                    .filter(function (details) {
                        return willTimeout(details.capabilitiesUrl) === false;
                    })
                    .value();

                //push an object in to gather any local capabilities
                capabilities.push({
                    id: data.links.selfInstanceId,
                    capabilitiesUrl: data.links.collection
                });

                remoteRootsPromise = ATLAS_PROJECT_CREATE.loadRemoteRoots(capabilities);
                selfInstanceId = data.links.selfInstanceId;
                if (typeof fn === 'function') {
                    fn(remoteRootsPromise, getDialog, onCheckboxChange);
                }
            },
            error: function (xhr, status, errorThrown) {
                // log & revert to vanilla JIRA behaviour.
                console.log("Project create error - error gathering roots from awareness capability");
                if (getDialog) {
                    $(getDialog().getCurPanel().page.element).find(".pt-submit-button").attr('aria-disabled', 'false');
                }
            }
        });
    }


    var selfInstanceId;
    var odFecruAwareness = null;

    // given a list<X> and a function fn : X -> promise returns a promise composed
    // of all the promises returned by applying fn to members of list
    function mapToPromise(list, fn) {
        var promises = _.map(list, fn);
        return promiseFromPromiseList(promises);
    }

    // given a list of promises, construct a new promise which fires done when all proivded promises have either been resolved or rejected.
    // NOTE: can not just be return $.when.apply(promises).promise() because that would reject when the first internal promise is rejected,
    // whereas we want the promise to fire after all are completed.
    // Again, NOTE: resolution of the returned promise will be empty. This should only be used when you want flow control,
    // data access should be by other means (or wrapped around one of these).
    function promiseFromPromiseList(promises) {
        var deferred = $.Deferred();
        var resolutionCount = 0;
        if (promises.length === 0) {
            deferred.resolve();
        } else {
            _.each(promises, function (promise) {
                promise.always(function () {
                    resolutionCount++;
                    if (resolutionCount === promises.length) {
                        deferred.resolve();
                    }
                });
            });
        }
        return deferred.promise();
    }

    function createProjectCreationResultPanel(dialog, callRedirectFn, redirectFn) {
        dialog.addPanel("title", "", "post-project-created-page-content");
        dialog.addHeader("Creating and linking companions for your JIRA project");
        dialog.addButton("All done!", function () {
            callRedirectFn(redirectFn, AJS.$(this));
        }, "project-create-acknowledge-button");

        AJS.$(".project-create-acknowledge-button").removeClass("button-panel-button")
            .addClass("aui-button aui-button-primary")
            .attr('aria-disabled', 'true')
            .prop('disabled', true);
    }

    function processCreatedRoots(data, type) {
        var createdThings = [];
        if (type.capabilityKey === "ondemand.svn-repository") {
            // TODO: Remove this special case when FeCru is removed from OnDemand
            // this is a hack to handle the fact that SVN repositories
            // are being created in JIRA.
            console.log("got back created SVN repository");
            createdThings.push({
                type: {
                    capabilityKey: "fecru.repository",
                    instanceId: odFecruAwareness.id,
                    baseUrl: odFecruAwareness.capabilitiesUrl
                },
                data: {
                    key: data.key
                }
            });
            createdThings.push({
                type: {
                    capabilityKey: "fecru.project",
                    instanceId: odFecruAwareness.id,
                    baseUrl: odFecruAwareness.capabilitiesUrl
                },
                data: {
                    key: "CR-" + data.key
                }
            });
        } else {
            console.log("got back created thing " + type.capabilityKey);
            var createdThing = {
                type: type,
                data: data
            };
            createdThings.push(createdThing);
        }

        return createdThings;
    }

    function renderCreatedRoots(data, statusId) {
        var statusBlock = AJS.$("." + statusId);
        statusBlock.empty(); //remove spinner
        statusBlock.append('<span class="aui-icon aui-icon-small aui-iconfont-success">' + "Success" + '</span>');
        if (data.links.resource) {
            var link = AJS.$("<a target='_blank'></a>");
            link.text(data.label);
            link.attr("href",data.links.resource);
            link.attr("title",data.label);
            statusBlock.closest('li').append(link);
        }
    }

    function renderErrorDuringRootCreation(statusId, type, xhr, errorThrown) {
        var statusBlock = AJS.$("." + statusId);
        statusBlock.empty(); //remove spinner
        statusBlock.append('<span class="aui-icon aui-icon-small aui-iconfont-error">' + "Error" + '</span>');
        var errorMessage = errorThrown;
        if (xhr && xhr.responseText) {
            try {
                var data = JSON.parse(xhr.responseText);
                if (data && data.message) {
                    errorMessage = data.message;
                }
            } catch (err) {
                // swallow syntax error if response is not valid JSON and display the response text as error
                errorMessage = xhr.responseText;
            }
        }

        AJS.messages.error(".li-" + statusId, {
            title: AJS.format("Could not create {0}", type.label),
            body: errorMessage
        });
    }

    function renderErrorHeaderInCaseOfErrors(dialog) {
        // if we have any errors, add a helpful message
        var currentPanel = dialog.getCurrentPanel();
        if (currentPanel.body.find('.aui-message.error').size() !== 0) {
            AJS.messages.warning('.project-creation-success', {
                title: "We were unable to create everything you requested",
                body: '<p>' + "However, you can create them yourself and manually set up links." + '</p>'
            });

            dialog.updateHeight();
        }
    }

    function sendAnalytics(selectedTypes) {
        var capabilityKeys = _.map(selectedTypes, function (type) { return type.capabilityKey;});
        var analyticsValue = (capabilityKeys.length == 0) ? "none" : capabilityKeys.sort().join('_');

        AJS.EventQueue.push({name: 'project.create.aggregateroots.selected', properties: {capabilitykeys: analyticsValue}});
    }

    function enableSubmitBtn(dialog, enabled) {
        $(dialog.getCurPanel().page.element).find(".pt-submit-button").attr('aria-disabled', !enabled);
    }

    function sortCapabilities(capabilityA, capabilityB) {
        return getCapabilityWeight(capabilityB.capabilityKey) - getCapabilityWeight(capabilityA.capabilityKey);
    }

    function getCapabilityWeight(capabilityKey) {
        return _.has(CAPABILITY_WEIGHT, capabilityKey) ? CAPABILITY_WEIGHT[capabilityKey] : 0;
    }



    JPT.AddProjectController.registerProjectKeyValidationCallback(checkIfKeyExists);

    var getJptDialog = function getJptDialog() {
        return JPT.DialogView.dialog || JPT.DialogView._dialog;
    };
    var onJptCheckboxChange = function onJptCheckboxChange() {
        if (JPT.AddProjectView.getKey().length >= 2) {
            JPT.AddProjectController._performKeyValidationChecks(JPT.AddProjectView.getKey());
        }
    };

    JPT.AddProjectView.addPostDrawCallback(function () {
        setupProjectCreationIntegration(getJptDialog, onJptCheckboxChange);
    });

    JPT.AddProjectController.registerPostProjectCreationCallback(function (dialog, returnUrl, projectId, projectKey, projectName) {
        var redirectFn = function() {
            window.location = AJS.contextPath() + returnUrl;
        };
        postProjectCreationCallback(dialog, redirectFn, projectId, projectKey, projectName);
    });

    // Embed project create in Greenhopper project create flow
    // (But only in flow creating a JIRA project at the same time)
    var registerGhCallbacks = function registerGhCallbacks() {
        var GH_PROJECT_CREATION_STEP = "projectCreation";
        GH.StartWizardView.registerWizardStepPreRenderCallback(function ghProjectCreateSetup(stepName) {
            if (stepName == GH_PROJECT_CREATION_STEP) {
                initRemoteRoots();

                GH.StartWizardView.registerWizardStepOnCreateCallbacks(function ghProjectCreageCallback(dialog, executeNextCallback, model) {
                    console.log("creating external entities");
                    dialog.addPage("post-project-created-page");
                    postProjectCreationCallback(dialog, executeNextCallback, null, model.project.key, model.project.name);
                });
            }
        });
        GH.StartWizardView.registerWizardStepPostRenderCallback(function renderGhProjectCheckboxes(stepName, dialog) {
            if (stepName == GH_PROJECT_CREATION_STEP) {
                setupProjectCreationIntegration(function getGhDialog() {
                    return dialog;
                });
                dialog.updateHeight();
            }
        });
        GH.StartWizardView.registerWizardStepOnValidateCallback(function validateProjectKey(stepName, dialog) {
            if (stepName == GH_PROJECT_CREATION_STEP) {
                var $keyInput = dialog.getCurPanel().body.find("#ghx-wizard-project-projectkey");
                var keyExistsResponse = checkIfKeyExists($keyInput.val());
                if (keyExistsResponse.errors.projectKey) {
                    var $errorElement = AJS.$("<div class='error project-creation-error'></div>");
                    var parent = $keyInput.parent();
                    parent.find(".project-creation-error").remove();
                    parent.append($errorElement);
                    $errorElement.text(keyExistsResponse.errors.projectKey);
                    $errorElement.show();
                    return false;
                }
            }
            return true;
        });
    };

    $(function() {

        // Embed project create in JIRA project templates dialog
        // on clicking the project create link, we want to start gathering our capabilities
        AJS.$('.add-project-trigger').live('click', initRemoteRoots);

        // check if Greenhopper is available and that it is a version which has support for the required
        // callbacks.  If so, register greenhopper callbacks
        if (typeof GH !== 'undefined') {
            if (GH.StartWizardView && GH.StartWizardView.registerWizardStepPreRenderCallback) {
                // GH has support for the required callbacks....
                registerGhCallbacks();
            }
        }
    });

    // Embed project create in JIRA project templates dialog
    // on clicking the project create link, we want to start gathering our capabilities
    $(function () {
        AJS.$('.add-project-trigger').live('click', initRemoteRoots);
    });


})(jQuery);
;
;
/* module-key = 'com.atlassian.plugins.jira-project-creation:project-creation-resources', location = '/templates/project-creation.soy' */
// This file was automatically generated from project-creation.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace project.creation.
 */

if (typeof project == 'undefined') { var project = {}; }
if (typeof project.creation == 'undefined') { project.creation = {}; }


project.creation.remoteRootsLoading = function(opt_data, opt_ignored) {
  return '<div class="field-group loading"><span class="aui-icon aui-icon-wait"/>' + soy.$$escapeHtml("Retrieving additional project types you might want to create") + '</div>';
};
if (goog.DEBUG) {
  project.creation.remoteRootsLoading.soyTemplateName = 'project.creation.remoteRootsLoading';
}


project.creation.remoteRootsCheckboxes = function(opt_data, opt_ignored) {
  var output = '<fieldset class="group remote-root-checkboxes"><h4>' + soy.$$escapeHtml("Create a linked:") + '</h4><div class=\'field-group\'>';
  var rootTypeList10 = opt_data.rootTypes;
  var rootTypeListLen10 = rootTypeList10.length;
  for (var rootTypeIndex10 = 0; rootTypeIndex10 < rootTypeListLen10; rootTypeIndex10++) {
    var rootTypeData10 = rootTypeList10[rootTypeIndex10];
    output += '<div class="checkbox"><input class="checkbox remote-root" type="checkbox" id="capability_' + soy.$$escapeHtml(rootTypeData10.capabilityKey) + '" checked="true" data-url="' + soy.$$escapeHtml(rootTypeData10.url) + '"></input><label for="capability_' + soy.$$escapeHtml(rootTypeData10.capabilityKey) + '">' + soy.$$escapeHtml(rootTypeData10.label) + '</label></div>';
  }
  output += '</div></fieldset>';
  return output;
};
if (goog.DEBUG) {
  project.creation.remoteRootsCheckboxes.soyTemplateName = 'project.creation.remoteRootsCheckboxes';
}


project.creation.remoteRootsSuccess = function(opt_data, opt_ignored) {
  var output = '<div class="project-creation-success"><ul>';
  var rootTypeList24 = opt_data.rootTypes;
  var rootTypeListLen24 = rootTypeList24.length;
  for (var rootTypeIndex24 = 0; rootTypeIndex24 < rootTypeListLen24; rootTypeIndex24++) {
    var rootTypeData24 = rootTypeList24[rootTypeIndex24];
    output += '<li class="li-' + soy.$$escapeHtml(rootTypeData24.statusId) + '"><div class="' + soy.$$escapeHtml(rootTypeData24.statusId) + ' created-entity-status"><span class="aui-icon aui-icon-wait">' + soy.$$escapeHtml("Loading, please wait") + '</span></div><div class="created-entity-status">' + soy.$$escapeHtml(rootTypeData24.label) + '</div></li>';
  }
  output += '<li class="li-linking-status"><div class="linking-status created-entity-status"><span class="aui-icon aui-icon-wait">' + soy.$$escapeHtml("Loading, please wait") + '</span></div><div class="created-entity-status">' + soy.$$escapeHtml("Creating links") + '</div></li></ul></div>';
  return output;
};
if (goog.DEBUG) {
  project.creation.remoteRootsSuccess.soyTemplateName = 'project.creation.remoteRootsSuccess';
}
;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/store-1.3.1.js' */
/* Copyright (c) 2010-2012 Marcus Westin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function(){
	var store = {},
		win = window,
		doc = win.document,
		localStorageName = 'localStorage',
		globalStorageName = 'globalStorage',
		namespace = '__storejs__',
		storage;

	store.disabled = false;
	store.set = function(key, value) {};
	store.get = function(key) {};
	store.remove = function(key) {};
	store.clear = function() {};
	store.transact = function(key, transactionFn) {
		var val = store.get(key);
		if (typeof val == 'undefined') { val = {} }
		transactionFn(val);
		store.set(key, val);
	};

	store.serialize = function(value) {
		return JSON.stringify(value);
	};
	store.deserialize = function(value) {
		if (typeof value != 'string') { return undefined }
		return JSON.parse(value);
	};

	// Functions to encapsulate questionable FireFox 3.6.13 behavior 
	// when about.config::dom.storage.enabled === false
	// See https://github.com/marcuswestin/store.js/issues#issue/13
	function isLocalStorageNameSupported() {
		try { return (localStorageName in win && win[localStorageName]); }
		catch(err) { return false; }
	}
	
	function isGlobalStorageNameSupported() {
		try { return (globalStorageName in win && win[globalStorageName] && win[globalStorageName][win.location.hostname]); }
		catch(err) { return false; }
	}	

	if (isLocalStorageNameSupported()) {
		storage = win[localStorageName];
		store.set = function(key, val) {
			if (val === undefined) { return store.remove(key); }
			storage.setItem(key, store.serialize(val));
		};
		store.get = function(key) { return store.deserialize(storage.getItem(key)); };
		store.remove = function(key) { storage.removeItem(key); };
		store.clear = function() { storage.clear(); };

	} else if (isGlobalStorageNameSupported()) {
		storage = win[globalStorageName][win.location.hostname];
		store.set = function(key, val) {
			if (val === undefined) { return store.remove(key); }
			storage[key] = store.serialize(val);
		};
		store.get = function(key) { return store.deserialize(storage[key] && storage[key].value); };
		store.remove = function(key) { delete storage[key]; };
		store.clear = function() { for (var key in storage ) { delete storage[key]; } };

	} else if (doc.documentElement.addBehavior) {
		var storageOwner,
			storageContainer;
		// Since #userData storage applies only to specific paths, we need to
		// somehow link our data to a specific path.  We choose /favicon.ico
		// as a pretty safe option, since all browsers already make a request to
		// this URL anyway and being a 404 will not hurt us here.  We wrap an
		// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
		// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
		// since the iframe access rules appear to allow direct access and
		// manipulation of the document element, even for a 404 page.  This
		// document can be used instead of the current document (which would
		// have been limited to the current path) to perform #userData storage.
		try {
			storageContainer = new ActiveXObject('htmlfile');
			storageContainer.open();
			storageContainer.write('<s' + 'cript>document.w=window</s' + 'cript><iframe src="/favicon.ico"></frame>');
			storageContainer.close();
			storageOwner = storageContainer.w.frames[0].document;
			storage = storageOwner.createElement('div');
		} catch(e) {
			// somehow ActiveXObject instantiation failed (perhaps some special
			// security settings or otherwse), fall back to per-path storage
			storage = doc.createElement('div');
			storageOwner = doc.body;
		}
		function withIEStorage(storeFunction) {
			return function() {
				var args = Array.prototype.slice.call(arguments, 0);
				args.unshift(storage);
				// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
				// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
				storageOwner.appendChild(storage);
				storage.addBehavior('#default#userData');
				storage.load(localStorageName);
				var result = storeFunction.apply(store, args);
				storageOwner.removeChild(storage);
				return result;
			}
		}
		store.set = withIEStorage(function(storage, key, val) {
			if (val === undefined) { return store.remove(key) }
			storage.setAttribute(key, store.serialize(val));
			storage.save(localStorageName);
		});
		store.get = withIEStorage(function(storage, key) {
			return store.deserialize(storage.getAttribute(key));
		});
		store.remove = withIEStorage(function(storage, key) {
			storage.removeAttribute(key);
			storage.save(localStorageName);
		});
		store.clear = withIEStorage(function(storage) {
			var attributes = storage.XMLDocument.documentElement.attributes;
			storage.load(localStorageName);
			for (var i=0, attr; attr = attributes[i]; i++) {
				storage.removeAttribute(attr.name);
			}
			storage.save(localStorageName);
		});
	}
	
	try {
		store.set(namespace, namespace);
		if (store.get(namespace) != namespace) { store.disabled = true; }
		store.remove(namespace);
	} catch(e) {
		store.disabled = true;
	}
	
	if (typeof module != 'undefined') { module.exports = store; }
	else if (typeof define === 'function' && define.amd) { define(store); }
	else { this.store = store; }
})();;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/page-visibility.js' */
define('atlassian/analytics/page-visibility', function () {
    var hasBrowserSupport = (document.hidden !== undefined);

    /**
     * A partial wrapper for the Page Visibility API
     * @exports atlassian/analytics/page-visibility
     */
    var wrapper = {

        /** Is the API supported by the browser? */
        supported: hasBrowserSupport,

        /**
         * A proxy for `document.hidden`.
         * Defaults to false if the API is not supported by the browser
         * @returns {boolean}
         */
        isHidden: function () {
            return hasBrowserSupport ? document.hidden : false;
        }
    };

    return wrapper;
});;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/user-activity-xhr-header.js' */
/**
 * Provides overrides that add a custom HTTP header to XHR and fetch requests
 * to make MAU User Activity event tracking easier by identifying requests
 * from inactive tabs/windows
 *
 * @module atlassian/analytics/user-activity-xhr-header
 *
 * @see module:atlassian/analytics/page-visibility
 */
define('atlassian/analytics/user-activity-xhr-header', ['atlassian/analytics/page-visibility'], function (pageVisibility) {

    var ACTIVITY_IGNORE_HEADER = 'x-atlassian-mau-ignore';

    // Store native xhr and fetch methods
    var oldSend = XMLHttpRequest.prototype.send;
    var oldFetch = window.fetch;

    var _installed = false;

    return /** @alias module:atlassian/analytics/user-activity-xhr-header */ {
        /**
         * Install global overrides to XHR send and fetch methods to add a
         * custom HTTP header that makes MAU User Activity event tracking
         * easier by identifying requests from inactive tabs/windows
         */
        install: function () {
            // Only install if the override is not already installed
            // and if the browser supports the Page Visibility API
            if (!_installed && pageVisibility.supported) {

                // Override the native send()
                XMLHttpRequest.prototype.send = function () {
                    if (pageVisibility.isHidden()) {
                        this.setRequestHeader(ACTIVITY_IGNORE_HEADER, pageVisibility.isHidden());
                    }
                    oldSend.apply(this, arguments);
                };

                // Override the native fetch() if it exists
                if (oldFetch) {
                    window.fetch = function (input, init) {
                        var augmentedInit = init || {};
                        var headers = augmentedInit.headers;

                        if (pageVisibility.isHidden()) {
                            augmentedInit.headers = (headers) ? new Headers(headers) : new Headers();
                            augmentedInit.headers.append(ACTIVITY_IGNORE_HEADER, pageVisibility.isHidden());
                        }

                        return oldFetch.call(this, input, augmentedInit);
                    };
                }

                _installed = true;
            }
        },

        /**
         * Restore native XHR send and fetch methods
         */
        uninstall: function () {
            if (_installed) {
                XMLHttpRequest.prototype.send = oldSend;
                if (oldFetch) {
                    window.fetch = oldFetch;
                }
            }
            _installed = false;
        }
    };

});

require('atlassian/analytics/user-activity-xhr-header').install();;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/atlassian-analytics.js' */
(function ($) {
    // Make sure we are getting the jQuery.ajax method, even if it has been overridden elsewhere.
    // This will only work if this code is executed before any code which overrides the ajax method.
    var $ajax = AJS.$.ajax;
    var baseStorageKey = 'atlassian-analytics';
    var contextPath =
        typeof AJS.contextPath == "function" ? AJS.contextPath() :
        typeof AJS.Confluence != "undefined" ? AJS.Confluence.getContextPath() :
        window.contextPath != null ? window.contextPath : "";

    var publish = null;
    var storageKey = null;
    var lockKey = null;

    // A unique identifier for this browser tab
    // Source: http://stackoverflow.com/a/2117523
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
    });

    var determineStorageKey = function(){
        // We need to give each product it's own key for events because in ondemand multiple product live
        // at the same url.
        var product = 'unknown';
        if (document.body.id == 'jira'){
            product = 'jira';
        }
        else if (document.body.id == 'com-atlassian-confluence'){
            product = 'confluence';
        }
        storageKey = baseStorageKey + '.' + product;
        lockKey = storageKey + '.lock';
    };

    var getLock = function() {
        if (store.get(lockKey)) {
            return false;
        }

        store.set(lockKey, uuid);

        // Reduce chance of race condition - read back lock to make sure we still have it
        return (store.get(lockKey) === uuid);
    };

    var releaseLock = function() {
        store.set(lockKey, null);
    };

    /**
     * Persists the events that have been generated until such time that they can be sent.
     */
    var saveForLater = function() {
        var events = [],
            event,
            e, i, ii;
        if (AJS.EventQueue.length == 0)
            return;
        // Prime our events array with anything that's already saved.
        events = store.get(storageKey) || events;
        // Suck the events out of the event queue and in to our events array.
        for (i = 0, ii = AJS.EventQueue.length; i < ii; ++i) {
            e = AJS.EventQueue[i];
            if (e.name) {
                // the queue could contain anything - shear unusable properties
                event = { name: e.name, properties: e.properties, time: e.time || 0};
                events.push(event);
            }
        }
        // Empty the event queue
        AJS.EventQueue.length = 0;
        // Save our events for later
        store.set(storageKey, events);
    };

    // Variable to track the number of retries to publish
    var bulkPublishRetryCount = 0;

    /**
     * Gets the amount of time that should be waited until the next publish attempt.
     * @param retryCount How many requests failed since the last successful publish.
     * @returns {number} how many ms that should be waited.
     */
    var getBulkPublishBackoff = function (retryCount) {
        return Math.min(5000 * Math.pow(2, retryCount), 5*60*1000);
    };

    /**
     * Publishes every event that's ready for publishing.
     */
    var bulkPublish = function() {
        var events;

        function reschedule() {
            setTimeout(bulkPublish, getBulkPublishBackoff(bulkPublishRetryCount = 0));
        }

        function rescheduleFailed() {
            setTimeout(bulkPublish, getBulkPublishBackoff(++bulkPublishRetryCount));
        }

        // Avoid multiple browser tabs hitting this all at once
        if (!getLock()) {
            return reschedule();
        }

        // Make sure every event we might have is stored.
        saveForLater();
        // Pull the stored events out and get 'em ready for transmission.
        events = store.get(storageKey);

        if (!events || !events.length) {
            releaseLock();
            return reschedule();
        }

        // Wipe the stored events.
        store.remove(storageKey);

        releaseLock();

        // Validate events and remove any dodgy ones
        if (!validateEvents(events)) {
            return reschedule();
        }

        // try to present a rough timing of events that the server can interpret relative to it's own time.
        var currentTime = new Date().getTime();
        for (var i = 0; i < events.length; i++){
            if (events[i].time > 0){
                events[i].timeDelta = events[i].time - currentTime;
            }
            else{
                // just fake it. This corresponds to a millisecond for each place behind last in the array.
                // This should be rare. Basically, events added to EventQueue before this script was loaded.
                events[i].timeDelta = i - events.length;
            }
            delete events[i].time;
        }

        // AJS.safe.post appears to corrupt a JSON data object, so we send it as a context param instead.
        // Failing to JSON encode the data results in jQuery not attempting to send, and silently swallowing our attempt
        publish = $ajax({
            type: "POST",
            url: contextPath + "/rest/analytics/1.0/publish/bulk",
            data: JSON.stringify(events),
            contentType: "application/json",
            dataType: "json"
        });
        // In case the transmission fails, let's keep the events we just attempted to send.
        publish.fail(function() {
            // This actually drops events, but the alternative is to use something like:
            //   $.merge(AJS.EventQueue, events);
            // Unfortunately using that will cause some fairly nasty issues where duplicate events continually
            // get sent - see https://jira.atlassian.com/browse/AA-179 for more details.
            // TODO: investigate why the above happens and fix this functionality for good
            AJS.EventQueue.concat(events);

            saveForLater();
            rescheduleFailed();
        });
        publish.done(function () {
            reschedule();
        });
    };

    /**
     * Check for any invalid events and remove/sanitise them.
     * @param events - the list of events to be published
     * @returns the number of valid events remaining
     */
    var validateEvents = function(events) {
        for (var i = events.length - 1; i >= 0; i--) {
            var validMsg = "";
            var event = events[i];
            var properties = event.properties;
            if (typeof event.name === "undefined") {
                validMsg = "you must provide a name for the event.";
            } else if (typeof properties !== "undefined" && properties !== null) {
                if (properties.constructor !== Object) {
                    validMsg = "properties must be an object with key value pairs.";
                } else {
                    sanitiseProperties(properties);
                }
            }
            if (validMsg !== "") {
                AJS.log("WARN: Invalid analytics event detected and ignored, " + validMsg + "\nEvent: "+JSON.stringify(event));
                events.splice(i, 1);
            }
        }
        return events.length;
    };

    var sanitiseProperties = function(properties) {
        for (var propertyName in properties) {
            if (properties.hasOwnProperty(propertyName)) {
                var propertyValue = properties[propertyName];
                if (typeof propertyValue !== "undefined" && propertyValue !== null && propertyValue.toString) {
                    // Sanitise the property value by invoking its "toString"
                    properties[propertyName] = propertyValue.toString();
                } else {
                    // If it's an undefined, null or invalid value - blank it out
                    properties[propertyName] = "";
                }
            }
        }
    };

    var cancelPublish = function() {
        if (publish && !(publish.state() === "resolved" || publish.state() === "rejected")) {
            publish.abort(); // This will cancel the request to the server, and cause the events to be saved for later.
        }
    };

    /**
     * Provides a way to publish events asynchronously, without requiring AJS.Events to have loaded.
     * Users of this property must conditionally initialise it to an empty array. Objects pushed
     * must have a name property, and optionally a properties property of other data to send.
     * @example
     * AJS.EventQueue = AJS.EventQueue || [];
     * AJS.EventQueue.push({name: 'eventName', properties: {some: 'data', more: true, hits: 20}});
     */
    AJS.EventQueue = AJS.EventQueue || [];

    var arrayPush = Array.prototype.push;
    AJS.EventQueue.push = function(obj) {
    	obj.time = new Date().getTime();
    	arrayPush.call(AJS.EventQueue, obj);
    };

    AJS.toInit(function() {
    	determineStorageKey();
        setTimeout(bulkPublish, 500);
        removeOldAnalytics();
    });
    $(window).unload(function() {
        cancelPublish();
        saveForLater();
    });

    /**
     * @deprecated since v3.39, please trigger as normal and use whitelisting to denote privacy policy safe events
     */
    AJS.Analytics = {
        triggerPrivacyPolicySafeEvent: function(name, properties) {
            AJS.log("WARN: 'triggerPrivacyPolicySafeEvent' has been deprecated");
            AJS.EventQueue.push({name: name, properties: properties});
        }
    };

    /**
     * Binds to an event that developers can trigger without having to do any feature check.
     * If this code is available then the event will get published and if it's not the event
     * will go unnoticed.
     * @example
     * AJS.trigger('analytics', {name: 'pageSaved', data: {pageName: page.name, space: page.spaceKey}});
     */
    AJS.bind('analytics', function(event, data) {
    	AJS.EventQueue.push({name: data.name, properties: data.data});
    });

    // legacy binding until Confluence page layout JS is updated
    AJS.bind('analyticsEvent', function(event, data) {
    	AJS.EventQueue.push({name: data.name, properties: data.data});
    });

    /**
     * As part of bundling this plugin in BTF now, we need to remove the existing JIRA analytics setting if we see it.
     */
    var removeOldAnalytics = function () {
        if (window.location.pathname.indexOf("/secure/admin/ViewApplicationProperties") > -1) {
            AJS.$("[data-property-id='analytics-enabled']").remove();
        } else if (window.location.pathname.indexOf("/secure/admin/EditApplicationProperties") > -1) {
            var $analytics = AJS.$(":contains(Enable Atlassian analytics)");
            if ($analytics.size() > 0) {
                var parentElement = $analytics[$analytics.size() - 2];
                if (parentElement) {
                    parentElement.remove();
                }
            }
        }
    }

}(AJS.$));
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:application-header-administration-cog-resource', location = 'header/cog.js' */
var NavLinks = (function (NavLinks) {

    NavLinks.ApplicationHeader = function (ApplicationHeader) {

        ApplicationHeader.Cog = (function () {

            var _get = function () {

                var jiraSection = AJS.$("#system-admin-menu-content");
                if (jiraSection.length > 0) {
                    return jiraSection;
                }

                var confluenceSection = AJS.$("#admin-menu-link-content");
                if (confluenceSection.length > 0) {
                    return confluenceSection;
                }

                // Bamboo
                return AJS.$("#bamboo\\.global\\.header-admin\\.menu");
            };

            return {
                getDropdown: _get
            };
        }());
        return ApplicationHeader;
    }(NavLinks.ApplicationHeader || {});

    return NavLinks;
}(NavLinks || {}));;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:administration-shortcuts-resources', location = 'adminshortcuts/adminshortcuts.soy' */
// This file was automatically generated from adminshortcuts.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.adminshortcuts.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.adminshortcuts == 'undefined') { navlinks.templates.adminshortcuts = {}; }


navlinks.templates.adminshortcuts.section = function(opt_data, opt_ignored) {
  var param5 = '<ul class="aui-list-truncate">';
  var linkList7 = opt_data.links;
  var linkListLen7 = linkList7.length;
  for (var linkIndex7 = 0; linkIndex7 < linkListLen7; linkIndex7++) {
    var linkData7 = linkList7[linkIndex7];
    param5 += '<li><a href="' + soy.$$escapeHtml(linkData7.link) + '">' + soy.$$escapeHtml(linkData7.label) + '</a></li>';
  }
  param5 += '</ul>';
  var output = '' + aui.dropdown2.section({id: 'nl-remote-admin-section', label: "Other applications", content: param5});
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.adminshortcuts.section.soyTemplateName = 'navlinks.templates.adminshortcuts.section';
}
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:administration-shortcuts-resources', location = 'adminshortcuts/adminnavlinks.js' */
var NavLinks = (function (NavLinks) {

    NavLinks.AdminShortcuts = (function () {

        var _requestLinks = function () {
            return AJS.$.ajax({
                url:AJS.contextPath() + '/rest/menu/latest/admin',
                cache:false,
                dataType:'json'
            });
        };

        var trackAnalytics = function () {
            AJS.$("#nl-remote-admin-section").on('click', 'a', function () {
                NL.trackEvent('remoteAdminItemSelected', NL.getCurrentApplication(), $(this).attr('href'));
            });
        };

        return {
            render: function () {

                _requestLinks().done(function (linkData) {

                    // filter links to exclude the local admin link
                    linkData = _.reject(linkData,  function (link) {
                        return link['local'] === true;
                    });

                    if (linkData.length) {
                        // if we have remote admin links, render them in a new dropdown section
                        var renderedTemplate = navlinks.templates.adminshortcuts.section({links: linkData});
                        NavLinks.ApplicationHeader.Cog.getDropdown().append(renderedTemplate);

                        trackAnalytics();
                    }
                })
            }
        };
    }());

    return NavLinks;
}(NavLinks || {}));;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:administration-shortcuts', location = 'adminshortcuts/adminshortcuts-cdn.js' */
AJS.toInit(function () {
    if (AJS.DarkFeatures && AJS.DarkFeatures.isEnabled('rotp.admin.shortcuts')) {
        NavLinks.AdminShortcuts.render();
    }
});;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-projectshortcuts', location = 'projectshortcuts/projectshortcuts.soy' */
// This file was automatically generated from projectshortcuts.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.projectshortcuts.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.projectshortcuts == 'undefined') { navlinks.templates.projectshortcuts = {}; }


navlinks.templates.projectshortcuts.dialogContent = function(opt_data, opt_ignored) {
  return '' + ((opt_data.localShortcuts && opt_data.localShortcuts.length > 0) ? navlinks.templates.projectshortcuts.dialogContentShortcuts({shortcuts: opt_data.localShortcuts, listClass: 'projectshortcut-links'}) : '') + ((opt_data.remoteShortcuts != null) ? (opt_data.remoteShortcuts.length > 0) ? '<h2 class="projectshortcuts-heading">Related Links</h2>' + navlinks.templates.projectshortcuts.dialogContentShortcuts(soy.$$augmentMap(opt_data.remoteShortcuts, {shortcuts: opt_data.remoteShortcuts, listClass: 'projectshortcut-links'})) : '' : navlinks.templates.projectshortcuts.dialogLoading(null));
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogContent.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogContent';
}


navlinks.templates.projectshortcuts.headingWrapper = function(opt_data, opt_ignored) {
  return '<div class="project-dialog-header-wrapper"><div class="project-header"><img class="project-img" src="' + soy.$$escapeHtml(opt_data.logoUrl) + '"><h2 class="dialog-title">' + soy.$$escapeHtml(opt_data.title) + '</h2></div><div class="project-content-wrapper">' + soy.$$filterNoAutoescape(opt_data.contentHtml) + '</div></div>';
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.headingWrapper.soyTemplateName = 'navlinks.templates.projectshortcuts.headingWrapper';
}


navlinks.templates.projectshortcuts.dialogContentShortcuts = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  var output = '<ul' + ((opt_data.listClass) ? ' class="' + soy.$$escapeHtml(opt_data.listClass) + '"' : '') + '>';
  var shortcutList35 = opt_data.shortcuts;
  var shortcutListLen35 = shortcutList35.length;
  for (var shortcutIndex35 = 0; shortcutIndex35 < shortcutListLen35; shortcutIndex35++) {
    var shortcutData35 = shortcutList35[shortcutIndex35];
    output += '<li' + ((shortcutIndex35 == shortcutListLen35 - 1) ? ' class="last"' : '') + '>' + navlinks.templates.projectshortcuts.dialogContentShortcut(shortcutData35) + '</li>';
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogContentShortcuts.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogContentShortcuts';
}


navlinks.templates.projectshortcuts.dialogContentShortcut = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.link) + '"' + ((opt_data.tooltip) ? ' title="' + soy.$$escapeHtml(opt_data.tooltip) + '"' : '') + '>' + soy.$$escapeHtml(opt_data.label) + '</a>';
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogContentShortcut.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogContentShortcut';
}


navlinks.templates.projectshortcuts.dialogLoading = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div class="projectshortcuts-loading">' + ((opt_data.text) ? soy.$$escapeHtml(opt_data.text) : '') + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogLoading.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogLoading';
}
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-projectshortcuts', location = 'projectshortcuts/projectshortcuts.js' */
(function ($, NL) {
    var dialog,
        dialogDataCache = {},
        triggerDataEntityKey = 'key',
        triggerDataEntityName = 'name',
        triggerDataEntityType = 'entity-type';

    function showShortcutsDialog(e) {
        var $trigger = $(this),
            projectKey = $trigger.data(triggerDataEntityKey),
            projectName = $trigger.data(triggerDataEntityName),
            projectEntityType = $trigger.data(triggerDataEntityType);

        if (typeof projectKey === 'undefined') {
            return;
        }

        e.preventDefault();

        dialog = new AJS.Dialog({
            width: 600,
            keypressListener: function (e) {
                if (e.which == jQuery.ui.keyCode.ESCAPE) {
                    dialog.remove();
                }
            },
            id: "project-shortcuts-dialog"
        })
            .addCancel('Close', function () {
                dialog.remove();
            })
            .addPanel('',
                    navlinks.templates.projectshortcuts.headingWrapper({
                            title: projectName,
                            logoUrl: getLogoUrl(),
                            contentHtml : navlinks.templates.projectshortcuts.dialogLoading({ text: 'Retrieving linksâ¦' })
                        }))
            .show();

        updateDialogHeight(dialog);

        if (!dialogDataCache[projectKey]) {
            dialogDataCache[projectKey] = {
                entity: {
                    title: projectName
                },
                localShortcuts: null,
                remoteShortcuts: null
            };
            getData(AJS.contextPath() + '/rest/project-shortcuts/1.0/local/' + projectKey, { entityType: projectEntityType }).done(updateLocal);
            getData(AJS.contextPath() + '/rest/project-shortcuts/1.0/remote/' + projectKey, { entityType: projectEntityType }).done(updateRemote).fail(function () {
                var $wrapper = dialog.getCurrentPanel().body.find('.project-content-wrapper');
                $wrapper.find('.projectshortcuts-loading').remove();
                AJS.messages.error($wrapper, {
                    body: "Could not retrieve remote project shortcuts",
                    closeable: false
                });
                updateDialogHeight(dialog);
            });
        } else {
            updateShortcutsDialog(dialogDataCache[projectKey]);
        }

        function updateLocal(data) {
            dialogDataCache[projectKey].localShortcuts = data.shortcuts;
            updateShortcutsDialog(dialogDataCache[projectKey]);
        }
        function updateRemote(data) {
            dialogDataCache[projectKey].remoteShortcuts = data.shortcuts;
            updateShortcutsDialog(dialogDataCache[projectKey]);
        }
    }

    function getLogoUrl() { 
        return $(".project-shortcut-dialog-trigger img").attr("src");
    }

    function updateShortcutsDialog(data) {
        if (data.localShortcuts) { // Don't update the dialog until we have entity data and local links (stops the dialog from displaying remote links only if remote links has returned first)
            dialog.getCurrentPanel().html(
                    navlinks.templates.projectshortcuts.headingWrapper({
                        title: data.entity.title,
                        logoUrl: getLogoUrl(),
                        contentHtml: navlinks.templates.projectshortcuts.dialogContent(data)
                    }));

            updateDialogHeight(dialog);
        }
    }
    
    function truncateDesc(desc) {

        var trunc = 210;
        if(!desc || desc.length <= trunc)
            return desc;

        var i = trunc;
        while(i > 0 && desc.charAt(i) != " ") {
            i--;
        }
        if(i == 0) {
            i = trunc;
        }

        desc = desc.substring(0, i);
        if(desc.length >= i)
            desc = desc + "...";
        return desc;
    }

    /**
     * Since AJS.Dialog's height updating is completely broken we need to do it custom for our dialog
     * @param dialog
     */
    function updateDialogHeight(dialog) {
        var $dialog = dialog.popup.element,
            $body = $dialog.find('.dialog-panel-body'),
            $components = $dialog.find('.dialog-components');

        $body.height('auto');
        $dialog.height($components.outerHeight() - 1);
        $('.aui-shadow').remove();
    }

    function getData(url, data) {
        return $.ajax({
            url: url,
            cache: false,
            data: data,
            dataType: 'json'
        });
    }

    $(document).on('click', '.project-shortcut-dialog-trigger', showShortcutsDialog);
}(jQuery, window.NL = (window.NL || {})));
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:atlassian-ui-popup-display-controller', location = 'popups/DisplayController.js' */
AJS.Popups = AJS.Popups || {};

/**
 * Coordinate the display of popup dialogs requested from other functions in the application.
 *
 * Its responsibility is to organise the display of these popups so that that they do not come into conflict with
 * each other.
 */
AJS.Popups.DisplayController = function () {

    var _popupDialogRegistry = [];
    var _renderPerformed = false;
    var _dialogShown = false;

    AJS.toInit(function () {
        setTimeout(function () {
            AJS.Popups.DisplayController.render();
        }, 0);
    });

    return {

        /**
         * Request the display of a popup dialog to this controller.
         *
         * @param popupDialog An {Object} containing a request to display a popup dialog.
         */
        request:function (popupDialog) {
            _popupDialogRegistry.push(popupDialog);
            if (_renderPerformed && _dialogShown === false) {
                this.render();
            }
        },

        /**
         * Renders a popup dialog on screen.
         *
         * If more than one popup has been requested, it will render the one that has the lowest "weight",
         * if no popups have been requested, no dialog will be displayed.
         *
         */
        render:function () {
            _popupDialogRegistry.sort(function (first, second) {
                return first.weight - second.weight;
            });

            _renderPerformed = true;

            if (_popupDialogRegistry.length !== 0) {
                _dialogShown = true;
                _popupDialogRegistry[0].show();
            }
        }
    };
}();;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-web-plugin:issue-link-web-link', location = 'js/issuelink-weblink.js' */
(function () {
    var $hiddenImg = AJS.$("<img>"),
        $iconUrlInput,
        $urlInput,
        faviconUrl,
        throbberTimeoutId;

    $hiddenImg.load(function() {
        $iconUrlInput.val(faviconUrl);
        $urlInput.css("background-image", 'url("' + faviconUrl + '")');

        clearTimeout(throbberTimeoutId);
        $urlInput.removeClass("loading");
    });
    $hiddenImg.error(function() {
        clearTimeout(throbberTimeoutId);
        $urlInput.removeClass("loading");
    });

    function init(context) {
        $iconUrlInput = AJS.$("#web-link-icon-url", context);
        $urlInput = AJS.$("#web-link-url", context).bind("change", fetchFavicon);

        if ($iconUrlInput.val()) {
            $urlInput.css("background-image", "url(" + $iconUrlInput.val() + ")");
        }
    }

    function fetchFavicon() {
        // Initialise state
        $hiddenImg.attr("src", '');
        $iconUrlInput.val('');
        $urlInput.css("background-image", '');
        faviconUrl = parseFaviconUrl($urlInput.val());

        if (!faviconUrl) {
            return;
        }

        /**
         * IE specific hack: For some reason I cannot change the class inside event handler for the event source.
         */
        setTimeout(function() { $urlInput.addClass("loading"); }, 0);
        throbberTimeoutId = setTimeout(function() { $urlInput.removeClass("loading"); }, 3000);

        $hiddenImg.attr("src", faviconUrl);
    }

    function parseFaviconUrl(url) {
        var hostUrl = url.match(/^([^/]*\/\/[^/]+)/)[1];

        if (!hostUrl) {
            return;
        }

        return hostUrl + "/favicon.ico";
    }

    JIRA.bind(JIRA.Events.NEW_PAGE_ADDED, function (e, context) {
        init(context);
    });
})();;
;
/* module-key = 'com.atlassian.plugin.jslibs:moment-2.6.0', location = 'libs/moment/2.6.0/moment-2.6.0.js' */
/////////// Modified by Atlassian ///////////
(function(factory) {
    define('atlassian/libs/moment-2.6.0', function () {
        var env = {};
        factory.call(env);
        return env.moment;
    });
})(function(){
/////// End of Atlassian modification ///////


//! moment.js
//! version : 2.6.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
     Constants
     ************************************/

    var moment,
        VERSION = "2.6.0",
    // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

    // internal storage for language config files
        languages = {},

    // moment internal properties
        momentProperties = {
            _isAMomentObject: null,
            _i : null,
            _f : null,
            _l : null,
            _strict : null,
            _isUTC : null,
            _offset : null,  // optional. Combine with _isUTC
            _pf : null,
            _lang : null  // optional
        },

    // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

    // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

    // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

    // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

    //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

    // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

    // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

    // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

    // format function strings
        formatFunctions = {},

    // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        function printMsg() {
            if (moment.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' && console.warn) {
                console.warn("Deprecation warning: " + msg);
            }
        }
        return extend(function () {
            if (firstTime) {
                printMsg();
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
     Constructors
     ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
     Helpers
     ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function cloneMoment(m) {
        var result = {}, i;
        for (i in m) {
            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                result[i] = m[i];
            }
        }

        return result;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                    m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                        m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                            m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                                    m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                                        -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
     Languages
     ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
     Formatting
     ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
     Parsing
     ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
            case 'Q':
                return parseTokenOneDigit;
            case 'DDDD':
                return parseTokenThreeDigits;
            case 'YYYY':
            case 'GGGG':
            case 'gggg':
                return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
            case 'Y':
            case 'G':
            case 'g':
                return parseTokenSignedNumber;
            case 'YYYYYY':
            case 'YYYYY':
            case 'GGGGG':
            case 'ggggg':
                return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
            case 'S':
                if (strict) { return parseTokenOneDigit; }
            /* falls through */
            case 'SS':
                if (strict) { return parseTokenTwoDigits; }
            /* falls through */
            case 'SSS':
                if (strict) { return parseTokenThreeDigits; }
            /* falls through */
            case 'DDD':
                return parseTokenOneToThreeDigits;
            case 'MMM':
            case 'MMMM':
            case 'dd':
            case 'ddd':
            case 'dddd':
                return parseTokenWord;
            case 'a':
            case 'A':
                return getLangDefinition(config._l)._meridiemParse;
            case 'X':
                return parseTokenTimestampMs;
            case 'Z':
            case 'ZZ':
                return parseTokenTimezone;
            case 'T':
                return parseTokenT;
            case 'SSSS':
                return parseTokenDigits;
            case 'MM':
            case 'DD':
            case 'YY':
            case 'GG':
            case 'gg':
            case 'HH':
            case 'hh':
            case 'mm':
            case 'ss':
            case 'ww':
            case 'WW':
                return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
            case 'M':
            case 'D':
            case 'd':
            case 'H':
            case 'h':
            case 'm':
            case 's':
            case 'w':
            case 'W':
            case 'e':
            case 'E':
                return parseTokenOneOrTwoDigits;
            case 'Do':
                return parseTokenOrdinal;
            default :
                a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
                return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
            // QUARTER
            case 'Q':
                if (input != null) {
                    datePartArray[MONTH] = (toInt(input) - 1) * 3;
                }
                break;
            // MONTH
            case 'M' : // fall through to MM
            case 'MM' :
                if (input != null) {
                    datePartArray[MONTH] = toInt(input) - 1;
                }
                break;
            case 'MMM' : // fall through to MMMM
            case 'MMMM' :
                a = getLangDefinition(config._l).monthsParse(input);
                // if we didn't find a month name, mark the date as invalid.
                if (a != null) {
                    datePartArray[MONTH] = a;
                } else {
                    config._pf.invalidMonth = input;
                }
                break;
            // DAY OF MONTH
            case 'D' : // fall through to DD
            case 'DD' :
                if (input != null) {
                    datePartArray[DATE] = toInt(input);
                }
                break;
            case 'Do' :
                if (input != null) {
                    datePartArray[DATE] = toInt(parseInt(input, 10));
                }
                break;
            // DAY OF YEAR
            case 'DDD' : // fall through to DDDD
            case 'DDDD' :
                if (input != null) {
                    config._dayOfYear = toInt(input);
                }

                break;
            // YEAR
            case 'YY' :
                datePartArray[YEAR] = moment.parseTwoDigitYear(input);
                break;
            case 'YYYY' :
            case 'YYYYY' :
            case 'YYYYYY' :
                datePartArray[YEAR] = toInt(input);
                break;
            // AM / PM
            case 'a' : // fall through to A
            case 'A' :
                config._isPm = getLangDefinition(config._l).isPM(input);
                break;
            // 24 HOUR
            case 'H' : // fall through to hh
            case 'HH' : // fall through to hh
            case 'h' : // fall through to hh
            case 'hh' :
                datePartArray[HOUR] = toInt(input);
                break;
            // MINUTE
            case 'm' : // fall through to mm
            case 'mm' :
                datePartArray[MINUTE] = toInt(input);
                break;
            // SECOND
            case 's' : // fall through to ss
            case 'ss' :
                datePartArray[SECOND] = toInt(input);
                break;
            // MILLISECOND
            case 'S' :
            case 'SS' :
            case 'SSS' :
            case 'SSSS' :
                datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
                break;
            // UNIX TIMESTAMP WITH MS
            case 'X':
                config._d = new Date(parseFloat(input) * 1000);
                break;
            // TIMEZONE
            case 'Z' : // fall through to ZZ
            case 'ZZ' :
                config._useUTC = true;
                config._tzm = timezoneMinutesFromString(input);
                break;
            case 'w':
            case 'ww':
            case 'W':
            case 'WW':
            case 'd':
            case 'dd':
            case 'ddd':
            case 'dddd':
            case 'e':
            case 'E':
                token = token.substr(0, 1);
            /* falls through */
            case 'gg':
            case 'gggg':
            case 'GG':
            case 'GGGG':
            case 'GGGGG':
                token = token.substr(0, 2);
                if (input) {
                    config._w = config._w || {};
                    config._w[token] = input;
                }
                break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                var intVal = parseInt(val, 10);
                return val ?
                    (val.length < 3 ? (intVal > 68 ? 1900 + intVal : 2000 + intVal) : intVal) :
                    (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            }
            else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ?  parseWeekday(w.d, lang) :
                    (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
     Relative Time
     ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
     Week of Year
     ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
     Top Level Functions
     ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = cloneMoment(input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = lang;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
        "moment construction falls back to js Date. This is " +
        "discouraged and will be removed in upcoming major " +
        "release. Please refer to " +
        "https://github.com/moment/moment/issues/1407 for more info.",
        function (config) {
            config._d = new Date(config._i);
        });

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = lang;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
        // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
     Moment Prototype
     ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                    (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                    (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                        units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                            units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                                units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var sod = makeAs(moment(), this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                        diff < 0 ? 'lastDay' :
                            diff < 1 ? 'sameDay' :
                                diff < 2 ? 'nextDay' :
                                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
            this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
                case 'year':
                    this.month(0);
                /* falls through */
                case 'quarter':
                case 'month':
                    this.date(1);
                /* falls through */
                case 'week':
                case 'isoWeek':
                case 'day':
                    this.hours(0);
                /* falls through */
                case 'hour':
                    this.minutes(0);
                /* falls through */
                case 'minute':
                    this.seconds(0);
                /* falls through */
                case 'second':
                    this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        // keepTime = true means only change the timezone, without affecting
        // the local hour. So 5:31:26 +0300 --[zone(2, true)]--> 5:31:26 +0200
        // It is possible that 5:31:26 doesn't exist int zone +0200, so we
        // adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepTime) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    if (!keepTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                            moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this._lang._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.lang().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
            daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
     Duration Prototype
     ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
     Default Lang
     ************************************/


        // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                    (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                            (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
     Exposing Moment
     ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                "Accessing Moment through the global scope is " +
                "deprecated, and will be removed in an upcoming " +
                "release.",
                moment);
        } else {
            globalScope.moment = moment;
        }
    }

    /////////// Modified by Atlassian ///////////
    // CommonJS module is defined
    //if (hasModule) {
    //    module.exports = moment;
    //} else if (typeof define === "function" && define.amd) {
    //    define("moment", function (require, exports, module) {
    //        if (module.config && module.config() && module.config().noGlobal === true) {
    //            // release the global variable
    //            globalScope.moment = oldGlobalMoment;
    //        }
    //
    //        return moment;
    //    });
    //    makeGlobal(true);
    //} else {
    //    makeGlobal();
    //}
    // Bypassing in-library AMD
    makeGlobal();
    /////// End of Atlassian modification ///////

}).call(this);

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.lib.js' */
define('jira/moment/moment.lib', ['atlassian/libs/moment-2.6.0'], function(moment) {
    return moment;
});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.jira.formatter.js' */
define("jira/moment/moment.jira.formatter", ["underscore", "exports"], function(_, exports) {
    "use strict";
    var map = {
        d: "D",       // day
        y: "Y",       // year
        a: "A",       // meridiem
        E: "d",       // day name of week
        u: "d",       // day number of week
        Z: "ZZ",      // RFC 822 time zone
        z: "[GMT]ZZ", // replacing time zone name with offset
        XX: "ZZ",     // ISO 8601 time zone
        XXX: "Z"      // ISO 8601 time zone
    };

    function actuallyTranslate(tmpBuffer) {
        return map[tmpBuffer] || _.reduce(tmpBuffer, function (memo, value) {
            return memo + (map[value] || value);
        }, "");
    }

    function translateSimpleDateFormat(pattern) {
        var inQuote = false;
        var skip = false;
        var tmpBuffer = "";
        var reduction = _.reduce(pattern, function (memo, value, index, list) {
                if (skip) {
                    skip = false;
                }
                else if (value === '\'') {
                    if (tmpBuffer) {
                        memo += actuallyTranslate(tmpBuffer);
                        tmpBuffer = "";
                    }
                    if (list[index + 1] === '\'') {
                        memo += value;
                        skip = true;
                    }
                    else {
                        memo += !inQuote ? "[" : "]";
                        inQuote = !inQuote;
                    }
                }
                else if (inQuote) {
                    memo += value;
                }
                else if (!/[a-zA-Z]/.test(value)) {
                    if (tmpBuffer) {
                        memo += actuallyTranslate(tmpBuffer);
                        tmpBuffer = "";
                    }
                    memo += value;
                }
                else if (!tmpBuffer || tmpBuffer[tmpBuffer.length - 1] === value) {
                    tmpBuffer += value;
                }
                else {
                    memo += actuallyTranslate(tmpBuffer);
                    tmpBuffer = value;
                }
                return memo;
            }, "");
        if (tmpBuffer) {
            reduction += actuallyTranslate(tmpBuffer);
        }
        return reduction;
    }

    exports.translateSimpleDateFormat = translateSimpleDateFormat;
});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.jira.i18n.js' */
/* global WRM */
define("jira/moment/moment.jira.i18n", [
    "jira/moment/moment.lib",
    "jira/moment/moment.jira.formatter",
    "jira/util/data/meta"
], function (moment, formatter, Meta) {

    "use strict";

    var timeUnits = WRM.data.claim("jira.webresources:dateFormatProvider.dateFormat");

    moment.lang("jira", {
        months: timeUnits.months,
        monthsShort: timeUnits.monthsShort,
        weekdays: timeUnits.weekdays,
        weekdaysShort: timeUnits.weekdaysShort,
        weekdaysMin: timeUnits.weekdaysShort,
        longDateFormat: {
            LT: formatter.translateSimpleDateFormat(Meta.get("date-time")),
            L: formatter.translateSimpleDateFormat(Meta.get("date-day")),
            LL: formatter.translateSimpleDateFormat(Meta.get("date-dmy")),
            LLL: formatter.translateSimpleDateFormat(Meta.get("date-complete"))
        },
        meridiem: function (hours) {
            return timeUnits.meridiem[+(hours > 11)];
        },

        calendar: {
            sameDay:  "LLL",
            nextDay:  "LLL",
            nextWeek: "LLL",
            lastDay:  "LLL",
            lastWeek: "LLL",
            sameElse: "LLL"
        },

        // TODO Deprecate?
        relativeTime: {
            future: AJS.format("in {0}", "%s"),
            past: AJS.format("{0} ago", "%s"),
            s: "a few seconds",
            m: "a minute",
            mm: AJS.format("{0} minutes", "%d"),
            h: "an hour",
            hh: AJS.format("{0} hours", "%d"),
            d: "a day",
            dd: AJS.format("{0} days", "%d"),
            M: "a month",
            MM: AJS.format("{0} months", "%d"),
            y: "a year",
            yy: AJS.format("{0} years", "%d")
        }
    });

});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.js' */
/**
 * @fileOverview
 * Pulls in the core Moment.js library, defines JIRA's i18n mappings,
 * then returns a moment instance that always uses the correct i18n setting.
 * See {@link http://momentjs.com/docs/#/i18n/instance-locale/} for details
 * on Moment.js' (changes in its) support for i18n.
 */

/**
 * @module jira/moment
 */
define('jira/moment', ['jira/moment/moment.lib', 'jira/moment/moment.jira.i18n'], function(moment, i18n) {
    return moment;
});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.legacy.js' */
(function() {
    AJS.namespace('JIRA.translateSimpleDateFormat', null, require('jira/moment/moment.jira.formatter').translateSimpleDateFormat);
    AJS.namespace('window.moment', null, require('jira/moment'));
}());
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:shared-utility', location = 'js/ctrlv/time.js' */
define("dndattachment/ctrlv/time", [], function () {
  "use strict";
  return moment;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:shared-utility', location = 'js/ctrlv/base64decode.js' */
// Modified by Atlassian
// Copyright (c) 2013 ethertank, fusionchess
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
define("dndattachment/ctrlv/base64decode", [
    "exports"
], function (
  exports
) {
    "use strict";

    /**
     * Array of bytes to base64 string decoding
     * @param nChr
     * @returns {number}
     */
    function b64ToUint6(nChr) {
        return nChr > 64 && nChr < 91 ?
            nChr - 65
            : nChr > 96 && nChr < 123 ?
            nChr - 71
            : nChr > 47 && nChr < 58 ?
            nChr + 4
            : nChr === 43 ?
            62
            : nChr === 47 ?
            63
            :
            0;
    }

    var base64decode = function (encoded) {
        var sB64Enc = encoded.replace(/[^A-Za-z0-9\+\/]/g, ""),
            nInLen = sB64Enc.length,
            nOutLen = nInLen * 3 + 1 >> 2,
            taBytes = new Uint8Array(nOutLen);

        for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
            nMod4 = nInIdx & 3;
            nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
            if (nMod4 === 3 || nInLen - nInIdx === 1) {
                for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
                    taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
                }
                nUint24 = 0;
            }
        }

        return taBytes;
    };
    /**
     * Decoder of base64 encoded string to a byte array
     * @param encoded
     * @returns {Uint8Array}
     */
    exports.base64decode = base64decode;


    exports.decodeBase64DataUri = function (uri) {
        var separator = ";base64,",
            prefix = uri.slice(0, uri.indexOf(separator)) + separator,
            base64encoded = uri.substring(prefix.length);
        return base64decode(base64encoded);
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:shared-utility', location = 'js/ctrlv/utility.js' */
define("dndattachment/ctrlv/utility", [
    "jquery",
    "underscore",
    "dndattachment/ctrlv/base64decode",
    "dndattachment/ctrlv/time",
    "jira/flag",
    "jira/util/navigator",
    "featureflags/feature-manager",
    "exports"
], function (
  $,
  _,
  base64decode,
  time,
  JIRAFlag,
  Navigator,
  FeatureManager,
  exports
) {
    "use strict";

    /**
     * Determine if a keypress event is a "paste" (the keys differ between platform).
     * @param {Event} event
     * @param {string} [platform] If provided, overrides the value of navigator.platform.
     * @returns {boolean}
     */
    exports.isKeyPasteEvent = function (event, platform) {
        var V_KEY = 86;
        var IS_MAC = ((platform || "").indexOf("Mac") !== -1) || Navigator.isMac();

        return event.which === V_KEY && (IS_MAC ? event.metaKey : event.ctrlKey);
    };

    /**
     * Feature detection, check whether given parameter is a valid clipboard event
     *
     * @param event JQuery Event object
     * @returns {boolean}
     */
    exports.isImagePasteEvent = function (event) {
        if (event && event.clipboardData) {
            // Get the items from the clipboard, scan items and files properties
            var items = _.union(_.toArray(event.clipboardData.items), _.toArray(event.clipboardData.files));
            var hasImage = items.some(function (item) {
                return item.type.indexOf("image") !== -1;
            });
            var hasRtf = items.some(function (item) {
                return item.type.indexOf("rtf") !== -1;
            });
            return hasImage && !hasRtf;
        }
    };

    var getHtmlImagePaste = function (event) {
        if (!event.clipboardData || !event.clipboardData.types || !_.contains(event.clipboardData.types, "text/html")) {
            return;
        }

        var $data = $(event.clipboardData.getData("text/html"));
        if($data.length === 1 && $data.children().length === 0 && $data[0].nodeName.toLowerCase() === "img"){
            return $data[0].src;
        }
        return null;
    };

    exports.getHtmlImagePaste = getHtmlImagePaste;

    /**
     * Detect whether given event comes with html content in its ClipboardData, that contains single image tag
     * @param {Event} event
     * @returns {Boolean}
     */
    exports.isHtmlImagePasteEvent = function(event) {
        return getHtmlImagePaste(event) != null;
    };

    /**
     * Detect whether given event comes with text content in its ClipboardData
     * @param {Event} event
     * @returns {Boolean}
     */
    exports.isTextPasteEvent = function(event) {
        return event.clipboardData.types && (_.contains(event.clipboardData.types, "text/plain") || _.contains(event.clipboardData.types, "text/html"));
    };

    /**
     * Detect whether this element is an/withing contentEditable
     * @param {HTMLElement} element
     * @returns {Boolean}
     */
    exports.isContentEditable = function(element) {
        return  element.contentEditable == "true" || element.contentEditable == "" ||
                (element.contentEditable == "inherit" && $(element).parents().is('[contenteditable=true]'));
    };

    /**
     * Check if provided file name does not contain any of forbidden characters
     * @param {String} fileName
     * @returns {boolean}
     */
    exports.isValidFileName = function(fileName) {
        return !_([
            // characters forbidden by various file systems
            '\\', '/', '\"', ':', '?', '*', '<', '|', '>',
            // wiki markup
            '!'
        ]).any(function(character) {
            return fileName.indexOf(character) > -1;
        });
    };

    /**
     * Get text content from paste event
     * @param {Event} event
     * @returns {String}
     */
    exports.getTextPasteContent = function(event) {
        return event.clipboardData.types && _.contains(event.clipboardData.types, "text/plain") && event.clipboardData.getData("text/plain") || '';
    };

    /**
     * Get text contet from node, pick property which preserves new lines.
     * @param node
     * @returns {String}
     */
    exports.getTextContent = function(node) {
        if (!node) {
            return '';
        } else if (Navigator.isIE() && typeof node.innerText !== "undefined") {
            return node.innerText;
        } else  {
            return $(node).text();
        }
    };

    /**
     * Copy clipboardData from pasteEvent.originalEvent into pasteEvent or create and adapter
     * @param {Event} pasteEvent
     * @returns {Event}
     */
    exports.normalizePasteEvent = function(pasteEvent) {
        if(pasteEvent && pasteEvent.originalEvent && pasteEvent.originalEvent.clipboardData) {
            pasteEvent.clipboardData = pasteEvent.originalEvent.clipboardData;
        }

        // IE case, create small adapter for IE window.clipboardData
        if(pasteEvent && !pasteEvent.clipboardData && window.clipboardData) {
            pasteEvent.clipboardData = {
                files: window.clipboardData.files,
                types: {
                    contains: function(mimeType) {
                        if(mimeType == "text/plain") {
                            return !!window.clipboardData.getData("Text");
                        }
                    }
                },
                getData: function(mimeType) {
                    if(mimeType == "text/plain") {
                        return window.clipboardData.getData("Text");
                    }
                }
            };
        }

        return pasteEvent;
    };

    /**
     * Determine if the current browser is supported.
     * @param {string} [platform] If provided, overrides the value of navigator.platform.
     * @returns {boolean}
     */
    exports.browserIsSupported = function (platform) {
        var isMac = ((platform || "").indexOf("Mac") !== -1) || Navigator.isMac();
        var isSafari = Navigator.isSafari();

        // Safari isn't supported because it supports neither the HTML5 approach nor the Java applet approach.
        return !(isMac && isSafari);
    };

    /**
     * Determine wheter the current browser supports paste natively.
     * @returns {boolean}
     */
    exports.browserIsNativePaste = function () {
        return Navigator.isChrome() || Navigator.isSafari();
    };

    /**
     * Determine whether the unified attachments dark feature is enabled.
     * @returns {boolean}
     */
    exports.isUnifiedAttachmentsEnabled = function() {
        return FeatureManager.isFeatureEnabled("jira.unified.attachments");
    };

    /**
     * Determine whether the issuePasteDisabled dark feature is enabled.
     * @returns {boolean}
     */
    exports.isIssuePasteDisabledEnabled = function() {
        return FeatureManager.isFeatureEnabled("com.atlassian.plugins.jira.screenshot.issuePasteDisabled");
    };

    /**
     * Determine whether $pasteTarget is an input element and that it is a wiki textfield
     * @returns {boolean}
     */
    exports.isWikiTextfield = function ($pasteTarget) {
        return $pasteTarget.is(':input') && $pasteTarget.hasClass("wiki-textfield")
    };

    /**
     * Determine whether the element is the summary input field
     * @returns {boolean}
     */
    var _isSummaryField = function ($pasteTarget) {
        return $pasteTarget.is('input#summary');
    };

    /**
     * Append the given text content (if not null) to either the summary field or to a wiki textfield
     * @param content to be appended
     * @param pasteTarget element that will have the value updated
     * @param selectionStart
     * @param selectionEnd
     */
    var insertToInput = function (content, pasteTarget, selectionStart, selectionEnd) {
        var $pasteTarget = $(pasteTarget);

        // bail if pasteTarget is not a valid field or if no content was passed in
        if( !(exports.isWikiTextfield($pasteTarget) || _isSummaryField($pasteTarget)) || !content) {
            return;
        }

        if(!$pasteTarget.is(':focus')) {
            // This is a workaround for the case where the textfield is not focused (only needed for some browsers).
            // This ensures the cursor moves to the end of the text.
            $pasteTarget.one('focus', function() {
                var pasteTarget = $pasteTarget[0];
                pasteTarget.selectionStart = pasteTarget.selectionEnd = selectionStart + content.length;
            });
        }

        var value = $pasteTarget.val();
        var prefix = value.substring(0, selectionStart);
        var suffix = value.substring(selectionEnd, value.length);

        // wiki editor maintains its own history buffer, it helps us in some browser(Safari, IE)
        var wikiEditor = $pasteTarget.data("wikiEditor");
        if(wikiEditor && wikiEditor.undoRedoEl && _.isFunction(wikiEditor.undoRedoEl.recordHistoryItem)) {
            wikiEditor.undoRedoEl.recordHistoryItem();
        }

        $pasteTarget.val(prefix + content + suffix);

        // trigger input for dirty form handlers if there are any
        $pasteTarget.trigger("input");

        pasteTarget.selectionStart = pasteTarget.selectionEnd = selectionStart + content.length;

        if(wikiEditor && wikiEditor.undoRedoEl && _.isFunction(wikiEditor.undoRedoEl.updateCurrent)) {
            wikiEditor.undoRedoEl.updateCurrent();
        }
    };

    /**
     * Insert content into textfield at its current selection
     * @param {String} content
     * @param {HTMLElement} textfield
     * @param {Number} selectionStart current selection start
     * @param {Number} selectionEnd current selection end
     */
    exports.insertToInput = insertToInput;

    exports.getMarkup = function(fileName) {
        var animatedImageFileTypes = [
            'gif'
        ];
        var regularImageFileTypes = [
            'bmp',
            'jpeg',
            'jpg',
            'png'
        ];
        var nameParts = fileName.split('.');
        var fileType = nameParts[nameParts.length - 1].toLowerCase();
        if (_.contains(animatedImageFileTypes, fileType)) {
            return '!' + fileName + '!';
        } else if (_.contains(regularImageFileTypes, fileType)) {
            return '!' + fileName + '|thumbnail!';
        } else {
            return '[^' + fileName + ']';
        }
    };

    /**
     * Wrap fileName into wiki markup and insert it into textfield at its current selection
     * @param {String} fileName
     * @param {HTMLElement} pasteTarget
     * @param {Number} selectionStart current selection start
     * @param {Number} selectionEnd current selection end
     */
    exports.insertWikiMarkup = function (fileName, pasteTarget, selectionStart, selectionEnd) {
        var markup = exports.getMarkup(fileName);
        if (markup) {
            // Add a space before and after so that it will display properly if the user forgets to add spaces
            markup = " " + markup + " ";
            insertToInput(markup, pasteTarget, selectionStart, selectionEnd);
        }
    };

    /**
     * Load image from given source
     * @param imageSrc
     * @returns {$.Deferred}
     */
    exports.loadImage = function (imageSrc) {
        var deferred = new $.Deferred();

        var image = new Image();
        image.setAttribute("crossOrigin", "anonymous");
        image.onload = function() {
            deferred.resolve(image);
        };
        image.onerror = deferred.reject.bind(deferred);
        image.src = imageSrc;

        // maybe it was already loaded (from cache)
        if(image.width > 0 && image.height > 0) {
            deferred.resolve(image);
        }

        return deferred;
    };

    /**
     * Convert image to blob or return null when it is not possible
     * @param image
     * @returns {Blob}
     */
    exports.convertImageToBlob = function(image) {
        // off screen canvas and try feature detection
        var canvas = $('<canvas>').attr("width", image.width).attr("height", image.height)[0];
        canvas.getContext('2d').drawImage(image, 0, 0);
        try {
            if(canvas.mozGetAsFile) {
                return canvas.mozGetAsFile("image/png");
            }

            if(canvas.toDataURL) {
                return new Blob([base64decode.decodeBase64DataUri(canvas.toDataURL("image/png"))], { type: "image/png" });
            }
        } catch(e) {
            // in case of any exceptions (security, malformed uri etc)
            return null;
        }
    };

    /**
     * Convert a blob into an image
     * @param blob
     * @param imageName
     * @return {File}
     */
    exports.convertBlobToImage = function(blob, imageName) {
        var file = new Blob([blob.slice()], { type: blob.type });
        file.lastModifiedDate = new Date();
        file.name = imageName;
        return file;
    };

    /**
     * Try to drop image file to element and return true if the event was actually consumed
     * @param {Blob} file
     * @param {jQuery} element
     * @returns {Boolean} Returns true if drop was actually consumed
     */
    exports.dropFileToElement = function(file, $element) {
        var fileName = file.name;
        if(!fileName) {
            fileName = this.generateFileName();
            file.name = fileName + ".png";
        }
        var event = $.Event("drop", {dataTransfer: {files: [file]}});

        var result = false;
        $(document).on('dropHandled.dropFileToElement', function() {
            result = true;
        });
        $element.trigger(event);
        $(document).off('.dropFileToElement');
        return result;
    };

    exports.generateFileName = function() {
        return "image-" + time().format("YYYY-MM-DD-HH-mm-ss-SSS");
    };

    exports.getCurrentIssueId = function() {
        return JIRA.Issues.Api.getSelectedIssueId();
    };

    exports.showErrorMsg = function(title, message){
        JIRAFlag.showErrorMsg(title, message);
    };

    /**
     * Create Blob from file with same mime type and copied file.name.
     * This is required, because we want to pass file with modified name in drop event and name property of File is read only
     * @param {File} file
     * @returns {Blob}
     */
    exports.createBlobFromFile = function(file) {
        var fileBlob = new Blob([file.slice()], { type: file.type });
        fileBlob.name = file.name;
        return fileBlob;
    };

    /**
     * Check whether a drag event contains files. To be used during dragover/dragenter events to determine whether
     * we should show the dropzone or not. If dataTransfer.types is not supported (only IE) just returns true.
     * This doesn't work completely on Firefox, since they count dragging an image element from within the browser
     * as a 'file'.
     * @param event
     * @returns {boolean}
     */
    exports.dragEventContainsFiles = function (event) {
        // If we can't check the types, assume it does contain files.
        if (!event.dataTransfer || !event.dataTransfer.types) {
            return true;
        }

        // Behaviour
        // Mozilla: types = DOMStringList and contains "Files" even when a file is not dragging. It contains "application/x-moz-file" when a file is actually dragging
        // IE: types = DOMStringList and contains "Files" when dragging  a file
        // Chrome + Safari: types = Array and contains "Files" when dragging a file

        var types = event.dataTransfer.types;

        if (Navigator.isMozilla()) {
            return types.contains("application/x-moz-file");
        }

        // using a standard iterator as it works for both Array and DOMStringList
        for (var i = 0; i < types.length; i++) {
            if (types[i] === "Files") {
                return true;
            }
        }

        return false;
    };
});
;
;
/* module-key = 'com.atlassian.pocketknife.featureflags-plugin:pocketknife-feature-flags', location = '/featureflags/feature-manager.js' */
define("featureflags/feature-manager", [
    "exports"
], function(
    exports
    ){

    var json = WRM.data.claim("com.atlassian.pocketknife.featureflags-plugin:pocketknife-feature-flags.feature-flag-data");
    var systemEnabledFeatures = (json && json["enabled-feature-keys"]) || [];
    var featureFlagStates = (json && json["feature-flag-states"]) || {};

    var contains = function (arr, target) {
        return arr.indexOf(target) !== -1;
    };

    /**
     * Checks if the given feature is enabled. If no feature flag is defined with
     * the given feature key, this will fall-back to the default feature manager behaviour (like AJS.DarkFeatures.isEnabled(..))
     * @param featureKey a String, usually of the form "my.feature.key" (NOT "my.feature.key.enabled" or "my.feature.key.disabled")
     * @returns {boolean}
     */
    exports.isFeatureEnabled = function(featureKey){
        var flagState = featureFlagStates[featureKey];

        if(flagState === true){
            // Feature flag is in enabled state, check for (featureKey + ".disabled") to tell us otherwise
            var isSystemNegated = contains(systemEnabledFeatures, featureKey + ".disabled");
            return !isSystemNegated;
        }
        else if(flagState === false){
            // Disabled state, remain disabled unless (featureKey + ".enabled") is present
            var isSystemEnabled = contains(systemEnabledFeatures, featureKey + ".enabled");
            return isSystemEnabled;
        }
        else {
            // There is no flag defined with the given key, fall-back to what the system features say
            return contains(systemEnabledFeatures, featureKey);
        }
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/Configuration.js' */
define("dndattachment/util/Configuration", function() {
    var dataKey = "com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone.";

    function getWRMData(key) {
        return _.isFunction(WRM.data) ? WRM.data(key) : WRM.data.claim(key);
    }

    return {
        getWRM: function(key) {
            return getWRMData(dataKey + key);
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/DataTransfer.js' */
define("dndattachment/util/DataTransfer", ['jquery'], function ($) {
    return Class.extend({
        init: function(_dataTransfer) {
            this._dataTransfer = _dataTransfer;
        },

        getFiles: function() {
            var files = this._dataTransfer.files;
            var items = this._dataTransfer.items;

            if(items && items.length > 0) {
                if(_.any(items, function(item) { return !!item.webkitGetAsEntry; })) {
                    return this.readEntries(items);
                }
            }

            if(files && files.length > 0) {
                return this.readFiles(this._dataTransfer.files)
            } else {
                return new $.Deferred().reject();
            }
        },

        readFiles: function(files) {
            var result = new $.Deferred();

            $.when.apply(window, _.map(files, function(file) {
                var deferred = new $.Deferred();

                var noExtension = !file.name.match(/\.([a-z0-9]+)$/i);

                // if there is no extension, we rely on a fact that underlying implementation
                // will throw permission denied on fopen call for directory path
                // typical candidates for directory are paths without extension at the end
                // and also file.size 8192, 4096 and below 1024(Mac OS X)
                if(noExtension && (file.size <= 8192) || file.size == 8192 || file.size == 4096 || file.size <= 1024) {
                    this.readFileAsText(file).fail(function() {
                        files = _(files).without(file);
                    }).always(deferred.resolve.bind(deferred));
                } else {
                    deferred.resolve();
                }

                return deferred;
            }.bind(this))).always(function() {
                result.resolve(files);
            });

            return result;
        },

        readFileAsText: function(file) {
            var result = new $.Deferred();

            var reader = new FileReader();
            reader.onload = function() {
                result.resolve(this.result);
            };
            reader.onerror = function() {
                result.reject(this.error);
            };

            reader.readAsText(file);

            return result;
        },

        readEntries: function(items) {
            var result = new $.Deferred();

            // if dropped item is a file or a directory, item.kind === "file"
            items = _.filter(items, function(item){
                return item.kind === "file";
            });

            $.when.apply(window, _.map(items, function (item) {
                return this.readEntry(item.webkitGetAsEntry(), item);
            }.bind(this))).then(function() {
                result.resolve(_.union.apply(_, arguments));
            }, result.reject.bind(result));

            return result;
        },

        readEntry: function(entry, item) {
            var result = new $.Deferred();

            if(entry.isFile) {
                if(item && item.getAsFile) {
                    result.resolve([item.getAsFile()]);
                } else {
                    entry.file(function(file) {
                        result.resolve([file]);
                    });
                }
            } else if(entry.isDirectory) {
                entry.createReader().readEntries(function(entries) {
                    var files = [];

                    $.when.apply(window, _.map(entries, function(entry) {
                        return this.readEntry(entry).then(function(entryFiles) {
                            return files.push.apply(files, entryFiles);
                        });
                    }.bind(this))).always(function() {
                        result.resolve(files);
                    });
                }.bind(this));
            }

            return result;
        }
    })
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/FileSizeUtil.js' */
/**
 * Ported from com.atlassian.core.util.FileSize
 */

define('dndattachment/util/FileSizeUtil',
function() {
    var KB_SIZE = 1024;
    var MB_SIZE = KB_SIZE * KB_SIZE;

    var KB = " kB";
    var MB = " MB";

    /**
     * Format the size of a file in human readable form.  Anything less than a kilobyte
     * is presented in kilobytes to one decimal place.  Anything between a kilobyte and a megabyte is
     * presented in kilobytes to zero decimal places.  Anything greater than one megabyte is
     * presented in megabytes to two decimal places.
     * <p>
     * eg.
     * <ul>
     *  <li>format(512) -> 0.5 kb
     *  <li>format(1024) -> 1.0 kb
     *  <li>format(2048) -> 2 kb
     *  <li>format(1024 * 400) -> 400 kb
     *  <li>format(1024 * 1024) -> 1024 kb
     *  <li>format(1024 * 1024 * 1.2) -> 1.20 Mb
     *  <li>format(1024 * 1024 * 20) -> 20.00 Mb
     * </ul>
     *
     * @param   filesize  The size of the file in bytes.
     * @return  The size in human readable form.
     */
    function format(filesize) {
        // TODO: filesize = 1024 gives "1.0 kB", but filesize = 1025 gives "1 kB", this is kinda inconsistent.

        if (filesize > MB_SIZE)
        {
            return formatMB(filesize);
        }
        else if (filesize > KB_SIZE)
        {
            return formatKB(filesize);
        }
        else
        {
            return formatBytes(filesize);
        }

    }

    function formatMB(filesize) {
        var mbsize = filesize / MB_SIZE;
        return mbsize.toFixed(2) + MB;
    }

    function formatKB(filesize) {
        var kbsize = Math.round(filesize / KB_SIZE); //format 0 decimal places
        return kbsize + KB;
    }

    function formatBytes(filesize) {
        var mbsize = filesize / KB_SIZE;
        return mbsize.toFixed(1) + KB;
    }

    return {
        format: format
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/AttachmentEvents.js' */
/**
 * A dictionary of attachment related event types that JIRA will fire from time to time.
 * @module jira/util/events/types
 */
define('dndattachment/util/events/types', {
    // Export the event name so listeners don't have to
    ATTACHMENT_FOR_PAGE_RECEIVED: "attachmentForPageReceived"
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-upload', location = 'js/upload/UploadHandler.js' */
/**
 * An executor is what the handler calls to actually execute the upload
 * @typedef {Object} Executor
 *  @function {boolean} isValid(event, args) - returns true if the executor wants to be invoked.
 *  @function {deferred} processFiles(files, attachmentDropZone) - handles the actual processing of the file.
 *  Should return a deferred that properly communicates the outcome
 *  @property {number} weight - the weight of the executor when we loop through them. Higher the number, the earier we check it
 *  @property {string} name - name of the executor. This is used as the 'key' when we register and remove executors.
 */

/**
 * This listens for EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED and handles the uploading of the files.
 * This does not do the actual uploading, just collects the events and pass them along.
 */
define('dndattachment/upload/handler', [
    'jira/util/events',
    'dndattachment/util/events/types',
    'underscore',
    'jquery',
    'dndattachment/ctrlv/utility',
    'exports'
], function(
    Events,
    EventTypes,
    _,
    $,
    Utility,
    exports
) {
    // The list of registered upload executors
    var executorList = [];

    // The current attachmentDropZone that is relevant to us
    var attachmentDropZone;

    /**
     * This method is called to handle the ATTACHMENT_FOR_PAGE_RECEIVED event once it has been triggered by something.
     *
     * @param event - This will be ATTACHMENT_FOR_PAGE_RECEIVED
     * @param args - These are all the arguments that are passed in when the event is thrown. Typically they will
     * contain files, successCallback, failureCallback and alwaysCallback but may contain more things depending on the code
     * that receives the file.
     */
    var handleAttachmentReceived = function(event, args) {
        var uploadResult = $.Deferred();

        //if there's a dialog open, we simulate a drop and let the dialog handle it.
        var JIRADialog = JIRA.Dialog.current;
        if (JIRADialog) {
            AJS.trigger('analytics', { name : 'attach.screenshot.html5.dialogPaste', data : {}});

            var fileBlob = Utility.createBlobFromFile(args.files[0]);
            if(Utility.dropFileToElement(fileBlob, JIRADialog.$form)) {
                uploadResult.resolve([args.files[0].name]);
            }
        }
        else {
            var validExecutor = _.find(executorList, function(executor) {
                return executor.isValid(event, args);
            });
            if(validExecutor) {
                uploadResult = validExecutor.processFiles(args.files, attachmentDropZone);
                if(args.successCallback) {
                    uploadResult.done(args.successCallback);
                }
                if(args.failureCallback) {
                    uploadResult.fail(args.failureCallback);
                }
                if(args.alwaysCallback) {
                    uploadResult.always(args.alwaysCallback);
                }
            }
        }

        uploadResult.done(function(fileNames, noInsertMarkup) {
            if (!noInsertMarkup && args.isWikiTextfieldFocused) {
                var wikiTextfield = args.wikiTextfield;
                _.each(fileNames, function(fileName) {
                    Utility.insertWikiMarkup(fileName, wikiTextfield, wikiTextfield.selectionStart, wikiTextfield.selectionStart);
                });
                if (JIRADialog && args.isPaste) {
                    AJS.trigger('analytics', { name : 'attach.screenshot.html5.dialogPaste.insertWikiMarkup', data : {}});
                }
                // Focus back on the textfield if the executor caused it to lose focus.
                if (!$(args.wikiTextfield).is(":focus")) {
                    setTimeout(function () {
                        args.wikiTextfield.focus();
                    }, 0);
                }
            }
        });
    };

    var isExecutorValid = function(executor) {
        // Check that the executor exists
        if(executor) {
            // Check that the valid methods are defined
            var hasIsValidMethod = typeof executor.isValid !== 'undefined';
            var hasProcessFiles = typeof executor.processFiles !== 'undefined';
            var hasWeight = typeof executor.weight !== 'undefined';
            var hasName = typeof executor.name !== 'undefined';

            return hasIsValidMethod && hasProcessFiles && hasWeight && hasName;
        }
        return false;
    };

    /**
     * This registers an executor for handling the uploads.
     *
     * @param {Executor} executor - The executor to register
     * @returns {Boolean} - true if the registration was successful
     */
    exports.registerExecutor = function(executor) {
        var isValid = isExecutorValid(executor);
        if(isValid) {
            // Prevent duplicate executors
            var list = _.reject(executorList, function (ex) {
                return ex.name === executor.name;
            });

            // Add in the executor
            list.push(executor);

            // Sort by weight
            executorList = _.sortBy(list, function (ex) {
                // Negative weight so that highest numbers are sorted first
                return -ex.weight;
            });
        }
        return isValid;
    };

    /**
     * This unregisters an executor
     *
     * @param {Executor} executor - The executor to register
     */
    exports.unregisterExecutor = function(executor) {
        executorList = _.reject(executorList, function(ex) {
            return ex.name === executor.name;
        });
    };

    /**
     * Initialised the upload handler
     */
    exports.initialize = function() {
        // Handle any attachments that need to be uploaded directly onto the page through the main attachment zone
        Events.bind(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, handleAttachmentReceived);
    };

    /**
     * Remove the upload handler
     */
    exports.disable = function() {
        // Cleanup everything that was done in the initialize method
        Events.unbind(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, handleAttachmentReceived);
    };

    /**
     * Set the attachmentDropZone that should handle incoming attachments
     */
    exports.setAttachmentDropZone = function(dropZone) {
        attachmentDropZone = dropZone;
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-upload', location = 'js/upload/DefaultUploadExecutor.js' */
/**
 * This is the default executor that uploads the files when none of the other registered executors hit
 */
define('dndattachment/upload/default/executor', [
    'jquery',
    'underscore',
    'dndattachment/ctrlv/utility',
    'exports'
], function(
    $,
    _,
    Utility,
    exports
) {
    exports.name = 'Default attachment executor';

    /**
     * The default executor's weight is always 0. As in it is always the lowest thing
     */
    exports.weight = 0;

    /**
     * This executor is always valid
     */
    exports.isValid = function(event, args) {
        return true;
    };

    exports.processFiles = function(files, attachmentDropZone) {
        return attachmentDropZone.uploadFiles(files);
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/path.js' */
define("dndattachment/ctrlv/path", [
    "exports"
], function (
  exports
) {
    "use strict";

    /**
     * Get the basename of a URI (i.e. the last path component).
     * @param {String} uri
     * @returns {String}
     */
    var basename = function basename(uri) {
        return uri.split(/\//).pop();
    };

    exports.basename = basename;

    /**
     * Get everything *except* the basename of a URI.
     * @param {String} uri
     * @returns {String}
     */
    exports.dirname = function (uri) {
        var basenameResult = basename(uri);
        return uri.substring(0, uri.length - basenameResult.length);
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/ie_version.js' */
define("dndattachment/ctrlv/version", [
    "jquery",
    "underscore",
    "jira/util/navigator",
    "exports"
  ],
  function(
    $,
    _,
    Navigator,
    exports
  ){
    "use strict";


    // It's a sad state of affairs that we need this browser detection, but unfortunately there's no reliable feature
    // detection for image pasting from clipboard support, so we're left with browser detection.
    //
    // JIRA politely puts classes on <html> to identify the browser for us, so let's treat that as our browser detection
    // API. We only care about IE for special casing clipboard behaviour, for all other browsers we'll assume they
    // support the HTML5 clipboard API,
    var classes = document.documentElement.className.split(/\s+/);
    var isIE = Navigator.isIE();
    var gt7 = $.inArray("msie-gt-7", classes) > -1;
    var gt8 = $.inArray("msie-gt-8", classes) > -1;
    var gt9 = $.inArray("msie-gt-9", classes) > -1;
    var gt10 = $.inArray("msie-gt-10", classes) > -1;

    var isIE8  = isIE && gt7 && !gt8;
    var isIE9  = isIE && gt8 && !gt9;
    var isIE10 = isIE && gt9 && !gt10;

    exports.isIE8 = _.once(function(){
      return isIE8;
    });

    exports.isIE9 = _.once(function(){
      return isIE9;
    });

    exports.isIE10 = _.once(function(){
      return isIE10;
    });

});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/resource-uris.js' */
define("dndattachment/ctrlv/resource-uris", [
    "jquery",
    "exports"
], function (
  $,
  exports
) {
    "use strict";

    var dataKey = "com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources.resource-uris";
    var data = WRM.data.claim(dataKey) || {};

    exports.get = function(name) {
        return data[name];
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'templates/soy/attach-screenshot-form.soy' */
// This file was automatically generated from attach-screenshot-form.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Html5Screenshot.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Html5Screenshot == 'undefined') { JIRA.Templates.Html5Screenshot = {}; }


JIRA.Templates.Html5Screenshot.attachScreenshotForm = function(opt_data, opt_ignored) {
  return '<h2 class="dialog-title">' + soy.$$escapeHtml("Attach Screenshot") + '</h2><form action="ShowAttachScreenshotFormAction.jspa" class="aui" method="post" id="attach-screenshot-form" data-attach-secure-token="' + soy.$$escapeHtml(opt_data.attachUserToken) + '" data-submit-secure-token="' + soy.$$escapeHtml(opt_data.submitUserToken) + '"><input type="hidden" name="id" value="' + soy.$$escapeHtml(opt_data.id) + '"/><input type="hidden" name="atl_token" value="' + soy.$$escapeHtml(opt_data.atlToken) + '"><input type="hidden" name="formToken" value="' + soy.$$escapeHtml(opt_data.formToken) + '"><input type="hidden" name="filetoconvert" value=""><div class="attach-screenshot-padding"><div class="attach-screenshot-container"><div id="attach-screenshot-inner-container"><div class="mod-content"><ul class="item-details"><li><dl><dt>' + soy.$$escapeHtml("Take a screenshot:") + '</dt>' + ((opt_data.userPlatform == 'pc') ? '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3ePrtScn\x3c/kbd\x3e") + '</dd>' : '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3e\x26#8963; Ctrl\x3c/kbd\x3e + \x3ckbd\x3e\x26#8984; Cmd\x3c/kbd\x3e + \x3ckbd\x3e\x26#8679; Shift\x3c/kbd\x3e + \x3ckbd\x3e3\x3c/kbd\x3e") + '</dd>') + '</dl></li><li><dl><dt>' + soy.$$escapeHtml("Paste the image:") + '</dt>' + ((opt_data.userPlatform == 'pc') ? '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3eCtrl\x3c/kbd\x3e + \x3ckbd\x3ev\x3c/kbd\x3e") + '</dd>' : '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3e\x26#8984; Cmd\x3c/kbd\x3e + \x3ckbd\x3ev\x3c/kbd\x3e") + '</dd>') + '</dl></li></ul></div><input type="text" id="attach-screenshot-fake-input"><div class="attach-screenshot-padding attach-screenshot-padding-inner"><div id="attach-screenshot-image-container" class="attach-screenshot-image-container"><div class="attach-screenshot-placeholder"><div class="mod-content"><ul class="item-details"><li><dl><dt id="attach-screenshot-placeholder-message">' + soy.$$escapeHtml("Your image will be pasted here") + '</dt></dl></li></ul></div></div></div></div><div id=\'attach-max-size\' class="hidden">' + soy.$$escapeHtml(opt_data.maxSize) + '</div></div></div></div><fieldset><div><legend><span>' + soy.$$escapeHtml("Attach Screenshot") + '</span></legend><div id="attach-screenshot-filename-group" class="field-group"><div id="attach-screenshot-progress-container"></div><label for="attachscreenshotname">' + soy.$$escapeHtml("File name") + ' <span class="aui-icon icon-required">' + soy.$$escapeHtml("Required") + '</span></label><input class="text" type="text" id="attachscreenshotname" name="attachscreenshotname" title="File Name" value="' + soy.$$escapeHtml(opt_data.nextScreenshotName) + '"><div class="description">' + soy.$$escapeHtml("A file name to be used as attached image name") + '</div></div></div></fieldset><div class="buttons-container form-footer"><div class="buttons"><button class="aui-button aui-button-primary" id="attach-screenshot-html5-upload">' + soy.$$escapeHtml("Upload") + '</button><a href="#" class="cancel">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form>';
};
if (goog.DEBUG) {
  JIRA.Templates.Html5Screenshot.attachScreenshotForm.soyTemplateName = 'JIRA.Templates.Html5Screenshot.attachScreenshotForm';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/requireDeployJava.js' */
define("dndattachment/ctrlv/requireDeployJava", [
    "jquery",
    "dndattachment/ctrlv/resource-uris",
    "exports"
], function (
  $,
  resourceUris,
  exports
) {
    "use strict";

    var deployJavaPromise = null;

    /**
     * AMD-ish pattern akin to require('deployJava').
     *
     * Oracle provides a JavaScript function -- deployJava -- that makes it easy to install Java in the browser.
     * @returns a jQuery promise that's resolved with two arguments:
     *     - {Function} `deployJava`
     *     - {WindowProxy} the contentWindow where `deployJava` exists.
     */
    exports.requireDeployJava = function () {
        var deferred;

        if (deployJavaPromise !== null) {
            return deployJavaPromise;
        }

        deferred = $.Deferred();
        deployJavaPromise = deferred.promise();

        $('<iframe style="display: none !important; visibility: hidden !important; opacity: 0"/>')
            .attr('src', resourceUris.get("deployJava.html"))
            .one('load', function () {
                deferred.resolve(this.contentWindow.deployJava, this.contentWindow);
            })
            .one('error', deferred.reject.bind(deferred))
            .appendTo('body');

        return deployJavaPromise;
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/polyfill.js' */
define("dndattachment/ctrlv/polyfill", [
    "jquery",
    "underscore",
    "dndattachment/ctrlv/utility",
    "dndattachment/ctrlv/requireDeployJava",
    "dndattachment/ctrlv/resource-uris",
    "dndattachment/ctrlv/path",
    "dndattachment/ctrlv/version",
    "jira/ajs/ajax/smart-ajax",
    "exports"
], function (
  $,
  _,
  utility,
  requireDeployJava,
  resourceUris,
  path,
  version,
  SmartAjax,
  exports
) {
    "use strict";

    var appletNode;

    var pasteImageWidth = 510;
    var pasteImageHeight = 280;
    var dataURILimit = version.isIE8() ? 32000 : Number.MAX_VALUE;

    exports.pasteImageWidth = pasteImageWidth;
    exports.pasteImageHeight = pasteImageHeight;
    exports.dataURILimit = dataURILimit;

    /**
     * Create a rejected jQuery deferred. All arguments are passed to .reject().
     * @returns a jQuery deferred.
     */
    function fail() {
        var deferred = $.Deferred();
        return deferred.reject.apply(deferred, arguments);
    }

    var $node;

    // paste polyfill
    var handleKeydown = function (event) {
        if (utility.isKeyPasteEvent(event)) {
            appletNode.reload();
            var imageUri = appletNode.getClipboardData();
            if (imageUri) {
                var previewImageUri = appletNode.getClipboardData(pasteImageWidth, pasteImageHeight);
                if (previewImageUri.length > dataURILimit) {
                    var f = dataURILimit / previewImageUri.length;
                    previewImageUri = appletNode.getClipboardData(pasteImageWidth * f, pasteImageHeight * f);
                }
                $node.trigger('polyPaste', [imageUri, previewImageUri]);
            }
        }
    };

    /**
     * Use the Java applet to make a HTTP request.
     * @param data
     * @param requestUrl
     * @returns a jQuery deferred that pretends to be a jqXHR. The only addition is a '.abort()' method to try to
     *   conform closer to jqXHR API.
     */
    function executeAjaxUpload(data, requestUrl) {
        var cookies = document.cookies,
          deferred = $.Deferred();

        var xhr = {
            getResponseHeader: function (name) {
                return responseHeaders[name];
            }
        };

        var requestDeferred = new $.Deferred()
          .progress(_.bind(deferred.notify, deferred))
          .done(_.bind(deferred.resolve, deferred))
          .fail(function(error, responseJson) {
              var errorMessage = responseJson || JSON.stringify({ errorMessage: errorMessage });
              deferred.reject(null, null, null, new SmartAjax.SmartAjaxResult(xhr, 0, "error", errorMessage, true));
          });

        appletNode.doMultipartRequest(requestUrl, "UTF-8", window.navigator.userAgent, requestDeferred);
        // Java applets use the browser's cookie storage for URLConnection for non-http-only cookies. This means
        // xsrftoken and other cookies can pollute the browser's.
        deferred.always(function () {
            document.cookies = cookies;
        });
        return deferred;
    }

    /**
     * Install the polyfill to provide clipboard access to non-HTML5 browsers.
     *
     * @param {Element} node Where the 'keydown' event handler should be added.
     * @returns a jQuery promise that's resolved with [deployJava, contentWindow], or rejected
     *   with a [reason, message].
     *
     * Reasons include:
     * - "java-absent" -- Java isn't installed.
     * - "java-version" -- The version Java is not supported.
     * - "java-security" -- Java security settings are blocking the applet. Typically this can be overcome by
     *   lowering the 'Security Level' in Java's 'Control Panel' (e.g. from High to Medium).
     * - "unknown" -- Every other case.
     */
    exports.install = _.once(function (node) {
        $node = $(node);

        return requireDeployJava.requireDeployJava()
            .pipe(function (deployJava, contentWindow) {
                // Unfortunately using deployJava.versionCheck() isn't guaranteed to be accurate. Depending on the
                // platform and JRE. For example Java 1.7.0_06 on IE9 only reports the JRE as 1.7.0 (i.e. no update
                // information).
                // Given that the specific rules/cases/etc are ambiguous, we'll opt for doing a 'best effort' here
                // rather than hard coding a bunch of special case rules that aren't guaranteed to be reliable.
                var attributes,
                    parameters,
                    requiresLegacyApplet,
                    minimumVersion = '1.7.0_06',
                    uri;

                if (deployJava.getJREs().length === 0) {
                    return fail("java-absent");
                } else if (!deployJava.versionCheck(minimumVersion + '+')) {
                    return fail("java-version");
                }

                // Java 1.7.0_45 changed the manifest attributes that are required to allow JavaScript to invoke
                // applet methods. Java 1.7.0_40 and earlier requires the 'Trusted-Library' attribute, but later
                // versions require the 'Caller-Allowable-Codebase' attribute.
                //
                // See https://blogs.oracle.com/java-platform-group/entry/7u45_caller_allowable_codebase_and for more
                // details.
                requiresLegacyApplet = !deployJava.versionCheck('1.7.0_45+');
                uri = resourceUris.get(requiresLegacyApplet ? "clipboard-legacy.jar" : "clipboard.jar");

                attributes = {
                    id: 'JIRA HTML5 Images Applet',
                    codebase: path.dirname(uri),
                    code: "com.atlassian.plugins.jira.screenshot.applet.ScreenshotApplet.class",
                    archive: path.basename(uri),
                    width: 0,
                    height: 0
                };
                parameters = {
                    permissions: "all-permissions"
                };

                deployJava.runApplet(attributes, parameters, minimumVersion);
                appletNode = contentWindow.document.getElementById(attributes.id);

                try {
                    // We need a try/catch here because...
                    // A 'appletNode.isSecurity' doesn't work, because it's falsey on IE. We can use .hasOwnProperty
                    // but it doesn't tell us if it's a function, and 'typeof appletNode.isSecurity' returns
                    // "unknown".
                    if (!appletNode || !appletNode.isSecurityOk()) {
                        return fail("java-security");
                    }
                } catch (e) {
                    return fail("java-security");
                }

                if(! utility.isUnifiedAttachmentsEnabled()){
                    $node.on('keydown', handleKeydown);
                }
                return executeAjaxUpload;
            }, function () {
                return fail("unknown");
            })
            // Add a message to the error.
            .pipe(null, function (reason) {
                var messages;
                if(utility.isUnifiedAttachmentsEnabled()){
                    messages = {
                        "unknown": "A problem occurred while attempting to attach screenshot via Ctrl+V.",
                        "java-version": AJS.format("You need to {0}upgrade Java{1} to be able to attach screenshots via Ctrl+V.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-absent": AJS.format("You need to install {0}Java{1} to be able to attach screenshots via Ctrl+V.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-security": AJS.format("Your Java security settings are blocking the ability to attach screenshots via Ctrl+V. Please upgrade to the latest {0}Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>")
                    }
                } else {
                    messages = {
                        "unknown": "A problem occurred while running Java.",
                        "java-version": AJS.format("You need to {0}upgrade Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-absent": AJS.format("You need to install {0}Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-security": AJS.format("Your Java security settings are blocking this feature. Please upgrade to the latest {0}Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>")
                    }
                }

                return fail(reason, messages[reason]);
            });
    });

    exports.getClipboardData = function(){
        var deferred = new $.Deferred();
        exports.install(document).done(function(){
            try {
                appletNode.reload();
                deferred.resolve(appletNode.getClipboardData());
            } catch(e){
                deferred.reject("A problem occurred while attempting to attach screenshot via Ctrl+V.");
            }
        }).fail(function(reason, message){
            deferred.reject(message);
        });
        return deferred;
    };

    exports.isRequired = function () {
        // Enable the Java applet for IE 8/9/10, assume all other browsers are compatible, since we
        // support latest IE, Chrome, Firefox, and all of these support HTML5 clipboard.
        return version.isIE8() || version.isIE9() || version.isIE10();
    };

    exports.isRequiredForBinaryAjax = function () {
        // The applet has security restrictions on Windows 8 + IE10, so we can't use it there. Luckily IE10 supports
        // AJAX requests with binary data anyway, so we can use that. IE8 and IE9 don't support binary data.
        return version.isIE8() || version.isIE9();
    };

    // proxy ajax request, because session with temporary attachments is in applet
    exports.proxyAjaxRequest = function (fn, userTokenFn) {
        return function () {
            var _smartAjaxMakeRequest = SmartAjax.makeRequest;

            SmartAjax.makeRequest = function (requestOptions) {
                var requestParams = _.reduce(_.keys(requestOptions.data), function (r, name) {
                    r.push(name, requestOptions.data[name]);
                    return r;
                }, []);

                requestParams.push("secureToken", userTokenFn());

                var requestResult = appletNode.doAjaxRequest(requestOptions.url, "UTF-8", window.navigator.userAgent, $.Deferred(), requestParams);
                requestResult.abort = $.noop;
                requestResult.then(function (data) {
                    var responseHeaders = _.filter(arguments, function (el, idx) {
                        return idx > 0;
                    });
                    responseHeaders[0] = "Status";
                    responseHeaders = _.reduce(_.reduce(responseHeaders, function (r, el, idx) {
                        var pdx = (idx / 2) << 0;
                        (r[pdx] || (r[pdx] = [])).push(el);
                        return r;
                    }, []), function (r, el) {
                        r[el[0]] = el[1];
                        return r;
                    }, {});

                    var xhr = {
                        getResponseHeader: function (name) {
                            return responseHeaders[name];
                        }
                    };
                    var textStatus = 'success';
                    var smartAjaxResult = new SmartAjax.SmartAjaxResult(xhr, 0, "success", data, true);
                    requestOptions.complete(xhr, textStatus, smartAjaxResult);
                });

                return requestResult;
            };

            fn.apply(this, arguments);

            SmartAjax.makeRequest = _smartAjaxMakeRequest;
        };
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/html5.js' */
define("dndattachment/ctrlv/html5", [
    "jquery",
    "underscore",
    "dndattachment/ctrlv/polyfill",
    "dndattachment/ctrlv/base64decode",
    "dndattachment/ctrlv/utility",
    "jira/dialog/dialog",
    "jira/dialog/dialog-register",
    "jira/ajs/ajax/smart-ajax",
    "jira/attachment/inline-attach",
    "exports"
], function (
  $,
  _,
  polyfill,
  base64decode,
  utility,
  Dialog,
  DialogRegister,
  SmartAjax,
  InlineAttach,
  exports
) {
    "use strict";

    /**
     * Try to get File Blob from event object, function is asynchronous since on some browsers we may want to
     * implement an workaround for clipboardData.items/files absence
     *
     * @param event JQuery Event object
     * @returns {$.Deferred}
     */
    exports.getFileFromEvent = function (event) {
        var deferred = new $.Deferred();

        if (utility.isImagePasteEvent(event)) {
            // look for image content in items and files, check mimetype and return the first one
            deferred.resolve(
                _(event.clipboardData.items)
                    .filter(function (item) {
                        return item.type.indexOf("image") !== -1;
                    }).map(function (item) {
                        return item.getAsFile();
                    })[0] ||
                    // according to bugzilla in future Mozilla will support this via files:
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=891247
                _(event.clipboardData.files)
                    .filter(function (item) {
                        return item.type.indexOf("image") !== -1;
                    })[0]);
        } else {
            deferred.reject();
        }

        return deferred.promise();
    };

    //exports.screenshotPasteHandler = {
    exports.REQUEST_TIMEOUT_MILLIS = 5 * 60 * 1000;

    exports.screenshotFileUpload = {};
    exports.screenshotFileUploadUri = null;

    exports.$document = undefined;
    exports.$window = undefined;
    exports.$container = undefined;
    exports.$fakeInput = undefined;

    exports.uploadError = false;
    exports.uploadErrorMsg = "";

    exports.progressView = {
        hidden: false,
        progress: 0,
        old: 0,
        progressBarContainer: undefined,
        progressEl: undefined,
        container: undefined,
        options: undefined,
        staticProgress: undefined,

        initProgress: function () {
            this.container = this.buildContainer();
            this.progressEl = this.buildProgress();
            this.container.append(this.progressEl);

            this.options = {showPercentage: false, height: "5px"};

            this.progressBarContainer = $("#attach-screenshot-progress-container");
            this.progressBarContainer.empty();
            this.progressBarContainer.append(this.container);

            this.staticProgress = this.container;
            this.hidden = true;
        },

        finish: function () {
            this.value(100);
        },

        progressHandler: function (event) {
            var percentage = Math.round(event.loaded * 100 / event.total);
            this.value(percentage);
        },

        value: function (value) {
            if (value > 100) {
                value = 100;
            } else if (value < 0) {
                value = 0;
            }

            if (this.hidden) {
                this.progressEl.show();
                this.hidden = false;
            }

            if (this.old !== value) {
                this.progressEl.progressBar(value, this.options);
                if (value >= 100) {
                    this.progressEl.fadeOut();
                }
                this.old = value;
            }
        },

        buildContainer: function () {
            return $("<div>").addClass("file-progress");
        },

        buildProgress: function () {
            return $("<div>").attr("id", "attach-screenshot-upload-progress");
        }
    };

    exports.dialogView = {
        pasteCatcher: {},
        presenter: undefined,

        getMaxSize: function () {
            return $("#attach-max-size").text();
        },

        getFileSize: function () {
            if ($.isPlainObject(this.presenter.screenshotFileUpload) && _.isEmpty(this.presenter.screenshotFileUpload)) {
                return 0;
            }
            return this.presenter.screenshotFileUpload.size || this.presenter.screenshotFileUpload.byteLength || this.presenter.screenshotFileUpload.length;
        },

        cleanGeneralErrors: function () {
            $("#error-attach-screenshot-image").closest(".field-group").remove();
        },

        cleanFileErrors: function () {
            $("#error-attach-screenshot-filename").remove();
        },

        displayErrors: function (errors) {
            if(utility.isUnifiedAttachmentsEnabled()){
                if ("compatibility" in errors) {
                    utility.showErrorMsg("", errors["compatibility"]);
                }
                if ("fileName" in errors) {
                    utility.showErrorMsg("", errors["fileName"]);
                }
                if ("fileUpload" in errors) {
                    utility.showErrorMsg("", errors["fileUpload"]);
                }
            }
            else{
                // cleanup old error messages
                exports.dialogView.cleanFileErrors();
                exports.dialogView.cleanGeneralErrors();

                if ("compatibility" in errors) {
                    $("#attach-screenshot-inner-container").before(aui.message.error({
                        content: errors["compatibility"]
                    }));
                }
                if ("fileName" in errors) {
                    $("#attach-screenshot-filename-group").append("<div class=\"error\" id=\"error-attach-screenshot-filename\" data-field=\"attachscreenshotname\"></div>").find('.error').text(errors["fileName"]);
                }
                if ("fileUpload" in errors) {
                    $("#attach-screenshot-inner-container").append("<div class=\"field-group attach-screenshot-image-error\"><div class=\"error\" id=\"error-attach-screenshot-image\"></div></div>").find('.error').text(errors["fileUpload"]);
                }
            }
        },

        appendBlobImage: function (blob) {
            // and use a URL or webkitURL (whichever is available to the browser)
            // to create a temporary URL to the object
            var URLObj = window.URL || window.webkitURL;
            var source = URLObj.createObjectURL(blob);
            this.presenter.screenshotFileUpload = blob;
            this.createImage(source);
        },

        /**
         * Creates and shows image
         * Supports:
         *  Chrome binary data from Webkit
         *  base64 encoded data from FireFox
         * @param uri image data
         */
        createImage: function (uri) {
            var pastedImage = new Image();
            pastedImage.onload = function () {
                // You now have the image!
            };
            pastedImage.src = uri;

            this.presenter.screenshotToUpload = pastedImage;

            // Appending image to document
            var jqueryImage = $(pastedImage);
            jqueryImage.addClass("attach-screenshot-pasted-image");
            var screenshotContainer = $("#attach-screenshot-image-container");
            screenshotContainer.empty();
            screenshotContainer.append(jqueryImage);

            this.presenter.$fakeInput.focus();

            // handle async upload
            // IE11 quirk: if this is called within onPaste handler, browser will throw "Access denied" on any XHR
            _.defer(function () {
                exports.imageCreatedHandler();
            });

        },

        /**
         * Parse the input in the paste catcher element
         */
        checkInput: function () {
            var image,
              node = exports.dialogView.pasteCatcher.childNodes[0];

            if (node) {
                // If the user pastes an image, the src attribute
                // will represent the image as a base64 encoded string.
                if ("IMG" === node.tagName) {
                    // does not start with data, try to get contents via canvas
                    if (node.src.indexOf("data:") === 0) {
                        image = node.src;
                    } else {
                        // we could use canvas and toDataURL here, but it is not allowed by browser:
                        // https://html.spec.whatwg.org/multipage/scripting.html#dom-canvas-todataurl
                    }
                }

                // Clear the inner html to make sure we're always getting the latest inserted content.
                exports.dialogView.pasteCatcher.innerHTML = "";
            }

            if (!image) {
                exports.$fakeInput.focus();
            }

            return image;
        },

        /**
         * onPaste handler, Either uses webkits clipboardData object on the paste event, or interprets
         * the data uri that has been embedded in the page by firefox.
         */
        onPaste: function (event) {
            exports.dialogView.cleanFileErrors();
            exports.dialogView.cleanGeneralErrors();

            // TODO: ensure target is not text fields - this prevents pasting text in text fields

            // We need to check if event contains image content we can use
            if (utility.isImagePasteEvent(event)) {
                // Get the items from the clipboard
                exports.getFileFromEvent(event).then(function (file) {
                    this.appendBlobImage(file);
                }.bind(this));
                // If we can't handle clipboard data directly (Firefox),
                // we need to read what was pasted from the contenteditable element
            } else {
                setTimeout(function () {
                    var image = this.checkInput();

                    if (image) {
                        // Firefox image is base64 encoded - decoding while setting up the data
                        exports.screenshotFileUpload = base64decode.decodeBase64DataUri(image);
                        exports.dialogView.createImage(image);
                    }

                }.bind(this), 0);
            }
        },

        getFakeInput: function () {
            return $("#attach-screenshot-fake-input");
        },

        getContainer: function () {
            return $("#attach-screenshot-image-container");
        },

        getIssueKey: function () {
            return $("input[name='id']").val();
        },

        getDocument: function () {
            return $(document);
        },

        getWindow: function () {
            return $(window);
        },

        getFileNameInput: function () {
            return $("#attachscreenshotname");
        },

        hasPngExtension: function (str) {
            var pattern = /\.png$/i; // REGEX: Ends with ".png". Case insensitive
            return pattern.test(str);
        },

        setFileToConvert: function (value) {
            $("input[name='filetoconvert']").val(value);
        },

        /**
         * Pasting into a content-editable element is the most cross-browser HTML5 approach.
         */
        buildPasteCatcher: function () {
            if (!document.getElementById("attach-screenshot-form")) return;
            var catcher = document.createElement("div");
            catcher.setAttribute("contenteditable", "true");
            catcher.style.width = 0;
            catcher.style.height = 0;
            /* make sure the catcher is rendered outside the browser view to prevent vertical scrollbars */
            catcher.style.position = 'absolute';
            catcher.style.top = '-5000px';
            document.getElementById("attach-screenshot-form").appendChild(catcher);
            return catcher;
        },

        _getFormSubmits: function () {
            return $("#attach-screenshot-form").find("button.aui-button");
        },

        disable: function () {
            this._getFormSubmits().attr("disabled", "disabled");
            return this;
        },
        enable: function () {
            this._getFormSubmits().removeAttr("disabled");
            return this;
        },
        isEnabled: function () {
            return this.isVisible() && !this._getFormSubmits().attr("disabled");
        },

        isVisible: function () {
            return $("#attach-screenshot-form").length > 0;
        },

        initDialog: function (presenter) {
            this.pasteCatcher = {};
            this.presenter = presenter;

            if (!polyfill.isRequired()) {
                this.pasteCatcher = this.buildPasteCatcher();
            }
        }
    };

    exports.initScreenshotPasteHandler = function () {
        var dialogView = exports.dialogView;

        exports.screenshotFileUpload = {};
        exports.resetUploadErrors();

        exports.dialogView.initDialog(exports);

        // Caching elements needed to fix tabbing
        exports.$document = dialogView.getDocument();
        exports.$window = dialogView.getWindow();
        exports.$container = dialogView.getContainer();
        exports.$fakeInput = dialogView.getFakeInput();

        // Event Handlers
        exports.bindOnce(exports.$container, "click", exports.setFocusOnClickHandler);
        exports.bindOnce(exports.$fakeInput, "focus", exports.showFocusOnFieldHandler);
        exports.bindOnce(exports.$fakeInput, "blur", exports.hideFocusOnFieldHandler);
        exports.bindOnce(exports.$fakeInput, "keydown", exports.keyDownHandler);

        if (!utility.browserIsSupported()) {
            dialogView.displayErrors({"compatibility": AJS.format("Your browser is not supported. Consider using an alternative supported browser such as {0}Google Chrome{1} or {2}Firefox{3}.", "<a href=\"//www.google.com/chrome/browser/\">", "</a>", "<a href=\"//www.mozilla.org/firefox/\">", "</a>")});
        } else if (polyfill.isRequired()) {
            polyfill.install(document)
              .done(function (executeAjaxUploadFromApplet) {
                  exports.bindOnce(exports.$document, "polyPaste", exports.polyPasteHandler);
                  if (polyfill.isRequiredForBinaryAjax()) {
                      exports.executeAjaxUpload = executeAjaxUploadFromApplet;
                  }
              })
              .fail(function (reason, message) {
                  dialogView.displayErrors({"compatibility": message});
              });
        } else {
            exports.bindOnce(exports.$window, "paste", exports.pasteHandler);
        }
    };

    exports.resetUploadErrors = function () {
        exports.uploadError = false;
        exports.uploadErrorMsg = undefined;
    };

    exports.setUploadError = function (errorMsg) {
        exports.uploadError = true;
        exports.uploadErrorMsg = errorMsg;
    };

    /**
     * Ensures only one event is bound to the element
     * @param jqueryEl
     * @param eventName
     * @param handler
     */
    exports.bindOnce = function (jqueryEl, eventName, handler) {
        jqueryEl.unbind(eventName, handler);
        jqueryEl.bind(eventName, handler);
    };

    exports.showFocusOnFieldHandler = function () {
        exports.$container.addClass("focus");
    };

    exports.hideFocusOnFieldHandler = function () {
        exports.$container.addClass("focus");
    };

    exports.setFocusOnClickHandler = function () {
        exports.$fakeInput.focus();
    };

    exports.pasteHandler = function (event) {
        if (!exports.dialogView.isEnabled()) {
            return;
        }
        event = utility.normalizePasteEvent(event);

        exports.dialogView.onPaste(event);
    };

    exports.polyPasteHandler = function (event, imageUri, imagePreviewUri) {
        if (!exports.dialogView.isEnabled()) {
            return;
        }

        exports.screenshotFileUpload = {length: -1};
        exports.screenshotFileUploadUri = imageUri;
        exports.dialogView.createImage(imagePreviewUri);
    };

    exports.keyDownHandler = function (event) {
        if (utility.isKeyPasteEvent(event)) {
            if (exports.dialogView.pasteCatcher.focus) {
                exports.dialogView.pasteCatcher.focus();
            }
        }
    };

    exports.imageCreatedHandler = function () {
        exports.doAjaxUpload(this.dialogView.getIssueKey(), this.dialogView.getFileNameInput().val());
    };

    exports.getMimeType = function () {
        if (polyfill.isRequired()) {
            return "image/jpeg";
        }
        return "image/png";
    };

    exports.createData = function () {
        if (polyfill.isRequired() && !polyfill.isRequiredForBinaryAjax() && !utility.isUnifiedAttachmentsEnabled()) {
            return base64decode.decodeBase64DataUri(exports.screenshotFileUploadUri);
        }
        return exports.screenshotFileUpload;
    };

    // TODO function is not called delete?
    exports.clipboardDataIsEmpty = function (event) {
        // Internet Explorer will fire paste event for anything but image content, therefore we can assume that such event is not empty
        if (window.clipboardData != null) {
            return false;
        }

        return !(event && event.clipboardData && event.clipboardData.types && event.clipboardData.types.length > 0);
    };

    exports.validateFileSize = function (errors, fileSize, maxSize) {
        var fileSize = fileSize || exports.dialogView.getFileSize();
        var maxSize = maxSize || exports.dialogView.getMaxSize();
        if (fileSize > maxSize) {
            //TODO: hack, using IninleAttach module, check if this a blessed way to go
            var sizes = InlineAttach.Text.fileSize(maxSize, fileSize);
            errors["fileUpload"] = AJS.format("Screenshot is too large to attach. Attachment is {0} but the largest allowed attachment is {1}.", sizes[1], sizes[0]);
        }
    };

    exports.validateFormData = function (fileUpload, fileName) {
        var errors = {};

        if ($.isPlainObject(fileUpload) && _.isEmpty(fileUpload)) {
            errors["fileUpload"] = "Please paste the image you wish to upload";
        }
        exports.validateFileSize(errors);
        if (exports.uploadError) {
            errors["fileUpload"] = "The error occurred during image upload - you will need to try the pasting image again. Sorry for the inconvenience.";
        }

        if ("" == fileName) {
            errors["fileName"] = "You must specify a filename of the image.";
        }

        if (!utility.isValidFileName(fileName)) {
            errors["fileName"] = "Filename must not contain the characters \'\\\', \'/\', \'\"\', \':\', \'?\', \'*\', \'\u003c\', \'|\', \'\u003e\', \'!\'";
        }
        return errors;
    };

    exports.doAjaxUpload = function (issueKey, fileName) {
        exports.dialogView.disable();

        var errors = {};
        exports.validateFileSize(errors);
        if (!_.isEmpty(errors)) {
            exports.dialogView.displayErrors(errors);
            exports.dialogView.enable();

            // Prevent form from uploading
            return;
        }

        var data = exports.createData(),
          mimeType = exports.getMimeType(),
          secureToken = $("#attach-screenshot-form").data("attach-secure-token"),
          formToken = $("#attach-screenshot-form").find("input[name='formToken']").attr('value');

        var requestUrl = AJS.contextPath() + "/rest/internal/1.0/AttachTemporaryFile" +
          (polyfill.isRequired() ? "/secure?" : "?") +
          "size=" + exports.dialogView.getFileSize() + "&" +
          "filename=" + encodeURIComponent(fileName) + "&" +
          "atl_token=" + encodeURIComponent(atl_token()) + "&" +
          "issueId=" + encodeURIComponent(this.dialogView.getIssueKey()) +
          (secureToken ? ("&secureToken=" + encodeURIComponent(secureToken)) : "") +
          (formToken ? ("&formToken=" + encodeURIComponent(formToken)) : "");

        exports.resetUploadErrors();
        exports.executeAjaxUpload(data, requestUrl, mimeType).progress(function (val) {
            if (val == 'init') {
                exports.progressView.initProgress();
            }
        }).done(function (val) {
            if (typeof val == "string") {
                val = JSON.parse(val);
            }

            exports.dialogView.setFileToConvert(val.id);
        }).fail(function (jqXHR, textStatus, msg, smartAjaxResult) {
            var errMsg;
            if (smartAjaxResult.statusText == "abort") {
                errMsg = "The call to the JIRA server did not complete within the timeout period.  We are unsure of the result of this operation.";
            } else if (smartAjaxResult.hasData) {
                var data = JSON.parse(smartAjaxResult.data);

                if (data.errorMessage) {
                    errMsg = data.errorMessage;
                } else {
                    errMsg = SmartAjax.buildSimpleErrorContent(smartAjaxResult, {alert: false});
                }
            }
            exports.setUploadError(errMsg);
            exports.dialogView.displayErrors({"fileUpload": errMsg});
        }).always(function () {
            var deferred = $.Deferred();

            // polyfill is required so we need a new secureToken
            if (polyfill.isRequired()) {
                exports.reloadSecureToken(deferred);
            } else {
                deferred.resolve();
            }

            deferred.then(function () {
                exports.dialogView.enable();
                // Progress Listener cleanup
                exports.progressView.finish();
            });
        }).progress(function (val) {
            if (val != 'init') {
                exports.progressView.progressHandler(val);
            }
        });
    };

    exports.executeAjaxUpload = function (data, requestUrl, mimeType) {
        var deferred = $.Deferred();

        var xhr = SmartAjax.makeRequest({
            type: 'POST',
            url: requestUrl,
            contentType: mimeType,
            processData: false,
            data: data,
            timeout: exports.REQUEST_TIMEOUT_MILLIS,
            success: deferred.resolve.bind(deferred),
            error: deferred.reject.bind(deferred),
            xhr: function () {
                var xhr = $.ajaxSettings.xhr();

                deferred.notify('init');
                xhr.upload.addEventListener("progress", deferred.notify.bind(deferred));
                return xhr;
            }
        });

        deferred.always(function () {
            $.ajaxSettings.xhr().removeEventListener("progress", exports.progressView.progressHandler);
            $(DialogRegister.attachScreenshotDialog).off("Dialog.hide", xhr.abort);
        });

        // cancel upload on dialog hide
        $(DialogRegister.attachScreenshotDialog).one("Dialog.hide", xhr.abort);

        return deferred.promise();
    };

    exports.reloadSecureToken = function (deferred) {
        var formUrl = AJS.contextPath() + "/secure/ShowAttachScreenshotFormAction!default.jspa?" +
          "id=" + encodeURIComponent(this.dialogView.getIssueKey()) +
          "&inline=true&decorator=dialog&_=" + (new Date().getTime());

        $.get(formUrl).then(function (response) {
            var newToken = $(response).find("#attach-screenshot-form").data("attach-secure-token");
            if (newToken) {
                $("#attach-screenshot-form").data("attach-secure-token", newToken);
                deferred.resolve(newToken);
            } else {
                deferred.reject();
            }
        }, _.bind(deferred.reject, deferred));
    };

    /**
     * Trigger Attach Screenshot dialog and resolve deferred once it is open
     *
     * @returns {$.Deferred}
     */
    exports.show = function () {
        var deferred = new $.Deferred();
        var $dialogTrigger = $(".issueaction-attach-screenshot-html5.aui-list-item-link");

        // Such situation is not supported yet
        // TODO remove once we add support for textfields in create issue dialog (temporary attachments problem)
        if (Dialog.current != null) {
            return deferred.reject().promise();
        }

        // trigger is not available
        // TODO refactor when we start supporting create issue dialog
        if ($dialogTrigger.length == 0) {
            return deferred.reject().promise();
        }

        // IE11 quirk: if this is called within onPaste handler, browser will throw "Access denied" on any XHR
        _.defer(function () {
            $dialogTrigger.trigger("click");
        });

        $(document).on("dialogContentReady", function (event, dialog) {
            if (dialog === DialogRegister.attachScreenshotDialog &&
              exports.dialogView.isEnabled()) {
                deferred.resolve(dialog);
            } else {
                deferred.reject();
            }
        });

        // each impression of dialog causes ajax request, reject deferred if there was request for dialog content, but after some brief time deferred was still not resolved
        $(document).on("ajaxComplete.jira.screenshot.dialog", function (event, jqXhr, options) {
            if (options.url.indexOf($dialogTrigger.attr("href")) > -1) {
                setTimeout(function () {
                    if (!deferred.isResolved()) {
                        deferred.reject();
                    }
                }, 1000);
            }
        });

        // unbind from ajaxComplete
        deferred.always(function () {
            $(document).off("ajaxComplete.jira.screenshot.dialog");
        });

        return deferred.promise();
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/issue-paste.js' */
define("dndattachment/ctrlv/issue-paste", [
    "jquery",
    "dndattachment/ctrlv/trace",
    "dndattachment/ctrlv/tracking",
    "dndattachment/ctrlv/utility",
    "dndattachment/ctrlv/html5",
    "dndattachment/ctrlv/polyfill",
    "dndattachment/ctrlv/base64decode",
    "jira/dialog/dialog",
    "jira/util/events",
    'dndattachment/util/events/types',
    "exports"
], function (
  $,
  trace,
  tracker,
  utility,
  html5,
  polyfill,
  base64decode,
  Dialog,
  Events,
  EventTypes,
  exports
) {
    "use strict";

    /** Ze State Machine **/

    // Event types
    var EVENT_WINDOW_KEYDOWN = 0;
    var EVENT_WINDOW_PASTE = 1;

    var EVENT_FILE_LOADED = 2;
    var EVENT_FILE_LOAD_ERROR = 3;

    var EVENT_IMAGE_LOADED = 4;
    var EVENT_IMAGE_LOAD_ERROR = 5;

    var EVENT_DIALOG_LOADED = 6;
    var EVENT_DIALOG_CLOSED = 7;
    var EVENT_DIALOG_CANCELED = 8;

    var EVENT_TIMEOUT = 9;
    /**
     * Stub function, does nothing, in future may wrap states in some default behavior
     * @param {Function} state
     * @returns {State}
     * @constructor
     */
    function State(stateName, state) {
        state.stateName = stateName;
        var result = function() {
            var handler = state.apply(null, arguments);
            handler.stateName = stateName;
            return handler;
        };
        result.stateName = stateName;

        return result;
    }

    /**
     * Wraps given state, so that it will receive EVENT_TIMEOUT event after given timeout
     * @param {Function} state
     * @param {Number} timeout in milliseconds
     * @returns {WeakState}
     * @constructor
     */
    function WeakState(stateName, state, timeoutDelay) {
        return State(stateName, function() {
            var timeout = setTimeout(function() {
                triggerEvent(EVENT_TIMEOUT);
            }, timeoutDelay);

            var handler = state.apply(null, arguments);
            var result = function(eventType, eventObject) {
                var result = handler(eventType, eventObject);
                // we will change state, so clear timeout
                if(result) {
                    clearTimeout(timeout);
                    return result;
                }
            };
            result.stateName = stateName;

            return result;
        });
    }

    /**
     * Idle state, initial
     */
    var StateIdle = State("idle", function() {

        function isValidTarget(event) {
            // - don't play with catching paste events on any input elements other than wiki-textfield
            // - ignore content editable, because it will rather handle paste on its own
            // - summary field is an exception, because it is focused by default in create issue dialog
            if($(event.target).is(':input:not(.wiki-textfield, #summary)') || utility.isContentEditable(event.target)) {
                return;
            }

            return true;
        }


        return function(eventType, eventObject) {
            // We have this just in case something goes wrong after OD deployment
            if(utility.isIssuePasteDisabledEnabled()) {
                trace("jira/attach-images-plugin/issuePasteDisabled");
                return;
            }

            if(eventType == EVENT_WINDOW_KEYDOWN && utility.isKeyPasteEvent(eventObject)) {
                // in chrome we rely 100% on onPaste event, in Safari we don't want to make any attempts on catching clipboard data
                if (utility.browserIsNativePaste() || !isValidTarget(eventObject) || !utility.browserIsSupported()) {
                    return;
                }

                tracker.trigger("attach.screenshot.html5.catchClipboard");

                return new StateCatchClipboard(eventObject);
            }

            if(eventType == EVENT_WINDOW_PASTE) {
                if(utility.isImagePasteEvent(eventObject)) {
                    tracker.trigger("attach.screenshot.html5.handlePaste");

                    if(!isValidTarget(eventObject)) {
                        trace("jira/attach-images-plugin/pasteIgnored");
                        return;
                    }

                    /** Prevent paste now so after pressing cancel in dialog selected fragment in textarea won't be removed */
                    if($(eventObject.target).is(':input.wiki-textfield')) {
                        eventObject.preventDefault();
                    }

                    return new StateFileLoading(eventObject);
                } else {
                    trace("jira/attach-images-plugin/pasteIgnoredNotImage");
                }
            }
        }
    });

    /**
     * Catch clipboard contents after CTRL+V
     * @param {Event} keyPasteEvent
     */
    var StateCatchClipboard = WeakState("catchClipboard", function(keyPasteEvent) {
        // we will switch focus from currently active element, but we want to restore it once we are done with this state
        var activeElement = document.activeElement;

        // preserve initial selection information for later use
        keyPasteEvent.selectionStart = keyPasteEvent.target.selectionStart;
        keyPasteEvent.selectionEnd = keyPasteEvent.target.selectionEnd;

        var $contentEditable = $('<div contenteditable="true" class="attach-screenshot-paste-catcher"></div>').appendTo('body');

        // focus on content editable, so the paste event will go into this element and we will get content from it (possible an image)
        $contentEditable.focus();

        // we rely on :focusable or :aui-focusable selector from AUI, we don't want to refocus on non focusable elements, because
        // it may cause unnecessary scroll
        // also focus only on input input elements
        if($(activeElement).is(':focusable:input,:aui-focusable:input')) {
            // this quirk is required for FF, otherwise it will bug cursor
            setTimeout(function() {
                activeElement.focus();
            });
        }

        // TODO refactor this, so we won't need to call this each time we want to leave this state
        function cleanUp() {
            $contentEditable.remove();
        }

        return function(eventType, eventObject) {
            if(eventType == EVENT_WINDOW_PASTE) {
                if(utility.isImagePasteEvent(eventObject)) {
                    cleanUp();

                    eventObject.target = activeElement;
                    return new StateFileLoading(eventObject);
                }

                if(utility.isHtmlImagePasteEvent(eventObject)) {
                    cleanUp();

                    eventObject.target = activeElement;
                    return new StateImageLoading(eventObject);
                }

                if(utility.isTextPasteEvent(eventObject)) {
                    cleanUp();

                    var text1 = utility.getTextPasteContent(eventObject);
                    utility.insertToInput(text1, keyPasteEvent.target, keyPasteEvent.selectionStart, keyPasteEvent.selectionEnd);

                    // This is required for consistent behavior, IE requires preventDefault, while others don't
                    eventObject.preventDefault();

                    return new StateIdle();
                }
            }

            if(eventType == EVENT_TIMEOUT) {
                cleanUp();

                var $img = $contentEditable.find('>img');
                if($img.is(':only-child')) {
                    var imgSrc = $img.attr("src");
                    if (imgSrc.toLowerCase().indexOf("http") === 0) {
                        // we could use canvas and toDataURL here, but it is not allowed by browser:
                        // https://html.spec.whatwg.org/multipage/scripting.html#dom-canvas-todataurl
                        return StateIdle();
                    }
                    else {
                        var array = base64decode.decodeBase64DataUri(imgSrc);
                        var blob = new Blob([array], {type: "image/png"});

                        return new StateAttachImage(blob, keyPasteEvent);
                    }
                } else {
                    // special handling for IE10
                    if(polyfill.isRequired() && !$contentEditable.text()){
                        // if we are here, we know:
                        // - user pressed Ctrl+v while not in a text field
                        // - the clipboard does not contain text (if it did it would have been handled elsewhere)
                        // this is a good place to attempt to load the java applet.
                        // We are not certain the user is trying to paste an image,
                        // but if not they can just choose not to load the applet.
                        return new StateAppletLoading(keyPasteEvent);
                    }
                    else {
                        // there was no image paste, so we need to reinsert pasted text into text input
                        var text2 = utility.getTextContent($contentEditable[0]);
                        utility.insertToInput(text2, keyPasteEvent.target, keyPasteEvent.selectionStart, keyPasteEvent.selectionEnd);

                        return StateIdle();
                    }
                }
            }
        }
    });

    var StateAppletLoading = State("appletLoading", function(keyPasteEvent) {
        polyfill.getClipboardData().done(function(imgUri){
            var array = base64decode.decodeBase64DataUri(imgUri);
            var blob = new Blob([array], {type: "image/jpeg"});
            triggerEvent(EVENT_IMAGE_LOADED, blob);
        }).fail(function(message){
            utility.showErrorMsg("", message);
            triggerEvent(EVENT_IMAGE_LOAD_ERROR);
        });

        return function(eventType, blob){
            if(eventType == EVENT_IMAGE_LOADED){
                return new StateAttachImage(blob, keyPasteEvent);
            }
            if(eventType == EVENT_IMAGE_LOAD_ERROR) {
                return new StateIdle();
            }
        }
    });

    /**
     * Load File from image, this state is not weak, because we expect file loading to take some time
     * @param {Event} pasteEvent that contains text/html in clipboardData
     */
    var StateImageLoading = State("imageLoading", function(pasteEvent) {
        var imageSrc = utility.getHtmlImagePaste(pasteEvent);
        if(!imageSrc) {
            triggerEvent(EVENT_IMAGE_LOAD_ERROR);
        } else {
            utility.loadImage(imageSrc).then(function(image) {
                triggerEvent(EVENT_IMAGE_LOADED, image);
            }, triggerEvent.bind(null, EVENT_IMAGE_LOAD_ERROR));
        }

        return function(eventType, eventObject) {
            if(eventType == EVENT_IMAGE_LOADED) {
                var file = utility.convertImageToBlob(eventObject);

                if(file) {
                    return new StateAttachImage(file, pasteEvent);
                } else {
                    return new StateIdle();
                }
            }

            if(eventType == EVENT_TIMEOUT || eventType == EVENT_IMAGE_LOAD_ERROR) {
                return new StateIdle();
            }
        }
    });

    /**
     * Handle paste event, get file open attach screenshot dialog
     * @param {Event} pasteEvent
     */
    var StateFileLoading = WeakState("fileLoading", function(pasteEvent) {
        html5.getFileFromEvent(pasteEvent).done(function (file) {
            triggerEvent(EVENT_FILE_LOADED, file);
        }).fail(function () {
            triggerEvent(EVENT_FILE_LOAD_ERROR);
        });

        return function(eventType, eventObject) {
            if (eventType == EVENT_FILE_LOADED) {
                return new StateAttachImage(eventObject, pasteEvent);
            } else if (eventType == EVENT_FILE_LOAD_ERROR || eventType == EVENT_TIMEOUT) {
                return new StateIdle();
            }
        }
    }, 1000);

    var StateAttachImage = State("attachImage", function(file, pasteEvent) {
        var pasteTarget =  pasteEvent.target;
        var screenshotName = utility.generateFileName() + (polyfill.isRequired() ? ".jpg" : ".png");

        var pastedImage = utility.convertBlobToImage(file, screenshotName);

        Events.trigger(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, {
            files: [pastedImage],
            // We want the attachment executor to know if a wiki textfield is in focus
            // so that the executor can then decide whether it wants to perform its action.
            isWikiTextfieldFocused: utility.isWikiTextfield($(pasteTarget)),
            wikiTextfield: pasteTarget,
            // Tell the dropzone whether the files came from a paste or from an actual drag and drop
            isPaste: true,
            successCallback: function() {
                triggerEvent(EVENT_DIALOG_LOADED)
            }
        });

        return function(eventType, eventObject) {
            return new StateIdle();
        };
    });

    /**
     * Current state, which will receive next event, initilized with {StateIdle}
     * @type {State}
     */
    var currentState = new StateIdle();

    /**
     * Trigger current state with given parameters
     * @param {Number} eventType
     * @param {Object} eventObject
     */
    function triggerEvent(eventType, eventObject) {
        // some states may call this function during initialization, therefore there is a need to queue such events
        // in order to avoid nested executions
        if(triggerEvent.eventQueue) {
            triggerEvent.eventQueue.push({ type: eventType, object: eventObject });
            return;
        }

        triggerEvent.eventQueue = [{ type: eventType, object: eventObject }];

        while(triggerEvent.eventQueue.length > 0) {
            var event = triggerEvent.eventQueue.splice(0, 1)[0];
            var newState = currentState(event.type, event.object);
            if(newState) {
                currentState = newState;
            }
        }

        delete triggerEvent.eventQueue;
    }

    /**
     * Required for tests
     */
    exports._getStateMap = function() {
        return {
            events: {
                EVENT_WINDOW_KEYDOWN: EVENT_WINDOW_KEYDOWN,
                EVENT_WINDOW_PASTE: EVENT_WINDOW_PASTE,

                EVENT_FILE_LOADED: EVENT_FILE_LOADED,
                EVENT_FILE_LOAD_ERROR: EVENT_FILE_LOAD_ERROR,

                EVENT_IMAGE_LOADED: EVENT_IMAGE_LOADED,
                EVENT_IMAGE_LOAD_ERROR: EVENT_IMAGE_LOAD_ERROR,

                EVENT_DIALOG_LOADED: EVENT_DIALOG_LOADED,
                EVENT_DIALOG_CLOSED: EVENT_DIALOG_CLOSED,
                EVENT_DIALOG_CANCELED: EVENT_DIALOG_CANCELED,

                EVENT_TIMEOUT: EVENT_TIMEOUT
            },
            states: {
                StateIdle: StateIdle,
                StateCatchClipboard: StateCatchClipboard,
                StateAppletLoading: StateAppletLoading,
                StateImageLoading: StateImageLoading,
                StateFileLoading: StateFileLoading,
                StateAttachImage: StateAttachImage
            }
        }
    };

    exports.initIssuePaste = function () {
        // handle CTRL+V on wiki textfields
        $(window).on('keydown', function (event) {
            triggerEvent(EVENT_WINDOW_KEYDOWN, event);
        });
        $(window).on("paste", function (event) {
            triggerEvent(EVENT_WINDOW_PASTE, utility.normalizePasteEvent(event));
        });
        Events.bind("Dialog.hide", function (event, $popup, reason) {
            if (reason) {
                triggerEvent(EVENT_DIALOG_CANCELED, $popup);
            } else {
                triggerEvent(EVENT_DIALOG_CLOSED, $popup);
            }
        });
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/trace.js' */
define("dndattachment/ctrlv/trace", [], function () {
  "use strict";
  // tests often redefine JIRA.trace this avoid grabbing a stale version
  return function amdJiraTrace() {
    return JIRA.trace.apply(undefined, arguments);
  };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/tracking.js' */
define("dndattachment/ctrlv/tracking", [
  "exports"
], function (
  exports
) {
  "use strict";
  exports.trigger = function (analyticKey, payload) {
    AJS.trigger("analytics", {name: analyticKey, data: payload || {}});
  };
});

;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/executor.js' */
define("dndattachment/ctrlv/executor", [
    "jquery",
    "jira/util/events",
    "dndattachment/ctrlv/html5",
    "dndattachment/upload/handler",
    "exports"
], function (
    $,
    Events,
    html5,
    DnDUploadHandler,
    exports
) {

    exports.register = function () {
        /*
         * This executor spawns the attach screenshot dialog and is only valid if user pastes an attachment via ctrlv.
         */
        var ctrlvExecutor = {
            name: 'JIRA Ctrl+V attachment executor',
            // This weight is higher than the default executor (weight 0) and lower than the ServiceDesk executor (weight 50)
            weight: 5,
            isValid: function (event, args) {
                return !!args.isPaste;
            },
            processFiles: function (files, attachmentDropZone) {
                var deferred = $.Deferred();
                html5.show().done(function (dialog) {
                    var $el = $("#attach-screenshot-placeholder-message");
                    var evt = $.Event("paste");
                    evt.clipboardData = {files: files};
                    $el.focus();
                    setTimeout(function() {
                        $el.trigger(evt)
                    });

                    Events.bind("Dialog.hide", function (event, $popup, reason) {
                        if (reason) {
                            deferred.reject();
                        }
                        else {
                            // If there is no reason, then we know the file was uploaded successfully.
                            deferred.resolve([$popup.find('#attachscreenshotname').val() + '.png']);
                        }
                    });
                });

                return deferred;
            }
        };

        DnDUploadHandler.registerExecutor(ctrlvExecutor);
    }

});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/initialize.js' */
define("dndattachment/ctrlv/initialize", [
  "jquery",
  "underscore",
  "dndattachment/ctrlv/polyfill",
  "dndattachment/ctrlv/utility",
  "dndattachment/ctrlv/html5",
  "dndattachment/ctrlv/issue-paste",
  "dndattachment/ctrlv/tracking",
  "dndattachment/ctrlv/executor",
  "jira/dialog/dialog-register",
  "jira/dialog/form-dialog",
  "exports"
], function (
  $,
  _,
  polyfill,
  utility,
  html5,
  issue_paste,
  tracker,
  executor,
  DialogRegister,
  FormDialog,
  exports
) {
  "use strict";

  // Initialization of HTML5 paste handler
  exports.init = function() {
    var AttachImageDialog = FormDialog.extend({
      options: {}
    });

    /**
     * SW-306 js errors are present when this reference isn't available in global scope
     * @deprecated
     */
    JIRA.ScreenshotDialog = AttachImageDialog;

    issue_paste.initIssuePaste();

    // Upload and Cancel Button Handlers
    $(document).ready(function () {
      "use strict";

      var delayShowUntil = $.Deferred();

      if (!utility.browserIsSupported() || !polyfill.isRequired()) {
        delayShowUntil.resolve();
      }

      // Shows the Attach Screenshot in a Popup
      DialogRegister.attachScreenshotDialog = new AttachImageDialog({
        id: "attach-screenshot-dialog",
        trigger: "a.issueaction-attach-screenshot-html5",
        isIssueDialog: true,
        onContentRefresh: function attachScreenshotContentRefresh() {

          this.$form.bind("before-submit", function attachScreenshotContentRefreshBeforeSubmit(e) {
            var errors = html5.validateFormData(html5.screenshotFileUpload, $.trim(html5.dialogView.getFileNameInput().val()));
            if (html5.dialogView.getFileSize() == 0) {
              e.preventDefault();
              return false;
            } else if (!_.isEmpty(errors)) {
              html5.dialogView.displayErrors(errors);
              e.preventDefault();
              return false;
            }
            return true;
          });

        },
        delayShowUntil: function () {
          if (polyfill.isRequired()) {
            polyfill.install(document)
              .done(function () {
                AttachImageDialog.prototype._submitForm = polyfill.proxyAjaxRequest(AttachImageDialog.prototype._submitForm, function () {
                  return $("#attach-screenshot-form").data("submit-secure-token");
                });
              })
              .always(function () {
                delayShowUntil.resolve();
              });
          }
          return delayShowUntil;
        }
      });

      $(document).bind("dialogContentReady", function (event, dialog) {
        // Ensure that the dialog is *ours*, and that it's showing the Attach screen shot form. It's possible that
        // it's populated with an error from the server, in which case we wouldn't want to "init" it.
        if (dialog === DialogRegister.attachScreenshotDialog && document.getElementById("attach-screenshot-form") !== null) {
          tracker.trigger("attach.screenshot.html5.contentReady");
          html5.initScreenshotPasteHandler();
        }
      });

      $(document).ready(function () {
        // Atlassian Analytics - Capture click events
        $(document).on("click", "#attach-screenshot-html5", function () {
          tracker.trigger("attach.screenshot.html5.display");
        });
      });
    });

    executor.register();
  };
});

require([
  "dndattachment/ctrlv/initialize",
  "jquery"
], function(
  jhtml5,
  $
) {
  "use strict";
  $(function() { jhtml5.init(); });
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'applet/deployJava.js' */
/*
 * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * deployJava.js
 *
 * This file is part of the Deployment Toolkit.  It provides functions for web
 * pages to detect the presence of a JRE, install the latest JRE, and easily run
 * applets or Web Start programs.  More Information on usage of the
 * Deployment Toolkit can be found in the Deployment Guide at:
 * http://docs.oracle.com/javase/6/docs/technotes/guides/jweb/index.html
 *
 * The "live" copy of this file may be found at :
 * http://java.com/js/deployJava.js.
 * For web pages provisioned using https, you may want to access the copy at:
 * https://java.com/js/deployJava.js.
 *
 * You are encouraged to link directly to the live copies.
 * The above files are stripped of comments and whitespace for performance,
 * You can access this file w/o the whitespace and comments removed at:
 * http://java.com/js/deployJava.txt.
 *
 */

var deployJava = function() {
    /** HTML attribute filter implementation */
    var hattrs = {
        core: [ 'id', 'class', 'title', 'style' ],
        i18n: [ 'lang', 'dir' ],
        events: [ 'onclick', 'ondblclick', 'onmousedown', 'onmouseup',
            'onmouseover', 'onmousemove', 'onmouseout', 'onkeypress',
            'onkeydown', 'onkeyup' ],
        applet: [ 'codebase', 'code', 'name', 'archive', 'object',
            'width', 'height', 'alt', 'align', 'hspace', 'vspace' ],
        object: [ 'classid', 'codebase', 'codetype', 'data', 'type',
            'archive', 'declare', 'standby', 'height', 'width', 'usemap',
            'name', 'tabindex', 'align', 'border', 'hspace', 'vspace' ]
    };

    var object_valid_attrs = hattrs.object.concat(hattrs.core, hattrs.i18n,
        hattrs.events);
    var applet_valid_attrs = hattrs.applet.concat(hattrs.core);

    // generic log function, use console.log unless it isn't available
    // then revert to alert()
    function log(message) {
        if ( ! rv.debug ) {return};

        if (console.log) {
            console.log(message);
        } else {
            alert(message);
        }
    }

    //checks where given version string matches query
    //
    //NB: assume format is correct. Can add format check later if needed
    // from dtjava.js
    function versionCheckEx(query, version) {
        if (query == null || query.length == 0) return true;

        var c = query.charAt(query.length - 1);

        //if it is not explicit pattern but does not have update version then need to append *
        if (c != '+' && c != '*' && (query.indexOf('_') != -1 && c != '_')) {
            query = query + "*";
            c = '*';
        }

        query = query.substring(0, query.length - 1);
        //if query ends with ".", "_" then we want to strip it to allow match of "1.6.*" to shorter form such as "1.6"
        //TODO: add support for match of "1.7.0*" to "1.7"?
        if (query.length > 0) {
            var z = query.charAt(query.length - 1);
            if (z == '.' || z == '_') {
                query = query.substring(0, query.length - 1);
            }
        }
        if (c == '*') {
            //it is match if version starts from it
            return (version.indexOf(query) == 0);
        } else if (c == '+') {
            //match if query string is lexicographically smaller
            return query <= version;
        }
        return false;
    }

    function getWebStartLaunchIconURL() {
        var imageUrl = '//java.com/js/webstart.png';
        try {
            // for http/https; use protocol less url; use http for all other protocol
            return document.location.protocol.indexOf('http') != -1 ?
                imageUrl : 'http:' + imageUrl;
        } catch (err) {
            return 'http:' + imageUrl;
        }
    }

    // GetJava page
    function constructGetJavaURL(query) {

        var getJavaURL = 'http://java.com/dt-redirect';

        if (query == null || query.length == 0) return getJavaURL;
        if(query.charAt(0) == '&')
        {
            query = query.substring(1, query.length);
        }
        return getJavaURL + '?'+  query;
    }

    function arHas(ar, attr) {
        var len = ar.length;
        for (var i = 0; i < len; i++) {
            if (ar[i] === attr) return true;
        }
        return false;
    }

    function isValidAppletAttr(attr) {
        return arHas(applet_valid_attrs, attr.toLowerCase());
    }

    function isValidObjectAttr(attr) {
        return arHas(object_valid_attrs, attr.toLowerCase());
    }

    /**
     * returns true if we can enable DT plugin auto-install without chance of
     * deadlock on cert mismatch dialog
     *
     * requestedJREVersion param is optional - if null, it will be
     * treated as installing any JRE version
     *
     * DT plugin for 6uX only knows about JRE installer signed by SUN cert.
     * If it encounter Oracle signed JRE installer, it will have chance of
     * deadlock when running with IE.  This function is to guard against this.
     */
    function enableWithoutCertMisMatchWorkaround(requestedJREVersion) {

        // Non-IE browser are okay
        if ('MSIE' != deployJava.browserName) return true;

        // if DT plugin is 10.0.0 or above, return true
        // This is because they are aware of both SUN and Oracle signature and
        // will not show cert mismatch dialog that might cause deadlock
        if (deployJava.compareVersionToPattern(deployJava.getPlugin().version,
            ["10", "0", "0"], false, true)) {
            return true;
        }

        // If we got there, DT plugin is 6uX

        if (requestedJREVersion  == null) {
            // if requestedJREVersion is not defined - it means ANY.
            // can not guarantee it is safe to install ANY version because 6uX
            // DT does not know about Oracle certificates and may deadlock
            return false;
        }

        // 6u32 or earlier JRE installer used Sun certificate
        // 6u33+ uses Oracle's certificate
        // DT in JRE6 does not know about Oracle certificate => can only
        // install 6u32 or earlier without risk of deadlock
        return !versionCheckEx("1.6.0_33+", requestedJREVersion);
    }

    /* HTML attribute filters */

    var rv = {

        debug: null,

        /* version of deployJava.js */
        version: "20120801",

        firefoxJavaVersion: null,

        myInterval: null,
        preInstallJREList: null,
        returnPage: null,
        brand: null,
        locale: null,
        installType: null,

        EAInstallEnabled: false,
        EarlyAccessURL: null,


        // mime-type of the DeployToolkit plugin object
        oldMimeType: 'application/npruntime-scriptable-plugin;DeploymentToolkit',
        mimeType: 'application/java-deployment-toolkit',

        /* location of the Java Web Start launch button graphic is right next to
         * deployJava.js at:
         *    http://java.com/js/webstart.png
         *
         * Use protocol less url here for http/https support
         */
        launchButtonPNG: getWebStartLaunchIconURL(),

        browserName: null,
        browserName2: null,

        /**
         * Returns an array of currently-installed JRE version strings.
         * Version strings are of the form #.#[.#[_#]], with the function returning
         * as much version information as it can determine, from just family
         * versions ("1.4.2", "1.5") through the full version ("1.5.0_06").
         *
         * Detection is done on a best-effort basis.  Under some circumstances
         * only the highest installed JRE version will be detected, and
         * JREs older than 1.4.2 will not always be detected.
         */
        getJREs: function() {
            var list = new Array();
            if (this.isPluginInstalled()) {
                var plugin =  this.getPlugin();
                var VMs = plugin.jvms;
                for (var i = 0; i < VMs.getLength(); i++) {
                    list[i] = VMs.get(i).version;
                }
            } else {
                var browser = this.getBrowser();

                if (browser == 'MSIE') {
                    if (this.testUsingActiveX('1.7.0')) {
                        list[0] = '1.7.0';
                    } else if (this.testUsingActiveX('1.6.0')) {
                        list[0] = '1.6.0';
                    } else if (this.testUsingActiveX('1.5.0')) {
                        list[0] = '1.5.0';
                    } else if (this.testUsingActiveX('1.4.2')) {
                        list[0] = '1.4.2';
                    } else if (this.testForMSVM()) {
                        list[0] = '1.1';
                    }
                } else if (browser == 'Netscape Family') {
                    this.getJPIVersionUsingMimeType();
                    if (this.firefoxJavaVersion != null) {
                        list[0] = this.firefoxJavaVersion;
                    } else if (this.testUsingMimeTypes('1.7')) {
                        list[0] = '1.7.0';
                    } else if (this.testUsingMimeTypes('1.6')) {
                        list[0] = '1.6.0';
                    } else if (this.testUsingMimeTypes('1.5')) {
                        list[0] = '1.5.0';
                    } else if (this.testUsingMimeTypes('1.4.2')) {
                        list[0] = '1.4.2';
                    } else if (this.browserName2 == 'Safari') {
                        if (this.testUsingPluginsArray('1.7.0')) {
                            list[0] = '1.7.0';
                        } else if (this.testUsingPluginsArray('1.6')) {
                            list[0] = '1.6.0';
                        } else if (this.testUsingPluginsArray('1.5')) {
                            list[0] = '1.5.0';
                        } else if (this.testUsingPluginsArray('1.4.2')) {
                            list[0] = '1.4.2';
                        }
                    }
                }
            }

            if (this.debug) {
                for (var i = 0; i < list.length; ++i) {
                    log('[getJREs()] We claim to have detected Java SE ' + list[i]);
                }
            }

            return list;
        },

        /**
         * Triggers a JRE installation.  The exact effect of triggering an
         * installation varies based on platform, browser, and if the
         * Deployment Toolkit plugin is installed.
         *
         * The requestVersion string is of the form #[.#[.#[_#]]][+|*],
         * which includes strings such as "1.4", "1.5.0*", and "1.6.0_02+".
         * A star (*) means "any version starting within this family" and
         * a plus (+) means "any version greater or equal to this".
         * "1.5.0*" * matches 1.5.0_06 but not 1.6.0_01, whereas
         * "1.5.0+" matches both.
         *
         * installCallback is an optional argument which holds a reference
         * to a javascript callback function for reporting install status.
         *
         * If the Deployment Toolkit plugin is not present, this will just call
         * this.installLatestJRE().
         */
        installJRE: function(requestVersion, installCallback) {
            var ret = false;
            if (this.isPluginInstalled() &&
                this.isAutoInstallEnabled(requestVersion)) {
                var installSucceeded = false;
                if (this.isCallbackSupported()) {
                    installSucceeded =
                        this.getPlugin().installJRE(requestVersion, installCallback);
                } else {
                    installSucceeded = this.getPlugin().installJRE(requestVersion);
                }

                if (installSucceeded) {
                    this.refresh();
                    if (this.returnPage != null) {
                        document.location = this.returnPage;
                    }
                }
                return installSucceeded;
            } else {
                return this.installLatestJRE();
            }
        },

        /**
         * returns true if jre auto install for the requestedJREVersion is enabled
         * for the local system; false otherwise
         *
         * requestedJREVersion param is optional - if not specified, it will be
         * treated as installing any JRE version
         *
         * DT plugin for 6uX only knows about JRE installer signed by SUN cert.
         * If it encounter Oracle signed JRE installer, it will have chance of
         * deadlock when running with IE.  This function is to guard against this.
         */
        isAutoInstallEnabled: function(requestedJREVersion) {
            // if no DT plugin, return false
            if (!this.isPluginInstalled()) return false;

            if (typeof requestedJREVersion  == 'undefined') {
                requestedJREVersion = null;
            }

            return enableWithoutCertMisMatchWorkaround(requestedJREVersion);

        },

        /**
         * returns true if jre install callback is supported
         * callback support is added since dt plugin version 10.2.0 or above
         */
        isCallbackSupported: function() {
            return this.isPluginInstalled() &&
                this.compareVersionToPattern(this.getPlugin().version,
                    ["10", "2", "0"], false, true);
        },

        /**
         * Triggers a JRE installation.  The exact effect of triggering an
         * installation varies based on platform, browser, and if the
         * Deployment Toolkit plugin is installed.
         *
         * In the simplest case, the browser window will be redirected to the
         * java.com JRE installation page, and (if possible) a redirect back to
         * the current URL upon successful installation.  The return redirect is
         * not always possible, as the JRE installation may require the browser to
         * be restarted.
         *
         * installCallback is an optional argument which holds a reference
         * to a javascript callback function for reporting install status.
         *
         * In the best case (when the Deployment Toolkit plugin is present), this
         * function will immediately cause a progress dialog to be displayed
         * as the JRE is downloaded and installed.
         */
        installLatestJRE: function(installCallback) {
            if (this.isPluginInstalled() && this.isAutoInstallEnabled()) {
                var installSucceeded = false;
                if (this.isCallbackSupported()) {
                    installSucceeded = this.getPlugin().installLatestJRE(installCallback);
                } else {
                    installSucceeded = this.getPlugin().installLatestJRE();
                }
                if (installSucceeded) {
                    this.refresh();
                    if (this.returnPage != null) {
                        document.location = this.returnPage;
                    }
                }
                return installSucceeded;
            } else {
                var browser = this.getBrowser();
                var platform = navigator.platform.toLowerCase();
                if ((this.EAInstallEnabled == 'true') &&
                    (platform.indexOf('win') != -1) &&
                    (this.EarlyAccessURL != null)) {

                    this.preInstallJREList = this.getJREs();
                    if (this.returnPage != null) {
                        this.myInterval =
                            setInterval("deployJava.poll()", 3000);
                    }

                    location.href = this.EarlyAccessURL;

                    // we have to return false although there may be an install
                    // in progress now, when complete it may go to return page
                    return false;
                } else {
                    if (browser == 'MSIE') {
                        return this.IEInstall();
                    } else if ((browser == 'Netscape Family') &&
                        (platform.indexOf('win32') != -1)) {
                        return this.FFInstall();
                    } else {
                        location.href = constructGetJavaURL(
                            ((this.returnPage != null) ?
                                ('&returnPage=' + this.returnPage) : '') +
                                ((this.locale != null) ?
                                    ('&locale=' + this.locale) : '') +
                                ((this.brand != null) ?
                                    ('&brand=' + this.brand) : ''));
                    }
                    // we have to return false although there may be an install
                    // in progress now, when complete it may go to return page
                    return false;
                }
            }
        },


        /**
         * Ensures that an appropriate JRE is installed and then runs an applet.
         * minimumVersion is of the form #[.#[.#[_#]]], and is the minimum
         * JRE version necessary to run this applet.  minimumVersion is optional,
         * defaulting to the value "1.1" (which matches any JRE).
         * If an equal or greater JRE is detected, runApplet() will call
         * writeAppletTag(attributes, parameters) to output the applet tag,
         * otherwise it will call installJRE(minimumVersion + '+').
         *
         * After installJRE() is called, the script will attempt to detect that the
         * JRE installation has completed and begin running the applet, but there
         * are circumstances (such as when the JRE installation requires a browser
         * restart) when this cannot be fulfilled.
         *
         * As with writeAppletTag(), this function should only be called prior to
         * the web page being completely rendered.  Note that version wildcards
         * (star (*) and plus (+)) are not supported, and including them in the
         * minimumVersion will result in an error message.
         */
        runApplet: function(attributes, parameters, minimumVersion) {
            if (minimumVersion == 'undefined' || minimumVersion == null) {
                minimumVersion = '1.1';
            }

            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";

            var matchData = minimumVersion.match(regex);

            if (this.returnPage == null) {
                // if there is an install, come back here and run the applet
                this.returnPage = document.location;
            }

            if (matchData != null) {
                var browser = this.getBrowser();
                if (browser != '?') {
                    if (this.versionCheck(minimumVersion + '+')) {
                        this.writeAppletTag(attributes, parameters);
                    } else if (this.installJRE(minimumVersion + '+')) {
                        // after successful install we need to refresh page to pick
                        // pick up new plugin
                        this.refresh();
                        location.href = document.location;
                        this.writeAppletTag(attributes, parameters);
                    }
                } else {
                    // for unknown or Safari - just try to show applet
                    this.writeAppletTag(attributes, parameters);
                }
            } else {
                log('[runApplet()] Invalid minimumVersion argument to runApplet():' +
                    minimumVersion);
            }
        },


        /**
         * Outputs an applet tag with the specified attributes and parameters, where
         * both attributes and parameters are associative arrays.  Each key/value
         * pair in attributes becomes an attribute of the applet tag itself, while
         * key/value pairs in parameters become <PARAM> tags.  No version checking
         * or other special behaviors are performed; the tag is simply written to
         * the page using document.writeln().
         *
         * As document.writeln() is generally only safe to use while the page is
         * being rendered, you should never call this function after the page
         * has been completed.
         */
        writeAppletTag: function(attributes, parameters) {
            var startApplet = '<' + 'applet ';
            var params = '';
            var endApplet = '<' + '/' + 'applet' + '>';
            var addCodeAttribute = true;

            if (null == parameters || typeof parameters != 'object') {
                parameters = new Object();
            }

            for (var attribute in attributes) {
                if (! isValidAppletAttr(attribute)) {
                    parameters[attribute] = attributes[attribute];
                } else {
                    startApplet += (' ' +attribute+ '="' +attributes[attribute] + '"');
                    if (attribute == 'code') {
                        addCodeAttribute = false;
                    }
                }
            }

            var codebaseParam = false;
            for (var parameter in parameters) {
                if (parameter == 'codebase_lookup') {
                    codebaseParam = true;
                }
                // Originally, parameter 'object' was used for serialized
                // applets, later, to avoid confusion with object tag in IE
                // the 'java_object' was added.  Plugin supports both.
                if (parameter == 'object' || parameter == 'java_object' ||
                    parameter == 'java_code' ) {
                    addCodeAttribute = false;
                }
                params += '<param name="' + parameter + '" value="' +
                    parameters[parameter] + '"/>';
            }
            if (!codebaseParam) {
                params += '<param name="codebase_lookup" value="false"/>';
            }

            if (addCodeAttribute) {
                startApplet += (' code="dummy"');
            }
            startApplet += '>';

            document.write(startApplet + '\n' + params + '\n' + endApplet);
        },


        /**
         * Returns true if there is a matching JRE version currently installed
         * (among those detected by getJREs()).  The versionPattern string is
         * of the form #[.#[.#[_#]]][+|*], which includes strings such as "1.4",
         * "1.5.0*", and "1.6.0_02+".
         * A star (*) means "any version within this family" and a plus (+) means
         * "any version greater or equal to the specified version".  "1.5.0*"
         * matches 1.5.0_06 but not 1.6.0_01, whereas "1.5.0+" matches both.
         *
         * If the versionPattern does not include all four version components
         * but does not end with a star or plus, it will be treated as if it
         * ended with a star.  "1.5" is exactly equivalent to "1.5*", and will
         * match any version number beginning with "1.5".
         *
         * If getJREs() is unable to detect the precise version number, a match
         * could be ambiguous.  For example if getJREs() detects "1.5", there is
         * no way to know whether the JRE matches "1.5.0_06+".  versionCheck()
         * compares only as much of the version information as could be detected,
         * so versionCheck("1.5.0_06+") would return true in in this case.
         *
         * Invalid versionPattern will result in a JavaScript error alert.
         * versionPatterns which are valid but do not match any existing JRE
         * release (e.g. "32.65+") will always return false.
         */
        versionCheck: function(versionPattern)
        {
            var index = 0;
            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?(\\*|\\+)?$";

            var matchData = versionPattern.match(regex);

            if (matchData != null) {
                // default is exact version match
                // examples:
                //    local machine has 1.7.0_04 only installed
                //    exact match request is "1.7.0_05":  return false
                //    family match request is "1.7.0*":   return true
                //    minimum match request is "1.6+":    return true
                var familyMatch = false;
                var minMatch = false;

                var patternArray = new Array();

                for (var i = 1; i < matchData.length; ++i) {
                    // browser dependency here.
                    // Fx sets 'undefined', IE sets '' string for unmatched groups
                    if ((typeof matchData[i] == 'string') && (matchData[i] != '')) {
                        patternArray[index] = matchData[i];
                        index++;
                    }
                }

                if (patternArray[patternArray.length-1] == '+') {
                    // + specified in request - doing a minimum match
                    minMatch = true;
                    familyMatch = false;
                    patternArray.length--;
                } else if (patternArray[patternArray.length-1] == '*') {
                    // * specified in request - doing a family match
                    minMatch = false;
                    familyMatch = true;
                    patternArray.length--;
                } else if (patternArray.length < 4) {
                    // versionPattern does not include all four version components
                    // and does not end with a star or plus, it will be treated as
                    // if it ended with a star. (family match)
                    minMatch = false;
                    familyMatch = true;
                }

                var list = this.getJREs();
                for (var i = 0; i < list.length; ++i) {
                    if (this.compareVersionToPattern(list[i], patternArray,
                        familyMatch, minMatch)) {
                        return true;
                    }
                }

                return false;
            } else {
                var msg = 'Invalid versionPattern passed to versionCheck: ' +
                    versionPattern;
                log('[versionCheck()] ' + msg);
                alert(msg);
                return false;
            }
        },


        /**
         * Returns true if an installation of Java Web Start of the specified
         * minimumVersion can be detected.  minimumVersion is optional, and
         * if not specified, '1.4.2' will be used.
         * (Versions earlier than 1.4.2 may not be detected.)
         */
        isWebStartInstalled: function(minimumVersion) {

            var browser = this.getBrowser();
            if (browser == '?') {
                // we really don't know - better to try to use it than reinstall
                return true;
            }

            if (minimumVersion == 'undefined' || minimumVersion == null) {
                minimumVersion = '1.4.2';
            }

            var retval = false;
            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";
            var matchData = minimumVersion.match(regex);

            if (matchData != null) {
                retval = this.versionCheck(minimumVersion + '+');
            } else {
                log('[isWebStartInstaller()] Invalid minimumVersion argument to isWebStartInstalled(): ' + minimumVersion);
                retval = this.versionCheck('1.4.2+');
            }
            return retval;
        },

        // obtain JPI version using navigator.mimeTypes array
        // if found, set the version to this.firefoxJavaVersion
        getJPIVersionUsingMimeType: function() {
            // Walk through the full list of mime types.
            for (var i = 0; i < navigator.mimeTypes.length; ++i) {
                var s = navigator.mimeTypes[i].type;
                // The jpi-version is the plug-in version.  This is the best
                // version to use.
                var m = s.match(/^application\/x-java-applet;jpi-version=(.*)$/);
                if (m != null) {
                    this.firefoxJavaVersion = m[1];
                    // Opera puts the latest sun JRE last not first
                    if ('Opera' != this.browserName2) {
                        break;
                    }
                }
            }
        },

        // launch the specified JNLP application using the passed in jnlp file
        // the jnlp file does not need to have a codebase
        // this requires JRE 7 or above to work
        // if machine has no JRE 7 or above, we will try to auto-install and then launch
        // (function will return false if JRE auto-install failed)
        launchWebStartApplication: function(jnlp) {
            var uaString = navigator.userAgent.toLowerCase();

            this.getJPIVersionUsingMimeType();

            // make sure we are JRE 7 or above
            if (this.isWebStartInstalled('1.7.0') == false) {

                // perform latest JRE auto-install
                if ((this.installJRE('1.7.0+') == false) ||
                    ((this.isWebStartInstalled('1.7.0') == false))) {
                    return false;
                }
            }

            var jnlpDocbase = null;

            // use document.documentURI for docbase
            if (document.documentURI) {
                jnlpDocbase = document.documentURI;
            }

            // fallback to document.URL if documentURI not available
            if (jnlpDocbase == null) {
                jnlpDocbase = document.URL;
            }

            var browser = this.getBrowser();

            var launchTag;

            if (browser == 'MSIE') {

                launchTag = '<' +
                    'object classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93" ' +
                    'width="0" height="0">' +
                    '<' + 'PARAM name="launchjnlp" value="' + jnlp + '"' + '>' +
                    '<' + 'PARAM name="docbase" value="' + jnlpDocbase + '"' + '>' +
                    '<' + '/' + 'object' + '>';
            } else if (browser == 'Netscape Family') {

                launchTag = '<' +
                    'embed type="application/x-java-applet;jpi-version=' +
                    this.firefoxJavaVersion + '" ' +
                    'width="0" height="0" ' +
                    'launchjnlp="' +  jnlp + '"' +
                    'docbase="' +  jnlpDocbase + '"' +
                    ' />';
            }

            if (document.body == 'undefined' || document.body == null) {
                document.write(launchTag);
                // go back to original page, otherwise current page becomes blank
                document.location = jnlpDocbase;
            } else {
                var divTag = document.createElement("div");
                divTag.id = "div1";
                divTag.style.position = "relative";
                divTag.style.left = "-10000px";
                divTag.style.margin = "0px auto";
                divTag.className ="dynamicDiv";
                divTag.innerHTML = launchTag;
                document.body.appendChild(divTag);
            }
        },

        createWebStartLaunchButtonEx: function(jnlp, minimumVersion) {

            if (this.returnPage == null) {
                // if there is an install, come back and run the jnlp file
                this.returnPage = jnlp;
            }

            var url = 'javascript:deployJava.launchWebStartApplication(\'' + jnlp +
                '\');';

            document.write('<' + 'a href="' + url +
                '" onMouseOver="window.status=\'\'; ' +
                'return true;"><' + 'img ' +
                'src="' + this.launchButtonPNG + '" ' +
                'border="0" /><' + '/' + 'a' + '>');
        },


        /**
         * Outputs a launch button for the specified JNLP URL.  When clicked, the
         * button will ensure that an appropriate JRE is installed and then launch
         * the JNLP application.  minimumVersion is of the form #[.#[.#[_#]]], and
         * is the minimum JRE version necessary to run this JNLP application.
         * minimumVersion is optional, and if it is not specified, '1.4.2'
         * will be used.
         * If an appropriate JRE or Web Start installation is detected,
         * the JNLP application will be launched, otherwise installLatestJRE()
         * will be called.
         *
         * After installLatestJRE() is called, the script will attempt to detect
         * that the JRE installation has completed and launch the JNLP application,
         * but there are circumstances (such as when the JRE installation
         * requires a browser restart) when this cannot be fulfilled.
         */
        createWebStartLaunchButton: function(jnlp, minimumVersion) {

            if (this.returnPage == null) {
                // if there is an install, come back and run the jnlp file
                this.returnPage = jnlp;
            }

            var url = 'javascript:' +
                'if (!deployJava.isWebStartInstalled(&quot;' +
                minimumVersion + '&quot;)) {' +
                'if (deployJava.installLatestJRE()) {' +
                'if (deployJava.launch(&quot;' + jnlp + '&quot;)) {}' +
                '}' +
                '} else {' +
                'if (deployJava.launch(&quot;' + jnlp + '&quot;)) {}' +
                '}';

            document.write('<' + 'a href="' + url +
                '" onMouseOver="window.status=\'\'; ' +
                'return true;"><' + 'img ' +
                'src="' + this.launchButtonPNG + '" ' +
                'border="0" /><' + '/' + 'a' + '>');
        },


        /**
         * Launch a JNLP application, (using the plugin if available)
         */
        launch: function(jnlp) {
            /*
             * Using the plugin to launch Java Web Start is disabled for the time being
             */
            document.location=jnlp;
            return true;
        },


        /*
         * returns true if the ActiveX or XPI plugin is installed
         */
        isPluginInstalled: function() {
            var plugin = this.getPlugin();
            if (plugin && plugin.jvms) {
                return true;
            } else {
                return false;
            }
        },

        /*
         * returns true if the plugin is installed and AutoUpdate is enabled
         */
        isAutoUpdateEnabled: function() {
            if (this.isPluginInstalled()) {
                return this.getPlugin().isAutoUpdateEnabled();
            }
            return false;
        },

        /*
         * sets AutoUpdate on if plugin is installed
         */
        setAutoUpdateEnabled: function() {
            if (this.isPluginInstalled()) {
                return this.getPlugin().setAutoUpdateEnabled();
            }
            return false;
        },

        /*
         * sets the preferred install type : null, online, kernel
         */
        setInstallerType: function(type) {
            this.installType = type;
            if (this.isPluginInstalled()) {
                return this.getPlugin().setInstallerType(type);
            }
            return false;
        },

        /*
         * sets additional package list - to be used by kernel installer
         */
        setAdditionalPackages: function(packageList) {
            if (this.isPluginInstalled()) {
                return this.getPlugin().setAdditionalPackages(
                    packageList);
            }
            return false;
        },

        /*
         * sets preference to install Early Access versions if available
         */
        setEarlyAccess: function(enabled) {
            this.EAInstallEnabled = enabled;
        },

        /*
         * Determines if the next generation plugin (Plugin II) is default
         */
        isPlugin2: function() {
            if (this.isPluginInstalled()) {
                if (this.versionCheck('1.6.0_10+')) {
                    try {
                        return this.getPlugin().isPlugin2();
                    } catch (err) {
                        // older plugin w/o isPlugin2() function -
                    }
                }
            }
            return false;
        },

        //support native DT plugin?
        allowPlugin: function() {
            this.getBrowser();

            // Safari and Opera browsers find the plugin but it
            // doesn't work, so until we can get it to work - don't use it.
            var ret = ('Safari' != this.browserName2 &&
                'Opera' != this.browserName2);

            return ret;
        },

        getPlugin: function() {
            this.refresh();

            var ret = null;
            if (this.allowPlugin()) {
                ret = document.getElementById('deployJavaPlugin');
            }
            return ret;
        },

        compareVersionToPattern: function(version, patternArray,
                                          familyMatch, minMatch) {
            if (version == undefined || patternArray == undefined) {
                return false;
            }
            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";
            var matchData = version.match(regex);

            if (matchData != null) {
                var index = 0;
                var result = new Array();

                for (var i = 1; i < matchData.length; ++i) {
                    if ((typeof matchData[i] == 'string') && (matchData[i] != ''))
                    {
                        result[index] = matchData[i];
                        index++;
                    }
                }

                var l = Math.min(result.length, patternArray.length);

                // result contains what is installed in local machine
                // patternArray is what is being requested by application
                if (minMatch) {
                    // minimum version match, return true if what we have (installed)
                    // is greater or equal to what is requested.  false otherwise.
                    for (var i = 0; i < l; ++i) {
                        if (result[i] < patternArray[i]) {
                            return false;
                        } else if (result[i] > patternArray[i]) {
                            return true;
                        }
                    }
                    return true;
                } else {
                    for (var i = 0; i < l; ++i) {
                        if (result[i] != patternArray[i]) return false;
                    }
                    if (familyMatch) {
                        // family match - return true as long as what we have
                        // (installed) matches up to the request pattern
                        return true;
                    } else {
                        // exact match
                        // result and patternArray needs to have exact same content
                        return (result.length == patternArray.length);
                    }
                }
            } else {
                return false;
            }
        },

        getBrowser: function() {

            if (this.browserName == null) {
                var browser = navigator.userAgent.toLowerCase();

                log('[getBrowser()] navigator.userAgent.toLowerCase() -> ' + browser);


                // order is important here.  Safari userAgent contains mozilla,
                // IE 11 userAgent contains mozilla and netscape,
                // and Chrome userAgent contains both mozilla and safari.
                if ((browser.indexOf('msie') != -1) && (browser.indexOf('opera') == -1)) {
                    this.browserName = 'MSIE';
                    this.browserName2 = 'MSIE';
                } else if (browser.indexOf('trident') != -1 || browser.indexOf('Trident') != -1) {
                    this.browserName = 'MSIE';
                    this.browserName2 = 'MSIE';
                } else if (browser.indexOf('iphone') != -1) {
                    // this included both iPhone and iPad
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'iPhone';
                } else if ((browser.indexOf('firefox') != -1) && (browser.indexOf('opera') == -1)) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Firefox';
                } else if (browser.indexOf('chrome') != -1) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Chrome';
                } else if (browser.indexOf('safari') != -1) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Safari';
                } else if ((browser.indexOf('mozilla') != -1) && (browser.indexOf('opera') == -1)) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Other';
                } else if (browser.indexOf('opera') != -1) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Opera';
                } else {
                    this.browserName = '?';
                    this.browserName2 = 'unknown';
                }

                log('[getBrowser()] Detected browser name:'+ this.browserName +
                    ', ' + this.browserName2);
            }
            return this.browserName;
        },


        testUsingActiveX: function(version) {
            var objectName = 'JavaWebStart.isInstalled.' + version + '.0';

            // we need the typeof check here for this to run on FF/Chrome
            // the check needs to be in place here - cannot even pass ActiveXObject
            // as arg to another function
            if (typeof ActiveXObject == 'undefined' || !ActiveXObject) {
                log('[testUsingActiveX()] Browser claims to be IE, but no ActiveXObject object?');
                return false;
            }

            try {
                return (new ActiveXObject(objectName) != null);
            } catch (exception) {
                return false;
            }
        },


        testForMSVM: function() {
            var clsid = '{08B0E5C0-4FCB-11CF-AAA5-00401C608500}';

            if (typeof oClientCaps != 'undefined') {
                var v = oClientCaps.getComponentVersion(clsid, "ComponentID");
                if ((v == '') || (v == '5,0,5000,0')) {
                    return false;
                } else {
                    return true;
                }
            } else {
                return false;
            }
        },


        testUsingMimeTypes: function(version) {
            if (!navigator.mimeTypes) {
                log ('[testUsingMimeTypes()] Browser claims to be Netscape family, but no mimeTypes[] array?');
                return false;
            }

            for (var i = 0; i < navigator.mimeTypes.length; ++i) {
                s = navigator.mimeTypes[i].type;
                var m = s.match(/^application\/x-java-applet\x3Bversion=(1\.8|1\.7|1\.6|1\.5|1\.4\.2)$/);
                if (m != null) {
                    if (this.compareVersions(m[1], version)) {
                        return true;
                    }
                }
            }
            return false;
        },

        testUsingPluginsArray: function(version) {
            if ((!navigator.plugins) || (!navigator.plugins.length)) {
                return false;
            }
            var platform = navigator.platform.toLowerCase();

            for (var i = 0; i < navigator.plugins.length; ++i) {
                s = navigator.plugins[i].description;
                if (s.search(/^Java Switchable Plug-in (Cocoa)/) != -1) {
                    // Safari on MAC
                    if (this.compareVersions("1.5.0", version)) {
                        return true;
                    }
                } else if (s.search(/^Java/) != -1) {
                    if (platform.indexOf('win') != -1) {
                        // still can't tell - opera, safari on windows
                        // return true for 1.5.0 and 1.6.0
                        if (this.compareVersions("1.5.0", version) ||
                            this.compareVersions("1.6.0", version)) {
                            return true;
                        }
                    }
                }
            }
            // if above dosn't work on Apple or Windows, just allow 1.5.0
            if (this.compareVersions("1.5.0", version)) {
                return true;
            }
            return false;



        },

        IEInstall: function() {

            location.href = constructGetJavaURL(
                ((this.returnPage != null) ?
                    ('&returnPage=' + this.returnPage) : '') +
                    ((this.locale != null) ?
                        ('&locale=' + this.locale) : '') +
                    ((this.brand != null) ? ('&brand=' + this.brand) : ''));

            // should not actually get here
            return false;
        },

        done: function (name, result) {
        },

        FFInstall: function() {

            location.href = constructGetJavaURL(
                ((this.returnPage != null) ?
                    ('&returnPage=' + this.returnPage) : '') +
                    ((this.locale != null) ?
                        ('&locale=' + this.locale) : '') +
                    ((this.brand != null) ? ('&brand=' + this.brand) : '') +
                    ((this.installType != null) ?
                        ('&type=' + this.installType) : ''));

            // should not actually get here
            return false;
        },

        // return true if 'installed' (considered as a JRE version string) is
        // greater than or equal to 'required' (again, a JRE version string).
        compareVersions: function(installed, required) {

            var a = installed.split('.');
            var b = required.split('.');

            for (var i = 0; i < a.length; ++i) {
                a[i] = Number(a[i]);
            }
            for (var i = 0; i < b.length; ++i) {
                b[i] = Number(b[i]);
            }
            if (a.length == 2) {
                a[2] = 0;
            }

            if (a[0] > b[0]) return true;
            if (a[0] < b[0]) return false;

            if (a[1] > b[1]) return true;
            if (a[1] < b[1]) return false;

            if (a[2] > b[2]) return true;
            if (a[2] < b[2]) return false;

            return true;
        },

        enableAlerts: function() {
            // reset this so we can show the browser detection
            this.browserName = null;
            this.debug = true;
        },

        poll: function() {

            this.refresh();
            var postInstallJREList = this.getJREs();

            if ((this.preInstallJREList.length == 0) &&
                (postInstallJREList.length != 0)) {
                clearInterval(this.myInterval);
                if (this.returnPage != null) {
                    location.href = this.returnPage;
                };
            }

            if ((this.preInstallJREList.length != 0) &&
                (postInstallJREList.length != 0) &&
                (this.preInstallJREList[0] != postInstallJREList[0])) {
                clearInterval(this.myInterval);
                if (this.returnPage != null) {
                    location.href = this.returnPage;
                }
            }

        },

        writePluginTag: function() {
            var browser = this.getBrowser();

            if (browser == 'MSIE') {
                // width=0 and height=0 don't seem to be enough to hide the object element on all IE versions
                // so position: absolute + top were added to ensure the expected behaviour
                document.write('<' +
                    'object classid="clsid:CAFEEFAC-DEC7-0000-0001-ABCDEFFEDCBA" ' +
                    'id="deployJavaPlugin" width="0" height="0" style="position: absolute; top: -5000px;">' +
                    '<' + '/' + 'object' + '>');
            } else if (browser == 'Netscape Family' && this.allowPlugin()) {
                this.writeEmbedTag();
            }
        },

        refresh: function() {
            navigator.plugins.refresh(false);

            var browser = this.getBrowser();
            if (browser == 'Netscape Family' && this.allowPlugin()) {
                var plugin = document.getElementById('deployJavaPlugin');
                // only do this again if no plugin
                if (plugin == null) {
                    this.writeEmbedTag();
                }
            }
        },

        writeEmbedTag: function() {
            var written = false;
            if (navigator.mimeTypes != null) {
                for (var i=0; i < navigator.mimeTypes.length; i++) {
                    if (navigator.mimeTypes[i].type == this.mimeType) {
                        if (navigator.mimeTypes[i].enabledPlugin) {
                            document.write('<' +
                                'embed id="deployJavaPlugin" type="' +
                                this.mimeType + '" hidden="true" />');
                            written = true;
                        }
                    }
                }
                // if we ddn't find new mimeType, look for old mimeType
                if (!written) for (var i=0; i < navigator.mimeTypes.length; i++) {
                    if (navigator.mimeTypes[i].type == this.oldMimeType) {
                        if (navigator.mimeTypes[i].enabledPlugin) {
                            document.write('<' +
                                'embed id="deployJavaPlugin" type="' +
                                this.oldMimeType + '" hidden="true" />');
                        }
                    }
                }
            }
        }
    }; // deployJava object

    rv.writePluginTag();
    if (rv.locale == null) {
        var loc = null;

        if (loc == null) try {
            loc = navigator.userLanguage;
        } catch (err) { }

        if (loc == null) try {
            loc = navigator.systemLanguage;
        } catch (err) { }

        if (loc == null) try {
            loc = navigator.language;
        } catch (err) { }

        if (loc != null) {
            loc.replace("-","_")
            rv.locale = loc;
        }
    }

    return rv;
}();;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-amd', location = 'js/jira-amd.js' */
/**
 * AMD wrapper for JIRA object
 */

define('dndattachment/JIRA',  function() {
    return JIRA;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-amd', location = 'js/aui-amd.js' */
// amd shim required for JIRA 6.1

define('dndattachment/aui', function() { return AJS; });;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:attachment-menu-link-init', location = 'js/menu/initAttachmentMenuLink.js' */
require([
        'jquery',
        'dndattachment/aui',
        'jira/util/events',
        'dndattachment/util/events/types'
    ], function ($,
                 AJS,
                 Events,
                 EventTypes) {

        var ISSUEACTION_ATTACH_FILES_CLASS = "issueaction-attach-file";

        var addDialogClassAndInvoke = function($el) {
            $el.addClass(ISSUEACTION_ATTACH_FILES_CLASS);
            $el.click();
        };

        var openFilePickerForPage = function() {
            var $tempFileInput = $("<input type=\"file\" multiple />");
            $tempFileInput.change(function (event) {
                Events.trigger(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, {
                    files: $tempFileInput[0].files
                });
            });
            $tempFileInput.click();
        };

        var isSubtaskLink = function($link) {
            return !! $link.data("issuekey");
        };

        // This should use skate once skate is a thing in jira-core
        var initialiseMenuAttachmentLink = function () {
            $(document).on('click', '.unified-attach-file', function (e) {
                AJS.trigger('analytics', { name : 'issue.dnd.attachment.opsbar.attachFiles.linkClick', data : {}});

                var $target = $(e.target);

                // If we have the old issueaction class, then do nothing
                if($target.hasClass(ISSUEACTION_ATTACH_FILES_CLASS)) {
                    return;
                }

                e.preventDefault();

                // Check if we have a Drop Zone present
                var isDropZonePresent = $(".issue-drop-zone").length;
                if(isDropZonePresent && !isSubtaskLink($target)) {
                    // If we have a drop zone available then we  create a dummy file input and open it
                    openFilePickerForPage();
                } else {
                    // If we do not, then add the class to make it behave the old way then click the target again to open the dialog
                    // This is mainly for JIRA Agile, who won't have a drop zone available to listen accept the files.
                    addDialogClassAndInvoke($target);
                }
            });
        };

        var onReady = function () {
            initialiseMenuAttachmentLink();
        };

        if ($.isReady) {
            onReady();
        } else {
            AJS.$(onReady);
        }
    }
);;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-public', location = 'js/applinks.public.js' */
/**
 * Support code to provide appropriate behavior for HTML elements created by
 * ApplicationLinkUIService; also, public functions that can be used from JS code
 * in other plugins to create the same kinds of HTML elements, in case it's not
 * convenient to do so on the back end.
 */
var ApplinksUtils = ApplinksUtils || (function($) {

    var pendingRequests = {},
        pendingConfirmations = {};
    
    // Provide a well-defined name for the authentication window/tab we create with
    // window.open() - may be useful in debugging, and is used by integration tests.
    // Note, IE8 does not allow this name to contain hyphens or periods.
    var authWindowName = "com_atlassian_applinks_authentication";

    /**
     * This function is basically duplicated from messages.js in AJS, because some products
     * only provide a stub version of messages.js within gadgets.
     */
    function makeCloseable(message) {
        var $icon = $('<span class="aui-icon icon-close"></span>').click(function () {
            message.trigger("messageClose", [this]).remove();
        });
        message.append($icon);
    }

    /**
     * Helper function to get the DOM object of the current iframe.
     * @return {Object} a DOM object, or null if we are not in an iframe
     */
    function getCurrentIframe() {
        if (window === parent.window) {
            return null;
        }
        var ret = null,
            myFrameWindow = window;
        $('iframe', parent.document.body).each(function(index) {
            if (this.contentWindow.window === myFrameWindow) {
                ret = this;
            }
        });
        return ret;
    }

    /**
     * Event handler that is called by the applinks authorization completion servlet.  It triggers
     * the completion function for any pending authorization request that matches the given applink
     * ID, and also redispatches the event to any other iframes in the current window.
     * @param {Object} eventObject  JQuery event object
     * @param {string} applinkId  application link ID
     * @param {boolean} success  true if the request was approved
     * @param {string} authAdminUri  URI of the "OAuth Access Tokens" page (will be displayed in the
     *   confirmation message)
     * @param {boolean} wasRedispatched  true if the event has been retriggered from another frame
     * @param {Object} [messages]
     *      'userError': an error message relevant to a non-admin user,
     *      'adminError': an error message relevant to an admin user,
     *      'adminErrorDetails': a list of details related to the admin message if there is one 
     */
    function onAuthCompletion(eventObject, applinkId, success, authAdminUri, wasRedispatched, messages) {
        if (applinkId in pendingRequests) {
            var request = pendingRequests[applinkId];
            if (success) {
                request.authAdminUri = authAdminUri;
                delete pendingRequests[applinkId];
            }
            completeAuthRequest(request, success, messages);
        }
        if (!wasRedispatched && parent && (parent !== window)) {
            var myWindow = window;
            $('iframe', parent.document.body).each(function(index, frame) {
                var scope = frame.contentWindow;
                if (scope !== myWindow) {
                    if (scope.AJS && scope.AJS.$) {
                        scope.AJS.$(scope.document).trigger('applinks.auth.completion',
                            [applinkId, success, authAdminUri, true, messages]);
                    }
                }
            });
        }
    }
      
    /**
     * Fires the appropriate event when the authorization flow has completed.  On approval, reloads
     * the window/frame unless an event handler calls {@code preventDefault()} on the event.
     * @param {Object} applinkProperties  has the same properties passed to {@link createAuthRequestBanner}
     * @param {boolean} approved  true if the request was approved
     * @param {Object} [messages]
     *      'userError': an error message relevant to a non-admin user,
     *      'adminError': an error message relevant to an admin user,
     *      'adminErrorDetails': a list of details related to the admin message if there is one
     */
    function completeAuthRequest(applinkProperties, approved, messages) {
        var $scope = $(document);
        if (approved) {
            // Temporarily bind an event handler so our handler runs after any other handlers that
            // may exist.
            var defaultApprovalHandler = function (eventObject) {
                if (eventObject.isDefaultPrevented()) {
                    // Don't reload, just show the confirmation message
                    showAuthConfirmationBanner(applinkProperties);
                } else {
                    // Reload, but first save a reminder to make us show a confirmation message
                    // after we've reloaded.
                    registerPendingConfirmation(applinkProperties);
                    document.location.reload(true);
                }
            };
            $scope.bind('applinks.auth.approved', defaultApprovalHandler);
            $scope.trigger('applinks.auth.approved', applinkProperties);
            $scope.unbind('applinks.auth.approved', defaultApprovalHandler);
        } else {
            // There's no default behavior for a request that was denied, but fire an event in case
            // anyone is interested.
            $scope.trigger('applinks.auth.denied', [applinkProperties, messages]);
        }
    }

    /**
     * Used internally to make the applink support code aware of a "please authenticate" message
     * element that has been displayed, by wiring the appropriate event handlers and adding the
     * applink's properties to an internal list of authentication requests.
     * @param $element {Object}  a JQuery object
     * @param applinkProperties {Object}  has the same properties passed to {@link createAuthRequestBanner}
     */
    function initAuthRequest($element, applinkProperties) {
        var $authLink = $element.find("a.applink-authenticate");
        
        if ($element.hasClass('aui-message')) {
            // Workaround for incomplete AJS availability in some products
            makeCloseable($element);
        }
        
        $authLink.click(function(e) {
            window.open(applinkProperties.authUri, authWindowName);
            e.preventDefault();
        });
        
        pendingRequests[applinkProperties.id] = applinkProperties;
        
        return $element;
    }
    
    /**
     * Used internally to ensure that {@link initAuthRequest} is called for every
     * authorisation request element that was generated as HTML from the back end,
     * rather than by calling {@link createAuthRequestBanner} or
     * {@link createAuthRequestInline}.  The parameters of the request are passed
     * from the back end in hidden input elements.
     */
    function initAuthRequestElements() {
        $('.applinks-auth-request').each(function(index) {
            var $e = $(this),
                applinkId = $e.find(".applinkId").val(),
                appName = $e.find(".appName").val(),
                appUri = $e.find(".appUri").val(),
                authUri = $e.find(".authUri").val();
            // Ignore request banners that have already been created (by {@link createAuthRequestBanner} or
            // {@link createAuthRequestInline})
            if (applinkId && authUri) {
                initAuthRequest($e, {
                    id: applinkId,
                    appName: appName,
                    appUri: appUri,
                    authUri: authUri});
            }
        });
    }

    /**
     * Builds a "please authenticate" banner (in a standard AUI message box) containing a link that
     * that will start authorization for an application link that needs credentials.
     * <p>
     * On completion of the authorization flow, a JQuery event will be triggered on the document,
     * with the event type "applinks.auth.approved" or "applinks.auth.denied", and an additional
     * parameter equal to the {@code applinkProperties} parameter that was passed here.
     * <p>
     * If authorization is granted (event "applinks.auth.approved"), the default behavior is for the
     * window or frame to be reloaded; also, a confirmation banner will be displayed either within
     * a &lt;div&gt; element of class "applinks-auth-confirmation-container" if one exists, or at the top of
     * the document otherwise.  Reloading of the window/frame can be disabled by having an event
     * handler call {@code preventDefault()} on the event.
     *
     * @param {Object} applinkProperties contains the following application link properties:
     *   {@code id}: the application link identifier;
     *   {@code appName}: the name of the remote application;
     *   {@code appUri}: the base URI of the remote application;
     *   {@code authUri}: the URI for starting the authorization flow
     * @return {Object} a JQuery object referring to a {@code <div>} element, which has not yet
     *   been inserted anywhere on the page; its class is "applinks-auth-request"
     */
    function createAuthRequestBanner(applinkProperties) {
        var $banner = $('<div class="aui-message warning closeable applinks-auth-request"><p><span class="aui-icon icon-applinks-key"></span></p></div>');
        // Note that we can't just use the AJS.messages.warning() function, because it will put a
        // standard warning icon in the message box and we want a custom icon.
        $banner.append(AJS.format("Additional information may be available, please \u003ca class=\"applink-authenticate\" href=\"{0}\"\u003eauthenticate\u003c/a\u003e with \u003ca href=\"{1}\"\u003e{2}\u003c/a\u003e.",
                                        AJS.escapeHtml(applinkProperties.authUri),
                                        AJS.escapeHtml(applinkProperties.appUri),
                                        AJS.escapeHtml(applinkProperties.appName)));
        initAuthRequest($banner, applinkProperties);
        return $banner;
    }

    /**
     * Builds a "please authenticate" message suitable for displaying inline (in a span
     * with the class "applinks-auth-request"), containing a link that will start authorization.
     * This behaves identically to {@link createAuthRequestBanner}, except it creates a {@code <span>}
     * element instead of a {@code div} and also allows additional text to be displayed.
     * 
     * @param {string} content  optional HTML content to be displayed within the inline
     *   element (e.g. a description of the entity for which authorization is required);
     *   will not be escaped; may be null
     * @param {Object} applinkProperties  see {@link createAuthRequestBanner}
     * @return {Object} a JQuery object referring to a {@code <span>} element, which has not yet
     *   been inserted anywhere on the page; its class is "applinks-auth-request"
     */
    function createAuthRequestInline(content, applinkProperties) {
        var $lozenge = $('<span class="applinks-auth-request"></span>'),
            $contentSpan = $('<span class="applinks-request-description"></span>'),
            message = AJS.format("\u003ca class=\"applink-authenticate\" href=\"{0}\"\u003eAuthenticate\u003c/a\u003e to see additional information.", AJS.escapeHtml(applinkProperties.authUri));
        if (content) {
            $contentSpan.append(content);
            $contentSpan.append(" - ");
        }
        $contentSpan.append(message);
        $lozenge.append($contentSpan);
        initAuthRequest($lozenge, applinkProperties);
        return $lozenge;
    }

    /**
     * Used internally to remember the fact that we have just completed authorizing an
     * applink and are about to refresh the iframe associated with it, so that we can
     * display a confirmation message after the iframe is refreshed.
     */
    function registerPendingConfirmation(applinkProperties) {
        var frame = getCurrentIframe();
        if ((!frame) || (!frame.id)) {
            return;
        }
        if (! parent.ApplinksUtils.pendingConfirmations) {
            parent.ApplinksUtils.pendingConfirmations = { };
        }
        if (!(frame.id in parent.ApplinksUtils.pendingConfirmations)) {
            parent.ApplinksUtils.pendingConfirmations[frame.id] = [];
        }
        parent.ApplinksUtils.pendingConfirmations[frame.id].push(applinkProperties);
        return;
    }

    /**
     * Called after a page load, to see if we've been refreshed due to a successful authorization.
     * If we're in an iframe, a variable will have been set on the parent window to tell us that
     * this happened.  If so, insert a confirmation banner at the top of the iframe.
     */
    function checkForPendingConfirmations() {
        if (parent && parent.ApplinksUtils && parent.ApplinksUtils.pendingConfirmations) {
            var myFrame = getCurrentIframe();
            if (myFrame) {
                if (myFrame.id in parent.ApplinksUtils.pendingConfirmations) {
                    var pendingConfirmations = parent.ApplinksUtils.pendingConfirmations[myFrame.id];
                    delete parent.ApplinksUtils.pendingConfirmations[myFrame.id];
                    for (var i = 0, n = pendingConfirmations.length; i < n; i++) {
                        showAuthConfirmationBanner(pendingConfirmations[i]);
                    }
                }
            }
        }
    }

    /**
     * Displays a confirmation banner.  If an element exists with the class
     * "applinks-auth-confirmation-contianer", it is inserted there, otherwise at the top of the
     * document.
     */
    function showAuthConfirmationBanner(applinkProperties) {
        var scope = $(document),
            banner = $('<div class="aui-message success closeable applinks-auth-confirmation"><p><span class="aui-icon icon-applinks-key-success"></span></p></div>'),
            container = scope.find('div.applinks-auth-confirmation-container');
        if (!container.length) {
            container = scope.find('body');
        }
        banner.append(AJS.format("This application is now using \u003ca href=\"{0}\"\u003e{1}\u003c/a\u003e\'\'s credentials. Revoke access at any time by going to \u003ca href=\"{2}\"\u003eOAuth access tokens\u003c/a\u003e.",
                                        AJS.escapeHtml(applinkProperties.appUri),
                                        AJS.escapeHtml(applinkProperties.appName),
                                        AJS.escapeHtml(applinkProperties.authAdminUri)));
        makeCloseable(banner);
        container.prepend(banner);
        setTimeout(function() {
            banner.fadeOut(1000, function() {
                $(this).remove();
            });
        }, 5000);
    }
    
    /**
     * Initialization function to be called once at document ready time.
     */
    function setup() {
        // If we're in an iframe, set up an object in the parent window that we can use to
        // keep track of state even if the iframe is refreshed.
        if (parent && !(parent === window)) {
            if (! parent.ApplinksUtils) {
                parent.ApplinksUtils = { };
            }
        }
        
        $(document).bind('applinks.auth.completion', onAuthCompletion);

        initAuthRequestElements();
        checkForPendingConfirmations();
    }

    $(document).ready(setup);
    
    return {      
        createAuthRequestBanner: createAuthRequestBanner,
        createAuthRequestInline: createAuthRequestInline
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.plugin.jslibs:underscore-1.5.2', location = 'libs/underscore/1.5.2/underscore-1.5.2.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
  define('atlassian/libs/underscore-1.5.2', function() {
    var env = {};
    factory.call(env);
    return env._.noConflict();
  });
})(function(){
/////// End of Atlassian modification ///////

  //     Underscore.js 1.5.2
  //     http://underscorejs.org
  //     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  //     Underscore may be freely distributed under the MIT license.

  (function() {

    // Baseline setup
    // --------------

    // Establish the root object, `window` in the browser, or `exports` on the server.
    var root = this;

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Establish the object that gets returned to break out of a loop iteration.
    var breaker = {};

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var
      push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var
      nativeForEach      = ArrayProto.forEach,
      nativeMap          = ArrayProto.map,
      nativeReduce       = ArrayProto.reduce,
      nativeReduceRight  = ArrayProto.reduceRight,
      nativeFilter       = ArrayProto.filter,
      nativeEvery        = ArrayProto.every,
      nativeSome         = ArrayProto.some,
      nativeIndexOf      = ArrayProto.indexOf,
      nativeLastIndexOf  = ArrayProto.lastIndexOf,
      nativeIsArray      = Array.isArray,
      nativeKeys         = Object.keys,
      nativeBind         = FuncProto.bind;

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) {
      if (obj instanceof _) return obj;
      if (!(this instanceof _)) return new _(obj);
      this._wrapped = obj;
    };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `_` as a global object via a string identifier,
    // for Closure Compiler "advanced" mode.
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = _;
      }
      exports._ = _;
    } else {
      root._ = _;
    }

    // Current version.
    _.VERSION = '1.5.2';

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles objects with the built-in `forEach`, arrays, and raw objects.
    // Delegates to **ECMAScript 5**'s native `forEach` if available.
    var each = _.each = _.forEach = function(obj, iterator, context) {
      if (obj == null) return;
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, length = obj.length; i < length; i++) {
          if (iterator.call(context, obj[i], i, obj) === breaker) return;
        }
      } else {
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
        }
      }
    };

    // Return the results of applying the iterator to each element.
    // Delegates to **ECMAScript 5**'s native `map` if available.
    _.map = _.collect = function(obj, iterator, context) {
      var results = [];
      if (obj == null) return results;
      if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
      each(obj, function(value, index, list) {
        results.push(iterator.call(context, value, index, list));
      });
      return results;
    };

    var reduceError = 'Reduce of empty array with no initial value';

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
    _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
      var initial = arguments.length > 2;
      if (obj == null) obj = [];
      if (nativeReduce && obj.reduce === nativeReduce) {
        if (context) iterator = _.bind(iterator, context);
        return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
      }
      each(obj, function(value, index, list) {
        if (!initial) {
          memo = value;
          initial = true;
        } else {
          memo = iterator.call(context, memo, value, index, list);
        }
      });
      if (!initial) throw new TypeError(reduceError);
      return memo;
    };

    // The right-associative version of reduce, also known as `foldr`.
    // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
    _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
      var initial = arguments.length > 2;
      if (obj == null) obj = [];
      if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
        if (context) iterator = _.bind(iterator, context);
        return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
      }
      var length = obj.length;
      if (length !== +length) {
        var keys = _.keys(obj);
        length = keys.length;
      }
      each(obj, function(value, index, list) {
        index = keys ? keys[--length] : --length;
        if (!initial) {
          memo = obj[index];
          initial = true;
        } else {
          memo = iterator.call(context, memo, obj[index], index, list);
        }
      });
      if (!initial) throw new TypeError(reduceError);
      return memo;
    };

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = function(obj, iterator, context) {
      var result;
      any(obj, function(value, index, list) {
        if (iterator.call(context, value, index, list)) {
          result = value;
          return true;
        }
      });
      return result;
    };

    // Return all the elements that pass a truth test.
    // Delegates to **ECMAScript 5**'s native `filter` if available.
    // Aliased as `select`.
    _.filter = _.select = function(obj, iterator, context) {
      var results = [];
      if (obj == null) return results;
      if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
      each(obj, function(value, index, list) {
        if (iterator.call(context, value, index, list)) results.push(value);
      });
      return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = function(obj, iterator, context) {
      return _.filter(obj, function(value, index, list) {
        return !iterator.call(context, value, index, list);
      }, context);
    };

    // Determine whether all of the elements match a truth test.
    // Delegates to **ECMAScript 5**'s native `every` if available.
    // Aliased as `all`.
    _.every = _.all = function(obj, iterator, context) {
      iterator || (iterator = _.identity);
      var result = true;
      if (obj == null) return result;
      if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
      each(obj, function(value, index, list) {
        if (!(result = result && iterator.call(context, value, index, list))) return breaker;
      });
      return !!result;
    };

    // Determine if at least one element in the object matches a truth test.
    // Delegates to **ECMAScript 5**'s native `some` if available.
    // Aliased as `any`.
    var any = _.some = _.any = function(obj, iterator, context) {
      iterator || (iterator = _.identity);
      var result = false;
      if (obj == null) return result;
      if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
      each(obj, function(value, index, list) {
        if (result || (result = iterator.call(context, value, index, list))) return breaker;
      });
      return !!result;
    };

    // Determine if the array or object contains a given value (using `===`).
    // Aliased as `include`.
    _.contains = _.include = function(obj, target) {
      if (obj == null) return false;
      if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
      return any(obj, function(value) {
        return value === target;
      });
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = function(obj, method) {
      var args = slice.call(arguments, 2);
      var isFunc = _.isFunction(method);
      return _.map(obj, function(value) {
        return (isFunc ? method : value[method]).apply(value, args);
      });
    };

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = function(obj, key) {
      return _.map(obj, function(value){ return value[key]; });
    };

    // Convenience version of a common use case of `filter`: selecting only objects
    // containing specific `key:value` pairs.
    _.where = function(obj, attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return _[first ? 'find' : 'filter'](obj, function(value) {
        for (var key in attrs) {
          if (attrs[key] !== value[key]) return false;
        }
        return true;
      });
    };

    // Convenience version of a common use case of `find`: getting the first object
    // containing specific `key:value` pairs.
    _.findWhere = function(obj, attrs) {
      return _.where(obj, attrs, true);
    };

    // Return the maximum element or (element-based computation).
    // Can't optimize arrays of integers longer than 65,535 elements.
    // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
    _.max = function(obj, iterator, context) {
      if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
        return Math.max.apply(Math, obj);
      }
      if (!iterator && _.isEmpty(obj)) return -Infinity;
      var result = {computed : -Infinity, value: -Infinity};
      each(obj, function(value, index, list) {
        var computed = iterator ? iterator.call(context, value, index, list) : value;
        computed > result.computed && (result = {value : value, computed : computed});
      });
      return result.value;
    };

    // Return the minimum element (or element-based computation).
    _.min = function(obj, iterator, context) {
      if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
        return Math.min.apply(Math, obj);
      }
      if (!iterator && _.isEmpty(obj)) return Infinity;
      var result = {computed : Infinity, value: Infinity};
      each(obj, function(value, index, list) {
        var computed = iterator ? iterator.call(context, value, index, list) : value;
        computed < result.computed && (result = {value : value, computed : computed});
      });
      return result.value;
    };

    // Shuffle an array, using the modern version of the
    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherâYates_shuffle).
    _.shuffle = function(obj) {
      var rand;
      var index = 0;
      var shuffled = [];
      each(obj, function(value) {
        rand = _.random(index++);
        shuffled[index - 1] = shuffled[rand];
        shuffled[rand] = value;
      });
      return shuffled;
    };

    // Sample **n** random values from an array.
    // If **n** is not specified, returns a single random element from the array.
    // The internal `guard` argument allows it to work with `map`.
    _.sample = function(obj, n, guard) {
      if (arguments.length < 2 || guard) {
        return obj[_.random(obj.length - 1)];
      }
      return _.shuffle(obj).slice(0, Math.max(0, n));
    };

    // An internal function to generate lookup iterators.
    var lookupIterator = function(value) {
      return _.isFunction(value) ? value : function(obj){ return obj[value]; };
    };

    // Sort the object's values by a criterion produced by an iterator.
    _.sortBy = function(obj, value, context) {
      var iterator = lookupIterator(value);
      return _.pluck(_.map(obj, function(value, index, list) {
        return {
          value: value,
          index: index,
          criteria: iterator.call(context, value, index, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
      }), 'value');
    };

    // An internal function used for aggregate "group by" operations.
    var group = function(behavior) {
      return function(obj, value, context) {
        var result = {};
        var iterator = value == null ? _.identity : lookupIterator(value);
        each(obj, function(value, index) {
          var key = iterator.call(context, value, index, obj);
          behavior(result, key, value);
        });
        return result;
      };
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = group(function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });

    // Indexes the object's values by a criterion, similar to `groupBy`, but for
    // when you know that your index values will be unique.
    _.indexBy = group(function(result, key, value) {
      result[key] = value;
    });

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    _.countBy = group(function(result, key) {
      _.has(result, key) ? result[key]++ : result[key] = 1;
    });

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = function(array, obj, iterator, context) {
      iterator = iterator == null ? _.identity : lookupIterator(iterator);
      var value = iterator.call(context, obj);
      var low = 0, high = array.length;
      while (low < high) {
        var mid = (low + high) >>> 1;
        iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
      }
      return low;
    };

    // Safely create a real, live array from anything iterable.
    _.toArray = function(obj) {
      if (!obj) return [];
      if (_.isArray(obj)) return slice.call(obj);
      if (obj.length === +obj.length) return _.map(obj, _.identity);
      return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = function(obj) {
      if (obj == null) return 0;
      return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
    };

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = function(array, n, guard) {
      if (array == null) return void 0;
      return (n == null) || guard ? array[0] : slice.call(array, 0, n);
    };

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N. The **guard** check allows it to work with
    // `_.map`.
    _.initial = function(array, n, guard) {
      return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
    };

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array. The **guard** check allows it to work with `_.map`.
    _.last = function(array, n, guard) {
      if (array == null) return void 0;
      if ((n == null) || guard) {
        return array[array.length - 1];
      } else {
        return slice.call(array, Math.max(array.length - n, 0));
      }
    };

    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
    // Especially useful on the arguments object. Passing an **n** will return
    // the rest N values in the array. The **guard**
    // check allows it to work with `_.map`.
    _.rest = _.tail = _.drop = function(array, n, guard) {
      return slice.call(array, (n == null) || guard ? 1 : n);
    };

    // Trim out all falsy values from an array.
    _.compact = function(array) {
      return _.filter(array, _.identity);
    };

    // Internal implementation of a recursive `flatten` function.
    var flatten = function(input, shallow, output) {
      if (shallow && _.every(input, _.isArray)) {
        return concat.apply(output, input);
      }
      each(input, function(value) {
        if (_.isArray(value) || _.isArguments(value)) {
          shallow ? push.apply(output, value) : flatten(value, shallow, output);
        } else {
          output.push(value);
        }
      });
      return output;
    };

    // Flatten out an array, either recursively (by default), or just one level.
    _.flatten = function(array, shallow) {
      return flatten(array, shallow, []);
    };

    // Return a version of the array that does not contain the specified value(s).
    _.without = function(array) {
      return _.difference(array, slice.call(arguments, 1));
    };

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = function(array, isSorted, iterator, context) {
      if (_.isFunction(isSorted)) {
        context = iterator;
        iterator = isSorted;
        isSorted = false;
      }
      var initial = iterator ? _.map(array, iterator, context) : array;
      var results = [];
      var seen = [];
      each(initial, function(value, index) {
        if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
          seen.push(value);
          results.push(array[index]);
        }
      });
      return results;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = function() {
      return _.uniq(_.flatten(arguments, true));
    };

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    _.intersection = function(array) {
      var rest = slice.call(arguments, 1);
      return _.filter(_.uniq(array), function(item) {
        return _.every(rest, function(other) {
          return _.indexOf(other, item) >= 0;
        });
      });
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = function(array) {
      var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
      return _.filter(array, function(value){ return !_.contains(rest, value); });
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = function() {
      var length = _.max(_.pluck(arguments, "length").concat(0));
      var results = new Array(length);
      for (var i = 0; i < length; i++) {
        results[i] = _.pluck(arguments, '' + i);
      }
      return results;
    };

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values.
    _.object = function(list, values) {
      if (list == null) return {};
      var result = {};
      for (var i = 0, length = list.length; i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    };

    // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
    // we need this function. Return the position of the first occurrence of an
    // item in an array, or -1 if the item is not included in the array.
    // Delegates to **ECMAScript 5**'s native `indexOf` if available.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = function(array, item, isSorted) {
      if (array == null) return -1;
      var i = 0, length = array.length;
      if (isSorted) {
        if (typeof isSorted == 'number') {
          i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
        } else {
          i = _.sortedIndex(array, item);
          return array[i] === item ? i : -1;
        }
      }
      if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
      for (; i < length; i++) if (array[i] === item) return i;
      return -1;
    };

    // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
    _.lastIndexOf = function(array, item, from) {
      if (array == null) return -1;
      var hasIndex = from != null;
      if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
        return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
      }
      var i = (hasIndex ? from : array.length);
      while (i--) if (array[i] === item) return i;
      return -1;
    };

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function(start, stop, step) {
      if (arguments.length <= 1) {
        stop = start || 0;
        start = 0;
      }
      step = arguments[2] || 1;

      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var idx = 0;
      var range = new Array(length);

      while(idx < length) {
        range[idx++] = start;
        start += step;
      }

      return range;
    };

    // Function (ahem) Functions
    // ------------------

    // Reusable constructor function for prototype setting.
    var ctor = function(){};

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
    // available.
    _.bind = function(func, context) {
      var args, bound;
      if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
      if (!_.isFunction(func)) throw new TypeError;
      args = slice.call(arguments, 2);
      return bound = function() {
        if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
        ctor.prototype = func.prototype;
        var self = new ctor;
        ctor.prototype = null;
        var result = func.apply(self, args.concat(slice.call(arguments)));
        if (Object(result) === result) return result;
        return self;
      };
    };

    // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context.
    _.partial = function(func) {
      var args = slice.call(arguments, 1);
      return function() {
        return func.apply(this, args.concat(slice.call(arguments)));
      };
    };

    // Bind all of an object's methods to that object. Useful for ensuring that
    // all callbacks defined on an object belong to it.
    _.bindAll = function(obj) {
      var funcs = slice.call(arguments, 1);
      if (funcs.length === 0) throw new Error("bindAll must be passed function names");
      each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
      return obj;
    };

    // Memoize an expensive function by storing its results.
    _.memoize = function(func, hasher) {
      var memo = {};
      hasher || (hasher = _.identity);
      return function() {
        var key = hasher.apply(this, arguments);
        return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
      };
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = function(func, wait) {
      var args = slice.call(arguments, 2);
      return setTimeout(function(){ return func.apply(null, args); }, wait);
    };

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = function(func) {
      return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
    };

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    _.throttle = function(func, wait, options) {
      var context, args, result;
      var timeout = null;
      var previous = 0;
      options || (options = {});
      var later = function() {
        previous = options.leading === false ? 0 : new Date;
        timeout = null;
        result = func.apply(context, args);
      };
      return function() {
        var now = new Date;
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0) {
          clearTimeout(timeout);
          timeout = null;
          previous = now;
          result = func.apply(context, args);
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = function(func, wait, immediate) {
      var timeout, args, context, timestamp, result;
      return function() {
        context = this;
        args = arguments;
        timestamp = new Date();
        var later = function() {
          var last = (new Date()) - timestamp;
          if (last < wait) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) result = func.apply(context, args);
          }
        };
        var callNow = immediate && !timeout;
        if (!timeout) {
          timeout = setTimeout(later, wait);
        }
        if (callNow) result = func.apply(context, args);
        return result;
      };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = function(func) {
      var ran = false, memo;
      return function() {
        if (ran) return memo;
        ran = true;
        memo = func.apply(this, arguments);
        func = null;
        return memo;
      };
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = function(func, wrapper) {
      return function() {
        var args = [func];
        push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function() {
      var funcs = arguments;
      return function() {
        var args = arguments;
        for (var i = funcs.length - 1; i >= 0; i--) {
          args = [funcs[i].apply(this, args)];
        }
        return args[0];
      };
    };

    // Returns a function that will only be executed after being called N times.
    _.after = function(times, func) {
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    };

    // Object Functions
    // ----------------

    // Retrieve the names of an object's properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`
    _.keys = nativeKeys || function(obj) {
      if (obj !== Object(obj)) throw new TypeError('Invalid object');
      var keys = [];
      for (var key in obj) if (_.has(obj, key)) keys.push(key);
      return keys;
    };

    // Retrieve the values of an object's properties.
    _.values = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var values = new Array(length);
      for (var i = 0; i < length; i++) {
        values[i] = obj[keys[i]];
      }
      return values;
    };

    // Convert an object into a list of `[key, value]` pairs.
    _.pairs = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var pairs = new Array(length);
      for (var i = 0; i < length; i++) {
        pairs[i] = [keys[i], obj[keys[i]]];
      }
      return pairs;
    };

    // Invert the keys and values of an object. The values must be serializable.
    _.invert = function(obj) {
      var result = {};
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        result[obj[keys[i]]] = keys[i];
      }
      return result;
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`
    _.functions = _.methods = function(obj) {
      var names = [];
      for (var key in obj) {
        if (_.isFunction(obj[key])) names.push(key);
      }
      return names.sort();
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = function(obj) {
      each(slice.call(arguments, 1), function(source) {
        if (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      });
      return obj;
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = function(obj) {
      var copy = {};
      var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
      each(keys, function(key) {
        if (key in obj) copy[key] = obj[key];
      });
      return copy;
    };

     // Return a copy of the object without the blacklisted properties.
    _.omit = function(obj) {
      var copy = {};
      var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
      for (var key in obj) {
        if (!_.contains(keys, key)) copy[key] = obj[key];
      }
      return copy;
    };

    // Fill in a given object with default properties.
    _.defaults = function(obj) {
      each(slice.call(arguments, 1), function(source) {
        if (source) {
          for (var prop in source) {
            if (obj[prop] === void 0) obj[prop] = source[prop];
          }
        }
      });
      return obj;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = function(obj) {
      if (!_.isObject(obj)) return obj;
      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = function(obj, interceptor) {
      interceptor(obj);
      return obj;
    };

    // Internal recursive comparison function for `isEqual`.
    var eq = function(a, b, aStack, bStack) {
      // Identical objects are equal. `0 === -0`, but they aren't identical.
      // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
      if (a === b) return a !== 0 || 1 / a == 1 / b;
      // A strict comparison is necessary because `null == undefined`.
      if (a == null || b == null) return a === b;
      // Unwrap any wrapped objects.
      if (a instanceof _) a = a._wrapped;
      if (b instanceof _) b = b._wrapped;
      // Compare `[[Class]]` names.
      var className = toString.call(a);
      if (className != toString.call(b)) return false;
      switch (className) {
        // Strings, numbers, dates, and booleans are compared by value.
        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return a == String(b);
        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
          // other numeric values.
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') return false;
      // Assume equality for cyclic structures. The algorithm for detecting cyclic
      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
      var length = aStack.length;
      while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] == a) return bStack[length] == b;
      }
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Add the first object to the stack of traversed objects.
      aStack.push(a);
      bStack.push(b);
      var size = 0, result = true;
      // Recursively compare objects and arrays.
      if (className == '[object Array]') {
        // Compare array lengths to determine if a deep comparison is necessary.
        size = a.length;
        result = size == b.length;
        if (result) {
          // Deep compare the contents, ignoring non-numeric properties.
          while (size--) {
            if (!(result = eq(a[size], b[size], aStack, bStack))) break;
          }
        }
      } else {
        // Deep compare objects.
        for (var key in a) {
          if (_.has(a, key)) {
            // Count the expected number of properties.
            size++;
            // Deep compare each member.
            if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
          }
        }
        // Ensure that both objects contain the same number of properties.
        if (result) {
          for (key in b) {
            if (_.has(b, key) && !(size--)) break;
          }
          result = !size;
        }
      }
      // Remove the first object from the stack of traversed objects.
      aStack.pop();
      bStack.pop();
      return result;
    };

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = function(a, b) {
      return eq(a, b, [], []);
    };

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = function(obj) {
      if (obj == null) return true;
      if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
      for (var key in obj) if (_.has(obj, key)) return false;
      return true;
    };

    // Is a given value a DOM element?
    _.isElement = function(obj) {
      return !!(obj && obj.nodeType === 1);
    };

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || function(obj) {
      return toString.call(obj) == '[object Array]';
    };

    // Is a given variable an object?
    _.isObject = function(obj) {
      return obj === Object(obj);
    };

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
    each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
      _['is' + name] = function(obj) {
        return toString.call(obj) == '[object ' + name + ']';
      };
    });

    // Define a fallback version of the method in browsers (ahem, IE), where
    // there isn't any inspectable "Arguments" type.
    if (!_.isArguments(arguments)) {
      _.isArguments = function(obj) {
        return !!(obj && _.has(obj, 'callee'));
      };
    }

    // Optimize `isFunction` if appropriate.
    if (typeof (/./) !== 'function') {
      _.isFunction = function(obj) {
        return typeof obj === 'function';
      };
    }

    // Is a given object a finite number?
    _.isFinite = function(obj) {
      return isFinite(obj) && !isNaN(parseFloat(obj));
    };

    // Is the given value `NaN`? (NaN is the only number which does not equal itself).
    _.isNaN = function(obj) {
      return _.isNumber(obj) && obj != +obj;
    };

    // Is a given value a boolean?
    _.isBoolean = function(obj) {
      return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
    };

    // Is a given value equal to null?
    _.isNull = function(obj) {
      return obj === null;
    };

    // Is a given variable undefined?
    _.isUndefined = function(obj) {
      return obj === void 0;
    };

    // Shortcut function for checking if an object has a given property directly
    // on itself (in other words, not on a prototype).
    _.has = function(obj, key) {
      return hasOwnProperty.call(obj, key);
    };

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function() {
      root._ = previousUnderscore;
      return this;
    };

    // Keep the identity function around for default iterators.
    _.identity = function(value) {
      return value;
    };

    // Run a function **n** times.
    _.times = function(n, iterator, context) {
      var accum = Array(Math.max(0, n));
      for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
      return accum;
    };

    // Return a random integer between min and max (inclusive).
    _.random = function(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    };

    // List of HTML entities for escaping.
    var entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      }
    };
    entityMap.unescape = _.invert(entityMap.escape);

    // Regexes containing the keys and values listed immediately above.
    var entityRegexes = {
      escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
      unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
    };

    // Functions for escaping and unescaping strings to/from HTML interpolation.
    _.each(['escape', 'unescape'], function(method) {
      _[method] = function(string) {
        if (string == null) return '';
        return ('' + string).replace(entityRegexes[method], function(match) {
          return entityMap[method][match];
        });
      };
    });

    // If the value of the named `property` is a function then invoke it with the
    // `object` as context; otherwise, return it.
    _.result = function(object, property) {
      if (object == null) return void 0;
      var value = object[property];
      return _.isFunction(value) ? value.call(object) : value;
    };

    // Add your own custom functions to the Underscore object.
    _.mixin = function(obj) {
      each(_.functions(obj), function(name) {
        var func = _[name] = obj[name];
        _.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return result.call(this, func.apply(_, args));
        };
      });
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = function(prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
      evaluate    : /<%([\s\S]+?)%>/g,
      interpolate : /<%=([\s\S]+?)%>/g,
      escape      : /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'":      "'",
      '\\':     '\\',
      '\r':     'r',
      '\n':     'n',
      '\t':     't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    _.template = function(text, data, settings) {
      var render;
      settings = _.defaults({}, settings, _.templateSettings);

      // Combine delimiters into one regular expression via alternation.
      var matcher = new RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');

      // Compile the template source, escaping string literals appropriately.
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset)
          .replace(escaper, function(match) { return '\\' + escapes[match]; });

        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        }
        if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        }
        if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }
        index = offset + match.length;
        return match;
      });
      source += "';\n";

      // If a variable is not specified, place data values in local scope.
      if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

      source = "var __t,__p='',__j=Array.prototype.join," +
        "print=function(){__p+=__j.call(arguments,'');};\n" +
        source + "return __p;\n";

      try {
        render = new Function(settings.variable || 'obj', '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }

      if (data) return render(data, _);
      var template = function(data) {
        return render.call(this, data, _);
      };

      // Provide the compiled function source as a convenience for precompilation.
      template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

      return template;
    };

    // Add a "chain" function, which will delegate to the wrapper.
    _.chain = function(obj) {
      return _(obj).chain();
    };

    // OOP
    // ---------------
    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.

    // Helper function to continue chaining intermediate results.
    var result = function(obj) {
      return this._chain ? _(obj).chain() : obj;
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        method.apply(obj, arguments);
        if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
        return result.call(this, obj);
      };
    });

    // Add all accessor Array functions to the wrapper.
    each(['concat', 'join', 'slice'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        return result.call(this, method.apply(this._wrapped, arguments));
      };
    });

    _.extend(_.prototype, {

      // Start chaining a wrapped Underscore object.
      chain: function() {
        this._chain = true;
        return this;
      },

      // Extracts the result from a wrapped and chained object.
      value: function() {
        return this._wrapped;
      }

    });

  }).call(this);

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:lodash-amd', location = 'applinks/internal/lib/lodash-jslibs.js' */
define('applinks/lib/lodash', ['atlassian/libs/underscore-1.5.2'], function(lodash) {
        return lodash;
    });;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/console-amd.js' */
define('applinks/lib/console', function() {
    return window.console;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/jquery-amd.js' */
define('applinks/lib/jquery', function() {
   return window.jQuery;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/aui-amd.js' */
define('applinks/lib/aui', function() {
   var aui = window.AJS;
   if (!aui) {
      throw "window.AJS not defined, cannot load AUI";
   }
   var auiVersion = aui.version.split(".");
   aui.versionDetails = {
      major: parseInt(auiVersion[0]),
      minor: parseInt(auiVersion[1]),
      bugfix: parseInt(auiVersion[2])
   };
   return aui;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/wrm-amd.js' */
/**
 * Define Web resource manager as an AMD dependency. This should also be present in apps using Atlassian Plugins Web
 * Resources framework.
 */
define('applinks/lib/wrm', function() {
   return window.WRM;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/skate-amd.js' */
define('applinks/lib/skate', function() {
   return window.skate;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/window-amd.js' */
/**
 * Define window as AMD module to facilitate unit testing of some modules
 */
define('applinks/lib/window', function() {
    return window;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/preconditions.js' */
define('applinks/common/preconditions', [
    'applinks/lib/lodash'
], function(
    _
) {
    function nonEmptyString(value, varName, customMessage) {
        _checkArgument(
            _.isString(value) && !_.isEmpty(value),
            customMessage,
            _withVarName(varName, ': expected a non-empty string')
        );
    }

    function isFunction(value, varName, customMessage) {
        _checkArgument(
            _.isFunction(value),
            customMessage,
            _withVarName(varName, ': expected a function, was: ' + value)
        );
    }

    function hasValue(value, varName, customMessage) {
        _checkArgument(
            value,
            customMessage,
            _withVarName(varName, ': expected a value')
        );
    }

    function _checkArgument(value, message, defaultMessage) {
        var actualMessage = message ? message : defaultMessage;
        if (!value) {
            throw new Error(actualMessage)
        }
    }

    function _withVarName(varName, msg) {
        return (varName || '[unspecified]') + msg;
    }

    return {
        checkArgument: _.partial(_checkArgument, _, _, ''),
        nonEmptyString: nonEmptyString,
        isFunction: isFunction,
        hasValue: hasValue
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/context.js' */
define('applinks/common/context', [
    'applinks/lib/console',
    'applinks/lib/window',
    'applinks/lib/wrm',
    'applinks/common/modules'
], function(
    console,
    window,
    WRM,
    ApplinksModules
) {
    var context = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-context'));

    return {
        currentUser: function() {
            return context.currentUser
        },

        /**
         * @returns {object} host application containing `id` and `type` properties
         */
        hostApplication: function() {
            return context.hostApplication
        },

        validateCurrentUser: function() {
            if (!this.currentUser()) {
                console.log('No user context, reloading the page to trigger redirect to the login screen');
                window.location.reload();
            }
        }
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/help-paths.js' */
define('applinks/common/help-paths', [
    'applinks/lib/console',
    'applinks/lib/wrm',
    'applinks/lib/lodash',
    'applinks/common/modules',
    'applinks/common/preconditions'
], function(
    console,
    WRM,
    _,
    ApplinksModules,
    Preconditions
) {
    // lazy-load help paths, facilitates unit-testing
    var allHelpPaths = _.memoize(function() {
        var helpPaths = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-help-paths'));
        if (!helpPaths.entries) {
            console.warn('Help paths not found, all help links are likely to be broken.');
        }
        return helpPaths.entries || {};
    });

    var getPath = function(key, sectionKey) {
        Preconditions.nonEmptyString(key, 'key');
        var path = allHelpPaths()[key] || key;
        if (sectionKey) {
            Preconditions.nonEmptyString(sectionKey, 'sectionKey');
            var prefix = path.replace(/\+/g, ''); // "g" flag to remove _all_ '+' signs
            path += '#' +prefix + '-' + sectionKey;
        }
        return path;
    };

    function endsWith(string, suffix) {
        return string.indexOf(suffix, string.length - suffix.length) !== -1;
    }

    function addSuffixIfRequired(string, suffix) {
        return endsWith(string, suffix) ? string : string + suffix;
    }

    return {
        /**
         * @param key {string} key to get the path for
         * @returns {string} relative help path that can be appended to any relevant docs base URL
         */
        getPath: getPath,

        /**
         * @param key {string} key to get the path for
         * @param sectionKey {string} optional key of the anchor on the target page
         * @returns {string} full help path including the base URL
         */
        getFullPath: function(key, sectionKey) {
            var baseUrl = this.baseUrl();
            return addSuffixIfRequired(baseUrl, '/') + this.getPath(key, sectionKey);
        },

        /**
         * @returns {string} configured base URL for the help paths
         */
        baseUrl: _.partial(getPath, 'applinks.docs.root')
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/events.js' */
define('applinks/common/events', function() {

    var PREFIX = 'applinks.event.';

    return {
        PREREADY: PREFIX + 'preready',
        READY: PREFIX + 'ready',

        /**
         * Raised when applinks list is first loaded
         */
        APPLINKS_LOADED: PREFIX + 'loaded',
        /**
         * Raised when applinks list is updated
         */
        APPLINKS_UPDATED: PREFIX + 'updated',

        /**
         * This event is only raised when linking to Atlassian applications
         * Can be consumed by other plugins
         */
        NEW_APPLINK_CREATED: PREFIX + 'created',

        // legacy events
        Legacy: {
            MESSAGE_BOX_DISPLAYED: PREFIX + 'message-box-displayed'
        }
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/initializer.js' */
define('applinks/common/initializer', [
    'applinks/lib/jquery',
    'applinks/lib/lodash'
], function(
    $,
    _
) {
    function _callInitCallback(module) {
        if (module && _.isFunction(module.init)) {
            module.init();
        }
        if (module && _.isFunction(module.initialize)) {
            module.initialize();
        }
    }

    return {

        /**
         * Init `module`. If the module contains an `init` or `initialize` function, it will be called immediately
         * If both functions are present, both will be called.
         *
         * @param module {object} module to initialize
         */
        init: function(module) {
            _callInitCallback(module);
        },

        /**
         * Init `module` on DOM ready. If the module contains an `init` or `initialize` function, it will be called
         * on DOM ready event. Those functions should contain code that performs UI initialization dependent on the
         * state of the DOM. If both functions are present, both will be called.
         *
         * @param module {object} module to initialize
         */
        initOnDomReady: function(module) {
            $(document).ready(function() {
                _callInitCallback(module);
            });
        }
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/modules.js' */
/**
 * Applinks plugin modules core constants and definitions.
 */
define('applinks/common/modules', function() {
    return {
        /**
         * Applinks plugin key
         */
        PLUGIN_KEY: 'com.atlassian.applinks.applinks-plugin',

        /**
         * Fully qualifies a module name using the plugin key.
         *
         * @param {string} moduleName module name to qualify
         * @returns {string} fully qualified name
         */
        fqn: function(moduleName) {
            return this.PLUGIN_KEY + ':' + moduleName;
        },

        /**
         * Fully qualifies web-resource data using module name and data key.
         *
         * @param {string} moduleName module name
         * @param {string} dataKey key of the data element
         * @returns {string} fully qualified name
         */
        dataFqn: function(moduleName, dataKey) {
            return this.fqn(moduleName) + '.' + dataKey;
        }
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/features.js' */
define('applinks/common/features', [
    'applinks/lib/wrm',
    'applinks/lib/lodash',
    'applinks/common/modules',
    'applinks/common/context',
    'applinks/common/rest'
], function(
    WRM,
    _,
    ApplinksModules,
    ApplinksContext,
    ApplinksRest
) {
    var enabledFeatures, discoveredFeatures;

    function _getEnabledFeatures() {
        if (_.isUndefined(enabledFeatures)) {
            enabledFeatures = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-features'));
        }
        return enabledFeatures;
    }

    function _getDiscoveredFeatures() {
        if (_.isUndefined(discoveredFeatures)) {
            discoveredFeatures = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-discovered-features'));
        }
        return discoveredFeatures;
    }

    function isDiscovered(featureKey) {
        return _.contains(_getDiscoveredFeatures(), featureKey.toLowerCase());
    }

    function addEnabledFeatures(features) {
        _.extend(_getEnabledFeatures(), features);
    }

    function addDiscoveredFeatures(featureKeys) {
        featureKeys.forEach(function(featureKey){
            if (!isDiscovered(featureKey)) {
                _getDiscoveredFeatures().push(featureKey.toLowerCase());
            }
        });
    }

    /**
     * Allows to query for, enable and discover Applinks features.
     */
    return {

        BITBUCKET_REBRAND: 'BITBUCKET_REBRAND',
        V3_UI_OPT_IN: 'V3_UI_OPT_IN',
        V3_UI: 'V3_UI',

        /**
         * @returns {Object.<string, Object>} all enabled features mapped by key
         */
        getEnabledFeatures: function() {
            return _getEnabledFeatures();
        },

        isEnabled: function(featureName) {
            return this.getEnabledFeatures()[featureName];
        },

        /**
         * Disable `featureName`, requires user context and admin permissions.
         *
         * @param featureName {string} feature name to enable
         * @return the request promise to hook callbacks to
         */
        disable: function(featureName) {
            ApplinksContext.validateCurrentUser();
            return ApplinksRest.V3.features(featureName).del()
                .done(function() {
                    _getEnabledFeatures()[featureName] = false;
                });
        },

        /**
         * Enable `featureName`, requires user context and admin permissions.
         *
         * @param featureName {string} feature name to enable
         * @return the request promise to hook callbacks to
         */
        enable: function(featureName) {
            ApplinksContext.validateCurrentUser();
            return ApplinksRest.V3.features(featureName).put()
                .done(function(feature) {
                    addEnabledFeatures(feature);
                });
        },

        /**
         * @returns {string[]} an array of discovered feature keys
         */
        getDiscoveredFeatures: function() {
            return _getDiscoveredFeatures();
        },

        isDiscovered: isDiscovered,

        /**
         * Discover `featureKey`, requires user context.
         *
         * @param featureKey {string} key to discover
         */
        discover: function(featureKey) {
            ApplinksContext.validateCurrentUser();
            ApplinksRest.V3.featureDiscovery(featureKey).put()
                .fail(function(req) {
                    throw 'Feature discovery request failed: ' + req.status + ': ' + req.responseText;
                }).done(function(featureKey) {
                    addDiscoveredFeatures(featureKey);
                });
        }
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/products.js' */
define('applinks/common/products', [
    'applinks/lib/window'
], function(Window) {

    function getTypeName(typeId) {
        // Note: window.appLinksI18n.entries is injected into the page by common_header.vm
        return Window.appLinksI18n.entries['applinks.application.type.'+typeId];
    }

    /**
     * Map of Atlassian product keys to application type IDs
     */
    return {
        BAMBOO: 'bamboo',
        BITBUCKET: 'stash', // special case, see java class com.atlassian.applinks.application.bitbucket.BitbucketApplicationTypeImpl.TYPE_ID
        CONFLUENCE: 'confluence',
        FECRU: 'fecru',
        JIRA: 'jira',
        REFAPP: 'refapp',
        STASH: 'stash',
        getTypeName: getTypeName
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/response-status.js' */
define('applinks/common/response-status', [
    'applinks/lib/lodash'
], function(
    _
) {

    function StatusFamily(familyCode) {
        this.familyCode = familyCode;
    }

    StatusFamily.prototype.matches = function(code) {
        return Math.floor(_getStatusCode(code) / 100) == this.familyCode;
    };

    var StatusFamilies = {
        INFORMATIONAL: new StatusFamily(1),
        SUCCESSFUL: new StatusFamily(2),
        REDIRECTION: new StatusFamily(3),
        CLIENT_ERROR: new StatusFamily(4),
        SERVER_ERROR: new StatusFamily(5),

        forCode: function(code) {
            return _.find(StatusFamilies.all(), function(family) {
                return family.matches(code);
            });
        },

        all: function() {
            return [
                StatusFamilies.INFORMATIONAL,
                StatusFamilies.SUCCESSFUL,
                StatusFamilies.REDIRECTION,
                StatusFamilies.CLIENT_ERROR,
                StatusFamilies.SERVER_ERROR
            ];
        }
    };

    function ResponseStatus(code) {
        this.code = code;
        this.family = StatusFamilies.forCode(code);
    }

    ResponseStatus.prototype.matches = function(code) {
        return _getStatusCode(code) == this.code;
    };

    function _getStatusCode(object) {
        if (object && object.status && _.isNumber(object.status)) {
            return object.status;
        } else if (_.isNumber(object)) {
            return object;
        } else {
            return 0;
        }
    }

    return {
        OK: new ResponseStatus(200),
        CREATED: new ResponseStatus(201),

        BAD_REQUEST: new ResponseStatus(400),
        UNAUTHORIZED: new ResponseStatus(401),
        FORBIDDEN: new ResponseStatus(403),
        NOT_FOUND: new ResponseStatus(404),
        CONFLICT: new ResponseStatus(409),

        Family: StatusFamilies
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/rest-request.js' */
define('applinks/common/rest-request', [
    'applinks/lib/console',
    'applinks/lib/window',
    'applinks/lib/jquery',
    'applinks/lib/lodash',
    'applinks/common/preconditions',
    'applinks/common/response-status'
], function(
    console,
    window,
    $,
    _,
    Preconditions,
    ResponseStatus
) {
    var defaultRequestSettings = {
        dataType: 'json',
        contentType: 'application/json'
    };

    // construct the target URL by adding query params
    function _toUrl(url, queryParams) {
        if (_.isEmpty(queryParams)) {
            return url;
        }
        var separator = url.indexOf('?') > -1 ? '&' : '?';
        return url + separator + $.param(queryParams);
    }

    // create default success and error handlers to ensure we got an expected status
    function _defaultSuccessHandler(statuses) {
        return function(data, textStatus, request) {
            if (!_.some(statuses, function(status) { return status.matches(request) })) {
                console.error('Unexpected response status: ' + request.status + ': ' + request.responseText);
            }
        }
    }

    function _defaultErrorHandler(statuses) {
        return function(request, textStatus, error) {
            if (!_.some(statuses, function(status) { return status.matches(request) })) {
                console.error('Unexpected response status: ' + request.status + ': ' + request.responseText);
                // force re-login if UNAUTHORIZED
                if (ResponseStatus.UNAUTHORIZED.matches(request)) {
                    window.location.reload();
                }
            }
        }
    }

    /**
     * Creates a new instance of `ApplinksRestRequest`.
     *
     * @param url URL to request to. NOTE: URLs with fragments (`#`) are not supported
     * @param params query parameters to add to the request URL
     * @constructor
     */
    function ApplinksRestRequest(url, params) {
        Preconditions.nonEmptyString(url, 'url');
        Preconditions.checkArgument(url.indexOf('#') == -1, 'url: "#" fragments not supported');
        this._url = url;
        this._queryParams = _.extend({}, params);
        this._expectedStatus = [ResponseStatus.Family.SUCCESSFUL];
    }

    ApplinksRestRequest.GET = 'GET';
    ApplinksRestRequest.PUT = 'PUT';
    ApplinksRestRequest.POST = 'POST';
    ApplinksRestRequest.DELETE = 'DELETE';

    ApplinksRestRequest.prototype.get = function() {
        return this._execute(this._requestSettings(ApplinksRestRequest.GET));
    };

    ApplinksRestRequest.prototype.del = function() {
        return this._execute(this._requestSettings(ApplinksRestRequest.DELETE));
    };

    ApplinksRestRequest.prototype.put = function(data) {
        var settings = this._requestSettings(ApplinksRestRequest.PUT);
        if (data) {
            settings.data = data;
        }
        return this._execute(settings);
    };

    ApplinksRestRequest.prototype.post = function(data) {
        var settings = this._requestSettings(ApplinksRestRequest.POST);
        if (data) {
            settings.data = data;
        }
        return this._execute(settings);
    };

    /**
     * Add query param to this request.
     *
     * @param {string} name param name
     * @param {string} value param value
     * @return {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.queryParam = function(name, value) {
        this._queryParams[name] = value;
        return this;
    };

    /**
     * Add query params to this request.
     *
     * @param {Object} params params map to add
     * @returns {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.queryParams = function(params) {
        this._queryParams = _.extend(this._queryParams, params);
        return this;
    };

    /**
     * Add `authorisationCallback` query parameter to this request, this is useful for resources that are expected to
     * respond with `authorisationUri`
     *
     * @param {string} callback URI to call back once authorisation is done
     * @return {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.authorisationCallback = function(callback) {
        this.queryParam('authorisationCallback', callback);
        return this;
    };

    /**
     * Expect a specific status (or status family). Use a specific number or one of the members defined in
     * `applinks/common/response-status`. By default a successful 20x response is expected. If the response does not
     * meet this expectation, a default error handler will be invoked.
     *
     * Invoke this method with any number of of statuses expressed as an object that contains `matches` method (using
     * the ones in `applinks/lib/response-status` is highly recommended).
     * @returns {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.expectStatus = function() {
        this._expectedStatus = _.isArray(arguments[0]) ? arguments[0] : _.toArray(arguments);
        return this;
    };

    ApplinksRestRequest.prototype._requestSettings = function(requestType) {
        var that = this;
        return _.defaults({
            url: _toUrl(that._url, that._queryParams),
            type: requestType
        }, defaultRequestSettings);
    };

    ApplinksRestRequest.prototype._execute = function(settings) {
        return $.ajax(settings)
            .done(_defaultSuccessHandler(this._expectedStatus))
            .fail(_defaultErrorHandler(this._expectedStatus));
    };

    return ApplinksRestRequest;
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/rest.js' */
define('applinks/common/rest', [
    'applinks/lib/aui',
    'applinks/common/preconditions',
    'applinks/common/rest-request',
    'applinks/common/rest-oauth'
], function(
    AJS,
    Preconditions,
    ApplinksRestRequest,
    ApplinksOAuthRest
) {
    function ApplinksRestModule(version) {
        Preconditions.hasValue(version, 'version');
        this._version = version;
    }

    ApplinksRestModule.prototype.baseUrl = function() {
        return AJS.contextPath() + '/rest/applinks/' + this._version;
    };

    ApplinksRestModule.prototype.withPath = function(path) {
        return this.baseUrl() + '/' + path;
    };

    function ApplinksV1RestModule() {
        this.module = new ApplinksRestModule('1.0');
    }

    function ApplinksV2RestModule() {
        this.module = new ApplinksRestModule('2.0');
    }

    function ApplinksV3RestModule() {
        this.module = new ApplinksRestModule('3.0');
    }

    ApplinksV3RestModule.prototype.featureDiscovery = function(featureKey) {
        if (!featureKey) {
            throw 'feature key not defined';
        }
        return new ApplinksRestRequest(this.module.withPath('feature-discovery/' + featureKey));
    };

    ApplinksV3RestModule.prototype.features = function(featureName) {
        if (!featureName) {
            throw 'feature name not defined';
        }
        return new ApplinksRestRequest(this.module.withPath('features/' + featureName));
    };

    ApplinksV3RestModule.prototype.status = function(applinkId) {
        if (!applinkId) {
            throw 'applinkId not defined';
        }
        return new ApplinksRestRequest(this.module.withPath('status/' + applinkId));
    };

    return {
        V1: new ApplinksV1RestModule(),
        V2: new ApplinksV2RestModule(),
        V3: new ApplinksV3RestModule(),
        OAuth: ApplinksOAuthRest
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/rest-oauth.js' */
define('applinks/common/rest-oauth', [
    'applinks/lib/aui',
    'applinks/common/rest-request',
    'applinks/common/preconditions'
], function(
    AJS,
    ApplinksRestRequest,
    Preconditions
) {
    function ApplinksOAuthRestModule(version) {
        Preconditions.hasValue(version, 'version');
        this.baseUrl =  AJS.contextPath() + '/rest/applinks-oauth/' + version + '/';
    }

    ApplinksOAuthRestModule.prototype._withPath = function(path) {
        return this.baseUrl + path;
    };

    function ApplinksOAuthV1RestModule() {
        this.module = new ApplinksOAuthRestModule('1.0');
    }

    ApplinksOAuthV1RestModule.prototype.consumerToken = function(applinkId) {
        Preconditions.hasValue(applinkId, 'applinkId');
        return new ApplinksRestRequest(this.module._withPath('consumer-token/' + applinkId));
    };

    return {
        V1: new ApplinksOAuthV1RestModule()
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/i18n.js' */
define('applinks/common/i18n', [
    'applinks/lib/jquery',
    'applinks/lib/aui'
], function(
    $,
    AJS
) {
    function init() {
        // set up I18n for dynamical calls on client side, remember to use " for AJS.I18n.getText
        // Please make sure that AbstractApplinksServlet.java has put the appLinksI18n.entries correctly on the page
        AJS.I18n.keys = AJS.I18n.keys || {};
        $.extend(AJS.I18n.keys, appLinksI18n.entries);
    }

    return {
        init: init
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'js/fecru-compatibility.js' */
if (jQuery != undefined && AJS != undefined) jQuery = AJS.$; // make sure we're extending the correct jQuery;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/common/rest-service.js' */
/**
 * The triggering of AppLinks initialisation can be customised by setting a function on
 * AJS.AppLinksInitialisationBinder. The binder function should take a single argument which is a zero-arg function to
 * run and should execute this function when appropriate.
 */
AppLinks = AJS.$.extend(window.AppLinks || {}, {
    Event: {
        NAMESPACE: "applinks"
    }
});
var ApplinksEvents = require('applinks/common/events');
AppLinks.Event = AJS.$.extend(window.AppLinks.Event, ApplinksEvents);

// Is there an overridden initialisation binder?
if (AJS.AppLinksInitialisationBinder) {
    AppLinks.initialisationBinder = AJS.AppLinksInitialisationBinder;
} else {
    // The default bind if no specific binder is specified
    AppLinks.initialisationBinder = function(f) {
        AJS.toInit(f);
    }
}

AppLinks.initialisationBinder(function() {
    //$ is passed in by AJS.toInit but initilizationBinder can be over loaded by products so that $ is unsafe.
    var $ = AJS.$;
    AppLinks = $.extend(window.AppLinks || {}, {
        failure: function(data) {
            if (data.status == 401) {
                window.location.reload();
            } else {
                var message = AppLinks.parseError(data);
                var errorDivs = $('.page-error');

                if (errorDivs.length > 0) {
                    errorDivs.html(message).fadeIn('slow');
                }
                else {
                    alert("REST request failed: " + message);
                }
            }
        },
        jsonRequest: function(url, type, data, success, error) {
            if (data) {
                data = JSON.stringify(data);
            }
            $(".page-error").fadeOut('fast');
            if (!error) error = AppLinks.failure;
            return jQuery.ajax({
                url: url,
                type: type,
                data: data,
                dataType: 'json',
                contentType: "application/json; charset=utf-8",
                cache: false,
                success: success,
                error: error
            });
        },
        xmlRequest: function(url, type, data, success, error) {
            if (data) {
                data = JSON.stringify(data);
            }
            $(".page-error").fadeOut('fast');
            if (!error) error = AppLinks.failure;
            return jQuery.ajax({
                url: url,
                type: type,
                data: data,
                dataType: 'xml',
                contentType: "application/xml; charset=utf-8",
                cache: false,
                success: success,
                error: error
            });
        },
        parseError: function(errorData) {
            var error;
            try {
                error = JSON.parse(errorData.responseText);
            } catch (e) {
                if (errorData.statusText) {
                    return error = errorData.statusText;
                } else {
                    return errorData;
                }
            }
            if (error.message) {
                if ($.isArray(error.message)) {
                    return error.message.join(' ');
                }
                return error.message;
            }
            else {
                return errorData.statusText;
            }
        },
        put: function(url, data, success, error) {
            return AppLinks.jsonRequest(url, 'PUT', data, success, error);
        },
        post: function(url, data, success, error) {
            return AppLinks.jsonRequest(url, 'POST', data, success, error);
        },
        update: function(data, success, error) {
            AppLinks.put(AppLinks.self_link(data), data, success, error);
        },
        get: function(url, success, error) {
            return AppLinks.jsonRequest(url, 'GET', null, success, error);
        },
        getXml: function(url, success, error) {
            return AppLinks.xmlRequest(url, 'GET', null, success, error);
        },
        self_link: function(item) {
            for (var i = 0, _i = item.link.length; i < _i; i++) {
                var link = item.link[i];
                if (link.rel == "self") return link.href;
            }

            throw "No self-link found";
        },
        del: function(urlOrObject, success, error) {
            var url;
            if (typeof(urlOrObject) == 'string') url = urlOrObject;
            else url = AppLinks.self_link(urlOrObject);
            return AppLinks.jsonRequest(url, 'DELETE', null, success, error);
        },
        SPI: $.extend({}, {
            API_VERSION: "1.0",
            REST_RESOURCE_URL: AJS.contextPath() + "/rest/applinks/",
            BASE_URL: AJS.contextPath() + "/rest/applinks/1.0",
            OAUTH_REST_RESOURCE_URL: AJS.contextPath() + "/rest/applinks-oauth/",
            OAUTH_BASE_URL: AJS.contextPath() + "/rest/applinks-oauth/1.0",

            /**
             * Update the API version and associated urls.
             * @param version
             */
            setApiVersion: function(version){
                AppLinks.SPI.API_VERSION = version;
                AppLinks.SPI.setBaseUrl(AppLinks.SPI.REST_RESOURCE_URL + AppLinks.SPI.API_VERSION);
            },
            setBaseUrl: function(url){
                AppLinks.SPI.BASE_URL = url;
            },
            setOAuthBaseUrl: function(url){
                AppLinks.SPI.OAUTH_BASE_URL = url;
            },
            /**
             * Build a base URL for rest calls using the specified baseUrl.
             * @param baseUrl
             * @returns {string}
             */
            getRemoteRestBaseUrl: function(baseUrl) {
                return baseUrl + "/rest/applinks/" + AppLinks.SPI.API_VERSION;
            },
            /**
             * Build a base URL for plugin servlet calls using the specified baseUrl.
             * @param baseUrl
             * @returns {string}
             */
            getRemotePluginServletBaseUrl: function(baseUrl) {
                return baseUrl + "/plugins/servlet";
            },
            getAllLinks: function(success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink";
                return AppLinks.get(url, success, failure);
            },
            getAllLinksWithAuthInfo: function(success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/listApplicationlinks";
                return AppLinks.get(url, success, failure);
            },
            getApplicationLinkState: function(id, success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/listApplicationlinkstates/id/" + id;
                return AppLinks.get(url, success, failure);
            },
            getLinksOfType: function(typeId, success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink/type/" + typeId;
                return AppLinks.get(url, success, failure);
            },
            tryToFetchManifest: function(url, success, failure) {
                var restUrl = AppLinks.SPI.BASE_URL + '/applicationlinkForm/manifest.json?url=' + encodeURIComponent(url);
                return AppLinks.get(restUrl, success, failure);
            },
            getManifestFor: function(id, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/manifest/' + id + ".json";
                return AppLinks.get(url, success, failure);
            },
            getLocalManifest: function(success, failure){
                var url = AppLinks.SPI.BASE_URL + '/manifest.json';
                return AppLinks.get(url, success, failure);
            },
            /**
             * Attempt to get the Manifest of the remote application, via a direct REST call.
             * Requires CORS enabled on the REST resource.
             * @param url
             * @param success
             * @param failure
             * @returns {*}
             */
            getRemoteManifest: function(remoteBaseUrl, success, failure){
                var remoteManifestUrl = AppLinks.SPI.getRemoteRestBaseUrl(remoteBaseUrl) + '/manifest.json';
                return AppLinks.get(remoteManifestUrl, success, failure);
            },
            /**
             * Attempt to get the OAuth Consumer Info of the remote application, via a direct call.
             * Requires CORS enabled on the REST resource.
             * @param url
             * @param success
             * @param failure
             * @returns {*}
             */
            getRemoteOAuthConsumerInfo: function(remoteBaseUrl, success, failure){
                var remoteManifestUrl = AppLinks.SPI.getRemotePluginServletBaseUrl(remoteBaseUrl) + '/oauth/consumer-info';
                return AppLinks.getXml(remoteManifestUrl, success, failure);
            },
            getApplinkStatus: function (applinkId, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/status/' + applinkId;
                return AppLinks.get(url, success, failure);
            },
            createStaticUrlAppLink: function(applicationType, success, failure) {
                var restUrl = AppLinks.SPI.BASE_URL + '/applicationlinkForm/createStaticUrlAppLink?typeId=' + applicationType;
                return AppLinks.post(restUrl, null, success, failure);
            },
            createLink: function(applicationLink, username, password, createTwoWayLink, customRpcUrl, rpcUrl, configFormValues, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlinkForm/createAppLink';
                var data = {
                    applicationLink: applicationLink,
                    username: username,
                    password: password,
                    createTwoWayLink: createTwoWayLink,
                    customRpcURL: customRpcUrl,
                    rpcUrl: rpcUrl,
                    configFormValues: configFormValues
                };
                return AppLinks.post(url, data, success, failure);
            },
            createLinkWithOrphanedTrust : function(applicationLink, username, password, createTwoWayLink, customRpcUrl, rpcUrl, configFormValues, orphanedTrust, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlinkForm/createAppLink';
                var data = {
                    applicationLink: applicationLink,
                    username: username,
                    password: password,
                    createTwoWayLink: createTwoWayLink,
                    customRpcURL: customRpcUrl,
                    rpcUrl: rpcUrl,
                    configFormValues: configFormValues,
                    orphanedTrust: orphanedTrust
                };
                return AppLinks.post(url, data, success, failure);
            },
            verifyTwoWayLinkDetails : function (remoteUrl, rpcUrl, username, password, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlinkForm/details';
                var data = {
                    username: username,
                    password: password,
                    remoteUrl: remoteUrl,
                    rpcUrl: rpcUrl
                };
                return AppLinks.post(url, data, success, failure);
            },
            getApplicationLinkInfo: function (appId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlinkInfo/id/" + appId;
                return AppLinks.get(url, success, error);
            },
            deleteLink: function(applicationLink, reciprocate, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink/" + applicationLink.id;
                if (reciprocate) url += "?reciprocate=true";
                return AppLinks.del(url, success, error);
            },
            makePrimary: function(applicationLink, success) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink/primary/" + applicationLink.id;
                return AppLinks.post(url, null, success);
            },
            relocate: function(applicationLink, newUrl, suppressWarnings, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/relocateApplicationlink/" + applicationLink.id + "?newUrl=" + encodeURIComponent(newUrl) +
                        "&nowarning=" + (suppressWarnings ? "true" : "false");
                return AppLinks.post(url, null, success, error);
            },
            legacyUpgrade: function(applicationLink, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/upgrade/legacy/" + applicationLink.id;
                return AppLinks.post(url, null, success, error);
            },
            ualUpgrade: function(applicationLink, body, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/upgrade/ual/" + applicationLink.id;
                return AppLinks.post(url, body, success, error);
            },
            getEntityTypesForApplicationType: function(applicationType, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/type/entity/" + applicationType;
                return AppLinks.get(url, success, error);
            },
            getLocalEntitiesWithLinksToApplication: function(applicationLinkId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/localEntitiesWithLinksTo/" + applicationLinkId + ".json";
                return AppLinks.get(url, success, error);
            },
            getEntityLinksForApplication: function(applicationLinkId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entities/" + applicationLinkId + ".json";
                AppLinks.get(url, success, error);
            },
            getEntityLinksForApplicationUsingAnonymousAccess: function(applicationLinkId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entities/anonymous/" + applicationLinkId + ".json";
                return AppLinks.get(url, success, error);
            },
            createNonUalEntityLink: function(localType, localKey, applicationId, remoteTypeId, remoteKey, name, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/" + localType + "/" + localKey + "?reciprocate=false";
                var data = {
                    applicationId: applicationId,
                    typeId: remoteTypeId,
                    key: remoteKey,
                    name: name,
                    isPrimary: false
                };
                return AppLinks.put(url, data, success, error);
            },
            createEntityLink: function(localType, localKey, entity, reciprocate, success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/" + localType + "/" + localKey + "?reciprocate=";
                url += (reciprocate ? "true" : "false");
                return AppLinks.put(url, entity, success, failure);
            },
            getConfiguredEntityLinks: function(localType, localKey, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/primaryLinks/" + localType + "/" + localKey + ".json";
                return AppLinks.get(url, success, error);
            },
            deleteEntityLink: function(localTypeId, localKey, entity, reciprocate, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/" + localTypeId + "/" + localKey + "?typeId=" + entity.typeId + "&key=" + entity.key + "&applicationId=" + entity.applicationId + "&reciprocate=" + reciprocate;
                return AppLinks.del(url, success, error);
            },
            makePrimaryEntityLink: function(localTypeID, localKey, entity, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/primary/" + localTypeID + "/" + localKey + "?typeId=" + entity.typeId + "&key=" + entity.key + "&applicationId=" + entity.applicationId;
                return AppLinks.post(url, null, success, error);
            },
            canDeleteAppLink: function(applicationId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/permission/reciprocate-application-delete/" + applicationId;
                return AppLinks.get(url, success, error);
            },
            canDeleteEntityLink: function(localTypeId, localKey, entity, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/permission/reciprocate-entity-delete/" + entity.applicationId + "/" + localTypeId + "/" + localKey + "/" + entity.typeId + "/" + entity.key;
                return AppLinks.get(url, success, error);
            },
            canCreateReciprocateEntityLink: function(applicationId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/permission/reciprocate-entity-create/" + applicationId;
                return AppLinks.get(url, success, error);
            },
            processPermissionCode: function(settings) {
                var config = {
                    noPermission: function() {},
                    missing: function() {},
                    credentialsRequired: function(authUrl) {},
                    authenticationFailed: function(authUrl) {},
                    noAuthentication: function(authUrl) {},
                    noAuthenticationConfigured: function() {},
                    noConnection: function() {},
                    allowed: function() {},
                    unrecognisedCode: function(code) {},
                    updateView: function(message, icon, button) {}
                };

                if (!settings) settings = {};

                settings = $.extend(config, settings);

                return function(data) {
                    var code = data.code;
                    if (code == "NO_PERMISSION") {
                        settings.noPermission();
                    } else if (code == "MISSING") {
                        settings.missing();
                    } else if (code == "CREDENTIALS_REQUIRED") {
                        settings.credentialsRequired(data.url);
                    } else if (code == "AUTHENTICATION_FAILED") {
                        settings.authenticationFailed(data.url);
                    } else if (code == "NO_AUTHENTICATION") {
                        settings.noAuthentication(data.url);
                    } else if (code == "NO_AUTHENTICATION_CONFIGURED") {
                        settings.noAuthenticationConfigured();
                    } else if (code == "NO_CONNECTION") {
                        settings.noConnection();
                    } else if (code == "ALLOWED") {
                        settings.allowed();
                    } else {
                        settings.unrecognisedCode(data.code);
                    }
                };
            },
            addAuthenticationTrigger: function(target, authUrl, callbacks) {
                if (!callbacks) {
                    callbacks = {};
                }

                if (typeof callbacks.onSuccess == "undefined") {
                    callbacks.onSuccess = function() {
                        location.reload();
                    }
                }

                if (typeof callbacks.onFailure == "undefined") {
                    callbacks.onFailure = function() {
                        return true;
                    }
                }
                //Unbind previous click listener, otherwise we might end up opening multiple windows.
                $(target).unbind('click');
                $(target).click(function() {
                    if (callbacks.before) {
                        callbacks.before();
                    }
                    AppLinks.authenticateRemoteCredentials(authUrl, callbacks.onSuccess, callbacks.onFailure);
                });
            },
            deleteOrphanedTrust: function(id, type, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/orphaned-trust/" + type + "/" + id;
                return AppLinks.del(url, success, error);
            },
            getOrphanedTrust: function(success, error) {
                var url = AppLinks.SPI.BASE_URL + "/orphaned-trust/";
                return AppLinks.get(url, success, error);
            },
            showCreateEntityLinkSuggestion: function() {
                return true;
            },
            getApplicationLink: function(id, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlink/' + id;
                return AppLinks.get(url, success, failure);
            },
            createApplicationLink: function(id, name, rpcUrl, displayUrl, typeId, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlink';
                var data = {
                    id: id,
                    name: name,
                    rpcUrl: rpcUrl,
                    displayUrl: displayUrl,
                    typeId: typeId
                };
                return AppLinks.put(url, data, success, failure);
            },
// TODO APLDEV-3 extract OAuth creation code into OAuth specific js files in the Oauth plugin.
            createConsumer: function(id, key, name, description, sharedSecret, publicKey, twoLOAllowed, executingTwoLOUser, twoLOImpersonationAllowed, outgoing, success, failure) {
                var url = AppLinks.SPI.OAUTH_BASE_URL + '/applicationlink/' + id + '/authentication/consumer';
                var data = {
                    key: key,
                    name: name,
                    description: description,
                    sharedSecret: sharedSecret,
                    publicKey: publicKey,
                    outgoing: outgoing,
                    twoLOAllowed: twoLOAllowed,
                    executingTwoLOUser: executingTwoLOUser,
                    twoLOImpersonationAllowed: twoLOImpersonationAllowed
                };
                return AppLinks.put(url, data, success, failure);
            },
            createConsumerAutoConfigure: function(id, twoLOAllowed, executingTwoLOUser, twoLOImpersonationAllowed, success, failure) {
                var url = AppLinks.SPI.OAUTH_BASE_URL + '/applicationlink/' + id + '/authentication/consumer?autoConfigure=true';
                var data = {
                    twoLOAllowed: twoLOAllowed,
                    executingTwoLOUser: executingTwoLOUser,
                    twoLOImpersonationAllowed: twoLOImpersonationAllowed
                };
                return AppLinks.put(url, data, success, failure);
            },
            registerProvider: function(id, provider, config, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlink/' + id + '/authentication/provider';
                var data = {
                    config : config,
                    provider : provider
                };
                return AppLinks.put(url, data, success, failure);
            },
            enableFeature: function(featureName, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/features/' + featureName;
                return AppLinks.put(url, {}, success, failure);
            },
            disableFeature: function(featureName, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/features/' + featureName;
                return AppLinks.del(url, success, failure);
            }
        }, (window.AppLinks && window.AppLinks.SPI) || {})
    });

    var i18nRootKey = 'applinks';

    AppLinks.UI = {
        showInfoBox: function(message) {
            $('.aui-message.success').remove();
            AppLinks.UI.createMessage('success', message, 'page-info');
        },
        hideInfoBox: function() {
            $('.aui-message.success').remove();
        },
        showErrorBox: function(message) {
            AppLinks.UI.createMessage('error', message, 'page-error');
        },
        hideErrorBox: function() {
            $('.aui-message.error').remove();
        },
        showWarningBox: function(messages) {
            if ($.isArray(messages) && messages.length > 0) {
                var ulEl = $("<ul></ul>");
                $(messages).each(function(index) {
                    ulEl.append($("<li/>", {
                        text: messages[index]
                    }));
                });
                var messageEl = $('<div class="page-warning"></div>').append(ulEl);
                AppLinks.UI.createMessage('warning', messageEl.html(), 'page-warning');
            } else {
                AppLinks.UI.createMessage('warning', messages, 'page-warning');
            }
        },
        hideWarningBox: function() {
            $('.aui-message.warning').remove();
        },
        shortenString: function(message, maxLength) {
            if (message.length  > maxLength) {
               message = message.substring(0, maxLength) + "...";
            }
            return message;
        },
        createMessage: function(type, message, cssClass) {
            var messageEl = $('<div class="' + cssClass + '">');
            messageEl.html(message);
            AJS.messages[type](".applinks-message-bar", {
                title: "",
                body: messageEl.wrap('<div></div>').parent().html(),
                closeable: true
            });
            $(document).trigger(AppLinks.Event.Legacy.MESSAGE_BOX_DISPLAYED);
        },
        displayValidationErrorMessages: function (errorClass, rootEl, messages) {
            if ($.isArray(messages)) {
                $(messages).each(function(i,v) {
                   var d = $('<div class="error applinks-error">');
                   d.text(v);
                   $(rootEl).find("." + errorClass).append(d);
                });
            } else if(typeof messages != 'undefined'){
                var d = $('<div class="error applinks-error">');
                d.text(messages.toString());
                $(rootEl).find("." + errorClass).append(d);
            }
        },
        displayValidationError: function(errorClass, rootEl, errorFn) {
            return function(xhr) {
                if (xhr.status == 401) {
                    window.location.reload();
                    return;
                }

                $('.applinks-error').remove();
                $('.loading').remove();
                var respJSON = xhr.responseText;
                var respObj = $.parseJSON(respJSON);
                var messages = respObj.message;
                if (typeof respObj.fields == "undefined") {
                    AppLinks.UI.displayValidationErrorMessages(errorClass, rootEl, messages);
                } else {
                    var fields = respObj.fields;
                    $(fields).each(function(index) {
                        var d = $('<div class="error applinks-error" id="' + fields[index] + '-error">');
                        d.text(messages[index]);
                        if ($(rootEl).find('.' + fields[index]).length > 0) {
                          d.insertAfter($(rootEl).find('.' + fields[index]));
                        } else {
                          d.insertAfter($(rootEl).find('.' + errorClass).append(d));
                        }
                    });
                }
                $(rootEl).find('.' + errorClass).addClass("fully-populated-errors");
                if (errorFn) {
                 errorFn();
                }
            }
        },
        addProtocolToURL : function(url) {
            var newUrl = $.trim(url);
            var tempURL = newUrl.toLowerCase();
            var hasProtocol = false;
            if (tempURL.length >= 7) {
                if (tempURL.substring(0,7).indexOf('http') != -1) {
                    hasProtocol = true;
                }
            }
            //default protocol is http
            if (!hasProtocol) {
                newUrl = 'http://' + newUrl;
            }
            return newUrl;
        },
        /**
         * Similar to the standard Javascript join() method, but nicer in that
         * it uses a different delimiter for the last node (by default "and"),
         * so that:
         * {code}
         * "1, 2 and 3" == prettyJoin(['1', '2', '3'], function(value) {return value;});
         * {code}
         *
         * @param inputArray
         * @param resolveFn
         * @param finalDelimiter
         */
        prettyJoin : function(inputArray, resolveFn, finalDelimiter) {
            if (!finalDelimiter) {
                finalDelimiter = AppLinks.I18n.getText('applinks.and');
            }
            var maxLength = inputArray.length;
            var message = "";
            $.each(inputArray, function(index, value) {
                if (index == (maxLength - 1) && maxLength > 1) {
                  message += " " + finalDelimiter + "  " + resolveFn(value);
                } else {
                  message += resolveFn(value);
                  if (index + 2 < maxLength) {
                      message += ", ";
                  }
                }
            });
            return message;
        },
        showLoadingIcon: function(element) {
            $('<span class="loading">&nbsp;</span>').insertAfter(element);
        },
        hideLoadingIcon: function(element) {
            $(element).next('.loading').remove();
        },
        findUrl: function(text) {
            var url = undefined;
            var lcText = text.toLowerCase();
            var startOfUrl = lcText.indexOf('http:');
            if (startOfUrl == -1) {
                startOfUrl = lcText.indexOf('https:');
            }
            if (startOfUrl > -1) {
                var endOfUrl = lcText.indexOf(' ', startOfUrl);
                if (endOfUrl == -1) {
                    endOfUrl = lcText.length;
                }
                url = text.substring(startOfUrl, endOfUrl); // use _case-sensitive_ version to retrieve the actual URL
            }
            return url;
        },
        findApplicationType : function(id) {
            id = id.toLowerCase();
            if (id.indexOf("jira") != -1) {
                return "jira";
            } else if (id.indexOf("fisheye") != -1) {
                return "fecru";
            } else if (id.indexOf("confluence") != -1) {
                return "confluence";
            } else if (id.indexOf("refapp") != -1) {
                return "refapp";
            } else {
                return undefined;
            }
        },
        escapeSelector: function(selector) {
            // based on http://samuelsjoberg.com/archive/2009/09/escape-jquery-selectors
            return selector.replace(/([#;&,\.\+\*\~':"\!\^$\[\]\(\)=>\|])/g, "\\$1");
        },
        sanitiseHTML: function(input) {
            var replacements = {
                "<": "&lt;",
                '"': "&quot;",
                "&": "&amp;"
            };
            return input.replace(/[<"&]/g, function(match) {
                return replacements[match];
            });
        },
        refreshOrphanedTrust: function() {
            // post dialog -- check whether we need to remove any orphaned-trust entries
            var updateOrphanedTrust = function(data) {
                $("tr.orphaned-trust-row").each(function() {
                    var $this = $(this);
                    var id = $this.attr("data-id");
                    var type = $this.attr("data-type");
                    var stillExists = false;
                    for (var i = 0; i < data.orphanedTrust.length; i++) {
                        var ot = data.orphanedTrust[i];
                        if (id == ot.id && type == ot.type) {
                            stillExists = true;
                            break;
                        }
                    }
                    if (!stillExists) {
                        $this.remove();
                        if (data.orphanedTrust.length == 0) {
                            // we just removed the last orphaned trust cert, hide warning!
                            $(".orphaned-trust-warning").hide();
                        }
                    }
                });
            };

            AppLinks.SPI.getOrphanedTrust(updateOrphanedTrust);
        },
        removeCssClass: function(element, prefix) {
            $(element).removeClass( function(index, className) {
                   var classes = className.split(' ');
                   var classToRemove = "";
                   $.each(classes, function(index, value) {
                       if (value.indexOf(prefix) != -1) {
                           classToRemove = value;
                       }
                   });
                   return classToRemove;
            } );
        }
    };

    /**
     * Add jQuery event system to AppLinks.UI namespace.
     */
    (function(){
        var eventBus = $({});
        $.each(['bind', 'unbind', 'trigger'], function(i, current){
            AppLinks.UI[current] = function(){
                return eventBus[current].apply(eventBus, arguments);
            }
        });
    })();

    AppLinks.I18n = {
        // very simple i18n param interpolation, doesn't attempt to respect escaping
        //Deferrs to AJS.format for for legacy reason the array conversion needs to stick around.
        interpolate: function(text, params) {
            if (params) {
                if (!$.isArray(params)) {
                    // single arg
                    params = [new String(params)];
                }
                params.unshift(text);
                text = AJS.format.apply(AJS, params);
            }
            return text;
        },
        getTextWithPrefix: function(key, params) {
            return AppLinks.I18n.interpolate(appLinksI18n.entries[i18nRootKey + "." + key], params);
        },
        getText: function(key, params) {
            return AppLinks.I18n.interpolate(AppLinks.I18n.resolveValue(key), params);
        },
        getApplicationTypeName: function(typeId) {
            return appLinksI18n.entries["applinks.application.type." + typeId];
        },
        getEntityTypeName: function(typeId) {
            return appLinksI18n.entries["applinks.entity.type." + typeId];
        },
        getPluralizedEntityTypeName: function(typeId) {
            return appLinksI18n.entries["applinks.entity.type.plural." + typeId];
        },
        getAuthenticationTypeName: function(type) {
            return appLinksI18n.entries["applinks.auth.provider." + type];
        },
        resolveValue: function(key) {
            var value = appLinksI18n.entries[key];
            return typeof value == "undefined" ? key : value;
        }
    };

    var ApplinksHelpPaths = require('applinks/common/help-paths');
    AppLinks.Docs = {

        /**
         * NOTE: this is a dynamically generated version of the link build in _help_link.vm, any update here should be
         * applied there.
         * @method createDocLink
         * @param pageKey a key that maps to a page in ual-help-paths.properties
         * @param sectionKey (Optional) a key that maps to an anchor section id in ual-help-paths.properties
         * @return an html &lt;a&gt; element targeting the specified page & section
         * @deprecated use
         */
        createDocLink: function(pageKey, sectionKey, css) {
            if (!css) {
                css = "";
            } else {
                css = " " + css;
            }
            return $("<a/>", {
                "class": "ual-help-link help-link" + css,
                href: AppLinks.Docs.getDocHref(pageKey, sectionKey),
                target: "_blank",
                "data-help-link-key": pageKey,
                text: AppLinks.I18n.getText("applinks.help"),
                title: AppLinks.I18n.getText("applinks.help")
            });
        },
        /**
         * @method getDocHref
         * @param pageKey a key that maps to a page in ual-help-paths.properties
         * @param sectionKey (Optional) a key that maps to an anchor section id in ual-help-paths.properties
         * @return the url of the given page and section (if specified)
         */
        getDocHref: function(pageKey, sectionKey) {
            var link = ApplinksHelpPaths.getFullPath(pageKey);
            if (sectionKey) {
                link += '#' + ApplinksHelpPaths.getPath(pageKey);
            }
            return link;
        }
    };

    $(document).trigger(AppLinks.Event.PREREADY);
    $(document).trigger(AppLinks.Event.READY);
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/component/autocomplete.js' */
AJS.$(document).bind(AppLinks.Event.READY, function() {
/**
 * TODO: THIS CODE IS COPIED FROM CONFLUENCE and should be part of AUI/AJS.
 * IF AUI comes with the InputDrivenDropDown when can remove this file.
 * https://studio.atlassian.com/browse/AJS-471
 *
 * A simple cache manager that supports a
 * FIFO cache invalidation strategy.
 *
 * @class cacheManager
 * @namespace AJS.Confluence
 * @constructor
 * @param cacheSize the size of the cache before keys are invalidated
 */
AppLinks.autoComplete = {
        cacheManager : function (cacheSize) {
    var cache = {},
        cacheStack = [],
        cacheSize = cacheSize || 30;

    return {
        /**
         * Return the value stored in the cache for the given key
         * @method get
         * @param key {String}
         */
        get: function(key) {
            return cache[key];
        },
        /**
         * Put the given key, value in the cache
         * @method put
         * @param key {String}
         * @param value {Object}
         */
        put: function(key, value) {
            cache[key] = value;
            cacheStack.push(key);
            if (cacheStack.length > cacheSize) {
                delete cache[cacheStack.shift()];
            }
        },
        /**
         * Clear the cache.
         */
        clear : function() {
            cache = {};
            cacheStack = [];
        }
    };
}};


(function($){
    /**
     * Check that all items in the drop down can be displayed - show ellipses at the end of any that
     * are too long. Also remove any unused properties that the dropDown may have stored for each
     * item in the list.
     *
     * @method truncateText
     * @private
     */
    var truncateText = function (dd) {
        AJS.log("InputDrivenDropDown: truncating text");
        var width = dd.$.closest(".aui-dropdown").width(),
            rightPadding = 20; // add some padding so the ellipsis doesn't run over the edge of the box

        $("a span:not(.icon)", dd.$).each(function () {
            var $a = $(this),
                elpss = AJS("var", "&#8230;"),
                elwidth = elpss.width(),
                isLong = false;

            $a.wrapInner($("<em>"));
            $("em", $a).each(function () {
                var $label = $(this);

                $label.show();
                if (this.offsetLeft + this.offsetWidth > width) {
                    var childNodes = this.childNodes,
                        success = false;

                    for (var j = childNodes.length - 1; j >= 0; j--) {
                        var childNode = childNodes[j],
                            truncatedChars = 1,
                            valueAttr = (childNode.nodeType == 3) ? "nodeValue" : "innerHTML",
                            nodeText = childNode[valueAttr];

                        do {
                            if (truncatedChars <= nodeText.length) {
                                childNode[valueAttr] = nodeText.substr(0, nodeText.length - truncatedChars++);
                            } else { // if we cannot fit even one character of the next word, then try truncating the node just previous to this
                                break;
                            }
                        } while (this.offsetLeft + this.offsetWidth + elwidth > width - rightPadding);

                        if (truncatedChars <= nodeText.length) {
                            // we've managed truncate part of the word and fit it in
                            success = true;
                            break;
                        }
                    }

                    if (success) {
                        isLong = true;
                    } else {
                        $label.hide();
                    }
                }
            });
            if (isLong) {
                $a.append(elpss);
                this.elpss = elpss;
            }
        });
    };

    var highlightTokens = function(dd, tokens) {
        if (!tokens.length || !tokens[0]) return;

        AJS.log("InputDrivenDropDown: highlighting tokens");

        // escape regex chars .*+?|()[]{}\ first
        for (var i = 0, ii = tokens.length; i < ii; i++) {
            var token = tokens[i];
            tokens[i] = token ? token.replace(/[\.\*\+\?\|\(\)\[\]{}\\]/g, "\\$") : "";
        }

        var regex = new RegExp("(" + tokens.join("|") + ")", "gi");

        $("li a:not(.dropdown-prevent-highlight) span", dd.$).each(function() {
            var span = $(this),
                html = span.html().replace(regex, "<strong>$1</strong>");
            span.html(html);
        });
    };

    /**
     * Builds and shows the dropdown.
     *
     * @param idd the InputDrivenDropdown
     * @param dropdownData in the form { matrix, query, queryTokens }
     * @private
     */
    var makeDropdown = function (idd, dropdownData) {
        var options = idd.options,
            old_dd = idd.dd;

        if (old_dd) {
            old_dd.hide();
            old_dd.$.remove();
        }

        options.ajsDropDownOptions = options.ajsDropDownOptions || {};
        if (options.ajsDropDownOptions && !options.ajsDropDownOptions.alignment) { // default to left alignment
            options.ajsDropDownOptions.alignment = "left";
        }
        //this needs to be moved into aui
        options.ajsDropDownOptions.selectionHandler = options.ajsDropDownOptions.selectionHandler || function(e, element) {
            if(e.type != "click") {
                e.preventDefault();
                $("a",element).click();
                document.location = $("a",element).attr("href");
            }
        };

        /* Fixing an AUI bug in here:  AJS.dropdown puts the raw 'matrix[i].name' as html, without escaping it !
           The solution is to override their displayHandler
         */
        /**
         * Escape obj.name and return it
         */
        options.ajsDropDownOptions.displayHandler = function (obj) {
            return AJS.escapeHtml(obj.name);
        }

        var dd = idd.dd = new AJS.dropDown(dropdownData.matrix, options.ajsDropDownOptions)[0];

        // could move into dropdown.js in AUI
        if (options.ajsDropDownOptions && options.ajsDropDownOptions.className) {
            dd.$.addClass(options.ajsDropDownOptions.className);
        }

        // place the created drop down using the configured dropdownPlacement function
        // if there is none then use a default behaviour
        if (options.dropdownPlacement) {
            options.dropdownPlacement(dd.$);
        } else {
            AJS.log("No dropdownPlacement function specified. Appending dropdown to the body.");
            $("body").append(dd.$);
        }

        highlightTokens(dd, dropdownData.queryTokens || [dropdownData.query]);
        truncateText(dd);

        if (options.dropdownPostprocess) {
            options.dropdownPostprocess(dd.$);
        }
        dd.show(idd._effect);

        if (typeof options.onShow == "function") {
            options.onShow.call(dd, dd.$);
        }

        return dd;
    };

    /**
     * Provides a controller-agnostic object that listens for controller changes and populates a dropdown
     * via a callback. Most aspects can be customized via the options object parameter.
     * <br>
     * Options are:
     * <li>
     *   getDataAndRunCallback - (required) callback method used to provide data for the dropdown. It must take
     *                          two parameters, user input value and the callback function to execute.
     * </li>
     * <li>
     *   onShow - function to call when the drop-down is displayed
     * </li>
     * <li>
     *   dropdownPlacement - a function that will be called with the drop down and which should place it in the
     *                          correct place on the page. The supplied arguments are 1) the input that issued the
     *                          search, 2) the dropDown to be placed.
     * </li>
     * <li>
     *   ajsDropDownOptions - any options the underlying dropDown component can handle expects
     * </li>
     * <li>
     *   onDeath - callback to run when dropdown dies
     * </li>
     * @class InputDrivenDropDown
     * @namespace AJS
     */
    function InputDrivenDropDown(id, options) {
        this._effect = "appear";
        this._timer = null;

        this.id = id;
        this.options = options;
        this.inactive = false;
        this.busy = false;
        this.cacheManager = AppLinks.autoComplete.cacheManager();
    }

    /**
     * Clears the cache.
     */
    InputDrivenDropDown.prototype.clearCache = function () {
        this.cacheManager.clear();
    };

    /**
     * This method should be called when the user input for this dropdown has changed.
     * It will check the cache before fetching data (via options.getDataAndRunCallback)
     * and displaying the dropdown.
     *
     * @param value {String} the new value of the user input
     * @param force {Boolean} force a change to occur regardless of user input
     */
    InputDrivenDropDown.prototype.change = function (value, force) {
        var t = this;
        if (value != t._value || force) {
            t._value = value;
            t.busy = false;

            clearTimeout(t._timer);

            if (force || (/\S{0,}/).test(value)) {
                var cachedVal = t.cacheManager.get(value);
                if (cachedVal) {
                    makeDropdown(t, cachedVal);
                } else {
                    t.busy = true;
                    t._timer = setTimeout(function () { // delay sending a request to give the user a chance to finish typing their search term(s)
                        t.options.getDataAndRunCallback.call(t, value, t.show);
                    }, 200);
                }
            } else {
                t.dd && t.dd.hide();
            }
        }
    };

    /**
     * Gets the number of visible options in the dropdown.
     */
    InputDrivenDropDown.prototype.dropDownLength = function () {
        return this.dd.links ? this.dd.links.length : 0;
    };
    
    /**
     * Gets the specified menu item from the dropdown list.
     * 
     * @param index {Integer} the 0-based index of the dropdown option list
     */
    InputDrivenDropDown.prototype.dropDownItem = function (index) {
        return this.dropDownLength() > index ? this.dd.links[index] : null;
    };
    
    /**
     * Hides the drop down
     */
    InputDrivenDropDown.prototype.hide = function () {
        this.dd && this.dd.hide();
    };

    /**
     * Hides and removes the drop down from the DOM.
     */
    InputDrivenDropDown.prototype.remove = function () {
        var dd = this.dd;
        if (dd) {
            this.hide();
            dd.$.remove();
        }
        this.inactive = true;
        this.options.onDeath && this.options.onDeath();
    };

    /**
     * Shows the drop down with the given matrix data and query.
     * <br>
     * Matrix property should be an array of arrays, where the sub-arrays represent the different
     * search categories.
     *
     * Expected properties of category sub-array objects are:
     *  - href
     *  - name
     *  - className
     *  - html (optional, replaces href and name)
     *  - icon (optional)
     *
     *
     * @param matrix {Array} matrix to populate the drop down from
     * @param query {String} the user input string that triggered this show
     * @param queryTokens {Array} an array of strings of the query tokens. Use for highlighting search terms.
     */
    InputDrivenDropDown.prototype.show = function (matrix, query, queryTokens) {
        if (this.inactive) {
            AJS.log("Quick search abandoned before server response received, ignoring. " + this);
            return;
        }

        var dropdownData = {
            matrix: matrix,
            query: query,
            queryTokens: queryTokens
        };
        this.cacheManager.put(query, dropdownData);

        makeDropdown(this, dropdownData);
        this.busy = false;
    };

    /**
     * Returns an InputDrivenDropDown. See InputDrivenDropDown for more documentation.
     * @param options {Object} options for the InputDrivenDropDown
     * @constructor
     */
    AppLinks.inputDrivenDropdown = function (options) {
        return new InputDrivenDropDown("inputdriven-dropdown", options);
    };

})(jQuery);
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/component/wizard.js' */
AJS.$(document).bind(AppLinks.Event.PREREADY, function() {

    (function($) {

        $.fn.wizard = function(settings) {
            var config = {
                width: 500,
                height: 350,
                onshow: function(popup, configuration) {
                    return true;
                },
                aftershow: function() {
                    return true;
                },
                oncancel: function() {
                    return true;
                },
                onsubmit: function() {
                    return true;
                },
                aftersubmit: function() {
                    return true;
                },
                onnext: function() {
                    return true;
                },
                onprevious: function() {
                    return true;
                },
                cancelLabel: AppLinks.I18n.getText("applinks.cancel"),
                submitLabel: AppLinks.I18n.getText("applinks.create"),
                nextLabel: AppLinks.I18n.getText("applinks.next"),
                previousLabel: AppLinks.I18n.getText("applinks.previous"),
                id: ""
            };

            if (!settings) settings = {};

            settings = $.extend(config, settings);

            var result = this;

            this.each(function() {
                var obj = $(this);
                var popup = new AJS.Dialog(settings.width, settings.height, settings.id);
                var showFn = show(popup, settings.onshow, settings.aftershow);
                var cancelFn = cancel(popup, settings.oncancel);
                var submitFn = submit(popup, settings.onsubmit, settings.aftersubmit);
                var previousFn = previous(popup, settings.onprevious)
                var nextFn = next(popup, settings.onnext);

                var disableNextFn = disableNext(popup);
                var enableNextFn  = enableNext(popup);

                var disableSubmitFn = disableSubmit(popup);
                var enableSubmitFn  = enableSubmit(popup);

                var disablePreviousFn = disablePrevious(popup);
                var enablePreviousFn  = enablePrevious(popup);

                if (settings.showButtonId) {
                    $('#' + settings.showButtonId).click(showFn);
                }

                var pages = findPages(obj);


                for (var pageIndex = 0; pageIndex < pages.length; pageIndex++) {
                    var page = pages[pageIndex];
                    createPage(popup, page);
                    if (page.className) {
                        popup.addHeader(page.title, page.className + "-header");
                    } else {
                        popup.addHeader(page.title);
                    }

                    if (pageIndex != 0 && $(page.div).attr("previous") != "false") {
                        popup.addButton(settings.previousLabel, previousFn, "applinks-previous-button");
                    }

                    if (pageIndex < pages.length - 1 && $(page.div).attr("submit") != "true" && $(page.div).attr("next") != "false") {
                        popup.addButton(settings.nextLabel, nextFn, "applinks-next-button");
                    }

                    if ($(page.div).attr("submit") == "true") {
                        popup.addButton(settings.submitLabel, submitFn, "wizard-submit");
                    }

                    if (!popup.getPage(pageIndex).buttonpanel) {
                        //THIS IS A DUMMY BUTTON, which gets remove afterwards
                        //THE DUMMY BUTTON will cause the cancel text link to appear on the correct position.
                        //IT IS A WORKAROUND so I don't have to change the dialog.js code
                        popup.addButton("", null);
                        $(popup.getPage(pageIndex).buttonpanel).empty();
                        var cancelLink = $('<button class="aui-button aui-button-link button-panel-button applinks-cancel-link">' + settings.cancelLabel + '</button>');
                        popup.getPage(pageIndex).buttonpanel.append(cancelLink);
                        cancelLink.click(cancelFn);
                    } else {
                        var cancelLink = $('<button class="aui-button aui-button-link button-panel-link button-panel-cancel-link applinks-cancel-link">' + settings.cancelLabel + '</button>');
                        $(popup.getPage(pageIndex).buttonpanel).append(cancelLink);
                        cancelLink.click(cancelFn);
                    }

                    if (pageIndex < pages.length - 1) {
                        popup.addPage();
                    }
                }

                result = {
                    dialog: popup,
                    nextPage: nextFn,
                    prevPage: previousFn,
                    submit: submitFn,
                    cancel: cancelFn,
                    show: showFn,
                    disableNextBtn     : disableNextFn,
                    enableNextBtn      : enableNextFn,
                    disableSubmitBtn   : disableSubmitFn,
                    enableSubmitBtn    : enableSubmitFn,
                    disablePreviousBtn : disablePreviousFn,
                    enablePreviousBtn  : enablePreviousFn
                };
                popup.gotoPage(0);
                popup.gotoPanel(0);
            });

            return result;
        };

        function disablePrevious(popup) {
            return function() {
                disable(getButton(popup, 'applinks-previous-button'));
            }
        }

        function enablePrevious(popup) {
            return function() {
                enable(getButton(popup, 'applinks-previous-button'));
            }
        }

        function disableNext(popup) {
            return function() {
                disable(getButton(popup, 'applinks-next-button'));
            }
        }

        function enableNext(popup) {
            return function() {
                enable(getButton(popup, 'applinks-next-button'));
            }
        }

        function disableSubmit(popup) {
            return function(showLoading) {
                var buttonEl = getButton(popup, 'wizard-submit');
                disable(buttonEl);
                if (typeof(showLoading) == 'undefined' || showLoading) {
                    $('<span class="loading">&nbsp;</span>').insertBefore(buttonEl);
                } else {
                    buttonEl.parent().find('.loading').remove();
                }
            }
        }

        function enableSubmit(popup) {
            return function() {
                var buttonEl = getButton(popup, 'wizard-submit');
                enable(buttonEl);
                buttonEl.parent().find('.loading').remove();
            }
        }

        function getButton(popup, cssClass) {
            return $(popup.getPage(popup.curpage).buttonpanel).find('.' + cssClass);
        }

        function resetForms(popup) {
             $(popup.popup.element).find('form').each( function() {
                  this.reset();
             });
        }

        function enable(element) {
            element.attr('disabled', false);
        }

        function disable(element) {
            element.attr('disabled', true);
        }
		
        function show(popup, onshow, aftershow) {
            return function(configuration) {
				if (onshow(popup, configuration) !== false) {
                    popup.gotoPage(0);
                    popup.gotoPanel(0);
                    $(document).unbind('keydown.ual.dialog');
                    $(document).bind('keydown.ual.dialog', attachKeypressListener(popup));
					popup.show();
                    aftershow();
                }
            }
        }

        function cancel(popup, oncancel) {
            return function() {
                if (oncancel(popup) !== false) {
                    popup.hide();
                    resetForms(popup);
                }
            }
        }

        function previous(popup, onprevious) {
            return function() {
                if (onprevious(popup) !== false) {
                    popup.prevPage();
                }
            }
        }

        function next(popup, onnext) {
            return function() {
                if (onnext(popup) !== false) {
                    popup.nextPage();
                }
            }
        }

        function attachKeypressListener(popup) {
            return function(e) {
                if (e.keyCode === 27) {
                    resetForms(popup);
                    $(document).unbind('keydown.ual.dialog');
                }
            }
        }

        function submit(popup, onSubmit, afterSubmit) {
            return function() {
                if (onSubmit(popup) !== false) {
                    afterSubmit(popup);
                    resetForms(popup);
                }
            }
        }

        function createPage(popup, page) {
            var panelDivs = $("> div[panel]", page.div);
            if (panelDivs.length > 0) {
                panelDivs.each(function(index, panelDiv) {
                    var popupPage = popup.addPanel(panelDiv.title, null, panelDiv.className, 'menu-' + panelDiv.id);
                    popupPage.getCurrentPanel().body.append(panelDivs[index]);
                });
            }
            else {
                var popupPage = popup.addPanel(page.title);
                popupPage.getCurrentPanel().body.append(page.div);
            }
        }


        function findPages(containerDiv) {
            var pagesDivs = $(" > div", containerDiv);
            var pages = [];
            pagesDivs.each(function(index) {
                var pageDiv = $(this);
                pages[index] = {
                    title: pageDiv.attr('title') || null,
                    className: pageDiv.attr('class'),
                    div: pageDiv
                };
            });
            return pages;
        }
    })(jQuery)
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/feature/applinks-wizard/applinkwizard.js' */
(function($) {
    AppLinks.Wizard = {
        getWizard: function(){
            return $("#create-application-link-container").data('wizard');
        },
        initAuthenticationUI: function(element) {
            var root = $(element);
            var createTwoWayLinkCheckbox = root.find('.create-reciprocal-link');
            var ualArrow = root.find('.ual-arrow');
            var linkDetails = root.find('.two-way-link-details');
            var linkDescription = root.find('.reciprocal-link-description');
            var noLinkDescription = root.find('.no-reciprocal-link-description');
            createTwoWayLinkCheckbox.click(function() {
                if (createTwoWayLinkCheckbox.is(':checked')) {
                    ualArrow.removeClass('no-background');
                    linkDetails.show();
                    linkDescription.show();
                    noLinkDescription.hide();
                } else {
                    ualArrow.addClass('no-background');
                    linkDetails.hide();
                    linkDescription.hide();
                    noLinkDescription.show();
                }
            });
            var sameUserBtn = root.find('.same-user-radio-btn');
            var differentUserBtn = root.find('.different-user-radio-btn');
            var differentUserBaseImage = root.find('.different-userbase-image');
            var sameUserBaseImage = root.find('.same-userbase-image');

            sameUserBtn.click(function() {
                differentUserBaseImage.addClass('different-userbase-image-grey');
                sameUserBaseImage.removeClass('same-userbase-image-grey');
            });

            differentUserBtn.click(function() {
                sameUserBaseImage.addClass('same-userbase-image-grey');
                differentUserBaseImage.removeClass('different-userbase-image-grey');
            });
        },

        initNonUALUI : function(element) {
            var root = $(element);
            var applicationTypesEl = root.find('.application-types');
            for (var i = 0; i < nonAppLinksApplicationTypes.length; i++) {
                $('<option value=\"' + nonAppLinksApplicationTypes[i].typeId + '\">' + nonAppLinksApplicationTypes[i].label + '</option>').appendTo(applicationTypesEl);
            }
        },
        fetchManifest : function(wizard, dialogRootEl, ualAppCallbackFn, nonUALAppCallbackFn) {
            var applicationURLEl = dialogRootEl.find('#application-url');
            if (applicationURLEl.val() == '') {
                var applicationTypeEl = dialogRootEl.find('#application-types');
                if (applicationTypeEl.val() == '') {
                    $('<div class="error applinks-error">' + AppLinks.I18n.getText('applinks.error.url.field.empty') + '</div>').insertAfter(applicationURLEl);
                    return false;
                }
                var success = function(data) {
                    wizard.enableSubmitBtn();
                    wizard.enablePreviousBtn();
                    wizard.cancel();
                    AppLinks.UI.listApplicationLinks(data.applicationLink.id, 'new', data);
                };
                AppLinks.SPI.createStaticUrlAppLink(applicationTypeEl.val(), success, null);
                return true;
            }
            var appUrl = AppLinks.UI.addProtocolToURL(applicationURLEl.val());

            AppLinks.UI.showLoadingIcon(applicationURLEl);
            var success = function(data) {
                var manifest = data;
                wizard.enableNextBtn();
                dialogRootEl.find('.loading').remove();
                dialogRootEl.find('.reciprocal-rpc-url').val($('#baseUrl').val());
                if (typeof data.typeId != "undefined") {
                    AppLinks.Wizard.handleUALManifest(manifest, dialogRootEl);
                    wizard.dialog.gotoPage(2);
                    dialogRootEl.find('.reciprocal-link-username').focus();
                    if (ualAppCallbackFn) {
                      ualAppCallbackFn(manifest);
                    }
                }
                else {
                    if (data.code == 'applinks.warning.redirected.host' && !applicationURLEl.data('hasWarnedAboutRedirection')) {
                        // The host requires a redirection. Stay on the same page, ask for a confirmation.
                        AppLinks.UI.displayValidationErrorMessages('manifest-validation-errors', dialogRootEl, data.warning);
                        applicationURLEl.data('hasWarnedAboutRedirection', 'true');
                        var unsetRedirectionWarning = function () {
                            $(applicationURLEl).removeData('hasWarnedAboutRedirection');
                            $(applicationURLEl).unbind('change', unsetRedirectionWarning);
                        };
                        applicationURLEl.bind('change', unsetRedirectionWarning);
                    }
                	else if (data.code == 'applinks.warning.unknown.host' && !applicationURLEl.data('forceWhenHostIsOffline')) {
                	    // The host doesn't ping. Stay on the same page, ask for a confirmation.
                	    AppLinks.UI.displayValidationErrorMessages('manifest-validation-errors', dialogRootEl, data.warning);
                	    applicationURLEl.data('forceWhenHostIsOffline', 'true');
                	    var unsetForceWhenHostIsOffline = function () {
                	        $(applicationURLEl).removeData('forceWhenHostIsOffline');
                	        $(applicationURLEl).unbind('change', unsetForceWhenHostIsOffline);
                	    };
                	    applicationURLEl.bind('change', unsetForceWhenHostIsOffline);
            		}
                	else {
                        if (manifest.code == 'applinks.warning.unknown.host' || manifest.code == "applinks.warning.redirected.host") {
                	        // The user has already been notified of this warning.
                	        delete manifest.warning;
                	        delete manifest.code;
                	    }
                	    AppLinks.Wizard.handleNonUALManifest(manifest, appUrl, dialogRootEl);
                        wizard.dialog.gotoPage(1);
                        dialogRootEl.find('.application-name').focus();
                        if (nonUALAppCallbackFn) {
                          nonUALAppCallbackFn(manifest);
                        }
                	}
                }
            };
            wizard.disableNextBtn();
            AppLinks.SPI.tryToFetchManifest(appUrl, success, AppLinks.UI.displayValidationError('manifest-validation-errors', dialogRootEl, function() {
                wizard.enableNextBtn();
            }));
            return appUrl;
        },
        handleUALManifest : function(manifest, element) {
            var root = $(element);
            root.find('.remote-app-image').removeClass( function(index, className) {
            var classes = className.split(' ');
            var classToRemove = "";
                $.each(classes, function(index, value) {
                    if (value.indexOf('application-type-image-') != -1) {
                        classToRemove = value;
                    }
                });
                return classToRemove;
            });
            root.find('.remote-app-image').addClass('application-type-image-' + manifest.typeId);
            root.find('.link-to-app-type').html(AppLinks.I18n.getText('applinks.create.title.link.to', AppLinks.I18n.getApplicationTypeName(manifest.typeId)));
            root.find('.remote-app-name').text(AppLinks.UI.shortenString(manifest.name, 20));
            root.find('.create-reciprocal-link').attr('checked', true);
            root.find('#reciprocal-link-back-to-server').html(AppLinks.I18n.getText('applinks.create.link.back.to.server', AJS.escapeHtml(manifest.name)));
            // For the two way link text, we need to specify different roles for the credentials depending on the remote app
            // For JIRA and Confluence version < 3.10, it is system administrator
            // For everything else, it is administrator
            var twoWayLinkParams = ["administrator", AJS.escapeHtml(manifest.name),
                             '<a target="_blank" href="' + AppLinks.Docs.getDocHref("applinks.docs.adding.application.link") + '">', '</a>'];
            if(manifest.applinksVersion != undefined) {
                var remoteVersion = manifest.applinksVersion.split(".");
                var majorVersion = parseInt(remoteVersion[0]);
                var minorVersion = parseInt(remoteVersion[1]);
                // we don't have to check for versions < 3 since those won't have the manifest.
                if ((manifest.typeId == "jira" || manifest.typeId == "confluence") && (majorVersion == 3 && minorVersion < 10)) {
                    twoWayLinkParams[0] = "system administrator";
                }
            }
            root.find('.reciprocal-link-description').html(AppLinks.I18n.getText('applinks.create.two.way.link', twoWayLinkParams));
            root.find('.no-reciprocal-link-description').hide();
            root.find('.no-reciprocal-link-description').html(AppLinks.I18n.getText('applinks.create.two.way.no.link', AJS.escapeHtml(manifest.name)));
            root.find('.reciprocal-link-username').val('');
            root.find('.reciprocal-link-password').val('');
            root.find('.ual-arrow').removeClass('no-background');
            root.find('.two-way-link-details').show();
            root.find('.reciprocal-link-description').show();
            root.find('.no-reciprocal-link-description').hide();
        },
        handleNonUALManifest : function(data, appUrl, element) {
            var root = $(element);
            root.find('.application-name').val('');
            root.find(".application-types option:first-child").attr("selected", "selected");
            root.find('.non-ual-application-url').text(appUrl);
            if (data.warning) {
                root.find('.create-non-ual-warning').show();
                root.find('.create-non-ual-warning').html(data.warning);
            } else {
                root.find('.create-non-ual-warning').hide();
            }
        },
        checkReciprocalLinkFormThreeStepMode : function(element, handleOneWayLinkFn, handleTwoWayLinkDetailsSuccess, appUrl, errorFn) {
            var root = $(element);
            if (root.find('.create-reciprocal-link').is(':checked')) {
                var reciprocalRPCURL = $.trim(root.find('.reciprocal-rpc-url').val());
                if (reciprocalRPCURL == '') {
                    $("<div class='error applinks-error'>" + AppLinks.I18n.getText('applinks.error.url.field.empty') + "</div>").insertAfter(root.find('.reciprocal-rpc-url'))
                    if (errorFn) {
                        errorFn();
                    }
                    return;
                }
                var reciprocalLinkUsername = root.find('.reciprocal-link-username');
                var reciprocalLinkPwd = root.find('.reciprocal-link-password');
                if (reciprocalLinkUsername.val() == '') {
                    $('<div class="error applinks-error">'+ AppLinks.I18n.getText('applinks.error.username.empty') +'</div>').insertAfter(reciprocalLinkUsername);
                    if (errorFn) {
                        errorFn();
                    }
                    return false;
                }

                //verify user has admin rights.
                var successFn = function(data) {
                    root.find('.same-user-description').find('input').attr('checked', true);
                    root.find(".trust-radio-btn").attr('checked', true);
                    root.find('.same-user-radio-btn').click();
                    handleTwoWayLinkDetailsSuccess(data);
                };
                reciprocalRPCURL = AppLinks.UI.addProtocolToURL(reciprocalRPCURL);
                AppLinks.SPI.verifyTwoWayLinkDetails(appUrl, reciprocalRPCURL, reciprocalLinkUsername.val(), reciprocalLinkPwd.val(), successFn, AppLinks.UI.displayValidationError('two-way-link-errors', element, errorFn));
                return false;
            } else {
                handleOneWayLinkFn();
                return false;
            }
        },
        checkReciprocalLinkFormTwoStepMode : function(element, appUrl, successFn, errorFn) {
            var root = $(element);
            var reciprocalRPCURL = $.trim(root.find('.reciprocal-rpc-url').val());
            if (reciprocalRPCURL == '') {
                $("<div class='error applinks-error'>" + AppLinks.I18n.getText('applinks.error.url.field.empty') + "</div>").insertAfter(root.find('.reciprocal-rpc-url'))
                if (errorFn) {
                    errorFn();
                }
                return;
            }
            var reciprocalLinkUsername = root.find('.reciprocal-link-username');
            var reciprocalLinkPwd = root.find('.reciprocal-link-password');
            if (reciprocalLinkUsername.val() == '') {
                $('<div class="error applinks-error">'+ AppLinks.I18n.getText('applinks.error.username.empty') +'</div>').insertAfter(reciprocalLinkUsername);
                if (errorFn) {
                    errorFn();
                }
                return false;
            }

            reciprocalRPCURL = AppLinks.UI.addProtocolToURL(reciprocalRPCURL);
            AppLinks.SPI.verifyTwoWayLinkDetails(appUrl, reciprocalRPCURL, reciprocalLinkUsername.val(), reciprocalLinkPwd.val(), successFn, AppLinks.UI.displayValidationError('two-way-link-errors', element, errorFn));
            return false;
        }
    }
})(AJS.$);
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/common/urls.js' */
define('applinks/common/urls', [
    'applinks/lib/aui',
    'applinks/lib/lodash',
    'applinks/common/products'
], function(
    AJS,
    _,
    Products
) {
    /**
     * Utility functions for generating URLs in JS, including a link to applinks admin screen.
     */
    var ApplinksUrls = {

        /**
         * Generate a URL from the base and parameters.
         * @param baseUrl the baseUrl
         * @param parametersMap a map of parameters to add, in the form of { parameterName :  parameterValue }
         * @return {String}
         */
        generateUrl: function(baseUrl, parametersMap) {
            var redirectUrl = baseUrl;

            if(_.isUndefined(parametersMap)) {
                return redirectUrl;
            } else {
                _.each(parametersMap, function(value, key) {
                    if(redirectUrl.indexOf('?') < 0) {
                        redirectUrl = redirectUrl + '?';
                    } else {
                        redirectUrl = redirectUrl + '&';
                    }
                    redirectUrl = redirectUrl + key + "=" + encodeURIComponent(JSON.stringify(value))
                });

                return redirectUrl;
            }
        }
    };

    ApplinksUrls.Local = {

        admin: function(params) {
            var url = AJS.contextPath() + "/plugins/servlet/applinks/listApplicationLinks";
            return ApplinksUrls.generateUrl(url, params);
        }
    };

    ApplinksUrls.Remote = {

        /**
         * Generate a URL to remote Applinks Admin screen. For compatibility it needs to accept `applicationTypeId`.
         *
         * @param remoteBaseUrl
         * @param applicationTypeId
         * @param params extra URL params
         * @returns {String}
         */
        admin: function(remoteBaseUrl, applicationTypeId, params) {
            var suffix = applicationTypeId === Products.CONFLUENCE ?
                '/admin/listapplicationlinks.action' :
                '/plugins/servlet/applinks/listApplicationLinks';
            var url = remoteBaseUrl + suffix;

            return ApplinksUrls.generateUrl(url, params);
        }
    };

    return ApplinksUrls;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'js/help-link-analytics.js' */
(function ($) {
    $(function () {
        AJS.$('body').on('click', '.help-link', function () {
            AJS.trigger('analyticsEvent', {
                name: 'applinks.view.documentation',
                data: {linkKey: $(this).attr('data-help-link-key')}
            });
        });
    })
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-applinks-common-plugin:issue-link-applinks', location = 'js/issuelink-applinks.js' */
/**
 * Initialises anything requiring OAuth authentication. Requires the following elements:
 * <div class="issue-link-applinks-authentication-message"></div>
 */
var IssueLinkAppLinks = IssueLinkAppLinks || (function($) {
    function createHelper(servers, context, settings) {
        var helper = {};
        var selectedServer = null;

        function selectServer(appId) {
            selectedServer = getServer(servers, appId);

            var authenticationRequired = selectedServer && selectedServer.requireCredentials;
            doAuthenticationRequired(authenticationRequired, context);

            return {"authenticationRequired": authenticationRequired};
        }

        function setAuthenticationRequired(appId, authenticationRequired) {
            var server = getServer(servers, appId);
            if (server) {
                server.requireCredentials = authenticationRequired;

                // Refresh the authenication message if we have updated the selected server
                if (selectedServer && selectedServer.id === appId) {
                    doAuthenticationRequired(authenticationRequired, context);
                }
            }
        }

        function doAuthenticationRequired(required, context) {
            $(".issue-link-applinks-authentication-message", context).empty();
            if (required) {
                createAuthRequiredBanner($(".issue-link-applinks-authentication-message", context), context);
                $(".issue-link-oauth-toggle").hide();
                $(".buttons-container input[type=submit]", context).attr("disabled", "disabled");
            } else {
                $(".issue-link-oauth-toggle").show();
                $(".buttons-container input[type=submit]", context).removeAttr("disabled");
            }
        }

        function createAuthRequiredBanner($container, context) {
            var oauthCallbacks = {
                onSuccess: function () {
                    selectedServer.requireCredentials = false;
                    doAuthenticationRequired(false, context);
                    if (settings.onAuthenticationSuccessCallback) {
                        settings.onAuthenticationSuccessCallback(context, selectedServer.id, helper);
                    }
                },
                onFailure: function () {
                    if (settings.onAuthenticationFailedCallback) {
                        settings.onAuthenticationFailedCallback(context, selectedServer.id, helper);
                    }
                }
            };

            var encodedServerName = AJS.escapeHtml(selectedServer.name);
            if (selectedServer.authUrl) {
                var $banner = $('<div class="aui-message warning closeable shadowed applinks-auth-request"><p><span class="aui-icon icon-applinks-key"></span></p></div>');
                $banner.append(AJS.format("Authorization required to create issue link. Please \u003ca href=\"{0}\" class=\"applink-authenticate\"\u003eauthenticate\u003c/a\u003e with \u003ca href=\"{1}\"\u003e{2}\u003c/a\u003e.", selectedServer.authUrl, selectedServer.url, encodedServerName));
                $("a", $banner).addClass("applink-authenticate");
                $('.applink-authenticate', $banner).click(function (e) {
                    authenticateRemoteCredentials(selectedServer.authUrl, oauthCallbacks.onSuccess, oauthCallbacks.onFailure);
                    e.preventDefault();
                });
                $container.append($banner);
            } else {
                var warningMessage = AJS.format("Unable to create a link to \u003ca href=\"{0}\"\u003e{1}\u003c/a\u003e as the application does not have any authentication configured.", selectedServer.url, encodedServerName);
                AJS.messages.warning($container, {body: warningMessage});
            }
        }

        function createOAuthCallback() {
            if (!AppLinks.OAuthCallback && typeof(oauthCallback) === "undefined") {
                AppLinks.OAuthCallback = function() {

                };

                AppLinks.OAuthCallback.prototype.success = function() {
                    this.aouthWindow.close();
                    this.onSuccess();
                    delete oauthCallback;
                    delete AppLinks.OAuthCallback;
                };

                AppLinks.OAuthCallback.prototype.failure = function() {
                    this.aouthWindow.close();
                    this.onFailure();
                    delete oauthCallback;
                    delete AppLinks.OAuthCallback;
                };

                AppLinks.OAuthCallback.prototype.show = function(url, onSuccess, onFailure) {
                    this.onSuccess = onSuccess;
                    this.onFailure = onFailure;
                    this.aouthWindow = window.open(url, "com_atlassian_applinks_authentication");
                };
                // set the global oAuthCallback variable required by AppLinks
                oauthCallback = new AppLinks.OAuthCallback();
            }
        }

        function authenticateRemoteCredentials(url, onSuccess, onFailure) {
            createOAuthCallback();

            $('.applinks-error').remove();
            oauthCallback.show(url, onSuccess, onFailure);
        }

        return $.extend(helper, {
            selectServer: selectServer,
            setAuthenticationRequired: setAuthenticationRequired
        });
    }

    function getServer(servers, appId) {
        var i;
        if (servers.length) {
            for (i = 0; i < servers.length; i++) {
                if (servers[i].id === appId) {
                    return servers[i];
                }
            }
        }
        return null;
    }

    /**
     * Called only once during the initialisation to retrieve the list of servers.
     *
     * @param context the context to perform the initialisation. This is either the inline dialog or the entire document
     *                body.
     */
    function initApplinkServers(settings, context, deferred) {
        var currentAppId = settings.getCurrentAppId(context);
        var applicationType = $(".issue-link-applinks-application-type", context).val();
        var issueId = settings.getIssueId(context);
        $.get(AJS.contextPath() + '/rest/issueLinkAppLink/1/appLink/info', { type: applicationType, issueIdOrKey: issueId }, function (servers) {
            var helper = createHelper(servers, context, settings);
            var currentRequiresCredentials;
            if (servers && servers.length) {
                var currentServer = getServer(servers, currentAppId);
                if (currentServer) {
                    currentRequiresCredentials = $(".issue-link-applinks-authentication-message", context).hasClass("required");
                    if (currentRequiresCredentials) {
                        currentServer.requireCredentials = true;
                    }
                    helper.selectServer(currentAppId);
                }
                deferred.resolve(context, helper);
            } else {
                deferred.reject(context);
            }
        });
    }

    /**
     * @return jQuery.Promise<String>
     */
    function init(settings, context) {
        var deferred = $.Deferred();

        var isIssueLinkAppLinkContent = $(".issue-link-applinks-authentication-message", context).length !== 0;
        if (isIssueLinkAppLinkContent && settings.shouldExecute(context)) {
            initApplinkServers(settings, context, deferred);
        }

        return deferred.promise();
    }

    return {
        init: init
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-remote-jira-js', location = 'js/issuelink-jira.js' */
/**
 * Initialises OAuth authentication for JIRA Application Links. Requires the following elements:
 * <div class="issue-link-applinks-authentication-message"></div>
 */
(function ($) {

    var settings = {
        getCurrentAppId: function (context) {
            return $("#jira-app-link", context).val();
        },
        shouldExecute: function (context) {
            return $("#jira-app-link", context).length !== 0;
        },
        getIssueId: function (context) {
            return $("input[name=id]", context).val();
        }
    };

    var updateIssuePicker = function($select, appId) {
        if ($select.length) {
            // Update the appId param
            $select.attr("data-ajax-options.data.app-id", appId);
            if (appId && appId !== "") {
                // Set the url for remote JIRA queries
                $select.attr("data-ajax-options.url", contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/picker");
            }
            else {
                // Set the url for local JIRA queries
                $select.attr("data-ajax-options.url", contextPath + "/rest/api/2/issue/picker");
            }

            $select.trigger("updateOptions");

            // Now that we have changed server, our current issue selection is no longer relevant
            $select.trigger("clearSelection");
        }
    };

    var updateCreateReciprocalCheckbox = function(appId, context) {
        var $reciprocalCheckbox = $("#create-reciprocal", context);
        if ($reciprocalCheckbox.length) {
            if (appId && appId !== "") {
                // Get default choice for creating a remote reciprocal link
                var defaultChoice = ($("#create-reciprocal-default", context).val() == "true");
                if (defaultChoice) {
                    $reciprocalCheckbox.attr("checked", "checked");
                } else {
                    $reciprocalCheckbox.removeAttr("checked");
                }
                $reciprocalCheckbox.removeAttr("disabled");
                $("#create-reciprocal-fieldset", context).removeClass("disabled");
            } else {
                // Set to checked for local links, as they always create a reciprocal link
                $reciprocalCheckbox.attr("checked", "checked");
                $reciprocalCheckbox.attr("disabled", "disabled");
                $("#create-reciprocal-fieldset", context).addClass("disabled");
            }
        }
    };

    JIRA.bind(JIRA.Events.NEW_PAGE_ADDED, function (e, context) {

        var $select = $("#jira-issue-keys", context);
        if ($select.length) {
            var appId = $("#jira-app-link", context).val();
            updateIssuePicker($select, appId);
            updateCreateReciprocalCheckbox(appId, context);
        }

        IssueLinkAppLinks.init(settings, context).done(function (context, helper) {
            $("#jira-app-link", context).change(function () {
                var appId = $(this).val();
                helper.selectServer(appId);
                updateIssuePicker($select, appId);
                updateCreateReciprocalCheckbox(appId, context);
            });
        });
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-jira-search-js', location = 'js/issuelink-jira-jqlautocomplete.js' */
/**
 * Instantiates jql autocomplete functionality on request instead of on page load.
 */
var IssueLinkJQLAutoComplete = IssueLinkJQLAutoComplete || (function($) {

    /**
     * Initializes an auto complete field
     */
    function initialize(options) {

        var fieldID = options.fieldID;
        var errorID = options.errorID;
        var autoCompleteUrl = options.autoCompleteUrl;
        var autoCompleteData = options.autoCompleteData;
        var formSubmitFunction = options.formSubmitFunction;

        var $field = $('#'+fieldID);
        var hasFocus = $field.length > 0 && $field[0] == document.activeElement;

        var jqlFieldNames = autoCompleteData.visibleFieldNames || [];
        var jqlFunctionNames = autoCompleteData.visibleFunctionNames || [];
        var jqlReservedWords = autoCompleteData.jqlReservedWords || [];

        var jqlAutoComplete = JIRA.JQLAutoComplete({
            fieldID: fieldID,
            parser: JIRA.JQLAutoComplete.MyParser(jqlReservedWords),
            queryDelay: .65,
            jqlFieldNames: jqlFieldNames,
            jqlFunctionNames: jqlFunctionNames,
            minQueryLength: 0,
            allowArrowCarousel: true,
            autoSelectFirst: false,
            errorID: errorID,
            autoCompleteUrl: autoCompleteUrl
        });

        $field.unbind("keypress", submitOnEnter);

        if (formSubmitFunction) {
            $field.keypress(function (e) {
                if (jqlAutoComplete.dropdownController === null || !jqlAutoComplete.dropdownController.displayed || jqlAutoComplete.selectedIndex < 0) {
                    if (e.keyCode === 13 && !e.ctrlKey && ! e.shiftKey)
                    {
                        formSubmitFunction();
                        return false;
                    }
                    else
                    {
                        return true;
                    }
                }
            });
        }

        jqlAutoComplete.buildResponseContainer();
        jqlAutoComplete.parse($field.text());
        jqlAutoComplete.updateColumnLineCount();

        $field.click(function(){
            jqlAutoComplete.dropdownController.hideDropdown();
        });

        if (hasFocus) {
            $field.select();
        }
    }

    return {
        initialize: initialize
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-jira-search-js', location = 'js/issuelink-jira-search.js' */
AJS.$(function ($) {
    var remoteJiraSearchDialog =  new JIRA.FormDialog({
        id: "remote-jira-search-dialog",
        trigger: "#link-jira-issue .remote-jira-search-trigger",
        widthClass: "large",
        content: function (render) {
            render(JIRA.Templates.RemoteJiraIssueSearch.dialog());
            initSearchDialog(this.$popup);
        },
        submitHandler: function(e, callback){
            e.preventDefault();
            $("#simple-search-panel-button").removeAttr("disabled");
            $("#advanced-search-panel-button").removeAttr("disabled");
            if($(e.target).attr("id") === "remote-jira-simple-search-form"){
                $("#simple-search-panel-button").click();
            } else {
                $("#advanced-search-panel-button").click();
            }
            callback();
        }
    });

    function initSearchDialog($dialog) {
        // Gather the JQL auto complete data
        var appId = $("#jira-app-link").val();
        var autoCompletePromise = getJqlAutoCompleteData(appId);

        // Bind the simple search button
        $("#simple-search-panel-button", $dialog).click(function () {
            $("#search-results-table", $dialog).empty();
            var searchText = $("#link-search-text", $dialog).val();
            searchText = $.trim(searchText);
            if (searchText) {
                doSimpleSearch(searchText, $dialog);
            } else {
                AJS.messages.info("#search-results-table", {
                    body: "Please enter search value.",
                    closeable: false
                });
            }

            return false;
        });

        // Bind the advanced search button
        $("#advanced-search-panel-button", $dialog).click(function() {
            advancedSearchButtonClick($dialog);
            return false;
        });

        $("#simple-search-toggle", $dialog).click(function() {
            $("#remote-jira-simple-search-form", $dialog).show();
            $("#remote-jira-advanced-search-form", $dialog).hide();
            return false;
        });

        $("#linkjiraissue-add-selected", $dialog).click(function(){
            //select selected checkboxes of only *visible* rows
            //filtering to visible is necessary due to tabbed layout
            $("table tbody tr:visible  td.selection input:checked", $dialog).each(function(){
                var issueKey = $(this).parent().data("key");
                $("#jira-issue-keys").trigger("selectOption", [{
                    value: issueKey
                }]);
            });


            // Clear all error messages on the parent dialog, as we now have a newly selected issue
            $("#link-issue-dialog .error").hide();

            remoteJiraSearchDialog.hide();

            $("#link-issue-dialog")
                    .show()
                    .trigger("multiSelectRevealed");

            $("#jira-issue-keys-textarea").focus().select();
        });


        $("#advanced-search-toggle", $dialog).click(function() {
            $("#remote-jira-advanced-search-form", $dialog).show();
            $("#remote-jira-simple-search-form", $dialog).hide();

            // Initialise the JQL auto complete once we have the data
            // Ensure that we only initialise it once only
            var $jqlSearchText = $("#jql-search-text");
            if (!$jqlSearchText.attr("jql-initialized")) {
                setAutoCompleteLoadingIconVisible(true, $dialog);
                WRM.require("wr!jira.webresources:jqlautocomplete", function(){
                    autoCompletePromise.done(function (smartAjaxResult) {
                        if (smartAjaxResult.successful) {
                            // Enable JQL AutoComplete
                            IssueLinkJQLAutoComplete.initialize({
                                fieldID: "jql-search-text",
                                errorID: "jql-search-error",
                                autoCompleteUrl: getAutoCompleteUrl(appId),
                                autoCompleteData: smartAjaxResult.data,
                                formSubmitFunction: function() {
                                    advancedSearchButtonClick($dialog);
                                }
                            });
                        }
                        else {
                            setJQLErrorVisible(false, $dialog);
                            setAutoCompleteFailedIconVisible(true, $dialog);
                        }
                        setAutoCompleteLoadingIconVisible(false, $dialog);
                        $jqlSearchText.attr("jql-initialized", 1);
                    });
                });

            }
            $jqlSearchText.focus();

            return false;
        });

        $("#simple-search-toggle", $dialog).trigger("click");
    }

    function getAutoCompleteUrl(appId) {
        if (appId && appId !== "") {
            // Remote JIRA instance
            return contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/autocomplete?appId=" + appId;
        }
        // Local JIRA instance - will use the default URL in JQLAutoComplete
        return "";
    }

    function advancedSearchButtonClick($dialog) {
        $("#search-results-table", $dialog).empty();
        var searchText = $("#jql-search-text", $dialog).val();
        searchText = $.trim(searchText);
        if (searchText) {
            doAdvancedSearch(searchText, $dialog);
        } else {
            AJS.messages.info("#search-results-table", {
                body: "Please enter search value.",
                closeable: false
            });
        }
    }

    function setLoadingIconVisible(visible, $context) {
        $("#link-search-loading", $context).toggleClass("hidden", !visible);
    }

    function setAutoCompleteLoadingIconVisible(visible, $context) {
        $("#autocomplete-loading", $context).toggleClass("hidden", !visible);
    }

    function setAutoCompleteFailedIconVisible(visible, $context) {
        $("#autocomplete-failed", $context).toggleClass("hidden", !visible);
    }

    function setJQLErrorVisible(visible, $context) {
        $("#jql-search-error", $context).toggleClass("hidden", !visible);
    }

    function doSimpleSearch(searchText, $context) {
        setLoadingIconVisible(true, $context);
        var appId = $("#jira-app-link").val();
        var issueKeyJql = 'key = "' + searchText + '"';
        var projectJql = 'project = "' + searchText + '"';
        var plainTextJql = 'summary ~ "' + searchText + '" OR description ~ "' + searchText + '" OR comment ~ "' + searchText + '"';

        // First, check if search text is an issue key
        // We need to do this because the search will fail if it is not an issue key,
        // even if it is OR'd with a condition that returns results!
        jqlSearch(issueKeyJql, appId).done(function (smartAjaxResult) {
            if (smartAjaxResult.successful && smartAjaxResult.data.issues.length > 0) {
                setLoadingIconVisible(false, $context);
                showResults(smartAjaxResult, $context);
            } else {

                // Then check if search text is a project
                jqlSearch(projectJql, appId).done(function (smartAjaxResult) {
                    if (smartAjaxResult.successful && smartAjaxResult.data.issues.length > 0) {
                        // The search text is a project name or key
                        setLoadingIconVisible(false, $context);
                        showResults(smartAjaxResult, $context);
                    } else {

                        // Finally, a plain text search
                        jqlSearch(plainTextJql, appId).done(function (smartAjaxResult) {
                            setLoadingIconVisible(false, $context);
                            if (smartAjaxResult.successful) {
                                showResults(smartAjaxResult, $context);
                            } else {
                                showResultsError(smartAjaxResult);
                            }
                        });
                    }
                });
            }
        });
    }

    function doAdvancedSearch(jql, $context) {
        setLoadingIconVisible(true, $context);
        var appId = $("#jira-app-link").val();
        jqlSearch(jql, appId).done(function (smartAjaxResult) {
            setLoadingIconVisible(false, $context);
            if (smartAjaxResult.successful) {
                showResults(smartAjaxResult, $context);
            } else {
                if (smartAjaxResult.status === 400) {
                    AJS.messages.warning("#search-results-table", {
                        body: "Invalid JQL query.",
                        closeable: false
                    });
                } else {
                    showResultsError(smartAjaxResult);
                }
            }
        });
    }

    function jqlSearch(jql, appId) {
        var deferred = $.Deferred();
        var url;
        if (appId && appId !== "") {
            // Remote JIRA instance
            url = contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/search?jql=" + jql + "&appId=" + appId + "&maxResults=10";
        } else {
            // Local JIRA instance
            // Filter out current issue from results
            var currentIssueKey = $("#current-issue-key").val();
            jql = "(" + jql + ") and key != " + currentIssueKey;
            url = contextPath + "/rest/api/2/search?jql=" + jql + "&maxResults=10";
        }
        JIRA.SmartAjax.makeRequest({
            url: url,
            complete: function (xhr, textStatus, smartAjaxResult) {
                deferred.resolve(smartAjaxResult);
            }
        });
        return deferred.promise();
    }

    function getJqlAutoCompleteData(appId) {
        var deferred = $.Deferred();
        var remote;
        var url;
        if (appId && appId !== "") {
            // Remote JIRA instance
            url = contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/autocompletedata?appId=" + appId;
            remote = true;
        } else {
            // Local JIRA instance
            url = contextPath + "/rest/api/2/jql/autocompletedata";
            remote = false;
        }
        JIRA.SmartAjax.makeRequest({
            url: url,
            complete: function (xhr, textStatus, smartAjaxResult) {
                if (!smartAjaxResult.successful && remote) {
                    // If a remote JIRA request fails, it probably doesn't have the autocompletedata REST endpoint (added in JIRA v5.1)
                    // Get the auto complete data by parsing the issue navigator page
                    JIRA.SmartAjax.makeRequest({
                        url: contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/autocompletedata/legacy?appId=" + appId,
                        complete: function (xhr, textStatus, smartAjaxResult) {
                            deferred.resolve(smartAjaxResult);
                        }
                    });
                } else {
                    deferred.resolve(smartAjaxResult);
                }
            }
        });
        return deferred.promise();
    }

    function showResults(smartAjaxResult, $context) {
        var resultHtml = JIRA.Templates.RemoteJiraIssueSearch.resultsTable({result: smartAjaxResult.data});
        $("#search-results-table", $context).html(resultHtml);

        $("#linkjiraissue-select-all", $context).click(function(){
            var $masterStatus = $(this).prop("checked");
            $("tbody tr td.selection input", $context).prop("checked", $masterStatus);
        });

        $("tbody tr", $context).click(function (e) {

            //if we click on checkbox directly we don't want to change its value
            if($(e.target).is(":checkbox")){
                return;
            }
            var checkbox = $(this).find("td.selection input");
            checkbox.prop("checked", !checkbox.prop("checked"));


        });
    }

    function showResultsError(smartAjaxResult) {
        AJS.messages.error("#search-results-table", {
            body: JIRA.SmartAjax.buildSimpleErrorContent(smartAjaxResult),
            closeable: false
        });
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-jira-search-js', location = 'templates/dialog/linkjiraissue-search.soy' */
// This file was automatically generated from linkjiraissue-search.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.RemoteJiraIssueSearch.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.RemoteJiraIssueSearch == 'undefined') { JIRA.Templates.RemoteJiraIssueSearch = {}; }


JIRA.Templates.RemoteJiraIssueSearch.dialog = function(opt_data, opt_ignored) {
  return '<h2>' + soy.$$escapeHtml("Find JIRA issues") + '</h2><form class="aui search-form" id="remote-jira-simple-search-form" action="#" method="post"><div class="field-group"><label for="link-search-text">' + soy.$$escapeHtml("Search") + ':</label><input id="link-search-text" type="text" tabindex="0" class="text" size="50"> <input type="submit" tabindex="0" class="button" id="simple-search-panel-button" value="' + soy.$$escapeHtml("Search") + '"> <a id="advanced-search-toggle" href="#" title="' + soy.$$escapeHtml("Perform a JQL search") + '">' + soy.$$escapeHtml("Advanced Search") + '</a><span id="link-search-loading" class="icon loading throbber hidden"/></div></form><form class="aui search-form" id="remote-jira-advanced-search-form" action="#" method="post"><div class="field-group"><label for="jql-search-text">' + soy.$$escapeHtml("JQL Search") + '<span id="autocomplete-loading" class="hidden"><span class="icon loading throbber"/>' + soy.$$escapeHtml("Loading auto-complete") + '</span><span id="autocomplete-failed" class="hidden">' + soy.$$escapeHtml("(auto-complete unavailable)") + '</span></label><div id="jql-search-container"><span id="jql-search-error" class="icon jqlgood" /><div class="atlassian-autocomplete"><textarea id="jql-search-text" class="text full-width-field" tabindex="0" /></div></div><button class="aui-button aui-button-subtle search-button" id="advanced-search-panel-button" type="submit"><span class="aui-icon aui-icon-small aui-iconfont-search" title="' + soy.$$escapeHtml("Search") + '"></span></button> <a id="simple-search-toggle" href="#" title="' + soy.$$escapeHtml("Perform a plain text search") + '">' + soy.$$escapeHtml("Simple Search") + '</a><span id="link-search-loading" class="icon loading throbber hidden"/></div></form><div class="message-panel hidden"></div><div id="search-results-table" class="data-table"></div><div class="buttons-container form-footer"><div class="buttons"><button type="button" class="aui-button" id="linkjiraissue-add-selected">' + soy.$$escapeHtml("Add") + '</button><button class="aui-button aui-button-link cancel" href="#" id="remote-jira-link-cancel" title="' + soy.$$escapeHtml("Press Esc to close") + '">' + soy.$$escapeHtml("Close") + '</button></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.dialog.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.dialog';
}


JIRA.Templates.RemoteJiraIssueSearch.resultsTable = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.result.issues.length > 0) {
    output += '<table id="remote-jira-searchresult" class="aui"><thead><tr><th class="selection" ><input id="linkjiraissue-select-all" type="checkbox"/></th><th class="type">' + soy.$$escapeHtml("Type") + '</th><th class="key">' + soy.$$escapeHtml("Key") + '</th><th class="summary">' + soy.$$escapeHtml("Summary") + '</th><th class="status">' + soy.$$escapeHtml("Status") + '</th></tr></thead><tbody>';
    var issueList44 = opt_data.result.issues;
    var issueListLen44 = issueList44.length;
    for (var issueIndex44 = 0; issueIndex44 < issueListLen44; issueIndex44++) {
      var issueData44 = issueList44[issueIndex44];
      output += '<tr title="' + soy.$$escapeHtml(issueData44.key) + '"><td class="selection" data-key="' + soy.$$escapeHtml(issueData44.key) + '"><input type="checkbox"/></td><td class="type">' + JIRA.Templates.RemoteJiraIssueSearch.issueType({issueType: issueData44.fields.issuetype}) + '</td><td class="key" title="' + soy.$$escapeHtml(issueData44.key) + '">' + soy.$$escapeHtml(issueData44.key) + '</td><td class="summary" title="' + soy.$$escapeHtml(issueData44.fields.summary) + '">' + soy.$$escapeHtml(issueData44.fields.summary) + '</td><td class="status">' + JIRA.Templates.RemoteJiraIssueSearch.status({status: issueData44.fields.status}) + '</td></tr>';
    }
    output += '</tbody></table>';
  } else {
    output += '<div class="aui-message info"><span class="aui-icon icon-info"></span><p>' + soy.$$escapeHtml("Search returned no results.") + '</p></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.resultsTable.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.resultsTable';
}


JIRA.Templates.RemoteJiraIssueSearch.issueType = function(opt_data, opt_ignored) {
  return '<img src="' + soy.$$escapeHtml(opt_data.issueType.iconUrl) + '" alt="' + soy.$$escapeHtml(opt_data.issueType.name) + '" title="' + soy.$$escapeHtml(opt_data.issueType.name) + ' - ' + soy.$$escapeHtml(opt_data.issueType.description) + '"/>';
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.issueType.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.issueType';
}


JIRA.Templates.RemoteJiraIssueSearch.status = function(opt_data, opt_ignored) {
  return '' + JIRA.Template.Util.Issue.Status.issueStatusResolver({issueStatus: opt_data.status});
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.status.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.status';
}
;
;
/* module-key = 'jira.webresources:jira-analytics', location = '/includes/jira/analytics/analytics.js' */
/**
 * Capture analytics events in the JIRA general context.
 */
AJS.toInit(function($) {
    /**
     * Returns the currently selected tab on the Browse Project page
     */
    function getBrowseProjectTab() {
        return $("li.active a.browse-tab").attr("id");
    }

    // Need to defer for debugging support (see analytics-debug.js).
    _.defer(function() {
        if (AJS.EventQueue) {
            // Capture clicks on 'Administer Project' button on Browse Project page
            $(document).delegate("#project-admin-link", "click", function() {
                var selectedTab = getBrowseProjectTab();
                AJS.EventQueue.push({
                    name: "browseproject.administerproject",
                    properties: {
                        selectedtab: selectedTab
                    }
                });
            });

            // Capture clicks on 'Create New Project' button on Browse Projects page
            $(document).delegate("#browse-projects-create-project", "click", function() {
                AJS.EventQueue.push({
                    name: "browseprojects.createproject",
                    properties: {}
                });
            });

            // Capture clicks on the 'create an issue' link on the Issues tab when no issues exist in the project
            $(document).delegate("#no-issues-create-issue", "click", function() {
                AJS.EventQueue.push({
                    name: "browseproject.issuesblankslate.createissue",
                    properties: {}
                });
            });

            // Capture clicks on the issue filter links on the Issues tab
            $(document).delegate("a.issue-filter-link", "click", function() {
                var $el = $(this);
                var id = $el.attr("id").replace("filter_", "");
                var type = $el.attr("data-type");
                AJS.EventQueue.push({
                    name: "browse" + type + ".issuefilter." + id,
                    properties: {}
                });
            });

            $(document).on("click", "#project_import_link_lnk", function() {
                AJS.EventQueue.push({
                    name: "topnav.jim",
                    properties: {}
                });
            });

            $(document).on("click", ".issueaction-viewworkflow", function() {
                var classes = $(this).attr("class");
                var isNew = classes.indexOf("new-workflow-designer") > -1 || classes.indexOf("jira-workflow-designer-link") > -1;
                var version = isNew ? "new" : "old";

                var newEnabled = AJS.DarkFeatures.isEnabled("casper.VIEW_ISSUE");

                AJS.EventQueue.push({
                    name: "issue.viewworkflow",
                    properties: {
                        version: version,
                        newEnabled: newEnabled
                    }
                });
            });
        } // if (AJS.EventQueue)
    });
});
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/jquery/plugins/avataror/avataror.js' */

jQuery.fn.avataror = function (options) {
    var $ = jQuery,
        $document = $(document);
    this.each(function () {
        var $this = $(this);

        var imgsrc = $this.find("img").attr("src");
        $this.css({"-moz-border-radius": "10px", "-webkit-border-radius": "10px"});
        $this.html("<p>Loading?</p>");
        var avataror = {previewSize: 48};
        avataror.preview = $("<div/>").addClass("avataror-preview").css({border: "solid 1px #000", "float": "left", height: avataror.previewSize +"px", overflow: "hidden", width: avataror.previewSize +"px", position: "relative", top: "-9999em", left: "-9999em"});
        avataror.preview.prependTo(options.previewElement);
        avataror.img = $('<img src="' + imgsrc + '" alt="Avatar Source"/>');
        avataror.img.load(function () {
            avataror.image = $("<div/>").css({background: "url('" + imgsrc + "') no-repeat", clear: "left", position: "relative"});
            avataror.marker = $("<div/>").css({cursor: "move", position: "relative" });
            avataror.dash = $("<div/>");
            avataror.shadow = $("<div/>");
            avataror.dash.add(avataror.shadow).css({cursor: "move", opacity: .5, left: 0, top: 0, position: "absolute"});
            avataror.image.append(avataror.shadow).append(avataror.dash).append(avataror.marker);
            $this.append(avataror.image);
            avataror.marker.html('<div></div><div></div><div></div><div></div>');
            $("div", avataror.marker).each(function (i) {
                var $this = $(this);
                $this.css({background: "#000", border: "solid 1px #fff", width: "10px", height: "10px", position: "absolute", "font-size": "1px"});
                $this.css(["left", "right", "right", "left"][i], "-6px");
                $this.css(["top", "top", "bottom", "bottom"][i], "-6px");
                $this.css("cursor", ["nw-resize", "ne-resize", "se-resize", "sw-resize"][i]);
                $this.mousedown(function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    avataror.dragging = {x: e.pageX, y: e.pageY, ax: avataror.x, ay: avataror.y, w: avataror.width, h: avataror.height, i: i + 1};
                    avataror.shadow.hide();
                });
            });
            avataror.marker.add(avataror.image).mousedown(function (e) {
                e.preventDefault();
                avataror.dragging = {
                    x: e.pageX,
                    y: e.pageY,
                    ax: avataror.x,
                    ay: avataror.y,
                    w: avataror.width,
                    h: avataror.height};
                avataror.shadow.hide();
            });

            $document.mouseup(function (e) {
                avataror.handleMouseUp(e);
            });
            $document.mousemove(function (e) {
                if (avataror.dragging) {
                    avataror.handleMouseMove(e.pageX, e.pageY);
                    e.preventDefault();
                }
            });


            avataror.imgwidth = avataror.img.width();
            avataror.imgheight = avataror.img.height();
            avataror.x = parseInt($("#avatar-offsetX").val());
            avataror.y = parseInt($("#avatar-offsetY").val());
            avataror.width = parseInt($("#avatar-width").val());
            avataror.height = avataror.width;
            avataror.image.css({width: avataror.imgwidth + "px", height: avataror.imgheight + "px"});
            avataror.setMarker();

            $this.css({width: avataror.imgwidth + "px"});
            avataror.preview.css({position: "static"});
            $("p", $this).remove();
            $this.trigger("AvatarImageLoaded");
        });
        avataror.preview.append(avataror.img);

        avataror.setMarker = function () {
            avataror.marker.css("border", "dashed 1px #fff");
            avataror.dash.css("border", "solid 1px #000");
            avataror.shadow.css("border", "solid 1px #000");
            avataror.marker.add(this.dash).css("left", this.x - 1 + "px");
            avataror.marker.add(avataror.dash).css("top", avataror.y - 1 + "px");
            avataror.shadow.css("border-left-width", avataror.x + "px");
            avataror.shadow.css("border-right-width", avataror.imgwidth - avataror.x - avataror.width + "px");
            avataror.shadow.css("border-top-width", avataror.y + "px");
            avataror.shadow.css("border-bottom-width", avataror.imgheight - avataror.y - avataror.height + "px");
            avataror.shadow.css("width", avataror.width + "px");
            avataror.shadow.css("height", avataror.height + "px");
            avataror.marker.add(avataror.dash).css("width", avataror.width + "px");
            avataror.marker.add(avataror.dash).css("height", avataror.height + "px");
        };

        avataror.adjustPreview = function() {
            avataror.img.attr("width", avataror.imgwidth * avataror.previewSize / avataror.width);
            avataror.img.attr("height", avataror.imgheight * avataror.previewSize / avataror.height);
            avataror.img.css("margin-left", "-" + avataror.x * avataror.previewSize / avataror.width + "px");
            avataror.img.css("margin-top", "-" + avataror.y * avataror.previewSize / avataror.height + "px");
            avataror.preview.select();
        };

        avataror.handleMouseMove = function(newX, newY) {
            avataror.dragging.nextExec = avataror.dragging.nextExec || 0;
            if (avataror.dragging.nextExec == 0) {
                avataror.dragging.nextExec = 3;
            } else {
                avataror.dragging.nextExec--;
                return;
            }
            var dx = newX - avataror.dragging.x;
            var dy = newY - avataror.dragging.y;
            if (this.dragging.i) {
                var handler = avataror.resizeHandlers[this.dragging.i-1];
                handler(dx,dy);
            } else {
                avataror.x = avataror.dragging.ax + dx;
                avataror.y = avataror.dragging.ay + dy;
                if (avataror.x + avataror.width > avataror.imgwidth) {
                    avataror.x = avataror.imgwidth - avataror.width;
                }
                if (avataror.y + avataror.height > avataror.imgheight) {
                    avataror.y = avataror.imgheight - avataror.height;
                }
                if (avataror.x < 0) {
                    avataror.x = 0;
                }
                if (avataror.y < 0) {
                    avataror.y = 0;
                }
            }
            avataror.setMarker();
            avataror.adjustPreview();
        };

        avataror.handleMouseUp = function(e) {
//            avataror.adjustPreview();
            $("#avatar-offsetX").val(avataror.x);
            $("#avatar-offsetY").val(avataror.y);
            $("#avatar-width").val(avataror.width);
            avataror.dragging = null;
            avataror.shadow.show();
        };

        avataror.originX = function() {
            return avataror.dragging.ax;
        };
        avataror.originY = function() {
            return avataror.dragging.ay;
        };
        avataror.originBottomX = function() {
            return avataror.dragging.ax + avataror.dragging.w;
        };
        avataror.originBottomY = function() {
            return avataror.dragging.ay + avataror.dragging.h;
        };

        avataror.originNw = function() {
            return {x: avataror.originX(), y: avataror.originY()};
        };
        avataror.originNe = function() {
            return {x: avataror.originBottomX(), y: avataror.originY()};
        };
        avataror.originSe = function() {
            return {x: avataror.originBottomX(), y: avataror.originBottomY()};
        };
        avataror.originSw = function() {
            return {x: avataror.originX(), y: avataror.originBottomY()};
        };

        avataror.nwHandler = function(dx, dy) {
            var anchor = avataror.originSe();
            var tmpBase = {x: avataror.originX() + dx, y: avataror.originY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);
            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x - newSize < 0) {
                newSize = anchor.x;
            }
            if (anchor.y - newSize < 0) {
                newSize = anchor.y;
            }
            avataror.x = anchor.x - newSize;
            avataror.y = anchor.y - newSize;
            avataror.width = avataror.height = newSize;
        };

        avataror.neHandler = function(dx, dy) {
            var anchor = avataror.originSw();
            var tmpBase = {x: avataror.originBottomX() + dx, y: avataror.originY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);

            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x + newSize > avataror.imgwidth) {
                newSize = avataror.imgwidth - anchor.x;
            }
            if (anchor.y - newSize < 0) {
                newSize = anchor.y;
            }

            avataror.y = anchor.y - newSize;
            avataror.width = avataror.height = newSize;
        };

        avataror.seHandler = function(dx, dy) {
            var anchor = avataror.originNw();
            var tmpBase = {x: avataror.originBottomX() + dx, y: avataror.originBottomY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);

            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x + newSize > avataror.imgwidth) {
                newSize = avataror.imgwidth - anchor.x;
            }
            if (anchor.y + newSize > avataror.imgheight) {
                newSize = avataror.imgheight - anchor.y;
            }
            avataror.width = avataror.height = newSize;
        };

        avataror.swHandler = function(dx, dy) {
            var anchor = avataror.originNe();
            var tmpBase = {x: avataror.originX() + dx, y: avataror.originBottomY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);

            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x - newSize < 0) {
                newSize = anchor.x;
            }
            if (anchor.y + newSize > avataror.imgheight) {
                newSize = avataror.imgheight - anchor.y;
            }
            avataror.x = anchor.x - newSize;
            avataror.width = avataror.height = newSize;
        };

        avataror.resizeHandlers = [avataror.nwHandler, avataror.neHandler, avataror.seHandler, avataror.swHandler];

        // implementation
    });
};
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/Avatar.js' */
/**
 * Represents an icon for a project or some other entity in JIRA.
 *
 * @Class JIRA.Avatar
 *
 */
JIRA.Avatar = Class.extend({

    /**
     * @constructor
     * @param {object} options
     * @param {Number} options.id
     * @param {Boolean} options.isSystemAvatar
     * @param {object} [options.urls] an optional hash of avatar URLs
     */
    init: function (options) {
        this._id = options.id;
        this._isSystemAvatar = options.isSystemAvatar;
        this._isSelected = options.isSelected;
        this._urls = options.urls;
    },

    /**
     * Sets as unselected
     */
    setUnSelected: function () {
        this._isSelected = false;
    },

    /**
     * Sets as selected
     */
    setSelected: function () {
        this._isSelected = true;
    },

    /**
     * Gets selected state
     */
    isSelected: function () {
        return !!this._isSelected;
    },

    /**
     * Indicates whether the Avatar is a system-provided one or if users have defined it.
     *
     * @return {Boolean} true only if the Avatar is a system-provided one.
     */
    isSystemAvatar: function () {
        return this._isSystemAvatar;
    },

    /**
     * The database identifier for the Avatar, may be null if it hasn't yet been stored.
     *
     * @return the database id or null.
     */
    getId: function () {
        return this._id;
    },

    /**
     * Returns the URL of this avatar in the given size.
     *
     * @param {string} size an avatar size
     * @return {string} the avatar URL
     */
    getUrl: function(size) {
        return this._urls[size];
    },

    /**
     * Serilaizes the object into a JSON object
     *
     * @return {Object}
     */
    toJSON: function () {
        return {
            id: this._id,
            isSystemAvatar: this._isSystemAvatar,
            isSelected: this._isSelected,
            urls: this._urls
        };
    }
});


// Factories

/**
 * Creates custom avatar
 *
 * @param descriptor
 * ... {String} id
 */
JIRA.Avatar.createCustomAvatar = function (descriptor) {
    descriptor.isSystemAvatar = false;
    return new JIRA.Avatar(descriptor);
};

/**
 * Creates system avatar
 *
 * @param descriptor
 * ... {String} id
 */
JIRA.Avatar.createSystemAvatar = function (descriptor) {
    descriptor.isSystemAvatar = true;
    return new JIRA.Avatar(descriptor);
};

/**
 * Converts avatar size name to size object. If passed parameters is object is
 * returned unmodified.
 * @param name
 * @returns {JIRA.Avatar}
 */
JIRA.Avatar.getSizeObjectFromName = function (name) {
    if ( "object" === typeof name ) {
        return name;
    }
    var nameTrimmed = "string" === typeof name ? jQuery.trim(name) : "";
    if ( JIRA.Avatar.LARGE.param===name ) {
        return JIRA.Avatar.LARGE;
    } else if ( JIRA.Avatar.MEDIUM.param===name ) {
        return JIRA.Avatar.MEDIUM;
    } else if ( JIRA.Avatar.SMALL.param===name ) {
        return JIRA.Avatar.SMALL;
    } else if ( "xsmall"===name ) { // Java uses xmall name!#@$
        return JIRA.Avatar.SMALL;
    } else {
        return JIRA.Avatar.LARGE;
    }
};


// Sizes

/**
 * Large avatar settings
 */
JIRA.Avatar.LARGE = {
    param: "large",
    height: 48,
    width: 48
};

/**
 * Medium avatar settings
 */
JIRA.Avatar.MEDIUM = {
    param: "medium",
    width: 32,
    height: 32
};

/**
 * Small avatar settings
 */
JIRA.Avatar.SMALL = {
    param: "small",
    width: 16,
    height: 16
};

;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarManager.js' */
/**
 * Manager interface for JIRA.Avatar objects.
 *
 * You should use this for creating, manipulating and deleteing of avatars. Helper methods such as getting avatar
 * urls are also contained within this class.
 *
 * Please use the factory methods for construction
 *
 * @Class JIRA.AvatarManager
 */
JIRA.AvatarManager = Class.extend({

    /**
     * @param options
     * @param {JIRA.AvatarStore} options.store
     * @param {Number|String} options.defaultAvatarId - This is the avatar that is currently in use if no other have been selected
     * @param {Number|String} options.anonymousAvatarId - In the case of user avatar, this is the one used for logged out/or annonymous users
     * @param {String} options.avatarSrcBaseUrl - The base url used to load the avatar image
     */
    init: function (options) {
        this.store = options.store;
        this.ownerId = options.ownerId;
        this.username = options.username;
        this.anonymousAvatarId = options.anonymousAvatarId;
        this.avatarSrcBaseUrl = options.avatarSrcBaseUrl;
    },

    /**
     * Selects avatar, this will become the displayed avatar for the given type (ie project)
     *
     * @param avatar
     * @param options
     */
    selectAvatar: function (avatar, options) {
        return this.store.selectAvatar(avatar, options);
    },

    /**
     * Retrieve the avatar with the given id.
     *
     * @param avatarId must not be null.
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    getById: function (id) {
        return this.store.getById(id);
    },

    /**
     * Delete the avatar
     *
     * @param {String} avatar must not be null.
     */
    destroy: function (avatar, options) {
        this.store.destroy(avatar, options);
    },

    /**
     * Saves the avatar as an updated version of the avatar with the same id that is already in the store.
     *
     * @param {JIRA.Avatar} avatar must not be null.
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    update: function (avatar, options) {
        this.store.update(avatar, options);
    },

    /**
     * Creates a database record for the given avatar. Use the return value as the persistent avatar, not the one you
     * passed in.
     *
     * @param {JIRA.Avatar} avatar must not be null, must have a null id.
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    add: function (avatar, options) {
        this.store._add(avatar, options);
    },

    /**
     * Provides a list of all system avatars.
     *
     * Note: You will need to call refreshStore first
     *
     * @return {Array<JIRA.Avatar>} the system avatars.
     */
    getAllSystemAvatars: function () {
        return this.store.getAllSystemAvatars();
    },

    /**
     * Provides an array of all system avatars.
     *
     * Note: You will need to call refreshStore first
     *
     * @return {Array<JIRA.Avatar>} the custom avatars.
     */
    getAllCustomAvatars: function () {
        return this.store.getAllCustomAvatars();
    },

    /**
     * Gets selected avatar
     *
     * @return JIRA.Avatar
     */
    getSelectedAvatar: function () {
        return this.store.getSelectedAvatar();
    },

    /**
     *
     * Gets all avatars
     *
     * Note: You will need to call refreshStore first
     *
     * @return {Object}
     * ... {Array<JIRA.Avatar>} system
     * ... {Array<JIRA.Avatar>} custom
     */
    getAllAvatars: function () {
        return this.store.getAllAvatars();
    },

    /**
     * Gets a JSON blob, that contains the img src of each avatar based on the supplied size
     *
     * @param {JIRA.Avatar.LARGE | JIRA.Avatar.MEDIUM | JIRA.Avatar.SMALL} size
     * @return {Object}
     * ... {Array[{id, src, isSystemAvatar}]} system
     * ... {Array[{id, src, isSystemAvatar}] custom
     */
    getAllAvatarsRenderData: function (size) {

        var i,
                instance = this,
                avatars = this.getAllAvatars(),
                renderData = {
                    system: [],
                    custom: []
                };

        for (i = 0; i < avatars.system.length; i++) {
            renderData.system.push(instance.getAvatarRenderData(avatars.system[i], size));
        }

        for (i = 0; i < avatars.custom.length; i++) {
            renderData.custom.push(instance.getAvatarRenderData(avatars.custom[i], size));
        }

        return renderData;
    },

    /**
     * Gets json descriptor of given avatar that contains the img src based on the supplied size
     * @param avatar
     * @param size
     */
    getAvatarRenderData: function (avatar, size) {
        var data = avatar.toJSON();

        data.src = this.getAvatarSrc(avatar, size);
        data.width = size.width;
        data.height = size.height;


        return data;
    },

    /**
     * Refreshes avatar store
     *
     * @param options
     * ... {function} success
     * ... {function} error
     */
    refreshStore: function (options) {
        this.store.refresh(options);
    },

    /**
     *
     * @param {JIRA.Avatar} avatar
     * @param {JIRA.Avatar.LARGE | JIRA.Avatar.MEDIUM | JIRA.Avatar.SMALL} size
     * @return String
     */
    getAvatarSrc: function(avatar, size) {

        if (this.store.isTempAvatar(avatar)) {
            // if the user chooses a new temporary avatar we need to keep making this url unique so that the image is kept fresh
            return contextPath + "/secure/temporaryavatar?" + jQuery.param({
                cropped: true,
                magic: new Date().getTime(),
                size: size.param
            });
        }

        return avatar.getUrl(AJS.format('{0}x{1}', size.height, size.width));
    },

    /**
     * Creates temporary avatar from the value in the supplied file input field
     *
     * @param {HTMLElement} field
     * @param {Object} options
     * ... {function} success
     * ... {function} error
     */
    createTemporaryAvatar: function (field, options) {
        this.store.createTemporaryAvatar(field, options);
    },

    /**
     * Creates an avatar with the properties of the given avatar.
     *
     * @param {Object} instructions
     * ... {Number} cropperOffsetX
     * ... {Number} cropperOffsetY
     * ... {Number} cropperWidth
     *
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    createAvatarFromTemporary: function (instructions, options) {
        this.store.createAvatarFromTemporary(instructions, options);
    },

    /**
     * Gets the avatar id to use to represent an unknown or anonymous user
     * @return {Number} the avatar id for an anonymous user
     */
    getAnonymousAvatarId: function () {
        return this.anonymousAvatarId;
    }

});


// Factories


/**
 *
 * Creates a project avatar manager
 *
 * @param options
 * ... {String} projectKey
 * ... {String} projectId
 * ... {String} defaultAvatarId
 */
JIRA.AvatarManager.createUniversalAvatarManager = function (options) {

    // Cater for the projectKey being empty
    var restQueryUrl,
            restUpdateUrl = "",
            restCreateTempUrl = "",
            restUpdateTempUrl = "",
            restSingleAvatarUrl = "";

    if (options.projectId) {
        var urlAvatarOwnerPrefix = contextPath + "/rest/api/latest/universal_avatar/type/"+options.avatarType+"/owner/" + options.projectId;

        restQueryUrl = urlAvatarOwnerPrefix;

        var avatarCreateUrl = urlAvatarOwnerPrefix + "/avatar";

        restUpdateUrl = null;
        restCreateTempUrl = urlAvatarOwnerPrefix + "/temp";
        restUpdateTempUrl = avatarCreateUrl;
        restSingleAvatarUrl = avatarCreateUrl;
    } else {
        restQueryUrl = contextPath + "/rest/api/latest/avatar/project/system";
        restCreateTempUrl = contextPath + "/rest/api/latest/avatar/project/temporary";
        restUpdateTempUrl = contextPath + "/rest/api/latest/avatar/project/temporaryCrop";
    }

    var store = new JIRA.AvatarStore({
        restQueryUrl: restQueryUrl,
        restUpdateUrl: restUpdateUrl,
        restCreateTempUrl: restCreateTempUrl,
        restUpdateTempUrl: restUpdateTempUrl,
        restSingleAvatarUrl: restSingleAvatarUrl,
        defaultAvatarId: options.defaultAvatarId
    });

    return new JIRA.AvatarManager({
        store: store,
        ownerId: options.projectId,
        avatarSrcBaseUrl: contextPath + "/secure/projectavatar"
    });
};

/**
 *
 * Creates a project avatar manager
 *
 * @param options
 * ... {String} projectKey
 * ... {String} projectId
 * ... {String} defaultAvatarId
 */
JIRA.AvatarManager.createProjectAvatarManager = function (options) {
    options.avatarType = "project";

    return JIRA.AvatarManager.createUniversalAvatarManager(options);
};

/**
 * Creates a user avatar manager
 *
 * @param options
 * ... {String} username
 * ... {String} defaultAvatarId
 */
JIRA.AvatarManager.createUserAvatarManager = function (options) {

    var userRestUrl = contextPath + "/rest/api/latest/user";
    var store = new JIRA.AvatarStore({
        restQueryUrl: userRestUrl + "/avatars",
        restUpdateUrl: userRestUrl + "/avatar",
        restCreateTempUrl: userRestUrl + "/avatar/temporary",
        restUpdateTempUrl: userRestUrl + "/avatar",
        restSingleAvatarUrl: userRestUrl + "/avatar",
        restParams: { 'username': options.username },
        defaultAvatarId: options.defaultAvatarId
    });

    return new JIRA.AvatarManager({
        store: store,
        username: options.username,
        avatarSrcBaseUrl: contextPath + "/secure/useravatar"
    });
};
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarStore.js' */
/**
 * Persistent storage mechanism for JIRA.Avatar
 *
 * This default store uses a CRUD rest interface. There are several parameters to provide. Any optional rest URL
 * parameters are simply not invoked.
 *
 * @param restQueryUrl
 *      Mandatory. Retrieves the list of available avatars to pick from.
 *      Type: GET
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatars
 *      Response: {"system":[{"id":10001,"isSystemAvatar":true,"selected":false}], "custom": [{"id":10002,"isSystemAvatar":false,"selected":false}]}
 *
 * @param restUpdateUrl
 *      Optional. Sets the avatar as the selection for the owner.
 *      Type: PUT
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar
 *      Request: {"id":10001,"isSystemAvatar":true,"selected":false}
 *
 * @param restCreateTempUrl
 *      Mandatory. Uploads a file and stores it as the session's temporary avatar
 *      Type: Wildcard
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar/temporary
 *      Request: io stream (for supporting browsers) or multipart
 *
 * @param restUpdateTempUrl
 *      Mandatory. Crops the temporary avatar. This may also be a good time to convert it into a real avatar, but that
 *      will not always be the case, e.g. when an owner (project, user, etc) is still in the process of being created.
 *      Type: POST
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar
 *      Request: {"cropperOffsetX":"90","cropperOffsetY":"57","cropperWidth":"143"}
 *
 * @param restSingleAvatarUrl
 *      Optional. Deletes avatar.
 *      Type: DELETE
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar
 *      Request: {"id":10001,"isSystemAvatar":true,"selected":false}
 *
 * @param restParams
 *      Optional. e.g. {username: "admin"}
 *
 * @param defaultAvatarId
 *      Mandatory. Used if the currently selected avatar is deleted.
 *
 * Note: If you want to use a different storage mechanism, you can implement the same interface as here and pass it to the
 * constructor of your JIRA.AvatarManager
 */
JIRA.AvatarStore = Class.extend({

    TEMP_ID: "TEMP",

    /**
     * @constructor
     * @param options
     * ... {String} restQueryUrl - Retrieves the list of available avatars to pick from (see class description)
     * ... {String} restUpdateUrl - Sets the avatar as the selection for the owner (see class description)
     * ... {String} restCreateTempUrl - Uploads a file and stores it as the session's temporary avatar (see class description)
     * ... {String} restUpdateTempUrl - Crops the temporary avatar (see class description)
     * ... {String} restSingleAvatarUrl - Deletes avatar (see class description)
     * ... {String} restParams - The optional query parameters to append to the base URL for rest requests (see class description)
     * ... {Number} defaultAvatarId - The id of default avatar. The selected avatar if user has not selected one yet.
     */
    init: function (options) {

        if (!options.restQueryUrl) {
            throw new Error("JIRA.AvatarStore.init: You must specify [restQueryUrl], The rest url for querying avatars (see class description)");
        }

        if (!options.restCreateTempUrl) {
            throw new Error("JIRA.AvatarStore.init: You must specify [restCreateTempUrl], The rest url for creating a temporary avatar (see class description)");
        }

        if (!options.restUpdateTempUrl) {
            throw new Error("JIRA.AvatarStore.init: You must specify [restUpdateTempUrl], The rest url for updating a temporary avatar (see class description)");
        }

        if (!options.defaultAvatarId) {
            throw new Error("JIRA.AvatarStore.init: You must specify [defaultAvatarId] to the contructor so the store " +
                "knows what to select if you delete the selected one");
        }

        this.restQueryUrl = options.restQueryUrl;
        this.restUpdateUrl = options.restUpdateUrl;
        this.restCreateTempUrl = options.restCreateTempUrl;
        this.restUpdateTempUrl = options.restUpdateTempUrl;
        this.restSingleAvatarUrl = options.restSingleAvatarUrl;
        this.restParams = options.restParams || {};
        this.restParams.atl_token = atl_token();
        this.defaultAvatarId = options.defaultAvatarId;
        this.avatars = {system: [], custom: []};
    },

    /**
     * Builds the REST URL using the given url and optional restParams options.
     */
    _buildCompleteUrl: function (url) {
        var completeUrl = url;

        if (this.restParams) {
            var queryParams = '';
            for (var name in this.restParams) {
                queryParams += AJS.format('&{0}={1}', encodeURIComponent(name), encodeURIComponent(this.restParams[name]));
            }

            completeUrl += ('?' + queryParams.substr(1));
        }

        return completeUrl;
    },

    /**
     * Retrieves the Avatar by id.
     *
     * @param avatarId the avatar's id, must not be null.
     * @return the avatar with the given id or null if it doesn't exist.
     */
    getById: function (avatarId) {

        var match;

        jQuery.each(this.avatars.system, function (i, avatar) {
            if (this.getId() === avatarId) {
                match = avatar;
                return false;
            }
        });

        if (!match) {
            jQuery.each(this.avatars.custom, function (i, avatar) {
                if (this.getId() === avatarId) {
                    match = avatar;
                    return false;
                }
            });
        }

        return match;
    },

    /**
     * Checks if the given avatar is the temporarty avatar.
     *
     * @param avatar
     * @return true if it is the temporary avatar, false if otherwise.
     */
    isTempAvatar: function(avatar) {
        return (avatar.getId() === this.TEMP_ID);
    },

    /**
     * Update client side storage
     *
     * @param avatar
     */
    _selectAvatar: function (avatar) {

        var selected = this.getSelectedAvatar();

        if (selected) {
            selected.setUnSelected();
        }
        avatar.setSelected();
    },

    /**
     * Selects avatar, this will become the displayed avatar for the given type (ie project)
     *
     * @param {JIRA.Avatar} avatar
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    selectAvatar: function (avatar, options) {

        var instance = this;

        if (!avatar) {
            throw new Error("JIRA.AvatarStore.selectAvatar: Cannot select Avatar that does not exist");
        }

        if (this.restUpdateUrl) {
            JIRA.SmartAjax.makeRequest({
                type: "PUT",
                contentType: "application/json",
                dataType: "json",
                url: this._buildCompleteUrl(this.restUpdateUrl),
                data: JSON.stringify(avatar.toJSON()),
                success: function () {
                    instance._selectAvatar(avatar);
                    if (options.success) {
                        options.success.call(this, avatar);
                    }
                },
                error: options.error
            });
        } else {
            instance._selectAvatar(avatar);
            if (options.success) {
                options.success.call(this, avatar);
            }
        }
    },

    /**
     * Removes avatar in client side store
     *
     * @param {JIRA.Avatar} avatar
     */
    _destory: function (avatar) {

        var index = jQuery.inArray(avatar, this.avatars.custom);

        if (index !== -1) {
            this.avatars.custom.splice(index, 1);
        } else {
            throw new Error("JIRA.AvatarStore._destroy: Cannot remove avatar [" + avatar.getId() + "], "
                    + "it might be a system avatar (readonly) or does not exist.");
        }
    },

    /**
     * Permanently removes the avatar from the system.
     *
     * @param {JIRA.Avatar} avatar - must not be null.
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    destroy: function (avatar, options) {

        var instance = this;

        options = options || {};

        if (!avatar) {
            throw new Error("JIRA.AvatarStore.destroy: Cannot delete Avatar that does not exist");
        }

        JIRA.SmartAjax.makeRequest({
            type: "DELETE",
            url: this.getRestUrlForAvatar(avatar),
            success: function () {
                instance._destory(avatar);
                if (avatar.isSelected()) {
                    instance.selectAvatar(instance.getById(instance.defaultAvatarId), options);
                } else if (options.success) {
                    options.success.apply(this, arguments);
                }
            },
            error: options.error
        });
    },

    /**
     * Gets selected avatar, the displayed avatar for the given type (ie project)
     *
     * @return {JIRA.Avatar}
     */
    getSelectedAvatar: function () {

        for (var i = 0; i < this.avatars.custom.length; i++) {
            if (this.avatars.custom[i].isSelected()) {
                return this.avatars.custom[i];
            }
        }

        for (i = 0; i < this.avatars.system.length; i++) {
            if (this.avatars.system[i].isSelected()) {
                return this.avatars.system[i];
            }
        }
    },

    /**
     * Updates avatar in our client side store
     *
     * @param {JIRA.Avatar} avatar
     */
    _update: function (avatar) {

        var instance = this;

        if (this.getById(avatar.getId())) {
            jQuery.each(this.avatars.custom, function (i) {
                if (this.getId() === avatar.getId()) {
                    instance.avatars.custom[i] = avatar;
                }
            });
        }
        else {
            throw new Error("JIRA.AvatarStore._update: Cannot update avatar [" + avatar.getId() + "], "
                    + "it might be a system avatar (readonly) or does not exist.");
        }
    },

    /**
     * Updates an avatar's properties to match those in the given avatar. The avatar
     * to change is identified by the id of the given avatar.
     *
     * @param {JIRA.Avatar} avatar - the avatar to update, must not be null.
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    update: function (avatar, options) {

        var instance = this;

        options = options || {};

        JIRA.SmartAjax.makeRequest({
                    type: "PUT",
                    url: this.getRestUrlForAvatar(avatar),
                    error: options.error,
                    success: function () {
                        instance._update(avatar);
                        if (options.success) {
                            options.success.apply(this, arguments);
                        }
                    }
                });
    },

    /**
     * Adds avatar to our client side store
     *
     * @param avatar
     */
    _add: function (avatar) {
        if (avatar.isSystemAvatar()) {
            this.avatars.system.push(avatar);
        }
        else {
            this.avatars.custom.push(avatar);
        }
    },

    /**
     * Creates an avatar with the properties of the given avatar.
     *
     * @param {Object} instructions
     * ... {Number} cropperOffsetX
     * ... {Number} cropperOffsetY
     * ... {Number} cropperWidth
     *
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    createAvatarFromTemporary: function (instructions, options) {

        var instance = this;

        options = options || {};

        if (this.restUpdateTempUrl) {
            JIRA.SmartAjax.makeRequest({
                type: "POST",
                url: this._buildCompleteUrl(this.restUpdateTempUrl),
                data: JSON.stringify(instructions),
                contentType: "application/json",
                dataType: "json",
                success: function (data) {

                    // If no data is returned, no real avatar was created and the temporary avatar has just been updated with the cropping instructions
                    if (!data) {
                        data = {
                            id: instance.TEMP_ID,
                            isSelected: true
                        };
                    }
                    var avatar = JIRA.Avatar.createCustomAvatar(data);
                    instance._add(avatar);

                    if (options.success) {
                        options.success.call(this, data);
                    }
                },
                error: options.error
            });
        }
    },

    /**
     *
     * Creates temporary avatar on server
     *
     * @param {HTMLElement} fileInput
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    createTemporaryAvatar: function (fileInput, options) {
        // add the restParams as option
        options = AJS.$.extend(true, {}, options, { params: this.restParams });

        JIRA.AvatarUtil.uploadTemporaryAvatar(this.restCreateTempUrl, fileInput, options);
    },

    /**
     * Resets store with the Avatars created from the supplied JSON
     *
     * @param JSON avatar descriptors
     */
    _refresh: function (avatars) {

        var instance = this;

        instance.avatars.system = [];
        instance.avatars.custom = [];

        if (avatars.system) {
            jQuery.each(avatars.system, function (i, descriptor) {
                instance.avatars.system.push(JIRA.Avatar.createSystemAvatar(descriptor));
            });
        }

        if (avatars.custom) {
            jQuery.each(avatars.custom, function (i, descriptor) {
                instance.avatars.custom.push(JIRA.Avatar.createCustomAvatar(descriptor));
            });
        }
    },

    /**
     * Goes back to the server and retrievs all avatars
     *
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    refresh: function (options) {

        var instance = this;

        // Remember the temporary avatar if we have one
        var tempAvatar = this.getById(instance.TEMP_ID);

        options = options || {};

        JIRA.SmartAjax.makeRequest({
            url: this._buildCompleteUrl(this.restQueryUrl),
            error: options.error,
            success: function (avatars) {
                instance._refresh(avatars);
                if (tempAvatar) {
                    instance._add(tempAvatar);
                }
                if (options.success) {
                    options.success.apply(this, arguments);
                }
            }
        });
    },

    /**
     * Gets all avatars, custom and system
     *
     * @return {Object}
     * ... {Array<JIRA.Avatar>} system
     * ... {Array<JIRA.Avatar>} custom
     */
    getAllAvatars: function () {
        return this.avatars;
    },

    /**
     * Provides an array of all system avatars.
     *
     * @return the system avatars, never null.
     */
    getAllSystemAvatars: function () {
        return this.avatars.system;
    },

    /**
     * Provides an array of all system avatars.
     *
     * @return the custom avatars.
     */
    getAllCustomAvatars: function () {
        return this.avatars.custom;
    },

    /**
     * Gets rest url to update a single avatar
     *
     * @param avatar
     */
    getRestUrlForAvatar: function (avatar) {
        return this._buildCompleteUrl(this.restSingleAvatarUrl + "/" + avatar.getId());
    }
});
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarUtil.js' */
JIRA.AvatarUtil = {

    uploadUsingIframeRemoting: function (url, field, options) {
        options = options || {};

        var fileName = field.val(),
            form = new AJS.InlineAttach.Form(new AJS.InlineAttach.FileInput(field, false)),
            progress = form.addStaticProgress(fileName);

        //Add a new "File Input" to the form. We use the old input as part of a hidden form that we can submit to the
        //server in the background.
        var $oldInput = form.cloneFileInput();

        form.fileSelector.clear();

        //We only show progress after we are sure the upload will take longer than AJS.InlineAttach.DISPLAY_WAIT.
        var timer = new AJS.InlineAttach.Timer(function() {
            !this.cancelled && progress.show();
        }, this);

        var upload = new AJS.InlineAttach.FormUpload({
            $input: $oldInput,
            url: url,
            params: AJS.$.extend({}, options.params, {
                filename: fileName,
                atl_token: atl_token()
            }),
            scope: this,
            before: function() {
                !this.cancelled && progress.start();
            },
            success: function(val, status) {
                if (val.errorMessages && val.errorMessages.length) {
                    form.addErrorWithFileName(val.errorMessages[0], fileName, JIRA.AvatarUtil.getErrorTarget(form));
                } else if (options.success) {
                    options.success(val, status);
                }
            },
            error: function(text) {

                console.log(text);

                if (this.cancelled) {
                    return;
                }

                if (text.indexOf("SecurityTokenMissing") >= 0) {
                    form.addError(AJS.InlineAttach.Text.tr("upload.xsrf.timeout", fileName), JIRA.AvatarUtil.getErrorTarget(form));
                } else {
                    form.addError(AJS.InlineAttach.Text.tr("upload.error.unknown", fileName), JIRA.AvatarUtil.getErrorTarget(form));
                }
            },
            after: function() {

                timer.cancel();
                progress.remove();

                if (!this.cancelled) {
                    form.enable();
                }
            }
        });

        progress.onCancel(function() {
            upload.abort();
        });

        upload.upload();
    },

    uploadUsingFileApi: function (url, field, options) {

        var timer,
            upload,
            cancelled,
            file = field[0].files[0],
            form = new AJS.InlineAttach.Form(new AJS.InlineAttach.FileInput(field, false)),
            progress = form.addProgress(file);

        options = options || {};

        //We only show progress after we are sure the upload will take longer than AJS.InlineAttach.DISPLAY_WAIT.
        timer = new AJS.InlineAttach.Timer(function() {
            if (!cancelled) {
                progress.show();
            }
        });

        upload = new AJS.InlineAttach.AjaxUpload({
            file: file,
            params: AJS.$.extend({}, options.params, {
                filename: file.name,
                size: file.size,
                atl_token: atl_token()
            }),
            scope: this,
            url: url,
            before: function() {
                field.hide();
                !cancelled && progress.start();
            },
            progress: function(val) {
                progress.progress.$progress.parent().parent().show();
                !cancelled && progress.update(val);
            },
            success: function(val, status) {

                if (cancelled) {
                    return;
                }

                if (val.errorMessages && val.errorMessages.length) {
                    form.addErrorWithFileName(val.errorMessages[0], file.name, JIRA.AvatarUtil.getErrorTarget(form));
                } else if (status === 201) {
                    options.success(val, status);
                }
            },
            error: function(text, status) {


                if (status < 0) {
                    //This is a client error so just render it.
                    form.addError(text, JIRA.AvatarUtil.getErrorTarget(form));
                } else {
                    form.addError(AJS.InlineAttach.Text.tr("upload.error.unknown", file.name), JIRA.AvatarUtil.getErrorTarget(form));
                }

                if (options.error) {
                    options.error(text, status);
                }
            },
            after: function() {
                timer.cancel();
                progress.finish().remove();
                field.val("").show();
            }
        });

        upload.upload();

        progress.onCancel(function () {
            upload.abort();
        });
    },

    getErrorTarget: function (form) {
        return {
            $element: form.$form.find(".error")
        };
    },

    /**
     * Uploads temporary avatar using progress bars (if file API supported)
     *
     * @param {String} url - url to upload to, must accept any type, multipart etc
     * @param {HTMLElement} field - file input field containing file path
     * @param options
     * ... {Function} success
     * ... {Function} error
     * ... {Object} params additional query params to use in the upload request
     */
    uploadTemporaryAvatar: function (url, field, options) {
        if (AJS.InlineAttach.AjaxPresenter.isSupported(field)) {
            this.uploadUsingFileApi(url, field, options);
        } else {
            this.uploadUsingIframeRemoting(url, field, options);
        }
    }
};
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarPicker.js' */
;(function($) {

    /**
     * Creates/Renders avatar picker
     *
     * @class JIRA.AvatarPicker
     */
    JIRA.AvatarPicker = AJS.Control.extend({

        /**
         * @constructor
         * @param {Object} options
         * ... {JIRA.AvatarManager or something that implements same interface} avatarManager
         * ... {JIRA.AvatarPicker.Avatar or something that implements same interface} avatarRenderer
         * ... {JIRA.Avatar.LARGE | JIRA.Avatar.MEDIUM | JIRA.Avatar.SMALL} size
         */
        init: function (options) {
            this.avatarManager = options.avatarManager;
            this.avatarRenderer = options.avatarRenderer;
            this.imageEditor = options.imageEditor;
            this.size = options.size;
            this.selectCallback = options.select;
            this.cropperDialog = null;
            this.initialSelection = options.initialSelection;
        },

        /**
         * Renders avatar picker
         *
         * @param {Function} ready - a callback function that will be called when rendering is complete, the first
         * argument of this function will be the contents of the avatar picker. You can then append this element to wherever you
         * want the picker displayed
         */
        render: function (ready) {

            var instance = this;

            // we need to go to the server and get all the avatars first
            this.avatarManager.refreshStore({

                success: function () {
                    if (instance.cropperDialog instanceof JIRA.Dialog) {
                        instance.cropperDialog.hide();
                        delete instance.cropperDialog;
                    }
                    instance.element = $('<div id="jira-avatar-picker" />');

                    instance.element.html(JIRA.Templates.AvatarPicker.picker({
                        avatars: instance.avatarManager.getAllAvatarsRenderData(instance.size)
                    }));

                    instance._assignEvents("selectAvatar", instance.element.find(".jira-avatar button"));
                    instance._assignEvents("deleteAvatar", instance.element.find(".jira-delete-avatar"));
                    instance._assignEvents("uploader", instance.element.find("#jira-avatar-uploader"));

                    if (undefined !== instance.initialSelection) {
                        instance.getAvatarElById(instance.initialSelection).addClass("jira-selected-avatar");
                    }

                    // we are finished, call with picker contents
                    ready(instance.element);
                },
                error: function (xhr, error, textStatus, smartAjaxResult) {
                    instance.appendErrorContent(instance.element, smartAjaxResult);
                    ready(instance.element);
                }
            });
        },

        /**
         *
         * Gets the most useful error response from a smartAjaxResponse and appends it to the picker
         *
         * @param el
         * @param smartAjaxResult
         */
        appendErrorContent: function (el, smartAjaxResult) {
            try {
                var errors = JSON.parse(smartAjaxResult.data);

                if (errors && errors.errorMessages) {
                    $.each(errors.errorMessages, function (i, message) {
                        AJS.messages.error(el, {
                            body: AJS.escapeHTML(message),
                            closeable: false,
                            shadowed: false
                        });
                    });
                } else {
                    el.append(JIRA.SmartAjax.buildDialogErrorContent(smartAjaxResult, true));
                }
            } catch (e) {
                el.append(JIRA.SmartAjax.buildDialogErrorContent(smartAjaxResult, true));
            }
        },

        /**
         * Saves temporary avatar and invokes cropper
         *
         * @param {HTMLElement} field
         */
        uploadTempAvatar: function (field) {

            var instance = this;

            this.avatarManager.createTemporaryAvatar(field, {

                success: function (data) {

                    if (data.id) {
                        // We have an avatar and don't need to crop
                        instance.render(function () {
                            instance.selectAvatar(data.id);
                        });
                    } else {
                        field.val("");

                        instance.cropperDialog = new JIRA.Dialog({
                            id: "project-avatar-cropper",
                            width: 560,
                            content: function(ready) {
                                var $el = instance.imageEditor.render(data);
                                function disableSubmitButton() {
                                    var $button = $el.find("input[type=submit]");
                                    var $loader = $("<span class='icon throbber loading'></span>");
                                    $button.attr("aria-disabled", "true").attr("disabled", "");
                                    $button.before($loader);
                                    return function() {
                                        $loader.remove();
                                        $button.removeAttr("aria-disabled").removeAttr("disabled");
                                    };
                                }

                                instance.imageEditor.edit({
                                    confirm: function (instructions) {
                                        var reEnableSubmit = disableSubmitButton();
                                        instance.avatarManager.createAvatarFromTemporary(instructions, {
                                            success: function (data) {
                                                instance.render(function () {
                                                    instance.selectAvatar(data.id);
                                                });
                                            },
                                            error: reEnableSubmit
                                        });
                                    }
                                });
                                $el.find(".cancel").click(function() {
                                    instance.cropperDialog.hide();
                                });
                                ready($el);
                            }
                        });
                        instance.cropperDialog.bind("dialogContentReady", function() {
                            $(instance).trigger(JIRA.AvatarPicker.ImageEditor.LOADED);
                        });
                        instance.cropperDialog.bind("Dialog.hide", function() {
                            $(instance).trigger(JIRA.AvatarPicker.ImageEditor.DISMISSED);
                        });

                        instance.cropperDialog.show();
                    }
                },
                error: function () {
                    console.log(arguments);
                }
            });
        },

        /**
         * Gets avatar HTML element based on it's database id
         *
         * @param {String} id
         * @return {$}
         */
        getAvatarElById: function (id) {
            return this.element.find(".jira-avatar[data-id='" + id + "']");
        },

        /**
         * Selects avatar
         *
         * @param {String} id - avatar id
         */
        selectAvatar: function (id) {
            var avatar = this.avatarManager.getById(id);
            var instance = this;

            this.avatarManager.selectAvatar(this.avatarManager.getById(id), {
                error: function () {
                },
                success: function () {

                    instance.getAvatarElById(id).remove();

                    if (instance.selectCallback) {
                        instance.selectCallback.call(instance, avatar,
                                instance.avatarManager.getAvatarSrc(avatar, instance.size));
                    }
                }
            });
        },

        /**
         * Deletes avatar, shows confirmation before hand
         *
         * @param {String} id - avatar id
         */
        deleteAvatar: function (id) {

            var instance = this;

            if (confirm("Are you sure you want to delete avatar?")) {
                this.avatarManager.destroy(this.avatarManager.getById(id), {
                    error: function () {

                    },
                    success: function () {

                        var selectedAvatar = instance.avatarManager.getSelectedAvatar(),
                            $avatar = instance.getAvatarElById(id);

                        $avatar.fadeOut(function () {
                            $avatar.remove();
                        });

                        // if the avatar we have deleted is the selected avatar, then we want to set the selected avatar to be
                        // the default. This is done automagically in AvatarStore.
                        if (selectedAvatar.getId() !== id) {

                            instance.getAvatarElById(selectedAvatar.getId()).addClass("jira-selected-avatar");

                            instance.selectCallback.call(instance, selectedAvatar,
                                    instance.avatarManager.getAvatarSrc(selectedAvatar, instance.size), true);
                        }
                    }
                });
            }
        },

        _events: {
            uploader: {
                change: function (e, el) {
                    this.uploadTempAvatar(el);
                }
            },
            deleteAvatar: {
                click: function (e, el) {
                    this.deleteAvatar(el.attr("data-id"));
                }
            },
            selectAvatar: {
                click: function (e, el) {
                    // Don't select avatar if we click an overlay, such as delete icon
                    if (el[0].id === "select-avatar-button") {
                        this.selectAvatar(el.attr("data-id"));
                    }
                }
            }
        }
    });

    /**
     * Handles cropping of avatar
     *
     * @class JIRA.AvatarPicker.ImageEditor
     *
     */
    JIRA.AvatarPicker.ImageEditor = AJS.Control.extend({
        /**
         * Renders cropper
         *
         * @param {Object} data
         * ... {Number} cropperOffsetX
         * ... {Number} cropperOffsetY
         * ... {Number} cropperWidth
         */
        render: function (data) {
            this.element = $('<div id="avatar-picker-image-editor"/>').html(JIRA.Templates.AvatarPicker.imageEditor(data));
            return this.element;
        },

        /**
         * Initializes cropper
         *
         * @param {Object} options
         * ... {Function} confirm
         * ... {Function} cancel
         * ... {Function} ready
         */
        edit: function (options) {

            var instance = this,
                    avator = this.element.find(".avataror");

            options = options || {};

            avator.unbind();
            avator.bind("AvatarImageLoaded", function () {
                if (options.ready) {
                    options.ready();
                }
            });

            avator.find("img").load(function () {
                avator.avataror({
                    previewElement: instance.element.find(".jira-avatar-cropper-header"),
                    parent: instance.element
                });
            });

            this.element.find("#avataror").submit(function (e) {

                e.preventDefault();

                if (options.confirm) {
                    options.confirm({
                        cropperOffsetX: $("#avatar-offsetX").val(),
                        cropperOffsetY: $("#avatar-offsetY").val(),
                        cropperWidth: $("#avatar-width").val()
                    });
                }
            })
            .find(".cancel").click(function (e) {
                e.preventDefault();
                if (options.cancel) {
                    options.cancel();
                }
            });
        }

    });

    /**
     * Name of event fired when the image editor dialog is loaded and ready.
     */
    JIRA.AvatarPicker.ImageEditor.LOADED = "imageEditorLoaded";

    /**
     * Name of event fired when the image editor dialog is dismissed/actioned and unloaded.
     */
    JIRA.AvatarPicker.ImageEditor.DISMISSED = "imageEditorDismissed";


    /**
     * Creates project avatar picker
     *
     * @param options
     * ... {String} projectKey
     *
     * @return JIRA.AvatarPicker
     */
    JIRA.AvatarPicker.createUniversalAvatarPicker = function (options) {
        return new JIRA.AvatarPicker({
            avatarManager: JIRA.AvatarManager.createUniversalAvatarManager({
                projectKey: options.projectKey,
                projectId: options.projectId,
                defaultAvatarId: options.defaultAvatarId,
                avatarType: options.avatarType
            }),
            initialSelection: options.initialSelection,
            imageEditor: new JIRA.AvatarPicker.ImageEditor(),
            size: options.hasOwnProperty('avatarSize') ? options.avatarSize : JIRA.Avatar.LARGE,
            select: options.select
        });
    };

    /**
     * Creates project avatar picker
     *
     * @param options
     * ... {String} projectKey
     *
     * @return JIRA.AvatarPicker
     */
    JIRA.AvatarPicker.createProjectAvatarPicker = function (options) {
        return new JIRA.AvatarPicker({
            avatarManager: JIRA.AvatarManager.createProjectAvatarManager({
                projectKey: options.projectKey,
                projectId: options.projectId,
                defaultAvatarId: options.defaultAvatarId
            }),
            imageEditor: new JIRA.AvatarPicker.ImageEditor(),
            size: JIRA.Avatar.LARGE,
            select: options.select
        });
    };

    /**
     * Creates user avatar picker
     *
     * @param {Object} options
     * @param {String} options.username
     *
     * @return JIRA.AvatarPicker
     */
    JIRA.AvatarPicker.createUserAvatarPicker = function (options) {
        return new JIRA.AvatarPicker({
            avatarManager: JIRA.AvatarManager.createUserAvatarManager({
                username: options.username,
                defaultAvatarId: options.defaultAvatarId
            }),
            imageEditor: new JIRA.AvatarPicker.ImageEditor(),
            size: JIRA.Avatar.LARGE,
            select: options.select
        });
    };

    /**
     * Creates a project avatar picker dialog
     *
     * @param {Object} options
     * @param {HTMLElement | String} options.trigger - element that when clicked will bring up dialog
     * @param {String} options.projectKey
     * @param {String} options.projectId
     */
    JIRA.createUniversalAvatarPickerDialog = function (options) {
        var lastSelection = options.initialSelection || options.defaultAvatarId;

        var projectAvatarDialog = new JIRA.FormDialog({
            trigger: options.trigger,
            id: "project-avatar-picker",
            width: 600,
            stacked: true,
            content: function (ready) {

                var avatarPicker,
                        $dialogWrapper;

                $dialogWrapper = $('<div id="projectavatar-content-wrapper"/>');

                $("<h2 />").text( options.title || "Select a Project Avatar")
                        .appendTo($dialogWrapper);


                avatarPicker = JIRA.AvatarPicker.createUniversalAvatarPicker({
                    projectKey: options.projectKey,
                    projectId: options.projectId,
                    defaultAvatarId: options.defaultAvatarId,
                    initialSelection: lastSelection,
                    avatarType: options.avatarType,
                    avatarSize: options.avatarSize,
                    select: function (avatar, src, implicit) {
                        lastSelection = String(avatar.getId());

                        if (options.select) {
                            options.select.apply(this, arguments);
                        }
                        if (!implicit) {
                            projectAvatarDialog.hide();
                        }
                    }
                });

                avatarPicker.render(function (content) {
                    $dialogWrapper.append(content);
                    ready($dialogWrapper);
                });
            }
        });

        projectAvatarDialog._focusFirstField = function () {};
    };

    /**
     * Creates a project avatar picker dialog
     *
     * @param {Object} options
     * @param {HTMLElement | String} options.trigger - element that when clicked will bring up dialog
     * @param {String} options.projectKey
     * @param {String} options.projectId
     */
    JIRA.createProjectAvatarPickerDialog = function (options) {
        var projectAvatarDialog = new JIRA.FormDialog({
            trigger: options.trigger,
            id: "project-avatar-picker",
            width: 600,
            stacked: true,
            content: function (ready) {

                var avatarPicker,
                    $dialogWrapper;

                $dialogWrapper = $('<div id="projectavatar-content-wrapper"/>');

                $("<h2 />").text("Select a Project Avatar")
                        .appendTo($dialogWrapper);


                avatarPicker = JIRA.AvatarPicker.createProjectAvatarPicker({
                    projectKey: options.projectKey,
                    projectId: options.projectId,
                    defaultAvatarId: options.defaultAvatarId,
                    select: function (avatar, src, implicit) {
                        if (options.select) {
                            options.select.apply(this, arguments);
                        }
                        if (!implicit) {
                            projectAvatarDialog.hide();
                        }
                    }
                });

                avatarPicker.render(function (content) {
                    $dialogWrapper.append(content);
                    ready($dialogWrapper);
                });
            }
        });

        projectAvatarDialog._focusFirstField = function () {};
    };

    var avatarPickerData = WRM.data.claim("jira.webresources:avatar-picker.data");

    /**
     * Creates a project avatar picker dialog
     *
     * @param {Object} options
     * @param {HTMLElement | String} options.trigger - element that when clicked will bring up dialog
     * @param {String} options.projectKey
     * @param {String} options.projectId
     */
    JIRA.createUserAvatarPickerDialog = function (options) {

        if (avatarPickerData && avatarPickerData.isEnabled) {
            // SW-1977 - Defer and redirect to the Atlassian ID version.
            $(options.trigger).click(function(e) {
                var href = AJS.contextPath() + avatarPickerData.url;
                var separator = href.indexOf("?") > -1 ? "&" : "?";
                href += separator + "continue=" + encodeURIComponent(window.location.href);
                e.preventDefault();
                e.stopPropagation();
                AJS.reloadViaWindowLocation(href);
            });
            return;
        }

        var userAvatarDialog = new JIRA.FormDialog({
            trigger: options.trigger,
            id: "user-avatar-picker",
            width: 600,
            stacked: true,
            content: function (ready) {

                var avatarPicker,
                    $dialogWrapper;

                $dialogWrapper = $('<div id="useravatar-content-wrapper"/>');

                $("<h2 />").text("Select a User Avatar")
                        .appendTo($dialogWrapper);


                avatarPicker = JIRA.AvatarPicker.createUserAvatarPicker({
                    username: options.username,
                    defaultAvatarId: options.defaultAvatarId,
                    select: function (avatar, src, implicit) {

                        if (options.select) {
                            options.select.apply(this, arguments);
                        }

                        $(".avatar-image").attr("src", src);

                        if (!implicit) {
                            userAvatarDialog.hide();
                        }
                    }
                });

                avatarPicker.render(function (content) {
                    $dialogWrapper.append(content);
                    ready($dialogWrapper);
                });
            }
        });
    };

    // initialize user picker dialog
    $(function () {
        JIRA.createUserAvatarPickerDialog({
            trigger: "#user_avatar_image",
            username: $("#avatar-owner-id").text(),
            defaultAvatarId: $("#default-avatar-id").text()
        });
    });

})(window.jQuery);
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/GravatarUtil.js' */
/**
 * Helper methods for showing Gravatar-related help text.
 */
;(function() {
    AJS.namespace('JIRA.GravatarUtil');
    JIRA.GravatarUtil.showGravatarHelp = function(data) {
        // response is in the form of  { entry: [] }
        if (typeof(data) !== 'undefined' && typeof(data.entry) !== 'undefined') {
            // hide the "sign up" text and show the "log in" text
            AJS.$('.gravatar-signup-text').addClass('hidden');
            AJS.$('.gravatar-login-text').removeClass('hidden');
        }
    };

    var displayGravatarHelp = function() {
        var gravatarJsonUrl = AJS.$('#gravatar_json_url');
        if (gravatarJsonUrl.length) {
            // use JSONP to determine whether the user has a Gravatar
            AJS.$.ajax(gravatarJsonUrl.val(), {
                dataType: 'jsonp',
                success: JIRA.GravatarUtil.showGravatarHelp
            });
        }
    };

    AJS.$(document).ready(function() {
        if (AJS.$('#gravatar_help_params')) {
            displayGravatarHelp();
        }
    });
}());
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarPicker.soy' */
// This file was automatically generated from AvatarPicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.AvatarPicker.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.AvatarPicker == 'undefined') { JIRA.Templates.AvatarPicker = {}; }


JIRA.Templates.AvatarPicker.picker = function(opt_data, opt_ignored) {
  var output = '<form class="jira-avatar-upload-form aui top-label" action="#"><input name="id" value="10000" type="hidden" ><input name="pid" value="10000" type="hidden" ><div class="field-group"><label for="jira-avatar-uploader">' + soy.$$escapeHtml("Upload a new avatar") + '</label><input type="file" class="ignore-inline-attach" name="avatar" id="jira-avatar-uploader"/><div class="error"></div></div></form><div class="form-body"><ul class="jira-avatars">';
  var avatarList6 = opt_data.avatars.system;
  var avatarListLen6 = avatarList6.length;
  for (var avatarIndex6 = 0; avatarIndex6 < avatarListLen6; avatarIndex6++) {
    var avatarData6 = avatarList6[avatarIndex6];
    output += '<li class="jira-avatar jira-system-avatar ' + ((avatarData6.isSelected) ? 'jira-selected-avatar' : '') + '" title="Select this Avatar" data-id="' + soy.$$escapeHtml(avatarData6.id) + '"><button id="select-avatar-button" data-id="' + soy.$$escapeHtml(avatarData6.id) + '" class="jira-icon-button" title="' + soy.$$escapeHtml("Select this Avatar") + '"><img id="avatar-' + soy.$$escapeHtml(avatarData6.id) + '" src="' + soy.$$escapeHtml(avatarData6.src) + '" width="' + soy.$$escapeHtml(avatarData6.width) + '" height="' + soy.$$escapeHtml(avatarData6.height) + '" alt="' + soy.$$escapeHtml("Select this Avatar") + '"/></button></li>';
  }
  var avatarList29 = opt_data.avatars.custom;
  var avatarListLen29 = avatarList29.length;
  for (var avatarIndex29 = 0; avatarIndex29 < avatarListLen29; avatarIndex29++) {
    var avatarData29 = avatarList29[avatarIndex29];
    output += '<li class="jira-avatar jira-custom-avatar ' + ((avatarData29.isSelected) ? 'jira-selected-avatar' : '') + '" title="Select this avatar" data-id="' + soy.$$escapeHtml(avatarData29.id) + '"><button id="select-avatar-button" data-id="' + soy.$$escapeHtml(avatarData29.id) + '" class="jira-icon-button" title="' + soy.$$escapeHtml("Select this Avatar") + '"><img id="avatar-' + soy.$$escapeHtml(avatarData29.id) + '" src="' + soy.$$escapeHtml(avatarData29.src) + '" width="' + soy.$$escapeHtml(avatarData29.width) + '" height="' + soy.$$escapeHtml(avatarData29.height) + '" alt="' + soy.$$escapeHtml("Select this Avatar") + '" /></span><button class="jira-delete-avatar jira-icon-button" data-id="' + soy.$$escapeHtml(avatarData29.id) + '" title="' + soy.$$escapeHtml("Delete this Avatar") + '">' + soy.$$escapeHtml("Delete this Avatar") + '</button></li>';
  }
  output += '</ul></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.AvatarPicker.picker.soyTemplateName = 'JIRA.Templates.AvatarPicker.picker';
}


JIRA.Templates.AvatarPicker.imageEditor = function(opt_data, opt_ignored) {
  return '<form id="avataror" class="jira-avatar-cropper-form aui" action="/jira/secure/project/AvatarPicker.jspa"><input type="hidden" name="cropperOffsetX" id="avatar-offsetX" value="' + soy.$$escapeHtml(opt_data.cropperOffsetX) + '"><input type="hidden" name="cropperOffsetY" id="avatar-offsetY" value="' + soy.$$escapeHtml(opt_data.cropperOffsetY) + '"><input type="hidden" name="cropperWidth" id="avatar-width"  value="' + soy.$$escapeHtml(opt_data.cropperWidth) + '"><div class="jira-avatar-cropper-header"><p>' + soy.$$escapeHtml("Please select which part of the uploaded image you wish to use as the avatar.") + '</p></div><div class="form-body"><div class="avataror"><img src="' + soy.$$escapeHtml(opt_data.url) + '" height="300" /></div></div><div class="form-footer buttons-container"><div class="buttons"><input type="submit" class="aui-button aui-button-primary" value="' + soy.$$escapeHtml("Confirm") + '"><a class="aui-button aui-button-link cancel" href="#">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form>';
};
if (goog.DEBUG) {
  JIRA.Templates.AvatarPicker.imageEditor.soyTemplateName = 'JIRA.Templates.AvatarPicker.imageEditor';
}
;
;
/* module-key = 'jira.webresources:avatar-picker-trigger', location = '/includes/jira/admin/initAvatarPickerTrigger.js' */
(function () {


    var AvatarPickerContentRetriever = AJS.ContentRetriever.extend({

        init: function (avatarPicker) {
            this.avatarPicker = avatarPicker;
        },

        content: function (finished) {
            this.avatarPicker.render(function (el) {
                finished(jQuery("<div />").html(el));
            });
        },
        cache: function () {
            return false;
        },
        isLocked: function () {},
        startingRequest: function () {},
        finishedRequest: function () {}

    });


    var InlineAvatarPicker = AJS.InlineLayer.extend({

        init: function (options) {
            var instance = this;
            this.avatarPicker = JIRA.AvatarPicker.createProjectAvatarPicker({
                projectId: options.projectId,
                projectKey: options.projectKey,
                defaultAvatarId: options.defaultAvatarId,
                select: function (avatar, src, implicit) {
                    if (options.select) {
                        options.select.apply(this, arguments);
                    }
                    if (!implicit) {
                        instance.hide();
                    }

                    instance.offsetTarget().attr("src", src);
                    instance.offsetTarget().trigger("AvatarSelected");
                }
            });

            options.contentRetriever = new AvatarPickerContentRetriever(this.avatarPicker);

            jQuery(this.avatarPicker.imageEditor).bind(JIRA.AvatarPicker.ImageEditor.LOADED, function () {
                // todo: need to use prop() instead of attr() in master
                instance.setWidth(instance.layer().attr("scrollWidth"));
            });

            this._super(options);

            // Wrap the image in a little box to manage its appearance.
            var $triggerImg = this.offsetTarget();
            var $triggerContainer = jQuery("<span class='jira-avatar-picker-trigger'></span>");
            $triggerContainer.insertBefore($triggerImg).append($triggerImg);

            this._assignEvents("offsetTarget", $triggerContainer);

        },
        _events: {
            offsetTarget: {
                click: function (e) {
                    this.show();
                }
            }
        }
    });


    function initProjectAvatarPicker(ctx) {
        var trigger = jQuery(".jira-avatar-picker-trigger");
        var triggerImg = jQuery(".jira-avatar-picker-trigger img, img.jira-avatar-picker-trigger", ctx);
        var avatarIdField = jQuery(ctx).find("#avatar-picker-avatar-id");
        var avatarIconurlField = jQuery(ctx).find("#avatar-picker-iconurl");
        var avatarTypeElement = jQuery(ctx).find("#avatar-type");
        if ("" === avatarTypeElement.text()) return;
        JIRA.createUniversalAvatarPickerDialog({
            trigger: trigger,
            title: jQuery(ctx).find("#avatar-dialog-title").text(),
            projectId: jQuery(ctx).find("#avatar-owner-id").text(),
            projectKey: jQuery(ctx).find("#avatar-owner-key").text(),
            defaultAvatarId: jQuery(ctx).find("#default-avatar-id").text(),
            initialSelection: avatarIdField.val(),
            avatarSize: JIRA.Avatar.getSizeObjectFromName(jQuery(ctx).find("#avatar-size").text()),
            avatarType: avatarTypeElement.text(),
            select: function (avatar, src) {
                triggerImg.attr("src", src);
                avatarIconurlField.val(src);
                avatarIdField.val(avatar.getId());
            }
        });
    }

    function initProjectInlineAvatarPicker(ctx) {
        var $triggerImg = jQuery(".jira-inline-avatar-picker-trigger", ctx);

        if ($triggerImg.length) {
            new InlineAvatarPicker({
                offsetTarget: $triggerImg,
                projectId: jQuery(ctx).find("#avatar-owner-id").text(),
                projectKey: jQuery(ctx).find("#avatar-owner-key").text(),
                defaultAvatarId: jQuery(ctx).find("#default-avatar-id").text(),
                alignment: AJS.LEFT,
                width: 420, // Fits 7 avatars + the OSX choose file dialog min width.
                allowDownsize: true
            });
        }

    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initProjectAvatarPicker(context);
            initProjectInlineAvatarPicker(context);
        }
    });

})();;
;
/* module-key = 'jira.webresources:croneditor', location = '/includes/js/cron/croneditor.js' */
/*
Renders an element visible to the user
*/
function hideCronEdit(elementid)
{
    document.getElementById(elementid).style.display = 'none';
}

/*
Renders an element invisible to the user
*/
function showCronEdit(elementid)
{
    document.getElementById(elementid).style.display = '';
}

function toggleFrequencyControl(paramPrefix, setOriginal)
{
    var select = document.getElementById(paramPrefix + "interval");
    if(select.value == 0)
    {
        switchToOnce(paramPrefix, setOriginal);
    }
    else
    {
        switchToMany(paramPrefix, setOriginal);
    }
}

/*
Toggles the frequency controls to match 'once per day' mode
*/
function switchToOnce(paramPrefix, setOriginal)
{
    //make sure the frequency select is set correctly
    //set state
    hideCronEdit(paramPrefix + "runMany");
    showCronEdit(paramPrefix + "runOnce");
    if (setOriginal)
    {
        timesOnce[paramPrefix] = true;
    }
}

/*
Toggles the frequency controls to match 'many per day' mode
*/
function switchToMany(paramPrefix, setOriginal)
{
    //set state
    hideCronEdit(paramPrefix + "runOnce");
    showCronEdit(paramPrefix + "runMany");
    if (setOriginal)
    {
        timesOnce[paramPrefix] = false;
    }
}

function switchToDaysOfMonth(paramPrefix)
{
    hideCronEdit(paramPrefix + 'daysOfWeek');
    showCronEdit(paramPrefix + 'daysOfMonth');
    showCronEdit(paramPrefix + 'freqDiv');
    hideCronEdit(paramPrefix + 'innerFreqDiv');
    hideCronEdit(paramPrefix + 'advanced');
    switchToOnce(paramPrefix, false);
}

function switchToDaysOfWeek(paramPrefix)
{
    showCronEdit(paramPrefix + 'daysOfWeek');
    hideCronEdit(paramPrefix + 'daysOfMonth');
    showCronEdit(paramPrefix + 'freqDiv');
    showCronEdit(paramPrefix + 'innerFreqDiv');
    hideCronEdit(paramPrefix + 'advanced');
    switchToOriginal(paramPrefix);
}

function switchToDaily(paramPrefix)
{
    hideCronEdit(paramPrefix + 'daysOfWeek');
    hideCronEdit(paramPrefix + 'daysOfMonth');
    showCronEdit(paramPrefix + 'freqDiv');
    showCronEdit(paramPrefix + 'innerFreqDiv');
    hideCronEdit(paramPrefix + 'advanced');
    switchToOriginal(paramPrefix);
}

function switchToAdvanced(paramPrefix)
{
    hideCronEdit(paramPrefix + 'daysOfWeek');
    hideCronEdit(paramPrefix + 'daysOfMonth');
    hideCronEdit(paramPrefix + "runOnce");
    hideCronEdit(paramPrefix + "runMany");
    hideCronEdit(paramPrefix + 'freqDiv');
    showCronEdit(paramPrefix + 'advanced');

}

function switchToOriginal(paramPrefix)
{
    if (timesOnce[paramPrefix])
    {
        switchToOnce(paramPrefix, false);
    }
    else
    {
        switchToMany(paramPrefix, false);
    }
}
;
;
/* module-key = 'com.atlassian.jira.jira-quick-edit-plugin:loading-indicator', location = 'js/util/loading-indicator.js' */
define('quick-edit/util/loading-indicator',[
    'jira/loading/loading',
    'jira/flag'
], function (
    Loading,
    Flag
) {
    var dim = AJS.dim;
    var undim = AJS.undim;

    return {
        showLoadingIndicator: function () {
            dim();
            Loading.showLoadingIndicator();
        },

        hideLoadingIndicator: function (showErrorFlag) {
            undim();
            Loading.hideLoadingIndicator();
            if (showErrorFlag) {
                Flag.showErrorMsg(null, "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.");
            }
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue-bootstrap', location = 'js/init/create-bootstrap-wrm.js' */
require([
    'jquery',
    'underscore',
    'wrm/require',
    'quick-edit/util/loading-indicator',
    'jira/ajs/keyboardshortcut/keyboard-shortcut-toggle'
], function (
    jQuery,
    _,
    wrmRequire,
    LoadingIndicator,
    KeyboardShortcutToggle
) {
    var showLoadingIndicator = function () {
        KeyboardShortcutToggle.disable();
        LoadingIndicator.showLoadingIndicator();
    };
    var hideLoadingIndicator = function () {
        LoadingIndicator.hideLoadingIndicator(true);
        KeyboardShortcutToggle.enable();
    };

    var subtaskTrigger;

    var createIssueDialogLoading = false;
    jQuery(document).on("simpleClick", ".create-issue, .create-issue-type", function(e) {
        e.preventDefault();
        if( !createIssueDialogLoading ) {
            createIssueDialogLoading = true;
            showLoadingIndicator();
            var resourceKey = 'wr!com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue';
            var wrmRequireDeferred = wrmRequire([resourceKey]);
            wrmRequireDeferred.then(onDone.bind(undefined, e), function onFail() {
                hideLoadingIndicator();
                createIssueDialogLoading = false;
            });
        }
    });
    var onDone = function (e) {
        var InitCreateDialogs = require('quick-edit/init/create');
        InitCreateDialogs.initIssueDialog(e);

        KeyboardShortcutToggle.enable();
        createIssueDialogLoading = false;
    };

jQuery(function () {
    subtaskTrigger = document.getElementById("stqc_show");

    // remove old subtask form
    if (subtaskTrigger) {
        subtaskTrigger.onclick = null;
    }
});

    var createSubtaskDialogLoading = false;
    jQuery(document).on("simpleClick", ".issueaction-create-subtask", function(e) {
        e.preventDefault();
        if (!createSubtaskDialogLoading) {
            createSubtaskDialogLoading = true;
            showLoadingIndicator();
            var resourceKey = 'wr!com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue';
            var wrmRequireDeferred = wrmRequire([resourceKey]);
            wrmRequireDeferred.then(onDoneSubtask, function onFail() {
                hideLoadingIndicator();
                createSubtaskDialogLoading = false;
            });
        }
    });
    var onDoneSubtask = function (e) {
        var InitCreateDialogs = require('quick-edit/init/create');
        InitCreateDialogs.initSubtaskDialog(e);

        KeyboardShortcutToggle.enable();
        createSubtaskDialogLoading = false;
    }
});
;
;
/* module-key = 'jira.webresources:jira-page-atl-prefetch', location = '/includes/jira/page/prefetch.js' */
define('jira/page/atl/prefetch', [
    'jira/util/data/meta',
    'jira/data/local-storage',
    'jira/ajs/dark-features',
    'jquery'
], function definePrefetchResource(meta,
    storage,
    darkFeatures,
    jQuery
) {
    /**
     * A module for pre-fetching resources for given page before it is really visited.
     * <link rel="prefetch" /> is used to instruct browser which resources to pre download.
     * Currently used to prefetch view issue resources.
     * @exports jira/issue/resources-prefetch
     */
    'use strict';

    var SESSION_KEY = 'jira.issue.prefetch.last.superbatch';
    var stateToken = _getStateToken();

    //
    // Private functions
    //
    function _getStateToken() {
        //lets use last super batch url as token with date as browser most probably removed entries from cache
        var now = new Date();
        var dateStr = now.getFullYear().toString() + now.getMonth().toString() + now.getDate().toString();
        var superbatch = jQuery('head > script').filter(function findSuperbatch(a, b) {return b.src.indexOf('/_super') > 0;});
        return (superbatch.length > 0 ? superbatch[0].src : 'empty') + dateStr;

    }

    function _addPrefetchTag(url) {
        jQuery('<link />', {
            rel: 'prefetch',
            href: url
        }).appendTo('head');
    }

    /**
     * @param {Object} issueMenuData - data for view issue menu.
     * @param {Object} [issueMenuData.sections] - optional section in view issue menu.
     */
    function _getLastIssueFromMenu(issueMenuData) {
        var sections = issueMenuData.sections;
        if (!sections) {
            return;
        }
        var recentIssues = sections.filter(function filterMenu(menuItem) {return menuItem.id === 'issues_history_main';});
        if (recentIssues.length && recentIssues[0].items.length !== 0) {
            var lastIssue = recentIssues[0].items[0];
            return lastIssue.url;
        }
    }

    function _addPrefetchForRegex(response, regex) {
        var matchResult;
        while (matchResult = regex.exec(response)) {
            var url = matchResult[1].replace(/&amp;/g, '&');
            _addPrefetchTag(url);
        }
    }

    function _rememberFetchState() {
        storage.setItem(SESSION_KEY, stateToken);

    }

    function _parsePageAndInsertLinks(data) {
        _addPrefetchForRegex(data, /<script.+?src="(.+?)".+?<\/script>/g);
        _addPrefetchForRegex(data, /<link.+?rel="stylesheet".+?href="(.+?)".+?>/g);
        _rememberFetchState();
    }

    function _shouldFetchResources() {
        if (!darkFeatures.isEnabled('jira.issue.prefetch')) {
            //don't fetch if dark feature is not enabled
            return false;
        }
        if (jQuery('#isNavigator').length === 1) {
            //don't fetch on navigator as this has the same resources as issue
            _rememberFetchState();
            return false;
        }
        else if (meta.get('issue-key')) {
            //don't fetch on issue page
            _rememberFetchState();
            return false;
        }
        else {
            //fetch if current state token is different for stored in local storage
            return stateToken !== storage.getItem(SESSION_KEY);
        }
    }
    function _prefetchResourcesForLastIssue(data) {
        var issueUrl = _getLastIssueFromMenu(data);
        if (issueUrl) {
            prefetchResourcesForUrl(issueUrl);
        }
    }
    //
    // Public API functions
    //

    function prefetchResourcesForUrl(url) {
        jQuery.get(url, _parsePageAndInsertLinks);
    }


    function prefetchViewIssueResources() {
        if (_shouldFetchResources()) {
            //only execute if we are on view issue context and
            jQuery.ajax(
                {
                    url: AJS.contextPath() + '/rest/api/1.0/menus/find_link?inAdminMode=false',
                    dataType: 'json'
                }).done(_prefetchResourcesForLastIssue);
        }
    }

    return {
        /**
         * Adds prefetch tags for resources included by page at given URL
         * @param {String} url
         */
        prefetchResourcesForUrl: prefetchResourcesForUrl,
        /**
         * Adds prefetch tags for view issue resources.
         * It will work only if user has visited any issue in the past so it is accessible from latest issues menu.
         */
        prefetchViewIssueResources: prefetchViewIssueResources
    };
});
;
;
/* module-key = 'jira.webresources:init-jira-page-atl-prefetch', location = '/includes/jira/page/initPrefetch.js' */
require(['jira/page/atl/prefetch', 'jquery'], function executePrefetch(resourcePrefetch, $) {
    $(window).on('load', resourcePrefetch.prefetchViewIssueResources.bind(resourcePrefetch));
});
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:update-plugin-banner-resources', location = 'js/banner/update-hipchat-link-banner.js' */
(function ($) {
    AJS.toInit(function () {

        var HIPCHAT_ADMIN_BANNER_COOKIE_KEY = "HIPCHAT_ADMIN_BANNER_DISMISS_2";
        var warningMsg;

        if (!isHipChatConfigurationPage() && AJS.Meta.get("is-admin") && !isAlreadyDismissed()) {

            $.ajax({
                url: AJS.contextPath() + '/rest/hipchat/integrations/1.0/configuration/status',
                dataType: 'json',
                cache: false
            }).done(function (data) {

                if (data.requiresManualInstallation || data.v1) {
                    warningMsg = showWarningMsg(data);
                }
            });

        }

        function showWarningMsg(data) {
            var html = JIRA.Templates.HipChat.Banner.updateHipChatLink({removeV1link: !data.v2 && data.v1});
            var warningMsg = JIRA.Messages.showWarningMsg(html);
            $(document).on("click", "#remove-hipchat-v1-link", removeHipChatLink);
            $(document).on("aui-flag-close", ".aui-flag", dismissPopUp);
            return warningMsg;
        }

        function isHipChatConfigurationPage() {
            return window.location.toString().indexOf("/plugins/servlet/hipchat/configure") > 0;
        }

        function dismissPopUp(e) {

            // The aui flag sends all the close events, that is why we need to filter
            // to the flag that has my container
            if ($(e.target).find(".hipchat-update-banner").length > 0) {
                AJS.Cookie.save(HIPCHAT_ADMIN_BANNER_COOKIE_KEY, true);
            }
        }

        function isAlreadyDismissed() {
            return AJS.Cookie.read(HIPCHAT_ADMIN_BANNER_COOKIE_KEY) == "true";
        }


        function removeHipChatLink(e) {
            e.preventDefault();

            $.ajax({
                url: AJS.contextPath() + '/rest/hipchat/integrations/1.0/configuration/v1',
                cache: false,
                type: "DELETE"
            }).error(function (error) {

                if(warningMsg){
                    warningMsg.hide();
                }

                JIRA.Messages.showErrorMsg(AJS.format("We couldn\'\'t find your integration. If the problem persists, contact Atlassian Support.\u003cbr/\u003e Error Status [{0}]", error.status));

            }).done(function (data) {

                if(warningMsg){
                    warningMsg.hide();
                }

                JIRA.Messages.showSuccessMsg("Integration has been removed successfully");
            });
        }
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:update-plugin-banner-resources', location = 'soy/banner/update-hipchat-link-banner.soy' */
// This file was automatically generated from update-hipchat-link-banner.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.Banner.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.Banner == 'undefined') { JIRA.Templates.HipChat.Banner = {}; }


JIRA.Templates.HipChat.Banner.updateHipChatLink = function(opt_data, opt_ignored) {
  return '<div class="hipchat-update-banner"><b>' + soy.$$escapeHtml("HipChat Integration is out of date") + '</b><p>' + soy.$$escapeHtml("Update to take full advantage of the latest features.") + '</p><p/><a href="' + soy.$$escapeHtml("/jira" + '/plugins/servlet/hipchat/configure') + '">' + soy.$$escapeHtml("Update Now!") + '</a>' + ((opt_data.removeV1link) ? '<a id="remove-hipchat-v1-link">' + soy.$$escapeHtml("Remove Integration") + '</a>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Banner.updateHipChatLink.soyTemplateName = 'JIRA.Templates.HipChat.Banner.updateHipChatLink';
}
;
;
/* module-key = 'com.atlassian.labs.plugins.quickreload.reloader:qr-batched-mode-twizzler', location = 'batchedmode/quickreload-batchedmode-switcher.js' */
;(function($, AJS) {
    if(!$) {
        console.warn("Could not find jQuery, QuickReload batch mode switcher not enabled");
        return;
    }
    if(!AJS) {
        console.warn("Could not find AJS, QuickReload batch mode switcher not enabled");
        return;
    }
    if(!$.isFunction(AJS.whenIType)) {
        console.warn("Could not find AJS.whenIType, QuickReload batch mode switcher not enabled");
        return;
    }

    //From underscore
    var debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;

        var later = function() {
            var last = Date.now() - timestamp;

            if (last < wait && last >= 0) {
                timeout = setTimeout(later, wait - last);
            } else {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                    if (!timeout) context = args = null;
                }
            }
        };

        return function() {
            context = this;
            args = arguments;
            timestamp = Date.now();
            var callNow = immediate && !timeout;
            if (!timeout) timeout = setTimeout(later, wait);
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }

            return result;
        };
    };

    var searchForContextPath = function() {
        if($.isFunction(AJS.contextPath)) {
            return AJS.contextPath();
        } else if (AJS.Meta && $.isFunction(AJS.Meta.get)) {
            try {
                return AJS.Meta.get("context-path");
            } catch(ignored) {}
        }

        return null;
    };

    var getCurrentBatchModeStateUrl = function(contextPath) {
        return contextPath + "/rest/qr/1.0/batching";
    };

    var getUpdateBatchModeUrl = function(contextPath, enableBatching) {
        return contextPath + "/rest/qr/1.0/batching/setState?enabled=" + !!enableBatching;
    };

    var tryGrabAuiFlag = function() {
        try {
            if($.isFunction(require)) {
                return require("aui/flag");
            }
        } catch(notFoundException) {}

        return null;
    };

    var getToastSuccessTitle = function(newBatchedModeState) {
        if(!!newBatchedModeState) {
            return "Production mode";
        } else {
            return "Dev mode";
        }
    };

    var getToastSuccessMessageHtml = function(newBatchedModeState) {
        if(!!newBatchedModeState) {
            return "Web resource batching and caching enabled";
        } else {
            return "Disabled web resource batching and caching";
        }
    };

    var toastSuccess = function(title, messageHtml) {
        toastMessage(title, messageHtml, true);
    };

    var toastError = function(title, messageHtml) {
        toastMessage(title, messageHtml, false);
    };

    var messageId = "quickreload-flag";
    var toastMessage = function(title, messageHtml, isSuccess) {
        var auiFlag = tryGrabAuiFlag();
        if(auiFlag) {
            auiFlag({
                type: !!isSuccess ? "success" : "error",
                title: title,
                body: messageHtml,
                persistent: false,
                close: "auto"
            });
        } else if(AJS.messages && $.isFunction(AJS.messages.success)) {
            var messageFunc;
            if(!!isSuccess) {
                messageFunc = AJS.messages.success;
            } else {
                messageFunc = AJS.messages.error;
            }

            var $message = $(messageFunc.call(AJS.messages, {
                title: title,
                body: messageHtml,
                id: messageId,
                fadeout: true,
                delay: 3000
            }));

            $("#" + messageId).remove();
            $("body").append($message);
        } else {
            alert(title);
        }
    };

    $(function() {
        var contextPath = searchForContextPath();
        if(!contextPath) {
            console.warn("Failed to determine context path, QuickReload batch mode switcher not enabled");
            return;
        }

        var batchingEnabledState = false;
        //Fetch initial state
        $.get(getCurrentBatchModeStateUrl(contextPath)).done(function(data) {
            batchingEnabledState = data.batchingEnabled;
        });

        var debouncedToggleBatchingCallback = debounce(function() {
            $.get(getUpdateBatchModeUrl(contextPath, !batchingEnabledState))
                .done(function(data) {
                    batchingEnabledState = data.batchingEnabled;
                    var successTitle = getToastSuccessTitle(batchingEnabledState);
                    var successMessageHtml = getToastSuccessMessageHtml(batchingEnabledState);
                    toastSuccess(successTitle, successMessageHtml);
                })
                .fail(function(xhr, textStatus) {
                    if(textStatus !== "abort") {
                        var batchingStateStr = batchingEnabledState ? "enabled" : "disabled";
                        toastError("Failed to update batch mode state (current state: " + batchingStateStr + ")");
                    }

                });
        }, 2000, true);

        AJS.whenIType("b").execute(debouncedToggleBatchingCallback);
    });
})((AJS && AJS.$) || $, AJS);;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:newsletter-signup-tip', location = 'static/components/newsletter/NewsletterSignup.soy' */
// This file was automatically generated from NewsletterSignup.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }


JIRA.Templates.newsletterSignupTip = function(opt_data, opt_ignored) {
  return '<div><p>' + soy.$$escapeHtml(opt_data.description) + '</p>' + aui.form.form({action: '#', isTopLabels: true, extraClasses: 'insiders-signup-form', content: '' + aui.form.textField({id: 'jira-newsletter-user-email', placeholderText: '' + soy.$$escapeHtml("Email address"), value: opt_data.userEmail}) + aui.form.buttons({content: '' + aui.form.submit({type: 'primary', text: '' + soy.$$filterNoAutoescape("Sign me up")}) + aui.form.linkButton({text: '' + soy.$$escapeHtml("No thanks")})})}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.newsletterSignupTip.soyTemplateName = 'JIRA.Templates.newsletterSignupTip';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:newsletter-signup-tip', location = 'static/components/newsletter/NewsletterSignup.js' */
define('jira/newsletter/signuptip', [
    'jquery'
], function(
    $
) {

    // taken from setup-mac-util.js
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address without &
    var emailRegex = /^[a-zA-Z0-9.!#$%'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

    function validateEmail(email) {
        if (email.length > 255) {
            return false;
        }
        return emailRegex.test(email);
    }

    return {
        render : function (newsletterFormDetails, helpTipOptions) {
            var defaults = {
                anchor: "#user-options",
                isSequence: false,
                showCloseButton: false
            };

            if (newsletterFormDetails.isBusinessOnly) {
                defaults.id = "business-newsletter-signup-tip";
                defaults.title = "Atlassian for Business Teams";
                defaults.bodyHtml = JIRA.Templates.newsletterSignupTip({
                    userEmail: newsletterFormDetails.userEmail,
                    description: "Atlassian gets down to business. Get our view on productivity for business teams. You\'ll get business-related content, best practices and product announcements to unleash the potential in your marketing, HR, finance, legal and sales teams."
                });
            } else {
                defaults.id = "newsletter-signup-tip";
                defaults.title = "JIRA Insiders";
                defaults.bodyHtml = JIRA.Templates.newsletterSignupTip({
                    userEmail: newsletterFormDetails.userEmail,
                    description: "Stay up-to-date with the latest JIRA tips, tricks, and exclusive inside jokes. All this and more in JIRA Insiders, delivered every month from our inbox to yours."
                });
            }
            var tip = new AJS.HelpTip($.extend(defaults, helpTipOptions));
            if(tip.isDismissed()) {
                return;
            }

            tip.show();

            AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.shown" });

            var $body = $("body");
            $body.on("submit", "form.aui.insiders-signup-form", function (e) {
                e.preventDefault();

                var $form = $(this);
                $form.find(".error").remove();

                var $emailInput = $form.find("#jira-newsletter-user-email");
                var email = $emailInput.val();
                if (validateEmail(email)) {
                    $.ajax({
                        type: 'POST',
                        url: AJS.format(newsletterFormDetails.formUrl, encodeURI(email)),
                        dataType: 'json'
                    }).success(function() {
                        AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.submitted" });
                    }).error(function(xhr) {
                        AJS.trigger('analyticsEvent', {
                            name: "jira.newsletter.signuptip.error",
                            data: {
                                statusCode: xhr.status
                            }
                        });
                    });

                    if(newsletterFormDetails.userEmail !== email) {
                        AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.email.changed" });
                    }

                    tip.dismiss("newslettersubscribed");
                }
                else {
                    AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.email.validationerror" });
                    $emailInput.after(aui.form.fieldError({message: "Please enter a valid e-mail address."}));
                }
            });

            $body.on("click", "form.aui.insiders-signup-form a.cancel", function (e) {
                e.preventDefault();
                AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.dismissed" });
                tip.dismiss("newslettercancelled");
            });
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:newsletter-signup-tip', location = 'static/components/newsletter/initNewsletterSignup.js' */
define('jira/newsletter/init-signup', [
    'jira/newsletter/signuptip'
], function (NewsletterSignup) {
    return function () {
        var newsletterSignupData = WRM.data.claim("com.atlassian.jira.jira-header-plugin:newsletter-signup-tip.newsletterSignup");

        if (newsletterSignupData && newsletterSignupData.showNewsletterTip) {
            NewsletterSignup.render({
                userEmail: newsletterSignupData.userEmail,
                formUrl: newsletterSignupData.formUrl,
                isBusinessOnly: newsletterSignupData.isBusinessOnly
            });
        }
    };
});

require([
    'jquery',
    'jira/newsletter/init-signup'
], function ($,
    InitNewsletterSignup) {
    $(InitNewsletterSignup);
});

;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/dialog.js' */
define('jira/admin-helper/dialog', [
    'jquery',
    'jira/dialog/dialog',
    'jira/focus/set-focus'
], function (
    $,
    Dialog,
    setFocus
) {

    return Dialog.extend({

        _getDefaultOptions: function () {
            return $.extend(this._super(), {
                cached: false,
                widthClass: "large",
                stacked: true
            });
        },

        defineResources: function() {
            this._super();
            this.requireResource("com.atlassian.jira.plugins.jira-admin-helper-plugin:whereismycf-resources");
        },

        decorateContent: function () {

            var instance = this;

            // init the close link
            this.get$popupContent().find(".cancel").click(function (e) {
                instance.hide();
                e.preventDefault();
            });
        },

        _onShowContent: function () {
            this._super();
            if (Dialog.current === this) {
                var triggerConfig = new setFocus.FocusConfiguration();
                triggerConfig.context = this.get$popup()[0];
                triggerConfig.parentElementSelectors = ['.form-body'];
                setFocus.pushConfiguration(triggerConfig);
                setFocus.triggerFocus();
            }
        },

        hide: function (undim) {

            if (this._super(undim) === false) {
                return false;
            }
            setFocus.popConfiguration();
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/notification-helper-init.js' */
require([
    'jquery',
    'jira/admin-helper/dialog',
    'jira/util/data/meta'
], function (
    $,
    Dialog,
    Meta
) {
    if (Meta.get("is-admin")) {

        $(document).delegate(".notificationhelper-trigger", "click", function (event) {
            event.preventDefault();
            new Dialog({
                id: "notification-helper-dialog",
                content: function content(callback) {
                    var dialog = this;
                    require(['jira/admin-helper/notification-helper/content-loader'],
                        function (ContentLoader) {
                            ContentLoader.loadContent(dialog, callback);
                        });
                }
            }).show();
        });
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/permission-helper-init.js' */
require([
    'jquery',
    'jira/admin-helper/dialog',
    'jira/util/data/meta'
], function (
    $,
    Dialog,
    Meta
) {
    if (Meta.get("is-admin")) {

        $(document).delegate(".permissionhelper-trigger", "click", function (event) {
            event.preventDefault();

            new Dialog({
                id: "permission-helper-dialog",
                content: function content(callback) {
                    var dialog = this;
                    require(['jira/admin-helper/permission-helper/content-loader'],
                        function (ContentLoader) {
                            ContentLoader.loadContent(dialog, callback);
                        });
                }
            }).show();
        });
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/whereismycf-init.js' */
require([
    'jquery',
    'jira/admin-helper/dialog',
    'jira/util/data/meta',
    'jira/dialog/dialog'
], function (
    $,
    Dialog,
    Meta,
    JiraDialog
) {
    if (Meta.get("is-admin")) {
        var LABEL = "Where is my field?";

        $(document).delegate(".whereismycf-trigger", "click", function (event) {
            event.preventDefault();
            new Dialog({
                id: "whereismycf-dialog",
                content: function content(callback) {
                    var dialog = this;
                    require(['jira/admin-helper/whereismycf/content-loader'],
                        function (ContentLoader) {
                            ContentLoader.loadContentForView(dialog, callback);
                        });
                }
            }).show();

        });
        // hook into the quick-edit
        $(document).bind("showLayer", function (event, control, hash) {
            if (control == "inlineDialog" && hash.popup.attr("id") == "inline-dialog-field_picker_popup") {
                if (hash.popup.find(".whereismycf-qfpicker-link").length == 0) {
                    var thelink = $("<a href='#' class='whereismycf-qfpicker-link'>" + LABEL + "</a>").appendTo(hash.popup.find(".qf-picker-header dl"));
                    thelink.click(function (event) {
                        event.preventDefault();
                        hash.hide();
                        eventsAndDecouplingInJavaScriptAreSoooAwesome();
                        var currentDialog = JiraDialog.current;
                        new Dialog({
                            id: "whereismycf-dialog",
                            content: function content(callback) {
                                var dialog = this;
                                require(['jira/admin-helper/whereismycf/content-loader'],
                                    function (ContentLoader) {
                                        ContentLoader.loadContentForEditAndCreate(dialog, currentDialog, callback);
                                    });
                            }
                        }).show();

                    });
                }
            }
        });

        function eventsAndDecouplingInJavaScriptAreSoooAwesome() {
            // we're doing this because LayerManager wants to outsmart the world by deciding what to hide and what not...
            // and InlineDialog (and everything else in AUI) wants to outsmart the world by applying stupid timeouts to everything...
            // but ultimately you can outsmart every smartass in the JS land just by setting global variables to null! BUAHAHAHAHAHAHA
            AJS.InlineDialog.current = null;
        }
    }
});;
;
/* module-key = 'com.atlassian.jira-core-project-templates:jira-core-project-templates-resources', location = '/soy/CoreProjectTemplates.soy' */
// This file was automatically generated from CoreProjectTemplates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.CoreTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }
if (typeof JIRA.Templates.ProjectTemplates.CoreTemplates == 'undefined') { JIRA.Templates.ProjectTemplates.CoreTemplates = {}; }


JIRA.Templates.ProjectTemplates.CoreTemplates.taskManagementInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Create simple tasks, organize them and get them done. You can use this project to manage your tasks or assign them to someone else.", projectTemplate: 'taskManagement'});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.taskManagementInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.taskManagementInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.projectManagementInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Create your tasks, organize and track their progress, and deliver your work on time. Estimations and time tracking allow you to report on where your project is at any stage.", projectTemplate: 'projectManagement'});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.projectManagementInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.projectManagementInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.processManagementInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Create your tasks and track them at every step, from start to finish. You can use this project to review documentation, approve expenses, or other processes.", projectTemplate: 'processManagement'});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.processManagementInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.processManagementInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.boardBetaInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Visualize work across your team with a board.", projectTemplate: 'projectManagement', issueTypesHtml: '' + JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType(null)});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.boardBetaInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.boardBetaInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog = function(opt_data, opt_ignored) {
  return '<div><div class="top-panel"><p>' + soy.$$escapeHtml(opt_data.description) + '</p></div><div class="left-panel"><h6>' + soy.$$escapeHtml("Issue Types") + '</h6><ul class="project-template-issuetype-list">' + ((opt_data.issueTypesHtml != null) ? soy.$$filterNoAutoescape(opt_data.issueTypesHtml) : JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType(null) + JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType(null)) + '</ul></div><div class="right-panel"><h6>' + soy.$$escapeHtml("Workflow") + '</h6><div class="workflow ' + soy.$$escapeHtml(opt_data.projectTemplate) + '"></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.issueType = function(opt_data, opt_ignored) {
  return '<li><span class="issuetype-list-label"><span class="issuetype-icon ' + soy.$$escapeHtml(opt_data.iconKey) + '"></span><span class="issuetype-name">' + soy.$$escapeHtml(opt_data.label) + '</span></span></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.issueType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.issueType';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.issueType({iconKey: 'task', label: "Task"});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.issueType({iconKey: 'subtask', label: "Sub-task"});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-confluence-plugin:issue-link-confluence-js', location = 'js/issuelink-confluence.js' */
/**
 * Initialises OAuth authentication for Confluence Application Links. Requires the following elements:
 * <div class="issue-link-applinks-authentication-message"></div>
 */
(function ($) {

    var settings = {
        getCurrentAppId: function (context) {
            return $("#issue-link-confluence-app-id", context).val();
        },
        shouldExecute: function (context) {
            return $("#confluence-page-link", context).length !== 0;
        },
        getIssueId: function (context) {
            return $("input[name=id]", context).val();
        }
    };

    JIRA.bind(JIRA.Events.NEW_PAGE_ADDED, function (e, context) {
        IssueLinkAppLinks.init(settings, context);
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-confluence-plugin:confluence-page-resource', location = 'js/ConfluencePageSearch.js' */
AJS.$(function ($) {
    var confluenceSearchDialog =  new JIRA.FormDialog({
        id: "confluence-page-search-dialog",
        trigger: "#confluence-page-link .confluence-search-trigger",
        widthClass: "large",
        height: "565px",
        content: function (render) {
            var dialog = this;
            JIRA.SmartAjax.makeRequest({
                url: contextPath + "/rest/confluenceIssueLink/1/confluence/applink",
                complete: function (xhr, textStatus, smartAjaxResult) {
                    if (smartAjaxResult.successful) {
                        var appLinks = smartAjaxResult.data.applicationLinks;
                        render(JIRA.Templates.ConfluencePageSearch.result({appLinks: appLinks}));

                        initAppLinks(dialog).done(function (context, helper) {
                            initSearchDialog(context, helper);
                            $("#link-search-text", context).focus();
                        });
                    } else {
                        AJS.messages.error("#search-results-table", {
                            body: "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.",
                            closeable: false
                        });
                        render();
                    }
                }
            });
        },
        submitHandler: function(e, callback){
            e.preventDefault();
            $("#search-panel-button").click().removeAttr("disabled");
            callback();
        }
    });

    function initSearchDialog($dialog, helper) {
        // Bind the select drop-down
        $("#confluence-app-link", $dialog).change(function () {
            var authenticationRequired = helper.selectServer($(this).val()).authenticationRequired;
            if (!authenticationRequired) {
                populateSpaces($dialog, $(this).val(), helper);
            }
            $("#search-results-table", $dialog).empty();

            // Any previous errors are not relevant to our new selection
            setSearchControlsEnabled(true, $dialog);
        });

        // Bind the search button
        $("#search-panel-button", $dialog).click(function () {
            $("#search-results-table", $dialog).empty();
            var searchText = $("#link-search-text", $dialog).val();
            searchText = $.trim(searchText);
            if (searchText) {
                doSearch(searchText, $dialog);
            } else {
                AJS.messages.info("#search-results-table", {
                    body: "Please enter search value.",
                    closeable: false
                });
            }

            return false;
        });
    }

    var spaceAjaxId = 0;
    function populateSpaces($context, appId, helper) {
        $("select#search-panel-space", $context).html(JIRA.Templates.ConfluencePageSearch.allSpacesOption());
        var myAjaxId = ++spaceAjaxId;
        JIRA.SmartAjax.makeRequest({
            url: contextPath + "/rest/confluenceIssueLink/1/confluence/space?appId=" + appId,
            complete: function (xhr, textStatus, smartAjaxResult) {
                if (myAjaxId !== spaceAjaxId) {
                    return;
                }
                if (smartAjaxResult.successful) {
                    var spaces = smartAjaxResult.data.spaces;
                    $("select#search-panel-space", $context).html(JIRA.Templates.ConfluencePageSearch.spaceOptions({spaces: spaces}));
                } else {
                    if (smartAjaxResult.status === 401) {
                        helper.setAuthenticationRequired(appId, true);
                    } else {
                        // Since we have an error, prevent the user from submitting a search
                        setSearchControlsEnabled(false, $context);

                        var msg;
                        if (smartAjaxResult.status === 403) {
                            msg = "Content on the Confluence site could not be accessed because the Confluence server\'s \'Remote API\' feature is disabled. The Confluence system administrator must enable this \'Remote API\' feature for JIRA to successfully access this content.";
                        } else {
                            msg = "Unable to gather information from the selected Confluence instance.";
                        }
                        AJS.messages.error("#search-results-table", {
                            body: msg,
                            closeable: false
                        });
                    }
                }
            }
        });
    }

    function setSearchControlsEnabled(enabled, $context) {
        if (enabled) {
            $("#link-search-text", $context).removeAttr("disabled");
            $("#search-panel-space", $context).removeAttr("disabled");
            $("#search-panel-button", $context).removeAttr("disabled");
        } else {
            $("#link-search-text", $context).attr("disabled", "disabled");
            $("#search-panel-space", $context).attr("disabled", "disabled");
            $("#search-panel-button", $context).attr("disabled", "disabled");
        }
    }

    function setLoadingIconVisible(visible, $context) {
        $("#link-search-loading", $context).toggleClass("hidden", !visible);
    }

    function doSearch(searchText, $context) {
        setLoadingIconVisible(true, $context);
        var appLinkId = $("#confluence-app-link", $context).val();
        var spaceKey = $("#search-panel-space option:selected", $context).val();
        JIRA.SmartAjax.makeRequest({
            url: contextPath + "/rest/confluenceIssueLink/1/confluence/search?query=" + searchText + "&appId=" + appLinkId + "&spaceKey=" + spaceKey + "&maxResults=10",
            complete: function (xhr, textStatus, smartAjaxResult) {
                setLoadingIconVisible(false, $context);
                if (smartAjaxResult.successful) {
                    var results = smartAjaxResult.data.result;
                    var resultHtml = JIRA.Templates.ConfluencePageSearch.resultsTable({results: results});
                    $("#search-results-table", $context).html(resultHtml);
                } else {
                    // This replicates the JIRA.SmartAjax.buildSimpleErrorContent method, but we can't use that because
                    // it mentions a JIRA instance.
                    var msg;
                    if (smartAjaxResult.hasData) {
                        msg = "The JIRA server was contacted but has returned an error response. We are unsure of the result of this operation.";
                    } else {
                        msg = "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.";
                    }
                    AJS.messages.error("#search-results-table", {
                        body: msg,
                        closeable: false
                    });
                }

                $("#confluence-searchresult tbody tr", $context).click(function () {
                    var linkUrl = $(this).children().first().data("url");
                    $("#confluence-page-url").val(linkUrl);

        ////        If we want to display the title in the 'description' area on the main dialog
        ////        var linkTitle = $(this).children().first().text();
        ////        $("#confluence-page-url").siblings(".description").text(linkTitle);

                    // Clear all error messages on the parent dialog, as we now have a newly selected URL
                    $("#link-issue-dialog .error").hide();

                    confluenceSearchDialog.hide();
                    $("#link-issue-dialog").show();
                    $("#confluence-page-url").focus().select();
                });
            }
        });
    }

    function initAppLinks(dialog) {
        var settings = {
            getCurrentAppId: function (context) {
                return $("#confluence-app-link", context).val();
            },
            shouldExecute: function (context) {
                return $("#confluence-app-link", context).length !== 0;
            },
            onAuthenticationSuccessCallback: function (context, currentAppId, helper) {
                populateSpaces(context, currentAppId, helper);
            },
            getIssueId: function (context) {
                return $("#confluence-page-link input[name=id]").val();
            }
        };

        return IssueLinkAppLinks.init(settings, dialog.$popup).done(function (context, helper) {
            populateSpaces(context, settings.getCurrentAppId(context), helper);
        });
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-confluence-plugin:confluence-page-resource', location = 'templates/dialog/searchresult.soy' */
// This file was automatically generated from searchresult.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ConfluencePageSearch.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ConfluencePageSearch == 'undefined') { JIRA.Templates.ConfluencePageSearch = {}; }


JIRA.Templates.ConfluencePageSearch.result = function(opt_data, opt_ignored) {
  var output = '<h2>' + soy.$$escapeHtml("Find a Confluence page") + '</h2><form class="aui search-form" id="confluence-page-search-form" action="#" method="post"><div class="field-group"><label for="confluence-app-link">' + soy.$$escapeHtml("Server") + ':</label>';
  if (opt_data.appLinks.length == 1) {
    output += '<span class="field-value">' + soy.$$escapeHtml(opt_data.appLinks[0].name) + '</span><input id="confluence-app-link" class="hidden" type="hidden" name="appId" value="' + soy.$$escapeHtml(opt_data.appLinks[0].id) + '"/>';
  } else {
    output += '<select id="confluence-app-link" class="select medium-field" name="appId">';
    var appLinkList17 = opt_data.appLinks;
    var appLinkListLen17 = appLinkList17.length;
    for (var appLinkIndex17 = 0; appLinkIndex17 < appLinkListLen17; appLinkIndex17++) {
      var appLinkData17 = appLinkList17[appLinkIndex17];
      output += '<option value="' + soy.$$escapeHtml(appLinkData17.id) + '">' + soy.$$escapeHtml(appLinkData17.name) + '</option>';
    }
    output += '</select>';
  }
  output += '</div><div class="issue-link-applinks-authentication-message applinks-message-bar"></div><div class="hidden"><input class="issue-link-applinks-application-type" type="hidden" value="com.atlassian.applinks.api.application.confluence.ConfluenceApplicationType"/></div><div class="issue-link-oauth-toggle field-group"><label for="link-search-text" id="linkSearch-label">' + soy.$$escapeHtml("Search") + ':</label><input id="link-search-text" type="text" tabindex="0" class="text" name="linkSearch" size="50" /> <select tabindex="0" class="search-space select" id="search-panel-space"><option value="">' + soy.$$escapeHtml("All Spaces") + '</option></select> <input type="submit" tabindex="0" class="aui-button" id="search-panel-button" value="' + soy.$$escapeHtml("Search") + '"/><span id="link-search-loading" class="icon loading throbber hidden"/></div><div class="message-panel hidden"></div><div id="search-results-table" class="data-table"></div><div class="buttons-container form-footer"><div class="buttons"><button class="aui-button aui-button-link cancel" id="confluence-link-cancel" title="' + soy.$$escapeHtml("Press Esc to close") + '">' + soy.$$escapeHtml("Close") + '</button></div></div></form>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.result.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.result';
}


JIRA.Templates.ConfluencePageSearch.resultsTable = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.results.length > 0) {
    output += '<table id="confluence-searchresult" class="aui"><thead><tr><th width="180px">' + soy.$$escapeHtml("Title") + '</th><th width="550px">' + soy.$$escapeHtml("Excerpt") + '</th></tr></thead><tbody>';
    var resultList44 = opt_data.results;
    var resultListLen44 = resultList44.length;
    for (var resultIndex44 = 0; resultIndex44 < resultListLen44; resultIndex44++) {
      var resultData44 = resultList44[resultIndex44];
      output += '<tr title="' + soy.$$escapeHtml(resultData44.title) + '"><td class="title" data-url="' + soy.$$escapeHtml(resultData44.url) + '">' + soy.$$escapeHtml(resultData44.title) + '</td><td class="excerpt">' + soy.$$escapeHtml(resultData44.excerpt) + '</td></tr>';
    }
    output += '</tbody></table>';
  } else {
    output += '<div class="aui-message info"><span class="aui-icon icon-info"></span><p>' + soy.$$escapeHtml("Search returned no results.") + '</p></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.resultsTable.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.resultsTable';
}


JIRA.Templates.ConfluencePageSearch.spaceOptions = function(opt_data, opt_ignored) {
  var output = '<option value="">' + soy.$$escapeHtml("All Spaces") + '</option>';
  var spaceList64 = opt_data.spaces;
  var spaceListLen64 = spaceList64.length;
  for (var spaceIndex64 = 0; spaceIndex64 < spaceListLen64; spaceIndex64++) {
    var spaceData64 = spaceList64[spaceIndex64];
    output += '<option value="' + soy.$$escapeHtml(spaceData64.key) + '">' + soy.$$escapeHtml(spaceData64.name) + '</option>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.spaceOptions.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.spaceOptions';
}


JIRA.Templates.ConfluencePageSearch.allSpacesOption = function(opt_data, opt_ignored) {
  return '<option value="">' + soy.$$escapeHtml("All Spaces") + '</option><option value="" disabled="disabled">' + soy.$$escapeHtml("Loading...") + '</option>';
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.allSpacesOption.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.allSpacesOption';
}
;
;
/* module-key = 'com.atlassian.administration.atlassian-admin-quicksearch-jira:admin-quicksearch-webresources', location = 'com/atlassian/administration/quicksearch/jira/js/adminQuickNav.js' */
/**
 * Shifter group for admin search
 */
require([
    'jquery',
    'underscore',
    'jira/ajs/ajax/smart-ajax',
    'jira/shifter',
    'wrm/context-path'
], function (jQuery,
             _,
             SmartAjax,
             Shifter,
             contextPath) {
    Shifter.register(function () {
        var suggestionsDeferred = jQuery.Deferred();

        function formatItem(item) {
            return {
                label: item.label,
                value: item.linkUrl,
                keywords: item.aliases
            };
        }

        function getItemsInSection(section) {
            return _.map(section.items, formatItem).concat(_.map(section.sections, getItemsInSection));
        }

        function formatResponse(data) {
            return _.flatten(getItemsInSection(data));
        }

        SmartAjax.makeRequest({
            dataType: 'json',
            url: contextPath() + '/rest/adminquicksearch/latest/links/default'
        })
            .pipe(formatResponse)
            .done(function (suggestions) {
                suggestionsDeferred.resolve(suggestions);
            })
            .fail(function () {
                suggestionsDeferred.reject();
            });

        return {
            id: 'admin',
            name: "Administration",
            weight: 500,
            getSuggestions: function () {
                return suggestionsDeferred;
            },
            onSelection: function (value) {
                window.location = value;
                return jQuery.Deferred();
            }
        };
    });
});
;
;
/* module-key = 'com.atlassian.plugins.browser.metrics.browser-metrics-plugin:api', location = 'probe.js' */
;(function() {
var util_window, is_supported, event_stream, api_addReporter, api_delegateTo, api_end, util_table, util_document, util_element_hound, util_element_wolf, api_start_is_ready_supported, util_is_dom_content_loaded_done, api_start, api_subscribe, index;
util_window = function () {
  return window;
}();
is_supported = function (window) {
  /**
   * Feature detection for whether mandatory browser features are supported.
   */
  // required for .start() and .end() timing
  // http://caniuse.com/#search=performance.now
  return !!(window.performance && window.performance.now);
}(util_window);
event_stream = [];
api_addReporter = function (eventStream) {
  /**
   * Add a custom reporter to contribute to transition reports.
   *
   * @param {Reporter} reporter
   * @example
   *     api.addReporter(function dateReporter(transition) {
   *         return {
   *             date: Date.now()
   *         };
   *     });
   */
  return function addReporter(reporter) {
    // "addReporter" API has highest priority, so we use .unshift() rather than .push()
    eventStream.unshift({ addReporter: reporter });
  };
}(event_stream);
api_delegateTo = function (eventStream) {
  /**
   * Yield control to another object, giving it all events captured thus far, and all events in the future.
   * @param {function} subscriber
   */
  return function delegateTo(subscriber) {
    while (eventStream.length) {
      subscriber(eventStream.splice(0, 1)[0]);
    }
    eventStream.unshift = subscriber;
    eventStream.push = subscriber;
  };
}(event_stream);
api_end = function (eventStream, window) {
  /**
   * Finish timing and report the results.
   *
   * @param {String} options.key A key that identifies the page that has now finished loading. It must match the
   *     key provided to `start`.
   * @returns {undefined}
   * @example
   *     api.end({key: "jira.issue.view"});
   */
  return function end(options) {
    eventStream.push({
      end: {
        key: options.key,
        timestamp: window.performance.now()
      }
    });
  };
}(event_stream, util_window);
util_table = function () {
  /**
   * A multi-dimensional map that supports multiple values per key.
   * @constructor
   */
  function Table() {
    this._ = {};
  }
  /**
   * Recursive iteration over all keys and values. Function argument explanation:
   * {function} args[0] callback Called with arguments: values, key, higherKey, moreHigherKey,...
   * {Object} args[1] items to iterate
   * {string} args[2..n] keys from bottom to top
   *
   * @param {Array} args
   * @returns {undefined}
   */
  var _forEachRecursive = function (args) {
    var callback = args[0];
    var items = args[1];
    // at 1st level it's -> this;
    if (items instanceof Table) {
      if (args.length >= 3) {
        Object.keys(items._).forEach(function (key) {
          _forEachRecursive([
            callback,
            items._[key],
            key
          ].concat(args.slice(2)));
        });
      } else {
        Object.keys(items._).forEach(function (key) {
          _forEachRecursive([
            callback,
            items._[key],
            key
          ]);
        });
      }
    } else if (Array.isArray(items)) {
      callback.apply(null, [items].concat(args.slice(2)));
    }
  };
  /**
   * Iterate over all keys and values.
   * @param {function} callback Called with two arguments: values, key
   * @returns {undefined}
   */
  Table.prototype.forEach = function (callback) {
    _forEachRecursive([
      callback,
      this
    ]);
  };
  /**
   * Adds an object to a multi-dimension table. Head arguments are keys in order of deepness,
   * 1st goes highest key (e.g.: row key) and the one before last is the deepest level key (e.g.: column key).
   * Last argument considered as a value.
   *
   * @param arguments array of keys from top to bottom, ending with value (e.g.: [0] > rowKey, [1] > columnKey, [2] > value)
   */
  Table.prototype.add = function () {
    // selector, hasNone, callback
    var obj = this;
    // current level row
    var prev = null;
    // previous argument/key
    var cur = null;
    // current func argument/key/value
    for (var i = 0; i < arguments.length; i++) {
      cur = arguments[i];
      // then "obj" is an Array and "cur" is a value
      if (i === arguments.length - 1 && Array.isArray(obj)) {
        obj.push(cur);
        break;  // creating new level of table
      } else if (i < arguments.length - 2 && !obj._.hasOwnProperty(cur)) {
        obj._[cur] = new Table();  // {_: {}, length: 0}
                                   // considered as last level, we need to create an Array for values if not exists
      } else if (i === arguments.length - 2 && !obj._.hasOwnProperty(cur)) {
        obj._[cur] = [];
      }
      obj = obj._[cur];
      // this is an Array if i === arguments.length - 2
      prev = cur;
    }
  };
  /**
   *
   * @param visited an Array of tupples of "table key" > "object under that key" (root key is always null)
   * @param keyToRemove a key on the table structure which needs to be removed
   */
  var _cleanUpRecursive = function (visited, keyToRemove) {
    if (visited.length === 0) {
      return;
    }
    var tuple = visited.pop();
    var key = tuple[0];
    var obj = tuple[1];
    if (key === keyToRemove) {
      _cleanUpRecursive(visited, key);
    } else if (obj._.hasOwnProperty(keyToRemove)) {
      delete obj._[keyToRemove];
    }
    if (Object.keys(obj).length === 0) {
      _cleanUpRecursive(visited, key);
    }
  };
  /**
   * Remove an object under a key.
   * @param arguments array of keys from top to bottom, ending with value (e.g.: [0] > rowKey, [1] > columnKey, [2] > value)
   * @returns {boolean} true if an item was removed
   */
  Table.prototype.remove = function () {
    // e.g.: rowKey, columnKey, value
    var index;
    // index of the Array element that is about to be removed
    var mutated = false;
    // true if Table was changed, i.e. element was removed
    var key = null;
    // current level key
    var obj = this;
    // current level row
    // Visited elements - Array of tuples, root key is always null (e.g.: [aKey1, {_: { aKey2 : Table/Array }, length: 1}]
    var visited = [[
        key,
        obj
      ]];
    var cur = null;
    // current func argument
    for (var i = 0; i < arguments.length; i++) {
      cur = arguments[i];
      // then "obj" is Array and "cur" is an entry in this Array.
      if (Array.isArray(obj)) {
        index = obj.indexOf(cur);
        if (index > -1) {
          obj.splice(index, 1);
          if (obj.length === 0 && visited.length > 1) {
            _cleanUpRecursive(visited, key);  // cleaning all upper levels if they are empty as well
          }
          mutated = true;
        }
      } else if (obj._.hasOwnProperty(cur)) {
        // When only some key is specified, _all_ values under that key are removed.
        if (i === arguments.length - 1) {
          delete obj._[cur];
          // if we want correct reduce, we need to count all inner keys being removed
          if (Object.keys(obj).length === 0 && visited.length > 1) {
            _cleanUpRecursive(visited, key);  // cleaning all upper levels if they are empty either
          }
          mutated = true;
        }
        key = cur;
        obj = obj._[cur];
        visited.push([
          key,
          obj
        ]);  // at the previous to last index step obj is an Array
      } else {
        break;
      }
    }
    return mutated;
  };
  /**
   * Get objects under a key.
   * @returns {Array}
   * @param key under which sought-for element stored
   */
  Table.prototype.get = function (key) {
    if (this._.hasOwnProperty(key)) {
      return this._[key];
    }
    return [];
  };
  return Table;
}();
util_document = function (window) {
  return window.document;
}(util_window);
util_element_hound = function (Table, window, document) {
  var MutationObserver = window.MutationObserver;
  var observer;
  var observing = false;
  var Promise = window.Promise;
  var targets;
  // MutationObserver -- Required for determining whether selectors are satisfied in the DOM;
  // Promise -- Required for combining multiple conditions together.
  if (!(MutationObserver && Promise)) {
    return;
  }
  // A table of selector -> [hasNone -> [callbacks, ...], ... ] of things to find.
  targets = new Table();
  function isNothing(obj) {
    return !obj || obj == null || obj === 'null' || obj === 'undefined';
  }
  /**
   * Add a target to watch for, ensuring the MutationObserver is enabled.
   * @param {string} selector
   * @param {string} hasNone
   * @param {function} callback
   */
  function addTarget(selector, hasNone, callback) {
    if (!observing) {
      observer.observe(document, {
        attributes: true,
        childList: true,
        subtree: true
      });
      observing = true;
    }
    targets.add(selector, hasNone, callback);
  }
  /**
   * Find candidate elements that satisfy the "selector predicate".
   * @param selector
   * @param hasNone
   * @returns {boolean}
   */
  function satisfies(selector, hasNone) {
    var candidates = document.querySelectorAll(selector);
    return candidates.length && (isNothing(hasNone) || Array.prototype.every.call(candidates, function (element) {
      return !element.querySelector(hasNone);
    }));
  }
  // A MutationObserver so we know when the DOM changes.
  observer = new MutationObserver(function (mutations) {
    // 1. Gather list of elements that satisfy the "selector" predicate
    // 2. For each of those "candidate" elements, check if it satisfies the "hasNone" predicate.
    targets.forEach(function (callbacks, hasNone, selector) {
      if (satisfies(selector, hasNone)) {
        callbacks.forEach(function (callback) {
          callback();
        });
        targets.remove(selector, hasNone);
      }
    });
  });
  /**
   * @typedef {Promise} ElementHound
   * @property {function} dismiss When called, dismissed the hound.
   */
  /**
   * Find some elements!
   *
   * @param {string|string[]} selectors One ore more CSS selectors that must all match elements of interest.
   * @param {string|string[]} hasNones If not null, selectors only match elements that do not have descendants matching
   *     this selector.
   * @returns {ElementHound}
   * @constructor
   */
  function ElementHound(selectors, hasNones) {
    var dismiss;
    // Normalise selectors to an array.
    if (!selectors.forEach) {
      selectors = [selectors];
    }
    // Join all "hasNones" into one big comma separated selector
    if (!isNothing(hasNones) && Array.isArray(hasNones)) {
      hasNones = hasNones.join(',');
    }
    /**
     * @type {ElementHound}
     */
    var result = new Promise(function (resolve, reject) {
      var requirementPromises = [];
      var requirementCleanups = [];
      selectors.forEach(function (selector) {
        var promise;
        var cleanup;
        if (!satisfies(selector, hasNones)) {
          promise = new Promise(function (resolve) {
            addTarget(selector, hasNones, resolve);
            cleanup = function () {
              targets.remove(selector, hasNones, resolve);
            };
            requirementCleanups.push(cleanup);
          });
          requirementPromises.push(promise);
        }
      });
      // Clean-up after ourselves, to reduce the work done by the mutation observer.
      function cleanup() {
        requirementCleanups.forEach(function (requirementCleanup) {
          requirementCleanup();
        });
      }
      Promise.all(requirementPromises).then(cleanup).then(resolve, reject);
      dismiss = function () {
        cleanup();
        reject();
      };
    });
    // Allow the caller to explicitly dismiss the hound. This allows the caller to say
    // they don't care about the result any more, and allows us to stop looking for it.
    result.dismiss = dismiss;
    return result;
  }
  return ElementHound;
}(util_table, util_window, util_document);
util_element_wolf = function (Table, window, document) {
  var MutationObserver = window.MutationObserver;
  var observer;
  var observing = false;
  var Promise = window.Promise;
  var targets;
  // MutationObserver -- Required for determining whether selectors are satisfied in the DOM;
  // Promise -- Required for combining multiple conditions together.
  if (!(MutationObserver && Promise)) {
    return;
  }
  // A map of selector->[callback] of things to find.
  targets = new Table();
  /**
   * Add a target to watch for, ensuring the MutationObserver is enabled.
   * @param {string} selector
   * @param {function} callback
   */
  function addTarget(selector, callback) {
    if (!observing) {
      observer.observe(document, {
        attributes: true,
        childList: true,
        subtree: true
      });
      observing = true;
    }
    targets.add(selector, callback);
  }
  // A MutationObserver so we know when the DOM changes.
  observer = new MutationObserver(function (mutations) {
    targets.forEach(function (callbacks, selector) {
      if (!document.querySelector(selector)) {
        callbacks.forEach(function (callback) {
          callback();
        });
        targets.remove(selector);
      }
    });
  });
  /**
   * @typedef {Promise} ElementWolf
   * @property {function} dismiss When called, dismisses the wolf.
   */
  /**
   * Find some elements!
   *
   * @param {string|string[]} selectors One ore more CSS selectors that must all match elements of interest.
   * @returns {ElementWolf}
   * @constructor
   */
  function ElementWolf(selectors) {
    var dismiss;
    // Normalise selectors to an array.
    if (!selectors.forEach) {
      selectors = [selectors];
    }
    /**
     * @type {ElementWolf}
     */
    var result = new Promise(function (resolve, reject) {
      var requirementPromises = [];
      var requirementCleanups = [];
      selectors.forEach(function (selector) {
        var promise;
        var cleanup;
        if (document.querySelector(selector)) {
          promise = new Promise(function (resolve) {
            addTarget(selector, resolve);
            cleanup = function () {
              targets.remove(selector, resolve);
            };
          });
          requirementPromises.push(promise);
          requirementCleanups.push(cleanup);
        }
      });
      // Clean-up after ourselves, to reduce the work done by the mutation observer.
      function cleanup() {
        requirementCleanups.forEach(function (requirementCleanup) {
          requirementCleanup();
        });
      }
      Promise.all(requirementPromises).then(cleanup).then(resolve, reject);
      dismiss = function () {
        cleanup();
        reject();
      };
    });
    // Allow the caller to explicitly dismiss the hound. This allows the caller to say
    // they don't care about the result any more, and allows us to stop looking for it.
    result.dismiss = dismiss;
    return result;
  }
  return ElementWolf;
}(util_table, util_window, util_document);
api_start_is_ready_supported = function (ElementHound, ElementWolf) {
  /**
   * Feature detection for whether the .api({ready: â¦}) API option is supported.
   */
  return !!(ElementHound && ElementWolf);
}(util_element_hound, util_element_wolf);
util_is_dom_content_loaded_done = function (document, window) {
  var done = false;
  document.addEventListener('DOMContentLoaded', function () {
    // setTimeout matters here because the purpose of this module is to let know when all the DOMContentLoaded
    // event handlers have run. In order to know that, it would have to run after all the other handlers have run.
    // Hence we're using setTimeout to wait until the next tick. We know for certain that on the next tick all
    // the handlers have been executed due to JavaScript being single threaded.
    window.setTimeout(function () {
      done = true;
    });
  });
  /**
   * Return true if the DOMContentLoaded event handlers have been called.
   * @returns {boolean}
   */
  function isDOMContentLoadedDone() {
    return done;
  }
  return isDOMContentLoadedDone;
}(util_document, util_window);
api_start = function (end, isReadySupported, eventStream, ElementHound, ElementWolf, isDOMContentLoadedDone, window) {
  var Promise = window.Promise;
  var executeOnceOnStart = [];
  /**
   * In the .start() API, there are multiple short-hand versions of the 'ready' value that can be used. In the
   * interest of sanity, this function normalises them all to the most complex form.
   *
   * @param {string|string[]|{selector: string, requireUpdate: boolean, hasNone?: string|null}} conditions
   * @param {boolean} defaultRequireUpdate When a ready condition is a string (i.e. selector only), use this value for
   *     requireUpdate.
   * @returns {Array<{selector: string, requireUpdate: boolean, hasNone?: string|null}>}
   */
  function normalisedReady(conditions, defaultRequireUpdate) {
    if (!Array.isArray(conditions)) {
      conditions = [conditions];
    }
    return conditions.map(function (c) {
      return typeof c === 'string' ? {
        selector: c,
        requireUpdate: defaultRequireUpdate,
        hasNone: null
      } : c;
    });
  }
  /**
   * Combine all the ready conditions into a single promise.
   *
   * @param {{selector: string, requireUpdate: boolean, hasNone?: string|null}[]} conditions
   * @returns {Promise} a promise that is resolved when all conditions are satisfied
   */
  function combinedReady(conditions) {
    var combined;
    combined = conditions.map(function (condition) {
      var precondition;
      if (condition.requireUpdate) {
        precondition = new ElementWolf(condition.selector);
        // In case another transition happens _before_ we can finish.
        executeOnceOnStart.push(function () {
          precondition.dismiss();
        });
      } else {
        precondition = Promise.resolve();
      }
      return precondition.then(function () {
        var hound = new ElementHound(condition.selector, condition.hasNone);
        // In case another transition happens _before_ we can finish.
        executeOnceOnStart.push(function () {
          hound.dismiss();
        });
        return hound;
      });
    });
    return Promise.all(combined);
  }
  /**
   * Start measuring the duration of a transition.
   *
   * @param {String} options.key A key that identifies the page where the user is headed.
   * @param {boolean} [options.isInitial] If specified, indicates whether the transition should be treated as a
   *     "full page load" (initial). If not specified, this will be determined automatically based on whether or not
   *     DOMContentLoaded has fired.
   * @param {number} [options.threshold=1000] Declares the target (in milliseconds) duration for the navigation. The
   *     performance of the navigation is considered *good* if it completes within this threshold.
   * @param {String|String[]|{selector: string, requireUpdate: boolean}[]} [options.ready] A CSS selector that matches
   *     one or more DOM elements. When the selector matches something in the DOM, the page is considered "ready" for
   *     the user.
   *
   *     For non-initial page loads, if the selector _immediately_ matches one or more elements in the DOM, it will
   *     first wait a matching element to be removed, and then wait for a DOM mutation to expose a matching element.
   *     This behaviour can be turned off (i.e. don't require an element to be removed first) via the
   *     `requireUpdate=false` option.
   * @returns {undefined}
   * @example
   *     api.start({key: "jira.issue.view"});
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         threshold: 1000
   *     });
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         ready: ".issue-main-content",
   *         threshold: 1000
   *     });
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         ready: [
   *             ".issue-main-content",
   *             {selector: ".issue-main-content", hasNone: ".loading"},
   *             ".another-required-thing"
   *         ],
   *         threshold: 1000
   *     });
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         ready: [
   *             {selector: ".issue-main-content", requireUpdate: false, hasNone: ".aui-loading, .loading"},
   *             ".another-required-thing"
   *         ],
   *         threshold: 1000
   *     });
   */
  return function start(options) {
    var conditions;
    var isInitial = 'isInitial' in options ? options.isInitial : isDOMContentLoadedDone() === false;
    var threshold = 'threshold' in options ? options.threshold : 1000;
    eventStream.push({
      start: {
        key: options.key,
        isInitial: isInitial,
        threshold: threshold,
        timestamp: isInitial ? 0 : window.performance.now()
      }
    });
    executeOnceOnStart.forEach(function (callback) {
      callback();
    });
    // Empty the array of callbacks now that we've called them.
    executeOnceOnStart.splice(0, executeOnceOnStart.length);
    if (options.ready && isReadySupported) {
      conditions = normalisedReady(options.ready, /*defaultRequireUpdate=*/
      !isInitial);
      combinedReady(conditions).then(function () {
        end({ key: options.key });
      });
    }
  };
}(api_end, api_start_is_ready_supported, event_stream, util_element_hound, util_element_wolf, util_is_dom_content_loaded_done, util_window);
api_subscribe = function (eventStream) {
  /**
   * Add a subscriber that's interested in reports.
   */
  return function subscribe(subscriber) {
    eventStream.push({ subscribe: subscriber });
  };
}(event_stream);
index = function (isSupported, addReporter, delegateTo, end, start, subscribe) {
  var noop = function () {
  };
  return {
    start: isSupported ? start : noop,
    end: isSupported ? end : noop,
    addReporter: isSupported ? addReporter : noop,
    delegateTo: isSupported ? delegateTo : noop,
    subscribe: isSupported ? subscribe : noop
  };
}(is_supported, api_addReporter, api_delegateTo, api_end, api_start, api_subscribe);
window['browser-metrics'] = index;
if (window.define) {
  window.define('internal/browser-metrics', function () {
    return index;
  });
}
}());;
;
/* module-key = 'com.atlassian.plugins.browser.metrics.browser-metrics-plugin:api', location = 'internal/browser-metrics-aa-beacon.js' */
define("internal/browser-metrics-aa-beacon",function(){var n={};return n=function(n){function e(n,e){Object.keys(e).forEach(function(r){n[r]=e[r]})}var r=[],t=[];return n.addUrlCleaner=function(n){t.push(n)},n.cleanUrl=function(n){return t.reduce(function(e,r){var t=r(n);return t.length>e.length?t:e},"")},n.addReportMarshaller=function(n){r.push(n)},n.beacon=function(n){var t={};r.forEach(function(r){var a=r(n);"object"==typeof a&&e(t,a)});var a={name:"browser.metrics.navigation",properties:t};AJS.EventQueue.push(a)},n}(n)});;
;
/* module-key = 'com.atlassian.plugins.browser.metrics.browser-metrics-plugin:api', location = 'loader.js' */
;(function() {
var lib_window = {}, lib_wrm = {}, loader = {};
lib_window = function (exports) {
  var w = window;
  return w;
}(lib_window);
lib_wrm = function (exports, window) {
  var wrm = window.WRM;
  return wrm;
}(lib_wrm, lib_window);
loader = function (exports, window, WRM) {
  var contribInstallers = 0;
  var contribInstalls = 0;
  var collectorInstaller = null;
  function tryInstallCollector() {
    if (contribInstallers === contribInstalls && collectorInstaller) {
      collectorInstaller();
      collectorInstaller = null;
    }
  }
  var api = {
    install: function (installer) {
      contribInstallers += 1;
      installer(function () {
        contribInstalls += 1;
        tryInstallCollector();
      });
    }
  };
  window['browser-metrics-plugin'] = api;
  WRM.require(['wrc!browser-metrics-plugin.contrib'], function () {
    window.require(['internal/browser-metrics-plugin/collector'], function (collector) {
      collectorInstaller = function () {
        collector.install();
      };
      tryInstallCollector();
    });
  });
  return exports;
}(loader, lib_window, lib_wrm);
}());;
;
/* module-key = 'com.atlassian.jira.plugins.jira-browser-metrics:sensors', location = 'sensors.js' */
require(["internal/browser-metrics", "jira/util/events"], function (internal_browser_metrics, jira_util_events) {
var sensors_application_menus = {}, sensors_util_safe_dialog_id = {}, sensors_dialogs = {}, sensors = {};
sensors_application_menus = function (exports, Events, metrics) {
  function init() {
    var KEYS = {
      'bonfire_top_menu_dropdown-content': 'jira.header.menu.capture',
      'browse_link-content': 'jira.header.menu.projects',
      'find_link-content': 'jira.header.menu.issues',
      'greenhopper_menu-content': 'jira.header.menu.agile',
      'home_link-content': 'jira.header.menu.dashboards',
      'plugins-jira-webitem-main-content': 'jira.header.menu.portfolio',
      'servicedesk-section-content': 'jira.header.menu.service-desk',
      'system-admin-menu-content': 'jira.header.menu.admin',
      'system-help-menu-content': 'jira.header.menu.help',
      'user-options-content': 'jira.header.menu.profile'
    };
    function getKey(dropdownId) {
      return KEYS.hasOwnProperty(dropdownId) ? KEYS[dropdownId] : null;
    }
    Events.bind('aui-dropdown2-show-before', function (event) {
      var target = event.target;
      var key = getKey(target && target.id);
      if (key) {
        metrics.start({
          key: key,
          isInitial: false,
          threshold: 250
        });
      }
    });
    Events.bind('aui-dropdown2-show-after', function (event) {
      var target = event.target;
      var key = getKey(target && target.id);
      if (key) {
        metrics.end({ key: key });
      }
    });
  }
  exports.init = init;
  return exports;
}(sensors_application_menus, jira_util_events, internal_browser_metrics);
sensors_util_safe_dialog_id = function (exports) {
  var SAFE_DIALOG_IDS = [
    'about-dialog',
    'add-basicuser-dialog',
    'add-developer-dialog',
    'add-field-configuration-dialog',
    'add-field-configuration-scheme-dialog',
    'add-field-dialog',
    'add-field-screen-dialog',
    'add-field-screen-scheme-dialog',
    'add-incoming-mail-handler-dialog',
    'add-issue-type-dialog',
    'add-issue-type-field-configuration-association-dialog',
    'add-issue-type-screen-scheme-configuration-association-dialog',
    'add-issue-type-screen-scheme-dialog',
    'add-new-issue-type-to-scheme-dialog',
    'add-screen-scheme-item-dialog',
    'add-subtask-type-dialog',
    'add-workflow-dialog',
    'add_workflowscheme-dialog',
    'assign-dialog',
    'assign-issue-types-dialog',
    'assign-to-me-link-handler',
    'attach-file-dialog',
    'attach-screenshot-dialog',
    'auditing-settings-dialog',
    'clone-issue-dialog',
    'comment-add-dialog',
    'configure_wallboard_dialog',
    'confluence-page-search-dialog',
    'copy_classic default workflow-dialog',
    'copy-filter-dialog',
    'copy_jira-dialog',
    'create-issue-dialog',
    'create-issue-dialog.issueType',
    'create-issue-dialog.projectId',
    'create-request-dialog',
    'create-service-desk-dialog',
    'create-status-dialog',
    'create-story-dialog',
    'create-story-dialog.issueType',
    'create-story-dialog.projectId',
    'create-subtask-dialog',
    'create-subtask-dialog.issueType',
    'create-team-dialog',
    'create_user-dialog',
    'credits-dialog',
    'delete-attachment-dialog',
    'delete-comment-dialog',
    'delete-dshboard',
    'delete-filter-dialog',
    'delete-issue-dialog',
    'delete-issue-link-dialog',
    'delete-log-work-dialog',
    'delete-metric',
    'delete-queue',
    'delete-status-dialog',
    'deleteuser_link-dialog',
    'devstatus-branch-detail-dialog',
    'devstatus-build-detail-dialog',
    'devstatus-commit-detail-dialog',
    'devstatus-cta-dialog',
    'devstatus-deployment-detail-dialog',
    'devstatus-pullrequest-detail-dialog',
    'devstatus-review-detail-dialog',
    'discard-draft-dialog',
    'discard_draft_workflow-dialog',
    'edit-attachments-dialog',
    'edit-comment',
    'editgroups_admin-dialog',
    'editgroups_link-dialog',
    'editgroups_sysadmin-dialog',
    'edit-issue-dialog',
    'edit-labels-dialog',
    'edit-log-work-dialog',
    'edit-status-dialog',
    'edituser_link_admin-dialog',
    'edit-workflow-dialog',
    'gh-rapidboard-dialog',
    'inline-issue-create-dialog',
    'invite_user-dialog',
    'issue-actions-dialog',
    'issue-tab-error-dialog',
    'jim-create-project-dialog',
    'keyboard-shortcuts-dialog',
    'link-issue-dialog',
    'log-work-dialog',
    'manage-attachment-dialog',
    'metric-pre-save-dialog',
    'modal-field-view',
    'permission-helper-dialog',
    'project-avatar-cropper',
    'project-avatar-picker',
    'project-config-details-project-category-dialog',
    'project-config-project-edit-dialog',
    'project-config-project-edit-lead-and-default-assignee-dialog',
    'project-email-dialog',
    'publish_draft_workflow-dialog',
    'queue-dirty-edits',
    'QuickCreateIssue.error',
    'QuickCreateIssue.success',
    'QuickCreateSubtask.error',
    'QuickCreateSubtask.success',
    'QuickEdit.error',
    'QuickEdit.success',
    'remote-jira-search-dialog',
    'rename-filter-dialog',
    'report-dirty-edits',
    'save-filter-dialog',
    'sd-add-default-value',
    'sd-add-remove-agent-dialog',
    'sd-remove-field-dialog',
    'server-error-dialog',
    'report-delete-confirm',
    'tempo-add-hours-issue-dialog',
    'tempo-add-internal-activity-form',
    'tempo-core-medium-form',
    'tempo-delete-form-dialog',
    'tempo-grace-form',
    'tempo-large-form',
    'tempo-medium-form',
    'tempo-move-form-dialog',
    'tempo-pdf-form',
    'tempo-small-form',
    'tempo-split-form-dialog',
    'tempo-user-settings-dialog',
    'user-avatar-picker',
    'user-defaults-edit-dialog',
    'versionsMergeDialog',
    'view-workflow-dialog',
    'view-workflow-dialog-project-admin',
    'view-workflow-dialog-workflow-schemes',
    'wait-migrate-dialog',
    'whereismycf-dialog',
    'workflow-text-view'
  ].reduce(function (previousValue, currentValue) {
    previousValue[currentValue] = true;
    return previousValue;
  }, {});
  var DIALOG_ID_NORMALISATIONS = [
    {
      dialogId: 'component-delete-dialog',
      pattern: /^component-\d+-delete-dialog$/i
    },
    {
      dialogId: 'version-delete-dialog',
      pattern: /^version-\d+-delete-dialog$/i
    },
    {
      dialogId: 'workflow-transition-dialog',
      pattern: /^workflow-transition-\d+-dialog$/i
    }
  ];
  function safeDialogId(dialogId) {
    var i;
    if (SAFE_DIALOG_IDS.hasOwnProperty(dialogId)) {
      return dialogId;
    }
    for (i = 0; i < DIALOG_ID_NORMALISATIONS.length; i++) {
      if (dialogId.match(DIALOG_ID_NORMALISATIONS[i].pattern)) {
        return DIALOG_ID_NORMALISATIONS[i].dialogId;
      }
    }
    return null;
  }
  return safeDialogId;
}(sensors_util_safe_dialog_id);
sensors_dialogs = function (exports, Events, metrics, safeDialogId) {
  function init() {
    Events.bind('beforeShow', function (event, dialogId) {
      if (typeof dialogId !== 'string') {
        return;
      }
      var key = safeDialogId(dialogId);
      if (key) {
        metrics.start({
          key: 'jira.dialog.open.' + key,
          isInitial: false,
          threshold: 1000
        });
      }
    });
    Events.bind('dialogContentReady', function (event, dialog) {
      if (typeof dialog.options.id !== 'string') {
        return;
      }
      var key = safeDialogId(dialog.options.id);
      if (key) {
        metrics.end({ key: 'jira.dialog.open.' + key });
      }
    });
  }
  exports.init = init;
  return exports;
}(sensors_dialogs, jira_util_events, internal_browser_metrics, sensors_util_safe_dialog_id);
sensors = function (exports, applicationMenusSensor, dialogsSensor) {
  applicationMenusSensor.init();
  dialogsSensor.init();
  return exports;
}(sensors, sensors_application_menus, sensors_dialogs);});
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher.soy' */
// This file was automatically generated from appswitcher.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.appswitcher.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.appswitcher == 'undefined') { navlinks.templates.appswitcher = {}; }


navlinks.templates.appswitcher.linkSection = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.list.length > 0) {
    output += '<div class="aui-nav-heading sidebar-section-header">' + soy.$$escapeHtml(opt_data.title) + '</div><ul class="aui-nav nav-links">';
    var linkList8 = opt_data.list;
    var linkListLen8 = linkList8.length;
    for (var linkIndex8 = 0; linkIndex8 < linkListLen8; linkIndex8++) {
      var linkData8 = linkList8[linkIndex8];
      output += navlinks.templates.appswitcher.applicationsItem(linkData8);
    }
    output += '</ul>';
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.linkSection.soyTemplateName = 'navlinks.templates.appswitcher.linkSection';
}


navlinks.templates.appswitcher.applicationsItem = function(opt_data, opt_ignored) {
  return '<li class="nav-link"><a href="' + soy.$$escapeHtml(opt_data.link) + '" ' + ((opt_data.self) ? 'class="checked"' : '') + ' title="' + soy.$$escapeHtml(opt_data.link) + '"><span class="nav-link-label">' + soy.$$escapeHtml(opt_data.label) + '</span></a></li>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.applicationsItem.soyTemplateName = 'navlinks.templates.appswitcher.applicationsItem';
}


navlinks.templates.appswitcher.shortcutsItem = function(opt_data, opt_ignored) {
  return '<li class="nav-link"><a href="' + soy.$$escapeHtml(opt_data.link) + '" ' + ((opt_data.self) ? 'class="checked"' : '') + ' title="' + soy.$$escapeHtml(opt_data.link) + '"><span class="nav-link-label">' + soy.$$escapeHtml(opt_data.label) + '</span>' + ((opt_data.showDescription && opt_data.description) ? '<span class="nav-link-description">' + soy.$$escapeHtml(opt_data.description) + '</span>' : '') + '</a></li>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.shortcutsItem.soyTemplateName = 'navlinks.templates.appswitcher.shortcutsItem';
}


navlinks.templates.appswitcher.error = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-error">' + soy.$$filterNoAutoescape("Something went wrong, please \x3cspan class\x3d\x22app-switcher-retry\x22\x3etry again\x3c/span\x3e.") + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.error.soyTemplateName = 'navlinks.templates.appswitcher.error';
}


navlinks.templates.appswitcher.sidebarContents = function(opt_data, opt_ignored) {
  return '<div class="aui-page-panel-nav"><nav class="aui-navgroup aui-navgroup-vertical"><div class="app-switcher-section app-switcher-applications"><div class="aui-nav-heading">' + soy.$$escapeHtml("Application Links") + '</div><div class="app-switcher-loading">' + soy.$$filterNoAutoescape("Loading\x26hellip;") + '</div></div><div class="app-switcher-section app-switcher-shortcuts"><div class="aui-nav-heading">' + soy.$$escapeHtml("Shortcuts") + '</div><div class="app-switcher-loading">' + soy.$$filterNoAutoescape("Loading\x26hellip;") + '</div></div></nav></div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.sidebarContents.soyTemplateName = 'navlinks.templates.appswitcher.sidebarContents';
}


navlinks.templates.appswitcher.trigger = function(opt_data, opt_ignored) {
  return '<span class="aui-icon aui-icon-small aui-iconfont-appswitcher">' + soy.$$escapeHtml("Linked Applications") + '</span>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.trigger.soyTemplateName = 'navlinks.templates.appswitcher.trigger';
}


navlinks.templates.appswitcher.projectHeaderSection = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-title">' + aui.avatar.avatar({size: 'large', avatarImageUrl: opt_data.avatarUrl, isProject: true, title: opt_data.name}) + '<div class="sidebar-project-name">' + soy.$$escapeHtml(opt_data.name) + '</div></div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.projectHeaderSection.soyTemplateName = 'navlinks.templates.appswitcher.projectHeaderSection';
}


navlinks.templates.appswitcher.cogDropdown = function(opt_data, opt_ignored) {
  var output = '';
  var dropdownList__soy74 = '' + navlinks.templates.appswitcher.dropdownList({list: opt_data.links});
  output += aui.dropdown2.dropdown2({menu: {id: opt_data.id, content: dropdownList__soy74, extraClasses: 'aui-style-default sidebar-customize-section'}, trigger: {showIcon: false, content: '<span class="aui-icon aui-icon-small aui-iconfont-configure"></span>', container: '#app-switcher'}});
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.cogDropdown.soyTemplateName = 'navlinks.templates.appswitcher.cogDropdown';
}


navlinks.templates.appswitcher.dropdownList = function(opt_data, opt_ignored) {
  var output = '<ul class="sidebar-admin-links">';
  var linkList82 = opt_data.list;
  var linkListLen82 = linkList82.length;
  for (var linkIndex82 = 0; linkIndex82 < linkListLen82; linkIndex82++) {
    var linkData82 = linkList82[linkIndex82];
    output += '<li class="nav-link"><a href="' + soy.$$escapeHtml(linkData82.href) + '" title="' + soy.$$escapeHtml(linkData82.title) + '"><span class="nav-link-label">' + soy.$$escapeHtml(linkData82.label) + '</span></a></li>';
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.dropdownList.soyTemplateName = 'navlinks.templates.appswitcher.dropdownList';
}


navlinks.templates.appswitcher.switcher = function(opt_data, opt_ignored) {
  var output = '';
  if (true) {
    if (AJS.DarkFeatures.isEnabled('rotp.sidebar')) {
      var sidebarContents__soy97 = '' + navlinks.templates.appswitcher.sidebarContents(null);
      var triggerContent__soy99 = '' + navlinks.templates.appswitcher.trigger(null);
      output += navlinks.templates.appswitcher.sidebar({sidebar: {id: 'app-switcher', content: sidebarContents__soy97}, trigger: {showIcon: false, content: triggerContent__soy99}}) + '<script>\n                (function (NL) {\n                    var initialise = function () {\n                        new NL.SideBar({\n                            sidebarContents: \'#app-switcher\'\n                        });\n                    };\n                    if (NL.SideBar) {\n                        initialise();\n                    } else {\n                        NL.onInit = initialise;\n                    }\n                }(window.NL = (window.NL || {})));\n                window.NL.isUserAdmin = ' + soy.$$escapeHtml(false) + '<\/script>';
    } else {
      output += navlinks.templates.appswitcher_old.switcher(null);
    }
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.switcher.soyTemplateName = 'navlinks.templates.appswitcher.switcher';
}


navlinks.templates.appswitcher.sidebar = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.sidebar.id) + '" class="sidebar-trigger app-switcher-trigger" aria-owns="' + soy.$$escapeHtml(opt_data.sidebar.id) + '" aria-haspopup="true">' + soy.$$filterNoAutoescape(opt_data.trigger.content) + '</a><div id=' + soy.$$escapeHtml(opt_data.sidebar.id) + ' class="app-switcher-sidebar aui-style-default sidebar-offscreen">' + soy.$$filterNoAutoescape(opt_data.sidebar.content) + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.sidebar.soyTemplateName = 'navlinks.templates.appswitcher.sidebar';
}
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher.js' */
(function ($, NL) {
    NL.SideBar = function (options) {
        var that = this;
        this.$sidebar = null;

        options = $.extend({
            sidebarContents: null
        }, options);

        this.getLinks = function () {
            return $.ajax({
                url: AJS.contextPath() + '/rest/menu/latest/appswitcher',
                cache: false,
                dataType: 'json'
            }).done(this.updateAppLinks).fail(this.showAppSwitcherError);
        };

        this.populateProjectHeader = function(name, avatarUrl) {
            that.getSidebar().find('.app-switcher-shortcuts .aui-nav-heading').after(navlinks.templates.appswitcher.projectHeaderSection({
                avatarUrl: avatarUrl,
                name: name
            }));
        };

        this.getProjectData = function(){
            var $projectData = $('.project-shortcut-dialog-trigger'),
                projectKey = $projectData.data('key'),
                projectEntityType = $projectData.data('entity-type');
            // if we have no project data, we are not in a project context, so delete the shortcuts section and return.
            if ($projectData.size() == 0 || !projectKey || !projectEntityType)
            {
                $('.app-switcher-shortcuts').remove();
                return;
            }

            var remote, local;

            local = $.ajax({
                url: AJS.contextPath() + '/rest/project-shortcuts/1.0/local/' + projectKey,
                cache: false,
                data: { entityType: projectEntityType },
                dataType: 'json'
            });

            remote = $.ajax({
                url: AJS.contextPath() + '/rest/project-shortcuts/1.0/remote/' + projectKey,
                cache: false,
                data: { entityType: projectEntityType },
                dataType: 'json'
            });

            // wrap a closure around updateProjectShortcuts so we can bind projectKey
            $.when(local, remote).then(function(localData, remoteData){
                that.updateProjectShortcuts(localData, remoteData, {
                    key: projectKey,
                    entityType: projectEntityType,
                    name: $projectData.data('name'),
                    avatarUrl: $projectData.find('img').prop('src')
                });
            }, that.showProjectShortcutsError);
        }

        this.getSidebar = function () {
            if (!this.$sidebar) {
                this.$sidebar = $(options.sidebarContents);
            }
            return this.$sidebar;
        };

        this.addApplicationsCog = function ()
        {
            $('.app-switcher-applications .aui-nav-heading').before(navlinks.templates.appswitcher.cogDropdown({
                id: 'sidebar-applications-admin-dropdown',
                links: [{
                    href: AJS.contextPath() + '/plugins/servlet/customize-application-navigator',
                    label: "Customize navigator",
                    title: "Add new entries, hide existing or restrict who sees what"
                }, {
                    href: AJS.contextPath() + '/plugins/servlet/applinks/listApplicationLinks',
                    label: "Manage application links",
                    title: "Link to more Atlassian applications"
                }]
            }));
        };

        this.addProjectShortcutsCog = function (projectKey, entityType)
        {
            var links = [{
                href: AJS.contextPath() + '/plugins/servlet/custom-content-links-admin?entityKey=' + projectKey,
                label: "Customize shortcuts",
                title: ""
            }];

            if (that.entityMappings[entityType]) {
                links.push({
                    href: that.generateEntityLinksUrl(projectKey, that.entityMappings[entityType]),
                    label: "Manage product links",
                    title: ""
                });
            }

            that.getSidebar().find('.app-switcher-shortcuts .aui-nav-heading').before(navlinks.templates.appswitcher.cogDropdown({
                id: 'sidebar-project-shortcuts-admin-dropdown',
                links: links
            }));
        };

        this.updateAppLinks = function (data) {
            $(function () {
                that.getSidebar().find('.app-switcher-applications').html(navlinks.templates.appswitcher.linkSection({
                    title: "Application Links",
                    list: data
                }));

                if(NL.isUserAdmin)
                {
                    that.addApplicationsCog();
                }

                that.bindAnalyticsHandlers(that.getSidebar(), data);
            });
        };

        this.updateProjectShortcuts = function (localData, remoteData, projectData) {
            var localLinks = localData[0].shortcuts,
                remoteLinks = remoteData[0].shortcuts

            that.getSidebar().find('.app-switcher-shortcuts').html(navlinks.templates.appswitcher.linkSection({
                title: "Shortcuts",
                list: localLinks.concat(remoteLinks)
            }));

            // if we're an admin, put some project admin links in too
            if(NL.isUserAdmin)
            {
                that.addProjectShortcutsCog(projectData.key, projectData.entityType);
            }

            that.populateProjectHeader(projectData.name, projectData.avatarUrl);

            that.bindAnalyticsHandlers(that.getSidebar(), data);
        };

        // Warning: ick.
        this.entityMappings = {
            'confluence.space': 'com.atlassian.applinks.api.application.confluence.ConfluenceSpaceEntityType',
            'jira.project': 'com.atlassian.applinks.api.application.jira.JiraProjectEntityType',
            'bamboo.project': 'com.atlassian.applinks.api.application.bamboo.BambooProjectEntityType',
            'stash.project': 'com.atlassian.applinks.api.application.stash.StashProjectEntityType'
        }
        this.generateEntityLinksUrl = function(projectKey, entityType) {
            // special case for confluence which has a much nicer entity links page
            if (entityType === that.entityMappings['confluence.space']) {
                return AJS.contextPath() + '/spaces/listentitylinks.action?typeId=' + entityType + '&key=' + projectKey;
            } else {
                return AJS.contextPath() + '/plugins/servlet/applinks/listEntityLinks/' + entityType + '/' + projectKey;
            }
        }

        this.showAppSwitcherError = function () {
            $(function () {
                var $sidebar = that.getSidebar();
                $sidebar.find('.app-switcher-applications .app-switcher-loading')
                        .replaceWith(navlinks.templates.appswitcher.error())
                $sidebar.off('.appswitcher')
                        .on('click.appswitcher', '.app-switcher-retry', $.proxy(that.retryLoading, that));
            });
        };

        this.showProjectShortcutsError = function () {
            $(function () {
                var $sidebar = that.getSidebar();
                $sidebar.find('.app-switcher-shortcuts .app-switcher-loading')
                    .replaceWith(navlinks.templates.appswitcher.error());
                $sidebar.off('.appswitcher')
                    .on('click.appswitcher', '.app-switcher-retry', $.proxy(that.retryLoading, that));
            });
        };

        this.retryLoading = function (e) {
            this.getSidebar().html(navlinks.templates.appswitcher.sidebarContents());
            this.getLinks();
            this.getProjectData();
            e && e.stopPropagation();
        };

        this.bindAnalyticsHandlers = function ($sidebar, apps) {
            // TODO: reconsider what we want to capture
        };

        this.getLinks();
        $(this.getProjectData);

        this.toggleSidebar = function(event){
            var sidebar = that.getSidebar(),
                body = $('body'), document = $(window.document);

            if (!body.hasClass('app-switcher-open')) {
                var header = $('#header');

                //append the sidebar to the body if this is the first toggle call.
                sidebar.css('left', -sidebar.width());
                sidebar.parent('body').length || sidebar.appendTo('body');
                sidebarStalk({data: sidebar});
                //Animation can be kicked off now that things are in position
                sidebar.animate({'left': 0}, 300);

                function closeSidebar(closeEvent){
                    var target = closeEvent.target && $(closeEvent.target),
                        keyCode = closeEvent.keyCode;

                    //shortcut out if this is the same even which bound the event to begin with
                    if( closeEvent.originalEvent === event.originalEvent ) {
                        return;
                    }

                    if (target && !keyCode && !(target.closest(sidebar).length || target.closest(header).length)
                            && event.which == 1 && !(closeEvent.shiftKey || closeEvent.ctrlKey || closeEvent.metaKey)){
                        //event is a click outside of the toolbar or header
                        that.toggleSidebar();
                    } else if (keyCode === 27) {
                        //event is the escape key
                        that.toggleSidebar();
                    }
                }
                document.on('click.appSwitcher', closeSidebar);
                document.on('keydown.appSwitcher', closeSidebar);
                document.on('scroll.appSwitcher', sidebar, sidebarStalk);
            } else {
                document.off('.appSwitcher');
            }
            body.toggleClass('app-switcher-open');
        }

        $('#header').on('click', '.app-switcher-trigger', this.toggleSidebar);
    };

    function sidebarStalk(event){
        var scrollPosition = $(document).scrollTop(),
            header = $('#header'),
            topOffset = (header.height() + header.offset().top) - scrollPosition;

        if ( topOffset >= 0 ) {
            event.data.css({top: topOffset, position: 'fixed'});
        } else {
            event.data.css({top: 0, left: 0, position: 'fixed'});
        }
    }

    if (NL.onInit) {
        NL.onInit();
    }
}(jQuery, window.NL = (window.NL || {})));
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher_old.js' */
var APPSWITCHER_TRIGGER_CLICK = "appswitcher.trigger.click";
var APPSWITCHER_DROPDOWN_SHOW = "appswitcher.dropdown.show";
var APPSWITCHER_DROPDOWN_DISPLAY_ERROR = "appswitcher.dropdown.display.error";
var APPSWITCHER_APP_LINK_CLICK = "appswitcher.app.link.click";
var APPSWITCHER_CONFIGURE_LINK_CLICK = "appswitcher.configure.link.click";

(function ($, NL) {
    NL.AppSwitcher = function (options) {
        var ADMIN_EDIT_PATH = AJS.contextPath() + "/plugins/servlet/customize-application-navigator";
        var GLOBAL_BILLING_SYSTEM_DARK_FEATURE_KEY = "unified.usermanagement";
        var that = this;
        this.$dropdown = null;

        options = $.extend({
            dropdownContents: null
        }, options);

        this.getLinks = function () {
            return $.ajax({
                url: AJS.contextPath() + '/rest/menu/latest/appswitcher',
                cache: false,
                dataType: 'json'
            }).done(this.updateDropdown).fail(this.showError);
        };

        this.getDropdown = function () {
            if (!this.$dropdown) {
                this.$dropdown = $(options.dropdownContents);
            }
            return this.$dropdown;
        };

        this.updateDropdown = function (data) {
            $(function () {
                that.getDropdown().html(navlinks.templates.appswitcher_old.applications({
                    apps: data,
                    showAdminLink: NL.environment.isUserAdmin,
                    adminLink: ADMIN_EDIT_PATH
                }));

                that.bindAnalyticsHandlers();
                if (NL.environment.isAppSuggestionAvailable === true) {
                    that.handleSuggestionApps(data);
                }
            });
        };

        this.bindAnalyticsHandlers = function () {
            $(".app-switcher-trigger").on("click", function() {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_TRIGGER_CLICK});
            });

            $("#app-switcher").on("aui-dropdown2-show", function() {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_DROPDOWN_SHOW});
            });

            $('#app-switcher .nav-link').on('click', function() {
                var product = "custom";
                var productLink = $(this).find("a");
                var url = productLink.attr("href");
                var hostname = window.location.hostname;

                if (url.indexOf(hostname + "/wiki") > -1) {
                    product = "confluence";
                } else if (url.indexOf(hostname + "/build") > -1) {
                    product = "bamboo";
                } else if (url.indexOf(hostname) > -1) {
                    product = "jira";
                }

                AJS.trigger("analyticsEvent", {
                    name: APPSWITCHER_APP_LINK_CLICK,
                    data: { product: product }
                });
            });

            $('.nav-link-edit-wrapper').on('click', function() {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_CONFIGURE_LINK_CLICK});
            })
        };

        this.isBillingSystemEnabled = function() {
            return (NL.environment.isSiteAdminUser === true) && AJS.DarkFeatures.isEnabled(GLOBAL_BILLING_SYSTEM_DARK_FEATURE_KEY);
        };

        this.handleSuggestionApps = function(data) {

            var installedApps = _.map(data, function (app) {
                return app.applicationType.toLowerCase();
            });

            var $suggestionApps = $("<div id='app-switcher-suggestion-apps' class='aui-dropdown2-section'/>");
            $suggestionApps.html(navlinks.templates.appswitcher_old.suggestionApps);

            var apps = $suggestionApps.find('.suggestion-apps');
            var hasSuggestionApps = false;
            _.each(suggestions, function(value) {
                if (!_.contains(installedApps, value.appName)) {
                    hasSuggestionApps = true;
                    apps.append(navlinks.templates.appswitcher_old.suggestionApp({
                        suggestionApp: value,
                        isBillingSystemEnabled:  that.isBillingSystemEnabled()
                    }));
                }
            });

            if (!hasSuggestionApps) return;

            $("#app-switcher").append($suggestionApps);

            $('.app-discovery-suggestion-app').click(function () {
                var $suggestionAppLink = $(this).find("a");
                var eventName;
                if (NL.environment.isSiteAdminUser) {
                    eventName = 'appswitcher.discovery.siteadmin.select.inproduct.';
                } else {
                    eventName = 'appswitcher.discovery.user.select.';
                }
                eventName = eventName + $suggestionAppLink.attr("id").toLowerCase();
                AJS.trigger("analytics", {name: eventName});
            });

            $('.app-discovery-suggestion-app').hover(function () {
                $(this).find("a").removeClass("active").removeClass("aui-dropdown2-active");
            });

            $('.app-discovery-cancel-button').click(function () {
                AJS.trigger("analytics", {name: "appswitcher.discovery.nothanks.button.click"});
                storeUserStorageData(KEY_NO_THANKS, "true");
                $suggestionApps.remove();
            });
        };

        this.showError = function () {
            $(function () {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_DROPDOWN_DISPLAY_ERROR});
                that.getDropdown()
                    .html(navlinks.templates.appswitcher_old.error())
                    .off('.appswitcher')
                    .on('click.appswitcher', '.app-switcher-retry', $.proxy(that.retryLoading, that));
            });
        };

        this.retryLoading = function (e) {
            this.getDropdown().html(navlinks.templates.appswitcher_old.loading());
            this.getLinks();
            e && e.stopPropagation();
        };

        this.getLinks();
    };

    var KEY_NO_THANKS = "key-no-thanks";
    var suggestions = [
        {
            appName: "jira",
            appDesc: "Issue & Project Tracking Software",
            discoveryUrl: 'https://www.atlassian.com/software/jira',
            billingSystemDiscoveryUrl: '/admin/billing/addapplication'
        },
        {
            appName: "confluence",
            appDesc: "Collaboration and content sharing",
            discoveryUrl: 'https://www.atlassian.com/software/confluence',
            billingSystemDiscoveryUrl: '/admin/billing/addapplication?product=confluence.ondemand'
        },
        {
            appName: "bamboo",
            appDesc: "Continuous integration",
            discoveryUrl: 'https://www.atlassian.com/software/bamboo',
            billingSystemDiscoveryUrl: '/admin/billing/addapplication?product=bamboo.ondemand'
        }];

    var storeUserStorageData = function (key, value) {
        $.ajax({
            url: AJS.contextPath() + '/rest/menu/latest/userdata/',
            type: "PUT",
            contentType: "application/json",
            data: JSON.stringify({
                key: key,
                value:value
            })
        });
    };

    if (NL.onInit) {
        NL.onInit();
    }


}(jQuery, window.NL = (window.NL || {})));;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher_old.soy' */
// This file was automatically generated from appswitcher_old.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.appswitcher_old.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.appswitcher_old == 'undefined') { navlinks.templates.appswitcher_old = {}; }


navlinks.templates.appswitcher_old.applications = function(opt_data, opt_ignored) {
  return '' + navlinks.templates.appswitcher_old.applicationsSection({list: opt_data.apps, listClass: 'nav-links', showDescription: opt_data.showDescription}) + ((opt_data.custom) ? navlinks.templates.appswitcher_old.applicationsSection({list: opt_data.custom, showDescription: opt_data.showDescription}) : '') + ((opt_data.showAdminLink) ? navlinks.templates.appswitcher_old.adminSection(opt_data) : '');
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.applications.soyTemplateName = 'navlinks.templates.appswitcher_old.applications';
}


navlinks.templates.appswitcher_old.applicationsSection = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.list.length > 0) {
    var param19 = '<ul' + ((opt_data.listClass) ? ' class="' + soy.$$escapeHtml(opt_data.listClass) + '"' : '') + '>';
    var linkList27 = opt_data.list;
    var linkListLen27 = linkList27.length;
    for (var linkIndex27 = 0; linkIndex27 < linkListLen27; linkIndex27++) {
      var linkData27 = linkList27[linkIndex27];
      param19 += navlinks.templates.appswitcher_old.applicationsItem(soy.$$augmentMap(linkData27, {showDescription: opt_data.showDescription}));
    }
    param19 += '</ul>';
    output += aui.dropdown2.section({content: param19});
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.applicationsSection.soyTemplateName = 'navlinks.templates.appswitcher_old.applicationsSection';
}


navlinks.templates.appswitcher_old.applicationsItem = function(opt_data, opt_ignored) {
  return '<li class="nav-link' + ((opt_data.self) ? ' nav-link-local' : '') + '"><a href="' + soy.$$escapeHtml(opt_data.link) + '" class="aui-dropdown2-radio ' + ((opt_data.self) ? 'aui-dropdown2-checked' : '') + '" title="' + soy.$$escapeHtml(opt_data.link) + '"><span class="nav-link-label">' + soy.$$escapeHtml(opt_data.label) + '</span>' + ((opt_data.showDescription && opt_data.description) ? '<span class="nav-link-description">' + soy.$$escapeHtml(opt_data.description) + '</span>' : '') + '</a></li>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.applicationsItem.soyTemplateName = 'navlinks.templates.appswitcher_old.applicationsItem';
}


navlinks.templates.appswitcher_old.adminSection = function(opt_data, opt_ignored) {
  return '' + aui.dropdown2.section({content: '<ul class="nav-links"><li><a class="nav-link-edit-wrapper" href="' + soy.$$escapeHtml(opt_data.adminLink) + '"><span class="nav-link-edit">' + soy.$$filterNoAutoescape("Configure\x26hellip;") + '</span></a></li></ul>'});
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.adminSection.soyTemplateName = 'navlinks.templates.appswitcher_old.adminSection';
}


navlinks.templates.appswitcher_old.error = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-error">' + soy.$$filterNoAutoescape("Something went wrong, please \x3cspan class\x3d\x22app-switcher-retry\x22\x3etry again\x3c/span\x3e.") + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.error.soyTemplateName = 'navlinks.templates.appswitcher_old.error';
}


navlinks.templates.appswitcher_old.loading = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-loading">' + soy.$$filterNoAutoescape("Loading\x26hellip;") + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.loading.soyTemplateName = 'navlinks.templates.appswitcher_old.loading';
}


navlinks.templates.appswitcher_old.trigger = function(opt_data, opt_ignored) {
  return '<span class="aui-icon aui-icon-small aui-iconfont-appswitcher">' + soy.$$escapeHtml("Linked Applications") + '</span>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.trigger.soyTemplateName = 'navlinks.templates.appswitcher_old.trigger';
}


navlinks.templates.appswitcher_old.switcher = function(opt_data, opt_ignored) {
  var output = '';
  if (true) {
    var loadingContent__soy81 = '' + navlinks.templates.appswitcher_old.loading(null);
    var triggerContent__soy83 = '' + navlinks.templates.appswitcher_old.trigger(null);
    output += aui.dropdown2.dropdown2({menu: {id: 'app-switcher', content: loadingContent__soy81, extraClasses: 'aui-style-default'}, trigger: {showIcon: false, content: triggerContent__soy83, extraClasses: 'app-switcher-trigger', extraAttributes: {href: '#app-switcher'}}}) + '<script>\n            (function (NL) {\n                var initialise = function () {\n                    // For some milestones of AUI, the atlassian soy namespace was renamed to aui. Handle that here by ensuring that window.atlassian is defined.\n                    window.atlassian = window.atlassian || window.aui;\n                    new NL.AppSwitcher({\n                        dropdownContents: \'#app-switcher\'\n                    });\n                };\n                if (NL.AppSwitcher) {\n                    initialise();\n                } else {\n                    NL.onInit = initialise;\n                }\n            }(window.NL = (window.NL || {})));\n            window.NL.environment = ' + soy.$$escapeHtml({}) + ';<\/script>';
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.switcher.soyTemplateName = 'navlinks.templates.appswitcher_old.switcher';
}


navlinks.templates.appswitcher_old.suggestionApp = function(opt_data, opt_ignored) {
  var output = '';
  var href__soy92 = opt_data.isBillingSystemEnabled == true ? opt_data.suggestionApp.billingSystemDiscoveryUrl : opt_data.suggestionApp.discoveryUrl;
  output += '<li class="app-discovery-suggestion-app"><a id="' + soy.$$escapeHtml(opt_data.suggestionApp.appName) + '" href="' + soy.$$escapeHtml(href__soy92) + '" class="app-discovery-link aui-icon-container app-discovery-' + soy.$$escapeHtml(opt_data.suggestionApp.appName) + '-product-icon" title="' + soy.$$escapeHtml(href__soy92) + '" target="_blank"/><div class="app-discovery-small">' + soy.$$escapeHtml(opt_data.suggestionApp.appDesc) + '</div></li>';
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.suggestionApp.soyTemplateName = 'navlinks.templates.appswitcher_old.suggestionApp';
}


navlinks.templates.appswitcher_old.suggestionApps = function(opt_data, opt_ignored) {
  return '<ul class=\'nav-links suggestion-apps\'><li><span class=\'app-discovery-suggest-title nav-link-label\'><h6>' + soy.$$escapeHtml("Try other Atlassian apps") + '</h6></span></li></ul><div class=\'buttons-container app-discovery-suggest-apps-buttons\'><div class=\'buttons\'><button class=\'aui-button aui-button-link app-discovery-cancel-button\' name=\'cancel\' accesskey=\'c\' href=\'#\'>' + soy.$$escapeHtml("Don\x27t show this again") + '</button></div></div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.suggestionApps.soyTemplateName = 'navlinks.templates.appswitcher_old.suggestionApps';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:jira-header', location = 'soy/headerDropdown.soy' */
// This file was automatically generated from headerDropdown.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Menu.Dropdowns.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Menu == 'undefined') { JIRA.Templates.Menu = {}; }
if (typeof JIRA.Templates.Menu.Dropdowns == 'undefined') { JIRA.Templates.Menu.Dropdowns = {}; }


JIRA.Templates.Menu.Dropdowns.dropdown2Fragment = function(opt_data, opt_ignored) {
  var output = '';
  var sectionList3 = opt_data.sections;
  var sectionListLen3 = sectionList3.length;
  for (var sectionIndex3 = 0; sectionIndex3 < sectionListLen3; sectionIndex3++) {
    var sectionData3 = sectionList3[sectionIndex3];
    var hasItems__soy4 = sectionData3.items && sectionData3.items.length > 0;
    output += '<div class="aui-dropdown2-section">' + ((hasItems__soy4 && sectionData3.label) ? '<strong>' + soy.$$escapeHtml(sectionData3.label) + '</strong>' : '') + '<ul class=\'aui-list-truncate\'' + ((sectionData3.id) ? ' id="' + soy.$$escapeHtml(sectionData3.id) + '"' : '') + ((sectionData3.style) ? ' class="' + soy.$$escapeHtml(sectionData3.style) + '"' : '') + '>';
    if (hasItems__soy4) {
      var itemList25 = sectionData3.items;
      var itemListLen25 = itemList25.length;
      for (var itemIndex25 = 0; itemIndex25 < itemListLen25; itemIndex25++) {
        var itemData25 = itemList25[itemIndex25];
        output += JIRA.Templates.Menu.Dropdowns.dropdown2Item(itemData25);
      }
    }
    output += '</ul></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Menu.Dropdowns.dropdown2Fragment.soyTemplateName = 'JIRA.Templates.Menu.Dropdowns.dropdown2Fragment';
}


JIRA.Templates.Menu.Dropdowns.dropdown2Item = function(opt_data, opt_ignored) {
  var output = '<li' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ((opt_data.style) ? ' class="' + soy.$$escapeHtml(opt_data.style) + '"' : '') + '><a href="' + soy.$$escapeHtml(opt_data.url) + '"' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '_lnk"' : '') + ((opt_data.title) ? ' title="' + soy.$$escapeHtml(opt_data.title) + '"' : '') + ' class="' + ((opt_data.iconUrl) ? 'aui-icon-container' : '') + ((opt_data.parameters && opt_data.parameters['class']) ? ' ' + soy.$$escapeHtml(opt_data.parameters['class']) : '') + '"';
  if (opt_data.parameters) {
    var keyList66 = soy.$$getMapKeys(opt_data.parameters);
    var keyListLen66 = keyList66.length;
    for (var keyIndex66 = 0; keyIndex66 < keyListLen66; keyIndex66++) {
      var keyData66 = keyList66[keyIndex66];
      output += (keyData66 != 'class') ? ' ' + soy.$$escapeHtml(keyData66) + '="' + soy.$$escapeHtml(opt_data.parameters[keyData66]) + '"' : '';
    }
  }
  output += '>' + ((opt_data.iconUrl) ? '<img class="icon" src="' + soy.$$escapeHtml(opt_data.iconUrl) + '" />' : '') + soy.$$escapeHtml(opt_data.label) + '</a></li>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Menu.Dropdowns.dropdown2Item.soyTemplateName = 'JIRA.Templates.Menu.Dropdowns.dropdown2Item';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:jira-header', location = 'js/init-dropdown2.js' */
/**
 * JIRA's implementation of AUI Dropdown2 remote API (https://extranet.atlassian.com/display/AUI/Dropdown2+remote+API).
 *
 * This predates AUI Dropdown2, and allows the application header menus to be dynamic and populated via AJAX. This is
 * required for menus that are dynamic (e.g. Issues or Projects).
 *
 * In addition to the normal `aui-dropdown2-show` event that is triggered on the dropdown, two extra events are
 * triggered to expose the asynchronous nature of the menus:
 *
 * - `aui-dropdown2-show-before` is triggered _before_ a dropdown is shown (due to implementation details, this is
 *    unfortunately triggered after `aui-dropdown2-show`).
 * - `aui-dropdown2-show-after` is triggered when the dropdown is populated and visible to the user. It is triggered for
 *    both remote dropdowns and normal dropdowns.
 *
 * The class `aui-dropdown2-loading` is added to the dropdown between `aui-dropdown2-show-before` and
 * `aui-dropdown2-show-after`.
 */
require(['jira/ajs/ajax/smart-ajax', 'jquery'], function (SmartAjax, $) {
    $(function () {
        $("nav.aui-header a.aui-dropdown2-trigger").each(function() {
            var $trigger = $(this);
            var $dropdown = $("#" + $trigger.attr("aria-owns"));
            var ajaxKey = $dropdown.data("aui-dropdown2-ajax-key");

            $dropdown.bind("aui-dropdown2-show", function (event, options) {
                $dropdown.trigger('aui-dropdown2-show-before');

                if (ajaxKey) {
                    // JIRA's own implementation of Dropdown2 remote API. This predates Dropdown2 remote, and should be
                    // removed when Dropdown2 remote API lands in AUI.
                    $dropdown.empty();
                    $dropdown.addClass("aui-dropdown2-loading");
                    SmartAjax.makeRequest({
                        url: AJS.contextPath() + "/rest/api/1.0/menus/" + ajaxKey,
                        data: {
                            inAdminMode: AJS.Meta.getBoolean("in-admin-mode")
                        },
                        dataType: "json",
                        cache: false,
                        success: function (data) {
                            $dropdown.removeClass("aui-dropdown2-loading");
                            $dropdown.html(JIRA.Templates.Menu.Dropdowns.dropdown2Fragment(data));

                            if (options && options.selectFirst) {
                                $dropdown.find("a:not(.disabled)").filter(":first").addClass("active");
                            }
                            $dropdown.trigger('aui-dropdown2-show-after');
                        }
                    });
                } else {
                    $dropdown.trigger('aui-dropdown2-show-after');
                }
            });
        });
    });
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/keymaster.js' */
//     keymaster.js
//     (c) 2011-2013 Thomas Fuchs
//     keymaster.js may be freely distributed under the MIT license.

;(function(global){
    var k,
            _handlers = {},
            _mods = { 16: false, 18: false, 17: false, 91: false },
            _scope = 'all',
    // modifier keys
            _MODIFIERS = {
                'â§': 16, shift: 16,
                'â¥': 18, alt: 18, option: 18,
                'â': 17, ctrl: 17, control: 17,
                'â': 91, command: 91
            },
    // special keys
            _MAP = {
                backspace: 8, tab: 9, clear: 12,
                enter: 13, 'return': 13,
                esc: 27, escape: 27, space: 32,
                left: 37, up: 38,
                right: 39, down: 40,
                del: 46, 'delete': 46,
                home: 36, end: 35,
                pageup: 33, pagedown: 34,
                ',': 188, '.': 190, '/': 191,
                '`': 192, '-': 189, '=': 187,
                ';': 186, '\'': 222,
                '[': 219, ']': 221, '\\': 220
            },
            code = function(x){
                return _MAP[x] || x.toUpperCase().charCodeAt(0);
            },
            _downKeys = [];

    for(k=1;k<20;k++) _MAP['f'+k] = 111+k;

    // IE doesn't support Array#indexOf, so have a simple replacement
    function index(array, item){
        var i = array.length;
        while(i--) if(array[i]===item) return i;
        return -1;
    }

    // for comparing mods before unassignment
    function compareArray(a1, a2) {
        if (a1.length != a2.length) return false;
        for (var i = 0; i < a1.length; i++) {
            if (a1[i] !== a2[i]) return false;
        }
        return true;
    }

    var modifierMap = {
        16:'shiftKey',
        18:'altKey',
        17:'ctrlKey',
        91:'metaKey'
    };
    function updateModifierKey(event) {
        for(k in _mods) _mods[k] = event[modifierMap[k]];
    };

    // handle keydown event
    function dispatch(event) {
        var key, handler, k, i, modifiersMatch, scope;
        key = event.keyCode;

        if (index(_downKeys, key) == -1) {
            _downKeys.push(key);
        }

        // if a modifier key, set the key.<modifierkeyname> property to true and return
        if(key == 93 || key == 224) key = 91; // right command on webkit, command on Gecko
        if(key in _mods) {
            _mods[key] = true;
            // 'assignKey' from inside this closure is exported to window.key
            for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = true;
            return;
        }
        updateModifierKey(event);

        // see if we need to ignore the keypress (filter() can can be overridden)
        // by default ignore key presses if a select, textarea, or input is focused
        if(!assignKey.filter.call(this, event)) return;

        // abort if no potentially matching shortcuts found
        if (!(key in _handlers)) return;

        scope = getScope();

        // for each potential shortcut
        for (i = 0; i < _handlers[key].length; i++) {
            handler = _handlers[key][i];

            // see if it's in the current scope
            if(handler.scope == scope || handler.scope == 'all'){
                // check if modifiers match if any
                modifiersMatch = handler.mods.length > 0;
                for(k in _mods)
                    if((!_mods[k] && index(handler.mods, +k) > -1) ||
                            (_mods[k] && index(handler.mods, +k) == -1)) modifiersMatch = false;
                // call the handler and stop the event if neccessary
                if((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch){
                    if(handler.method(event, handler)===false){
                        if(event.preventDefault) event.preventDefault();
                        else event.returnValue = false;
                        if(event.stopPropagation) event.stopPropagation();
                        if(event.cancelBubble) event.cancelBubble = true;
                    }
                }
            }
        }
    };

    // unset modifier keys on keyup
    function clearModifier(event){
        var key = event.keyCode, k,
                i = index(_downKeys, key);

        // remove key from _downKeys
        if (i >= 0) {
            _downKeys.splice(i, 1);
        }

        if(key == 93 || key == 224) key = 91;
        if(key in _mods) {
            _mods[key] = false;
            for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = false;
        }
    };

    function resetModifiers() {
        for(k in _mods) _mods[k] = false;
        for(k in _MODIFIERS) assignKey[k] = false;
    };

    // parse and assign shortcut
    function assignKey(key, scope, method){
        var keys, mods;
        keys = getKeys(key);
        if (method === undefined) {
            method = scope;
            scope = 'all';
        }

        // for each shortcut
        for (var i = 0; i < keys.length; i++) {
            // set modifier keys if any
            mods = [];
            key = keys[i].split('+');
            if (key.length > 1){
                mods = getMods(key);
                key = [key[key.length-1]];
            }
            // convert to keycode and...
            key = key[0]
            key = code(key);
            // ...store handler
            if (!(key in _handlers)) _handlers[key] = [];
            _handlers[key].push({ shortcut: keys[i], scope: scope, method: method, key: keys[i], mods: mods });
        }
    };

    // unbind all handlers for given key in current scope
    function unbindKey(key, scope) {
        var multipleKeys, keys,
                mods = [],
                i, j, obj;

        multipleKeys = getKeys(key);

        for (j = 0; j < multipleKeys.length; j++) {
            keys = multipleKeys[j].split('+');

            if (keys.length > 1) {
                mods = getMods(keys);
                key = keys[keys.length - 1];
            }

            key = code(key);

            if (scope === undefined) {
                scope = getScope();
            }
            if (!_handlers[key]) {
                return;
            }
            for (i in _handlers[key]) {
                obj = _handlers[key][i];
                // only clear handlers if correct scope and mods match
                if (obj.scope === scope && compareArray(obj.mods, mods)) {
                    _handlers[key][i] = {};
                }
            }
        }
    };

    // Returns true if the key with code 'keyCode' is currently down
    // Converts strings into key codes.
    function isPressed(keyCode) {
        if (typeof(keyCode)=='string') {
            keyCode = code(keyCode);
        }
        return index(_downKeys, keyCode) != -1;
    }

    function getPressedKeyCodes() {
        return _downKeys.slice(0);
    }

    function filter(event){
        var tagName = (event.target || event.srcElement).tagName;
        // ignore keypressed in any elements that support keyboard data input
        return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');
    }

    // initialize key.<modifier> to false
    for(k in _MODIFIERS) assignKey[k] = false;

    // set current scope (default 'all')
    function setScope(scope){ _scope = scope || 'all' };
    function getScope(){ return _scope || 'all' };

    // delete all handlers for a given scope
    function deleteScope(scope){
        var key, handlers, i;

        for (key in _handlers) {
            handlers = _handlers[key];
            for (i = 0; i < handlers.length; ) {
                if (handlers[i].scope === scope) handlers.splice(i, 1);
                else i++;
            }
        }
    };

    // abstract key logic for assign and unassign
    function getKeys(key) {
        var keys;
        key = key.replace(/\s/g, '');
        keys = key.split(',');
        if ((keys[keys.length - 1]) == '') {
            keys[keys.length - 2] += ',';
        }
        return keys;
    }

    // abstract mods logic for assign and unassign
    function getMods(key) {
        var mods = key.slice(0, key.length - 1);
        for (var mi = 0; mi < mods.length; mi++)
            mods[mi] = _MODIFIERS[mods[mi]];
        return mods;
    }

    // cross-browser events
    function addEvent(object, event, method) {
        if (object.addEventListener)
            object.addEventListener(event, method, false);
        else if(object.attachEvent)
            object.attachEvent('on'+event, function(){ method(window.event) });
    };

    // set the handlers globally on document
    addEvent(document, 'keydown', function(event) { dispatch(event) }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48
    addEvent(document, 'keyup', clearModifier);

    // reset modifiers to false whenever the window is (re)focused.
    addEvent(window, 'focus', resetModifiers);

    // store previously defined key
    var previousKey = global.key;

    // restore previously defined key and return reference to our key object
    function noConflict() {
        var k = global.key;
        global.key = previousKey;
        return k;
    }

    // set window.key and window.key.set/get/deleteScope, and the default filter
    global.key = assignKey;
    global.key.setScope = setScope;
    global.key.getScope = getScope;
    global.key.deleteScope = deleteScope;
    global.key.filter = filter;
    global.key.isPressed = isPressed;
    global.key.getPressedKeyCodes = getPressedKeyCodes;
    global.key.noConflict = noConflict;
    global.key.unbind = unbindKey;

    if(typeof module !== 'undefined') module.exports = key;

})(this);;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/amd-wrappers.js' */
/* AMD wrappers for commonly used objects */

define('wiki-edit/aui', function() { return AJS; });
define('wiki-edit/JIRA', function() { return JIRA; });
define('wiki-edit/keymaster', ["wiki-edit/aui"], function(AJS) {
    if (AJS.Meta.get("keyboard-shortcuts-enabled") === false) {
        return function keyMasterNoop() {};
    }
    return key.noConflict();
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/templates/wiki-editor.soy' */
// This file was automatically generated from wiki-editor.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Plugins.WikiEditor.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Plugins == 'undefined') { JIRA.Templates.Plugins = {}; }
if (typeof JIRA.Templates.Plugins.WikiEditor == 'undefined') { JIRA.Templates.Plugins.WikiEditor = {}; }


JIRA.Templates.Plugins.WikiEditor.renderEditor = function(opt_data, opt_ignored) {
  var output = '<div id="wiki-edit-dropdown2-text-style-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="paragraph" title="' + soy.$$escapeHtml("Paragraph") + '">' + soy.$$escapeHtml("Paragraph") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h1" data-operation="h1" title="' + soy.$$escapeHtml("Heading 1") + '">' + soy.$$escapeHtml("Heading 1") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h2" data-operation="h2" title="' + soy.$$escapeHtml("Heading 2") + '">' + soy.$$escapeHtml("Heading 2") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h3" data-operation="h3" title="' + soy.$$escapeHtml("Heading 3") + '">' + soy.$$escapeHtml("Heading 3") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h4" data-operation="h4" title="' + soy.$$escapeHtml("Heading 4") + '">' + soy.$$escapeHtml("Heading 4") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h5" data-operation="h5" title="' + soy.$$escapeHtml("Heading 5") + '">' + soy.$$escapeHtml("Heading 5") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h6" data-operation="h6" title="' + soy.$$escapeHtml("Heading 6") + '">' + soy.$$escapeHtml("Heading 6") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-monospace" data-operation="monospace" title="' + soy.$$escapeHtml("Preformatted") + '">' + soy.$$escapeHtml("Preformatted") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="paragraph-quote" title="' + soy.$$escapeHtml("Paragraph quote") + '">' + soy.$$escapeHtml("Paragraph quote") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="block-quote" title="' + soy.$$escapeHtml("Block quote") + '">' + soy.$$escapeHtml("Block quote") + '</a></li></ul></div></div><div id="wiki-edit-dropdown2-more-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="delete" data-shortcut="ctrl+shift+s, command+shift+s" title="' + soy.$$escapeHtml("Strikethrough") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+Shift+S)">' + soy.$$escapeHtml("Strikethrough") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="superscript">' + soy.$$escapeHtml("Superscript") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="subscript">' + soy.$$escapeHtml("Subscript") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="cite">' + soy.$$escapeHtml("Citation") + '</a></li></ul></div></div><div id="wiki-edit-dropdown2-link-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown wiki-edit-dropdown-link"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="link" data-shortcut="ctrl+k, command+k" title="' + soy.$$escapeHtml("External link") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+K)">' + soy.$$escapeHtml("External link") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="link-mail">' + soy.$$escapeHtml("Mail link") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="link-anchor">' + soy.$$escapeHtml("Anchor link") + '</a></li>' + ((! opt_data.attachmentM2FeatureFlag) ? '<li><a href="#" class="wiki-edit-operation" data-operation="link-attachment">' + soy.$$escapeHtml("Attachment link") + '</a></li>' : '') + '</ul></div>' + ((! opt_data.attachmentM2FeatureFlag) ? '<div class="aui-dropdown2-section wiki-edit-insert-link"><strong>' + soy.$$escapeHtml("Attachment link") + '</strong><ul class="aui-list-truncate"><li><a href="#"></a></li></ul></div>' : '') + '</div>' + ((! opt_data.attachmentM2FeatureFlag) ? '<div id="wiki-edit-dropdown2-image-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown wiki-edit-dropdown-image"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="image" title="' + soy.$$escapeHtml("External image") + '">' + soy.$$escapeHtml("External image") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="image-attachment">' + soy.$$escapeHtml("Attached image") + '</a></li></ul></div><div class="aui-dropdown2-section wiki-edit-insert-image"><strong>' + soy.$$escapeHtml("Attached image") + '</strong><ul class="aui-list-truncate"><li><a href="#"></a></li></ul></div></div>' : '<div id="wiki-edit-dropdown2-attachment-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown wiki-edit-dropdown-attachment"><div class="aui-dropdown2-section wiki-edit-insert-attachment"><ul class="aui-list-truncate"><li><a href="#"></a></li></ul></div><div class="aui-dropdown2-section wiki-edit-browse-image"><ul class="aui-list-truncate"><li><a href="#" class="wiki-attachment-browse"><span class="aui-icon aui-icon-small aui-iconfont-add"></span>&nbsp;&nbsp;' + soy.$$escapeHtml("Browse") + '</a></li></ul></div></div>') + '<div id="wiki-edit-color-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-picker wiki-edit-color-picker" data-container="wiki-edit-color-picker-buttons-' + soy.$$escapeHtml(opt_data.editorId) + '">';
  var colors__soy108 = ['333333', '707070', 'cccccc', '205081', '59afe1', '14892c', '8eb021', 'd04437', 'f79232', 'f6c342', '654982', 'f691b2'];
  output += '<div class="aui-dropdown2-section"><ul>';
  var colorList110 = colors__soy108;
  var colorListLen110 = colorList110.length;
  for (var colorIndex110 = 0; colorIndex110 < colorListLen110; colorIndex110++) {
    var colorData110 = colorList110[colorIndex110];
    output += '<li><a href="#" style="background-color: #' + soy.$$escapeHtml(colorData110) + '" data-operation="color" data-color="#' + soy.$$escapeHtml(colorData110) + '">&nbsp;</a></li>';
  }
  output += '</ul></div></div><div id="wiki-edit-dropdown2-icon-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-picker wiki-edit-icon-picker" data-container="wiki-edit-icon-picker-buttons-' + soy.$$escapeHtml(opt_data.editorId) + '"><div class="aui-dropdown2-section"><ul><li><a href="#" class="wiki-edit-operation" title=":)" data-operation=":)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/smile.gif" alt="' + soy.$$escapeHtml("smile") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=":(" data-operation=":("><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/sad.gif" alt="' + soy.$$escapeHtml("sad") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=":P" data-operation=":P"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/tongue.gif" alt="' + soy.$$escapeHtml("tongue") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=":D" data-operation=":D"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/biggrin.gif" alt="' + soy.$$escapeHtml("biggrin") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=";)" data-operation=";)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/wink.gif" alt="' + soy.$$escapeHtml("wink") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(y)" data-operation="(y)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/thumbs_up.gif" alt="' + soy.$$escapeHtml("thumbs up") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(n)" data-operation="(n)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/thumbs_down.gif" alt="' + soy.$$escapeHtml("thumbs down") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(i)" data-operation="(i)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/information.gif" alt="' + soy.$$escapeHtml("information") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(/)" data-operation="(/)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/check.gif" alt="' + soy.$$escapeHtml("check") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(x)" data-operation="(x)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/error.gif" alt="' + soy.$$escapeHtml("error") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(!)" data-operation="(!)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/warning.gif" alt="' + soy.$$escapeHtml("warning") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(+)" data-operation="(+)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/add.gif" alt="' + soy.$$escapeHtml("add") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(-)" data-operation="(-)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/forbidden.gif" alt="' + soy.$$escapeHtml("forbidden") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(?)" data-operation="(?)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/help_16.gif" alt="' + soy.$$escapeHtml("help") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(on)" data-operation="(on)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/lightbulb_on.gif" alt="' + soy.$$escapeHtml("lightbulb on") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(off)" data-operation="(off)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/lightbulb.gif" alt="' + soy.$$escapeHtml("lightbulb") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*)" data-operation="(*)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_yellow.gif" alt="' + soy.$$escapeHtml("star yellow") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*r)" data-operation="(*r)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_red.gif" alt="' + soy.$$escapeHtml("star red") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*g)" data-operation="(*g)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_green.gif" alt="' + soy.$$escapeHtml("star green") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*b)" data-operation="(*b)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_blue.gif" alt="' + soy.$$escapeHtml("star blue") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*y)" data-operation="(*y)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_yellow.gif" alt="' + soy.$$escapeHtml("star yellow") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(flag)" data-operation="(flag)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/flag.gif" alt="' + soy.$$escapeHtml("flag") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(flagoff)" data-operation="(flagoff)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/flag_grey.gif" alt="' + soy.$$escapeHtml("flag off") + '" /></a></li></ul></div></div><div id="wiki-edit-dropdown2-other-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="mention">' + soy.$$escapeHtml("User mention") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="table">' + soy.$$escapeHtml("Table") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="code">' + soy.$$escapeHtml("Code") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="noformat">' + soy.$$escapeHtml("Preformatted") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="panel">' + soy.$$escapeHtml("Panel") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="hr">' + soy.$$escapeHtml("Horizontal ruler") + '</a></li><li class="wiki-edit-speech-item hidden"><a href="#" class="wiki-edit-operation" data-operation="speech">' + soy.$$escapeHtml("Speech recognition") + '</a></li></ul></div></div><div class="wiki-edit-toolbar" id="wiki-edit-' + soy.$$escapeHtml(opt_data.editorId) + '"><div class="aui-toolbar2"><div class="aui-toolbar2-inner"><div class="aui-toolbar2-primary"><div class="aui-buttons"><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-style-picker-trigger" aria-owns="wiki-edit-dropdown2-text-style-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-text-style-' + soy.$$escapeHtml(opt_data.editorId) + '">' + soy.$$escapeHtml("Style") + '</a></div><div class="aui-buttons wiki-edit-toolbar-section"><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="bold" data-shortcut="ctrl+b, command+b" title="' + soy.$$escapeHtml("Bold") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+B)"><span class="aui-icon aui-icon-small aui-iconfont-editor-bold">' + soy.$$escapeHtml("Bold") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="italic" data-shortcut="ctrl+i, command+i" title="' + soy.$$escapeHtml("Italic") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+I)"><span class="aui-icon aui-icon-small aui-iconfont-editor-italic">' + soy.$$escapeHtml("Italic") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="underline" data-shortcut="ctrl+u, command+u" title="' + soy.$$escapeHtml("Underline") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+U)"><span class="aui-icon aui-icon-small aui-iconfont-editor-underline">' + soy.$$escapeHtml("Underline") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation wiki-edit-operation-color" data-operation="color" data-color="red" title="' + soy.$$escapeHtml("Text color") + '"><span class="aui-icon aui-icon-small aui-iconfont-editor-color">' + soy.$$escapeHtml("Text color") + '</span><span class="wiki-edit-color-indicator"></span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-color-picker-trigger" data-operation="color-parameter" aria-owns="wiki-edit-color-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" title="' + soy.$$escapeHtml("More colors") + '"><span>' + soy.$$escapeHtml("More colors") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-more-picker-trigger" aria-owns="wiki-edit-dropdown2-more-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-more-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("More") + '"><span class="aui-icon aui-icon-small aui-iconfont-editor-styles">' + soy.$$escapeHtml("More") + '</span></a></div><div class="aui-buttons"><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-link-picker-trigger" aria-owns="wiki-edit-dropdown2-link-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-link-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Link") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+K)"><span class="aui-icon aui-icon-small aui-iconfont-link">' + soy.$$escapeHtml("Link") + '</span></a>' + ((! opt_data.attachmentM2FeatureFlag) ? '<a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-image-picker-trigger" aria-owns="wiki-edit-dropdown2-image-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-image-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Image") + '"><span class="aui-icon aui-icon-small aui-iconfont-image">' + soy.$$escapeHtml("Image") + '</span></a>' : '<a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-attachment-picker-trigger" aria-owns="wiki-edit-dropdown2-attachment-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-attachment-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Attachment") + '"><span class="aui-icon aui-icon-small aui-iconfont-file-generic">' + soy.$$escapeHtml("Attachment") + '</span></a>') + '</div><div class="aui-buttons wiki-edit-toolbar-section"><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="bullet-list" data-shortcut="ctrl+shift+b, command+shift+b" title="' + soy.$$escapeHtml("Bullet list") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+Shift+B)"><span class="aui-icon aui-icon-small aui-iconfont-editor-list-bullet">' + soy.$$escapeHtml("Bullet list") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="numbered-list" data-shortcut="ctrl+shift+n, command+shift+n" title="' + soy.$$escapeHtml("Numbered list") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+Shift+N)"><span class="aui-icon aui-icon-small aui-iconfont-editor-list-number">' + soy.$$escapeHtml("Numbered list") + '</span></a></div><div class="aui-buttons"><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-icon-picker-trigger wiki-edit-tooltip" aria-owns="wiki-edit-dropdown2-icon-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-icon-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Icons") + '"><span class="aui-icon aui-icon-small aui-iconfont-editor-emoticon">' + soy.$$escapeHtml("Icons") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-other-picker-trigger wiki-edit-tooltip" aria-owns="wiki-edit-dropdown2-other-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-other-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Other") + '"><span class="aui-icon aui-icon-small aui-iconfont-add">' + soy.$$escapeHtml("Other") + '</span></a></div><div class="aui-buttons wiki-edit-toolbar-last"><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-visible-toggle wiki-edit-tooltip" title="' + soy.$$escapeHtml("Toggle visibility") + '"><span class="aui-icon icon-toolbartoggle">Lock / Unlock</span></a></div></div></div><!-- .aui-toolbar-inner --></div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Plugins.WikiEditor.renderEditor.soyTemplateName = 'JIRA.Templates.Plugins.WikiEditor.renderEditor';
}


JIRA.Templates.Plugins.WikiEditor.renderListItem = function(opt_data, opt_ignored) {
  return '<li><a href="#" ' + soy.$$escapeHtml(opt_data.attachmentType ? 'data-attachment-type=' + opt_data.attachmentType : '') + '>' + ((opt_data.attachmentM2FeatureFlagEnabled) ? '<span class="wiki-edit-attachment-type-icon aui-icon aui-icon-small ' + soy.$$escapeHtml(((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.cssClass) != null ? ((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.cssClass) : 'aui-iconfont-file-txt') + '" title="' + soy.$$escapeHtml(((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.title) != null ? ((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.title) : 'File') + '"></span>&nbsp;&nbsp;' : '') + '<span class="wiki-edit-attachment-name">' + soy.$$escapeHtml(opt_data.text) + '</span></a></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.Plugins.WikiEditor.renderListItem.soyTemplateName = 'JIRA.Templates.Plugins.WikiEditor.renderListItem';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/Analytics.js' */
define('wiki-edit/analytics',[
    'wiki-edit/aui'
], function(AJS) {

    var triggerEvent = (AJS.Analytics && AJS.Analytics.triggerPrivacyPolicySafeEvent) ?
        (function triggerEvent(name, props) {
            AJS.Analytics.triggerPrivacyPolicySafeEvent('jira.wikieditor.' + name, props || {});
        }) :
        (function triggerEvent(name, props) {
            AJS.trigger("analytics", { name: 'jira.wikieditor.'+name, data: props || {} });
        });

    function hashCode (string) {
        var charCode;
        var hash = 0;
        if (!string) {
            return "";
        }

        for (var i = 0; i < string.length; i += 1) {
            charCode = string.charCodeAt(i);
            hash = ((hash * 32) - hash) + charCode;
            hash |= 0; // force 32-bit representation
        }

        return hash;
    }

    return {
        trigger: triggerEvent,
        hashCode: hashCode
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/KeyTester.js' */
define('wiki-edit/KeyTester', function() {

    return {
        getActionType: function(keyCode) {
            if (this.isNavigation(keyCode)) {
                return "navigating";
            } else if (this.isDeleting(keyCode)) {
                return "deleting";
            } else if (this.isReturn(keyCode)) {
                return "newline";
            } else if (this.isEscape(keyCode)) {
                return "escape";
            } else if (this.isTyping(keyCode)) {
                return "typing";
            }
        },
        isNavigation: function(keyCode) {
            // 33 - 40: page up/dn and arrow keys
            // 63232 - 63235: page up/dn and arrow keys on safari
            return (keyCode >= 33 && keyCode <= 40) || (keyCode >= 63232 && keyCode <= 63235);
        },
        isDeleting: function(keyCode) {
            // 8 - backspace
            // 46 - delete
            // 127 - delete
            return (keyCode == 8 || keyCode == 46 || keyCode == 127);
        },
        isReturn: function(keyCode) {
            return (keyCode == 13);
        },
        isEscape: function(keyCode) {
            return (keyCode == 27);
        },
// not needed at this stage but left for possible later use
//        isSpacebar: function(keyCode) {
//            return keyCode == 32; // spacebar
//        },
        isTyping: function(keyCode) {
            return (keyCode > 47 && keyCode < 58)   || // numbers
                   (keyCode > 95 && keyCode < 112)  || // numpad
                   (keyCode > 64 && keyCode < 91)   || // letters
                   (keyCode > 185 && keyCode < 193) || // ;=,-./`
                   (keyCode > 218 && keyCode < 223) || // [\]'
                    keyCode == 32                   || // spacebar
                    keyCode == 13;                     // return

        }
    };

});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/UndoManager.js' */
define('wiki-edit/UndoManager', function() {

    /**
     * Simple undo/redo manager.
     * Basically the structure is like [---undoList---][CURRENT][---redoList---].
     * All operations move the current element on that "concatenated" list.
     */
    var UndoManager =  function() {
        this._undoStack = [];
        this._redoStack = [];
        this._current = undefined;
    };

    UndoManager.prototype.MAX_STACK = 1000;
    /**
     * Sets the current state of the manager
     * @param {Anything} current - state
     * @param {Boolean} preserveRedo - if set to true existing redo entries will be preserved
     */
    UndoManager.prototype.updateCurrent = function(current, preserveRedo) {
        if (current != this._current) {
            this._current = current;
            if(!preserveRedo) {
                this._redoStack.length = 0; // reset the redo stack
            }
        }
    };

    /**
     * Add val to the undo stack and make it undoable
     * @param {Anything} val - state to be made undoable
     */
    UndoManager.prototype.push = function(val) {
        this._redoStack.length = 0; // reset the redo stack
        if (!this._undoStack.length || !_.isEqual(val, this._undoStack[this._undoStack.length - 1])) {
            this._undoStack.push(val);
            this._current = val;
        }
        if (this._undoStack.length > this.MAX_STACK) {
            this._undoStack.splice(0, this._undoStack.length - this.MAX_STACK)
        }
    };

    /**
     * Undo a value. Set it to be the current element and push the current element to the redo stack
     * @return {Anything} current value after the undo operation
     */
    UndoManager.prototype.undo = function() {
        if (!this.canUndo()) { return; }
        var val;
        do {
            val = this._undoStack.pop();
        } while (_.isEqual(val, this._current) && this.canUndo());
        this._redoStack.push(this._current);
        this._current = val;
        return val;
    };

    /**
     * Redo a value. Set it to be the current element and push the current element to the undo stack
     * @return {Anything} current value after the redo operation
     */
    UndoManager.prototype.redo = function() {
        if (!this.canRedo()) { return; }
    
        var val = this._redoStack.pop();
        this._undoStack.push(this._current);
        this._current = val;
        return val;
    };

    /**
     * Check if it is possible to undo
     * @return {Boolean}
     */
    UndoManager.prototype.canUndo = function() {
        return !!this._undoStack.length;
    };

    /**
     * Check if it is possible to redo
     * @return {Boolean}
     */
    UndoManager.prototype.canRedo = function() {
        return !!this._redoStack.length;
    };

    return UndoManager;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/UndoableTextarea.js' */
define('wiki-edit/UndoableTextarea', [
        'wiki-edit/UndoManager',
        'wiki-edit/KeyTester',
        'jquery'
], function(
    UndoManager,
    KeyTester,
    $
) {

    var CUT_PASTE_MODE = "cut-paste";
    var _lastEditMode = "";

    function _setEditMode(context, newMode) {
        if (newMode === CUT_PASTE_MODE || _lastEditMode != newMode) {
            if (_lastEditMode != "newline") {
                context.recordHistoryItem();
            }
            _lastEditMode = newMode;
        }
    }

    function _manipulateHistory(context, stateName) {
        if (context.undoManager["can" + stateName[0].toUpperCase() + stateName.substring(1)]()) {
            var state = context.undoManager[stateName]();
            context.element.value = state.value;
            context.element.selectionStart = state.selectionStart;
            context.element.selectionEnd = state.selectionEnd;
        }
    }

    var UndoableTextarea = function UndoableTextarea(element) {
        this.element = element;
        this.$el = $(element);
        this.undoManager = new UndoManager();
        this.undoManager.updateCurrent(this.getValue());
        this.undoManager.push(this.getValue());

        var handleKeyboardInput = (function handleChange(e) {
            var keyCode = e.keyCode;
            var keyCodeChar = String.fromCharCode(keyCode);

            if (keyCode) {
                if (!e.ctrlKey && !e.metaKey) {
                    this.undoManager.updateCurrent(this.getValue());
                    _setEditMode(this, KeyTester.getActionType(keyCode));
                } else if ((e.ctrlKey || e.metaKey) && !e.altKey) {
                    switch (keyCodeChar.toLowerCase()) {
                        case "y":
                            this.undoManager.updateCurrent(this.getValue(), true);
                            this.redo();
                            e.preventDefault();
                            break;

                        case "z":
                            this.undoManager.updateCurrent(this.getValue(), true);
                            if (!e.shiftKey) {
                                this.undo();
                            } else {
                                this.redo();
                            }
                            e.preventDefault();
                            break;
                    }
                }
            } else {
                this.undoManager.updateCurrent(this.getValue());
                _setEditMode(this, "other");
            }
        }).bind(this);

        this.$el.on("keydown", handleKeyboardInput);

        this.$el.on("paste cut", function handleCutAndPaste() {
            this.undoManager.updateCurrent(this.getValue());
            _setEditMode(this, CUT_PASTE_MODE);
        }.bind(this));
    };

    UndoableTextarea.prototype.getValue = function() {
        return {
            value: this.element.value,
            selectionStart: this.element.selectionStart,
            selectionEnd: this.element.selectionEnd
        };
    };

    UndoableTextarea.prototype.updateCurrent = function() {
        this.undoManager.updateCurrent(this.getValue());
    };

    UndoableTextarea.prototype.recordHistoryItem = function() {
        this.undoManager.push(this.getValue());
    };

    UndoableTextarea.prototype.undo = function() {
        _setEditMode(this, "undo");
        _manipulateHistory(this, "undo");
        this.element.scrollTop = this.element.scrollHeight;
    };

    UndoableTextarea.prototype.redo = function() {
        _manipulateHistory(this, "redo");
        this.element.scrollTop = this.element.scrollHeight;
    };

    return UndoableTextarea;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/TextareaManipulator.js' */
define('wiki-edit/TextareaManipulator', function() {

    var TextareaManipulator = function(element) {
        this.el = element;
    };
    
    TextareaManipulator.prototype.NEW_LINE_TOKEN = "\n";
    
    /**
     * Gets object containing selection info
     * @returns {{position: number, start: number, end: number, length: number, text: string}}
     */
    TextareaManipulator.prototype.getSelection = function() {
        return {
            start: this.el.selectionStart,
            end: this.el.selectionEnd,
            length: this.el.selectionEnd - this.el.selectionStart,
            text: this.el.value.substring(this.el.selectionStart, this.el.selectionEnd)
        };
    };
    
    /**
     * Sets selection
     * @param start {number} index in the string, start of the selection
     * @param end {number} index in the string, end of the selection
     */
    TextareaManipulator.prototype.setSelection = function(start, end) {
        if (arguments.length === 1) {
            end = start;
        }
        this.el.selectionStart = start;
        this.el.selectionEnd = end;
    };
    
    /**
     * Replaces selected text with a parameter, if no text is selected
     * it's inserted where the cursor is
     * @param text {string} text to replace selection with
     * @param selectReplaced {Boolean} indicates if inserted text should be selected
     */
    TextareaManipulator.prototype.replaceSelectionWith = function(text, selectReplaced) {
        var start = this.el.selectionStart;
        var val = this.el.value;
        this.el.value = val.substring(0, this.el.selectionStart) + text + val.substring(this.el.selectionEnd, val.length);
    
        this.el.selectionEnd = start + text.length;
        this.el.selectionStart = (selectReplaced) ? start : this.el.selectionEnd;
    };
    
    /**
     * Wraps selection with a prefix and a suffix but only if it isn't already wrapped
     * @param prefix {string}
     * @param suffix {string}
     * @param placeholder {string} text to put between prefix and suffix if no selection was made
     */
    TextareaManipulator.prototype.wrapSelectionWith = function(prefix, suffix, placeholder) {
        if (arguments.length < 3) {
            placeholder = "";
        }
        if (arguments.length === 1) {
            suffix = prefix;
        }
        var selection = this.getSelection();
        var val = this.el.value;
    
        if (val.substring(selection.start - prefix.length, selection.start) === prefix &&
            val.substring(selection.end, selection.end + suffix.length) === suffix) {
            return;
        }
    
        var middle = val.substring(selection.start, selection.end);
        if (middle.length == 0) {
            middle = placeholder;
        }
        this.el.value = val.substring(0, selection.start) + prefix + middle + suffix + val.substring(selection.end, val.length);
        var newSelectionStart = selection.start + prefix.length;
        this.setSelection(newSelectionStart, newSelectionStart + middle.length);
    };
    
    /**
     * Finds selected lines within the textarea and returns an object containing full contents of the object
     * as an array of lines and start and end indexes of the selected lines
     * @returns {{lines: Array, start: number, end: number}}
     * @private
     */
    TextareaManipulator.prototype._getSelectedLines = function() {
        var val = this.el.value;
        var selection = this.getSelection();
        var startLine = val.substring(0, selection.start).split(this.NEW_LINE_TOKEN).length - 1; // 0-based index
        var endLine = startLine + val.substring(selection.start, selection.end).split(this.NEW_LINE_TOKEN).length - 1; // 0-based index
        var lines = val.split(this.NEW_LINE_TOKEN);
        return {
            lines: lines,
            start: startLine,
            end: endLine
        }
    };
    
    /**
     * Returns line at which cursor is (or end of the selection)
     * @returns {string}
     */
    TextareaManipulator.prototype.getLineAtCursor = function() {
        var linesSelection = this._getSelectedLines();
        return linesSelection.lines[linesSelection.end];
    };

    /**
     * Return regexp match of the fist line in the selection
     * @param pattern {regexp} prefix to check against
     * @returns {string} matched string or {undefined}
     */
    TextareaManipulator.prototype.getFirstLineMatch = function(pattern) {
        var linesSelection = this._getSelectedLines();
        var match = linesSelection.lines[linesSelection.start].match(pattern);
        if (match) {
            return match[0];
        }
    };
    
    /**
     * Checks if any of the selected lines is prefixed with a given string
     * @param prefix {string} prefix to check against
     * @returns {boolean}
     */
    TextareaManipulator.prototype.areSelectedLinesPrefixed = function(prefix) {
        var linesSelection = this._getSelectedLines();
        var currentLine;
    
        for (currentLine = linesSelection.start; currentLine <= linesSelection.end; currentLine++) {
            if (linesSelection.lines[currentLine].indexOf(prefix) == 0) {
                return true;
            }
        }
        return false;
    };
    
    /**
     * Prefixes selected lines with a given parameter. Lines already containing the prefix remain unchanged
     * @param prefix {string}
     */
    TextareaManipulator.prototype.prefixSelectedLines = function(prefix) {
        var selection = this.getSelection();
        var linesSelection = this._getSelectedLines();
        var currentLine;
        var prefixedLines = 0;
        var firstLinePrefixed = true;
        for (currentLine = linesSelection.start; currentLine <= linesSelection.end; currentLine++) {
            if (linesSelection.lines[currentLine].indexOf(prefix) == 0) {
                if (currentLine == linesSelection.start) {
                    firstLinePrefixed = false;
                }
                continue; //don't prefix lines which already have ie
            }
            prefixedLines += 1;
            linesSelection.lines[currentLine] = prefix + linesSelection.lines[currentLine];
        }
        this.el.value = linesSelection.lines.join(this.NEW_LINE_TOKEN);
    
        var prefixesLength = prefix.length * prefixedLines;
        this.setSelection(selection.start + ((firstLinePrefixed) ? prefix.length : 0), selection.end + prefixesLength);
    };
    
    /**
     * Removes prefix from selected lines
     * @param prefix {string}
     */
    TextareaManipulator.prototype.unprefixSelectedLines = function(prefix) {
        var selection = this.getSelection();
        var linesSelection = this._getSelectedLines();
        var currentLine;
        var firstLinePrefix = false;
        var prefixedLines = 0;
    
        for (currentLine = linesSelection.start; currentLine <= linesSelection.end; currentLine++) {
            if (linesSelection.lines[currentLine].indexOf(prefix) == 0) {
                prefixedLines += 1;
                linesSelection.lines[currentLine] = linesSelection.lines[currentLine].substring(prefix.length);
                if (currentLine == linesSelection.start) {
                    firstLinePrefix = true;
                }
            }
        }
        this.el.value = linesSelection.lines.join(this.NEW_LINE_TOKEN);

        var prefixesLength = prefix.length * prefixedLines;
        this.setSelection(selection.start - ((firstLinePrefix) ? prefix.length : 0), selection.end - prefixesLength);
    };

    return TextareaManipulator;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/keymaster-setup.js' */
define('wiki-edit/keymaster-setup', [
    'jquery',
    'wiki-edit/keymaster'
], function($, key) {
    return {
        init: function () {
            // Set-up library handling key bindings to correctly set scopes for wiki editor
            key.filter = function(event) {
                var element = event.target || event.srcElement || false;
                var editor;
                if (element && (' ' + element.className + ' ').indexOf(' wiki-textfield ') > -1) {
                    editor = $(element).data("wikiEditor");
                    if (editor) {
                        key.setScope(editor.id);
                        return true;
                    }
                }
                return false;
            };
        }
    }
});


;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/WikiEnabledTextarea.js' */
define('wiki-edit/WikiEnabledTextarea', [
        'wiki-edit/TextareaManipulator',
        'wiki-edit/UndoableTextarea',
        'wiki-edit/keymaster',
        'wiki-edit/keymaster-setup',
        'featureflags/feature-manager',
        'wiki-edit/SpeechRecognition',
        'jquery'
], function(TextareaManipulator, UndoableTextarea, onKey, keymasterSetup, FeatureManager, speechRecognition, $) {
    keymasterSetup.init();

    var editorCount = 0;
    // matches any combination of "*" and "#" followed by space which is any list, no matter how deeply nested
    var autocontinuingPrefixMarkupRegexp = /^[#\*]+ /;

    var WikiEnabledTextarea = function(element) {
        this.el = element;
        this.$el = $(element);
        if (this.$el.data("wikiEditor")) {
            // this will be very rare so defensive caching of this value doesn't seem to make much sense
            return this.$el.data("wikiEditor");
        }

        this.id = "wikiEdit" + editorCount;
        editorCount += 1;
        this.manipulationEngine = new TextareaManipulator(this.el);
        this.undoRedoEl = new UndoableTextarea(element);

        var wikiEditor = this;
        // on enter, continue list if possible or discontinue it if current list item is empty
        onKey("enter", wikiEditor.id, function onEnterKey(e) {
            var selection = wikiEditor.manipulationEngine.getSelection();
            var prefix = wikiEditor.manipulationEngine.getFirstLineMatch(autocontinuingPrefixMarkupRegexp);
            if (prefix) {
                if (selection.length == 0 && wikiEditor.manipulationEngine.getLineAtCursor() === prefix) {
                    wikiEditor.manipulationEngine.unprefixSelectedLines(prefix);
                } else {
                    wikiEditor.manipulationEngine.replaceSelectionWith("\n" + prefix);
                }
                e.preventDefault();
            }
        });

        this.$el.data("wikiEditor", this);
    };

    /**
     * Standard wiki markup in the form of <prefix>text<suffix> like *bold*, _italic_ or [mailto:someone@example.com].
     * Every time such markup is inserted:
     *     - if user didn't select any text, the placeholder text will be inserted and selected,
     *     - if user selected some text, this text will be wrapped with prefix and suffix.
     *
     * Each of this properties gets a function on the prototype with the same name
     * that changes value of textarea to apply the markup.
     */
    var wrapperMarkup = {
        'bold': ["*", "*", "strong text"],
        'italic': ["_", "_", "emphasized text"],
        'underline': ["+", "+", "underlined text"],
        'delete': ["-", "-", "deleted text"],
        'superscript': ["^", "^", "superscript text"],
        'subscript': ["~", "~", "subscript text"],
        'monospace': ["{{", "}}", "monospaced text"],
        'cite': ["??", "??", "citation"],
        'block-quote': ["{quote}", "{quote}", "quoted text"],
        'color': ["{color:$1}", "{color}", "colored text", "red"], // 4th parameter is a default value to replace $
        'link': ["[", "]", "link title"+"|http://example.com"],
        'link-anchor': ["[#", "]", "anchor"],
        'link-mail': ["[mailto:", "]", "mail@example.com"],
        'image': ["!", "!", "http://example.com/image.png"],
        'mention': ["@", "", "Mention someone by typing their name..."],
        'code': ["\n{code:java}\n","\n{code}\n", "// Some comments here\npublic String getFoo()\n{\n    return foo;\n}"],
        'noformat': ["\n{noformat}\n", "\n{noformat}\n", "*no* further _formatting_ is done here"],
        'panel': ["\n{panel:title="+"My title"+"}\n", "\n{panel}\n", "Some text with a title"],
        'table': ["\n||"+"Heading"+" 1||"+"Heading"+" 2||\n|", "|"+"Col"+" A2|\n", "Col"+" A1"]
    };

    for(var key in wrapperMarkup) {
        WikiEnabledTextarea.prototype[key] = (function(args, operationKey) {
            var paramsNumber = 0;
            if (args.length > 3) {
                paramsNumber = args.length - 3;
            }
            return function() {

                var prefix = args[0];
                var suffix = args[1];
                var placeholder = args[2];

                var i;
                for (i = 1; i <= paramsNumber; i++) {
                    prefix = prefix.replace("$"+i, arguments[i-1] || args[2 + i]);
                    suffix = suffix.replace("$"+i, arguments[i-1] || args[2 + i]);
                }

                var value = this.el.value;
                var selection = this.manipulationEngine.getSelection();

                this.undoRedoEl.recordHistoryItem();

                // unwrap selection if needed
                if (value.substring(selection.start - prefix.length, selection.start) === prefix &&
                    value.substring(selection.end, selection.end + suffix.length) === suffix) {

                    this.el.value = value.substring(0,selection.start - prefix.length) +
                    value.substring(selection.start, selection.end) +
                    value.substring(selection.end + suffix.length, value.length);

                    this.manipulationEngine.setSelection(selection.start - prefix.length, selection.end - prefix.length);

                    // wrap selection with markup
                } else {
                    this.manipulationEngine.wrapSelectionWith.call(this.manipulationEngine, prefix, suffix, placeholder);
                }
                this.undoRedoEl.recordHistoryItem();
                this.$el.trigger("input");
            };
        })(wrapperMarkup[key], key);
    }

    /**
     * Markup that is always a prefix for entire line, like h1. or bullet lists "* ".
     * Those prefixes are mutually exclusive, which means each line can be only prefixed with one of them
     * and applying one of them will remove any other.
     *
     * Each of this properties gets a function on the prototype with the same name
     * that changes value of textarea to apply the markup.
     */
    var excludingLinePrefixMarkup = {
        'paragraph': "",
        'bullet-list': "* ",
        'numbered-list': "# ",
        'h1': 'h1. ',
        'h2': 'h2. ',
        'h3': 'h3. ',
        'h4': 'h4. ',
        'h5': 'h5. ',
        'h6': 'h6. ',
        'paragraph-quote': 'bq. '
    };

    for(var key in excludingLinePrefixMarkup) {
        WikiEnabledTextarea.prototype[key] = (function(prefix) {
            return function() {
                this.undoRedoEl.recordHistoryItem();
                // check if line is already prefixed with one of the prefixes there
                for(var prefixToRemove in excludingLinePrefixMarkup) {
                    if (this.manipulationEngine.areSelectedLinesPrefixed(excludingLinePrefixMarkup[prefixToRemove])) {
                        this.manipulationEngine.unprefixSelectedLines(excludingLinePrefixMarkup[prefixToRemove]);
                    }
                }

                this.manipulationEngine.prefixSelectedLines.call(this.manipulationEngine, prefix);
                this.undoRedoEl.recordHistoryItem();
                this.$el.trigger("input");
            };
        })(excludingLinePrefixMarkup[key]);
    }

    /**
     * Markup that is just inserted in place of cursor or selection. The cursor is then placed at the end of inserted text.
     *
     * Each of this properties gets a function on the prototype with the same name
     * that changes value of textarea to apply the markup.
     */
    var insertMarkupWithoutSelecting = {
        'hr': "\n----\n",
        ':)': ':)',
        ':(': ':(',
        ':P': ':P',
        ':D': ':D',
        ';)': ';)',
        '(y)': '(y)',
        '(n)': '(n)',
        '(i)': '(i)',
        '(/)': '(/)',
        '(x)': '(x)',
        '(!)': '(!)',
        '(+)': '(+)',
        '(-)': '(-)',
        '(?)': '(?)',
        '(on)': '(on)',
        '(off)': '(off)',
        '(*)': '(*)',
        '(*r)': '(*r)',
        '(*g)': '(*g)',
        '(*b)': '(*b)',
        '(*y)': '(*y)',
        '(flag)': '(flag)',
        '(flagoff)': '(flagoff)',
        'image-attachment': [" !$1|thumbnail! ", "attachment-name.jpg"],
        'image-attachment-full': [" !$1! ", "attachment-name.gif"],
        'link-attachment': [" [^$1] ", "attachment-name.zip"]
    };

    for(var key in insertMarkupWithoutSelecting) {
        WikiEnabledTextarea.prototype[key] = (function(toInsert) {
            var paramsNumber = 0;
            var defaultValues;
            if (_.isArray(toInsert)) {
                paramsNumber = toInsert.length - 1;
                defaultValues = toInsert.slice(1);
                toInsert = toInsert[0];
            }
            return function() {
                var i;
                var result = toInsert;
                for (i = 1; i <= paramsNumber; i++) {
                    result = toInsert.replace("$"+i, arguments[i-1] || defaultValues[i-1]);
                }
                this.undoRedoEl.recordHistoryItem();
                this.manipulationEngine.replaceSelectionWith.call(this.manipulationEngine, result, false);
                this.undoRedoEl.recordHistoryItem();
                this.$el.trigger("input");
            };
        })(insertMarkupWithoutSelecting[key]);
    }

    WikiEnabledTextarea.prototype.speech = function()
    {
        speechRecognition.start(this);
    };

    return WikiEnabledTextarea;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/WikiEditor.js' */
define('wiki-edit/WikiEditor', [
    'wiki-edit/WikiEnabledTextarea',
    'jquery',
    'underscore',
    'wiki-edit/JIRA',
    'wiki-edit/keymaster',
    'wiki-edit/analytics',
    'wiki-edit/WikiEditorUtil',
    'jira/util/events',
    'featureflags/feature-manager'
], function (
    WikiEnabledTextarea,
    $,
    _,
    JIRA,
    key,
    analytics,
    WikiEditorUtil,
    JIRAEvents,
    FeatureManager
) {

    var controlKey = 'Ctrl';
    if (navigator.platform.indexOf('Mac') != -1) {
        controlKey = 'â';
    }

    // Check jira.unified.attachments.m2 dark feature toggle
    var unifiedAttachmentsM2IsEnabled = function() {
        return FeatureManager.isFeatureEnabled("jira.unified.attachments.m2");
    };

    var determineFileType = function (fileName) {
        return fileName.match(/\.(bmp|gif|jpg|jpeg|png|tiff|webp)$/i) ? 'image' : 'file';
    };

    var insertMarkup = function (wikiEditor, fileName, fileType) {
        // Gif attachments are rendered without thumbnail (eg: !lolcat.gif!) so they can animate properly
        if (unifiedAttachmentsM2IsEnabled()) {
            if (fileType == "image") {
                if (fileName.match(/\.gif$/i)) {
                    wikiEditor["image-attachment-full"](fileName);
                } else {
                    wikiEditor["image-attachment"](fileName);
                }

                analytics.trigger("operation.attachment.image");
            } else {
                wikiEditor["link-attachment"](fileName);
                analytics.trigger("operation.attachment.link");
            }
        } else {
            wikiEditor["image-attachment"](fileName);
            analytics.trigger("operation.attachment.image");
        }
    };

    return {
        create: function (element) {
            // disable plugin in IE <=8
            if (typeof element.selectionStart == "undefined") {
                return;
            }

            var $editorElement = $(element);

            if ($editorElement.data("wikiEditor")) {
                return;
            }

            // todo editor should initialize all html and events by itself
            var wikiEditor = new WikiEnabledTextarea(element);
            this.wikiEditor = wikiEditor;

            var $editorHtml = $(JIRA.Templates.Plugins.WikiEditor.renderEditor({
                editorId: wikiEditor.id,
                controlKey: controlKey,
                attachmentM2FeatureFlag: unifiedAttachmentsM2IsEnabled()
            }));
            var $editorToolbar = $editorHtml.filter(".wiki-edit-toolbar");

            // speech-capable browser?
            if ("webkitSpeechRecognition" in window) {
                $editorHtml.find(".wiki-edit-speech-item").removeClass("hidden");
            }

            $editorElement.parent().before($editorHtml);

            // detect if we are dealing with dialog
            var isDialog = $editorElement.closest(".jira-dialog").length > 0 || $editorElement.closest("form#issue-create").length > 0;
            var isCreateDialog = $editorElement.closest("#create-issue-dialog").length > 0;
            // detect if we are on view issue page
            var isViewIssue = $("#issue-content").length > 0;
            var isComment = $editorElement.closest("#addcomment").length > 0;

            var elementsWithTooltips = $editorHtml.find(".wiki-edit-operation[title], .aui-dropdown2-trigger, .wiki-edit-tooltip");
            var onWikiEditorHideEventName;
            if (isDialog) {
                onWikiEditorHideEventName = 'Dialog.beforeHide';
            } else {
                onWikiEditorHideEventName = JIRA.Events.BEFORE_INLINE_EDIT_CANCEL;
            }
            elementsWithTooltips.each(function () {
                var $this = $(this);
                var config = {
                    aria: true,
                    hideOnClick: true,
                    hoverable: false
                };
                if ($this.parent().is('li')) {
                    config.gravity = 'w';
                }
                $this.tooltip(config);
            });
            var hideAllTooltips = function (){
                elementsWithTooltips.each(function(){
                    $(this).tooltip('hide');
                });
            };
            JIRA.bind(onWikiEditorHideEventName, hideAllTooltips);

            var isDropdownEnabled = false;
            var $wikiDropdown = $editorHtml.filter(".aui-dropdown2");
            $wikiDropdown.on({
                'aui-dropdown2-show': function () {
                    isDropdownEnabled = true;

                    // focus on editorElement when dropdown opens so
                    // it can handle keyboard event (especially in dialogs)
                    $editorElement.focus();
                },
                'aui-dropdown2-hide': function () {
                    isDropdownEnabled = false;

                    hideAllTooltips();
                }
            });
            $editorElement.on('keydown', function checkEscapePressWhenDropdownIsEnabled(e) {
                if (isDropdownEnabled && e.keyCode === AJS.keyCode.ESCAPE) {
                    if (isDialog) {
                        JIRA.one("Dialog.beforeHide", function (e) {
                            e.preventDefault();
                        });
                    } else if (isViewIssue && !isComment) {
                        JIRA.one(JIRA.Events.BEFORE_INLINE_EDIT_CANCEL, function preventInlineEditCloseIfAnyDropdownIsEnabled(e) {
                            e.preventDefault();
                        });
                    }
                }
            });


            var $attachmentDropdown = $editorHtml.filter(
                ".wiki-edit-dropdown-image, " +
                ".wiki-edit-dropdown-attachment"
            );

            var $attachmentListContainer = $attachmentDropdown.find(
                ".wiki-edit-insert-image, " +
                ".wiki-edit-insert-attachment"
            );

            var $attachmentList = $attachmentDropdown.find(
                ".wiki-edit-insert-image ul, " +
                ".wiki-edit-insert-attachment ul"
            );

            // Attachment dropdown link click handler
            $attachmentList.on("click", "a", function (e) {
                e.preventDefault();

                var fileType = $(this).attr("data-attachment-type");
                if (typeof fileType === "undefined") {
                    fileType = "file";
                }

                var fileName = $(this).find('.wiki-edit-attachment-name').text();

                insertMarkup(wikiEditor, fileName, fileType);
            });

            // Build attachment links when attachment button is pressed
            $attachmentDropdown.on("aui-dropdown2-show", function () {
                var genericAttachments = [];

                // Add temporary attachments (those added before dialog is saved such as in create/edit dialog)
                if (isDialog) {
                    $(".upload-progress-bar:not(.upload-progress-bar__upload-error) span.upload-progress-bar__file-name").each(function(i,v){
                        genericAttachments.push(v);
                    });
                }

                // Add permanent attachments
                if (!isCreateDialog && isViewIssue) {
                    $("#attachment_thumbnails li.attachment-content, " +
                      "#file_attachments li.attachment-content").each(function(i,v){
                        genericAttachments.push(v);
                    });
                }

                $attachmentList.empty();
                $attachmentListContainer.addClass("hidden");

                if ((isDialog || isViewIssue) && genericAttachments.length) {
                    $attachmentListContainer.removeClass("hidden");

                    /**
                     * Contents of $genericAttachments (ie: "this") could be:
                     * - A thumbnails (gallery) view item
                     * - A list view item
                     * - Create / edit dialog entry
                     */
                    $(genericAttachments).each(function () {
                        // Handle various form of DOM structure a file name can appear in (create issue dialog,
                        // edit issue - list view, edit issue - thumbnail view
                        var fileName = $(this).is('span.upload-progress-bar__file-name') ?
                            $(this).text() :
                            $(this).find('a.attachment-title, .attachment-title a').first().text();

                        // Determine file type by 'data-attachment-type' attribute, or fall back by checking
                        // popular image file extension
                        var fileType = $(this).attr('data-attachment-type');
                        if (fileType === undefined) {
                            fileType = determineFileType(fileName);
                        }

                        // Try to figure out the attachment type icon using mime type. On thumbnail / list view mime-type
                        // can be looked up using data-downloadurl attribute. If mime-type not available let's fall back
                        // using file extension. And if that still doesn't work use aui-iconfont-file-txt.
                        var typeIcon = WikiEditorUtil.defaultAttachmentTypeIcon;
                        var dataDownloadUrl = $(this).attr('data-downloadurl');
                        if (dataDownloadUrl === undefined) {
                            dataDownloadUrl = $(this).find('[data-downloadurl]').attr('data-downloadurl');
                        }
                        if (dataDownloadUrl !== undefined && typeof dataDownloadUrl === 'string') {
                            var attrs = dataDownloadUrl.split(':');
                            if (attrs.length > 0) {
                                var mimeType = attrs[0];
                                typeIcon = WikiEditorUtil.translateMimeTypeToAttachmentTypeIcon(mimeType);
                            }
                        } else if (fileName !== undefined && typeof fileName === 'string') {
                            var matches = fileName.match(/\.(\w{1,5})$/i); // regex match exts such as .gz,.jpg,.docx,.3gp and discard the dot prefix
                            if (matches && matches.length > 1) {
                                var fileExtension = matches[1];
                                typeIcon = WikiEditorUtil.translateFileExtensionToAttachmentTypeIcon(fileExtension);
                            }
                        }

                        // If feature is disabled do not list non-image attachments
                        if (!unifiedAttachmentsM2IsEnabled() && fileType !== "image") {
                            return;
                        }

                        $attachmentList.append(
                            $(JIRA.Templates.Plugins.WikiEditor.renderListItem({
                                text: fileName,
                                attachmentType: fileType,
                                attachmentTypeIcon: typeIcon,
                                attachmentM2FeatureFlagEnabled: unifiedAttachmentsM2IsEnabled()
                            }))
                        );
                    });
                }
            });

            // dropdown2 fix so when item is selected using keyboard the container div scrolls
            // properly. This bug was fixed on AUI 5.8+ so only do this for older AUI versions
            if (WikiEditorUtil.compareVersion(AJS.version, '5.8.0') < 0) {
                $attachmentDropdown.on('aui-dropdown2-item-selected', function scrollContainerDivIfActiveItemIsOutOfView() {
                    var $active = $(this).find('.aui-dropdown2-active');
                    if (typeof $active !== 'object') {
                        return;
                    }
                    var $container = $active.closest('div');
                    if (typeof $container !== 'object') {
                        return;
                    }

                    // top/bottom limits are extreme points above/below which element will not / only be partially visible
                    var containerTopLimit = $container.offset().top;
                    var containerBottomLimit = containerTopLimit + $container.height();

                    var elementTop = $active.offset().top;
                    var elementBottom = elementTop + $active.height();

                    // Active element is (partially) above the container viewport, scroll up
                    if (elementTop < containerTopLimit) {
                        $container.scrollTop($container.scrollTop() - (containerTopLimit - elementTop));
                    }

                    // Active element is (partially) below the container viewport, scroll down
                    if (elementBottom > containerBottomLimit) {
                        $container.scrollTop($container.scrollTop() + (elementBottom - containerBottomLimit));
                    }
                });
            }

            // SUCCESS-198: Prevent attachments from being listed on links drop down
            if (!unifiedAttachmentsM2IsEnabled()) {
                var $linkDropdown = $editorHtml.filter(".wiki-edit-dropdown-link");
                var $linksList = $linkDropdown.find(".wiki-edit-insert-link");
                var $linkLinkDefault = $linkDropdown.find(".wiki-edit-operation[data-operation=link-attachment]");
                var $linkLinks = $linkDropdown.find(".wiki-edit-insert-link ul");
                $linkLinks.on("click", "a", function (e) {
                    e.preventDefault();
                    wikiEditor["link-attachment"]($(this).text());
                    analytics.trigger("operation.attachment.link");
                });

                $linkDropdown.on("aui-dropdown2-show", function () {
                    var $linkAttachments = $();
                    if (!isCreateDialog && isViewIssue) {
                        $linkAttachments = $linkAttachments.add("#attachment_thumbnails .attachment-title, #file_attachments .attachment-title a");
                    }
                    if (isDialog) {
                        $linkAttachments = $linkAttachments.add(".upload-progress-bar:not(.upload-progress-bar__upload-error) .upload-progress-bar__thumbnail + .upload-progress-bar__file-name");
                    }

                    var attachments = _.uniq($linkAttachments, false, function getValue(item) {
                        return $(item).text().trim();
                    });

                    $linkLinks.empty();
                    $linksList.addClass("hidden");
                    $linkLinkDefault.removeClass("hidden");

                    if ((isDialog || isViewIssue) && attachments.length) {
                        $linksList.removeClass("hidden");
                        $linkLinkDefault.addClass("hidden");
                        attachments.forEach(function (element) {
                            $linkLinks.append(
                                $(JIRA.Templates.Plugins.WikiEditor.renderListItem({
                                    text: $(element).text().trim(),
                                    attachmentM2FeatureFlagEnabled: unifiedAttachmentsM2IsEnabled()
                                }))
                            );
                        });
                    }
                });
            }

            $editorHtml.filter(".wiki-edit-dropdown, .wiki-edit-picker").on("mousedown", function (e) {
                e.preventDefault(); // prevent blurring textarea, needed for inline mode
            });

            // attach keyboard shortcuts
            $editorHtml.find(".wiki-edit-operation:not(.wiki-edit-operation-color)").each(function () {
                var $this = $(this);
                var handler = function (e) {
                    if (!e) {
                        return;
                    }
                    e.preventDefault && e.preventDefault();
                    $editorElement.focus();
                    wikiEditor[$this.data("operation")]();
                    analytics.trigger("operation", {
                        name: $this.data("operation"),
                        nameHash: analytics.hashCode($this.data("operation")),
                        trigger: e.type
                    });
                    analytics.trigger("operation." + $this.data("operation"), {trigger: e.type});
                };

                // todo event delegation, fool!
                $this.click(handler);
                if ($this.data("shortcut")) {
                    // todo shortcuts should be binded once, globally
                    key($this.data("shortcut"), wikiEditor.id, handler);
                }
            });

            // text color
            $editorHtml.find(".wiki-edit-operation-color").each(function () {
                var $this = $(this);
                var handler = function (e) {
                    if (!e) {
                        return;
                    }
                    e.preventDefault && e.preventDefault();
                    $editorElement.focus();
                    wikiEditor[$this.data("operation")]($this.data("color"));
                    analytics.trigger("operation", {
                        name: $this.data("operation"),
                        nameHash: analytics.hashCode($this.data("operation")),
                        trigger: e.type
                    });
                    analytics.trigger("operation." + $this.data("operation"), {trigger: e.type});
                };

                // todo event delegation, fool!
                $this.click(handler);
                if ($this.data("shortcut")) {
                    // todo shortcuts should be binded once, globally
                    key($this.data("shortcut"), wikiEditor.id, handler);
                }

            });

            var defaultColor = (window.localStorage.getItem("jira.wikieditor.last.color")) ? window.localStorage.getItem("jira.wikieditor.last.color") : "red";
            var $colorOperation = $editorHtml.find(".wiki-edit-operation-color");
            $colorOperation.data("color", defaultColor);
            var $colorIndicator = $editorToolbar.find(".wiki-edit-color-indicator");
            $colorIndicator.css("background-color", defaultColor);

            $editorHtml.filter(".wiki-edit-color-picker").on("click", "a", function (e) {
                e.preventDefault();
                $editorElement.focus();
                var color = $(this).data("color");
                wikiEditor.color(color);
                analytics.trigger("operation", {name: "color"});
                analytics.trigger("operation.color.picked", {color: color});
                $colorOperation.data("color", color);
                $colorIndicator.css("background-color", color);
                window.localStorage.setItem("jira.wikieditor.last.color", color);
            });

            var $visibilityToggle = $editorHtml.find('.wiki-edit-visible-toggle');
            var hideToolbar = (localStorage.getItem("jira.wikieditor.visibility" + element.name + '.' + element.id) === "true") ? true : false;
            if (hideToolbar) {
                $visibilityToggle.addClass("active");
                $editorToolbar.addClass("wiki-edit-toolbar-compact");
            }

            function toggleEditor(e) {
                e.preventDefault();
                e.stopPropagation();
                hideToolbar = !hideToolbar;
                $visibilityToggle.toggleClass("active", hideToolbar);
                $editorToolbar.toggleClass("wiki-edit-toolbar-compact", hideToolbar);
                localStorage.setItem("jira.wikieditor.visibility" + element.name + '.' + element.id, (hideToolbar) ? "true" : "false");
                analytics.trigger((hideToolbar) ? "hide" : "show")
            }

            $visibilityToggle.on("click", toggleEditor);
            $editorToolbar.parent().on("click", ".wiki-edit-toolbar-compact", toggleEditor);

            $(document).on("showWikiPreview", function (e, el) {
                if ($(el).find(element).length) {
                    $editorToolbar.addClass("hidden");
                }
            });
            $(document).on("showWikiInput", function (e, el) {
                if ($(el).find(element).length) {
                    $editorToolbar.removeClass("hidden");
                }
            });
        },

        initBrowseLink: function (element) {
            var wikiEditor = this.wikiEditor;

            if (unifiedAttachmentsM2IsEnabled()) {
                var $editorElement = $(element);

                var $browseButton = $editorElement.parent().siblings().find(".wiki-attachment-browse");
                var canAttach = $("#dnd-metadata-webpanel").data("can-attach");

                var isDialog = $editorElement.closest(".jira-dialog").length > 0 || $editorElement.closest("form#issue-create").length > 0;

                if (isDialog) {
                    // These are the dialogs we want to show the browse link in.
                    // The dialogs have an attachment dropzone that we can use to simulate a drop.
                    var supportedDialogSelectors = ['#create-issue-dialog:visible', '#create-subtask-dialog:visible', '#edit-issue-dialog:visible', '#create-linked-issue-dialog:visible'];
                    var supportedDialog = $(supportedDialogSelectors.join(","));
                    var isSupportedDialog = supportedDialog.length > 0;
                    canAttach = $(".jira-dialog fieldset span:contains('Attachment')").length > 0;

                    // If we did not find a dialog that we know can receive files, we search
                    // for other dialogs that explicitly state that they can receive files.
                    if (!isSupportedDialog) {
                        supportedDialog = $editorElement.closest(".dialog-can-receive-files:visible");
                        isSupportedDialog = supportedDialog.length > 0;
                        // If we do find such a dialog, we consume its can-attach (boolean) data attribute.
                        // If the dialog does not have that attribute, canAttach will be undefined and the
                        // browse link will not be shown.
                        canAttach = supportedDialog.data("can-attach");
                    }
                    var insertMarkupInDialog = supportedDialog.data("insert-markup-on-browse");
                }

                var $attachmentsDropdown = $editorElement.parent().siblings().find(".wiki-edit-attachment-picker-trigger");

                if (canAttach && (isDialog ? isSupportedDialog : true)) {
                    $browseButton.closest("div").removeClass("hidden");
                    $attachmentsDropdown.removeClass("hidden");
                    if (!$browseButton.data("initialised")) {
                        $browseButton.on('click', function (e) {
                            e.preventDefault();

                            var $tempFileInput = $("<input type=\"file\" multiple />");
                            $tempFileInput.change(function (event) {
                                var files = $tempFileInput[0].files;
                                if (isDialog) {
                                    var dropEvent = $.Event("drop");
                                    dropEvent.dataTransfer = {files: files};
                                    supportedDialog.find('.issue-drop-zone__target').trigger(dropEvent);
                                }
                                else {
                                    // This event comes from the JIRA Drag and Drop Plugin.
                                    JIRAEvents.trigger("attachmentForPageReceived", {
                                        files: files,
                                        isWikiTextfieldFocused: true
                                    });
                                }
                                if (isDialog ? insertMarkupInDialog : true) {
                                    for (var i = 0; i < files.length; i++) {
                                        var fileName = files[i].name;
                                        insertMarkup(wikiEditor, fileName, determineFileType(fileName));
                                    }
                                }
                            });
                            $tempFileInput.click();

                            analytics.trigger("attachment.dropdown.button.clicked.browse");
                        });
                        $browseButton.data("initialised", true);
                    }
                }
                else {
                    $browseButton.closest("div").addClass("hidden");

                    // Here we know the browse button will be hidden. If we will
                    // not show an attachments list, the attachment dropdown will be empty
                    // so we want to hide the attachment dropdown altogether.
                    var $genericAttachments = $("#attachment_thumbnails li.attachment-content, #file_attachments li.attachment-content");
                    var currentIssueHasAttachments = $genericAttachments.length > 0;

                    // Create issue/Create subtask dialogs are special because even if the current issue has attachments,
                    // we are not supposed to show these attachments in those two dialogs (because attachments are per issue).
                    var isCreateIssueOrSubtaskDialog = isDialog && isSupportedDialog &&
                        (supportedDialog.attr("id") === "create-issue-dialog" || supportedDialog.attr("id") === "create-subtask-dialog");

                    var willShowAttachmentsList = currentIssueHasAttachments &&  !isCreateIssueOrSubtaskDialog;

                    if (!willShowAttachmentsList) {
                        $attachmentsDropdown.addClass("hidden");
                    }
                }
            }
        }
    }
});

;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/WikiEditorUtil.js' */
define('wiki-edit/WikiEditorUtil', [
    'jquery',
    'underscore'
], function (
    $,
    _
) {

    var _defaultAttachmentTypeIcon = {
        cssClass : 'aui-iconfont-devtools-file',
        title : ''
    };

    var _fileExtToAttachmentTypeIconCssClass = {
        'pdf'   : 'aui-iconfont-file-pdf',

        'gif'   : 'aui-iconfont-image',
        'png'   : 'aui-iconfont-image',
        'jpeg'  : 'aui-iconfont-image',
        'jpg'   : 'aui-iconfont-image',

        'xml'   : 'aui-iconfont-file-code',
        'html'  : 'aui-iconfont-file-code',
        'htm'   : 'aui-iconfont-file-code',
        'txt'   : 'aui-iconfont-file-txt',

        'zip'   : 'aui-iconfont-file-zip',
        'gz'    : 'aui-iconfont-file-zip',
        'tar'   : 'aui-iconfont-file-zip',
        'rar'   : 'aui-iconfont-file-zip',
        '7z'    : 'aui-iconfont-file-zip',

        'doc'   : 'aui-iconfont-file-doc',
        'docx'  : 'aui-iconfont-file-doc',
        'xls'   : 'aui-iconfont-file-xls',
        'xlsx'  : 'aui-iconfont-file-xls',
        'xlsm'  : 'aui-iconfont-file-xls',
        'ppt'   : 'aui-iconfont-file-ppt',
        'pptx'  : 'aui-iconfont-file-ppt',

        'java'  : 'aui-iconfont-file-code',
        'c'     : 'aui-iconfont-file-code',
        'h'     : 'aui-iconfont-file-code',
        'cpp'   : 'aui-iconfont-file-code',
        'hpp'   : 'aui-iconfont-file-code',
        'scala' : 'aui-iconfont-file-code',
        'php'   : 'aui-iconfont-file-code',
        'css'   : 'aui-iconfont-file-code',
        'less'  : 'aui-iconfont-file-code',
        'soy'   : 'aui-iconfont-file-code',
        'js'    : 'aui-iconfont-file-code',
        'jar'   : 'aui-iconfont-file-zip',
        'war'   : 'aui-iconfont-file-zip',
        'obr'   : 'aui-iconfont-file-zip'
    };

    var _fileExtToAttachmentTypeIconTitle = {
        'pdf'   : "PDF File",

        'gif'   : "GIF File",
        'png'   : "PNG File",
        'jpeg'  : "JPEG File",
        'jpg'   : "JPEG File",

        'xml'   : "XML File",
        'html'  : "HTML File",
        'htm'   : "HTML File",
        'txt'   : "Text File",

        'zip'   : "Zip Archive",
        'gz'    : "GZip Archive",

        'doc'   : "Microsoft Word",
        'docx'  : "Microsoft Word",
        'xls'   : "Microsoft Excel",
        'xlsx'  : "Microsoft Excel",
        'xlsm'  : "Microsoft Excel",
        'ppt'   : "Microsoft PowerPoint",
        'pptx'  : "Microsoft PowerPoint",

        'java'  : "Java Source File",
        'jar'   : "Java Archive File",
        'war'   : "Java Archive File"
    };

    return {

        /**
         * Default attachment type icon, used as a fallback if type couldn't be determined
         */
        defaultAttachmentTypeIcon : _defaultAttachmentTypeIcon,

        /**
         * Used by attachments dropdown to determine what icon to put to the left of attachment name
         * Icon is decided by attachment mime type
         *
         * @param {string} mimeType attachment mime type (eg: image/jpg)
         *
         * @returns Object with cssClass and title attributes.
         *  If translation fails cssClass is aui-iconfont-devtools-file and title is empty string.
         */
        translateMimeTypeToAttachmentTypeIcon : function (mimeType) {
            return {
              cssClass : JIRA.Templates.ViewIssue.matchFileClass( { mimetype : mimeType } ),
              title : JIRA.Templates.ViewIssue.matchFileIconAlt( { mimetype : mimeType } )
            };
        },

        /**
         * Used by attachments dropdown to determine what icon to put to the left of attachment name
         * Icon is decided by file extension
         *
         * @param extension extension name, with or without dot prefix (eg: .pdf, doc)
         *
         * @returns Object with cssClass and title attributes.
         *  If translation fails cssClass is aui-iconfont-devtools-file and title is empty string.
         */
        translateFileExtensionToAttachmentTypeIcon : function (extension) {
            var result = _.clone(_defaultAttachmentTypeIcon);

            if (typeof extension !== 'string') {
                return result;
            }

            extension = extension.toLowerCase();
            extension = extension.replace(/^\.+/, '');

            var cssClass = _fileExtToAttachmentTypeIconCssClass[extension];
            if (typeof cssClass === 'string') {
                result.cssClass = cssClass;
            }

            var title = _fileExtToAttachmentTypeIconTitle[extension];
            if (typeof title === 'string') {
                result.title = title;
            }

            return result;
        },

        /**
         * Perform version number comparison. Returns a number less than 0 if version A is lower than B, greater than 0
         * if A is higher than B, 0 if both equals.
         *
         * Example:
         * - compareVersion('5.7.10', '5.8.0') // returns -1
         * - compareVersion('5.8.0', '5.8.0') // returns 0
         * - compareVersion('5.8.1', '5.8.0') // returns 1
         * - compareVersion('5.10.0', '5.8.0') // returns 1
         * - compareVersion('5.8', '5.8.0') // returns -1
         * - compareVersion('5.8', '5.8.0') // returns -1
         * - compareVersion('5.0a', '5.0') // returns NaN
         *
         * @param verA (string) version number (eg: 5.7.10)
         * @param verB (string) version number (eg: 5.7.10)
         *
         * @return (number) A number less than 0 if version A is lower than B, greater than 0 if A is higher than B,
         * 0 if both equals, NaN if version comparison can't be performed
         */
        compareVersion : function (verA, verB) {
            var partsA = verA.split('.');
            var partsB = verB.split('.');
            var result = NaN;

            $(partsA).each(function (i, e) {
                if (i >= partsB.length) {
                    return false;
                }
                var partA = Number(e);
                var partB = Number(partsB[i]);
                if (isNaN(partA) || isNaN(partB)) {
                    //noinspection JSUnusedAssignment
                    result = NaN;
                    return false;
                }
                if (partA < partB) {
                    //noinspection JSUnusedAssignment
                    result = -1;
                    return false;
                } else if (partA > partB) {
                    //noinspection JSUnusedAssignment
                    result = 1;
                    return false;
                }
                result = 0;
            });

            if (result == 0 && partsA.length != partsB.length) {
                return (partsA.length > partsB.length) ? 1 : -1;
            }

            return result;
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/SpeechRecognition.js' */
define('wiki-edit/SpeechRecognition', [
    'jquery',
    'aui/flag'
], function ($, auiFlag)
{
    function getIsFinal(results)
    {
        return results && results[0] && results[0].isFinal;
    }
    function getTranscript(results)
    {
        return results && results[0] && results[0][0] && results[0][0].transcript || '';
    }

    return {
        start: function (textareaInstance)
        {
            var self = this;
            var recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = true;
            // if lang is converted into something that Chrome does not understand, it defaults to the system language
            recognition.lang = AJS.Meta.get("user-locale").replace("_", "-");
            // stops any recognition in progress to start a new session
            recognition.stop();
            recognition.start();

            recognition.onstart = function()
            {
                self.showTimedMessage({title: "You can start speaking now :)"}, "info", 10);
                self.selectionStart = textareaInstance.manipulationEngine.getSelection().start;
            }
            recognition.onresult = function(event)
            {
                self.dismissCurrentMessage();
                var isFinal = getIsFinal(event.results);
                var speechResult = getTranscript(event.results);
                // capitalise first letter
                speechResult = speechResult.charAt(0).toUpperCase() + speechResult.slice(1);

                if (isFinal)
                {
                    textareaInstance.undoRedoEl.recordHistoryItem();
                }
                textareaInstance.manipulationEngine.replaceSelectionWith.call(textareaInstance.manipulationEngine, speechResult, false);
                var selectionEnd = self.selectionStart + speechResult.length;
                if (isFinal)
                {
                    // clears the selection
                    textareaInstance.manipulationEngine.setSelection(selectionEnd);
                    textareaInstance.undoRedoEl.recordHistoryItem();
                    textareaInstance.$el.trigger("input");
                    recognition.stop();
                }
                else
                {
                    textareaInstance.manipulationEngine.setSelection(self.selectionStart, selectionEnd);
                }
            }
            recognition.onerror = function(event)
            {
                recognition.stop();

                // this is a generic error message in case no specific error is raised
                var message = {
                    title: "Sorry, I can\'t hear you :(",
                    body: ''
                }
                switch (event.error)
                {
                    case "not-allowed":
                        message.title = "Speech recognition is currently disabled";
                        message.body = "Click the camera icon in the browser\'s address bar to enable it.";
                        break;
                    case "network":
                        message.title = "No internet connection";
                        message.body = "You need a working internet connection to use speech recognition.";
                        break;
                    case "no-speech":
                        message.title = "Sorry, I couldn\'t hear anything :(";
                        message.body = "Is your microphone working and unmuted?";
                        break;
                    // this only happens by user interaction, so there is no need to display a message
                    case "aborted":
                        return;
                }
                self.showTimedMessage(message, "warning", 5);
            }
            recognition.onend = function()
            {
                recognition.stop();
            }
        },

        /**
         * Shows a specific auiFlag and automatically hides it after the specified timeout
         *
         * @param message
         * @param flagType
         * @param duration in seconds
         */
        showTimedMessage: function(message, flagType, duration)
        {
            this.dismissCurrentMessage();
            this.speakFlag = auiFlag({
                type: flagType,
                title: message.title,
                body: message.body,
                persistent: true
            });

            clearTimeout(this.flagTimer);
            this.flagTimer = setTimeout(this.dismissCurrentMessage.bind(this), duration * 1000);
        },
        dismissCurrentMessage: function()
        {
            if (this.speakFlag && this.speakFlag.close)
            {
                this.speakFlag.close();
                this.speakFlag = null;
            }
        }
    }
})
;;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:skate', location = '/js/lib/skate.js' */
define('wiki-edit/skate', ['jira/skate'], function(skate) {
    return skate;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources-init', location = '/js/wiki-editor-init.js' */
require([
    'wiki-edit/WikiEditor',
    'wiki-edit/JIRA',
    'wiki-edit/skate',
    'jquery',
    'underscore'
], function(WikiEditor, JIRA, skate, $, _) {

    function createWikiTextfield(element) {
        var el = (this instanceof Element) ? this : element;
        var create = function(elem) {
            WikiEditor.create(elem);
            WikiEditor.initBrowseLink(elem);
            elem.wikiEnabled = true;
        };

        if (el.wikiEnabled === false) {
            if ($(el).is(':hidden')) {
                _.defer(create, el);
            } else {
                create(el);
            }
        }
    }

    function wikiEditorDefinition() {
        return {
            type: skate.type.CLASSNAME,
            attached: createWikiTextfield,
            prototype: {
                wikiEnabled: false
            }
        };
    }

    skate('wiki-textfield', wikiEditorDefinition());

    skate('wiki-enabled-textfield', wikiEditorDefinition());

    $(function() {
        if ($("#gh").length > 0) {
            JIRA.Dialogs.comment.options.width = 810;
            JIRA.Dialogs.assignIssue.options.width = 810;
            JIRA.Dialogs.attachFile.options.width = 810;
            JIRA.Dialogs.logWork.options.width = 810;
            JIRA.Dialogs.logWork.options.width = 810;
        }
    });

});
;
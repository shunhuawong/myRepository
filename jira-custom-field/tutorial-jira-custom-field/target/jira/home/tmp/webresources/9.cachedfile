;
/* module-key = 'com.atlassian.pocketknife.featureflags-plugin:pocketknife-feature-flags', location = '/featureflags/feature-manager.js' */
define("featureflags/feature-manager", [
    "exports"
], function(
    exports
    ){

    var json = WRM.data.claim("com.atlassian.pocketknife.featureflags-plugin:pocketknife-feature-flags.feature-flag-data");
    var systemEnabledFeatures = (json && json["enabled-feature-keys"]) || [];
    var featureFlagStates = (json && json["feature-flag-states"]) || {};

    var contains = function (arr, target) {
        return arr.indexOf(target) !== -1;
    };

    /**
     * Checks if the given feature is enabled. If no feature flag is defined with
     * the given feature key, this will fall-back to the default feature manager behaviour (like AJS.DarkFeatures.isEnabled(..))
     * @param featureKey a String, usually of the form "my.feature.key" (NOT "my.feature.key.enabled" or "my.feature.key.disabled")
     * @returns {boolean}
     */
    exports.isFeatureEnabled = function(featureKey){
        var flagState = featureFlagStates[featureKey];

        if(flagState === true){
            // Feature flag is in enabled state, check for (featureKey + ".disabled") to tell us otherwise
            var isSystemNegated = contains(systemEnabledFeatures, featureKey + ".disabled");
            return !isSystemNegated;
        }
        else if(flagState === false){
            // Disabled state, remain disabled unless (featureKey + ".enabled") is present
            var isSystemEnabled = contains(systemEnabledFeatures, featureKey + ".enabled");
            return isSystemEnabled;
        }
        else {
            // There is no flag defined with the given key, fall-back to what the system features say
            return contains(systemEnabledFeatures, featureKey);
        }
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-amd', location = 'js/jira-amd.js' */
/**
 * AMD wrapper for JIRA object
 */

define('dndattachment/JIRA',  function() {
    return JIRA;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-amd', location = 'js/aui-amd.js' */
// amd shim required for JIRA 6.1

define('dndattachment/aui', function() { return AJS; });;
;
/* module-key = 'com.atlassian.plugin.jslibs:moment-2.6.0', location = 'libs/moment/2.6.0/moment-2.6.0.js' */
/////////// Modified by Atlassian ///////////
(function(factory) {
    define('atlassian/libs/moment-2.6.0', function () {
        var env = {};
        factory.call(env);
        return env.moment;
    });
})(function(){
/////// End of Atlassian modification ///////


//! moment.js
//! version : 2.6.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
     Constants
     ************************************/

    var moment,
        VERSION = "2.6.0",
    // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

    // internal storage for language config files
        languages = {},

    // moment internal properties
        momentProperties = {
            _isAMomentObject: null,
            _i : null,
            _f : null,
            _l : null,
            _strict : null,
            _isUTC : null,
            _offset : null,  // optional. Combine with _isUTC
            _pf : null,
            _lang : null  // optional
        },

    // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

    // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

    // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

    // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

    //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

    // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

    // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

    // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

    // format function strings
        formatFunctions = {},

    // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        function printMsg() {
            if (moment.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' && console.warn) {
                console.warn("Deprecation warning: " + msg);
            }
        }
        return extend(function () {
            if (firstTime) {
                printMsg();
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
     Constructors
     ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
     Helpers
     ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function cloneMoment(m) {
        var result = {}, i;
        for (i in m) {
            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                result[i] = m[i];
            }
        }

        return result;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                    m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                        m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                            m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                                    m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                                        -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
     Languages
     ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
     Formatting
     ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
     Parsing
     ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
            case 'Q':
                return parseTokenOneDigit;
            case 'DDDD':
                return parseTokenThreeDigits;
            case 'YYYY':
            case 'GGGG':
            case 'gggg':
                return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
            case 'Y':
            case 'G':
            case 'g':
                return parseTokenSignedNumber;
            case 'YYYYYY':
            case 'YYYYY':
            case 'GGGGG':
            case 'ggggg':
                return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
            case 'S':
                if (strict) { return parseTokenOneDigit; }
            /* falls through */
            case 'SS':
                if (strict) { return parseTokenTwoDigits; }
            /* falls through */
            case 'SSS':
                if (strict) { return parseTokenThreeDigits; }
            /* falls through */
            case 'DDD':
                return parseTokenOneToThreeDigits;
            case 'MMM':
            case 'MMMM':
            case 'dd':
            case 'ddd':
            case 'dddd':
                return parseTokenWord;
            case 'a':
            case 'A':
                return getLangDefinition(config._l)._meridiemParse;
            case 'X':
                return parseTokenTimestampMs;
            case 'Z':
            case 'ZZ':
                return parseTokenTimezone;
            case 'T':
                return parseTokenT;
            case 'SSSS':
                return parseTokenDigits;
            case 'MM':
            case 'DD':
            case 'YY':
            case 'GG':
            case 'gg':
            case 'HH':
            case 'hh':
            case 'mm':
            case 'ss':
            case 'ww':
            case 'WW':
                return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
            case 'M':
            case 'D':
            case 'd':
            case 'H':
            case 'h':
            case 'm':
            case 's':
            case 'w':
            case 'W':
            case 'e':
            case 'E':
                return parseTokenOneOrTwoDigits;
            case 'Do':
                return parseTokenOrdinal;
            default :
                a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
                return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
            // QUARTER
            case 'Q':
                if (input != null) {
                    datePartArray[MONTH] = (toInt(input) - 1) * 3;
                }
                break;
            // MONTH
            case 'M' : // fall through to MM
            case 'MM' :
                if (input != null) {
                    datePartArray[MONTH] = toInt(input) - 1;
                }
                break;
            case 'MMM' : // fall through to MMMM
            case 'MMMM' :
                a = getLangDefinition(config._l).monthsParse(input);
                // if we didn't find a month name, mark the date as invalid.
                if (a != null) {
                    datePartArray[MONTH] = a;
                } else {
                    config._pf.invalidMonth = input;
                }
                break;
            // DAY OF MONTH
            case 'D' : // fall through to DD
            case 'DD' :
                if (input != null) {
                    datePartArray[DATE] = toInt(input);
                }
                break;
            case 'Do' :
                if (input != null) {
                    datePartArray[DATE] = toInt(parseInt(input, 10));
                }
                break;
            // DAY OF YEAR
            case 'DDD' : // fall through to DDDD
            case 'DDDD' :
                if (input != null) {
                    config._dayOfYear = toInt(input);
                }

                break;
            // YEAR
            case 'YY' :
                datePartArray[YEAR] = moment.parseTwoDigitYear(input);
                break;
            case 'YYYY' :
            case 'YYYYY' :
            case 'YYYYYY' :
                datePartArray[YEAR] = toInt(input);
                break;
            // AM / PM
            case 'a' : // fall through to A
            case 'A' :
                config._isPm = getLangDefinition(config._l).isPM(input);
                break;
            // 24 HOUR
            case 'H' : // fall through to hh
            case 'HH' : // fall through to hh
            case 'h' : // fall through to hh
            case 'hh' :
                datePartArray[HOUR] = toInt(input);
                break;
            // MINUTE
            case 'm' : // fall through to mm
            case 'mm' :
                datePartArray[MINUTE] = toInt(input);
                break;
            // SECOND
            case 's' : // fall through to ss
            case 'ss' :
                datePartArray[SECOND] = toInt(input);
                break;
            // MILLISECOND
            case 'S' :
            case 'SS' :
            case 'SSS' :
            case 'SSSS' :
                datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
                break;
            // UNIX TIMESTAMP WITH MS
            case 'X':
                config._d = new Date(parseFloat(input) * 1000);
                break;
            // TIMEZONE
            case 'Z' : // fall through to ZZ
            case 'ZZ' :
                config._useUTC = true;
                config._tzm = timezoneMinutesFromString(input);
                break;
            case 'w':
            case 'ww':
            case 'W':
            case 'WW':
            case 'd':
            case 'dd':
            case 'ddd':
            case 'dddd':
            case 'e':
            case 'E':
                token = token.substr(0, 1);
            /* falls through */
            case 'gg':
            case 'gggg':
            case 'GG':
            case 'GGGG':
            case 'GGGGG':
                token = token.substr(0, 2);
                if (input) {
                    config._w = config._w || {};
                    config._w[token] = input;
                }
                break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                var intVal = parseInt(val, 10);
                return val ?
                    (val.length < 3 ? (intVal > 68 ? 1900 + intVal : 2000 + intVal) : intVal) :
                    (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            }
            else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ?  parseWeekday(w.d, lang) :
                    (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
     Relative Time
     ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
     Week of Year
     ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
     Top Level Functions
     ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = cloneMoment(input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = lang;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
        "moment construction falls back to js Date. This is " +
        "discouraged and will be removed in upcoming major " +
        "release. Please refer to " +
        "https://github.com/moment/moment/issues/1407 for more info.",
        function (config) {
            config._d = new Date(config._i);
        });

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = lang;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
        // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
     Moment Prototype
     ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                    (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                    (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                        units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                            units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                                units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var sod = makeAs(moment(), this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                        diff < 0 ? 'lastDay' :
                            diff < 1 ? 'sameDay' :
                                diff < 2 ? 'nextDay' :
                                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
            this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
                case 'year':
                    this.month(0);
                /* falls through */
                case 'quarter':
                case 'month':
                    this.date(1);
                /* falls through */
                case 'week':
                case 'isoWeek':
                case 'day':
                    this.hours(0);
                /* falls through */
                case 'hour':
                    this.minutes(0);
                /* falls through */
                case 'minute':
                    this.seconds(0);
                /* falls through */
                case 'second':
                    this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        // keepTime = true means only change the timezone, without affecting
        // the local hour. So 5:31:26 +0300 --[zone(2, true)]--> 5:31:26 +0200
        // It is possible that 5:31:26 doesn't exist int zone +0200, so we
        // adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepTime) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    if (!keepTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                            moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this._lang._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.lang().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
            daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
     Duration Prototype
     ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
     Default Lang
     ************************************/


        // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                    (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                            (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
     Exposing Moment
     ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                "Accessing Moment through the global scope is " +
                "deprecated, and will be removed in an upcoming " +
                "release.",
                moment);
        } else {
            globalScope.moment = moment;
        }
    }

    /////////// Modified by Atlassian ///////////
    // CommonJS module is defined
    //if (hasModule) {
    //    module.exports = moment;
    //} else if (typeof define === "function" && define.amd) {
    //    define("moment", function (require, exports, module) {
    //        if (module.config && module.config() && module.config().noGlobal === true) {
    //            // release the global variable
    //            globalScope.moment = oldGlobalMoment;
    //        }
    //
    //        return moment;
    //    });
    //    makeGlobal(true);
    //} else {
    //    makeGlobal();
    //}
    // Bypassing in-library AMD
    makeGlobal();
    /////// End of Atlassian modification ///////

}).call(this);

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.lib.js' */
define('jira/moment/moment.lib', ['atlassian/libs/moment-2.6.0'], function(moment) {
    return moment;
});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.jira.formatter.js' */
define("jira/moment/moment.jira.formatter", ["underscore", "exports"], function(_, exports) {
    "use strict";
    var map = {
        d: "D",       // day
        y: "Y",       // year
        a: "A",       // meridiem
        E: "d",       // day name of week
        u: "d",       // day number of week
        Z: "ZZ",      // RFC 822 time zone
        z: "[GMT]ZZ", // replacing time zone name with offset
        XX: "ZZ",     // ISO 8601 time zone
        XXX: "Z"      // ISO 8601 time zone
    };

    function actuallyTranslate(tmpBuffer) {
        return map[tmpBuffer] || _.reduce(tmpBuffer, function (memo, value) {
            return memo + (map[value] || value);
        }, "");
    }

    function translateSimpleDateFormat(pattern) {
        var inQuote = false;
        var skip = false;
        var tmpBuffer = "";
        var reduction = _.reduce(pattern, function (memo, value, index, list) {
                if (skip) {
                    skip = false;
                }
                else if (value === '\'') {
                    if (tmpBuffer) {
                        memo += actuallyTranslate(tmpBuffer);
                        tmpBuffer = "";
                    }
                    if (list[index + 1] === '\'') {
                        memo += value;
                        skip = true;
                    }
                    else {
                        memo += !inQuote ? "[" : "]";
                        inQuote = !inQuote;
                    }
                }
                else if (inQuote) {
                    memo += value;
                }
                else if (!/[a-zA-Z]/.test(value)) {
                    if (tmpBuffer) {
                        memo += actuallyTranslate(tmpBuffer);
                        tmpBuffer = "";
                    }
                    memo += value;
                }
                else if (!tmpBuffer || tmpBuffer[tmpBuffer.length - 1] === value) {
                    tmpBuffer += value;
                }
                else {
                    memo += actuallyTranslate(tmpBuffer);
                    tmpBuffer = value;
                }
                return memo;
            }, "");
        if (tmpBuffer) {
            reduction += actuallyTranslate(tmpBuffer);
        }
        return reduction;
    }

    exports.translateSimpleDateFormat = translateSimpleDateFormat;
});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.jira.i18n.js' */
/* global WRM */
define("jira/moment/moment.jira.i18n", [
    "jira/moment/moment.lib",
    "jira/moment/moment.jira.formatter",
    "jira/util/data/meta"
], function (moment, formatter, Meta) {

    "use strict";

    var timeUnits = WRM.data.claim("jira.webresources:dateFormatProvider.dateFormat");

    moment.lang("jira", {
        months: timeUnits.months,
        monthsShort: timeUnits.monthsShort,
        weekdays: timeUnits.weekdays,
        weekdaysShort: timeUnits.weekdaysShort,
        weekdaysMin: timeUnits.weekdaysShort,
        longDateFormat: {
            LT: formatter.translateSimpleDateFormat(Meta.get("date-time")),
            L: formatter.translateSimpleDateFormat(Meta.get("date-day")),
            LL: formatter.translateSimpleDateFormat(Meta.get("date-dmy")),
            LLL: formatter.translateSimpleDateFormat(Meta.get("date-complete"))
        },
        meridiem: function (hours) {
            return timeUnits.meridiem[+(hours > 11)];
        },

        calendar: {
            sameDay:  "LLL",
            nextDay:  "LLL",
            nextWeek: "LLL",
            lastDay:  "LLL",
            lastWeek: "LLL",
            sameElse: "LLL"
        },

        // TODO Deprecate?
        relativeTime: {
            future: AJS.format("in {0}", "%s"),
            past: AJS.format("{0} ago", "%s"),
            s: "a few seconds",
            m: "a minute",
            mm: AJS.format("{0} minutes", "%d"),
            h: "an hour",
            hh: AJS.format("{0} hours", "%d"),
            d: "a day",
            dd: AJS.format("{0} days", "%d"),
            M: "a month",
            MM: AJS.format("{0} months", "%d"),
            y: "a year",
            yy: AJS.format("{0} years", "%d")
        }
    });

});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.js' */
/**
 * @fileOverview
 * Pulls in the core Moment.js library, defines JIRA's i18n mappings,
 * then returns a moment instance that always uses the correct i18n setting.
 * See {@link http://momentjs.com/docs/#/i18n/instance-locale/} for details
 * on Moment.js' (changes in its) support for i18n.
 */

/**
 * @module jira/moment
 */
define('jira/moment', ['jira/moment/moment.lib', 'jira/moment/moment.jira.i18n'], function(moment, i18n) {
    return moment;
});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.legacy.js' */
(function() {
    AJS.namespace('JIRA.translateSimpleDateFormat', null, require('jira/moment/moment.jira.formatter').translateSimpleDateFormat);
    AJS.namespace('window.moment', null, require('jira/moment'));
}());
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:shared-utility', location = 'js/ctrlv/time.js' */
define("dndattachment/ctrlv/time", [], function () {
  "use strict";
  return moment;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:shared-utility', location = 'js/ctrlv/base64decode.js' */
// Modified by Atlassian
// Copyright (c) 2013 ethertank, fusionchess
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
define("dndattachment/ctrlv/base64decode", [
    "exports"
], function (
  exports
) {
    "use strict";

    /**
     * Array of bytes to base64 string decoding
     * @param nChr
     * @returns {number}
     */
    function b64ToUint6(nChr) {
        return nChr > 64 && nChr < 91 ?
            nChr - 65
            : nChr > 96 && nChr < 123 ?
            nChr - 71
            : nChr > 47 && nChr < 58 ?
            nChr + 4
            : nChr === 43 ?
            62
            : nChr === 47 ?
            63
            :
            0;
    }

    var base64decode = function (encoded) {
        var sB64Enc = encoded.replace(/[^A-Za-z0-9\+\/]/g, ""),
            nInLen = sB64Enc.length,
            nOutLen = nInLen * 3 + 1 >> 2,
            taBytes = new Uint8Array(nOutLen);

        for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
            nMod4 = nInIdx & 3;
            nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
            if (nMod4 === 3 || nInLen - nInIdx === 1) {
                for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
                    taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
                }
                nUint24 = 0;
            }
        }

        return taBytes;
    };
    /**
     * Decoder of base64 encoded string to a byte array
     * @param encoded
     * @returns {Uint8Array}
     */
    exports.base64decode = base64decode;


    exports.decodeBase64DataUri = function (uri) {
        var separator = ";base64,",
            prefix = uri.slice(0, uri.indexOf(separator)) + separator,
            base64encoded = uri.substring(prefix.length);
        return base64decode(base64encoded);
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:shared-utility', location = 'js/ctrlv/utility.js' */
define("dndattachment/ctrlv/utility", [
    "jquery",
    "underscore",
    "dndattachment/ctrlv/base64decode",
    "dndattachment/ctrlv/time",
    "jira/flag",
    "jira/util/navigator",
    "featureflags/feature-manager",
    "exports"
], function (
  $,
  _,
  base64decode,
  time,
  JIRAFlag,
  Navigator,
  FeatureManager,
  exports
) {
    "use strict";

    /**
     * Determine if a keypress event is a "paste" (the keys differ between platform).
     * @param {Event} event
     * @param {string} [platform] If provided, overrides the value of navigator.platform.
     * @returns {boolean}
     */
    exports.isKeyPasteEvent = function (event, platform) {
        var V_KEY = 86;
        var IS_MAC = ((platform || "").indexOf("Mac") !== -1) || Navigator.isMac();

        return event.which === V_KEY && (IS_MAC ? event.metaKey : event.ctrlKey);
    };

    /**
     * Feature detection, check whether given parameter is a valid clipboard event
     *
     * @param event JQuery Event object
     * @returns {boolean}
     */
    exports.isImagePasteEvent = function (event) {
        if (event && event.clipboardData) {
            // Get the items from the clipboard, scan items and files properties
            var items = _.union(_.toArray(event.clipboardData.items), _.toArray(event.clipboardData.files));
            var hasImage = items.some(function (item) {
                return item.type.indexOf("image") !== -1;
            });
            var hasRtf = items.some(function (item) {
                return item.type.indexOf("rtf") !== -1;
            });
            return hasImage && !hasRtf;
        }
    };

    var getHtmlImagePaste = function (event) {
        if (!event.clipboardData || !event.clipboardData.types || !_.contains(event.clipboardData.types, "text/html")) {
            return;
        }

        var $data = $(event.clipboardData.getData("text/html"));
        if($data.length === 1 && $data.children().length === 0 && $data[0].nodeName.toLowerCase() === "img"){
            return $data[0].src;
        }
        return null;
    };

    exports.getHtmlImagePaste = getHtmlImagePaste;

    /**
     * Detect whether given event comes with html content in its ClipboardData, that contains single image tag
     * @param {Event} event
     * @returns {Boolean}
     */
    exports.isHtmlImagePasteEvent = function(event) {
        return getHtmlImagePaste(event) != null;
    };

    /**
     * Detect whether given event comes with text content in its ClipboardData
     * @param {Event} event
     * @returns {Boolean}
     */
    exports.isTextPasteEvent = function(event) {
        return event.clipboardData.types && (_.contains(event.clipboardData.types, "text/plain") || _.contains(event.clipboardData.types, "text/html"));
    };

    /**
     * Detect whether this element is an/withing contentEditable
     * @param {HTMLElement} element
     * @returns {Boolean}
     */
    exports.isContentEditable = function(element) {
        return  element.contentEditable == "true" || element.contentEditable == "" ||
                (element.contentEditable == "inherit" && $(element).parents().is('[contenteditable=true]'));
    };

    /**
     * Check if provided file name does not contain any of forbidden characters
     * @param {String} fileName
     * @returns {boolean}
     */
    exports.isValidFileName = function(fileName) {
        return !_([
            // characters forbidden by various file systems
            '\\', '/', '\"', ':', '?', '*', '<', '|', '>',
            // wiki markup
            '!'
        ]).any(function(character) {
            return fileName.indexOf(character) > -1;
        });
    };

    /**
     * Get text content from paste event
     * @param {Event} event
     * @returns {String}
     */
    exports.getTextPasteContent = function(event) {
        return event.clipboardData.types && _.contains(event.clipboardData.types, "text/plain") && event.clipboardData.getData("text/plain") || '';
    };

    /**
     * Get text contet from node, pick property which preserves new lines.
     * @param node
     * @returns {String}
     */
    exports.getTextContent = function(node) {
        if (!node) {
            return '';
        } else if (Navigator.isIE() && typeof node.innerText !== "undefined") {
            return node.innerText;
        } else  {
            return $(node).text();
        }
    };

    /**
     * Copy clipboardData from pasteEvent.originalEvent into pasteEvent or create and adapter
     * @param {Event} pasteEvent
     * @returns {Event}
     */
    exports.normalizePasteEvent = function(pasteEvent) {
        if(pasteEvent && pasteEvent.originalEvent && pasteEvent.originalEvent.clipboardData) {
            pasteEvent.clipboardData = pasteEvent.originalEvent.clipboardData;
        }

        // IE case, create small adapter for IE window.clipboardData
        if(pasteEvent && !pasteEvent.clipboardData && window.clipboardData) {
            pasteEvent.clipboardData = {
                files: window.clipboardData.files,
                types: {
                    contains: function(mimeType) {
                        if(mimeType == "text/plain") {
                            return !!window.clipboardData.getData("Text");
                        }
                    }
                },
                getData: function(mimeType) {
                    if(mimeType == "text/plain") {
                        return window.clipboardData.getData("Text");
                    }
                }
            };
        }

        return pasteEvent;
    };

    /**
     * Determine if the current browser is supported.
     * @param {string} [platform] If provided, overrides the value of navigator.platform.
     * @returns {boolean}
     */
    exports.browserIsSupported = function (platform) {
        var isMac = ((platform || "").indexOf("Mac") !== -1) || Navigator.isMac();
        var isSafari = Navigator.isSafari();

        // Safari isn't supported because it supports neither the HTML5 approach nor the Java applet approach.
        return !(isMac && isSafari);
    };

    /**
     * Determine wheter the current browser supports paste natively.
     * @returns {boolean}
     */
    exports.browserIsNativePaste = function () {
        return Navigator.isChrome() || Navigator.isSafari();
    };

    /**
     * Determine whether the unified attachments dark feature is enabled.
     * @returns {boolean}
     */
    exports.isUnifiedAttachmentsEnabled = function() {
        return FeatureManager.isFeatureEnabled("jira.unified.attachments");
    };

    /**
     * Determine whether the issuePasteDisabled dark feature is enabled.
     * @returns {boolean}
     */
    exports.isIssuePasteDisabledEnabled = function() {
        return FeatureManager.isFeatureEnabled("com.atlassian.plugins.jira.screenshot.issuePasteDisabled");
    };

    /**
     * Determine whether $pasteTarget is an input element and that it is a wiki textfield
     * @returns {boolean}
     */
    exports.isWikiTextfield = function ($pasteTarget) {
        return $pasteTarget.is(':input') && $pasteTarget.hasClass("wiki-textfield")
    };

    /**
     * Determine whether the element is the summary input field
     * @returns {boolean}
     */
    var _isSummaryField = function ($pasteTarget) {
        return $pasteTarget.is('input#summary');
    };

    /**
     * Append the given text content (if not null) to either the summary field or to a wiki textfield
     * @param content to be appended
     * @param pasteTarget element that will have the value updated
     * @param selectionStart
     * @param selectionEnd
     */
    var insertToInput = function (content, pasteTarget, selectionStart, selectionEnd) {
        var $pasteTarget = $(pasteTarget);

        // bail if pasteTarget is not a valid field or if no content was passed in
        if( !(exports.isWikiTextfield($pasteTarget) || _isSummaryField($pasteTarget)) || !content) {
            return;
        }

        if(!$pasteTarget.is(':focus')) {
            // This is a workaround for the case where the textfield is not focused (only needed for some browsers).
            // This ensures the cursor moves to the end of the text.
            $pasteTarget.one('focus', function() {
                var pasteTarget = $pasteTarget[0];
                pasteTarget.selectionStart = pasteTarget.selectionEnd = selectionStart + content.length;
            });
        }

        var value = $pasteTarget.val();
        var prefix = value.substring(0, selectionStart);
        var suffix = value.substring(selectionEnd, value.length);

        // wiki editor maintains its own history buffer, it helps us in some browser(Safari, IE)
        var wikiEditor = $pasteTarget.data("wikiEditor");
        if(wikiEditor && wikiEditor.undoRedoEl && _.isFunction(wikiEditor.undoRedoEl.recordHistoryItem)) {
            wikiEditor.undoRedoEl.recordHistoryItem();
        }

        $pasteTarget.val(prefix + content + suffix);

        // trigger input for dirty form handlers if there are any
        $pasteTarget.trigger("input");

        pasteTarget.selectionStart = pasteTarget.selectionEnd = selectionStart + content.length;

        if(wikiEditor && wikiEditor.undoRedoEl && _.isFunction(wikiEditor.undoRedoEl.updateCurrent)) {
            wikiEditor.undoRedoEl.updateCurrent();
        }
    };

    /**
     * Insert content into textfield at its current selection
     * @param {String} content
     * @param {HTMLElement} textfield
     * @param {Number} selectionStart current selection start
     * @param {Number} selectionEnd current selection end
     */
    exports.insertToInput = insertToInput;

    exports.getMarkup = function(fileName) {
        var animatedImageFileTypes = [
            'gif'
        ];
        var regularImageFileTypes = [
            'bmp',
            'jpeg',
            'jpg',
            'png'
        ];
        var nameParts = fileName.split('.');
        var fileType = nameParts[nameParts.length - 1].toLowerCase();
        if (_.contains(animatedImageFileTypes, fileType)) {
            return '!' + fileName + '!';
        } else if (_.contains(regularImageFileTypes, fileType)) {
            return '!' + fileName + '|thumbnail!';
        } else {
            return '[^' + fileName + ']';
        }
    };

    /**
     * Wrap fileName into wiki markup and insert it into textfield at its current selection
     * @param {String} fileName
     * @param {HTMLElement} pasteTarget
     * @param {Number} selectionStart current selection start
     * @param {Number} selectionEnd current selection end
     */
    exports.insertWikiMarkup = function (fileName, pasteTarget, selectionStart, selectionEnd) {
        var markup = exports.getMarkup(fileName);
        if (markup) {
            // Add a space before and after so that it will display properly if the user forgets to add spaces
            markup = " " + markup + " ";
            insertToInput(markup, pasteTarget, selectionStart, selectionEnd);
        }
    };

    /**
     * Load image from given source
     * @param imageSrc
     * @returns {$.Deferred}
     */
    exports.loadImage = function (imageSrc) {
        var deferred = new $.Deferred();

        var image = new Image();
        image.setAttribute("crossOrigin", "anonymous");
        image.onload = function() {
            deferred.resolve(image);
        };
        image.onerror = deferred.reject.bind(deferred);
        image.src = imageSrc;

        // maybe it was already loaded (from cache)
        if(image.width > 0 && image.height > 0) {
            deferred.resolve(image);
        }

        return deferred;
    };

    /**
     * Convert image to blob or return null when it is not possible
     * @param image
     * @returns {Blob}
     */
    exports.convertImageToBlob = function(image) {
        // off screen canvas and try feature detection
        var canvas = $('<canvas>').attr("width", image.width).attr("height", image.height)[0];
        canvas.getContext('2d').drawImage(image, 0, 0);
        try {
            if(canvas.mozGetAsFile) {
                return canvas.mozGetAsFile("image/png");
            }

            if(canvas.toDataURL) {
                return new Blob([base64decode.decodeBase64DataUri(canvas.toDataURL("image/png"))], { type: "image/png" });
            }
        } catch(e) {
            // in case of any exceptions (security, malformed uri etc)
            return null;
        }
    };

    /**
     * Convert a blob into an image
     * @param blob
     * @param imageName
     * @return {File}
     */
    exports.convertBlobToImage = function(blob, imageName) {
        var file = new Blob([blob.slice()], { type: blob.type });
        file.lastModifiedDate = new Date();
        file.name = imageName;
        return file;
    };

    /**
     * Try to drop image file to element and return true if the event was actually consumed
     * @param {Blob} file
     * @param {jQuery} element
     * @returns {Boolean} Returns true if drop was actually consumed
     */
    exports.dropFileToElement = function(file, $element) {
        var fileName = file.name;
        if(!fileName) {
            fileName = this.generateFileName();
            file.name = fileName + ".png";
        }
        var event = $.Event("drop", {dataTransfer: {files: [file]}});

        var result = false;
        $(document).on('dropHandled.dropFileToElement', function() {
            result = true;
        });
        $element.trigger(event);
        $(document).off('.dropFileToElement');
        return result;
    };

    exports.generateFileName = function() {
        return "image-" + time().format("YYYY-MM-DD-HH-mm-ss-SSS");
    };

    exports.getCurrentIssueId = function() {
        return JIRA.Issues.Api.getSelectedIssueId();
    };

    exports.showErrorMsg = function(title, message){
        JIRAFlag.showErrorMsg(title, message);
    };

    /**
     * Create Blob from file with same mime type and copied file.name.
     * This is required, because we want to pass file with modified name in drop event and name property of File is read only
     * @param {File} file
     * @returns {Blob}
     */
    exports.createBlobFromFile = function(file) {
        var fileBlob = new Blob([file.slice()], { type: file.type });
        fileBlob.name = file.name;
        return fileBlob;
    };

    /**
     * Check whether a drag event contains files. To be used during dragover/dragenter events to determine whether
     * we should show the dropzone or not. If dataTransfer.types is not supported (only IE) just returns true.
     * This doesn't work completely on Firefox, since they count dragging an image element from within the browser
     * as a 'file'.
     * @param event
     * @returns {boolean}
     */
    exports.dragEventContainsFiles = function (event) {
        // If we can't check the types, assume it does contain files.
        if (!event.dataTransfer || !event.dataTransfer.types) {
            return true;
        }

        // Behaviour
        // Mozilla: types = DOMStringList and contains "Files" even when a file is not dragging. It contains "application/x-moz-file" when a file is actually dragging
        // IE: types = DOMStringList and contains "Files" when dragging  a file
        // Chrome + Safari: types = Array and contains "Files" when dragging a file

        var types = event.dataTransfer.types;

        if (Navigator.isMozilla()) {
            return types.contains("application/x-moz-file");
        }

        // using a standard iterator as it works for both Array and DOMStringList
        for (var i = 0; i < types.length; i++) {
            if (types[i] === "Files") {
                return true;
            }
        }

        return false;
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/Configuration.js' */
define("dndattachment/util/Configuration", function() {
    var dataKey = "com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone.";

    function getWRMData(key) {
        return _.isFunction(WRM.data) ? WRM.data(key) : WRM.data.claim(key);
    }

    return {
        getWRM: function(key) {
            return getWRMData(dataKey + key);
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/DataTransfer.js' */
define("dndattachment/util/DataTransfer", ['jquery'], function ($) {
    return Class.extend({
        init: function(_dataTransfer) {
            this._dataTransfer = _dataTransfer;
        },

        getFiles: function() {
            var files = this._dataTransfer.files;
            var items = this._dataTransfer.items;

            if(items && items.length > 0) {
                if(_.any(items, function(item) { return !!item.webkitGetAsEntry; })) {
                    return this.readEntries(items);
                }
            }

            if(files && files.length > 0) {
                return this.readFiles(this._dataTransfer.files)
            } else {
                return new $.Deferred().reject();
            }
        },

        readFiles: function(files) {
            var result = new $.Deferred();

            $.when.apply(window, _.map(files, function(file) {
                var deferred = new $.Deferred();

                var noExtension = !file.name.match(/\.([a-z0-9]+)$/i);

                // if there is no extension, we rely on a fact that underlying implementation
                // will throw permission denied on fopen call for directory path
                // typical candidates for directory are paths without extension at the end
                // and also file.size 8192, 4096 and below 1024(Mac OS X)
                if(noExtension && (file.size <= 8192) || file.size == 8192 || file.size == 4096 || file.size <= 1024) {
                    this.readFileAsText(file).fail(function() {
                        files = _(files).without(file);
                    }).always(deferred.resolve.bind(deferred));
                } else {
                    deferred.resolve();
                }

                return deferred;
            }.bind(this))).always(function() {
                result.resolve(files);
            });

            return result;
        },

        readFileAsText: function(file) {
            var result = new $.Deferred();

            var reader = new FileReader();
            reader.onload = function() {
                result.resolve(this.result);
            };
            reader.onerror = function() {
                result.reject(this.error);
            };

            reader.readAsText(file);

            return result;
        },

        readEntries: function(items) {
            var result = new $.Deferred();

            // if dropped item is a file or a directory, item.kind === "file"
            items = _.filter(items, function(item){
                return item.kind === "file";
            });

            $.when.apply(window, _.map(items, function (item) {
                return this.readEntry(item.webkitGetAsEntry(), item);
            }.bind(this))).then(function() {
                result.resolve(_.union.apply(_, arguments));
            }, result.reject.bind(result));

            return result;
        },

        readEntry: function(entry, item) {
            var result = new $.Deferred();

            if(entry.isFile) {
                if(item && item.getAsFile) {
                    result.resolve([item.getAsFile()]);
                } else {
                    entry.file(function(file) {
                        result.resolve([file]);
                    });
                }
            } else if(entry.isDirectory) {
                entry.createReader().readEntries(function(entries) {
                    var files = [];

                    $.when.apply(window, _.map(entries, function(entry) {
                        return this.readEntry(entry).then(function(entryFiles) {
                            return files.push.apply(files, entryFiles);
                        });
                    }.bind(this))).always(function() {
                        result.resolve(files);
                    });
                }.bind(this));
            }

            return result;
        }
    })
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/FileSizeUtil.js' */
/**
 * Ported from com.atlassian.core.util.FileSize
 */

define('dndattachment/util/FileSizeUtil',
function() {
    var KB_SIZE = 1024;
    var MB_SIZE = KB_SIZE * KB_SIZE;

    var KB = " kB";
    var MB = " MB";

    /**
     * Format the size of a file in human readable form.  Anything less than a kilobyte
     * is presented in kilobytes to one decimal place.  Anything between a kilobyte and a megabyte is
     * presented in kilobytes to zero decimal places.  Anything greater than one megabyte is
     * presented in megabytes to two decimal places.
     * <p>
     * eg.
     * <ul>
     *  <li>format(512) -> 0.5 kb
     *  <li>format(1024) -> 1.0 kb
     *  <li>format(2048) -> 2 kb
     *  <li>format(1024 * 400) -> 400 kb
     *  <li>format(1024 * 1024) -> 1024 kb
     *  <li>format(1024 * 1024 * 1.2) -> 1.20 Mb
     *  <li>format(1024 * 1024 * 20) -> 20.00 Mb
     * </ul>
     *
     * @param   filesize  The size of the file in bytes.
     * @return  The size in human readable form.
     */
    function format(filesize) {
        // TODO: filesize = 1024 gives "1.0 kB", but filesize = 1025 gives "1 kB", this is kinda inconsistent.

        if (filesize > MB_SIZE)
        {
            return formatMB(filesize);
        }
        else if (filesize > KB_SIZE)
        {
            return formatKB(filesize);
        }
        else
        {
            return formatBytes(filesize);
        }

    }

    function formatMB(filesize) {
        var mbsize = filesize / MB_SIZE;
        return mbsize.toFixed(2) + MB;
    }

    function formatKB(filesize) {
        var kbsize = Math.round(filesize / KB_SIZE); //format 0 decimal places
        return kbsize + KB;
    }

    function formatBytes(filesize) {
        var mbsize = filesize / KB_SIZE;
        return mbsize.toFixed(1) + KB;
    }

    return {
        format: format
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/AttachmentEvents.js' */
/**
 * A dictionary of attachment related event types that JIRA will fire from time to time.
 * @module jira/util/events/types
 */
define('dndattachment/util/events/types', {
    // Export the event name so listeners don't have to
    ATTACHMENT_FOR_PAGE_RECEIVED: "attachmentForPageReceived"
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-upload', location = 'js/upload/UploadHandler.js' */
/**
 * An executor is what the handler calls to actually execute the upload
 * @typedef {Object} Executor
 *  @function {boolean} isValid(event, args) - returns true if the executor wants to be invoked.
 *  @function {deferred} processFiles(files, attachmentDropZone) - handles the actual processing of the file.
 *  Should return a deferred that properly communicates the outcome
 *  @property {number} weight - the weight of the executor when we loop through them. Higher the number, the earier we check it
 *  @property {string} name - name of the executor. This is used as the 'key' when we register and remove executors.
 */

/**
 * This listens for EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED and handles the uploading of the files.
 * This does not do the actual uploading, just collects the events and pass them along.
 */
define('dndattachment/upload/handler', [
    'jira/util/events',
    'dndattachment/util/events/types',
    'underscore',
    'jquery',
    'dndattachment/ctrlv/utility',
    'exports'
], function(
    Events,
    EventTypes,
    _,
    $,
    Utility,
    exports
) {
    // The list of registered upload executors
    var executorList = [];

    // The current attachmentDropZone that is relevant to us
    var attachmentDropZone;

    /**
     * This method is called to handle the ATTACHMENT_FOR_PAGE_RECEIVED event once it has been triggered by something.
     *
     * @param event - This will be ATTACHMENT_FOR_PAGE_RECEIVED
     * @param args - These are all the arguments that are passed in when the event is thrown. Typically they will
     * contain files, successCallback, failureCallback and alwaysCallback but may contain more things depending on the code
     * that receives the file.
     */
    var handleAttachmentReceived = function(event, args) {
        var uploadResult = $.Deferred();

        //if there's a dialog open, we simulate a drop and let the dialog handle it.
        var JIRADialog = JIRA.Dialog.current;
        if (JIRADialog) {
            AJS.trigger('analytics', { name : 'attach.screenshot.html5.dialogPaste', data : {}});

            var fileBlob = Utility.createBlobFromFile(args.files[0]);
            if(Utility.dropFileToElement(fileBlob, JIRADialog.$form)) {
                uploadResult.resolve([args.files[0].name]);
            }
        }
        else {
            var validExecutor = _.find(executorList, function(executor) {
                return executor.isValid(event, args);
            });
            if(validExecutor) {
                uploadResult = validExecutor.processFiles(args.files, attachmentDropZone);
                if(args.successCallback) {
                    uploadResult.done(args.successCallback);
                }
                if(args.failureCallback) {
                    uploadResult.fail(args.failureCallback);
                }
                if(args.alwaysCallback) {
                    uploadResult.always(args.alwaysCallback);
                }
            }
        }

        uploadResult.done(function(fileNames, noInsertMarkup) {
            if (!noInsertMarkup && args.isWikiTextfieldFocused) {
                var wikiTextfield = args.wikiTextfield;
                _.each(fileNames, function(fileName) {
                    Utility.insertWikiMarkup(fileName, wikiTextfield, wikiTextfield.selectionStart, wikiTextfield.selectionStart);
                });
                if (JIRADialog && args.isPaste) {
                    AJS.trigger('analytics', { name : 'attach.screenshot.html5.dialogPaste.insertWikiMarkup', data : {}});
                }
                // Focus back on the textfield if the executor caused it to lose focus.
                if (!$(args.wikiTextfield).is(":focus")) {
                    setTimeout(function () {
                        args.wikiTextfield.focus();
                    }, 0);
                }
            }
        });
    };

    var isExecutorValid = function(executor) {
        // Check that the executor exists
        if(executor) {
            // Check that the valid methods are defined
            var hasIsValidMethod = typeof executor.isValid !== 'undefined';
            var hasProcessFiles = typeof executor.processFiles !== 'undefined';
            var hasWeight = typeof executor.weight !== 'undefined';
            var hasName = typeof executor.name !== 'undefined';

            return hasIsValidMethod && hasProcessFiles && hasWeight && hasName;
        }
        return false;
    };

    /**
     * This registers an executor for handling the uploads.
     *
     * @param {Executor} executor - The executor to register
     * @returns {Boolean} - true if the registration was successful
     */
    exports.registerExecutor = function(executor) {
        var isValid = isExecutorValid(executor);
        if(isValid) {
            // Prevent duplicate executors
            var list = _.reject(executorList, function (ex) {
                return ex.name === executor.name;
            });

            // Add in the executor
            list.push(executor);

            // Sort by weight
            executorList = _.sortBy(list, function (ex) {
                // Negative weight so that highest numbers are sorted first
                return -ex.weight;
            });
        }
        return isValid;
    };

    /**
     * This unregisters an executor
     *
     * @param {Executor} executor - The executor to register
     */
    exports.unregisterExecutor = function(executor) {
        executorList = _.reject(executorList, function(ex) {
            return ex.name === executor.name;
        });
    };

    /**
     * Initialised the upload handler
     */
    exports.initialize = function() {
        // Handle any attachments that need to be uploaded directly onto the page through the main attachment zone
        Events.bind(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, handleAttachmentReceived);
    };

    /**
     * Remove the upload handler
     */
    exports.disable = function() {
        // Cleanup everything that was done in the initialize method
        Events.unbind(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, handleAttachmentReceived);
    };

    /**
     * Set the attachmentDropZone that should handle incoming attachments
     */
    exports.setAttachmentDropZone = function(dropZone) {
        attachmentDropZone = dropZone;
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-upload', location = 'js/upload/DefaultUploadExecutor.js' */
/**
 * This is the default executor that uploads the files when none of the other registered executors hit
 */
define('dndattachment/upload/default/executor', [
    'jquery',
    'underscore',
    'dndattachment/ctrlv/utility',
    'exports'
], function(
    $,
    _,
    Utility,
    exports
) {
    exports.name = 'Default attachment executor';

    /**
     * The default executor's weight is always 0. As in it is always the lowest thing
     */
    exports.weight = 0;

    /**
     * This executor is always valid
     */
    exports.isValid = function(event, args) {
        return true;
    };

    exports.processFiles = function(files, attachmentDropZone) {
        return attachmentDropZone.uploadFiles(files);
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-base', location = 'js/i18n.js' */
// because almond.js breaks jsI18n transformers

define('dndattachment/i18n', function() {
    var dict = {
        "dnd.attachment.unsupported.browser": "\u041f\u0435\u0440\u0435\u0442\u0430\u0441\u043a\u0438\u0432\u0430\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432 \u0432\u043b\u043e\u0436\u0435\u043d\u0438\u0439 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e \u0442\u043e\u043b\u044c\u043a\u043e \u0432 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u0430\u0445:",
        "dnd.attachment.file.is.too.large": "\u0420\u0430\u0437\u043c\u0435\u0440 \u0444\u0430\u0439\u043b\u0430 \u043f\u0440\u0435\u0432\u044b\u0441\u0438\u043b \u043b\u0438\u043c\u0438\u0442, \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u044b\u0439 \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u043c ({0}).",
        "dnd.attachment.upload.in.progress": "\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u043e\u0436\u0438\u0434\u0430\u0439\u0442\u0435. \u0412\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0430.",
        "dnd.attachment.not.uploaded": function(param) {
            return AJS.format("File \"{0}\" was not uploaded", param)
        },
        "dnd.attachment.unauthorized": "You are not authorized, session has expired or connection is lost.",
        "dnd.attachment.internal.server.error": "An internal error has occurred. Please contact your administrator.",
        "dnd.attachment.upload.aborted": "Upload was aborted.",
        "dnd.attachment.upload.remove": "Remove attachment"

    };
    return function(key) {
        if(dict[key])
            return dict[key];
        else
            throw "Unknown key: "+key;
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-base', location = 'js/TemporaryAttachments.js' */
define('dndattachment/TemporaryAttachments', [], function() {
    var attachments = { };

    return {
        createAttachment: function(id, name, type, file) {
            return {
                id: id,
                name: name,
                type: type,
                file: file
            };
        },

        getAttachment: function(id, name) {
            return attachments[id] || this.createAttachment(id, name);
        },

        putAttachment: function(id, file) {
            return attachments[id] = this.createAttachment(id, file.name, file.type, file);
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-base', location = 'js/Parser.js' */
define('dndattachment/Parser',
    ['dndattachment/aui',
     'jquery'],
function(AJS, $) {
    var PARSED_MARKCLASS = '-dui-type-parsed';
    var contextSelector = '*[duiType]:not(.'+PARSED_MARKCLASS+')';

    function parse(context) {
        var queue = $(context).find(contextSelector).add(context.filter(contextSelector));

        var deferreds = queue.addClass(PARSED_MARKCLASS).map(function(idx, el) {
            var result = new $.Deferred();

            require([$(el).attr('duiType')], function(duiType) {
                if(typeof duiType == "function")
                    result.resolve(new duiType(el));
                else
                    result.reject();
            });

            return result;
        });

        return $.when.apply(window, $.makeArray(deferreds));
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function(e, context, reason) {
        parse(context);
    });

    if($.isReady) {
        parse($('body'));
    } else {
        $(function() {
            parse($('body'));
        });
    }

    return {
        parse: parse
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-base', location = 'js/dropzones/IssueDropZone.js' */
define('dndattachment/dropzones/IssueDropZone', [
        'jquery',
        'jira/flag',
        'dndattachment/Parser',
        'dndattachment/aui',
        'dndattachment/JIRA',
        'dndattachment/i18n',
        'dndattachment/TemporaryAttachments',
        'dndattachment/util/DataTransfer',
        'featureflags/feature-manager',
        'dndattachment/ctrlv/utility'
    ],
    function($,
             Flag,
             Parser,
             AJS,
             JIRA,
             I18n,
             Attachments,
             DataTransfer,
             FeatureManager,
             Utility) {

    var AUTO_DESTROY_DELAY = 5000;
    var INTERNAL_ERROR = ["An internal error has occurred. Please contact your administrator."];

    var IssueDropZone = Class.extend({

        eventGroup: 'issuedropzone',

        progressBarType: 'dndattachment/progressbars/UploadProgressBar',

        init: function(element) {
            this.$node = $(element);

            if(!this.isSupportedBrowser()) {
                return this.renderUnsupported();
            }

            if(this.$node.parents('.mod-content')) {
                this.$node.parents('.mod-content').addClass('issue-drop-zone');
            }

            this.uploadLimit = this.$node.data('upload-limit');
            this.uploadSize = this.$node.data('upload-size');
            this.formToken = this.$node.data('form-token');
            this.attachFileUrl = contextPath + '/secure/AttachFile.jspa';

            this.pendingQueue = [];

            this.render();

            this.queueEvent('init');
        },

        queueTask: function(task) {
            this.pendingQueue.push(task);
            task.always(function() {
                this.pendingQueue.splice(this.pendingQueue.indexOf(task), 1);
            }.bind(this));

            this.markDirty(true);

            // debounce required to make transition -> commit possible
            $.when.apply(window, this.pendingQueue).always(_.debounce(this.checkMarkDirty, false, true).bind(this));
        },

        render: function() {
            this.$node.html(JIRA.Templates.DnDAttachmentPlugin.IssueDropZone({}));

            this.fileInput = this.$node.find('.issue-drop-zone__file');
            this.fileButton = this.$node.find('button.issue-drop-zone__button');

            this.connectListeners();

            JIRA.trace("jira.issue.dnd.issuedropzone.render");
        },

        connectListeners: function() {
            this.fileInput.change(function(event) {
                this.handleFilesReceived(this.fileInput[0].files);
                this.queueEvent('fileInput', { count: this.fileInput[0].files.length });
                this.fileInput.attr('value', null);
            }.bind(this));

            this.fileButton.click(function(e){
                e.preventDefault();
                this.fileInput.click();
            }.bind(this));

            var $dropNode = this.$node.parents('.issue-drop-zone').length > 0 ? this.$node.parents('.issue-drop-zone') : this.$node;
            this.$dropTarget = $dropNode.find('>*').andSelf();

            this.$dropTarget.on('dragover dragenter drop', function(event) {
                event.preventDefault();
                event.stopPropagation();

                $dropNode.addClass('dragover');

                if(event.type == 'drop') {
                    $dropNode.removeClass('dragover');
                    $(document).trigger("dropHandled");

                    var dataTransfer = new DataTransfer(event.dataTransfer);
                    dataTransfer.getFiles().then(function(files) {
                        this.handleFilesReceived(files);
                        this.queueEvent('fileDrop', { count: files.length });
                    }.bind(this));
                }
            }.bind(this));

            this.$dropTarget.on('dragleave', function() {
                $dropNode.removeClass('dragover');
            }.bind(this))
        },

        configureUploadProgressBar: function($progressBar, file) {
            $progressBar.data("upload-size", this.uploadSize).
                data("file", file).
                data("form-token", this.formToken);
        },

        /**
         * It will create progress bar for given file and place it in drop zone
         * @param {File} file An object that comes from input field or drop object
         * @returns {UploadProgressBar}
         */
        createUploadProgressBar: function(file) {
            var $progressBar = $('<div duiType="'+this.progressBarType+'" class="upload-progress-bar"></div>');
            this.configureUploadProgressBar($progressBar, file);

            return Parser.parse($progressBar).then(function(progressBar) {
                this.placeUploadProgressBar($progressBar, progressBar);
                this.handleNewProgressBar(progressBar);
            }.bind(this));
        },

        placeUploadProgressBar: function($progressBar) {
            return $progressBar.insertAfter(this.$node);
        },

        handleNewProgressBar: function(progressBar) {
            // This is to be overridden by parent classes if needed
        },

        // The default behaviour for handling files is to upload them
        handleFilesReceived: function (files) {
            this.uploadFiles(files);
        },

        uploadFiles: function(files) {

            var uploadFilesResult = new $.Deferred();
            var progressBars = [];
            var issueKey = AJS.Meta.get("issue-key");
            var issueLink = AJS.Meta.get("viewissue-permlink");
            // user could be editing the summary field || not editing
            var issueSummary = $("#summary-val input").attr("value") || $("#summary-val").text();
            var issueLinkHTML = JIRA.Templates.DnDAttachmentPlugin.SuccessMessageLink({ issueLink: issueLink, issueKey: issueKey, issueSummary: issueSummary });

            var queue = _.map(files, function(file) {
                var result = new $.Deferred();

                this.createUploadProgressBar(file).then(function(uploadProgressBar) {
                    this.trigger('progressBarInserted', uploadProgressBar);
                    progressBars.push(uploadProgressBar);
                    uploadProgressBar.uploadFile(file, this.uploadLimit)
                        .then(result.resolve.bind(result), result.resolve.bind(result))
                        .done(function() {
                            this.trigger('uploadFinished', uploadProgressBar);
                        }.bind(this))
                        .fail(function(){
                            uploadFilesResult.reject(arguments);
                        });
                }.bind(this));

                return result;
            }.bind(this));

            var uploadQueue = $.when.apply(window, queue);

            uploadQueue.done(function() {
                var fileIDs = _.filter(queue.length == 1 ? [arguments] : arguments, function(result) {
                    return result && result[0] && result[0].id }).map(function(result) {
                    return result[0].id
                });

                if(fileIDs.length == 0) {
                    return;
                }

                this.commitUpload(fileIDs).done(function() {
                    // auto destroy progress bars
                    _.delay(function() {
                        progressBars.some(function(progressBar) {
                            if(progressBar.getAutoDestroy()) {
                                progressBar.destroy();
                                this.queueEvent('autoDestroy')
                            }
                        }.bind(this));
                    }.bind(this), AUTO_DESTROY_DELAY);

                    var successfulUploads = _.filter(progressBars, function(progressBar){
                        return progressBar.result.isResolved();
                    });

                    if(successfulUploads.length == 1){
                        var fileName = successfulUploads[0].getFileName();
                        Flag.showSuccessMsg("", AJS.format("{0} was attached successfully to {1}.", fileName, issueLinkHTML));
                    }
                    else if(successfulUploads.length > 1){
                        Flag.showSuccessMsg("", AJS.format("{0} files were attached successfully to {1}.", successfulUploads.length, issueLinkHTML));
                    }
                    uploadFilesResult.resolve(
                        _.map(successfulUploads, function(successfulUpload) {
                            return successfulUpload.file.name;
                        })
                    );
                }.bind(this)).fail(function(errorMessages, errors) {
                    uploadFilesResult.reject(errorMessages, errors);
                    if(errorMessages) {
                        errorMessages.forEach(function(errorMessage) {
                            progressBars.forEach(function(progressBar) {
                                progressBar.reportError(errorMessage);
                            });
                        });
                    }

                    if(errors) {
                        progressBars.forEach(function(progressBar) {
                            var errorMessage = errors['#' + progressBar.getFileID()] || errors[progressBar.getFileName()];
                            if(errorMessage) {
                                progressBar.reportError(errorMessage);
                            }
                        });
                    }

                    JIRA.trace('jira.issue.dnd.commit.fail');
                });
            }.bind(this));

            this.queueTask(uploadQueue);

            return uploadFilesResult;
        },

        /**
         *
         * @param attachments
         */
        loadAttachments: function(attachments) {
            attachments.forEach(function(attachment) {
                this.createUploadProgressBar(attachment.file).then(function(progressBar) {
                    progressBar.setFileID(attachment.id);
                    progressBar.setFileName(attachment.name);
                    progressBar.setFileSize(attachment.size);
                    progressBar.setProgress(1);
                    progressBar.setFinished();

                    this.trigger('uploadFinished', progressBar);
                }.bind(this));
            }, this);
        },

        commitUpload: function(fileIDs) {
            // By default, do nothing. This method is typically overridden
            return new $.Deferred();
        },

        attachFile: function(fileIDs) {
            var result = new $.Deferred();

            JIRA.SmartAjax.makeRequest({
                type: "POST",
                url: this.attachFileUrl,
                data: {
                    inline: true,
                    id: JIRA.Issue.getIssueId(),
                    filetoconvert: fileIDs,
                    atl_token: atl_token(),
                    formToken: this.formToken
                },
                dataType: "json"
            })
            .done(result.resolve.bind(result))
            .fail(function(jqXHR) {
                try {
                    var response = JSON.parse(jqXHR.responseText);
                    result.reject(response.errorMessages || INTERNAL_ERROR, response.errors);
                } catch(ex) {
                    result.reject(INTERNAL_ERROR);
                }
            });

            return result;
        },

        isSupportedBrowser: function() {
            if ($('html.webkit')[0] || $('html.safari')[0]) {
                if (!(parseFloat($.browser.version) >= 537)) {
                    return false;
                }
            } else {
                if ($('html.mozilla')[0]) {
                    if (!(parseFloat($.browser.version) >= 1.9)) {
                        return false;
                    }
                } else if ($('html.msie')[0]) {
                    if (!(parseFloat($.browser.version) >= 10)) {
                        return false;
                    }
                } else {
                    return false; // we don't support anything else than IE10, Mozilla or WebKit
                }
            }
            return true;
        },

        renderUnsupported: function() {
            this.$node.addClass('issue-drop-zone__not-supported').text(I18n("dnd.attachment.unsupported.browser")).append('<ul><li>FireFox 3.6+</li><li>Chrome 5+</li><li>Safari 5</li></ul>');
        },

        markDirty: function(isDirty) {
            // DirtyForm
            this.$node.addClass(JIRA.DirtyForm.ClassNames.SANCTIONED);
            this.$node.toggleClass(JIRA.DirtyForm.ClassNames.EXEMPT, !isDirty);
            this.$node.attr('value', false);
            this.$node.attr('defaultValue', true);
        },

        checkMarkDirty: function() {
            // all tasks are done, succesful or not
            if(this.pendingQueue.length == 0)
                this.markDirty(false);
        },

        /**
         * Analytics
         */

        queueEvent: function(name, props) {
            AJS.trigger("analytics", { name: 'issue.dnd.attachment.'+this.eventGroup+'.'+name, data: props || {} });
        }

    });

    return IssueDropZone;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:drag-and-drop-attachment-javascript-init', location = 'js/initIssueDropZone.js' */
require(['dndattachment/Parser',
        'jquery',
        'dndattachment/dropzones/IssueDropZone',
        'dndattachment/upload/handler',
        'dndattachment/upload/default/executor',
        'dndattachment/aui',
        'dndattachment/TemporaryAttachments',
        'dndattachment/util/Configuration',
        'dndattachment/util/FileSizeUtil'],
    function (Parser,
              $,
              IssueDropZone,
              uploadHandler,
              defaultUploadExecutor,
              AJS,
              Attachments,
              Config,
              FileSizeUtil) {
        if (!IssueDropZone.prototype.isSupportedBrowser()) {
            return;
        }

        var uploadLimit = Config.getWRM("upload-limit");
        var attachmentDropzone;

        function createDropZoneInContext($context, duiType) {
            var $fileInputList = $context.find('.field-group.file-input-list');

            if ($fileInputList.size() == 0) {
                return;
            }

            // skip if we already have dropzone there
            if ($fileInputList.find('*[duiType*="' + duiType + '"]').length > 0) {
                return;
            }

            var attachments = $fileInputList.find('input[name=filetoconvert]:checked').map(function (idx, el) {
                return Attachments.getAttachment(el.value, $(el).siblings('label').text());
            }).toArray();

            var description = $fileInputList.find('.description:last-child').html();

            // clear contents
            $fileInputList.empty();

            var $dropZone = $(JIRA.Templates.DnDAttachmentPlugin[duiType]({
                uploadLimit: FileSizeUtil.format(uploadLimit),
                jiraAttachmentSize: uploadLimit,
                description: description
            }));

            Parser.parse($dropZone.appendTo($fileInputList)).then(function (dropZone) {
                if (dropZone != null)
                    dropZone.loadAttachments(attachments);
            });
        }

        function createDropZoneInDialog(dialog, duiType) {
            var createDropZone = function () {
                createDropZoneInContext(dialog.$popupContent, duiType);
            };
            if (dialog.$popup && dialog.$popup.is(':visible')) {
                createDropZone();
            } else {
                dialog.onContentReady(createDropZone);
            }
        }

        function createAttachmentsDropZone($context) {
            var $attachmentModule = $context && ($context.attr("id") == "attachmentmodule") && $('.mod-content:not(.issue-drop-zone)', $context);

            if ($attachmentModule && $attachmentModule.size() > 0) {
                if ($context.find('#add-attachments-link').length == 0) {
                    // add attachment link is not there, means user don't have permissions
                    // This attachment link is hidden by this plugin and defined in JIRA
                    return;
                }

                $attachmentModule.addClass('issue-drop-zone');

                var $dropZone = $(JIRA.Templates.DnDAttachmentPlugin.AttachmentsDropZone({
                    uploadLimit: FileSizeUtil.format(uploadLimit),
                    jiraAttachmentSize: uploadLimit
                }));

                Parser.parse($dropZone.prependTo($attachmentModule)).then(function (dropZone) {
                    if (attachmentDropzone) {
                        attachmentDropzone.disconnectContainer();
                    }
                    attachmentDropzone = dropZone;
                    uploadHandler.setAttachmentDropZone(dropZone);
                });
            }
        }

        // Requiring Parser is enough to process all duiType declarations
        // besides that we need to install issue-drop-zone in attachFile and createIssue dialogs
        // each time when they become visible.
        // This is NOT supposed to inject drop zone everywhere.
        var onReady = function () {
            if (JIRA.Dialogs.attachFile) {
                createDropZoneInDialog(JIRA.Dialogs.attachFile, 'AttachFilesDropZone');
            }

            var triggerDialogs = ['create-issue-dialog', 'create-subtask-dialog', 'edit-issue-dialog'];

            var onDialogShow = function (event, $popupContent, dialog) {
                if (_.contains(triggerDialogs, $popupContent.attr('id'))) {
                    createDropZoneInDialog(dialog, 'CreateIssueDropZone');
                }
            };
            $(AJS).on('Dialog.show', onDialogShow);

            // just in case init file was loaded after Dialog.show event
            if (JIRA.Dialog.current) {
                onDialogShow(null, JIRA.Dialog.current.$popup, JIRA.Dialog.current);
            }

            JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
                createDropZoneInContext(context, 'CreateIssueDropZone');

                createAttachmentsDropZone(context);
            });

            var $createIssueForm = $('form#issue-create, form#issue-edit');
            if ($createIssueForm.size() > 0) {
                createDropZoneInContext($createIssueForm, 'CreateIssueDropZone');
            }

            uploadHandler.initialize();
            uploadHandler.registerExecutor(defaultUploadExecutor);
            createAttachmentsDropZone($('#attachmentmodule'));

            var DRAGOVER_CLASS = 'issue-drop-zone-document__dragover';

            $(document).on("dragover dragenter", function () {
                $('body').addClass(DRAGOVER_CLASS);
            });

            $(document).on("dragleave drop dropHandled", function () {
                $('body').removeClass(DRAGOVER_CLASS);
            });
        };

        if ($.isReady) {
            onReady();
        } else {
            AJS.$(onReady);
        }

        // we want dataTransfer property from originalEvent
        $.event.props.push("dataTransfer");
    });;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:soy-templates', location = 'viewissue/attachmentsblock.soy' */
// This file was automatically generated from attachmentsblock.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ViewIssue.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ViewIssue == 'undefined') { JIRA.Templates.ViewIssue = {}; }


JIRA.Templates.ViewIssue.renderAttachments = function(opt_data, opt_ignored) {
  return '' + ((opt_data.viewMode == 'list') ? JIRA.Templates.ViewIssue.fileAttachments(opt_data) : JIRA.Templates.ViewIssue.galleryAttachments(opt_data));
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.renderAttachments.soyTemplateName = 'JIRA.Templates.ViewIssue.renderAttachments';
}


JIRA.Templates.ViewIssue.fileAttachments = function(opt_data, opt_ignored) {
  var output = '<ol id="file_attachments" class="item-attachments" data-sort-key="' + soy.$$escapeHtml(opt_data.sortKey) + '" data-sort-order="' + soy.$$escapeHtml(opt_data.sortOrder) + '">';
  var fileAttachmentList14 = opt_data.attachments;
  var fileAttachmentListLen14 = fileAttachmentList14.length;
  for (var fileAttachmentIndex14 = 0; fileAttachmentIndex14 < fileAttachmentListLen14; fileAttachmentIndex14++) {
    var fileAttachmentData14 = fileAttachmentList14[fileAttachmentIndex14];
    output += JIRA.Templates.ViewIssue.fileAttachment(soy.$$augmentMap(opt_data, {fileAttachment: fileAttachmentData14}));
  }
  output += '</ol>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.fileAttachments.soyTemplateName = 'JIRA.Templates.ViewIssue.fileAttachments';
}


JIRA.Templates.ViewIssue.galleryAttachments = function(opt_data, opt_ignored) {
  var output = '<ol id="attachment_thumbnails" class="item-attachments" data-sort-key="' + soy.$$escapeHtml(opt_data.sortKey) + '" data-sort-order="' + soy.$$escapeHtml(opt_data.sortOrder) + '">';
  var imageAttachmentList25 = opt_data.attachments;
  var imageAttachmentListLen25 = imageAttachmentList25.length;
  for (var imageAttachmentIndex25 = 0; imageAttachmentIndex25 < imageAttachmentListLen25; imageAttachmentIndex25++) {
    var imageAttachmentData25 = imageAttachmentList25[imageAttachmentIndex25];
    output += JIRA.Templates.ViewIssue.imageAttachment(soy.$$augmentMap(opt_data, {imageAttachment: imageAttachmentData25}));
  }
  output += '</ol>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.galleryAttachments.soyTemplateName = 'JIRA.Templates.ViewIssue.galleryAttachments';
}


JIRA.Templates.ViewIssue.fileAttachment = function(opt_data, opt_ignored) {
  return '<li class="attachment-content js-file-attachment' + ((! opt_data.fileAttachment.latest) ? ' earlier-version' : '') + '" data-attachment-id="' + soy.$$escapeHtml(opt_data.fileAttachment.id) + '"' + JIRA.Templates.ViewIssue.renderAttachmentData({issue: opt_data.issue, attachment: opt_data.fileAttachment}) + '>' + ((opt_data.fileAttachment.expandable) ? JIRA.Templates.ViewIssue.zipFileAttachment(opt_data) : '<div class="attachment-thumb"><a href="' + soy.$$escapeHtml(opt_data.baseurl) + '/' + soy.$$escapeHtml('' + opt_data.fileAttachment.attachmentUrl) + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(opt_data.fileAttachment.mimeType) + ':' + soy.$$escapeHtml(opt_data.fileAttachment.fileName) + ':' + soy.$$escapeHtml(opt_data.fullBaseUrl) + '/' + soy.$$escapeHtml('' + opt_data.fileAttachment.attachmentUrl) + '"' + JIRA.Templates.ViewIssue.tagAttachment({attachment: opt_data.fileAttachment}) + '>' + JIRA.Templates.ViewIssue.renderAttachmentIcon(soy.$$augmentMap(opt_data, {mimetype: opt_data.fileAttachment.mimeType})) + '</a></div><dl>' + JIRA.Templates.ViewIssue.renderAttachmentInfo(soy.$$augmentMap(opt_data, {attachment: opt_data.fileAttachment})) + '</dl>') + '</li>';
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.fileAttachment.soyTemplateName = 'JIRA.Templates.ViewIssue.fileAttachment';
}


JIRA.Templates.ViewIssue.zipFileAttachment = function(opt_data, opt_ignored) {
  return '<div class="twixi-block collapsed expander"><div class="twixi-wrap verbose"><a href="#" class="twixi"><span class="icon-default aui-icon aui-icon-small aui-iconfont-expanded"><span>' + soy.$$escapeHtml("Hide") + '</span></span></a><div class="attachment-thumb"><a href="' + soy.$$escapeHtml(opt_data.baseurl) + '/' + soy.$$escapeHtml('' + opt_data.fileAttachment.attachmentUrl) + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(opt_data.fileAttachment.mimeType) + ':' + soy.$$escapeHtml(opt_data.fileAttachment.fileName) + ':' + soy.$$escapeHtml(opt_data.fullBaseUrl) + '/' + soy.$$escapeHtml('' + opt_data.fileAttachment.attachmentUrl) + '"' + JIRA.Templates.ViewIssue.tagAttachment({attachment: opt_data.fileAttachment}) + '>' + JIRA.Templates.ViewIssue.renderAttachmentIcon(soy.$$augmentMap(opt_data, {mimetype: opt_data.fileAttachment.mimeType})) + '</a></div><dl>' + JIRA.Templates.ViewIssue.renderAttachmentInfo(soy.$$augmentMap(opt_data, {attachment: opt_data.fileAttachment})) + '<dd class="zip-contents"><ol><li><div class="attachment-thumb"><img src="' + soy.$$escapeHtml(opt_data.baseurl) + '/images/icons/wait.gif" /></div>' + soy.$$escapeHtml("Extracting archive...") + '</li></ol></dd></dl></div><div class="twixi-wrap concise"><a href="#" class="twixi"><span class="icon-default aui-icon aui-icon-small aui-iconfont-collapsed"><span>' + soy.$$escapeHtml("Show") + '</span></span></a><div class="attachment-thumb"><a href="' + soy.$$escapeHtml(opt_data.baseurl) + '/' + soy.$$escapeHtml('' + opt_data.fileAttachment.attachmentUrl) + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(opt_data.fileAttachment.mimeType) + ':' + soy.$$escapeHtml(opt_data.fileAttachment.fileName) + ':' + soy.$$escapeHtml(opt_data.fullBaseUrl) + '/' + soy.$$escapeHtml('' + opt_data.fileAttachment.attachmentUrl) + '"' + JIRA.Templates.ViewIssue.tagAttachment({attachment: opt_data.fileAttachment}) + '>' + JIRA.Templates.ViewIssue.renderAttachmentIcon(soy.$$augmentMap(opt_data, {mimetype: opt_data.fileAttachment.mimeType})) + '</a></div><dl>' + JIRA.Templates.ViewIssue.renderAttachmentInfo(soy.$$augmentMap(opt_data, {attachment: opt_data.fileAttachment})) + '</dl></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.zipFileAttachment.soyTemplateName = 'JIRA.Templates.ViewIssue.zipFileAttachment';
}


JIRA.Templates.ViewIssue.imageAttachment = function(opt_data, opt_ignored) {
  return '<li class="attachment-content js-file-attachment" draggable="true" data-downloadurl="' + soy.$$escapeHtml(opt_data.imageAttachment.mimeType) + ':' + soy.$$escapeHtml(opt_data.imageAttachment.fileName) + ':' + soy.$$escapeHtml(opt_data.fullBaseUrl) + '/' + soy.$$escapeHtml('' + opt_data.imageAttachment.attachmentUrl) + '"' + JIRA.Templates.ViewIssue.renderAttachmentData({issue: opt_data.issue, attachment: opt_data.imageAttachment}) + '><div class="attachment-thumb"><a href="' + soy.$$escapeHtml(opt_data.baseurl) + '/' + soy.$$escapeHtml('' + opt_data.imageAttachment.attachmentUrl) + '" title="' + soy.$$escapeHtml(opt_data.imageAttachment.fileName) + ' -' + ((opt_data.imageAttachment.latest) ? ' ' + soy.$$escapeHtml("Latest") : '') + ' ' + soy.$$escapeHtml(opt_data.imageAttachment.createdDateTime) + ((opt_data.imageAttachment.authorDisplayName) ? ' - ' + soy.$$escapeHtml(opt_data.imageAttachment.authorDisplayName) : '') + '"' + JIRA.Templates.ViewIssue.tagAttachment({attachment: opt_data.imageAttachment}) + '>' + ((opt_data.imageAttachment.thumbnailUrl != null) ? '<img src="' + soy.$$escapeHtml('' + opt_data.imageAttachment.thumbnailUrl) + '" alt="' + soy.$$escapeHtml(opt_data.imageAttachment.fileName) + '" />' : JIRA.Templates.ViewIssue.renderThumbnailIcon({mimetype: opt_data.imageAttachment.mimeType})) + '</a></div><dl ' + ((! opt_data.imageAttachment.latest) ? 'class="earlier-version"' : '') + '><dt>' + ((opt_data.imageAttachment.deletable) ? '<span class="blender blender-delete"></span><div class="attachment-delete"><a title="' + soy.$$escapeHtml("Delete this attachment") + '" id="del_' + soy.$$escapeHtml(opt_data.imageAttachment.id) + '" href="' + soy.$$escapeHtml(opt_data.baseurl) + '/secure/DeleteAttachment!default.jspa?id=' + soy.$$escapeHtml(opt_data.issue.id) + '&deleteAttachmentId=' + soy.$$escapeHtml(opt_data.imageAttachment.id) + '&from=issue"><span class="icon-default aui-icon aui-icon-small aui-iconfont-delete">' + soy.$$escapeHtml("Delete this attachment") + '</span></a></div>' : '<span class="blender"></span>') + '<a  href="' + soy.$$escapeHtml(opt_data.baseurl) + '/' + soy.$$escapeHtml('' + opt_data.imageAttachment.attachmentUrl) + '" class="attachment-title" title="' + soy.$$escapeHtml(opt_data.imageAttachment.fileName) + ' -' + ((opt_data.imageAttachment.latest) ? ' ' + soy.$$escapeHtml("Latest") : '') + ' ' + soy.$$escapeHtml(opt_data.imageAttachment.createdDateTime) + ((opt_data.imageAttachment.authorDisplayName) ? ' - ' + soy.$$escapeHtml(opt_data.imageAttachment.authorDisplayName) : '') + '"' + JIRA.Templates.ViewIssue.tagAttachment({attachment: opt_data.imageAttachment}) + '>' + soy.$$escapeHtml(opt_data.imageAttachment.fileName) + '</a></dt><dd class="attachment-size">' + soy.$$escapeHtml(opt_data.imageAttachment.fileSize) + '</dd><dd class="attachment-date"><time class="livestamp" datetime="' + soy.$$escapeHtml('' + opt_data.imageAttachment.createdIso8601) + '">' + soy.$$escapeHtml(opt_data.imageAttachment.createdDateTime) + '</time></dd></dl></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.imageAttachment.soyTemplateName = 'JIRA.Templates.ViewIssue.imageAttachment';
}


JIRA.Templates.ViewIssue.renderAttachmentInfo = function(opt_data, opt_ignored) {
  return '<dt class="attachment-title"><a href="' + soy.$$escapeHtml(opt_data.baseurl) + '/' + soy.$$escapeHtml('' + opt_data.attachment.attachmentUrl) + '" title="' + ((opt_data.attachment.latest) ? soy.$$escapeHtml("Latest") + ' ' : '') + ' ' + soy.$$escapeHtml(opt_data.attachment.createdDateTime) + ((opt_data.attachment.authorDisplayName) ? ' - ' + soy.$$escapeHtml(opt_data.attachment.authorDisplayName) : '') + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(opt_data.attachment.mimeType) + ':' + soy.$$escapeHtml(opt_data.attachment.fileName) + ':' + soy.$$escapeHtml(opt_data.fullBaseUrl) + '/' + soy.$$escapeHtml('' + opt_data.attachment.attachmentUrl) + '"' + JIRA.Templates.ViewIssue.tagAttachment(opt_data) + '>' + soy.$$escapeHtml(opt_data.attachment.fileName) + '</a></dt><dd class="attachment-delete">' + ((opt_data.attachment.deletable) ? '<a title="' + soy.$$escapeHtml("Delete this attachment") + '" id="del_' + soy.$$escapeHtml(opt_data.attachment.id) + '" href="' + soy.$$escapeHtml(opt_data.baseurl) + '/secure/DeleteAttachment!default.jspa?id=' + soy.$$escapeHtml(opt_data.issue.id) + '&deleteAttachmentId=' + soy.$$escapeHtml(opt_data.attachment.id) + '&from=issue"><span class="icon-default aui-icon aui-icon-small aui-iconfont-delete">' + soy.$$escapeHtml("Delete this attachment") + '</span></a>' : '<span class="icon"></span>') + '</dd><dd class="attachment-date"><time class="livestamp" datetime="' + soy.$$escapeHtml('' + opt_data.attachment.createdIso8601) + '">' + soy.$$escapeHtml(opt_data.attachment.createdDateTime) + '</time></dd><dd class="attachment-size">' + soy.$$escapeHtml(opt_data.attachment.fileSize) + '</dd><dd class="attachment-author">' + soy.$$escapeHtml(opt_data.attachment.authorDisplayName ? opt_data.attachment.authorDisplayName : '') + '</dd>';
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.renderAttachmentInfo.soyTemplateName = 'JIRA.Templates.ViewIssue.renderAttachmentInfo';
}


JIRA.Templates.ViewIssue.renderAttachmentData = function(opt_data, opt_ignored) {
  return 'data-issue-id="' + soy.$$escapeHtml(opt_data.issue.id) + '"' + ((opt_data.attachment.expandable) ? 'data-attachment-type="expandable"' : (opt_data.attachment.thumbnailUrl != null) ? 'data-attachment-type="image"' : 'data-attachment-type="file"');
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.renderAttachmentData.soyTemplateName = 'JIRA.Templates.ViewIssue.renderAttachmentData';
}


JIRA.Templates.ViewIssue.renderAttachmentLegacyIcon = function(opt_data, opt_ignored) {
  var output = '';
  var fileIconUrl__soy284 = '' + JIRA.Templates.ViewIssue.matchFileIconUrl(opt_data);
  var fileIconAlt__soy286 = '' + JIRA.Templates.ViewIssue.matchFileIconAlt(opt_data);
  output += '<img src="' + soy.$$escapeHtml(fileIconUrl__soy284) + '" height="16" width="16" border="0" alt="' + soy.$$escapeHtml(fileIconAlt__soy286) + '">';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.renderAttachmentLegacyIcon.soyTemplateName = 'JIRA.Templates.ViewIssue.renderAttachmentLegacyIcon';
}


JIRA.Templates.ViewIssue.matchFileIconUrl = function(opt_data, opt_ignored) {
  return soy.$$escapeHtml(opt_data.baseurl) + '/images/icons/attach/' + JIRA.Templates.ViewIssue.matchFileIcon(opt_data);
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.matchFileIconUrl.soyTemplateName = 'JIRA.Templates.ViewIssue.matchFileIconUrl';
}


JIRA.Templates.ViewIssue.matchFileIcon = function(opt_data, opt_ignored) {
  var output = '';
  switch (opt_data.mimetype) {
    case 'application/pdf':
      output += 'pdf.gif';
      break;
    case 'image/gif':
      output += 'image.gif';
      break;
    case 'image/png':
      output += 'image.gif';
      break;
    case 'image/jpeg':
      output += 'image.gif';
      break;
    case 'text/xml':
      output += 'xml.gif';
      break;
    case 'text/html':
      output += 'html.gif';
      break;
    case 'text/plain':
      output += 'text.gif';
      break;
    case 'application/zip':
      output += 'zip.gif';
      break;
    case 'application/x-gzip-compressed':
      output += 'zip.gif';
      break;
    case 'application/msword':
      output += 'word.gif';
      break;
    case 'application/msword-template':
      output += 'word.gif';
      break;
    case 'application/vnd.ms-word.document.macroEnabled.12':
      output += 'word.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
      output += 'word.gif';
      break;
    case 'application/vnd.ms-word.template.macroEnabled.12':
      output += 'word.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.template':
      output += 'word.gif';
      break;
    case 'application/vnd.ms-excel':
      output += 'excel.gif';
      break;
    case 'application/vnd.ms-excel.addin.macroEnabled.12':
      output += 'excel.gif';
      break;
    case 'application/vnd.ms-excel.sheet.binary.macroEnabled.12':
      output += 'excel.gif';
      break;
    case 'application/vnd.ms-excel.sheet.macroEnabled.12':
      output += 'excel.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
      output += 'excel.gif';
      break;
    case 'application/vnd.ms-excel.template.macroEnabled.12':
      output += 'excel.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.template':
      output += 'excel.gif';
      break;
    case 'application/vnd.ms-powerpoint':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.ms-powerpoint.template.macroEnabled.12':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.template':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.ms-powerpoint.addin.macroEnabled.12':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.slideshow':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.ms-powerpoint.presentation.macroEnabled.12':
      output += 'powerpoint.gif';
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
      output += 'powerpoint.gif';
      break;
    case 'text/x-java':
      output += 'java.gif';
      break;
    case 'text/x-java-source':
      output += 'java.gif';
      break;
    case 'application/x-java-archive':
      output += 'java.gif';
      break;
    default:
      output += 'file.gif';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.matchFileIcon.soyTemplateName = 'JIRA.Templates.ViewIssue.matchFileIcon';
}


JIRA.Templates.ViewIssue.matchFileIconAlt = function(opt_data, opt_ignored) {
  var output = '';
  switch (opt_data.mimetype) {
    case 'application/pdf':
      output += soy.$$escapeHtml("PDF File");
      break;
    case 'image/gif':
      output += soy.$$escapeHtml("GIF File");
      break;
    case 'image/png':
      output += soy.$$escapeHtml("PNG File");
      break;
    case 'image/jpeg':
      output += soy.$$escapeHtml("JPEG File");
      break;
    case 'text/xml':
      output += soy.$$escapeHtml("XML File");
      break;
    case 'text/html':
      output += soy.$$escapeHtml("HTML File");
      break;
    case 'text/plain':
      output += soy.$$escapeHtml("Text File");
      break;
    case 'application/zip':
      output += soy.$$escapeHtml("Zip Archive");
      break;
    case 'application/x-gzip-compressed':
      output += soy.$$escapeHtml("GZip Archive");
      break;
    case 'application/msword':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/msword-template':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.openxmlformats':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-word.document.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-word.template.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.template':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-excel':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-excel':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-excel.addin.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-excel.sheet.binary.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-excel.sheet.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-excel.template.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.template':
      output += soy.$$escapeHtml("Microsoft Word");
      break;
    case 'application/vnd.ms-powerpoint':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.ms-powerpoint.template.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.template':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.ms-powerpoint.addin.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.slideshow':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.ms-powerpoint.presentation.macroEnabled.12':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
      output += soy.$$escapeHtml("Microsoft PowerPoint");
      break;
    case 'text/x-java':
      output += soy.$$escapeHtml("Java Source File");
      break;
    case 'text/x-java-source':
      output += soy.$$escapeHtml("Java Source File");
      break;
    case 'application/x-java-archive':
      output += soy.$$escapeHtml("Java Archive File");
      break;
    default:
      output += soy.$$escapeHtml("File");
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.matchFileIconAlt.soyTemplateName = 'JIRA.Templates.ViewIssue.matchFileIconAlt';
}


JIRA.Templates.ViewIssue.renderAttachmentIcon = function(opt_data, opt_ignored) {
  var output = '';
  var fileClass__soy442 = '' + JIRA.Templates.ViewIssue.matchFileClass(opt_data);
  var fileIconAlt__soy444 = '' + JIRA.Templates.ViewIssue.matchFileIconAlt(opt_data);
  output += '<span class="aui-icon aui-icon-small attachment-icon ' + soy.$$escapeHtml(fileClass__soy442) + '" title="' + soy.$$escapeHtml(fileIconAlt__soy444) + '"></span>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.renderAttachmentIcon.soyTemplateName = 'JIRA.Templates.ViewIssue.renderAttachmentIcon';
}


JIRA.Templates.ViewIssue.renderThumbnailIcon = function(opt_data, opt_ignored) {
  var output = '';
  var fileClass__soy452 = '' + JIRA.Templates.ViewIssue.matchFileClass(opt_data);
  output += '<span class="aui-icon aui-icon-large attachment-thumbnail-icon ' + soy.$$escapeHtml(fileClass__soy452) + '"></span>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.renderThumbnailIcon.soyTemplateName = 'JIRA.Templates.ViewIssue.renderThumbnailIcon';
}


JIRA.Templates.ViewIssue.matchFileClass = function(opt_data, opt_ignored) {
  var output = '';
  switch (opt_data.mimetype) {
    case 'application/pdf':
      output += 'aui-iconfont-file-pdf';
      break;
    case 'image/gif':
      output += 'aui-iconfont-image';
      break;
    case 'image/png':
      output += 'aui-iconfont-image';
      break;
    case 'image/jpeg':
      output += 'aui-iconfont-image';
      break;
    case 'text/xml':
      output += 'aui-iconfont-file-code';
      break;
    case 'text/html':
      output += 'aui-iconfont-file-code';
      break;
    case 'text/plain':
      output += 'aui-iconfont-file-txt';
      break;
    case 'application/zip':
      output += 'aui-iconfont-file-zip';
      break;
    case 'application/x-gzip-compressed':
      output += 'aui-iconfont-file-zip';
      break;
    case 'application/msword':
      output += 'aui-iconfont-file-doc';
      break;
    case 'application/msword-template':
      output += 'aui-iconfont-file-doc';
      break;
    case 'application/vnd.ms-word.document.macroEnabled.12':
      output += 'aui-iconfont-file-doc';
      break;
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
      output += 'aui-iconfont-file-doc';
      break;
    case 'application/vnd.ms-word.template.macroEnabled.12':
      output += 'aui-iconfont-file-doc';
      break;
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.template':
      output += 'aui-iconfont-file-doc';
      break;
    case 'application/vnd.ms-excel':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.ms-excel.addin.macroEnabled.12':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.ms-excel.sheet.binary.macroEnabled.12':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.ms-excel.sheet.macroEnabled.12':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.ms-excel.template.macroEnabled.12':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.template':
      output += 'aui-iconfont-file-xls';
      break;
    case 'application/vnd.ms-powerpoint':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.ms-powerpoint.template.macroEnabled.12':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.template':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.ms-powerpoint.addin.macroEnabled.12':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.slideshow':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.ms-powerpoint.presentation.macroEnabled.12':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
      output += 'aui-iconfont-file-ppt';
      break;
    case 'text/x-java':
      output += 'aui-iconfont-file-code';
      break;
    case 'text/x-java-source':
      output += 'aui-iconfont-file-code';
      break;
    case 'application/x-java-archive':
      output += 'aui-iconfont-file-zip';
      break;
    default:
      output += 'aui-iconfont-devtools-file';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.matchFileClass.soyTemplateName = 'JIRA.Templates.ViewIssue.matchFileClass';
}


JIRA.Templates.ViewIssue.tagAttachment = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ViewIssue.tagFilePreview({id: opt_data.attachment.id, title: opt_data.attachment.fileName, mimeType: opt_data.attachment.mimeType, isImage: opt_data.attachment.thumbnailUrl != null, thumbnailUrl: opt_data.attachment.thumbnailUrl});
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.tagAttachment.soyTemplateName = 'JIRA.Templates.ViewIssue.tagAttachment';
}


JIRA.Templates.ViewIssue.tagFilePreview = function(opt_data, opt_ignored) {
  var output = '';
  var previewType__soy535 = '' + ((opt_data.isImage || opt_data.mimeType != null && ('' + opt_data.mimeType).indexOf('image/') != -1) ? 'image' : (opt_data.mimeType == 'application/pdf') ? 'document' : 'unknown');
  output += (previewType__soy535 != 'unknown') ? ' file-preview-id="' + soy.$$escapeHtml(opt_data.id) + '" file-preview-title="' + soy.$$escapeHtml(opt_data.title) + '" file-preview-type="' + soy.$$escapeHtml(previewType__soy535) + '"' + ((opt_data.thumbnailUrl != null) ? 'file-preview-url="' + soy.$$escapeHtml('' + opt_data.thumbnailUrl) + '"' : '') : '';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.tagFilePreview.soyTemplateName = 'JIRA.Templates.ViewIssue.tagFilePreview';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone', location = 'js/dropzones/AttachmentsDropZone.js' */
define('dndattachment/dropzones/AttachmentsDropZone', [
        'dndattachment/dropzones/IssueDropZone',
        'jira/util/events',
        'dndattachment/util/events/types',
        'jquery',
        'dndattachment/util/DataTransfer',
        'featureflags/feature-manager',
        "dndattachment/ctrlv/utility",
        "jira/dialog/dialog"
    ],
    function (IssueDropZone,
              Events,
              EventTypes,
              $,
              DataTransfer,
              FeatureManager,
              Utility,
              JIRADialog) {

        var canonicalBaseUrl = (function () {
            var uri = parseUri(window.location);
            return uri.protocol + "://" + uri.authority;
        })();

        var AttachmentsDropZone = IssueDropZone.extend({
            eventGroup: 'attachmentsdropzone',
            progressBarType: 'dndattachment/progressbars/AttachmentsUploadProgressBar',

            init: function () {
                this._super.apply(this, arguments);

                this.attachFileUrl = contextPath + '/rest/jddap/1.0/attachment';
                Events.bind(JIRA.Events.PANEL_REFRESHED, this.panelRefreshed.bind(this));

                if (FeatureManager.isFeatureEnabled('jira.unified.attachments')) {
                    this.connectContainer();
                }

            },

            connectContainer: function() {
                this.$containerNode = this.getContainerNode();
                this.$dragoverDropzone = $(JIRA.Templates.DnDAttachmentPlugin.dropzone());
                this.$dragoverBorder = this.$dragoverDropzone.find(".attachments-drop-zone__dragover-border");
                this.$dragoverInfo = this.$dragoverDropzone.find(".attachments-drop-zone__dragover-info");
                this.$dragoverDropzone.appendTo(this.$containerNode);
                this.onDragOverDropHandler = this.onDragOverDrop.bind(this);
                this.onDragLeaveHandler = this.onDragLeave.bind(this);
                this.$containerNode.on('dragover dragenter drop', this.onDragOverDropHandler);
                this.$containerNode.on('dragleave', this.onDragLeaveHandler);

                this.$windowMask = $(JIRA.Templates.DnDAttachmentPlugin.windowDropzoneMask());
                this.$body = $(document.body);
                this.$body.append(this.$windowMask);
                this.$body.on('dragenter', _.throttle(this.onBodyDragEnter.bind(this), 200));
                this.$body.on('dragleave', this.onBodyDragLeave.bind(this));
                this.$windowMask.on('dragover dragenter', this.onWindowMaskDragEnter.bind(this));
                this.$windowMask.on('dragleave', this.onWindowMaskDragLeave.bind(this));
                this.$windowMask.on('drop', this.onWindowMaskDrop.bind(this));

                // Save the aui sidebar for easy access
                this.$auiSidebar = $(".aui-sidebar-body");

                // Disconnect the listeners
                this._disconnectListenersFromParentDropzone();

                this.onContentAddedHandler = this.onContentAdded.bind(this);
                Events.bind(JIRA.Events.NEW_CONTENT_ADDED, this.onContentAddedHandler);
            },

            _disconnectListenersFromParentDropzone: function() {
                // Remove the default event handlers from IssueDropZone since we are overriding it.
                this.$dropTarget.off('dragover drop dragleave dragenter');
                $(document).off('dragover dragenter');
            },

            disconnectContainer: function() {
                this.$dragoverDropzone.remove();
                this.$windowMask.remove();
                this.$body.removeClass('attachments-drop-zone__dragover');

                this.$body.off('dragenter', this.onBodyDragEnter.bind(this));
                this.$containerNode.off('dragenter dragover drop', this.onDragOverDropHandler);
                this.$containerNode.off('dragleave', this.onDragLeaveHandler);

                Events.unbind(JIRA.Events.NEW_CONTENT_ADDED, this.onContentAddedHandler);
            },

            isAttached: function() {
                return $.contains(document, this.$node[0]);
            },

            onContentAdded: function() {
                if(!this.isAttached()) {
                    this.disconnectContainer();
                }
            },

            getContainerNode: function() {
                var $node = $($(".issue-container")[0]);
                // In the case of the issue nav view, we need to modify the parent to have a relative position so that
                // our dragover border is positioned correctly as it's child.
                if ($node.css('position') === 'static') {
                    $node.css('position', 'relative');
                }
                return $node;
            },

            /**
             * We don't want to do a full page drag+drop if they are editing a field or have a dialog open.
             * This will change in the future (they will soon be allowed to drag+drop into wiki-renderable fields).
             * @returns {boolean}
             */
            canDoFullPageDrop: function() {
                if (!JIRADialog.current) {
                    JIRA.trace("jira.issue.dnd.dropallowed");
                    return true;
                } else {
                    JIRA.trace("jira.issue.dnd.dropnotallowed");
                    return false;
                }
            },

            onDragOverDrop: function(event) {
                if (!this.isAttached()) {
                    this.disconnectContainer();
                    return;
                }
                if (!Utility.dragEventContainsFiles(event)) {
                    return;
                }
                if (!this.canDoFullPageDrop()) {
                    return;
                }
                event.preventDefault();
                if (event.originalEvent) {
                    event.originalEvent.dataTransfer.dropEffect = "copy";
                }
                JIRA.trace('jira.issue.dnd.dragover');
                this.$body.addClass('attachments-drop-zone__dragover');
                this.$body.addClass("attachments-drop-zone__window-dragover");
                this.$containerNode.addClass("attachments-drop-zone__dragover-fade");

                this._readjustDropzone();
                this._repositionStickyInfoBox();
                if(event.type == 'drop') {
                    this.removeAllDragoverClasses(this.$containerNode);
                    $(document).trigger("dropHandled");

                    var dataTransfer = new DataTransfer(event.dataTransfer);
                    dataTransfer.getFiles().then(function(files) {
                        this.handleFilesReceived(files);
                        this.queueEvent('fileDrop', { count: files.length });
                    }.bind(this));
                }
            },

            onDragLeave: function() {
                this.removeAllDragoverClasses(this.$containerNode);
            },

            /**
             * If the side-bar is in fly-out mode it overlays over the issue, so we need to adjust the dropzone in that case
             */
            _readjustDropzone: function() {
                if (this.$auiSidebar.length !== 0) {
                    var sidebarWidth = this.$auiSidebar.offset().left + this.$auiSidebar.width();
                    // IE can encounter problems with the dragoverBorder's parent offset, so check it's defined.
                    if (this.$dragoverBorder.parent().offset()) {
                        var dropzoneParentLeft = this.$dragoverBorder.parent().offset().left;
                        if (sidebarWidth > dropzoneParentLeft) {
                            this.$dragoverBorder.css({left: sidebarWidth - dropzoneParentLeft});
                        } else {
                            this.$dragoverBorder.css({left: 0});
                        }
                    } else {
                        this.$dragoverBorder.css({left: 0});
                    }
                }
            },

            _repositionStickyInfoBox: function() {
                // dragover-info should always be visible, so we calculate its position based on
                // how much the user has scrolled down within the containerNode and whether the
                // scrollParent of the containerNode has an offset.
                var scroll = this.$containerNode.scrollParent().scrollTop() + 10;
                var nodeOffset = this.$containerNode.offset().top;
                // Calling .offset() on $(document) returns null, so make sure we handle that case properly
                var parentOffset;
                if (this.$containerNode.scrollParent().offset()) {
                    parentOffset = this.$containerNode.scrollParent().offset().top;
                } else {
                    parentOffset = 0;
                }

                var dragoverInfoTop;

                if(parentOffset === 0){
                    if(scroll >= nodeOffset){
                        dragoverInfoTop = scroll - nodeOffset;
                    }
                    else{
                        dragoverInfoTop = 10;
                    }
                }
                else{
                    dragoverInfoTop = scroll;
                }

                this.$dragoverInfo.css({top: dragoverInfoTop});
            },

            onBodyDragEnter: function(e) {
                if (!Utility.dragEventContainsFiles(e)) {
                    return;
                }
                this._readjustDropzone();
                this.$body.addClass("attachments-drop-zone__window-dragover");
            },

            onBodyDragLeave: function() {
                this.removeAllDragoverClasses();
            },

            onWindowMaskDragEnter: function(event) {
                if (!Utility.dragEventContainsFiles(event)) {
                    return;
                }
                event.preventDefault();
                if (event.originalEvent) {
                    event.originalEvent.dataTransfer.dropEffect = "none";
                }
                this._readjustDropzone();
                this.$body.addClass("attachments-drop-zone__window-dragover");
                if (this.canDoFullPageDrop()) {
                    this.$body.addClass("attachments-drop-zone__dragover");
                    this._repositionStickyInfoBox();
                }
            },

            onWindowMaskDragLeave: function() {
                this.removeAllDragoverClasses();
            },

            onWindowMaskDrop: function(event) {
                event.preventDefault();
                this.removeAllDragoverClasses();
            },

            removeAllDragoverClasses: function(fadeMask) {
                if (fadeMask) {
                    fadeMask.removeClass("attachments-drop-zone__dragover-fade")
                }
                this.$body.removeClass("attachments-drop-zone__window-dragover");
                this.$body.removeClass("attachments-drop-zone__dragover");
            },

            handleFilesReceived: function (files) {
                var wikiTextfield = $("textarea.wiki-textfield:visible:focus");
                var isWikiTextfieldFocused = wikiTextfield.length > 0;

                // Files that are received in the drop zone should commit them to the page using the event handler so
                // they are handled in the same way as other attachments that are committed directly to the page
                Events.trigger(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, {
                    files: files,
                    // If a wiki textfield is in focus we insert the markup.
                    // We want the attachment executor to know if a wiki textfield is in focus
                    // so that the executor can then decide whether it wants to perform its action.
                    isWikiTextfieldFocused: isWikiTextfieldFocused,
                    wikiTextfield: wikiTextfield[0]
                });
            },

            render: function () {
                this.$node.parents("#attachmentmodule").addClass('attachments-drop-zone-parent');
                this.$listNode = this.$node.siblings('#file_attachments, #attachment_thumbnails');

                return this._super.apply(this, arguments);
            },

            panelRefreshed: function (event, panel, $new, $existing) {
                // our drop zone was attached to refreshed panel, so we should reattach it and recover removed progress bars
                if (!$existing.find(this.$node).is('*')) {
                    return;
                }

                var oldViewMode = this.getViewMode();

                $new = $new.find('>.mod-content');
                $new.addClass('issue-drop-zone');
                this.$node.prependTo($new);
                this.render();

                var $existingProgressBars = $existing.find('.attachments-upload-progress-bar');

                $existingProgressBars.data("viewMode", this.getViewMode()).each(function (idx, progressBar) {
                    $(progressBar).prop("_instance").render();
                });

                $existingProgressBars.each(function (idx, progressBar) {
                    this.insertProgressBar($(progressBar));
                }.bind(this));

                if (FeatureManager.isFeatureEnabled('jira.unified.attachments')) {
                    // Disconnect the listeners since they get reattached
                    this._disconnectListenersFromParentDropzone();
                }
            },

            /**
             *
             * @returns {string} "list" or "gallery"
             */
            getViewMode: function () {
                return this.$listNode.attr("id") == "file_attachments" ? "list" : "gallery";
            },

            /**
             *
             * @returns {string} "fileName" or "dateTime"
             */
            getSortBy: function () {
                return this.$listNode.data("sort-key");
            },

            /**
             *
             * @returns {string} "desc" or "asc"
             */
            getSortOrder: function () {
                return this.$listNode.data("sort-order");
            },

            /**
             * Return sort comparator function that takes two nodes
             * @returns {Function}
             */
            getSortComparator: function () {
                var sortOrder = this.getSortOrder() == "asc" ? 1 : -1;
                var getSortValue = this.getSortBy() == "fileName" ? function ($node) {
                    return $node.find('.attachment-title').text();
                } : function ($node) {
                    return new Date($node.find('*[datetime]').attr("datetime")).getTime();
                };

                var compareFn = this.getSortBy() == "fileName" && String.prototype.localeCompare ?
                    function (left, right) {
                        return left.localeCompare(right);
                    } :
                    function (left, right) {
                        return left < right ? -1 : (left > right ? 1 : 0);
                    };

                return function ($nodeLeft, $nodeRight) {
                    var left = getSortValue($nodeLeft);
                    var right = getSortValue($nodeRight);
                    return sortOrder * compareFn(left, right);
                }
            },

            commitUpload: function (fileIDs) {
                var result = new $.Deferred();

                this.attachFile(fileIDs).then(result.resolve.bind(result), result.reject.bind(result));

                result.then(function (beans) {
                    var $beans = $(JIRA.Templates.ViewIssue.renderAttachments({
                        baseurl: contextPath,
                        fullBaseUrl: canonicalBaseUrl + contextPath,
                        issue: {id: JIRA.Issues.Api.getSelectedIssueId()},
                        attachments: beans,
                        viewMode: this.getViewMode()
                    })).find('.attachment-content');

                    beans.forEach(function (bean, idx) {
                        var beanNode = $beans[idx];
                        var $progressBar = this.$listNode.find('>*[data-file-id="' + fileIDs[idx] + '"]');
                        $progressBar.replaceWith(beanNode);
                    }, this);

                    JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [this.$listNode, JIRA.CONTENT_ADDED_REASON.panelRefreshed]);

                    JIRA.trace('jira.issue.dnd.attached');
                }.bind(this));

                this.queueTask(result);

                this.queueEvent('commitUpload', {count: fileIDs.length});

                return result;
            },

            configureUploadProgressBar: function ($progressBar) {
                this._super.apply(this, arguments);

                $progressBar.data("viewMode", this.getViewMode());
            },

            placeUploadProgressBar: function ($progressBar, progressBar) {
                progressBar.$node.find('time.livestamp').attr("datetime", new Date().toISOString()).livestamp();

                this.insertProgressBar($progressBar);

                progressBar.bind("onDestroy", function () {
                    var $itemAttachments = $progressBar.parents('.item-attachments');
                    if ($itemAttachments.find(".attachments-upload-progress-bar, .attachment-content").length == 0) {
                        $itemAttachments.remove();
                    }
                });

                return $progressBar;
            },

            /**
             * Insert given progressBar element on attachment list respecting sorting options
             * @param $progressBar
             */
            insertProgressBar: function ($progressBar) {
                var comparator = this.getSortComparator();

                var $children = this.$listNode.children().toArray();

                var isGreater = function (item) {
                    if (comparator($progressBar, $(item)) < 1) {
                        $progressBar.insertBefore(item);
                        return true;
                    }
                };

                if (!$children.some(isGreater)) {
                    $progressBar.appendTo(this.$listNode);
                }
            }

        });

        return AttachmentsDropZone;
    });;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone', location = 'js/progressbars/UploadProgressBar.js' */
define('dndattachment/progressbars/UploadProgressBar',
    ['jquery',
     'dndattachment/Parser',
     'dndattachment/JIRA',
     'dndattachment/aui',
     'dndattachment/i18n',
     'dndattachment/TemporaryAttachments',
     'dndattachment/util/Configuration',
     'dndattachment/util/FileSizeUtil',
     'featureflags/feature-manager'],
function($,
         Parser,
         JIRA,
         AJS,
         I18n,
         Attachments,
         Config,
         FileSizeUtil,
         FeatureManager
) {

    var ICONS = ['aui-iconfont-error', 'aui-iconfont-success', 'aui-iconfont-close-dialog'];

    function queueEvent(name, props) {
        AJS.trigger("analytics", { name: 'issue.dnd.attachment.uploadprogress.'+name, data: props || {} });
    }

    var thumbnailMimeTypes = Config.getWRM("thumbnail-mime-types").split(",");

    var UploadProgressBar = Class.extend({

        autoDestroy: true,

        init: function(element) {
            this.result = new $.Deferred();
            this.$node = $(element);
            this.file = this.$node.data("file");
            this.uploadSize = this.$node.data('upload-size');
            this.formToken = this.$node.data('form-token');

            this.$node.prop("_instance", this);

            this.render();
        },

        render: function() {
            this.$node.html(JIRA.Templates.DnDAttachmentPlugin.UploadProgressBar({isImageType: this.isImageType()}));

            this.afterRender();
        },

        afterRender: function() {
            if (this.file) {
                this.setFileName(this.file.name);
                this.setFileSize(this.file.size);
                this.loadThumbnail(this.file);
            }

            if (this.progress)
            {
                this.updateProgress();
            }

            this.connectListeners();
        },

        connectListeners: function() {
            this.getControlNode().on('click', function() {
                this.destroy();
                queueEvent('buttonClick');
            }.bind(this));
        },

        destroy: function () {
            if (this.destroyed) {
                return;
            }

            if(this.upload) {
                this.upload.abort();
            }

            this.setAutoDestroy(false);
            this.trigger('onBeforeDestroy');
            this.destroyed = true;
            this.$node.animate({ opacity: 0 }, {
                duration: 250,
                complete: function () {
                    this.$node.slideUp(250, function () {
                        if (this.objectURL)
                            window.URL.revokeObjectURL(this.objectURL);
                        this.$node.remove();
                        JIRA.trace('jira.issue.dnd.progressbar.removed');

                        this.trigger('onDestroy');
                    }.bind(this));
                }.bind(this)
            });
        },

        isDestroyed: function() {
            return !!this.destroyed;
        },

        setAutoDestroy: function(enabled) {
            this.autoDestroy = enabled;
        },

        getAutoDestroy: function() {
            return this.autoDestroy;
        },

        getUploadParams: function(file) {
            var uploadParams = {
                filename: file.name,
                size: file.size,
                atl_token: atl_token(),
                formToken: this.formToken
            };

            _.extend(uploadParams, this.getEntityParams());

            return uploadParams
        },

        /**
         * Return object with projectKey, projectId, issueKey and/or issueId
         */
        getEntityParams: function() {
            var entityParams = {};

            var issueId = JIRA.Issue.getIssueId();
            var projectId = this.$node.parents('form').find('*[name="pid"]').attr('value');

            // projectId has priority over issueId
            if(projectId) {
                entityParams.projectId = projectId;
            } else if(issueId) {
                entityParams.issueId = issueId;
            }

            return entityParams;
        },

        setFile: function(file) {
            this.file = file;
        },

        setFileID: function(id) {
            this.fileID = id;
            this.$node.attr("data-file-id", id);
        },

        getFileID: function() {
            return this.fileID;
        },

        setFileName: function(fileName) {
            this.$node.find('.upload-progress-bar__file-name').text(fileName);
        },

        getFileName: function() {
            return this.$node.find('.upload-progress-bar__file-name').text();
        },

        setFileSize: function(fileSize) {
            if(fileSize >= 0) {
                this.$node.find('.upload-progress-bar__file-size').html(FileSizeUtil.format(fileSize));
            }
        },

        uploadFile: function(file, uploadLimit) {
            this.setFile(file);

            var result = this.result;

            this.monitorUpload(result);
            result.fail(this.reportError.bind(this));

            if(file.size > uploadLimit) {
                result.reject(I18n("dnd.attachment.file.is.too.large").replace('{0}', this.uploadSize), true);
                return result;
            }

            var invalidChars = [ '\\', '/','"', ':','?', '*', '<','|','>' ];
            for (var i = 0; i < invalidChars.length; i++) {
                var invalidChar = invalidChars[i];
                if (_.contains(file.name, invalidChar)) {
                    result.reject(AJS.format("{0} contains the invalid character \'\'{1}\'\'. Please rename the file and try again.", file.name, invalidChar), true);
                    return result;
                }
            }

            this.upload = new AJS.InlineAttach.AjaxUpload({
                file: file,
                params: this.getUploadParams(file),
                url: AJS.InlineAttach.AjaxPresenter.DEFAULT_URL,
                progress: function(val) {
                    result.notify(val / file.size);
                },
                success: function(val, status) {
                    if(val.id !== undefined && val.name !== undefined) {
                        result.notify(1);
                        result.resolve(val, status, file);
                    } else
                        result.reject(val, status, file);
                },
                error: function(text, status) {
                    result.reject(I18n("dnd.attachment.internal.server.error"), status);
                },
                abort: function() {
                    result.reject(I18n("dnd.attachment.upload.aborted"), "abort");
                }
            });

            // check if current session is able to create attachments
            this.checkSession().then(function() {
                this.upload.upload();
            }.bind(this)).fail(function() {
                result.reject(I18n("dnd.attachment.unauthorized"), 401);
            });

            this.$node.find('.upload-progress-bar__control>*').on('click', function() {
                this.upload.abort();
                result.reject();
            }.bind(this));

            result.done(function(val) {
                Attachments.putAttachment(val.id, file);

                this.setFileID(val.id);
                JIRA.trace('jira.issue.dnd.uploaded');
            }.bind(this));

            return result;
        },

        monitorUpload: function(promise) {
            promise.progress(this.setProgress.bind(this));

            promise.done(this.setFinished.bind(this));

            promise.fail(this.setFailed.bind(this));
        },

        setProgress: function(state) {
            this.progress = state;

            this.updateProgress();
        },

        updateProgress: function() {
            var progressBar = this.$node.find('.upload-progress-bar__progress-bar');
            progressBar.toggleClass('UploadProgressBar_progressUnknown', this.progress === false);
            if(this.progress >= 0) {
                progressBar.find('.upload-progress-bar__bar').css('width', 100 * this.progress + '%');
            }
        },

        setFinished: function() {
            this.$node.addClass('upload-progress-bar__upload-finished');
            this.$node.find('.upload-progress-bar__control button .aui-icon')
                .addClass('aui-iconfont-success')
                .removeClass('aui-iconfont-close-dialog');
            this.finished = true;
            this.trigger("onFinished");
        },

        setFailed: function() {
            this.$node.addClass('UploadProgressBar_uploadFailed');
            this.finished = true;
            this.failed = true;
            this.trigger("onFailed");
        },

        isFinished: function() {
            return !!this.finished;
        },

        isFailed: function() {
            return !!this.failed;
        },

        isSuccessful: function() {
            return this.isFinished() && !this.isFailed();
        },

        isImageType: function() {
            return this.file && this.file.type && _.contains(thumbnailMimeTypes, this.file.type);
        },

        getThumbnailSrc: function(file) {
            if(this.isImageType()) {
                this.objectURL = window.URL.createObjectURL(file);
            }

            return this.objectURL || JIRA.Templates.ViewIssue.matchFileIconUrl({ baseurl: AJS.contextPath(), mimetype: file.type });
        },

        getThumbnailNode: function ()
        {
            return this.$node.find('.upload-progress-bar__thumbnail');
        },

        getControlNode: function () {
            return this.$node.find('.upload-progress-bar__control button');
        },

        loadThumbnail: function(file) {
            var imgSrc = this.getThumbnailSrc(file);

            var $thumbnailNode = this.getThumbnailNode();
            $thumbnailNode.addClass(this.objectURL ? 'upload-progress-bar__thumbnail_image' : 'upload-progress-bar__thumbnail_icon');

            var $thumbnail = $('<img/>').attr('src', imgSrc);

            return $thumbnail.appendTo($thumbnailNode);
        },

        unifiedAttachmentsM2FeatureEnabled: function() {
            return FeatureManager.isFeatureEnabled("jira.unified.attachments.m2");
        },

        reportError: function(message, status) {
            if(typeof message == "object" && message.errorMessage)
                message = message.errorMessage;

            this.$node.addClass('upload-progress-bar__upload-error');
            this.$node.removeClass('upload-progress-bar__upload-finished');
            this.$node.find('.upload-progress-bar__bar').css('width', '100%');
            this.showErrorMessage(message, status);
            this.setAutoDestroy(false);

            queueEvent('error', { message: message });
        },

        showErrorMessage: function(message) {
            this.$node.find('.upload-progress-bar__error-message').text(message);
        },

        setIcon: function(iconName) {
            var $icon = this.$node.find('.upload-progress-bar__control button .aui-icon');
            if(!ICONS.some(function(icon) {
                $icon.toggleClass(icon, icon == iconName);
                return icon == iconName;
            })) {
                throw "Unknown icon";
            }
        },
        
        checkSession: function() {
            var result = new $.Deferred();

            // auth session should just return 200, when user is logged in
            AJS.$.ajax({
                type: "GET",
                url: contextPath + "/rest/auth/1/session",
                contentType: "application/json"
            }).done(function() {
                // user is authorized
                result.resolve();
            }).fail(function() {
                // in case of user being not logged in, check explictly for CREATE_ATTACHMENT permissions
                this.checkPermissions().done(function(response) {
                    result.resolve();
                }).fail(function() {
                    result.reject();
                });
            }.bind(this));

            return result;
        },

        checkPermissions: function() {
            var result = new $.Deferred();

            AJS.$.ajax({
                type: "GET",
                url: contextPath + "/rest/api/2/mypermissions",
                contentType: "application/json",
                data: this.getEntityParams()
            }).done(function(response) {
                if(response.permissions["CREATE_ATTACHMENT"].havePermission) {
                    result.resolve();
                } else {
                    result.reject();
                }
            }).fail(function() {
                result.reject();
            });

            return result;
        }
    });

    return UploadProgressBar;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone', location = 'js/progressbars/AttachmentsUploadProgressBar.js' */
define('dndattachment/progressbars/AttachmentsUploadProgressBar',
  ['dndattachment/progressbars/UploadProgressBar',
   'jira/flag',
   'jquery',
   'dndattachment/i18n'],
  function(UploadProgressBar, flag, $, I18n) {
    function queueEvent(name, props) {
        AJS.trigger("analytics", { name: 'issue.dnd.attachment.attachmentsuploadprogress.'+name, data: props || {} });
    }

    return UploadProgressBar.extend({
        render: function() {
            this.$node.html(JIRA.Templates.DnDAttachmentPlugin.AttachmentsUploadProgressBar({ isImageType: this.isImageType() }))
                    .removeClass('upload-progress-bar')
                    .addClass('attachments-upload-progress-bar');

            this.$node.toggleClass('attachment-content', !this.isImageType());

            this.afterRender();
        },

        loadThumbnail: function(file) {
            if(this.$node.data("viewMode") == "gallery") {
                if(UploadProgressBar.prototype.isImageType.call(this)) {
                    return this._super.apply(this, arguments);
                } else {
                    return $(JIRA.Templates.ViewIssue.renderThumbnailIcon({ mimetype: file.type })).appendTo(this.getThumbnailNode());
                }
            } else {
                return $(JIRA.Templates.ViewIssue.renderAttachmentIcon({ mimetype: file.type })).appendTo(this.getThumbnailNode());
            }
        },

        showErrorMessage: function(message, status) {
            if(status == "abort") {
                // upload was aborted by hand, so we don't show flag
                return;
            }

            var errorFlag = flag.showErrorMsg(I18n("dnd.attachment.not.uploaded")(this.getFileName()), AJS.escapeHTML(message));
            $(errorFlag).on('aui-flag-close', function() {
                this.destroy();
            }.bind(this));

            this.bind('onDestroy', function() {
                errorFlag.close();
            });
        },

        isImageType: function() {
            return this.$node.data("viewMode") == "gallery";
        },

        getControlNode: function () {
            return this.$node.find('.upload-progress-bar__upload-control span');
        },

        getAutoDestroy: function() {
            return false;
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone', location = 'templates/IssueDropZone.soy' */
// This file was automatically generated from IssueDropZone.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.DnDAttachmentPlugin.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.DnDAttachmentPlugin == 'undefined') { JIRA.Templates.DnDAttachmentPlugin = {}; }


JIRA.Templates.DnDAttachmentPlugin.IssueDropZone = function(opt_data, opt_ignored) {
  return '<div class="issue-drop-zone__target"></div><span class="issue-drop-zone__text"><span class="issue-drop-zone__drop-icon"> </span> ' + soy.$$escapeHtml("Drop files to attach, or") + ' <button type="button" class="issue-drop-zone__button"> ' + soy.$$escapeHtml("browse") + '.</button><input class="issue-drop-zone__file ignore-inline-attach" type="file" multiple /></span>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.IssueDropZone.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.IssueDropZone';
}


JIRA.Templates.DnDAttachmentPlugin.AttachmentsDropZone = function(opt_data, opt_ignored) {
  return '<div duiType="dndattachment/dropzones/AttachmentsDropZone" class="issue-drop-zone" data-upload-limit="' + soy.$$escapeHtml(opt_data.jiraAttachmentSize) + '" data-upload-size="' + soy.$$escapeHtml(opt_data.uploadLimit) + '" data-upload-size="' + soy.$$escapeHtml(opt_data.uploadLimit) + '"></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.AttachmentsDropZone.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.AttachmentsDropZone';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone', location = 'templates/AttachmentsDropZone.soy' */
// This file was automatically generated from AttachmentsDropZone.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.DnDAttachmentPlugin.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.DnDAttachmentPlugin == 'undefined') { JIRA.Templates.DnDAttachmentPlugin = {}; }


JIRA.Templates.DnDAttachmentPlugin.dropzoneMask = function(opt_data, opt_ignored) {
  return '<span><div class="attachments-drop-zone__dragover-mask" /></span>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.dropzoneMask.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.dropzoneMask';
}


JIRA.Templates.DnDAttachmentPlugin.dropzone = function(opt_data, opt_ignored) {
  return '<span><div class="attachments-drop-zone__dragover-border"><div class="attachments-drop-zone__dragover-info"><p>' + soy.$$escapeHtml("Drop files to attach them to the issue") + '</p></div></div></span>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.dropzone.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.dropzone';
}


JIRA.Templates.DnDAttachmentPlugin.windowDropzoneMask = function(opt_data, opt_ignored) {
  return '<span><div class="attachments-drop-zone__window-dragover-mask" /></span>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.windowDropzoneMask.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.windowDropzoneMask';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone', location = 'templates/UploadProgressBar.soy' */
// This file was automatically generated from UploadProgressBar.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.DnDAttachmentPlugin.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.DnDAttachmentPlugin == 'undefined') { JIRA.Templates.DnDAttachmentPlugin = {}; }


JIRA.Templates.DnDAttachmentPlugin.UploadProgressBar = function(opt_data, opt_ignored) {
  return '<div class="upload-progress-bar__thumbnail"> </div><span class="upload-progress-bar__file-name"> </span><span class="upload-progress-bar__file-size"> </span><div class="upload-progress-bar__progress-bar"><span class="upload-progress-bar__bar"> </span></div><div class="upload-progress-bar__control"><button type="button" class="aui-button aui-button-subtle aui-button-compact"><span class="aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Cancel upload") + '</span></button></div><div class="upload-progress-bar__error-message"></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.UploadProgressBar.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.UploadProgressBar';
}


JIRA.Templates.DnDAttachmentPlugin.AttachmentsUploadProgressBar = function(opt_data, opt_ignored) {
  return '' + ((opt_data.isImageType) ? '<div class="upload-progress-bar__thumbnail"><div class="upload-progress-bar__progress-bar"><span class="upload-progress-bar__bar"> </span></div></div><dl><dt><span class="upload-progress-bar__file-name"> </span></dt><dd class="upload-progress-bar__file-size"> </dd><dd class="upload-progress-bar__upload-control"><span>' + soy.$$escapeHtml("Cancel") + '</span></dd><dd class="upload-progress-bar__error-message"></dd><dd class="attachment-date"><time class="livestamp" /></dd></dl>' : '<div class="attachment-thumb upload-progress-bar__thumbnail"></div><dl><dt class="attachment-title upload-progress-bar__file-name"></dt><dd class="upload-progress-bar__upload-control"><span>' + soy.$$escapeHtml("Cancel") + '</span></dd><dd class="attachment-size"><span class="upload-progress-bar__file-size"> </span><div class="upload-progress-bar__progress-bar"><span class="upload-progress-bar__bar"> </span></div></dd><dd class="attachment-author"> </dd><dd class="attachment-date"><time class="livestamp" /></dd></dl>');
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.AttachmentsUploadProgressBar.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.AttachmentsUploadProgressBar';
}


JIRA.Templates.DnDAttachmentPlugin.TempUploadProgressBar = function(opt_data, opt_ignored) {
  return '<div class="temp-upload-progress-bar__parent-container temp-upload-progress-bar__uploading"><div class="temp-upload-progress-bar__container"><div class="upload-progress-bar__thumbnail"/><div class="upload-progress-bar__progress-bar"><span class="upload-progress-bar__bar"> </span></div><div class="upload-progress-bar__error"><div class="upload-progress-bar__error-indicator"><span class="aui-icon aui-icon-large aui-iconfont-error">' + soy.$$escapeHtml("Upload error") + '</span></div><div class="upload-progress-bar__error-text">' + soy.$$escapeHtml("Upload failed") + '</div></div><div class="upload-progress-bar__upload-mask"/><div class="upload-progress-bar__control"><button type="button" class="aui-button aui-button-subtle aui-button-compact"><span class="aui-icon aui-icon-small aui-iconfont-close-dialog"><div class="button-text" aria-label="' + soy.$$escapeHtml("Cancel upload") + ' "></div><div class="file-name"></div><div class="error-message"></div></span></button></div><div class="upload-progress-bar__progress-bar"><span class="upload-progress-bar__bar"> </span></div></div><div class="upload-progress-bar_file-name-container"><span class="upload-progress-bar__file-name"></span></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.TempUploadProgressBar.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.TempUploadProgressBar';
}


JIRA.Templates.DnDAttachmentPlugin.SuccessMessageLink = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.issueLink) + '">' + soy.$$escapeHtml(opt_data.issueKey) + ' - ' + soy.$$escapeHtml(opt_data.issueSummary) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.DnDAttachmentPlugin.SuccessMessageLink.soyTemplateName = 'JIRA.Templates.DnDAttachmentPlugin.SuccessMessageLink';
}
;
;
/* module-key = 'com.atlassian.jira.plugin.system.comment-panel:expandablecomments', location = 'js/plugin/comment/comments-expanding.js' */
AJS.$(function($) {
    $(document).on('simpleClick', '.collapsed-comments', function(e) {
        e.preventDefault();

        var collapsedLink = $(this);
        var collapsedLinkBlock = collapsedLink.closest('.message-container');
        var container = collapsedLink.closest('.issuePanelContainer');
        var module = collapsedLink.closest('.module');
        var numCommentsBefore = collapsedLinkBlock.prevAll('.activity-comment').length;
        var numCollapsed = collapsedLink.find('.show-more-comments').data('collapsed-count');

        showLoading();
        makeRequest();

        function showLoading() {
            collapsedLink.find('.show-more-comments').text("Loading...");
        }

        function makeRequest() {
            var url = collapsedLink.attr('href');
            JIRA.SmartAjax.makeRequest({
                url: url,
                method: 'GET',
                headers: { "X-PJAX": true } // needed for the ViewIssue action to return only the activity panel
            }).done(showCollapsed);
        }

        function showCollapsed(html) {
            var commentsToShow = $(html).find('.activity-comment').slice(numCommentsBefore, numCommentsBefore + numCollapsed);
            collapsedLinkBlock.replaceWith(commentsToShow);
            JIRA.trace("jira.issue.comment.expanded");
            JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [module, JIRA.CONTENT_ADDED_REASON.panelRefreshed]);

            // Expand the twixi for the first comment
            container.find('.activity-comment:first').removeClass('collapsed').addClass('expanded');
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:lib', location = 'namespaces.js' */
JIRA.Components = JIRA.Components || {};
JIRA.Issues = JIRA.Issues || {};
JIRA.Events = JIRA.Events || {};
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-legacy', location = 'content/js/search/LegacyIssueNavigatorShortcuts.js' */
define('jira/issues/search/legacyissuenavigatorshortcuts', [
    'jira/issues/search/legacyissuenavigator',
    'jira/focus/set-focus',
    'jira/ajs/persistence',
    'jira/util/events',
    'jira/issue',
    'jira/message',
    'jquery'
], function (
    IssueNavigator,/** @todo TF-711 remove. */
    SetFocus,
    Persistence,
    Events,
    Issue,
    Messages,
    $
) {
    "use strict";

    /**
     * @deprecated should all be superceded by {@link JIRA.Issues.Api}.
     * @todo TF-711 remove entirely.
     * @exports jira/issuenavigator/issue-navigator/shortcuts
     * @namespace JIRA.IssueNavigator.Shortcuts
     */
    var contextPath = AJS.contextPath();
    var Shortcuts = {};

    Shortcuts._quickEditSessionCompleteHandler = function () {
        IssueNavigator.setIssueUpdatedMsg();
        IssueNavigator.reload();
    };

    Shortcuts._quickCreateSubtaskSessionCompleteHandler = function (e, issues) {
        var lastIssue = issues[issues.length - 1],
            msg = Issue.issueCreatedMessage(lastIssue, true);

        IssueNavigator.setIssueUpdatedMsg({
            issueMsg: msg
        });

        IssueNavigator.reload();
    };

    var $rows,
        index,
        $nextPage,
        $previousPage,
        helpText,
        isLoadingNewPage = false;

    var issueIdToRowIndex = {};

    $(document).ready(function () {

        // TODO NEXT-156 - isNavigator() checks if is the Issue-Search / 'single' issue view (instead of the project issue navigator)
        // TODO NEXT-156 - but the focus only 'sort of' works on a full page reload on a 'single' issue that has sub-tasks.
        if (IssueNavigator.isNavigator()) {

            var $focusedRow;
            var focusedClassName = /(?:^|\s)focused(?!\S)/;
            var preventFocus = function() {
                $(this).attr("tabIndex", -1);
            };

            // TODO NEXT-156 - $rows is filled when there are subtasks
            $rows = $('#issuetable').find('tr.issuerow');

            // TODO NEXT-156 - None of this code is excuted when we're in the issue-search when I click on another issue.
            $rows.each(function(i) {
                var $row = $(this);

                $('a.hidden-link', this).blur(preventFocus);

                // TODO NEXT-156 - $row contains subtasks - it doesn't satisfy the regex test. Hence index and $focusedRow is never set.
                if (!$focusedRow && focusedClassName.test(this.className)) {
                    $focusedRow = $row;
                    index = i;
                }

                issueIdToRowIndex[$row.attr("rel")] = i;
            });

            // TODO NEXT-156 - this is always the case (if there are no sub-tasks or even sub-tasks - refer above)
            if (!$focusedRow) {
                // This shouldn't ever be the case, but let's be defensive.
                $focusedRow = $rows.first().addClass("focused");
            }

            var jqlHasFocus = $("#jqltext").hasClass('focused');

            if (!jqlHasFocus) {
                var triggerConfig = new SetFocus.FocusConfiguration();
                triggerConfig.focusNow = function() {
                    focusRow(index);
                };
                SetFocus.pushConfiguration(triggerConfig);
            }

            // TODO NEXT-156 - this will trigger when you hit enter on the single 'issue' view. (maybe search 'issue')
            // This is basically a hard coded shortcut for "Enter".  It will trigger a issue view ...
            $(document).keypress(function (e) {
                if (e.keyCode === '13' && $('div.aui-blanket').length === 0){ // ... but not if a dialog is currently open.
                    var target = e.target;
                    // On different browser the originalTarget is different, but all of these are impossible for a user to trigger.
                    if (target === undefined || target.nodeName === "HTML" || target.nodeName === "BODY" || target === document){

                        // TODO NEXT-156 - the if statement below never gets executed because index is always undefined.
                        if (hasResults() && $rows[index]) {
                            // TODO NEXT-156 - this is suppose to do a re-direct to the sub-task/issue.
                            window.location = contextPath + '/browse/' + $rows.eq(index).data('issuekey');
                        }
                    }
                }
            });


            var $pager = $('div.pagination').first(),
                shouldFocusSearch = $("#focusSearch").attr("content") === "true";

            $nextPage = $pager.find('a.icon-next');
            $previousPage = $pager.find('a.icon-previous');

            /*
             * This is used to set the focus away from an input box if they are coming back from a previous search.
             * The server is setting the #focusSearch meta property to true if its a new search and hence the focus will auto go to the input box.
             * But if its not a new search then we want to blur away from the input box so that keyboard shortcuts work
             */
            if (!shouldFocusSearch) {
                var activeElement = $(document.activeElement);
                if (activeElement.is(":input")) {
                    activeElement.blur();
                }
            }


            if (hasResults() && !$(document.activeElement).is(":input")) {
                setTimeout(function () {
                    $rows.eq(index).scrollIntoView();
                }, 0);
            }

            $(".issue-actions-trigger").click(function(){
                var $row = $(this).closest("tr");
                var issueId = $row.attr("rel");
                if (issueId){
                    Shortcuts.focusRow(issueId, 0, true);
                }
            });

            // listen for subtask creation to publish success message. See jira-quick-edit plugin.
            Events.bind("QuickCreateSubtask.sessionComplete", Shortcuts._quickCreateSubtaskSessionCompleteHandler);

            // Listen to edit event to publish success message. See jira-quick-edit plugin.
            Events.bind("QuickEdit.sessionComplete", Shortcuts._quickEditSessionCompleteHandler);
        }
    });

    Shortcuts.selectNextIssue = function () {
        if (hasResults() && !isLoadingNewPage) {
            if (index === $rows.length - 1) {
                followLink($nextPage);
            } else {
                unselectRow(index++);
                selectRow(index);
            }
        }
    };

    Shortcuts.selectPreviousIssue = function () {
        if (hasResults() && !isLoadingNewPage) {
            if (index === 0) {
                followLink($previousPage);
            } else {
                unselectRow(index--);
                selectRow(index);
            }
        }
    };

    Shortcuts.viewSelectedIssue = function () {
        if (hasResults() && $($rows[index]).length) {
            try {
                window.location = contextPath + '/browse/' + $($rows[index]).data('issuekey');
            } catch(err) {
                //IE8 seems to throw an unspecified error here if there's a dirty form warning (see JRADEV-3307).  Catching and ignoring it!
            }
        }
    };

    /**
     * Called to focus the row on the first row or the specified row if issueId is specified
     * @param issueId an optional issueIf to focus on
     * @param delay the delay before triggering ajax issue selection
     * @param supressLinkFocus Do not focus on the first link in the row if this is true.
     */
    Shortcuts.focusRow = function (issueId, delay, supressLinkFocus) {
        if (hasResults()) {
            if (issueId) {
                selectRowViaIssueId(issueId, delay, supressLinkFocus);
            } else {
                if (!supressLinkFocus){
                    $($rows[index]).find('a:first').focus();
                }
            }
        }
    };



    Shortcuts.focusSearch = function () {
        var $jqlTextArea = $("#jqltext");
        // go to the top of the page
        $("#jira").scrollIntoView();
        if ($jqlTextArea.length > 0){
            $jqlTextArea.focus();
        } else {
            var $issuenav = $("#issuenav");
            if ($issuenav.hasClass("lhc-collapsed")){
                $(".toggle-lhc").click();
            }
            var $textSection = $("#navigator-filter-subheading-textsearch-group");
            if ($textSection.hasClass("collapsed")){
                $("#searcher-pid").focus();
            } else {
                $("#searcher-query").focus();
            }
        }
    };

    function hasResults() {
        return $rows && $rows.length > 0;
    }

    function followLink($a) {
        var href = $a.attr('href');
        if (href) {
            isLoadingNewPage = true;
            Persistence.nextPage("blurSearch", true);
            window.location = href;
            //if the new page hasn't loaded, re-enable shortcuts after 5 seconds (user may have pressed stop).
            //this may leave a small window where j & k don't work but there doesn't seem to be a way to detect
            //if the user pressed stop. (JRADEV-2872)
            setTimeout(function() { isLoadingNewPage = false; }, 5000);

        }
    }

    function unselectRow(i) {

        var $td = $($rows[i]).find('td:first');
        $($rows[i]).removeClass('focused');
        helpText = $td.attr('title');
        $td.removeAttr('title');
    }

    function selectRow(i, delay, supressLinkFocus) {
        var $selected = $($rows[i]).addClass('focused').scrollIntoView();
        $selected.find('td').first().attr('title', helpText);
        if (!supressLinkFocus){
            focusRow(i);
        }
    }

    function selectRowViaIssueId(issueId, delay, supressLinkFocus)
    {
        var newIndex = issueIdToRowIndex[issueId];
        if (newIndex || newIndex === 0) {
            unselectRow(index);
            selectRow(index = newIndex, delay, supressLinkFocus);
        }
    }

    // This is here so tab and enter work correctly while traversing the navigator list.
    function focusRow(i) {
        var $selected = $($rows[i]);
        $selected.find('.hidden-link')
            .removeAttr('tabIndex')
            .focus();
    }

    return Shortcuts;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-legacy', location = 'content/js/search/LegacyIssueNavigator.js' */
define('jira/issues/search/legacyissuenavigator', [
    'jira/data/session-storage',
    'jira/util/browser',
    'jquery'
], function(
    SessionStorage,
    Browser,
    jQuery
) {
    "use strict";

    /**
     * Represents an the Issue Navigator page.  This class should be used to retrieve information from the
     * issue navigator such as the currently selected row, currently selected issue key and so on.
     *
     * @deprecated should all be superceded by {@link JIRA.Issues.Api}.
     * @todo TF-711 remove entirely.
     * @exports jira/issuenavigator/issue-navigator
     * @namespace JIRA.IssueNavigator
     */
    var IssueNavigator = {
        /**
         * Checks if we are currently viewing the issue navigator.
         *
         * @return {Boolean} true if the current page is the issue navigator, false otherwise
         */
        isNavigator: function() {
            return jQuery("#isNavigator").length === 1;
        },

        /**
         * Sets a message to be displayed when the navigator has been reloaded
         *
         * @param {Object} [options={}]
         * @param {String} options.issueMsg
         * @param {String} options.issueId
         * @param {String} options.issueKey
         */
        setIssueUpdatedMsg: function (options) {

            options = options || {};

            var issueMsg = options.issueMsg,
                issueId = options.issueId,
                issueKey = options.issueKey;

            if (!issueId) {
                issueId = this.getSelectedIssueId();
                issueKey = this.getSelectedIssueKey();
            }

            if (issueId) {
                SessionStorage.setItem('selectedIssueId', issueId);
            }

            if (issueKey) {
                SessionStorage.setItem('selectedIssueKey', issueKey);
            }

            if (issueMsg) {
                SessionStorage.setItem('selectedIssueMsg', issueMsg);
            }
        },

        /**
         * Reloads the issue navigator
         */
        reload: function () {
            Browser.reloadViaWindowLocation();
        },

        /**
         * Checks if any row is currently selected on the issue navigator. This can be the case for
         * an empty searchr, or if keyboard shortcuts are disabled.
         *
         * @return {Boolean} true if a selected issue row exists, false otherwise
         */
        isRowSelected: function() {
            return IssueNavigator.get$focusedRow().length !== 0;
        },

        /**
         * Returns a jQuery wrapped object representing the currently selected issue row.
         * TODO NEXT-156 - Remove this after confirming it is unused
         *
         * @return {jQuery} the jQuery wrapped issue row representing the currently selected row
         */
        get$focusedRow: function() {
            return jQuery("#issuetable tr.issuerow.focused");
        },

        /**
         * Gets the index of the focused issue.
         * TODO NEXT-156 - Remove this after confirming it is unused
         *
         * @return {Number} - The index of the focused issue in the current search result set.
         */
        getFocsuedIssueIndex: function() {
            var rowIndex = jQuery("#issuetable").find("tr.issuerow").index(this.get$focusedRow());
            var searchOffset = parseInt(jQuery('.results-count-start').first().text(), 10) - 1;
            return rowIndex + searchOffset;
        },

        /**
         * Returns the issue key for the currently selected row.
         *
         * @return {String} The issue key for the currently focused row or undefined if none exists.
         */
        getSelectedIssueKey: function() {
            var $focusedRow = IssueNavigator.get$focusedRow();
            if ($focusedRow.length !== 0) {
                return $focusedRow.attr("data-issuekey");
            }
            return undefined;
        },

        /**
         * Returns the issue id for the currently selected row.
         *
         * @return {String} The issue id for the currently focused row or undefined if none exists.
         */
        getSelectedIssueId: function() {
            return IssueNavigator.get$focusedRow().attr("rel");
        },

        /**
         * Returns the issue id for the next row after the currently selected row.
         *
         * Note: It is a known issue that no id will be returned when the last issue on the page is
         * focused. In future, the return value in this situation may change.
         * TODO NEXT-156 - Remove this after confirming it is unused
         *
         * @return {String} The issue id for the next issue after the currently focused row or undefined if none exists.
         */
        getNextIssueId: function() {
            return IssueNavigator.get$focusedRow().next("tr.issuerow").attr("rel");
        }
    };

    return IssueNavigator;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-legacy', location = 'content/js/search/LegacyIssue.js' */
define('jira/issues/search/legacyissue', [
    'jira/util/browser',
    'jira/util/events',
    'jquery',
    'wrm/context-path'
], function(
    Browser,
    Events,
    jQuery,
    contextPath
) {
    "use strict";

    /**
     * Represents the View Issue page.  This class should be used to get the current issue key
     * and any other issue centric information!
     *
     * @deprecated should all be superceded by {@link JIRA.Issues.Api}.
     * @todo TF-711 remove entirely.
     * @exports jira/issue
     * @namespace JIRA.Issue
     */
    var Issue = {};
    var $keyVal;

    //private function to cache the key value.
    function getKeyVal() {
        if(!$keyVal) {
            $keyVal = jQuery("#key-val");
        }
        return $keyVal;
    }

    /**
     * @return {jQuery}
     */
    Issue.getStalker = function () {
        return jQuery("#stalker");
    };

    /**
     * Gets subtask contents
     * @return {jQuery}
     */
    Issue.getSubtaskContent = function () {
        return Issue.getSubtaskModule().find(".mod-content");
    };

    /**
     * Gets subtask module
     */
    Issue.getSubtaskModule = function () {
        return jQuery("#view-subtasks");
    };

    /**
     * Reloads View Issue screen
     */
    Issue.reload = function () {
        Browser.reloadViaWindowLocation();
    };

    /**
     * Goes back to the server to get updates content, if there is any.
     *
     * @return jQuery.promise
     */
    Issue.refreshSubtasks = function () {

        var deferred = new jQuery.Deferred(),
            $subtasks = Issue.getSubtaskContent();

        if ($subtasks.length === 0) {
            Browser.reloadViaWindowLocation(window.location.href + "#view-subtasks");
            return deferred.promise();
        } else {
            return jQuery.ajax({
                url: contextPath + "/secure/ViewSubtasks.jspa?id=" + Issue.getIssueId(),
                success: function (html) {
                    $subtasks.replaceWith(html);
                    Events.trigger("Issue.subtasksRefreshed", [Issue.getSubtaskContent()]);
                }
            });
        }
    };

    /**
     * Highlights specified issues
     *
     * @param issues
     */
    Issue.highlightSubtasks = function (issues) {
        jQuery.each(issues, function (i, issue) {
            jQuery(".issuerow[data-issuekey='" + issue.issueKey + "']").fadeInBackground();
        });
    };

    /**
     * Returns the issue id of the current issue being viewed.
     *
     * @return {String} the issue id or undefined if none can be found.
     */
    Issue.getIssueId = function() {
        var $keyVal = getKeyVal();
        if($keyVal.length !== 0) {
            return $keyVal.attr("rel");
        }
        return undefined;
    };

    /**
     * Returns the issue key of the current issue being viewed.
     *
     * @return {String} the issue key or undefined if none can be found.
     */
    Issue.getIssueKey = function() {
        var $keyVal = getKeyVal();
        if($keyVal.length !== 0) {
            return $keyVal.text();
        }
        return undefined;
    };

    /**
     * Gets I18N message for a created issue.
     *
     * @param issue issue to get message for
     * @param isSubtask whether the created issue is a subtask
     * @return {String} the issue created message according to the given data
     */
    Issue.issueCreatedMessage = function(issue, isSubtask) {
        var issueText = isSubtask ? "Subtask" : "Issue";
        var link = '<a class="issue-created-key issue-link" data-issue-key="' + issue.issueKey + '" href="' + contextPath() + '/browse/' + issue.issueKey + '">'
            + issue.issueKey + ' - ' + AJS.escapeHtml(issue.summary) + '</a>';
        return AJS.format("{0} {1} has been successfully created.", issueText, link);
    };

    return Issue;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issues-api', location = 'content/js/search/IssuesApi.js' */
(function() {
    "use strict";

    /**
     * The JIRA issues API.
     *
     * @type {object}
     */
    var issuesApi = (function() {
        var searchPageModule;

        return {
            /**
             * Initialize the API.
             *
             * @param {object} options
             * @param {SearchPageModule} options.searchPageModule
             */
            initialize: function(options) {
                searchPageModule = options.searchPageModule;
            },

            /**
             * Initiate editing the value of a field on the selected issue.
             *
             * It's not always possible for the user to edit a field, for example if the issue is currently not editable, or
             * if the user doesn't have the correct permissions.
             *
             * For visible fields inline editing is used. For hidden fields, a modal dialog is used.
             *
             * @param fieldId the ID of the field to edit
             * @return {boolean} true if the field editing did/will happen, otherwise false.
             */
            editFieldOnSelectedIssue: function(fieldId) {
                var fields = JIRA.Issues.Api.getFieldsOnSelectedIssue();
                var field = fields && fields.get(fieldId);
                var permitted = field && field.isEditable();

                if (permitted && searchPageModule) {
                    JIRA.Issues.Application.execute("issueEditor:editField", field);
                }

                return permitted;
            },

            /**
             * Focus the search controls.
             * <p/>
             * In basic mode, the project criteria; in advanced mode, the JQL input.
             */
            focusSearch: function() {
                AJS.$(".criteria-selector:first, #advanced-search").focus().select();
            },

            /**
             * @return {JIRA.Issues.SimpleIssue} the currently selected issue.
             */
            getSelectedIssue: function() {
                return searchPageModule.getEffectiveIssue();
            },

            /**
             * @return {null|number} the ID of the selected issue or null.
             */
            getSelectedIssueId: function() {
                return searchPageModule.getEffectiveIssueId();
            },

            /**
             * @return {null|string} the key of the selected issue or <tt>null</tt>.
             */
            getSelectedIssueKey: function() {
                return searchPageModule.getEffectiveIssueKey();
            },

            /**
             * Returns the fields on the selected issue.
             *
             * @return {undefined|Backbone.Collection} collection of {JIRA.Components.IssueEditor.Models.Field} objects
             */
            getFieldsOnSelectedIssue: function() {
                var fields = JIRA.Issues.Application.request("issueEditor:fields");
                return fields.length ? fields : undefined;
            },

            /**
             * @return {boolean} whether there are saves in progress.
             */
            hasSavesInProgress: function() {
                return JIRA.Issues.Application.request("issueEditor:hasSavesInProgress");
            },

            /**
             * @return {boolean} whether an issue is currently being loaded.
             */
            isCurrentlyLoadingIssue: function() {
                return searchPageModule.isCurrentlyLoadingIssue();
            },

            /**
             * @return {boolean|null} whether the selected issue can be opened, or <tt>null</tt> if no issue is selected.
             */
            isSelectedIssueAccessible: function() {
                return searchPageModule.isHighlightedIssueAccessible();
            },

            /**
             * @return {boolean} whether an issue is visible.
             */
            issueIsVisible: function() {
                return searchPageModule.isIssueVisible();
            },

            /**
             * Select the next issue.
             * <p/>
             * When in issue search, the next issue is highlighted; when viewing an
             * issue, the next one is loaded. No-op if an overlay is visible.
             */
            nextIssue: function() {
                searchPageModule.nextIssue();
            },

            /**
             * Open the focus shifter.
             */
            openFocusShifter: function() {
                if (searchPageModule.isIssueVisible()) {
                    searchPageModule.openFocusShifter();
                }
            },

            /**
             * Select the previous issue.
             * <p/>
             * When in issue search, the previous issue is highlighted; when viewing
             * an issue, the previous one is loaded. No-op if an overlay is visible.
             */
            prevIssue: function() {
                searchPageModule.prevIssue();
            },

            /**
             * Refresh the content of the selected issue, by merging changes from the server.
             *
             * @param {object} [options] Extra options to include in the internal triggerRefreshIssue() call
             * @returns {jQuery.Promise}
             *
             * The returned promise is:
             * - resolved when the selected issue is refreshed, or if there is no selected issue
             * - rejected *only* when refreshing the selected issue fails
             */
            refreshSelectedIssue: function(options) {
                return JIRA.Issues.Application.request("issueEditor:refreshIssue", options);
            },

            /**
             * Return to issue search.
             * <p/>
             * If a form is dirty, we ask the user to confirm navigation.
             *
             * @param {boolean} ignoreDirtiness Whether we should ignore dirtiness
             *     (used, for example, to force return after deleting an issue).
             */
            returnToSearch: function(ignoreDirtiness) {
                searchPageModule.returnToSearch({
                    ignoreDirtiness: ignoreDirtiness
                });
            },

            /**
             * @param {Object|null} issueProps - if null/undefined, use currently selected issue
             */
            showInlineIssueLoadError: function(issueProps) {
                searchPageModule.showInlineIssueLoadError(issueProps);
            },

            /**
             * Switch to the next search layout.
             * <p/>
             * We cycle through layouts in the order they appear in the layout switcher.
             */
            switchLayouts: function(options) {
                var currentIndex = -1;
                var currentLayout = searchPageModule.getCurrentLayout();
                var layouts = searchPageModule.getSortedLayouts();
                var newLayout;

                _.find(layouts, function(layout, index) {
                    if (currentLayout instanceof layout.View) {
                        currentIndex = index;
                        return true;
                    }
                });

                newLayout = layouts[(currentIndex + 1) % layouts.length];

                if (!newLayout) {
                    return;
                } else if (newLayout.id === 'split-view') {
                    require('jira/issues/views/details/metrics').start();
                } else if (newLayout.id === 'list-view') {
                    require('jira/issues/navigator/metrics').notifyIssueNavList();
                }

                searchPageModule.changeLayout(newLayout.id, options);
            },

            /**
             * Return if the current query is valid.
             * @returns {boolean}
             */
            isQueryValid: function() {
                return searchPageModule.queryModule.isQueryValid();
            },

            /**
             * @returns {*|boolean}
             */
            isFullScreenIssueVisible: function() {
                return searchPageModule.isFullScreenIssueVisible();
            },

            /**
             * View the issue that is currently highlighted in the issue table.
             */
            viewSelectedIssue: function() {
                if (!JIRA.Issues.Api.isSelectedIssueAccessible()) return;

                var issueKey = JIRA.Issues.Api.getSelectedIssueKey();

                if (!searchPageModule.isIssueVisible()) {
                    searchPageModule.update({
                        selectedIssueKey: issueKey
                    });
                }
            },

            /**
             * Undocks/Docks filter panel
             */
            toggleFilterPanel: function() {
                searchPageModule.toggleFilterPanel();
            },

            /**
             * Returns a deferred that is resolved once all inline edits are complete.
             * Or straight away if you have no inline edits pending.
             *
             * @return jQuery.Deferred
             */
            waitForSavesToComplete: function() {
                var d = new jQuery.Deferred();
                window.setTimeout(function() {
                    if (!JIRA.Issues.Api.hasSavesInProgress()) {
                        d.resolve();
                    } else {
                        JIRA.bind(JIRA.Events.INLINE_EDIT_SAVE_COMPLETE, function() {
                            if (!JIRA.Issues.Api.hasSavesInProgress()) {
                                d.resolve();
                            }
                        });
                    }
                }, 10);
            },

            updateIssue: function(issue, message) {
                message = message || "thanks_issue_updated";

                return searchPageModule.updateIssue({
                    key: issue.key,
                    id: issue.id,
                    action: JIRA.Issues.Actions.UPDATE,
                    message: message,
                    meta: {}
                });
            },

            toggleFullscreenIssue: function() {
                if(searchPageModule.isFullScreenIssueVisible()) {
                    if(!searchPageModule.standalone) {
                        searchPageModule.returnToSearch();
                    }
                } else {
                    var options = searchPageModule.isSplitViewLayout() ? {reset: true} : {};

                    JIRA.Issues.Application.execute("navigation:navigate", {
                        selectedIssueKey: searchPageModule.getEffectiveIssueKey()
                    }, options);
                }
            }
        };
    })();

    AJS.namespace('JIRA.Issues.Api', null, issuesApi);

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issues-api', location = 'content/js/search/IssueAPI.js' */
(function() {
    "use strict";

    /**
     * The JIRA issue API.
     * TODO TF-711 Dismantle the old JIRA.Issue object.
     *
     * @type {object}
     */
    JIRA.Issues.IssueAPI = (function() {
        var patch = {
            /**
             * @return {null|string} the currently selected issue's ID or
             *     <tt>null</tt> if no issue is selected.
             */
            getIssueId: function() {
                return JIRA.Issues.Api.getSelectedIssueId();
            },

            /**
             * @return {null|string} the currently selected issue's key or
             *     <tt>null</tt> if no issue is selected.
             */
            getIssueKey: function() {
                return JIRA.Issues.Api.getSelectedIssueKey();
            }
        };

        return {
            /**
             * Patch the <tt>JIRA.Issue</tt> API with the above methods.
             *
             * @param {object} options
             */
            override: function(options) {
                // We override the target in tests.
                options = _.defaults({}, options, {
                    target: JIRA.Issue
                });

                _.extend(options.target, patch);
            }
        };
    })();
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issues-api', location = 'content/js/search/IssueNavigatorAPI.js' */
(function() {
    "use strict";

    /**
     * Overrides for the <tt>JIRA.IssueNavigator</tt> API.
     * TODO TF-711 Dismantle the old JIRA.IssueNavigator object.
     * TODO NEXT-156 Remove this file after removing JIRA's dependency.
     *
     * @type {object}
     */
    JIRA.Issues.IssueNavigatorAPI = (function() {
        var IssueNavigatorMixin = {
            /**
             * @return {Boolean} whether issue search is visible.
             */
            isNavigator: function() {
                return JIRA.Issues.Api.issueIsVisible();
            }
        };

        var IssueNavigatorShortcutsMixin = {
            focusSearch: JIRA.Issues.Api.focusSearch,
            isNavigator: IssueNavigatorMixin.isNavigator,
            selectNextIssue: JIRA.Issues.Api.nextIssue,
            selectPreviousIssue: JIRA.Issues.Api.prevIssue,
            viewSelectedIssue: JIRA.Issues.Api.viewSelectedIssue
        };

        return {
            /**
             * Override the <tt>JIRA.IssueNavigator</tt> API with the above mixins.
             */
            override: function() {

                JIRA.IssueNavigator = _.extend(JIRA.IssueNavigator, IssueNavigatorMixin);
                JIRA.IssueNavigator.Shortcuts = _.extend(JIRA.IssueNavigator.Shortcuts,
                    IssueNavigatorShortcutsMixin);
            }
        };
    })();
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issues-api', location = 'content/js/search/LayoutPreferenceManager.js' */
(function() {
    "use strict";

    /**
     * Manages getting/setting the user's preferred layout preference.
     */
    JIRA.Issues.LayoutPreferenceManager = {
        PREFERRED_LAYOUT_KEY: "jira.issues.preferred.layout.key",

        /**
         * @return {string} The key of the current user's preferred layout.
         */
        getPreferredLayoutKey: function() {
            return AJS.Meta.get(this.PREFERRED_LAYOUT_KEY);
        },

        /**
         * @param {string} layoutKey The key of the current user's preferred layout.
         * @param {object} [options]
         * @param {object} [options.ajax=true] Whether to post the user's preferred layout to the server.
         * @param {object} [options.render]
         */
        setPreferredLayoutKey: function(layoutKey, options) {
            options = _.defaults({}, options, {
                ajax: true
            });

            AJS.Meta.set(this.PREFERRED_LAYOUT_KEY, layoutKey);
            if (options.ajax) {
                AJS.$.ajax({
                    data: {
                        layoutKey: layoutKey
                    },
                    type: "POST",
                    headers: JIRA.Issues.XsrfTokenHeader,
                    url: AJS.contextPath() + "/rest/issueNav/latest/preferredSearchLayout"
                });
            }
        }
    };
}());
;
;
/* module-key = 'com.atlassian.jira.jira-project-config-plugin:custom-fields', location = 'customfields/js/util/IssuesApi.js' */
/**
 *  This is module exists only to provide AMD module for JIRA.Issues.Api.
 *  It should be removed as soon as there will be one provided by issue-nav-plugin.
 */
define("jira-project-config/issues/api", function() {
    return JIRA &&
        JIRA.Issues &&
        JIRA.Issues.Api;
});
;
;
/* module-key = 'com.atlassian.jira.jira-project-config-plugin:custom-fields', location = 'customfields/js/main.js' */
require([
    'wrm/require',
    'jquery'
], function(
    wrmRequire,
    $
) {
    var loadApi = function (callback) {
        wrmRequire(["wrc!com.atlassian.jira.jira-project-config-plugin.custom-fields-impl"], function () {
            require(['jira-project-config/custom-fields/api'], callback);
        });
    };

    // Adding a custom field from the View Issue page.
    $(document).on("click", ".issueaction-fields-add", function (event) {
        event.preventDefault();
        var issue = JIRA.Issues.Api.getSelectedIssueId();

        loadApi(function(api) {
            api.addCustomFieldToIssue(issue);
        });
    });
});
;
;
/* module-key = 'jira.webresources:calendar', location = '/includes/lib/calendar/Calendar.js' */
/*  Copyright Mihai Bazon, 2002-2005  |  www.bazon.net/mishoo
 * -----------------------------------------------------------
 *
 * The DHTML Calendar, version 1.0 "It is happening again"
 *
 * Details and latest version at:
 * www.dynarch.com/projects/calendar
 *
 * This script is developed by Dynarch.com.  Visit us at www.dynarch.com.
 *
 * This script is distributed under the GNU Lesser General Public License.
 * Read the entire license text here: http://www.gnu.org/licenses/lgpl.html
 */

// NOTE: we have modified calendar-ko.js to resolve JRA-7729, we added the month character to the
// Calendar._SMN (short month names) array values, this is what java expects
//
// NOTE: there is a further modification to resolve JRA-8703, we added the Calendar._SMN (short month names) and
// Calendar._SDN (short week names) to the calendar-nl.js.
//
// $Id: calendar.js,v 1.4 2006/10/20 04:34:05 jkoke Exp $

/** The Calendar object constructor. */
Calendar = function (firstDayOfWeek, dateStr, todayDateStr, onSelected, onClose) {
	// member variables
	this.activeDiv = null;
	this.currentDateEl = null;
	this.getDateStatus = null;
	this.getDateToolTip = null;
	this.getDateText = null;
	this.timeout = null;
	this.onSelected = onSelected || null;
	this.onClose = onClose || null;
	this.dragging = false;
	this.hidden = false;
	this.minYear = 1970;
	this.maxYear = 2050;
	this.dateFormat = Calendar._TT["DEF_DATE_FORMAT"];
	this.ttDateFormat = Calendar._TT["TT_DATE_FORMAT"];
	this.isPopup = true;
    this.weekNumbers = true;

    this.firstDayOfWeek = typeof firstDayOfWeek == "number" ? firstDayOfWeek : Calendar._FD; // 0 for Sunday, 1 for Monday, etc.
	this.showsOtherMonths = false;
	this.dateStr = dateStr;
	this.todayDateStr = todayDateStr;
	this.ar_days = null;
	this.showsTime = false;
	this.time24 = true;
	this.yearStep = 2;
	this.hiliteToday = true;
	this.multiple = null;
	// HTML elements
	this.table = null;
	this.element = null;
	this.tbody = null;
	this.firstdayname = null;
	// Combo boxes
	this.monthsCombo = null;
	this.yearsCombo = null;
	this.hilitedMonth = null;
	this.activeMonth = null;
	this.hilitedYear = null;
	this.activeYear = null;
	// Information
	this.dateClicked = false;

	// one-time initializations
	if (typeof Calendar._SDN == "undefined") {
		// table of short day names
		if (typeof Calendar._SDN_len == "undefined")
			Calendar._SDN_len = 3;
		var ar = new Array();
		for (var i = 8; i > 0;) {
			ar[--i] = Calendar._DN[i].substr(0, Calendar._SDN_len);
		}
		Calendar._SDN = ar;
		// table of short month names
		if (typeof Calendar._SMN_len == "undefined")
			Calendar._SMN_len = 3;
		ar = new Array();
		for (var i = 12; i > 0;) {
			ar[--i] = Calendar._MN[i].substr(0, Calendar._SMN_len);
		}
		Calendar._SMN = ar;
	}
};

// ** constants

/// "static", needed for event handlers.
Calendar._C = null;

/// detect a special case of "web browser"
Calendar.is_ie = ( /msie/i.test(navigator.userAgent) &&
		   !/opera/i.test(navigator.userAgent) );

Calendar.is_ie5 = ( Calendar.is_ie && /msie 5\.0/i.test(navigator.userAgent) );

Calendar.is_ie6 = ( Calendar.is_ie && /msie 6\.0/i.test(navigator.userAgent) );

/// detect Opera browser
Calendar.is_opera = /opera/i.test(navigator.userAgent);

/// detect KHTML-based browsers
Calendar.is_khtml = /Konqueror|Safari|KHTML/i.test(navigator.userAgent);

// BEGIN: UTILITY FUNCTIONS; beware that these might be moved into a separate
//        library, at some point.

Calendar.getAbsolutePos = function(el) {
    var coords = jQuery(el).offset();
    coords.x = coords.left;
    coords.y = coords.top;
    return coords;
};

Calendar.isRelated = function (el, evt) {
	var related = evt.relatedTarget;
	if (!related) {
		var type = evt.type;
		if (type == "mouseover") {
			related = evt.fromElement;
		} else if (type == "mouseout") {
			related = evt.toElement;
		}
	}
	while (related) {
		if (related == el) {
			return true;
		}
		related = related.parentNode;
	}
	return false;
};

Calendar.removeClass = function(el, className) {
	if (!(el && el.className)) {
		return;
	}
	var cls = el.className.split(" ");
	var ar = new Array();
	for (var i = cls.length; i > 0;) {
		if (cls[--i] != className) {
			ar[ar.length] = cls[i];
		}
	}
	el.className = ar.join(" ");
};

Calendar.addClass = function(el, className) {
	Calendar.removeClass(el, className);
	el.className += " " + className;
};

// FIXME: the following 2 functions totally suck, are useless and should be replaced immediately.
Calendar.getElement = function(ev) {
	var f = Calendar.is_ie ? window.event.srcElement : ev.currentTarget;
	while (f.nodeType != 1 || /^div$/i.test(f.tagName))
		f = f.parentNode;
	return f;
};

Calendar.getTargetElement = function(ev) {
	var f = Calendar.is_ie ? window.event.srcElement : ev.target;
	while (f.nodeType != 1)
		f = f.parentNode;
	return f;
};

Calendar.stopEvent = function(ev) {
    if (!ev) ev = window.event;
    if (ev.stopPropagation) {
		ev.preventDefault();
		ev.stopPropagation();
	} else {
		ev.cancelBubble = true;
		ev.returnValue = false;
    }
	return false;
};

Calendar.addEvent = function(el, evname, func) {
	if (el.attachEvent) { // IE
		el.attachEvent("on" + evname, func);
	} else if (el.addEventListener) { // Gecko / W3C
		el.addEventListener(evname, func, true);
	} else {
		el["on" + evname] = func;
	}
};

Calendar.removeEvent = function(el, evname, func) {
	if (el.detachEvent) { // IE
		el.detachEvent("on" + evname, func);
	} else if (el.removeEventListener) { // Gecko / W3C
		el.removeEventListener(evname, func, true);
	} else {
		el["on" + evname] = null;
	}
};

Calendar.createElement = function(type, parent) {
	var el = null;
	if (document.createElementNS) {
		// use the XHTML namespace; IE won't normally get here unless
		// _they_ "fix" the DOM2 implementation.
		el = document.createElementNS("http://www.w3.org/1999/xhtml", type);
	} else {
		el = document.createElement(type);
	}
	if (typeof parent != "undefined") {
		parent.appendChild(el);
	}
	return el;
};

// END: UTILITY FUNCTIONS

// BEGIN: CALENDAR STATIC FUNCTIONS

/** Internal -- adds a set of events to make some element behave like a button. */
Calendar._add_evs = function(el) {
	with (Calendar) {
		addEvent(el, "mouseover", dayMouseOver);
		addEvent(el, "mousedown", dayMouseDown);
		addEvent(el, "mouseout", dayMouseOut);
		if (is_ie) {
			addEvent(el, "dblclick", dayMouseDblClick);
			el.setAttribute("unselectable", true);
		}
	}
};

Calendar.findMonth = function(el) {
	if (typeof el.month != "undefined") {
		return el;
	} else if (typeof el.parentNode.month != "undefined") {
		return el.parentNode;
	}
	return null;
};

Calendar.findYear = function(el) {
	if (typeof el.year != "undefined") {
		return el;
	} else if (typeof el.parentNode.year != "undefined") {
		return el.parentNode;
	}
	return null;
};

Calendar.showMonthsCombo = function () {
	var cal = Calendar._C;
	if (!cal) {
		return false;
	}
	var cal = cal;
	var cd = cal.activeDiv;
	var mc = cal.monthsCombo;
	if (cal.hilitedMonth) {
		Calendar.removeClass(cal.hilitedMonth, "hilite");
	}
	if (cal.activeMonth) {
		Calendar.removeClass(cal.activeMonth, "active");
	}
	var mon = cal.monthsCombo.getElementsByTagName("div")[cal.date.getMonth()];
	Calendar.addClass(mon, "active");
	cal.activeMonth = mon;
	var s = mc.style;
	s.display = "block";
	if (cd.navtype < 0)
		s.left = cd.offsetLeft + "px";
	else {
		var mcw = mc.offsetWidth;
		if (typeof mcw == "undefined")
			// Konqueror brain-dead techniques
			mcw = 50;
		s.left = (cd.offsetLeft + cd.offsetWidth - mcw) + "px";
	}
	s.top = (cd.offsetTop + cd.offsetHeight) + "px";
};

Calendar.showYearsCombo = function (fwd) {
	var cal = Calendar._C;
	if (!cal) {
		return false;
	}
	var cal = cal;
	var cd = cal.activeDiv;
	var yc = cal.yearsCombo;
	if (cal.hilitedYear) {
		Calendar.removeClass(cal.hilitedYear, "hilite");
	}
	if (cal.activeYear) {
		Calendar.removeClass(cal.activeYear, "active");
	}
	cal.activeYear = null;
	var Y = cal.date.getFullYear() + (fwd ? 1 : -1);
	var yr = yc.firstChild;
	var show = false;
	for (var i = 12; i > 0; --i) {
		if (Y >= cal.minYear && Y <= cal.maxYear) {
			yr.innerHTML = Y;
			yr.year = Y;
			yr.style.display = "block";
			show = true;
		} else {
			yr.style.display = "none";
		}
		yr = yr.nextSibling;
		Y += fwd ? cal.yearStep : -cal.yearStep;
	}
	if (show) {
		var s = yc.style;
		s.display = "block";
		if (cd.navtype < 0)
			s.left = cd.offsetLeft + "px";
		else {
			var ycw = yc.offsetWidth;
			if (typeof ycw == "undefined")
				// Konqueror brain-dead techniques
				ycw = 50;
			s.left = (cd.offsetLeft + cd.offsetWidth - ycw) + "px";
		}
		s.top = (cd.offsetTop + cd.offsetHeight) + "px";
	}
};

// event handlers

Calendar.tableMouseUp = function(ev) {
	var cal = Calendar._C;
	if (!cal) {
		return false;
	}
	if (cal.timeout) {
		clearTimeout(cal.timeout);
	}
	var el = cal.activeDiv;
	if (!el) {
		return false;
	}
	var target = Calendar.getTargetElement(ev);
	ev || (ev = window.event);
	Calendar.removeClass(el, "active");
	if (target == el || target.parentNode == el) {
		Calendar.cellClick(el, ev);
	}
	var mon = Calendar.findMonth(target);
	var date = null;
	if (mon) {
		date = new Date(cal.date);
		if (mon.month != date.getMonth()) {
			date.setMonth(mon.month);
			cal.setDate(date);
			cal.dateClicked = false;
			cal.callHandler();
		}
	} else {
		var year = Calendar.findYear(target);
		if (year) {
			date = new Date(cal.date);
			if (year.year != date.getFullYear()) {
				date.setFullYear(year.year);
				cal.setDate(date);
				cal.dateClicked = false;
				cal.callHandler();
			}
		}
	}
	with (Calendar) {
		removeEvent(document, "mouseup", tableMouseUp);
		removeEvent(document, "mouseover", tableMouseOver);
		removeEvent(document, "mousemove", tableMouseOver);
		cal._hideCombos();
		_C = null;
		return stopEvent(ev);
	}
};

Calendar.tableMouseOver = function (ev) {
	var cal = Calendar._C;
	if (!cal) {
		return;
	}
	var el = cal.activeDiv;
	var target = Calendar.getTargetElement(ev);
	if (target == el || target.parentNode == el) {
		Calendar.addClass(el, "hilite active");
		Calendar.addClass(el.parentNode, "rowhilite");
	} else {
		if (typeof el.navtype == "undefined" || (el.navtype != 50 && (el.navtype == 0 || Math.abs(el.navtype) > 2)))
			Calendar.removeClass(el, "active");
		Calendar.removeClass(el, "hilite");
		Calendar.removeClass(el.parentNode, "rowhilite");
	}
	ev || (ev = window.event);
	if (el.navtype == 50 && target != el) {
		var pos = Calendar.getAbsolutePos(el);
		var w = el.offsetWidth;
		var x = ev.clientX;
		var dx;
		var decrease = true;
		if (x > pos.x + w) {
			dx = x - pos.x - w;
			decrease = false;
		} else
			dx = pos.x - x;

		if (dx < 0) dx = 0;
		var range = el._range;
		var current = el._current;
		var count = Math.floor(dx / 10) % range.length;
		for (var i = range.length; --i >= 0;)
			if (range[i] == current)
				break;
        while (count-- > 0)
			if (decrease) {
				if (--i < 0)
					i = range.length - 1;
			} else if ( ++i >= range.length )
				i = 0;
		var newval = range[i];
		el.innerHTML = newval;

		cal.onUpdateTime();
	}
	var mon = Calendar.findMonth(target);
	if (mon) {
		if (mon.month != cal.date.getMonth()) {
			if (cal.hilitedMonth) {
				Calendar.removeClass(cal.hilitedMonth, "hilite");
			}
			Calendar.addClass(mon, "hilite");
			cal.hilitedMonth = mon;
		} else if (cal.hilitedMonth) {
			Calendar.removeClass(cal.hilitedMonth, "hilite");
		}
	} else {
		if (cal.hilitedMonth) {
			Calendar.removeClass(cal.hilitedMonth, "hilite");
		}
		var year = Calendar.findYear(target);
		if (year) {
			if (year.year != cal.date.getFullYear()) {
				if (cal.hilitedYear) {
					Calendar.removeClass(cal.hilitedYear, "hilite");
				}
				Calendar.addClass(year, "hilite");
				cal.hilitedYear = year;
			} else if (cal.hilitedYear) {
				Calendar.removeClass(cal.hilitedYear, "hilite");
			}
		} else if (cal.hilitedYear) {
			Calendar.removeClass(cal.hilitedYear, "hilite");
		}
	}
	return Calendar.stopEvent(ev);
};

Calendar.tableMouseDown = function (ev) {
	if (Calendar.getTargetElement(ev) == Calendar.getElement(ev)) {
		return Calendar.stopEvent(ev);
	}
};

Calendar.calDragIt = function (ev) {
	var cal = Calendar._C;
	if (!(cal && cal.dragging)) {
		return false;
	}
	var posX;
	var posY;
	if (Calendar.is_ie) {
		posY = window.event.clientY + document.body.scrollTop;
		posX = window.event.clientX + document.body.scrollLeft;
	} else {
		posX = ev.pageX;
		posY = ev.pageY;
	}
	var st = cal.element.style;
	st.left = (posX - cal.xOffs) + "px";
	st.top = (posY - cal.yOffs) + "px";
	return Calendar.stopEvent(ev);
};

Calendar.calDragEnd = function (ev) {
	var cal = Calendar._C;
	if (!cal) {
		return false;
	}
	cal.dragging = false;
	with (Calendar) {
		removeEvent(document, "mousemove", calDragIt);
		removeEvent(document, "mouseup", calDragEnd);
		tableMouseUp(ev);
	}
};

Calendar.dayMouseDown = function(ev) {
	var el = Calendar.getElement(ev);
	if (el.disabled) {
		return false;
	}
	var cal = el.calendar;
	cal.activeDiv = el;
	Calendar._C = cal;
	if (el.navtype != 300) with (Calendar) {
		if (el.navtype == 50) {
			el._current = el.innerHTML;
			addEvent(document, "mousemove", tableMouseOver);
		} else
			addEvent(document, Calendar.is_ie5 ? "mousemove" : "mouseover", tableMouseOver);
		addClass(el, "hilite active");
		addEvent(document, "mouseup", tableMouseUp);
	} else if (cal.isPopup) {
		cal._dragStart(ev);
	}
	if (el.navtype == -1 || el.navtype == 1) {
		if (cal.timeout) clearTimeout(cal.timeout);
		cal.timeout = setTimeout("Calendar.showMonthsCombo()", 250);
	} else if (el.navtype == -2 || el.navtype == 2) {
		if (cal.timeout) clearTimeout(cal.timeout);
		cal.timeout = setTimeout((el.navtype > 0) ? "Calendar.showYearsCombo(true)" : "Calendar.showYearsCombo(false)", 250);
	} else {
		cal.timeout = null;
	}
	return Calendar.stopEvent(ev);
};

Calendar.dayMouseDblClick = function(ev) {
	Calendar.cellClick(Calendar.getElement(ev), ev || window.event);
	if (Calendar.is_ie) {
		document.selection.empty();
	}
};

Calendar.dayMouseOver = function(ev) {
	var el = Calendar.getElement(ev);
	if (Calendar.isRelated(el, ev) || Calendar._C || el.disabled) {
		return false;
	}
	if (el.ttip) {
		if (el.ttip.substr(0, 1) == "_") {
			el.ttip = el.caldate.print(el.calendar.ttDateFormat) + el.ttip.substr(1);
		}
		el.calendar.tooltips.innerHTML = el.ttip;
	}
	if (el.navtype != 300) {
		Calendar.addClass(el, "hilite");
		if (el.caldate) {
			Calendar.addClass(el.parentNode, "rowhilite");
		}
	}
	return Calendar.stopEvent(ev);
};

Calendar.dayMouseOut = function(ev) {
	with (Calendar) {
		var el = getElement(ev);
		if (isRelated(el, ev) || _C || el.disabled)
			return false;
		removeClass(el, "hilite");
		if (el.caldate)
			removeClass(el.parentNode, "rowhilite");
		if (el.calendar)
			el.calendar.tooltips.innerHTML = _TT["SEL_DATE"];
		return stopEvent(ev);
	}
};

/**
 *  A generic "click" handler :) handles all types of buttons defined in this
 *  calendar.
 */
Calendar.cellClick = function(el, ev) {
	var cal = el.calendar;
	var closing = false;
	var newdate = false;
	var date = null;
	if (typeof el.navtype == "undefined") {
		if (cal.currentDateEl) {
			Calendar.removeClass(cal.currentDateEl, "selected");
			Calendar.addClass(el, "selected");
			closing = (cal.currentDateEl == el);
			if (!closing) {
				cal.currentDateEl = el;
			}
		}
		cal.date.setDateOnly(el.caldate);
		date = cal.date;
		var other_month = !(cal.dateClicked = !el.otherMonth);
		if (!other_month && !cal.currentDateEl)
			cal._toggleMultipleDate(new Date(date));
		else
			newdate = !el.disabled;
		// a date was clicked
		if (other_month)
			cal._init(cal.firstDayOfWeek, date);
	} else {
		if (el.navtype == 200) {
			Calendar.removeClass(el, "hilite");
			cal.callCloseHandler();
			return;
		}
		date = new Date(cal.date);
		if (el.navtype == 0)
			if (cal.todayDateStr)
				date = new Date(cal.todayDateStr); // TODAY server TZ
			else
				// todayDate wasn't passed in, so use local TZ
				// this is same bahaviour as before JRA-45558 fix
				date.setDateOnly(new Date()); // TODAY local TZ
		// unless "today" was clicked, we assume no date was clicked so
		// the selected handler will know not to close the calenar when
		// in single-click mode.
		// cal.dateClicked = (el.navtype == 0);
		cal.dateClicked = false;
		var year = date.getFullYear();
		var mon = date.getMonth();

        function setMonth(m) {
			var day = date.getDate();
			var max = date.getMonthDays(m);
			if (day > max) {
				date.setDate(max);
			}
			date.setMonth(m);
		};
		switch (el.navtype) {
		    case 400:
			Calendar.removeClass(el, "hilite");
			var text = Calendar._TT["ABOUT"];
			if (typeof text != "undefined") {
				text += cal.showsTime ? Calendar._TT["ABOUT_TIME"] : "";
			} else {
				// FIXME: this should be removed as soon as lang files get updated!
				text = "Help and about box text is not translated into this language.\n" +
					"If you know this language and you feel generous please update\n" +
					"the corresponding file in \"lang\" subdir to match calendar-en.js\n" +
					"and send it back to <mihai_bazon@yahoo.com> to get it into the distribution  ;-)\n\n" +
					"Thank you!\n" +
					"http://dynarch.com/mishoo/calendar.epl\n";
			}
            /* [alert] */
			alert(text);
            /* [alert] end */
			return;
		    case -2:
			if (year > cal.minYear) {
				date.setFullYear(year - 1);
			}
			break;
		    case -1:
			if (mon > 0) {
				setMonth(mon - 1);
			} else if (year-- > cal.minYear) {
				date.setFullYear(year);
				setMonth(11);
			}
			break;
		    case 1:
			if (mon < 11) {
				setMonth(mon + 1);
			} else if (year < cal.maxYear) {
				date.setFullYear(year + 1);
				setMonth(0);
			}
			break;
		    case 2:
			if (year < cal.maxYear) {
				date.setFullYear(year + 1);
			}
			break;
		    case 100:
			cal.setFirstDayOfWeek(el.fdow);
			return;
		    case 50:
			var range = el._range;
			var current = el.innerHTML;
			for (var i = range.length; --i >= 0;)
				if (range[i] == current)
					break;
			if (ev && ev.shiftKey) {
				if (--i < 0)
					i = range.length - 1;
			} else if ( ++i >= range.length )
				i = 0;
			var newval = range[i];
			el.innerHTML = newval;
			cal.onUpdateTime();
			return;
		    case 0:
			// TODAY will bring us here
			if ((typeof cal.getDateStatus == "function") &&
			    cal.getDateStatus(date, date.getFullYear(), date.getMonth(), date.getDate())) {
				return false;
			}
			break;
		}
		if (!date.equalsTo(cal.date)) {
			cal.setDate(date);
			newdate = true;
		} else if (el.navtype == 0)
			newdate = closing = true;
	}
	if (newdate) {
		ev && cal.callHandler();
	}
	if (closing) {
		Calendar.removeClass(el, "hilite");
		ev && cal.callCloseHandler();
	}
};

// END: CALENDAR STATIC FUNCTIONS

// BEGIN: CALENDAR OBJECT FUNCTIONS

/**
 *  This function creates the calendar inside the given parent.  If _par is
 *  null than it creates a popup calendar inside the BODY element.  If _par is
 *  an element, be it BODY, then it creates a non-popup calendar (still
 *  hidden).  Some properties need to be set before calling this function.
 */
Calendar.prototype.create = function (_par) {
	var parent = null;
	if (! _par) {
		// default parent is the document body, in which case we create
		// a popup calendar.
		parent = document.getElementsByTagName("body")[0];
		this.isPopup = true;
	} else {
		parent = _par;
		this.isPopup = false;
	}

    // try to parse the current date/time in ISO8601 format
	if (this.dateStr) {
        this.date = new Date(this.dateStr);
    }

    // fall back to date/time in browser time zone if necessary
    if (!this.date || isNaN(this.date)) {
        this.date = new Date();
    }

	var table = Calendar.createElement("table");
	this.table = table;
	table.cellSpacing = 0;
	table.cellPadding = 0;
	table.calendar = this;
	Calendar.addEvent(table, "mousedown", Calendar.tableMouseDown);

	var div = Calendar.createElement("div");
	this.element = div;
	div.className = "calendar";
	if (this.isPopup) {
		div.style.position = "absolute";
		div.style.display = "none";
	}
	div.appendChild(table);

	var thead = Calendar.createElement("thead", table);
	var cell = null;
	var row = null;

	var cal = this;
	var hh = function (text, cs, navtype) {
		cell = Calendar.createElement("td", row);
		cell.colSpan = cs;
		cell.className = "button";
		if (navtype != 0 && Math.abs(navtype) <= 2)
			cell.className += " nav";
		Calendar._add_evs(cell);
		cell.calendar = cal;
		cell.navtype = navtype;
		cell.innerHTML = "<div unselectable='on'>" + text + "</div>";
		return cell;
	};

	row = Calendar.createElement("tr", thead);
	var title_length = 6;
	(this.isPopup) && --title_length;
	(this.weekNumbers) && ++title_length;

	hh("?", 1, 400).ttip = Calendar._TT["INFO"];
	this.title = hh("", title_length, 300);
	this.title.className = "title";
	if (this.isPopup) {
		this.title.ttip = Calendar._TT["DRAG_TO_MOVE"];
		this.title.style.cursor = "move";
		hh("&#x00d7;", 1, 200).ttip = Calendar._TT["CLOSE"];
	}

	row = Calendar.createElement("tr", thead);
	row.className = "headrow";

	this._nav_py = hh("&#x00ab;", 1, -2);
	this._nav_py.ttip = Calendar._TT["PREV_YEAR"];

	this._nav_pm = hh("&#x2039;", 1, -1);
	this._nav_pm.ttip = Calendar._TT["PREV_MONTH"];

	this._nav_now = hh(Calendar._TT["TODAY"], this.weekNumbers ? 4 : 3, 0);
	this._nav_now.ttip = Calendar._TT["GO_TODAY"];

	this._nav_nm = hh("&#x203a;", 1, 1);
	this._nav_nm.ttip = Calendar._TT["NEXT_MONTH"];

	this._nav_ny = hh("&#x00bb;", 1, 2);
	this._nav_ny.ttip = Calendar._TT["NEXT_YEAR"];

	// day names
	row = Calendar.createElement("tr", thead);
	row.className = "daynames";
	if (this.weekNumbers) {
		cell = Calendar.createElement("td", row);
		cell.className = "name wn";
		cell.innerHTML = Calendar._TT["WK"];
	}
	for (var i = 7; i > 0; --i) {
		cell = Calendar.createElement("td", row);
		if (!i) {
			cell.navtype = 100;
			cell.calendar = this;
			Calendar._add_evs(cell);
		}
	}
	this.firstdayname = (this.weekNumbers) ? row.firstChild.nextSibling : row.firstChild;
	this._displayWeekdays();

	var tbody = Calendar.createElement("tbody", table);
	this.tbody = tbody;

	for (i = 6; i > 0; --i) {
		row = Calendar.createElement("tr", tbody);
		if (this.weekNumbers) {
			cell = Calendar.createElement("td", row);
		}
		for (var j = 7; j > 0; --j) {
			cell = Calendar.createElement("td", row);
			cell.calendar = this;
			Calendar._add_evs(cell);
		}
	}

	if (this.showsTime) {
		row = Calendar.createElement("tr", tbody);
		row.className = "time";

		cell = Calendar.createElement("td", row);
		cell.className = "time";
		cell.colSpan = 2;
		cell.innerHTML = Calendar._TT["TIME"] || "&nbsp;";

		cell = Calendar.createElement("td", row);
		cell.className = "time";
		cell.colSpan = this.weekNumbers ? 4 : 3;

		(function(){
			function makeTimePart(className, init, range_start, range_end) {
				var part = Calendar.createElement("span", cell);
				part.className = className;
				part.innerHTML = init;
				part.calendar = cal;
				part.ttip = Calendar._TT["TIME_PART"];
				part.navtype = 50;
				part._range = [];
				if (typeof range_start != "number")
					part._range = range_start;
				else {
					for (var i = range_start; i <= range_end; ++i) {
						var txt;
						if (i < 10 && range_end >= 10) txt = '0' + i;
						else txt = '' + i;
						part._range[part._range.length] = txt;
					}
				}
				Calendar._add_evs(part);
				return part;
			};
			var hrs = cal.date.getHours();
			var mins = cal.date.getMinutes();
			var t12 = !cal.time24;
			var pm = (hrs > 12);
			if (t12 && pm) hrs -= 12;
			var H = makeTimePart("hour", hrs, t12 ? 1 : 0, t12 ? 12 : 23);
			var span = Calendar.createElement("span", cell);
			span.innerHTML = ":";
			span.className = "colon";
			var M = makeTimePart("minute", mins, 0, 59);
			var AP = null;
			cell = Calendar.createElement("td", row);
			cell.className = "time";
			cell.colSpan = 2;
			if (t12)
				AP = makeTimePart("ampm", pm ? Calendar._TT["PM"] : Calendar._TT["AM"], [Calendar._TT["am"], Calendar._TT["pm"]]);
			else
				cell.innerHTML = "&nbsp;";

			cal.onSetTime = function() {
				var pm, hrs = this.date.getHours(),
					mins = this.date.getMinutes();
				if (t12) {
					pm = (hrs >= 12);
					if (pm) hrs -= 12;
					if (hrs == 0) hrs = 12;
					AP.innerHTML = pm ? Calendar._TT["pm"] : Calendar._TT["am"];
				}
				H.innerHTML = (hrs < 10) ? ("0" + hrs) : hrs;
				M.innerHTML = (mins < 10) ? ("0" + mins) : mins;
			};

			cal.onUpdateTime = function() {
				var date = this.date;
				var h = parseInt(H.innerHTML, 10);
				if (t12) {
					if (new RegExp(Calendar._TT["pm"],"i").test(AP.innerHTML) && h < 12)
						h += 12;
					else if (new RegExp(Calendar._TT["am"],"i").test(AP.innerHTML) && h == 12)
						h = 0;
				}
				var d = date.getDate();
				var m = date.getMonth();
				var y = date.getFullYear();
				date.setHours(h);
				date.setMinutes(parseInt(M.innerHTML, 10));
				date.setFullYear(y);
				date.setMonth(m);
				date.setDate(d);
				this.dateClicked = false;
				this.callHandler();
			};
		})();
	} else {
		this.onSetTime = this.onUpdateTime = function() {};
	}

	var tfoot = Calendar.createElement("tfoot", table);

	row = Calendar.createElement("tr", tfoot);
	row.className = "footrow";

	cell = hh(Calendar._TT["SEL_DATE"], this.weekNumbers ? 8 : 7, 300);
	cell.className = "ttip";
	if (this.isPopup) {
		cell.ttip = Calendar._TT["DRAG_TO_MOVE"];
		cell.style.cursor = "move";
	}
	this.tooltips = cell;

	div = Calendar.createElement("div", this.element);
	this.monthsCombo = div;
	div.className = "combo";
	for (i = 0; i < Calendar._MN.length; ++i) {
		var mn = Calendar.createElement("div");
		mn.className = Calendar.is_ie ? "label-IEfix" : "label";
		mn.month = i;
		mn.innerHTML = Calendar._SMN[i];
		div.appendChild(mn);
	}

	div = Calendar.createElement("div", this.element);
	this.yearsCombo = div;
	div.className = "combo";
	for (i = 12; i > 0; --i) {
		var yr = Calendar.createElement("div");
		yr.className = Calendar.is_ie ? "label-IEfix" : "label";
		div.appendChild(yr);
	}

	this._init(this.firstDayOfWeek, this.date);
	parent.appendChild(this.element);

    // JRADEV-11430 Prevent clicks on parts of the calendar that aren't already handled by
    // this lib from stealing focus from a focused element
    Calendar.addEvent(this.element, "mousedown", function(ev) {
        ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
    });
};

Calendar._upkeyEvent = function (e) {
    // JRADEV-10921 - We need to make sure that the calendar is still visible when the
    // blur input field code runs (initKeyboardShortcuts.js) so that the LayerManager.js has the chance to preventDefault
    if (e.keyCode === 27) { // KEY esc
        window.setTimeout(function () {
            var cal = window._dynarch_popupCalendar;
            if (!cal || cal.multiple) {
                return false;
            } else {
                cal.callCloseHandler();
            }
        }, 0);
    }
};

/** keyboard navigation, only for popup calendars */
Calendar._keyEvent = function(ev) {
	var cal = window._dynarch_popupCalendar;
	if (!cal || cal.multiple)
		return false;
	var act = (Calendar.is_ie || ev.type == "keydown"),
        K = ev.keyCode;
	if (ev.ctrlKey) {
		switch (K) {
		    case 37: // KEY left
			act && Calendar.cellClick(cal._nav_pm);
			break;
		    case 38: // KEY up
			act && Calendar.cellClick(cal._nav_py);
			break;
		    case 39: // KEY right
			act && Calendar.cellClick(cal._nav_nm);
			break;
		    case 40: // KEY down
			act && Calendar.cellClick(cal._nav_ny);
			break;
		}
	} else switch (K) {
	    case 32: // KEY space (now)
		Calendar.cellClick(cal._nav_now);
		break;
	    case 37: // KEY left
	    case 38: // KEY up
	    case 39: // KEY right
	    case 40: // KEY down
		if (act) {
			var prev, x, y, ne, el, step;
			prev = K == 37 || K == 38;
			step = (K == 37 || K == 39) ? 1 : 7;
			function setVars() {
				el = cal.currentDateEl;
				var p = el.pos;
				x = p & 15;
				y = p >> 4;
				ne = cal.ar_days[y][x];
			};setVars();
			function prevMonth() {
				var date = new Date(cal.date);
				date.setDate(date.getDate() - step);
				cal.setDate(date);
			};
			function nextMonth() {
				var date = new Date(cal.date);
				date.setDate(date.getDate() + step);
				cal.setDate(date);
			};
			while (1) {
				switch (K) {
				    case 37: // KEY left
					if (--x >= 0)
						ne = cal.ar_days[y][x];
					else {
						x = 6;
						K = 38;
						continue;
					}
					break;
				    case 38: // KEY up
					if (--y >= 0)
						ne = cal.ar_days[y][x];
					else {
						prevMonth();
						setVars();
					}
					break;
				    case 39: // KEY right
					if (++x < 7)
						ne = cal.ar_days[y][x];
					else {
						x = 0;
						K = 40;
						continue;
					}
					break;
				    case 40: // KEY down
					if (++y < cal.ar_days.length)
						ne = cal.ar_days[y][x];
					else {
						nextMonth();
						setVars();
					}
					break;
				}
				break;
			}
			if (ne) {
				if (!ne.disabled)
					Calendar.cellClick(ne);
				else if (prev)
					prevMonth();
				else
					nextMonth();
			}
		}
		break;
	    case 13: // KEY enter
		if (act)
			Calendar.cellClick(cal.currentDateEl, ev);
		break;
	}
	return Calendar.stopEvent(ev);
};

/**
 *  (RE)Initializes the calendar to the given date and firstDayOfWeek
 */
Calendar.prototype._init = function (firstDayOfWeek, seedDate) {
    // JRA-19533
    //
    // Depending on when the DST is applied, some hours might not exist. For example,
    // in Brazil, the clock goes like
    //    Saturday, 17 October 2014 23:59:58
    //    Saturday, 17 October 2014 23:59:59
    //     <------ DST starts here ------->
    //    Sunday, 18 October 2014 01:00:00
    //    Sunday, 18 October 2014 01:00:01
    //
    // We want to avoid iterating over times of dubious values.
    //
    // So first, we'll clone the original seed date.
    var date = new Date(seedDate);
    // Now, to avoid DST problems, we need to tweak the hour of day.
    //
    // Set time to 13.00 to avoid the case where a DST transition causes
    // the below method of iterating through dates to print the same
    // date twice consecutively.
    //
    // After checking the IANA time zone database (http://en.wikipedia.org/wiki/IANA_time_zone_database)
    // 13.00 was never used by any country to apply the DST, so it's a better assumption than midnight or
    // noon.
    date.setHours(13);

	var today = new Date(),
		TY = today.getFullYear(),
		TM = today.getMonth(),
		TD = today.getDate();
	this.table.style.visibility = "hidden";
	var year = date.getFullYear();
	if (year < this.minYear) {
		year = this.minYear;
		date.setFullYear(year);
	} else if (year > this.maxYear) {
		year = this.maxYear;
		date.setFullYear(year);
	}
	this.firstDayOfWeek = firstDayOfWeek;
	var month = date.getMonth();
	var mday = date.getDate();
	var no_days = date.getMonthDays();

	// calendar voodoo for computing the first day that would actually be
	// displayed in the calendar, even if it's from the previous month.
	// WARNING: this is magic. ;-)
	date.setDate(1);
	var day1 = (date.getDay() - this.firstDayOfWeek) % 7;
	if (day1 < 0)
		day1 += 7;
	date.setDate(-day1);
	date.setDate(date.getDate() + 1);

	var row = this.tbody.firstChild;
	var MN = Calendar._SMN[month];
	var ar_days = this.ar_days = new Array();
	var weekend = Calendar._TT["WEEKEND"];
	var dates = this.multiple ? (this.datesCells = {}) : null;
	for (var i = 0; i < 6; ++i, row = row.nextSibling) {
		var cell = row.firstChild;
		if (this.weekNumbers) {
			cell.className = "day wn";
            //
            // The old code didn't take into account the displayed month and hence
            // it showed 52/53 for the first week in January instead of 1
            // so we now taken this into account, but only for non ISO 8601 dates.
            //
            //cell.innerHTML = date.getWeekNumber();
            var monthStartDate = date;
            if (month == 0 && i == 0 && Date.useISO8601WeekNumbers == false) { // Jan and first week in row
                monthStartDate = new Date(year,month,1);
            }
            cell.innerHTML = monthStartDate.getWeekNumber(this.firstDayOfWeek);
            cell = cell.nextSibling;
		}
		row.className = "daysrow";
		var hasdays = false, iday, dpos = ar_days[i] = [];
		for (var j = 0; j < 7; ++j, cell = cell.nextSibling, date.setDate(iday + 1)) {
			iday = date.getDate();
			var wday = date.getDay();
			cell.className = "day day-" + iday;
			cell.pos = i << 4 | j;
			dpos[j] = cell;
			var current_month = (date.getMonth() == month);
			if (!current_month) {
				if (this.showsOtherMonths) {
					cell.className += " othermonth";
					cell.otherMonth = true;
				} else {
					cell.className = "emptycell";
					cell.innerHTML = "&nbsp;";
					cell.disabled = true;
					continue;
				}
			} else {
				cell.otherMonth = false;
				hasdays = true;
			}
			cell.disabled = false;
			cell.innerHTML = this.getDateText ? this.getDateText(date, iday) : iday;
			if (dates)
				dates[date.print("%Y%m%d")] = cell;
			if (this.getDateStatus) {
				var status = this.getDateStatus(date, year, month, iday);
				if (this.getDateToolTip) {
					var toolTip = this.getDateToolTip(date, year, month, iday);
					if (toolTip)
						cell.title = toolTip;
				}
				if (status === true) {
					cell.className += " disabled";
					cell.disabled = true;
				} else {
					if (/disabled/i.test(status))
						cell.disabled = true;
					cell.className += " " + status;
				}
			}
			if (!cell.disabled) {
				cell.caldate = new Date(date);
				cell.ttip = "_";
				if (!this.multiple && current_month
				    && iday == mday && this.hiliteToday) {
					cell.className += " selected";
					this.currentDateEl = cell;
				}
				if (date.getFullYear() == TY &&
				    date.getMonth() == TM &&
				    iday == TD) {
					cell.className += " today";
					cell.ttip += Calendar._TT["PART_TODAY"];
				}
				if (weekend.indexOf(wday.toString()) != -1)
					cell.className += cell.otherMonth ? " oweekend" : " weekend";
			}
		}
		if (!(hasdays || this.showsOtherMonths))
			row.className = "emptyrow";
	}

    // JRA-19533
    // Now that we're done messing with the time of day, set the internal date to the seed date.
    this.date = new Date(seedDate);
    // The date above will include the original time, which will be used to set the time controls below.
	this.onSetTime();

    this.title.innerHTML = Calendar._MN[month] + ", " + year;
	this.table.style.visibility = "visible";
	this._initMultipleDates();
	// PROFILE
	// this.tooltips.innerHTML = "Generated in " + ((new Date()) - today) + " ms";
};

Calendar.prototype._initMultipleDates = function() {
	if (this.multiple) {
		for (var i in this.multiple) {
			var cell = this.datesCells[i];
			var d = this.multiple[i];
			if (!d)
				continue;
			if (cell)
				cell.className += " selected";
		}
	}
};

Calendar.prototype._toggleMultipleDate = function(date) {
	if (this.multiple) {
		var ds = date.print("%Y%m%d");
		var cell = this.datesCells[ds];
		if (cell) {
			var d = this.multiple[ds];
			if (!d) {
				Calendar.addClass(cell, "selected");
				this.multiple[ds] = date;
			} else {
				Calendar.removeClass(cell, "selected");
				delete this.multiple[ds];
			}
		}
	}
};

Calendar.prototype.setDateToolTipHandler = function (unaryFunction) {
	this.getDateToolTip = unaryFunction;
};

/**
 *  Calls _init function above for going to a certain date (but only if the
 *  date is different than the currently selected one).
 */
Calendar.prototype.setDate = function (date) {
	if (!date.equalsTo(this.date)) {
		this._init(this.firstDayOfWeek, date);
	}
};

/**
 *  Refreshes the calendar.  Useful if the "disabledHandler" function is
 *  dynamic, meaning that the list of disabled date can change at runtime.
 *  Just * call this function if you think that the list of disabled dates
 *  should * change.
 */
Calendar.prototype.refresh = function () {
	this._init(this.firstDayOfWeek, this.date);
};

/** Modifies the "firstDayOfWeek" parameter (pass 0 for Synday, 1 for Monday, etc.). */
Calendar.prototype.setFirstDayOfWeek = function (firstDayOfWeek) {
	this._init(firstDayOfWeek, this.date);
	this._displayWeekdays();
};

/**
 *  Allows customization of what dates are enabled.  The "unaryFunction"
 *  parameter must be a function object that receives the date (as a JS Date
 *  object) and returns a boolean value.  If the returned value is true then
 *  the passed date will be marked as disabled.
 */
Calendar.prototype.setDateStatusHandler = Calendar.prototype.setDisabledHandler = function (unaryFunction) {
	this.getDateStatus = unaryFunction;
};

/** Customization of allowed year range for the calendar. */
Calendar.prototype.setRange = function (a, z) {
	this.minYear = a;
	this.maxYear = z;
};

/** Calls the first user handler (selectedHandler). */
Calendar.prototype.callHandler = function () {
	if (this.onSelected) {
		this.onSelected(this, this.date.print(this.dateFormat));
	}
};

/** Calls the second user handler (closeHandler). */
Calendar.prototype.callCloseHandler = function () {
	if (this.onClose) {
		this.onClose(this);
	}
};

/** Removes the calendar object from the DOM tree and destroys it. */
Calendar.prototype.destroy = function () {
	var el = this.element.parentNode;
	el.removeChild(this.element);
	Calendar._C = null;
	window._dynarch_popupCalendar = null;
};

/**
 *  Moves the calendar element to a different section in the DOM tree (changes
 *  its parent).
 */
Calendar.prototype.reparent = function (new_parent) {
	var el = this.element;
	el.parentNode.removeChild(el);
	new_parent.appendChild(el);
};

// This gets called when the user presses a mouse button anywhere in the
// document, if the calendar is shown.  If the click was outside the open
// calendar this function closes it.
Calendar._checkCalendar = function(ev) {
	var calendar = window._dynarch_popupCalendar;
	if (!calendar) {
		return false;
	}
	var el = Calendar.is_ie ? Calendar.getElement(ev) : Calendar.getTargetElement(ev);
	for (; el != null && el != calendar.element; el = el.parentNode);
	if (el == null) {
		// calls closeHandler which should hide the calendar.
		window._dynarch_popupCalendar.callCloseHandler();
		return Calendar.stopEvent(ev);
	}
};

/** Shows the calendar. */
Calendar.prototype.show = function() {
	if (this.params.inputField.disabled) {
		// Don't show the calendar if its inputField isn't editable.
		return;
	}
	var rows = this.table.getElementsByTagName("tr");
	for (var i = rows.length; i > 0;) {
		var row = rows[--i];
		Calendar.removeClass(row, "rowhilite");
		var cells = row.getElementsByTagName("td");
		for (var j = cells.length; j > 0;) {
			var cell = cells[--j];
			Calendar.removeClass(cell, "hilite");
			Calendar.removeClass(cell, "active");
		}
	}
    Calendar.current = this;
    this.element.style.display = "block";
    this.element.className += " active";
    
	this.hidden = false;
	if (this.isPopup) {
		window._dynarch_popupCalendar = this;
		Calendar.addEvent(document, "keyup", Calendar._upkeyEvent);
		Calendar.addEvent(document, "keydown", Calendar._keyEvent);
		Calendar.addEvent(document, "mousedown", Calendar._checkCalendar);
	}
};

/**
 *  Hides the calendar.  Also removes any "hilite" from the class of any TD
 *  element.
 */
Calendar.prototype.hide = function () {
	if (this.isPopup) {
        Calendar.removeEvent(document, "keyup", Calendar._upkeyEvent);
		Calendar.removeEvent(document, "keydown", Calendar._keyEvent);
		Calendar.removeEvent(document, "mousedown", Calendar._checkCalendar);
	}

    Calendar.current = null;
	this.element.style.display = "none";
    this.element.className = this.element.className.replace(/active/gi, "");
	this.hidden = true;
};

/**
 *  Shows the calendar at a given absolute position (beware that, depending on
 *  the calendar element style -- position property -- this might be relative
 *  to the parent's containing rectangle).
 */
Calendar.prototype.showAt = function (x, y) {
	var s = this.element.style;
	s.left = x + "px";
	s.top = y + "px";
	this.show();
};

/** Shows the calendar near a given element. */
Calendar.prototype.showAtElement = function (el, opts) {
    var self = this;
	var p = Calendar.getAbsolutePos(el);
	if (!opts || typeof opts != "string") {
		this.showAt(p.x, p.y + el.offsetHeight);
		return true;
	}
	function fixPosition(box) {
		if (box.x < 0)
			box.x = 0;
		if (box.y < 0)
			box.y = 0;
		var cp = document.createElement("div");
		var s = cp.style;
		s.position = "absolute";
		s.right = s.bottom = s.width = s.height = "0px";
		document.body.appendChild(cp);
		var br = Calendar.getAbsolutePos(cp);
		document.body.removeChild(cp);
        br.y += jQuery(window).scrollTop();
        br.x += jQuery(window).scrollLeft();
		var tmp = box.x + box.width - br.x;
		if (tmp > 0) box.x -= tmp;
		tmp = box.y + box.height - br.y;
		if (tmp > 0) box.y -= tmp;
	};
	this.element.style.display = "block";
	Calendar.continuation_for_the_khtml_browser = function() {
		var w = jQuery(self.element).outerWidth();
		var h = jQuery(self.element).outerHeight();
		self.element.style.display = "none";
		var valign = opts.substr(0, 1);
		var halign = "l";
		if (opts.length > 1) {
			halign = opts.substr(1, 1);
		}
		// vertical alignment
		switch (valign) {
		    case "T": p.y -= h; break;
		    case "B": p.y += jQuery(el).outerHeight(); break;
		    case "C": p.y += (jQuery(el).outerHeight() - h) / 2; break;
		    case "t": p.y += jQuery(el).outerHeight() - h; break;
		    case "b": break; // already there
		}
		// horizontal alignment
		switch (halign) {
		    case "L": p.x -= w; break;
		    case "R": p.x += jQuery(el).outerWidth(); break;
		    case "C": p.x += (jQuery(el).outerWidth() - w) / 2; break;
		    case "l": p.x += jQuery(el).outerWidth() - w; break;
		    case "r": break; // already there
		}
		p.width = w;
		p.height = h + 40;
		self.monthsCombo.style.display = "none";
		fixPosition(p);
		self.showAt(p.x, p.y);
	};
    Calendar.continuation_for_the_khtml_browser();
};

/** Customizes the date format. */
Calendar.prototype.setDateFormat = function (str) {
	this.dateFormat = str;
};

/** Customizes the tooltip date format. */
Calendar.prototype.setTtDateFormat = function (str) {
	this.ttDateFormat = str;
};

/**
 *  Tries to identify the date represented in a string.  If successful it also
 *  calls this.setDate which moves the calendar to the given date.
 */
Calendar.prototype.parseDate = function(str, fmt) {
	if (!fmt)
		fmt = this.dateFormat;
	this.setDate(Date.parseDate(str, fmt));
};


/** Internal function; it displays the bar with the names of the weekday. */
Calendar.prototype._displayWeekdays = function () {
	var fdow = this.firstDayOfWeek;
	var cell = this.firstdayname;
	var weekend = Calendar._TT["WEEKEND"];
	for (var i = 0; i < 7; ++i) {
		cell.className = "day name";
		var realday = (i + fdow) % 7;
		if (i) {
			cell.ttip = Calendar._TT["DAY_FIRST"].replace("%s", Calendar._DN[realday]);
			cell.navtype = 100;
			cell.calendar = this;
			cell.fdow = realday;
			Calendar._add_evs(cell);
		}
		if (weekend.indexOf(realday.toString()) != -1) {
			Calendar.addClass(cell, "weekend");
		}
		cell.innerHTML = Calendar._SDN[(i + fdow) % 7];
		cell = cell.nextSibling;
	}
};

/** Internal function.  Hides all combo boxes that might be displayed. */
Calendar.prototype._hideCombos = function () {
	this.monthsCombo.style.display = "none";
	this.yearsCombo.style.display = "none";
};

/** Internal function.  Starts dragging the element. */
Calendar.prototype._dragStart = function (ev) {
	if (this.dragging) {
		return;
	}
	this.dragging = true;
	var posX;
	var posY;
	if (Calendar.is_ie) {
		posY = window.event.clientY + document.body.scrollTop;
		posX = window.event.clientX + document.body.scrollLeft;
	} else {
		posY = ev.clientY + window.scrollY;
		posX = ev.clientX + window.scrollX;
	}
	var st = this.element.style;
	this.xOffs = posX - parseInt(st.left);
	this.yOffs = posY - parseInt(st.top);
	with (Calendar) {
		addEvent(document, "mousemove", calDragIt);
		addEvent(document, "mouseup", calDragEnd);
	}
};

// BEGIN: DATE OBJECT PATCHES

/** Adds the number of days array to the Date object. */
Date._MD = new Array(31,28,31,30,31,30,31,31,30,31,30,31);

/** Constants used for time computations */
Date.SECOND = 1000 /* milliseconds */;
Date.MINUTE = 60 * Date.SECOND;
Date.HOUR   = 60 * Date.MINUTE;
Date.DAY    = 24 * Date.HOUR;
Date.WEEK   =  7 * Date.DAY;

/**
 * Splits based on multiple seprators as opposed to String.split, which takes only 1 separator
 */
Date._multisplit = function(s,seps) {
	if (s == null) {
		return null;
	}
	if (seps == null) {
		seps = "";
	}
	var arr = [];
	var len = s.length;
	var token = "";
	var inWord = false;
	for (i = 0; i < len; i++) {
		var c = s.charAt(i);
		if (seps.indexOf(c) == -1) {
			// it a non seperator
			inWord = true;
			token += c;
		} else {
			// its a separator
			if (inWord) {
				// finish of the last word first
				arr[arr.length] = token;
				token = "";
				inWord = false;
			}
			// ignore the sep character
		}
	}
	if (token.length > 0) {
		arr[arr.length] = token;
	}
	// in case the pass in a empty string to start with
	if (arr.length == 0) {
		arr[arr.length] = "";
	}
	return arr;
}

/**
 * This returns the characters in a string that are not part of the DHTML Calendar special
 * magic format characters, eg the ones that start with % something.
 */
Date._parseNonDateFormatChars = function(s) {
	//
	// as taken from code and documentation online
	// http://www.dynarch.com/demos/jscalendar/doc/html/reference.html#node_sec_5.3.6
	//
	var magicChars = "aAbBCdeHIJklmMnpPRSstUWVuwyY%";
	var nonMagicChars = "";
	var len = s.length;
	var inMagic = false;
	for (i = 0; i < len; i++) {
		var c = s.charAt(i);
		if (c == "%") {
			// peek ahead  and we always jump ahead too
			var peekc = "";
			if (i+1 < len) {
				peekc = s.charAt(i+1);
			}
			i = i+1;
			if (peekc.length > 0 && magicChars.indexOf(peekc) != -1) {
				// we have a magic chars so eat it
				continue;
			} else {
				// we have a non magic chars preceded by a % (weird huh?) so put it in the list if its not there already
				if (nonMagicChars.indexOf(c) == -1) {
					nonMagicChars += c;
				}
				if (peekc.length > 0 && nonMagicChars.indexOf(peekc) == -1) {
					nonMagicChars += peekc;
				}
			}
		} else {
			// we have a non magic chars so put it in the list if its not there already
			if (nonMagicChars.indexOf(c) == -1) {
					nonMagicChars += c;
			}
		}
	}
	return nonMagicChars;
}

Date.parseDate = function(str, fmt) {


    var today = new Date();
	var y = 0;
	var m = -1;
	var d = 0;
    // The old code used a regex /\W+/ that only worked for ISO Latin character sets
    // so we have replaced this with two new functions that parse out the non date format
    // characters and then splits the input value based on these non formatting characters.
    //
    //var a = str.split(/\W+/);
    var seps = Date._parseNonDateFormatChars(fmt);
    var a = Date._multisplit(str,seps);
    var b = fmt.match(/%./g);

    var i = 0, j = 0;
	var hr = 0;
	var min = 0;
	for (i = 0; i < a.length; ++i) {
		if (!a[i])
			continue;
		switch (b[i]) {
		    case "%d":
		    case "%e":
			d = parseInt(a[i], 10);
			break;

		    case "%m":
			m = parseInt(a[i], 10) - 1;
			break;

		    case "%Y":
		    case "%y":
			y = parseInt(a[i], 10);
			(y < 100) && (y += (y > 29) ? 1900 : 2000);
			break;

            //
            // the old code was too liberal in how it found month names and assumed that the short month name
            // was always contained within the long month name.  But this not always so.  So lets get more specific
            // and stop thinking %b and %B are equivalent.
            //
//          case "%b":
//		    case "%B":
//			for (j = 0; j < 12; ++j) {
//				if (Calendar._MN[j].substr(0, a[i].length).toLowerCase() == a[i].toLowerCase()) { m = j; break; }
//			}
//			break;
//
            case "%b":
            case "%B":

            var monthName = a[i].toLowerCase();
            var found = false;
            if (b[i] == "%b") {
                for (j = 0; j < 12; ++j) {
                    // check most specific first
                    if (Calendar._SMN[j].substr(0, monthName.length).toLowerCase() == monthName) {
                        m = j;
                        found = true;
                        break;
                    }
                }
            }
            if (! found) {
                // do it the old code way even for %b if need be
                for (j = 0; j < 12; ++j) {
                     if (Calendar._MN[j].substr(0, monthName.length).toLowerCase() == monthName) {
                         m = j;
                         break;
                     }
                 }
            }
            break;

            case "%H":
		    case "%I":
		    case "%k":
		    case "%l":
			hr = parseInt(a[i], 10);
			break;

		    case "%P":
		    case "%p":
			if (/pm/i.test(a[i]) && hr < 12)
				hr += 12;
			else if (/am/i.test(a[i]) && hr >= 12)
				hr -= 12;
			break;

		    case "%M":
			min = parseInt(a[i], 10);
			break;

            case "%R":
                var hrMinString = a[ i ];
                var hrMinSeparator = hrMinString.indexOf(":");
                var hrString = hrMinString.substring( 0, hrMinSeparator );
                var minString = hrMinSeparator == -1 ? 0 : hrMinString.substring( hrMinSeparator + 1 );

                hr = parseInt( hrString, 10 );
                min = parseInt( minString, 10 );
                break;
        }
	}
	if (isNaN(y)) y = today.getFullYear();
	if (isNaN(m)) m = today.getMonth();
	if (isNaN(d)) d = today.getDate();
	if (isNaN(hr)) hr = today.getHours();
	if (isNaN(min)) min = today.getMinutes();
	if (y != 0 && m != -1 && d != 0)
		return new Date(y, m, d, hr, min, 0);
	y = 0; m = -1; d = 0;
	for (i = 0; i < a.length; ++i) {
		if (a[i].search(/[a-zA-Z]+/) != -1) {
			var t = -1;
			for (j = 0; j < 12; ++j) {
				if (Calendar._MN[j].substr(0, a[i].length).toLowerCase() == a[i].toLowerCase()) { t = j; break; }
			}
			if (t != -1) {
				if (m != -1) {
					d = m+1;
				}
				m = t;
			}
		} else if (parseInt(a[i], 10) <= 12 && m == -1) {
			m = a[i]-1;
		} else if (parseInt(a[i], 10) > 31 && y == 0) {
			y = parseInt(a[i], 10);
			(y < 100) && (y += (y > 29) ? 1900 : 2000);
		} else if (d == 0) {
			d = a[i];
		}
	}
	if (y == 0)
		y = today.getFullYear();
	if (m != -1 && d != 0)
		return new Date(y, m, d, hr, min, 0);
	return today;
};

/** Returns the number of days in the current month */
Date.prototype.getMonthDays = function(month) {
	var year = this.getFullYear();
	if (typeof month == "undefined") {
		month = this.getMonth();
	}
	if (((0 == (year%4)) && ( (0 != (year%100)) || (0 == (year%400)))) && month == 1) {
		return 29;
	} else {
		return Date._MD[month];
	}
};

/** Returns the number of day in the year. */
Date.prototype.getDayOfYear = function() {
	// JRA-19533 -- We use an hour of 13 to avoid potential DST problems.
	var now = new Date(this.getFullYear(), this.getMonth(), this.getDate(), 13, 0, 0);
	var then = new Date(this.getFullYear(), 0, 0, 13, 0, 0);
	var time = now - then;
	return Math.floor(time / Date.DAY);
};

/** Returns the number of the week in year, as defined in ISO 8601. */
Date.prototype.getWeekNumber = function(startOfWeek) {
    if (Date.useISO8601WeekNumbers) {
        return this.getISO8601WeekNumber();
    } else {
        return this.getSimpleWeekNumber(startOfWeek);
    }
};

/* Algorithm taken from: http://www.staff.science.uu.nl/~gent0113/calendar/isocalendar.htm
 */
Date.prototype.getISO8601WeekNumber = function() {
    function gregdaynumber(year, month, day)
    {
        // computes the day number since 0 January 0 CE (Gregorian)

        y = year;
        m = month;
        if (month < 3)
        {
            y = y - 1;
        }
        if (month < 3)
        {
            m = m + 12;
        }
        return Math.floor(365.25 * y) - Math.floor(y / 100) + Math.floor(y / 400) + Math.floor(30.6 * (m + 1)) + day - 62;
    }

    function isocalendar1(date)
    {

        // computes the ISO calendar date from the current Gregorian date
        year = date.getFullYear();
        month = date.getMonth(); // 0=January, 1=February, etc.
        day = date.getDate();
        wday = date.getDay();

        weekday = ((wday + 6) % 7) + 1; // weekdays will be numbered 1 to 7

        isoyear = year;

        d0 = gregdaynumber(year, 1, 0);
        weekday0 = ((d0 + 4) % 7) + 1;

        d = gregdaynumber(year, month + 1, day);
        isoweeknr = Math.floor((d - d0 + weekday0 + 6) / 7) - Math.floor((weekday0 + 3) / 7);

        // check whether the last few days of December belong to the next year's ISO week

        if ((month == 11) && ((day - weekday) > 27))
        {
            isoweeknr = 1;
            isoyear = isoyear + 1;
        }

        // check whether the first few days of January belong to the previous year's ISO week
        if ((month == 0) && ((weekday - day) > 3))
        {
            d0 = gregdaynumber(year - 1, 1, 0);
            weekday0 = ((d0 + 4) % 7) + 1;
            isoweeknr = Math.floor((d - d0 + weekday0 + 6) / 7) - Math.floor((weekday0 + 3) / 7);
            isoyear = isoyear - 1;
        }

        return isoweeknr;
    }

    return isocalendar1(this);
}

/* Algorithm taken from: http://www.merlyn.demon.co.uk/weekcalc.htm#NIP
   Blame them for the shit variable and function names. Seriously, WTF?
   This is "Type 1" with a Sun-Sat row.

   Using the simple week counting you need to know
   the start of week so you can do the calculations properly.

   If you don't specify a startOfWeek then Sunday is used.
*/

Date.prototype.getSimpleWeekNumber = function(startOfWeek)
{
    function OddWkNo1(D, d1, d2)
    {
        var Yr = D.getFullYear(), Jan1 = new Date(Yr, 0, 1), Q;
        Q = Math.round((D - Jan1) / 86400000);
        if (d1 != null)
        {
            Q -= (7 + d1 - Jan1.getDay()) % 7;
        }
        if (d2 != null)
        {
            Q += d2;
        }
        return [Yr, 1 + Q / 7 | 0, 1 + (7 + Q) % 7];
    }

    return OddWkNo1(this, startOfWeek ? startOfWeek : 6, 6)[1];
//    return OddWkNo1(this, 6, 6)[1];
}

/** Checks date and time equality */
Date.prototype.equalsTo = function(date) {
	return ((this.getFullYear() == date.getFullYear()) &&
		(this.getMonth() == date.getMonth()) &&
		(this.getDate() == date.getDate()) &&
		(this.getHours() == date.getHours()) &&
		(this.getMinutes() == date.getMinutes()));
};

/** Set only the year, month, date parts (keep existing time) */
Date.prototype.setDateOnly = function(date) {
	var tmp = new Date(date);
	this.setDate(1);
	this.setFullYear(tmp.getFullYear());
	this.setMonth(tmp.getMonth());
	this.setDate(tmp.getDate());
};

/** Prints the date in a string according to the given format. */
Date.prototype.print = function (str) {

    var m = this.getMonth();
	var d = this.getDate();
	var y = this.getFullYear();
	var wn = this.getWeekNumber();
	var w = this.getDay();
	var s = {};
	var hr = this.getHours();
	var pm = (hr >= 12);
	var ir = (pm) ? (hr - 12) : hr;
	var dy = this.getDayOfYear();
	if (ir == 0)
		ir = 12;
	var min = this.getMinutes();
	var sec = this.getSeconds();
	s["%a"] = Calendar._SDN[w]; // abbreviated weekday name [FIXME: I18N]
	s["%A"] = Calendar._DN[w]; // full weekday name
	s["%b"] = Calendar._SMN[m]; // abbreviated month name [FIXME: I18N]

    s["%B"] = Calendar._MN[m]; // full month name
	// FIXME: %c : preferred date and time representation for the current locale
	s["%C"] = 1 + Math.floor(y / 100); // the century number
	s["%d"] = (d < 10) ? ("0" + d) : d; // the day of the month (range 01 to 31)
	s["%e"] = d; // the day of the month (range 1 to 31)
	// FIXME: %D : american date style: %m/%d/%y
	// FIXME: %E, %F, %G, %g, %h (man strftime)
	s["%H"] = (hr < 10) ? ("0" + hr) : hr; // hour, range 00 to 23 (24h format)
	s["%I"] = (ir < 10) ? ("0" + ir) : ir; // hour, range 01 to 12 (12h format)
	s["%j"] = (dy < 100) ? ((dy < 10) ? ("00" + dy) : ("0" + dy)) : dy; // day of the year (range 001 to 366)
	s["%k"] = hr;		// hour, range 0 to 23 (24h format)
	s["%l"] = ir;		// hour, range 1 to 12 (12h format)
	s["%m"] = (m < 9) ? ("0" + (1+m)) : (1+m); // month, range 01 to 12
	s["%M"] = (min < 10) ? ("0" + min) : min; // minute, range 00 to 59
	s["%n"] = "\n";		// a newline character
	s["%p"] = pm ? Calendar._TT["PM"] : Calendar._TT["AM"]
	s["%P"] = pm ? Calendar._TT["PM"] : Calendar._TT["AM"]
	// FIXME: %r : the time in am/pm notation %I:%M:%S %p
	// FIXME: %R : the time in 24-hour notation %H:%M
    s["%R"] = s["%k"] + ":" + s["%M"];



    s["%s"] = Math.floor(this.getTime() / 1000);
	s["%S"] = (sec < 10) ? ("0" + sec) : sec; // seconds, range 00 to 59
	s["%t"] = "\t";		// a tab character
	// FIXME: %T : the time in 24-hour notation (%H:%M:%S)
	s["%U"] = s["%W"] = s["%V"] = (wn < 10) ? ("0" + wn) : wn;
	s["%u"] = w + 1;	// the day of the week (range 1 to 7, 1 = MON)
	s["%w"] = w;		// the day of the week (range 0 to 6, 0 = SUN)
	// FIXME: %x : preferred date representation for the current locale without the time
	// FIXME: %X : preferred time representation for the current locale without the date
	s["%y"] = ('' + y).slice(-2); // year without the century (range 00 to 99)
	s["%Y"] = y;		// year with the century
	s["%%"] = "%";		// a literal '%' character

	var re = /%./g;
	if (!Calendar.is_ie5 && !Calendar.is_khtml)
		return str.replace(re, function (par) { return s[par] || par; });

	var a = str.match(re);
	for (var i = 0; i < a.length; i++) {
		var tmp = s[a[i]];
		if (tmp) {
			re = new RegExp(a[i], 'g');
			str = str.replace(re, tmp);
		}
	}

	return str;
};

Date.prototype.__msh_oldSetFullYear = Date.prototype.setFullYear;
Date.prototype.setFullYear = function(y) {
	var d = new Date(this);
	d.__msh_oldSetFullYear(y);
	if (d.getMonth() != this.getMonth())
		this.setDate(28);
	this.__msh_oldSetFullYear(y);
};

// END: DATE OBJECT PATCHES


// global object that remembers the calendar
window._dynarch_popupCalendar = null;
;
;
/* module-key = 'jira.webresources:calendar', location = '/includes/lib/calendar/Calendar.setup.js' */
/*  Copyright Mihai Bazon, 2002, 2003  |  http://dynarch.com/mishoo/
 * ---------------------------------------------------------------------------
 *
 * The DHTML Calendar
 *
 * Details and latest version at:
 * http://dynarch.com/mishoo/calendar.epl
 *
 * This script is distributed under the GNU Lesser General Public License.
 * Read the entire license text here: http://www.gnu.org/licenses/lgpl.html
 *
 * This file defines helper functions for setting up the calendar.  They are
 * intended to help non-programmers get a working calendar on their site
 * quickly.  This script should not be seen as part of the calendar.  It just
 * shows you what one can do with the calendar, while in the same time
 * providing a quick and simple method for setting it up.  If you need
 * exhaustive customization of the calendar creation process feel free to
 * modify this code to suit your needs (this is recommended and much better
 * than modifying calendar.js itself).
 */

// $Id: calendar-setup.js,v 1.1 2005/04/26 03:29:58 mchai Exp $

/**
 *  This function "patches" an input field (or other element) to use a calendar
 *  widget for date selection.
 *
 *  The "params" is a single object that can have the following properties:
 *
 *    prop. name   | description
 *  -------------------------------------------------------------------------------------------------
 *   inputField    | the ID of an input field to store the date
 *   displayArea   | the ID of a DIV or other element to show the date
 *   button        | ID of a button or other element that will trigger the calendar
 *   eventName     | event that will trigger the calendar, without the "on" prefix (default: "click")
 *   ifFormat      | date format that will be stored in the input field
 *   daFormat      | the date format that will be used to display the date in displayArea
 *   singleClick   | (true/false) whether the calendar is in single click mode or not (default: true)
 *   firstDay      | numeric: 0 to 6.  "0" means display Sunday first, "1" means display Monday first, etc.
 *   align         | alignment (default: "Br"); if you don't know what's this see the calendar documentation
 *   range         | array with 2 elements.  Default: [1900, 2999] -- the range of years available
 *   weekNumbers   | (true/false) if it's true (default) the calendar will display week numbers
 *   flat          | null or element ID; if not null the calendar will be a flat calendar having the parent with the given ID
 *   flatCallback  | function that receives a JS Date object and returns an URL to point the browser to (for flat calendar)
 *   disableFunc   | function that receives a JS Date object and should return true if that date has to be disabled in the calendar
 *   onSelect      | function that gets called when a date is selected.  You don't _have_ to supply this (the default is generally okay)
 *   onClose       | function that gets called when the calendar is closed.  [default]
 *   onUpdate      | function that gets called after the date is updated in the input field.  Receives a reference to the calendar.
 *   date          | the date that the calendar will be initially displayed to
 *   todayDate     | the date-time that the calendar will user with the Today button
 *   showsTime     | default: false; if true the calendar will include a time selector
 *   timeFormat    | the time format; can be "12" or "24", default is "12"
 *   electric      | if true (default) then given fields/date areas are updated for each move; otherwise they're updated only on close
 *   step          | configures the step of the years in drop-down boxes; default: 2
 *   position      | configures the calendar absolute position; default: null
 *   cache         | if "true" (but default: "false") it will reuse the same calendar object, where possible
 *   showOthers    | if "true" (but default: "false") it will show days from other months too
 *
 *  None of them is required, they all have default values.  However, if you
 *  pass none of "inputField", "displayArea" or "button" you'll get a warning
 *  saying "nothing to setup".
 */
Calendar.setup = function (params) {
    params = params || {};

	function param_default(pname, def) { if (typeof params[pname] == "undefined") { params[pname] = def; } };

	param_default("inputField",     null);
	param_default("context",        null);
	param_default("displayArea",    null);
	param_default("button",         null);
	param_default("eventName",      "click");
	param_default("ifFormat",       "%Y/%m/%d");
	param_default("daFormat",       "%Y/%m/%d");
	param_default("singleClick",    true);
	param_default("disableFunc",    null);
	param_default("dateStatusFunc", params["disableFunc"]);	// takes precedence if both are defined
	param_default("dateText",       null);
	param_default("firstDay",       null);
	param_default("align",          "Br");
	param_default("range",          [1900, 2999]);
	param_default("weekNumbers",    true);
     /*
     Set this to true if you want to use the ISO 8601 week numbering scheme.  This was the old default.
     But is now the week contain Jan 01 is considered the first week of the year after many customer requests
     so we now useISO8601WeekNumbers is false by default. 
    */
    param_default("useISO8601WeekNumbers",    false);

    param_default("flat",           null);
	param_default("flatCallback",   null);
	param_default("onSelect",       null);
	param_default("onClose",        null);
	param_default("onUpdate",       null);
	param_default("date",           null);
	param_default("todayDate",      null);
	param_default("showsTime",      false);
	param_default("timeFormat",     "24");
	param_default("electric",       true);
	param_default("step",           1);
	param_default("position",       null);
	param_default("cache",          false);
	param_default("showOthers",     false);
	param_default("multiple",       null);

    var i, item;

    // Unwrap jQuery and deal with the base Element.
    var unwrap = ["context", "inputField", "button", "displayArea"];
    for(i in unwrap) {
        item = unwrap[i];
        if (params[item] instanceof jQuery) {
            params[item] = params[item][0];
        }
    }

	var tmp = ["inputField", "displayArea", "button"];
	for (i in tmp) {
        item = tmp[i];
		if (typeof params[item] === "string") {
            /**
             * TODO JDEV-27991: Kill this ID string. The API of Calendar#setup should NOT accept an ID of an element, it should take the element itself.
             * Then there'd be no need to search within a context and do all this stupid stuff.
             */
            var escapedSelector = "#" + params[item].escapejQuerySelector();
            var el = jQuery(params.context || document.body).find(escapedSelector);
            params[item] = el[0];
		}
	}

	if (!(params.flat || params.multiple || params.inputField || params.displayArea || params.button)) {
        /* [logging] */
		AJS.log("Calendar.setup:\n  Nothing to setup (no fields found).  Please check your code");
        /* [logging] end */
		return false;
	}

    if (params.firstDay && params.firstDay !== null) {
        params.firstDay = +params.firstDay; // Convert firstDay from a string to a number
    }

	function onSelect(cal) {
		var p = cal.params;
		var update = (cal.dateClicked || p.electric);
		if (update && p.inputField) {
			p.inputField.value = cal.date.print(p.ifFormat);
            jQuery(p.inputField).change();            
		}
		if (update && p.displayArea)
			p.displayArea.innerHTML = cal.date.print(p.daFormat);
		if (update && typeof p.onUpdate == "function")
			p.onUpdate(cal);
		if (update && p.flat) {
			if (typeof p.flatCallback == "function")
				p.flatCallback(cal);
		}
        if (p.singleClick === "true") {
            p.singleClick = true;
        } else if (p.singleClick === "false") {
            p.singleClick = false;
        }
		if (update && p.singleClick && cal.dateClicked)
			cal.callCloseHandler();
	}

	if (params.flat != null) {
		if (typeof params.flat == "string")
			params.flat = document.getElementById(params.flat);
		if (!params.flat) {
            /* [logging] */
			AJS.log("Calendar.setup:\n  Flat specified but can't find parent.");
            /* [logging] end */
			return false;
		}
		var cal = new Calendar(params.firstDay, params.date, params.todayDate, params.onSelect || onSelect);
		cal.showsOtherMonths = params.showOthers;
		cal.showsTime = params.showsTime;
		cal.time24 = (params.timeFormat == "24");
		cal.params = params;
		cal.weekNumbers = params.weekNumbers;
		cal.setRange(params.range[0], params.range[1]);
		cal.setDateStatusHandler(params.dateStatusFunc);
		cal.getDateText = params.dateText;
		if (params.ifFormat) {
			cal.setDateFormat(params.ifFormat);
		}
		if (params.inputField && typeof params.inputField.value == "string") {
			cal.parseDate(params.inputField.value);
		}
		cal.create(params.flat);
		cal.show();
		return false;
	}

	var triggerEl = params.button || params.displayArea || params.inputField;

    jQuery(triggerEl).bind(params.eventName, function (e) {
        e.preventDefault();
        createCalendar();
    });

    if (params.inputField) {
        enhanceInputField();
    }

    function createCalendar() {
        if  (Calendar._UNSUPPORTED === true) {
            /* [alert] */
            alert("The JIRA Calendar does not currently support your language.");
            /* [alert] end */
            return;
        }
		var dateEl = params.inputField || params.displayArea;
		var dateFmt = params.inputField ? params.ifFormat : params.daFormat;
		var mustCreate = false;
		var cal = window.calendar;
		if (cal) {
			cal.hide();
		}

		if (dateEl) {
            if (dateEl.value || dateEl.innerHTML) {
                params.date = Date.parseDate(dateEl.value || dateEl.innerHTML, dateFmt);
            }
        }

		if (!(cal && params.cache)) {
			window.calendar = cal = new Calendar(params.firstDay,
							     params.date,
				 			     params.todayDate,
							     params.onSelect || onSelect,
							     params.onClose || function(cal) { cal.hide(); });
			cal.showsTime = params.showsTime;
			cal.time24 = (params.timeFormat == "24");
			cal.weekNumbers = params.weekNumbers;
            // BB - At the Date object level not Calendar
            Date.useISO8601WeekNumbers = params.useISO8601WeekNumbers;
            if (params.useISO8601WeekNumbers) {
                // ISO8601 assumes that first day of week is Monday
                cal.firstDayOfWeek = 1;
            }
            mustCreate = true;
		} else {
			if (params.date)
				cal.setDate(params.date);
			cal.hide();
		}
		if (params.multiple) {
			cal.multiple = {};
			for (var i = params.multiple.length; --i >= 0;) {
				var d = params.multiple[i];
				var ds = d.print("%Y%m%d");
				cal.multiple[ds] = d;
			}
		}
		cal.showsOtherMonths = params.showOthers;
		cal.yearStep = params.step;
		cal.setRange(params.range[0], params.range[1]);
		cal.params = params;
		cal.setDateStatusHandler(params.dateStatusFunc);
		cal.getDateText = params.dateText;
		cal.setDateFormat(dateFmt);
		if (mustCreate)
			cal.create();
		cal.refresh();
		if (!params.position)
			cal.showAtElement(params.button || params.displayArea || params.inputField, params.align);
		else
			cal.showAt(params.position[0], params.position[1]);
		return false;
	}

    // UX enhancements for when the calendar is used in conjunction with an input
    function enhanceInputField() {
        var $inputField = jQuery(params.inputField);

        // Prevent interactions with the calendar from blurring input.
        // Since the calendar already prevents default on mousedown inside the calendar popup,
        // this only needs to be done for the trigger button.
        if (params.button) {
            jQuery(params.button).mousedown(function(e) {
                e.preventDefault();

                // Give the inputField focus if it doesn't have it already.
                // Do not attempt to focus a disabled form element.
                if (!$inputField.is(':focus') && $inputField.is(":enabled")) {
                    $inputField.focus();
                }
            });
        }

        $inputField.keydown(function (e) {
            var cal = window.calendar;

            if (e.keyCode === 40) { // Down
                if (!cal || cal.hidden) {
                    // setTimeout is needed so that pressing the down arrow doesn't create the calendar AND cause the date to jump by a week
                    setTimeout(function() {
                        createCalendar();
                    }, 1);
                }
            }
        });
    }

	return cal;
};
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/dropdown/Dropdown.js' */
/**
 * Creates a dropdown list from a JSON object
 *
 * @constructor JIRA.Dropdown
 * @deprecated
 * @author Scott Harwood
 *
 * NOTE: Please use {@link Dropdown} instead of this for future dropdown implementations.
 */
JIRA.Dropdown = (function() {

    // private

    var instances = [];

    return /** @lends JIRA.Dropdown */ {

        // public

        /**
         * Adds this instance to private var <em>instances</em>
         * This reference can be used to access all instances
         */
        addInstance: function() {
            instances.push(this);
        },


        /**
         * Calls the hideList method on all instances of <em>dropdown</em>
         */
        hideInstances: function() {
            var that = this;
            jQuery(instances).each(function(){
                if (that !== this) {
                    this.hideDropdown();
                }
            });
        },


        getHash: function () {
            if (!this.hash) {
                this.hash = {
                    container: this.dropdown,
                    hide: this.hideDropdown,
                    show: this.displayDropdown
                };
            }
            return this.hash;
        },

        /**
         * Calls <em>hideInstances</em> method to hide all other dropdowns.
         * Adds <em>active</em> class to <em>dropdown</em> and styles to make it visible.
         */
        displayDropdown: function() {
            if (JIRA.Dropdown.current === this) {
                return;
            }

            this.hideInstances();
            JIRA.Dropdown.current = this;
            this.dropdown.css({display: "block"});

            this.displayed = true;

            var dd = this.dropdown;
            if (window.top.JIRA && !window.top.JIRA.Dialog.current) {
                setTimeout(function() {
                    // Scroll dropdown into view
                    var win = jQuery(window);
                    var minScrollTop = dd.offset().top + dd.prop("offsetHeight") - win.height() + 10;

                    if (win.scrollTop() < minScrollTop) {
                        jQuery("html,body").animate({scrollTop: minScrollTop}, 300, "linear");
                    }
                }, 100);
            }
        },

        /**
         * Removes <em>active</em> class from <em>dropdown</em> and styles to make it hidden.
         */
        hideDropdown: function() {
            if (this.displayed === false) {
                return;
            }

            JIRA.Dropdown.current = null;
            this.dropdown.css({display: "none"});

            this.displayed = false;
        },

        /**
         * Initialises instance by, applying primary handler, user options and a Internet Explorer hack.
         * @param {HTMLElement} trigger
         * @param {HTMLElement} dropdown
         */
        init: function(trigger, dropdown) {

            var that = this;

            this.addInstance(this);
            this.dropdown = jQuery(dropdown);

            this.dropdown.css({display: "none"});

            // hide dropdown on tab
            jQuery(document).keydown(function(e){
                if(e.keyCode === 9) {
                    that.hideDropdown();
                }
            });

            // this instance is triggered by a method call
            if (trigger.target) {
                jQuery.aop.before(trigger, function(){
                    if (!that.displayed) {
                        that.displayDropdown();
                    }
                });

            // this instance is triggered by a click event
            } else {
                that.dropdown.css("top",jQuery(trigger).outerHeight() + "px");
                trigger.click(function(e){
                    if (!that.displayed) {
                        that.displayDropdown();
                        e.stopPropagation();
                        // lets not follow the link (if it is a link)
                    } else {
                        that.hideDropdown();
                    }
                    e.preventDefault();
                });
            }

            // hide dropdown when click anywhere other than on this instance
            jQuery(document.body).click(function(){
                if (that.displayed) {
                    that.hideDropdown();
                }
            });
        }
    };

})();

/**
 * Standard dropdown constructor
 * @constuctor JIRA.Dropdown.Standard
 * @extends JIRA.Dropdown
 * @param {HTMLElement} trigger
 * @param {HTMLElement} dropdown
 * @return {JIRA.Dropdown} instance
 */
JIRA.Dropdown.Standard = function(trigger, dropdown) {

    /** @lends JIRA.Dropdown.Standard.prototype */
    var that = begetObject(JIRA.Dropdown);
    that.init(trigger, dropdown);

    return that;
};

/**
 * Standard dropdown constructor
 * @constructor JIRA.Dropdown.AutoComplete
 * @extends JIRA.Dropdown
 * @param {HTMLElement} trigger
 * @param {HTMLElement} dropdown
 * @return {Object} - instance
 */
JIRA.Dropdown.AutoComplete = function(trigger, dropdown) {

    /** @lends JIRA.Dropdown.AutoComplete.prototype */
    var that = begetObject(JIRA.Dropdown);

    that.init = function(trigger, dropdown) {

        this.addInstance(this);
        this.dropdown = jQuery(dropdown).click(function(e){
            // lets not hide dropdown when we click on it
            e.stopPropagation();
        });
        this.dropdown.css({display: "none"});

        // this instance is triggered by a method call
        if (trigger.target) {
            jQuery.aop.before(trigger, function(){
                if (!that.displayed) {
                    that.displayDropdown();
                }
            });

        // this instance is triggered by a click event
        } else {
            trigger.click(function(e){
                if (!that.displayed) {
                    that.displayDropdown();
                    e.stopPropagation();
                }
            });
        }

        // hide dropdown when click anywhere other than on this instance
        jQuery(document.body).click(function(){
            if (that.displayed) {
                that.hideDropdown();
            }
        });
    };

    that.init(trigger, dropdown);

    return that;
};

/** Preserve legacy namespace
    @deprecated jira.widget.dropdown */
AJS.namespace("jira.widget.dropdown", null, JIRA.Dropdown);
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/AutoComplete.js' */
define('jira/autocomplete/autocomplete', [
    'jira/ajs/ajax/smart-ajax',
    'jira/util/objects',
    'jquery'
], function(
    SmartAjax,
    Objects,
    jQuery
) {

    /**
     * @class AutoComplete
     * @requires jQuery.aop
     */
    return function() {

        var inFocus;

        /**
         * Calls a callback after specified delay
         * @memberof AutoComplete.prototype
         * @param {Number} l - length of delay in <em>seconds</em>
         * @param {Function} callback - function to call after delay
         */
        var delay = function(callback,l) {
            if (delay.t) {
                clearTimeout(delay.t);
                delay.t = undefined;
            }
            delay.t = setTimeout(callback, l * 1000);
        };

        var INVALID_KEYS = {
              9: true,
             13: true,
             14: true,
             25: true,
             27: true,
             38: true,
             40: true,
            224: true
        };

        return /** @lends AutoComplete.prototype */{

            /**
            * Checks whether a saved version (cached) of the request exists, if not performs a request and saves response,
            * then dispatches saved response to <em>renderSuggestions</em> method.
            *
            * @public
            */
            dispatcher: function() {},


            /**
             * Gets cached response
             *
             * @public
             * @param {String} val
             * @returns {Object}
             */
            getSavedResponse: function() {},

            /**
             * Saves response
             *
             * @public
             * @param {String} val
             * @param {Object} response
             */
            saveResponse: function() {},

            /**
             * Called to render suggestions. Used to define interface only.
             * Rendering is difficult to make generic, best to leave this to extending prototypes.
             *
             * @public
             * @param {Object} res - results object
             */
            renderSuggestions: function() {},

            /**
             * Disables autocomplete. Useful for shared inputs.
             * i.e The selection of a radio button may disable the instance
             * @Public
             */
            disable: function() {
                this.disabled = true;
            },

            /**
             * Enables autocomplete. Useful for shared inputs.
             * i.e The selection of a radio button may disable the instance
             * @Public
             */
            enable: function() {
                this.disabled = false;
            },

            /**
             * Sets instance variables from options object
             * to do: make function create getters and setters
             * @public
             * @param {Object} options
             */
            set: function(options) {
                for (var name in options) {
                    // safeguard to stop looping up the inheritance chain
                    if (options.hasOwnProperty(name)) {
                        this[name] = options[name];
                    }
                }
            },

            /**
             * Adds value to input field
             * @public
             * @param {String} value
             */
            completeField: function(value) {
                if (value) {
                    this.field.val(value).focus();
                    this.field.trigger("change");
                }
            },

            /**
             * Returns the text from the start of the field up to the end of
             * the position where suggestions are generated from.
             */
            textToSuggestionCursorPosition: function () {
                return this.field.val();
            },


            /**
             * An ajax request filter that only allows one request at a time. If there is another it will abort then issue
             * the new request.
             *
             * @param options - jQuery formatted ajax options
             */
            _makeRequest: function (options) {
                var that = this,
                    requestParams = Objects.copyObject(options);

                // if we have we are still waiting for an old request, lets abort it as we are firing a new
                if (this.pendingRequest) {
                    this.pendingRequest.abort();
                }

                requestParams.complete = function () {
                    that.pendingRequest = null;
                };

                requestParams.error = function (xhr) {

                    // We abort stale requests and this subsequently throws an error so we need to check if the request is aborted first.
                    // We detect this using xhr.aborted property for native XHR requests but for "Microsoft.XMLHTTP" we use the status code, which is 0.
                    // Status code is set to 0 when it is an unknown error so sense to fail silently.
                    if (!xhr.aborted && xhr.status !== 0 && options.error) {
                        options.error.apply(this, arguments);
                    }
                };

                return this.pendingRequest = SmartAjax.makeRequest(requestParams);
            },

            /**
             * Allows users to navigate/select suggestions using the keyboard
             * @public
             */
             addSuggestionControls: function(suggestionNodes) {

                // reference to this for closures
                var that = this;

                /**
                 * Make sure the index is within the threshold
                 * Looks ugly! Has to be a better way.
                 * @private
                 * @param {Integer} idx
                 * @param {Integer} max
                 * @return {Integer} valid threshold
                 */
                var evaluateIndex = function(idx, max) {
                    var minBoundary = (that.autoSelectFirst === false) ? -1 : 0;
                    if (that.allowArrowCarousel) {
                        if (idx > max) {
                            return minBoundary;
                        } else if (idx < minBoundary) {
                            return max;
                        } else {
                            return idx;
                        }
                    }
                    else {
                        if (idx > max) {
                            return max;
                        } else if (idx < minBoundary) {
                            that.responseContainer.scrollTop(0);
                            return minBoundary;
                        } else {
                            return idx;
                        }
                    }
                };

                /**
                 * Highlights focused node and removes highlight from previous.
                 * Actual highlight styles to come from css, adding and removing classes here.
                 * @private
                 * @param {Integer} idx - Index of node to be highlighted
                 */
                var setActive = function(idx) {

                        // if nothing is selected, select the first suggestion
                        if (that.selectedIndex !== undefined && that.selectedIndex > -1) {
                            that.suggestionNodes[that.selectedIndex][0].removeClass("active");
                        }
                        that.selectedIndex = evaluateIndex(idx, that.suggestionNodes.length-1);
                        if (that.selectedIndex > -1) {
                            that.suggestionNodes[that.selectedIndex][0].addClass("active");
                        }
                };

                 /**
                  * Checks to see if there is actually a suggestion in focus before attempting to use it
                  * @private
                  * @returns {boolean}
                  */
                 var evaluateIfActive = function() {
                    return that.suggestionNodes && that.suggestionNodes[that.selectedIndex] &&
                           that.suggestionNodes[that.selectedIndex][0].hasClass("active");
                 };


                /**
                 * When the responseContainer (dropdown) is visible listen for keyboard events
                 * that represent focus or selection.
                 * @private
                 * @param {Object} e - event object
                 */
                var keyPressHandler = function(e) {
                    // only use keyboard events if dropdown is visible
                    if (that.responseContainer.is(":visible")) {
                        // if enter key is pressed check that there is a node selected, then hide dropdown and complete field
                        if (e.keyCode === 13) {
                            if (evaluateIfActive() && !that.pendingRequest) {
                                that.completeField(that.suggestionNodes[that.selectedIndex][1]);
                            }
                            e.preventDefault();
                            // hack - stop propagation to prevent dialog from submitting. Looking for eg JIRA.Dropdown.current doesn't work.
                            e.stopPropagation();
                        }
                    }
                };

                /**
                * sets focus on suggestion nodes using the "up" and "down" arrows
                * These events need to be fired on mouseup as modifier keys don't register on keypress
                * @private
                * @param {Object} e - event object
                */
                var keyboardNavigateHandler = function(e) {

                    // only use keyboard events if dropdown is visible
                    if (that.responseContainer.is(":visible")) {

                        // keep cursor inside input field
                        if (that.field[0] !== document.activeElement){
                            that.field.focus();
                        }
                        // move selection down when down arrow is pressed
                        if (e.keyCode === 40) {
                            setActive(that.selectedIndex + 1);
                            if (that.selectedIndex >= 0) {
                                // move selection up when up arrow is pressed
                                var containerHeight = that.responseContainer.height();
                                var bottom = that.suggestionNodes[that.selectedIndex][0].position().top + that.suggestionNodes[that.selectedIndex][0].outerHeight() ;

                                if (bottom - containerHeight > 0){
                                    that.responseContainer.scrollTop(that.responseContainer.scrollTop() + bottom - containerHeight + 2);
                                }
                            } else {
                                that.responseContainer.scrollTop(0);
                            }
                            e.preventDefault();
                        } else if (e.keyCode === 38) {
                            setActive(that.selectedIndex-1);
                            if (that.selectedIndex >= 0) {
                                // if tab key is pressed check that there is a node selected, then hide dropdown and complete field
                                var top = that.suggestionNodes[that.selectedIndex][0].position().top;
                                if (top < 0){
                                    that.responseContainer.scrollTop(that.responseContainer.scrollTop() + top - 2);
                                }
                            }
                            e.preventDefault();
                        } else if (e.keyCode === 9) {
                            if (evaluateIfActive()) {
                                that.completeField(that.suggestionNodes[that.selectedIndex][1]);
                                e.preventDefault();
                            } else {
                                that.dropdownController.hideDropdown();
                            }
                        }
                    }
                };

                if (suggestionNodes.length) {

                    this.selectedIndex = 0;
                    this.suggestionNodes = suggestionNodes;

                    for (var i=0; i < that.suggestionNodes.length; i++) {
                        var eventData = { instance: this, index: i };
                        this.suggestionNodes[i][0]
                            .bind("mouseover", eventData, activate)
                            .bind("mouseout", eventData, deactivate)
                            .bind("click", eventData, complete);
                    }

                    // make sure we don't bind more than once
                    if (!this.keyboardHandlerBinded) {
                        jQuery(this.field).keypress(keyPressHandler);
                        jQuery(this.field).keydown(keyboardNavigateHandler);
                        this.keyboardHandlerBinded = true;
                    }

                    // automatically select the first in the list
                    if(that.autoSelectFirst === false) {
                        setActive(-1);
                    } else {
                        setActive(0);
                    }

                    // sets the autocomplete singleton infocus var to this instance
                    // is used to toggle event propagation. In short, the instance that it is set to will not hide the
                    // dropdown each time you click the input field
                    inFocus = this;
                }

                function activate(event) {
                    if (that.dropdownController.displayed) {
                        setActive(event.data.index);
                    }
                }
                function deactivate(event) {
                    if (event.data.index === 0) {
                        that.selectedIndex = -1;
                    }
                    jQuery(this).removeClass("active");
                }
                function complete(event) {
                    that.completeField(that.suggestionNodes[event.data.index][1]);
                }
            },


            /**
             * Uses jquery empty command, this is VERY important as it unassigns handlers
             * used for mouseover, click events which expose an opportunity for memory leaks
             * @public
             */
            clearResponseContainer: function() {
                this.responseContainer.empty();
                this.suggestionNodes = undefined;
            },

            delay: delay,

            /**
             * Builds HTML container for suggestions.
             * Positions container top position to be that of the field height
             * @public
             */
            buildResponseContainer: function() {
                var inputParent = this.field.parent().addClass('atlassian-autocomplete');
                this.responseContainer = jQuery(document.createElement("div"));
                this.responseContainer.addClass("suggestions");
                this.positionResponseContainer();
                this.responseContainer.appendTo(inputParent);
            },

            positionResponseContainer: function() {
                this.responseContainer.css({ top: this.field.outerHeight() });
            },

            /**
             * Validates the keypress by making sure the field value is beyond the set threshold and the key was either an
             * up or down arrow
             * @public
             * @param {Object} e - event object
             */
            keyUpHandler: (function () {
                function callback() {
                    if (!this.responseContainer) {
                        this.buildResponseContainer();
                    }
                    // send value to dispatcher to check if we have already got the response or if we need to go
                    // back to the server
                    this.dispatcher(this.field.val());
                }

                return function (e) {
                    // only initialises once the field length is past set length
                    if (this.field.val().length >= this.minQueryLength) {
                        // don't do anything if the key pressed is "enter" or "down" or "up" or "right" "left"
                        if (!(e.keyCode in INVALID_KEYS) || (this.responseContainer && !this.responseContainer.is(":visible") && (e.keyCode === 38 || e.keyCode === 40))) {
                            callback.call(this);
                        }
                    }
                    return e;
                };
            })(),

            /**
             * Adds in methods via AOP to handle multiple selections
             * @Public
             */
            addMultiSelectAdvice: function(delim) {

                // reference to this for closures
                var that = this;

                /**
                 * Alerts user if value already exists
                 * @private
                 * @param {String} val - value that already exists, will be displayed in message to user.
                 */
                var alertUserValueAlreadyExists = function(val) {

                    // check if there is an existing alert before adding another
                    if (!alertUserValueAlreadyExists.isAlerting) {

                        alertUserValueAlreadyExists.isAlerting = true;

                        // create alert node and append it to the input field's parent, fade it in then out with a short
                        // delay in between.
                        //TODO: JRA-1800 - Needs i18n!
                        var userAlert = jQuery(document.createElement("div"))
                        .css({"float": "left", display: "none"})
                        .addClass("warningBox")
                        .html("Oops! You have already entered the value <em>" + val + "</em>" )
                        .appendTo(that.field.parent())
                        .show("fast", function(){
                            // display message for 4 seconds before fading out
                            that.delay(function(){
                                userAlert.hide("fast",function(){
                                    // removes element from dom
                                    userAlert.remove();
                                    alertUserValueAlreadyExists.isAlerting = false;
                                });
                            }, 4);
                        });
                    }
                };

              // rather than request the entire field return the last comma seperated value
                jQuery.aop.before({target: this, method: "dispatcher"}, function(innvocation){
                    // matches everything after last comma
                    var val = this.field.val();
                    innvocation[0] = jQuery.trim(val.slice(val.lastIndexOf(delim) + 1));
                    return innvocation;
                });

                // rather than replacing this field just append the new value
                jQuery.aop.before({target: this, method: "completeField"}, function(args){
                    var valueToAdd = args[0],
                    // create array of values
                    untrimmedVals = this.field.val().split(delim);
                    // trim the values in the array so we avoid extra spaces being appended to the usernames - see JRA-20657
                    var trimmedVals = jQuery(untrimmedVals).map(function() {
                            return jQuery.trim(this);
                       }).get();
                    // check if the value to append already exists. If it does then call alert to to tell user and sets
                    // the last value to "". The value to add will either appear:
                    // 1) at the start of the string
                    // 2) after some whitespace; or
                    // 3) directly after the delimiter
                    // It is assumed that the value is delimited by the delimiter character surrounded by any number of spaces.
                    if (!this.allowDuplicates && new RegExp("(?:^|[\\s" + delim + "])" + valueToAdd + "\\s*" + delim).test(this.field.val())) {
                        alertUserValueAlreadyExists(valueToAdd);
                        trimmedVals[trimmedVals.length-1] = "";
                    } else {
                        // add the new value to the end of the array and then an empty value so we
                        // can get an extra delimiter at the end of the joined string
                        trimmedVals[trimmedVals.length-1] = valueToAdd;
                        trimmedVals[trimmedVals.length] = "";
                    }

                    // join the array of values with the delimiter plus an extra space to make the list of values readable
                    args[0] = trimmedVals.join(delim.replace(/([^\s]$)/,"$1 "));

                    return args;
                });
            },


            /**
             * Adds and manages state of dropdown control
             * @Public
             */
            addDropdownAdvice: function() {
                var that = this;

                // add dropdown functionality to response container
                jQuery.aop.after({target: this, method: "buildResponseContainer"}, function(args){
                    this.dropdownController = JIRA.Dropdown.AutoComplete({target: this, method: "renderSuggestions"}, this.responseContainer);

                    jQuery.aop.after({ target: this.dropdownController, method: "hideDropdown" }, function () {
                        this.dropdown.removeClass("dropdown-ready");
                    });

                    return args;
                });

                // display dropdown afer suggestions are updated
                jQuery.aop.after({target: this, method: "renderSuggestions"}, function(args){
                    if (args && args.length > 0) {
                        this.dropdownController.displayDropdown();

                        if (this.maxHeight && this.dropdownController.dropdown.prop("scrollHeight") > this.maxHeight) {
                            this.dropdownController.dropdown.css({
                                height: this.maxHeight,
                                overflowX: "visible",
                                overflowY: "scroll"
                            });
                        } else if (this.maxHeight) {
                            this.dropdownController.dropdown.css({
                                height: "",
                                overflowX: "",
                                overflowY: ""
                            });
                        }
                        this.dropdownController.dropdown.addClass("dropdown-ready");
                    } else {
                        this.dropdownController.hideDropdown();
                    }
                    return args;
                });

                // hide dropdown after suggestion value is applied to field
                jQuery.aop.after({target: this, method: "completeField"}, function(args){
                    this.dropdownController.hideDropdown();
                    return args;
                });

                jQuery.aop.after({target: this, method: "keyUpHandler"}, function(e) {
                    // only initialises once the field length is past set length
                    if ((!(this.field.val().length >= this.minQueryLength) || e.keyCode === 27)
                            && this.dropdownController && this.dropdownController.displayed) {
                        this.dropdownController.hideDropdown();
                        if (e.keyCode === 27) {
                            e.stopPropagation();
                        }
                    }
                    return e;
                });
            },

            /**
             * Initialises autocomplete by setting options, and assigning event handler to input field.
             * @param {Object} options
             * @constructs
             */
            init: function(options) {
                var that = this;
                this.set(options);
                this.field = this.field || jQuery("#" + this.fieldID);
                 // turn off browser default autocomplete
                this.field.attr("autocomplete","off")
                .keyup(function(e){
                    if (!that.disabled) {
                        that.keyUpHandler(e);
                    }
                })
                .keydown(function (e) {
                    var ESC_KEY = 27;
                    // do not clear field in IE
                    if (e.keyCode === ESC_KEY && that.responseContainer && that.responseContainer.is(":visible")) {
                        e.preventDefault();
                    }
                })
                // this will stop the dropdown with the suggestions hiding whenever you click the field
                .click(function(e){
                    if (inFocus === that) {
                        e.stopPropagation();
                    }
                })
                .blur(function () {
                    // we don't want the request to come back and show suggestions if we have already moved away from field
                    if (that.pendingRequest) {
                        that.pendingRequest.abort();
                    }
                });

                this.addDropdownAdvice();

                if (options.delimChar) {
                    this.addMultiSelectAdvice(options.delimChar);
                }
            }
        };

    }();

});

/** Preserve legacy namespace
 @deprecated jira.widget.autocomplete */
AJS.namespace("jira.widget.autocomplete", null, require('jira/autocomplete/autocomplete'));
AJS.namespace('JIRA.AutoComplete', null, require('jira/autocomplete/autocomplete'));
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/RESTAutoComplete.js' */
define('jira/autocomplete/rest-autocomplete', [
    'jira/autocomplete/autocomplete',
    'jira/util/objects'
], function(
    AutoComplete,
    Objects
) {
    /**
     * Designed for prototypical inheritance !!Abstract only
     * @class RESTAutoComplete
     * @extends AutoComplete
     * @abstract
     */
    return function() {

        /** @lends RESTAutoComplete.prototype */
        var that = Objects.begetObject(AutoComplete);

       /**
        * Checks whether a saved version (cached) of the request exists, if not performs a request and saves response,
        * then dispatches saved response to <em>renderSuggestions</em> method.
        * @param {String} reqFieldVal
        */
        that.dispatcher = function(reqFieldVal) {

            // reference to "this" for use in closures
             var that = this;

             if (reqFieldVal.length < this.minQueryLength) {
                 return;
             }

             if (!this.getSavedResponse(reqFieldVal)) {
                // Add a delay so that we don't go the server for every keypress,
                // some people type fast and may have already typed an entire word by the time the server comes
                // back with a response

                this.delay(function(){
                    var params = that.getAjaxParams();
                    params.data.query = reqFieldVal;
                    params.success = function(data){
                        // for use later so we don't have to go back to the server for the same query
                        that.saveResponse(reqFieldVal, data);
                        // creates html elements from JSON object
                        that.responseContainer.scrollTop(0);
                        that.renderSuggestions(data);

                    };
                    that._makeRequest(params);

                }, that.queryDelay);
            } else {
                that.renderSuggestions(that.getSavedResponse(reqFieldVal));
                that.responseContainer.scrollTop(0);
            }
        };


        that.getAjaxParams = function(){};

        /**
         * Gets cached response from <em>requested</em> object
         * @param {String} val
         * @returns {Object}
         */
        that.getSavedResponse = function(val) {
            if (!this.requested) {
                this.requested = {};
            }
            return this.requested[val];
        };

        /**
         * Saves response to <em>requested</em> object
         * @param {String} val
         * @param {Object} response
         */
        that.saveResponse = function(val, response) {
            if (typeof val === "string" && typeof response === "object") {
                if (!this.requested) {
                    this.requested = {};
                }
                this.requested[val] = response;
            }
        };

        return that;

    }();

});

/** Preserve legacy namespace
 @deprecated jira.widget.autocomplete.REST */
AJS.namespace("jira.widget.autocomplete.REST", null, require('jira/autocomplete/rest-autocomplete'));
AJS.namespace('JIRA.RESTAutoComplete', null, require('jira/autocomplete/rest-autocomplete'));
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/IssueAutoComplete.js' */
define('jira/autocomplete/issue-autocomplete', [
    'jira/autocomplete/rest-autocomplete',
    'jira/util/objects',
    'jquery'
], function(
    RESTAutoComplete,
    Objects,
    jQuery
) {
    /**
     * @constructor IssueAutoComplete
     * @extends RESTAutoComplete
     * @param options
     */
    var IssueAutoComplete = function(options) {

        /** @lends IssueAutoComplete.prototype */
        var that = Objects.begetObject(RESTAutoComplete);

        that.getAjaxParams = function(){
            return {
                url: contextPath + "/rest/api/2/issue/picker",
                data: options.ajaxData,
                dataType: "json",
                type: "GET"
            };
        };

        /**
         * @param {Object} response
         */
        that.renderSuggestions = function(response) {

            var resultsContainer, suggestionNodes = [];

            // remove previous results
            this.clearResponseContainer();

            if (response && response.sections && response.sections.length > 0) {

                resultsContainer = jQuery("<ul/>").appendTo(this.responseContainer);

                jQuery(response.sections).each(function() {
                    var section = this;
                    var subSection = jQuery("<div/>").attr("id", options.fieldID + "_s_" + section.id).addClass("yag").text(section.label);
                    if (section.sub){
                        subSection.append(jQuery("<span/>").addClass("yagt").text("(" + section.sub + ")"));
                    }
                    resultsContainer.append(jQuery("<li/>").append(subSection).mouseover(function(){
                            jQuery(this).addClass("active");
                        }).mouseout(function(){
                            jQuery(this).removeClass("active");
                        })
                    );

                    if (section.msg){
                        // add message node
                        var msg = jQuery("<div/>").attr("id", options.fieldID + "_i_" + section.id + "_n").addClass("yad").text(section.msg);
                        resultsContainer.append(jQuery("<li/>").append(msg).mouseover(function(){
                                jQuery(this).addClass("active");
                            }).mouseout(function(){
                                jQuery(this).removeClass("active");
                            })
                        );
                    }

                    if (section.issues && section.issues.length > 0){
                        jQuery(section.issues).each(function(){
                            // add issue
                            var imgUrl;
                            if (/^http/.test(this.img)){
                                imgUrl = this.img;
                            } else {
                                imgUrl =  contextPath + this.img;
                            }
                            var issueNode = jQuery("<li/>").append(
                                jQuery("<div/>").attr("id", options.fieldID + "_i_" + section.id + "_" + this.key).addClass("yad").append(
                                    jQuery("<table/>").addClass("yat").attr({
                                        cellpadding: "0",
                                        cellspacing: "0"
                                    }).append(
                                        jQuery("<tr/>").append(
                                            jQuery("<td/>").append(
                                                jQuery("<img/>").attr("src", imgUrl)
                                            )
                                        ).append(
                                             jQuery("<td/>").append(
                                                jQuery("<div/>").addClass("yak").html(this.keyHtml)
                                            )
                                        ).append(
                                             jQuery("<td/>").css("width", "100%").html(this.summary)
                                        )
                                    )
                                )
                            );

                            resultsContainer.append(issueNode);
                            suggestionNodes.push([issueNode, this.key]);
                        });
                    }
                });

                that.addSuggestionControls(suggestionNodes);

                return suggestionNodes;

            }
        };
        options.minQueryLength = 1;
        options.queryDelay = 0.25;

        that.init(options);

        return that;

    };

    /**
     * Iterates over the entire DOM to find issue autocomplete controls to initialize, and initializes them.
     * @static
     */
    IssueAutoComplete.init = function(){

        jQuery("fieldset.issue-picker-params").each(function(){
            var params = JIRA.parseOptionsFromFieldset(jQuery(this)),
                $container = jQuery("#" + params.fieldId + "-container").add("#" + params.fieldName + "_container");

            $container.find("a.popup-trigger").click(function(e){
                var url = contextPath + '/secure/popups/IssuePicker.jspa?';
                url += 'currentIssue=' + params.currentIssueKey + '&';
                url += 'singleSelectOnly=' + params.singleSelectOnly + '&';
                url += 'showSubTasks=' + params.showSubTasks + '&';
                url += 'showSubTasksParent=' + params.showSubTaskParent;
                if (params.currentProjectId && params.currentProjectId !== "")
                {
                    url += '&selectedProjectId=' + params.currentProjectId;
                }

                /**
                 * Provide a callback to the window for execution when the user selects an issue. This implies that only one
                 * popup can be displayed at a time.
                 *
                 * @param keysMap the issue keys selected.
                 */
                JIRA.IssuePicker.callback = function(keysMap){
                    var $formElement, keys = [];

                    keysMap = JSON.parse(keysMap);

                    if (params.fieldId && keys) {
                        $formElement = jQuery("#" + params.fieldId);
                        if ($formElement){
                            jQuery.each(keysMap, function () {
                                keys.push(this.value);
                            });
                            $formElement.val(keys.join(", "));
                        }
                    }
                };

                var vWinUsers = window.open(url, 'IssueSelectorPopup', 'status=no,resizable=yes,top=100,left=200,width=620,height=500,scrollbars=yes,resizable');
                vWinUsers.opener = self;
                vWinUsers.focus();
                e.preventDefault();
            });

            if (!params.fieldId) {
                params.fieldId = params.fieldName;
            }

            if (params.issuePickerEnabled === true){
                IssueAutoComplete({
                    fieldID: params.fieldId,
                    delimChar: params.singleSelectOnly === true ? undefined : ",",
                    ajaxData: params
                });
            }
        });
    };

    return IssueAutoComplete;
});

/** Preserve legacy namespace
 @deprecated jira.widget.autocomplete.Issues */
AJS.namespace("jira.widget.autocomplete.Issues", null, require('jira/autocomplete/issue-autocomplete'));
AJS.namespace('JIRA.IssueAutoComplete', null, require('jira/autocomplete/issue-autocomplete'));
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/UserAutoComplete.js' */
define('jira/autocomplete/user-autocomplete', [
    'jira/autocomplete/rest-autocomplete',
    'jira/data/parse-options-from-fieldset',
    'jira/util/browser',
    'jira/util/elements',
    'jira/util/objects',
    'jquery'
], function(
    RESTAutoComplete,
    parseOptionsFromFieldset,
    Browser,
    Elements,
    Objects,
    jQuery
) {
    /**
     * User picker - converted from YUI based autocomplete. There is some code in here that probably isn't necessary,
     * if removed though selenium tests would need to be re-written.
     * @class UserAutoComplete
     * @extends RESTAutoComplete
     * @param {Object} options
     */
    var UserAutoComplete = function(options) {

        /** @lends UserAutoComplete.prototype */
        var that = Objects.begetObject(RESTAutoComplete);

        that.getAjaxParams = function(){
            return {
                url: contextPath + "/rest/api/1.0/users/picker",
                data: {
                    fieldName: options.fieldID,
                    fieldConfigId: options.fieldConfigID,
                    projectId: options.projectId
                },
                dataType: "json",
                type: "GET"
            };
        };

        /**
         * Returns true if the field's containing form has the 'submitted' class.
         *
         * @param field The reference to the field whose form to check for the 'submitted' class.
         * @return {Boolean}
         */
        function fieldsFormHasBeenSubmitted(field) {
            var submitting = false,
                form = field.closest("form");

            if (form.length && form.hasClass("submitting")) {
                submitting = true;
            }

            return submitting;
        }

        /**
         * Create html elements from JSON object
         * @param {Object} response - JSON object
         * @returns {Array} Multidimensional array, one column being the html element and the other being its
         * corresponding complete value.
         */
        that.renderSuggestions = function(response) {

            if (fieldsFormHasBeenSubmitted(this.field) || !Browser.isSelenium() && !Elements.elementIsFocused(this.field)) {
                return false;
            }

            var resultsContainer, suggestionNodes = [];

            // remove previous results
            this.clearResponseContainer();


            if (response && response.users && response.users.length > 0) {

                resultsContainer = jQuery("<ul/>").appendTo(this.responseContainer);

                jQuery(response.users).each(function() {

                    // add html element and corresponding complete value  to sugestionNodes Array
                    suggestionNodes.push([jQuery("<li/>")
                    .html(this.html)
                    .appendTo(resultsContainer), this.name]);

                });
            }

            if (response.footer) {
                this.responseContainer.append(jQuery("<div/>")
                .addClass("yui-ac-ft")
                .html(response.footer)
                .css("display","block"));
            }

            if (suggestionNodes.length > 0) {
                that.addSuggestionControls(suggestionNodes);
                jQuery('.atlassian-autocomplete div.yad, .atlassian-autocomplete .labels li').textOverflow({
                    autoUpdate: true
                });
            }

            return suggestionNodes;

        };

        // Use autocomplete only once the field has at least 2 characters
        options.minQueryLength = 2;

        // wait 1/4 of after someone starts typing before going to server
        options.queryDelay = 0.25;

        that.init(options);

        return that;

    };

    /**
     * Searches for and initialises User autocomplete controls within a DOM context.
     * @param {HTMLElement|String} [parent] - element or CSS selector within which
     * autocomplete controls will be searched for. Defaults to entire DOM.
     * @static
     */
    UserAutoComplete.init = function(parent){
        jQuery("fieldset.user-picker-params", parent).each(function(){
            var params = parseOptionsFromFieldset(jQuery(this)),
                field = (params.fieldId || params.fieldName),
                $container = jQuery("#" + field + "_container");


            $container.find("a.popup-trigger").click(function(e){
                var url = contextPath,
                    vWinUsers;

                e.preventDefault();

                if (!params.formName)
                {
                    params.formName = $container.find("#" + field).parents("form").attr("name");
                }

                if (params.actionToOpen) {
                    url = url + params.actionToOpen;
                } else {
                    url = url + '/secure/popups/UserPickerBrowser.jspa';
                }
                url += '?formName=' + params.formName + '&';
                url += 'multiSelect=' + params.multiSelect + '&';
                url += 'decorator=popup&';
                url += 'element=' + field;

                if (params.fieldConfigId) {
                    url += '&fieldConfigId=' + params.fieldConfigId;
                }
                if (params.projectId) { // an array of project ids
                    if (jQuery.isArray(params.projectId)) {
                        for (var projectId in params.projectId) {
                            url += '&projectId=' + projectId;
                        }
                    } else {
                        url += '&projectId=' + params.projectId;
                    }
                }

                vWinUsers = window.open(url, 'UserPicker', 'status=yes,resizable=yes,top=100,left=100,width=800,height=750,scrollbars=yes');
                vWinUsers.opener = self;
                vWinUsers.focus();
            });


            if (params.userPickerEnabled === true ){
                UserAutoComplete({
                    field: parent ? parent.find("#" + field) : null,
                    fieldID: field,
                    fieldConfigID: params.fieldConfigId,
                    projectId: params.projectId,
                    delimChar: params.multiSelect === false ? undefined : ",",
                    ajaxData: {
                        fieldName: params.fieldName
                    }
                });
            }
        });
    };

    return UserAutoComplete;
});

/** Preserve legacy namespace
    @deprecated jira.widget.autocomplete.Users */
AJS.namespace("jira.widget.autocomplete.Users", null, require('jira/autocomplete/user-autocomplete'));
AJS.namespace('JIRA.UserAutoComplete', null, require('jira/autocomplete/user-autocomplete'));
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/initAutoCompleteFields.js' */
(function() {
    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            JIRA.UserAutoComplete.init(context);
            JIRA.IssueAutoComplete.init(context);
        }
    });

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            AJS.$("fieldset.user-searcher-params", context).each(function () {
                var params = JIRA.parseOptionsFromFieldset(AJS.$(this)),
                    $container = AJS.$("#" + params.fieldId + "_container", context);

                if (params.userPickerEnabled === true) {
                    var autocompleter = JIRA.UserAutoComplete({
                        fieldID: params.fieldId,
                        delimChar: params.multiSelect === true ? "," : undefined,
                        ajaxData: {
                            fieldName: params.fieldName
                        }
                    });
                }

                var setupFields = function (related) {
                    var field = AJS.$("#" + params.fieldId, context);
                    var userImage = AJS.$("#" + params.fieldId + "Image", context);
                    var groupImage = AJS.$("#" + params.fieldId + "GroupImage", context);
                    var fieldDesc = AJS.$("#" + params.fieldId + "_desc", context);
                    if (related === "select.list.none") {
                        field.val("").attr("disabled", "true");
                        userImage.hide();
                        groupImage.hide();
                        fieldDesc.hide();
                    } else {
                        field.removeAttr("disabled");
                        if (related === "select.list.group") {
                            userImage.hide();
                            groupImage.show();
                            if (params.userPickerEnabled === true) {
                                autocompleter.disable();
                                fieldDesc.hide();
                            }
                        } else {
                            userImage.show();
                            groupImage.hide();
                            if (params.userPickerEnabled === true) {
                                autocompleter.enable();
                                fieldDesc.show();
                            }
                        }
                    }
                };

                AJS.$("#" + params.userSelect, context).change(function () {
                    var related = AJS.$(this).find("option:selected").attr("rel");
                    setupFields(related);
                }).find("option:selected").each(function () {
                    setupFields(AJS.$(this).attr("rel"));
                });

                $container.find("a.user-popup-trigger").click(function (e) {
                    var url = contextPath + '/secure/popups/UserPickerBrowser.jspa?';
                    url += 'formName=' + params.formName + '&';
                    url += 'multiSelect=' + params.multiSelect + '&';
                    url += 'decorator=popup&';
                    url += 'element=' + params.fieldId;

                    var vWinUsers = window.open(url, 'UserPicker', 'status=yes,resizable=yes,top=100,left=100,width=800,height=750,scrollbars=yes');
                    vWinUsers.opener = self;
                    vWinUsers.focus();
                    e.preventDefault();
                });

                $container.find("a.group-popup-trigger").click(function (e) {
                    var url = contextPath + '/secure/popups/GroupPickerBrowser.jspa?';
                    url += 'formName=' + params.formName + '&';
                    url += 'multiSelect=' + params.multiSelect + '&';
                    url += 'decorator=popup&';
                    url += 'element=' + params.fieldId;

                    var vWinUsers = window.open(url, 'GroupPicker', 'status=yes,resizable=yes,top=100,left=100,width=800,height=750,scrollbars=yes');
                    vWinUsers.opener = self;
                    vWinUsers.focus();
                    e.preventDefault();
                });
            });
        }
    });
})();
;
;
/* module-key = 'jira.webresources:group-label-lozenge', location = '/includes/jira/admin/group-browser/group-label-lozenge.js' */
define('jira/admin/group-browser/group-label-lozenge', [
    'jquery',
    'jira/skate'
], function(
    $,
    skate
) {
    skate('group-label-lozenge', {
        type: skate.type.CLASSNAME,
        attached: function(element) {
            $(element).tooltip({gravity: 'w', html: true});
        }
    });
});
;
;
/* module-key = 'jira.webresources:group-label-lozenge', location = '/includes/jira/admin/group-browser/group-label-lozenge.soy' */
// This file was automatically generated from group-label-lozenge.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }


JIRA.Templates.groupLabelLozenge = function(opt_data, opt_ignored) {
  return '' + aui.lozenges.lozenge({text: opt_data.label.text, title: opt_data.label.title, isSubtle: true, extraClasses: 'group-label-lozenge'});
};
if (goog.DEBUG) {
  JIRA.Templates.groupLabelLozenge.soyTemplateName = 'JIRA.Templates.groupLabelLozenge';
}
;
;
/* module-key = 'jira.webresources:groupbrowser', location = '/includes/jira/admin/group-browser/group-browser.js' */
require([
    'jquery',
    'jira/admin/group-browser/group-label-lozenge'
], function(
    $
) {
    $(function(){
        $(".operations-list .aui-button[disabled]").tooltip({gravity: 'e', html: false});
    });
});;
;
/* module-key = 'jira.webresources:group-pickers', location = '/includes/jira/field/groupPickerUtil.js' */
    JIRA.GroupPickerUtil = {
        formatResponseWithLabels: function(data) {
            return JIRA.GroupPickerUtil.formatResponse(data, true);
        },

        formatResponse: function (data, showLabels) {
            var ret = [];

            var template = showLabels ? JIRA.Templates.GroupPickerUtil.formatResponseWithLabels :
                                        JIRA.Templates.GroupPickerUtil.formatResponse;

            AJS.$(data).each(function(i, suggestions) {

                var groupDescriptor = new AJS.GroupDescriptor({
                    weight: i, // order or groups in suggestions dropdown
                    label: suggestions.header
                });
                AJS.$(suggestions.groups).each(function(){
                        groupDescriptor.addItem(new AJS.ItemDescriptor({
                            value: this.name, // value of item added to select
                            label: this.name, // title of lozenge
                            title: this.name, // tooltip
                            html: template(this),
                            highlighted: true
                        }));
                });

                ret.push(groupDescriptor);
            });

            return ret;
        }
    };
;
;
/* module-key = 'jira.webresources:group-pickers', location = '/includes/jira/field/templates/groupPickerUtil.soy' */
// This file was automatically generated from groupPickerUtil.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.GroupPickerUtil.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.GroupPickerUtil == 'undefined') { JIRA.Templates.GroupPickerUtil = {}; }


JIRA.Templates.GroupPickerUtil.formatResponseWithLabels = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.GroupPickerUtil.formatResponse(soy.$$augmentMap(opt_data, {showLabels: true}));
};
if (goog.DEBUG) {
  JIRA.Templates.GroupPickerUtil.formatResponseWithLabels.soyTemplateName = 'JIRA.Templates.GroupPickerUtil.formatResponseWithLabels';
}


JIRA.Templates.GroupPickerUtil.formatResponse = function(opt_data, opt_ignored) {
  var output = '<div class="group-suggestion-item"><span class="group-suggestion-item__name">' + soy.$$filterNoAutoescape(opt_data.html) + '</span>';
  if (opt_data.showLabels) {
    output += '<span class="group-suggestion-item__labels group-labels-lozenges">';
    var labelList13 = opt_data.labels;
    var labelListLen13 = labelList13.length;
    for (var labelIndex13 = 0; labelIndex13 < labelListLen13; labelIndex13++) {
      var labelData13 = labelList13[labelIndex13];
      output += JIRA.Templates.groupLabelLozenge({label: labelData13}) + ' ';
    }
    output += '</span>';
  }
  output += '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.GroupPickerUtil.formatResponse.soyTemplateName = 'JIRA.Templates.GroupPickerUtil.formatResponse';
}
;
;
/* module-key = 'jira.webresources:group-pickers', location = '/includes/jira/field/initMultiGroupPickers.js' */
(function () {

    function initMultiGroupPickers(ctx) {
        ctx.find('.js-default-multi-group-picker').each(function () {
            var $el = jQuery(this);
            var showLabels = $el.data("show-labels") === true;
            var userName = $el.data("user-name");
            new AJS.MultiSelect({
                element: this,
                itemAttrDisplayed: "label",
                showDropdownButton: false,
                ajaxOptions:  {
                    data: function (query) {
                        return {
                            userName: userName,
                            query: query,
                            exclude: $el.val()
                        };
                    },
                    url: contextPath + "/rest/api/2/groups/picker",
                    query: true, // keep going back to the sever for each keystroke
                    formatResponse: showLabels ? JIRA.GroupPickerUtil.formatResponseWithLabels :
                                                JIRA.GroupPickerUtil.formatResponse
                }
            });
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initMultiGroupPickers(context);
        }
    });

})();
;
;
/* module-key = 'jira.webresources:group-pickers', location = '/includes/jira/field/initSingleGroupPickers.js' */
(function () {
    var SingleSelect = require('jira/ajs/select/single-select');

    function initSingleGroupPickers(ctx) {
        ctx.find('.js-default-single-group-picker').each(function () {
            var $el = jQuery(this);
            var $emptyValue = $el.find('option[data-empty]');
            var showLabels = $el.data("show-labels") === true;
            var userName = $el.data("user-name");
            new SingleSelect({
                element: this,
                itemAttrDisplayed: "label",
                revertOnInvalid: true,
                ajaxOptions:  {
                    data: function (query) {
                        return {
                            userName: userName,
                            query: query,
                            exclude: $el.val()
                        };
                    },
                    url: contextPath + "/rest/api/2/groups/picker",
                    query: true, // keep going back to the sever for each keystroke
                    formatResponse: function(data) {
                        var formattedData = JIRA.GroupPickerUtil.formatResponse(data, showLabels);
                        if ($emptyValue.length && $el.val() !== '') {
                            formattedData.unshift(new AJS.ItemDescriptor({
                                value: '',
                                label: $emptyValue.text(),
                                highlighted:true
                            }));
                        }
                        return formattedData;
                    }
                }
            });
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initSingleGroupPickers(context);
        }
    });

})();
;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/userPickerUtil.js' */
(function ($) {

    JIRA.UserPickerUtil = {

        formatResponse: function (data) {

            var ret = [];

            $(data).each(function(i, suggestions) {

                var groupDescriptor = new AJS.GroupDescriptor({
                    weight: i, // order or groups in suggestions dropdown
                    label: suggestions.footer
                });

                $(suggestions.users).each(function(){
                    groupDescriptor.addItem(new AJS.ItemDescriptor({
                        value: this.name, // value of item added to select
                        label: this.displayName, // title of lozenge
                        html: this.html,
                        icon: this.avatarUrl,
                        allowDuplicate: false,
                        highlighted: true
                    }));
                });
                ret.push(groupDescriptor);
            });
            return ret;
        }

    };

})(AJS.$);

;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/initSingleUserPickers.js' */
(function ($) {

    function createSingleUserPickers(ctx) {

        var restPath = "/rest/api/1.0/users/picker";

        $(".js-default-user-picker", ctx).each(function () {
            var $this = $(this);
            if ($this.data("aui-ss")) return;
            var data = {showAvatar: true},
                inputText = $this.data('inputValue');

            new AJS.SingleSelect({
                element: $this,
                submitInputVal: true,
                showDropdownButton: !!$this.data('show-dropdown-button'),
                errorMessage: AJS.format("There is no user \'\'{0}\'\'.", "'{0}'"),
                ajaxOptions: {
                    url: contextPath + restPath,
                    query: true, // keep going back to the sever for each keystroke
                    data: data,
                    formatResponse: JIRA.UserPickerUtil.formatResponse
                },
                inputText: inputText
            });
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            createSingleUserPickers(context);
        }
    });

})(AJS.$);



;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/NoBrowseUserNamePicker.js' */
    /**
     * Caters for addition of users in frotherized MultiSelect inputs when the user
     * does not have the Browse User permission.
     *
     * Whilst this control could potentially give away valid usernames it is not new in this behaviour.
     * The old-style user picker used in the Edit Issue form will reveal if a particular username is invalid or not.
     * @class
     * @extends MultiSelect
     */
    AJS.NoBrowseUserNamePicker = AJS.MultiSelect.extend({

        /**
         * Use the User REST interface to attempt to get a user by username.
         */
        _getDefaultOptions: function () {
            return AJS.$.extend(true, this._super(), {
                errorMessage: "The requested user does not exist.",
                showDropdownButton: false,
                removeOnUnSelect: true,
                itemAttrDisplayed: "label"
            });
        },

        /**
         * Override to prevent requesting per keypress.
         *
         * NoBrowseUserNamePicker does not send a request per keypress.
         * Instead it will request for validity when enter or space is pressed
         * or when the field is blurred.
         */
        _handleCharacterInput: function() {
            //this.hideErrorMessage();
        },

        /**
         * Prevents the display of Suggestions for this control.
         *
         * We don't want any suggestions for the NoBrowseUserNamePicker
         * as the user using doesn't have access to see a list of users.
         * Also, using this REST enpoint will not retrieve a list of users anyway.
         */
        _setSuggestions: function() {},

        /**
         * Handles an error from the REST endpoint.
         *
         * The REST endpoint used for this operation returns a 404 if the user requested
         * does not exist. This situation is handled here.
         *
         * If any other error is returned the parent's error handler will be used.
         *
         * @param smartAjaxResult The error.
         */
        _handleServerError: function(smartAjaxResult) {
            if (smartAjaxResult.status === 404) {
                this.showErrorMessage();
            } else {
                this._super();
            }
        },

        /**
         * Called when the field is blurred.
         *
         * When the field is deactivated (i.e. blurred) we want to issue a
         * request to check if the currently entered username (if any) is valid or not.
         */
        _deactivate: function() {
            this.validateAndAdd();
        },

        /**
         * Issues a request to the User REST endpoint with the current field value.
         *
         * Hides any existing error messages before issuing a request to the User endpoint
         * to determine the validity of the current input.
         */
        validateAndAdd: function() {
            var instance = this;
            if (AJS.$.trim(this.$field.val()) === "") {
                this.hideErrorMessage();
            } else {
                jQuery.ajax({
                    url: contextPath + "/rest/api/2/user",
                    data: {
                        username: AJS.$.trim(instance.getQueryVal())
                    },
                    success: function (user) {
                        instance.hideErrorMessage();
                        instance.$field.val("");
                        instance.addItem(new AJS.ItemDescriptor({
                            label: user.displayName,
                            value: user.name
                        }));
                    },
                    error: function () {
                        instance.showErrorMessage();
                    }
                });
            }
        },

        /**
         * Sends a request to the REST endpoint using the currently entered username (if any)
         * when space is pressed.
         *
         * This allows for quick entry of usernames.
         *
         * If the username is not valid the space keypress event is prevented and an error message
         * displayed.
         */
        _handleSpace: function() {
            this.validate();
        },

        /**
         * Transforms the successfully returned username into a Lozenge.
         *
         * @param data The successfully selected username.
         */
        _handleServerSuggestions: function() {
            this.hideErrorMessage();
            this.handleFreeInput();
        },

        /**
         * Adds the current user input as a lozenge.
         *
         * By this time the input has been validated as a username.
         * If the input is not a valid username the response comes back as a
         * 404 triggering _handleServerError.
         */
        handleFreeInput: function() {
            var value = AJS.$.trim(this.$field.val());

            if (value !== "") {
                this.addItem({ value: value, label: value });
                this.model.$element.trigger("change");
            }

            this.$field.val("");
        },

        keys: {
            /**
             * Issue a request for the currently entered username when Return is pressed.
             *
             * @param event The aui:keypress event.
             */
            "Return": function(event) {
                event.preventDefault();
                this.validateAndAdd();
            },

            /**
             * Issue a request for the currently entered username when the Spacebar is pressed.
             *
             * @param event The aui:keypress event.
             */
            "Spacebar": function(event) {
                event.preventDefault();
                this.validateAndAdd();
            }
        }
    });
;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/initMultiUserPickers.js' */
(function () {

    function initMultiUserPicker(ctx) {
        ctx.find(".js-default-multi-user-picker").each(function () {
            var $el = jQuery(this);
            if (AJS.params.currentUserCanBrowseUsers) {
                new AJS.MultiSelect({
                    element: this,
                    itemAttrDisplayed: "label",
                    showDropdownButton: false,
                    removeOnUnSelect: true,
                    submitInputVal: true,
                    ajaxOptions: {
                        url: contextPath + "/rest/api/1.0/users/picker",
                        query: true, // keep going back to the sever for each keystroke
                        data: function (query) {
                            return {
                                showAvatar: true,
                                query: query,
                                exclude: $el.val()
                            };
                        },
                        formatResponse: JIRA.UserPickerUtil.formatResponse
                    }
                });
            } else {
                new AJS.NoBrowseUserNamePicker({
                    element: this
                });
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initMultiUserPicker(context);
        }
    });

})();
;
;
/* module-key = 'jira.webresources:ie-imitation-placeholder', location = '/includes/jira/field/IEImitationPlaceholder.js' */
/**
 * Temporary functionality to allow HTML5 input placeholder text
 * functionality in IE.
 *
 * Please remove this file if/when IE supports placeholder.
 */
(function($) {
    $.fn.ieImitationPlaceholder = function () {
        if ($.browser.msie) {
            var form = this,
                fields = form.find("[placeholder]");

            fields.focus(clearTextIfUnchanged);
            fields.blur(setTextFromPlaceholder);
            form.submit(clearAllIfUnchanged);

            fields.each(setTextFromPlaceholder);

            function setTextFromPlaceholder() {
                var field = $(this);
                if (field.val() === "") {
                    field.val(field.attr("placeholder"));
                    field.addClass("input-placeholder");
                }
            }

            function clearTextIfUnchanged() {
                var field = $(this);
                if (field.val() === field.attr("placeholder")) {
                    field.val("");
                    field.removeClass("input-placeholder");
                }
            }

            function clearAllIfUnchanged() {
                fields.each(clearTextIfUnchanged);
            }
        }
    };
})(AJS.$);
;
;
/* module-key = 'jira.webresources:jira-project-issuetype-fields', location = '/includes/jira/field/ProjectIssueTypeSelect.js' */
    /**
     * @class
     * @extends Class
     */
    JIRA.ProjectIssueTypeSelect = Class.extend({

        init: function (options) {

            var val,
                instance = this;

            this.$project = options.project;

            this.issueTypeSelect = options.issueTypeSelect;
            this.$projectIssueTypesSchemes = options.projectIssueTypesSchemes;
            this.$issueTypeSchemeIssueDefaults = options.issueTypeSchemeIssueDefaults;
            this.projectIssueTypeSchemes = JSON.parse(this.$projectIssueTypesSchemes.html());
            this.issueTypesSchemeDefaults = JSON.parse(this.$issueTypeSchemeIssueDefaults.html() || '[]');

            //may not have a project select on the edit issue page!
            if(instance.$project.length > 0) {
                val = instance.$project.val();
                instance.setIssueTypeScheme(instance.getIssueTypeSchemeForProject(val));

                this.$project.change(function () {
                    var val = instance.$project.val();
                    instance.setIssueTypeScheme(instance.getIssueTypeSchemeForProject(val));
                });
            }
        },

        getIssueTypeSchemeForProject: function (projectId) {
            return this.projectIssueTypeSchemes[projectId];
        },

        getDefaultIssueTypeForScheme: function (issueTypeSchemeId) {
            return this.issueTypesSchemeDefaults[issueTypeSchemeId];
        },

        setIssueTypeScheme: function (issueTypeSchemeId) {
            var selectedIssueType = this.issueTypeSelect.model.getValue();

            this.issueTypeSelect.model.setFilterGroup(issueTypeSchemeId);

            //retain value if possible, if not set default value
            //we set selection using model method since this change doesn't deal with dropdown
            if (!this.issueTypeSelect.model.setSelected(selectedIssueType, false)) {
                this.setDefaultIssueType(issueTypeSchemeId);
            }

            this.issueTypeSelect.model.$element.data('project',this.$project.val());
        },
        /**
         * Sets the default issue type for given issue type scheme.
         * If there is no default issue type in model set the first one
         *
         * @param {string} issueTypeSchemeId id of the issue type scheme
         */
        setDefaultIssueType: function (issueTypeSchemeId) {
            var defaultIssueType = this.getDefaultIssueTypeForScheme(issueTypeSchemeId),
                descriptor = this.issueTypeSelect.model.getDescriptor(defaultIssueType);

            if (!descriptor) {
                descriptor = this.issueTypeSelect.model.getAllDescriptors()[0];
            }
            this.issueTypeSelect.setSelection(descriptor,false);
        }
    });;
;
/* module-key = 'jira.webresources:jira-project-issuetype-fields', location = '/includes/jira/field/initProjectIssueTypeSelect.js' */
(function () {

    var SuggestionCollectionModel = require('jira/ajs/select/suggestion-collection-model');

    function findProjectAndIssueTypeSelectAndConvertToPicker(ctx) {
        var $ctx = ctx || jQuery("body");

        $ctx.find(".issuetype-field").each(function (index) {
            var $project = $ctx.find(".project-field, .project-field-readonly"),
                $issueTypeSelect = jQuery(this),
                $projectIssueTypes = $ctx.find("#" + $issueTypeSelect.attr('id') + '-projects'),
                $defaultProjectIssueTypes = $ctx.find("#" + $issueTypeSelect.attr('id') + '-defaults'),
                issueTypeSelect = new AJS.SingleSelect({
                    element: $issueTypeSelect,
                    revertOnInvalid: true,
                    model: SuggestionCollectionModel
                });

            // Remove redundant "please select" option
            issueTypeSelect.model.remove("");

            //if there is accompanied project field link them together
            if ($project.length > 0) {
                new JIRA.ProjectIssueTypeSelect({
                    project: $project.eq(index), //link correct project field in case of multiple project fields
                    issueTypeSelect: issueTypeSelect,
                    projectIssueTypesSchemes: $projectIssueTypes,
                    issueTypeSchemeIssueDefaults: $defaultProjectIssueTypes
                });
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            findProjectAndIssueTypeSelectAndConvertToPicker(context);
        }
    });

})();;
;
/* module-key = 'jira.webresources:jira-project-issuetype-fields', location = '/includes/jira/field/initIssueTypePickers.js' */
/**
 * Initialises issuetype picker frother fields
 *
 * @deprecated All initialization of issue type fields has been moved to initProjectIssueTypeSelect.
 */

(function () {

    function createissueTypePicker(context) {
        context.find(".issuetype-field").each(function () {

            var $select = jQuery(this);

            // Remove redundant "please select" option
            $select.bind("reset", function () {
                $select.find("option[value='']").remove();
            }).trigger("reset");

            new AJS.SingleSelect({
                element: this,
                revertOnInvalid: true
            });

        });
    }
})();

;
;
/* module-key = 'jira.webresources:jira-project-issuetype-fields', location = '/includes/jira/field/initProjectPickers.js' */
/**
 * Initialises project picker frother fields
 *
 * Please not that project fields interact with issue type fields in create issue. This interation is handled in
 * initIssueTypeSelect.js
 */
(function() {
    var ScrollableSingleSelect = require('jira/ajs/select/scrollable-single-select');
    var SuggestionCollectionModel = require('jira/ajs/select/suggestion-collection-model');

    function createProjectPicker(context) {
        context.find(".project-field").each(function () {
            new ScrollableSingleSelect({
                element: this,
                revertOnInvalid: true,
                pageSize: 50,
                pagingThreshold: 100,
                model: SuggestionCollectionModel
            });
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            createProjectPicker(context);
        }
    });

})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/field-templates.soy' */
// This file was automatically generated from field-templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Fields.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Fields == 'undefined') { JIRA.Templates.Fields = {}; }


JIRA.Templates.Fields.username = function(opt_data, opt_ignored) {
  return '' + ((opt_data.escape) ? soy.$$escapeHtml(opt_data.displayName) : soy.$$filterNoAutoescape(opt_data.displayName));
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.username.soyTemplateName = 'JIRA.Templates.Fields.username';
}


JIRA.Templates.Fields.recipientUsername = function(opt_data, opt_ignored) {
  return '<li data-username="' + soy.$$escapeHtml(opt_data.username) + '" title=' + soy.$$escapeHtml(opt_data.username) + '><span><span class="user-hover" rel="' + soy.$$escapeHtml(opt_data.username) + '"><img alt="" src="' + soy.$$escapeHtml(opt_data.icon) + '" title="' + JIRA.Templates.Fields.username(opt_data) + '"><span title="' + JIRA.Templates.Fields.username(opt_data) + '">' + JIRA.Templates.Fields.username(opt_data) + '</span></span>' + ((! opt_data.readOnly) ? '<button type="button" class="remove-recipient item-delete"><span class="icon-default aui-icon aui-icon-small aui-iconfont-delete">' + soy.$$escapeHtml(AJS.format("Remove watcher: {0}",opt_data.username)) + '</span></button>' : '') + '</span></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.recipientUsername.soyTemplateName = 'JIRA.Templates.Fields.recipientUsername';
}


JIRA.Templates.Fields.recipientEmail = function(opt_data, opt_ignored) {
  return '<li data-email="' + soy.$$escapeHtml(opt_data.email) + '" title=' + soy.$$escapeHtml(opt_data.email) + '><span><img src="' + soy.$$escapeHtml(opt_data.icon) + '" title="' + soy.$$escapeHtml(opt_data.email) + '"><span title="' + soy.$$escapeHtml(opt_data.email) + '">' + soy.$$escapeHtml(opt_data.email) + '</span><span class="remove-recipient item-delete"><span class="icon-default aui-icon aui-icon-small aui-iconfont-delete"></span></span></span></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.recipientEmail.soyTemplateName = 'JIRA.Templates.Fields.recipientEmail';
}
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/IssuePicker.js' */
define('jira/field/issue-picker', [
    'jira/ajs/select/multi-select',
    'jira/ajs/list/group-descriptor',
    'jira/ajs/list/item-descriptor',
    'jquery'
], function(
    MultiSelect,
    GroupDescriptor,
    ItemDescriptor,
    jQuery
) {
    /**
     * A multiselect list for querying and selecting issues. Issues can also be selected via a popup.
     *
     * @class IssuePicker
     * @extends MultiSelect
     */
    var IssuePicker = MultiSelect.extend({

        /**
         *
         * Note: We could probably have the server return in a format that can be digested by appendOptionsFromJSON, but
         * we currently have a legacy issue picker that uses the same end point.
         *
         * @param {Object} response
         */
        _formatResponse: function (response) {
            var ret = [],
                canonicalBaseUrl = (function(){
                    var uri = parseUri(window.location);
                    return uri.protocol + "://" + uri.authority;
                })();

            if (response && response.sections) {

                jQuery(response.sections).each(function(i, section) {

                    var groupDescriptor = new GroupDescriptor({
                        weight: i, // order or groups in suggestions dropdown
                        label: section.label, // Heading of group
                        description: section.sub // description for the group heading
                    });

                    if (section.issues && section.issues.length > 0){

                        jQuery(section.issues).each(function(){

                            groupDescriptor.addItem(new ItemDescriptor({
                                highlighted: true,
                                value: this.key, // value of item added to select
                                label: this.key + " - " + this.summaryText, // title of lozenge
                                icon: this.img ? canonicalBaseUrl + contextPath + this.img : null, // Need to have the canonicalBaseUrl for IE7 to avoid mixed content warnings when viewing the issuepicker over https
                                html: this.keyHtml + " - " + this.summary // html used in suggestion
                            }));
                        });
                    }

                    ret.push(groupDescriptor);

                });
            }

            return ret;
        },


        /**
         * Gets default options
         *
         * @protected
         * @return {Object}
         */
        _getDefaultOptions: function () {
            return jQuery.extend(true, this._super(), {
                ajaxOptions: {
                    formatResponse: this._formatResponse
                }
            });
        },

        /**
         * Launches a popup window, where issues can be fixed based on filter/history and current search. Installs
         * a callback in the current window that can be used by the popup window to add items to the control.
         *
         * @override
         */
        _launchPopup: function () {

            function getWithDefault(value, def) {
                if(value == null){
                    return def;
                } else {
                    return value;
                }
            }

            var url, urlParam, vWinUsers, options, instance = this;

            IssuePicker.callback = function (items) {
                if (typeof items === "string") {
                    items = JSON.parse(items);
                }
                instance._addMultipleItems(items, true);
                instance.$field.focus();
            };

            options = this.options.ajaxOptions.data;
            url = contextPath + '/secure/popups/IssuePicker.jspa?';
            urlParam = {
                singleSelectOnly: "false",
                decorator: "popup",
                currentIssue: options.currentIssueKey || "",
                showSubTasks: getWithDefault(options.showSubTasks, false),
                /* Note the slightly different option name here showSubTasksParent vs. showSubTaskParent */
                showSubTasksParent: getWithDefault(options.showSubTaskParent, false)
            };

            if (options.currentProjectId) {
                urlParam["currentProjectId"] = options.currentProjectId;
            }

            url += jQuery.param(urlParam);

            vWinUsers = window.open(url, 'IssueSelectorPopup', 'status=no,resizable=yes,top=100,left=200,width=' + this.options.popupWidth + ',height=' + this.options.popupHeight + ',scrollbars=yes,resizable');
            vWinUsers.opener = self;
            vWinUsers.focus();
        },

        /**
         * Adds popup link next to picker and assigns event to open popup window
         *
         * @param {Boolean} disabled - Adds a standard text box instead of ajax picker if set to true
         * @override
         */
        _createFurniture: function (disabled) {
            var $popupLink;

            this._super(disabled);

            $popupLink = this._render("popupLink");

            this._assignEvents("popupLink", $popupLink);
            this.$container.addClass('jira-issue-picker');
            this.$container.addClass('hasIcon');
            this.$container.after($popupLink);

        },

        handleFreeInput: function() {
            var values = this.$field.val().toUpperCase().match(/\S+/g);

            if (values) {
                this._addMultipleItems(jQuery.map(values, function(value) {
                    return { value: value, label: value };
                }));
            }

            this.$field.val("");
        },

        _events: {
            popupLink: {
                click: function (e) {
                    this._launchPopup();
                    e.preventDefault();
                }
            }
        },

        _renders: {
            popupLink: function () {
                return jQuery("<a class='issue-picker-popup' />")
                        .attr({
                            href: "#",
                            title: this.options.popupLinkMessage
                        })
                        .text("" + this.options.popupLinkMessage + "");
            }
        }

    });

    IssuePicker.callback = null;

    return IssuePicker;
});

/** @deprecated */
AJS.namespace("jira.issuepicker", null, require('jira/field/issue-picker'));
/** @deprecated */
AJS.namespace("AJS.IssuePicker", null, require('jira/field/issue-picker'));
AJS.namespace('JIRA.IssuePicker', null, require('jira/field/issue-picker'));
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/LabelPicker.js' */
define('jira/field/label-picker', [
    'jira/ajs/select/multi-select',
    'jira/ajs/list/group-descriptor',
    'jira/ajs/list/item-descriptor',
    'jquery'
], function(
    MultiSelect,
    GroupDescriptor,
    ItemDescriptor,
    jQuery
) {
    /**
     * @class LabelPicker
     * @extends MultiSelect
     */
    return MultiSelect.extend({

        _getDefaultOptions: function () {
            return jQuery.extend(true, this._super(), {
                ajaxOptions: {
                    url: contextPath + "/includes/js/ajs/layer/labeldata.js",
                    query: true,
                    formatResponse: this._formatResponse
                },
                removeDuplicates: true,
                removeOnUnSelect: true,
                userEnteredOptionsMsg: "New Label"
            });
        },

        isValidItem: function(itemValue) {
            return !/\s/.test(itemValue);
        },

        _handleServerSuggestions: function (data) {
            // if the suggestions brought back from the server include the original token and it doesn't match with the
            // token provided by the user disregard the suggestions
            if(data && data.token) {
                if(jQuery.trim(this.$field.val()) !== data.token) {
                    return;
                }
            }
            this._super(data);
        },

        _handleSpace: function () {
            if(jQuery.trim(this.$field.val()) !== "") {
                if(this.handleFreeInput()) {
                    this.hideSuggestions();
                }
            }
        },

        keys: {

            //if the user presses space, turn the text entered into labels.
            //if they pressed enter and the dropdown is *not* visible, then also turn text into labels.  Otherwise if the
            //dropdown is visibly enter should just select the item from the dropdown.
            "Spacebar": function (event) {
                this._handleSpace();
                event.preventDefault();
            }
        },

        _formatResponse: function (data) {

            var optgroup = new GroupDescriptor({
                label: "Suggestions",
                type: "optgroup",
                styleClass: 'labels-suggested'
            });

            if (data && data.suggestions) {
                jQuery.each(data.suggestions, function () {
                    optgroup.addItem(new ItemDescriptor({
                        value: this.label,
                        label: this.label,
                        html: this.html,
                        highlighted: true
                    }));
                });
            }
            return [optgroup];
        },

        handleFreeInput: function() {
            var values = jQuery.trim(this.$field.val()).match(/\S+/g);

            if (values) {
                // If there are multiple space-separated values, add them separately.
                for (var value, i = 0; value = values[i]; i++) {
                    this.addItem({ value: value, label: value });
                }
                this.model.$element.trigger("change");
            }

            this.$field.val("");
        }
    });

});

/** Preserve legacy namespace
 @deprecated AJS.LabelPicker */
AJS.namespace("AJS.LabelPicker", null, require('jira/field/label-picker'));
AJS.namespace('JIRA.LabelPicker', null, require('jira/field/label-picker'));
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/MultiUserListPicker.js' */
(function($) {


    /**
     * A multi-select list for selecting recipients to Share an issue or filter with. Shares are to 2 types of recipients:
     * - Users: selected from a dropdown list, and
     * - Email: addresses typed out in full
     *
     * @constructor JIRA.MultiUserListPicker
     * @extends AJS.MultiSelect
     */
    JIRA.MultiUserListPicker = AJS.MultiSelect.extend({

        init: function (options) {

            var restPath = "/rest/api/1.0/users/picker";

            function formatResponse(response) {

                var ret = [];

                $(response).each(function(i, suggestions) {

                    var groupDescriptor = new AJS.GroupDescriptor({
                        weight: i, // order or groups in suggestions dropdown
                        label: suggestions.footer // Heading of group
                    });

                    $(suggestions.users).each(function(){
                        groupDescriptor.addItem(new AJS.ItemDescriptor({
                            value: this.name, // value of item added to select
                            label: this.displayName, // title of lozenge
                            html: this.html,
                            icon: this.avatarUrl,
                            allowDuplicate: false,
                            highlighted: true
                        }));
                    });

                    ret.push(groupDescriptor);
                });

                return ret;
            }

            $.extend(options, {
                itemAttrDisplayed: "label",
                userEnteredOptionsMsg: "Email address",
                showDropdownButton: false,
                removeOnUnSelect: true,
                ajaxOptions: {
                    url: contextPath + restPath,
                    query: true,                // keep going back to the server for each keystroke
                    data: { showAvatar: true },
                    formatResponse: formatResponse
                },
                suggestionsHandler: AJS.UserListSuggestHandler,
                itemGroup: new AJS.Group(),
                itemBuilder: function (descriptor) {
                    return new JIRA.MultiUserListPicker.Item({
                        descriptor: descriptor,
                        container: this.$selectedItemsContainer
                    });
                }
            });

            this._super(options);
        },

        _createFurniture: function (disabled) {
            this._super(disabled);
            if (this.options.description) {
                this._render("description", this.options.description).insertAfter(this.$field);
            }
        },

        /**
         * The share textarea has no lozenges inside it and no need for cursor and indent nonsense.
         * It could even be a plain text field.
         */
        updateItemsIndent: $.noop,

        _renders: {
            selectedItemsWrapper: function () {
                return $('<div class="recipients"></div>');
            },
            selectedItemsContainer: function () {
                return $('<ol />');
            },
            description: function (description) {
                return $("<div />").addClass("description").text(description);
            }
        }

    });

}(AJS.$));;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/MultiUserListPicker.Item.js' */
    /**
     * A JIRA.MultiUserListPicker.Item represents an item selected in the Share Dialog & Watchers Dialog.
     * It is much like an AJS.MultiSelect.Lozenge but is rendered differently with slightly altered behaviour.
     *
     * @constructor JIRA.MultiUserListPicker.Item
     * @extends AJS.Control
     */
    JIRA.MultiUserListPicker.Item = AJS.Control.extend({

        init: function(options) {
            this._setOptions(options);

            this.$lozenge = this._render("item");
            this.$removeButton = this.$lozenge.find('.remove-recipient');

            this._assignEvents("instance", this);
            this._assignEvents("lozenge", this.$lozenge);
            this._assignEvents("removeButton", this.$removeButton);

            this.$lozenge.prependTo(this.options.container);
        },

        _getDefaultOptions: function() {
            return {
                label: null,
                title: null,
                container: null,
                focusClass: "focused"
            };
        },

        _renders: {
            "item": function() {
                var descriptor = this.options.descriptor;

                var data;
                if (descriptor.noExactMatch() !== true) {
                    // A User selected from the matches
                    data = {
                        escape: false,
                        username: descriptor.value(),
                        icon: descriptor.icon(),
                        displayName: AJS.escapeHtml(descriptor.label())
                    };

                    return AJS.$(JIRA.Templates.Fields.recipientUsername(data));
                } else {
                    // Just an email
                    data = {
                        email: descriptor.value(),
                        icon: AJS.Meta.get('default-avatar-url')
                    };
                    return AJS.$(JIRA.Templates.Fields.recipientEmail(data));
                }
            }
        },

        _events: {
            "instance": {
                "remove": function() {
                    this.$lozenge.remove();
                }
            },
            "removeButton": {
                "click": function(e) {
                    // We need to stop the click propagation, else by the time the InlineDialog catches the event the span
                    // will no longer be in the DOM and the click handler will think the user clicked outside of the dialog,
                    // closing it.
                    e.stopPropagation();
                    this.trigger("remove");
                }
            }
        }
    });
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initCascadingSelects.js' */
(function () {

    function initCascadingSelect(el) {
        AJS.$(el || document.body).find('div.aui-field-cascadingselect').add('tr.aui-field-cascadingselect').add('td.aui-field-cascadingselect').each(function () {
            var $container = AJS.$(this),
                parent = $container.find('.cascadingselect-parent'),
                parentOptions = parent.find('option'),
                oldClass = "",
                child = $container.find('.cascadingselect-child'),
                childOptions = child.find('option'),
                selectedChild = child.find(':selected');

            function update() {
                var placeholder,
                    currentClass = parent.find('option:selected').attr('class');
                // Compare so we're not redrawing the child dropdown when changing between the options with the class "default-option"
                if (currentClass !== oldClass) {
                    // Hide all the options other than ones relating to the selected parent

                    placeholder = jQuery("<span />").insertAfter(child);
                    child.detach();
                    child.find('option').each(function (i, elem) {
                        elem.parentNode.removeChild(this);
                    });
                    child.insertAfter(placeholder);
                    placeholder.remove();

                    childOptions.filter('.'+parent.find('option:selected').attr('class')).appendTo(child);
                    // Select the option which is to be selected on page load - default to the first one if none specified.
                    if (selectedChild.hasClass(parent.find('option:selected').attr('class'))) {
                        child.val(selectedChild.val());
                    } else {
                        child.val(child.find('option:first').val());
                    }
                    oldClass = currentClass;
                }
            }
            parent.bind('cascadingSelectChanged', update)
                  .change(function(){
                        AJS.$(this).trigger('cascadingSelectChanged');
                  })
                  .trigger('cascadingSelectChanged');
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initCascadingSelect(context);
        }
    });

})();;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initComponentPickers.js' */
(function () {

    JIRA.ComponentPicker = AJS.MultiSelect.extend({

        init: function(options) {
            this._super(options);
            this.suggestionsHandler = new AJS.OnlyNewItemsSuggestHandler(this.options, this.model);
        },

        _getDefaultOptions: function (opts) {
            var canCreate = false;
            if(opts && opts.element) {
                canCreate = AJS.$(opts.element).data("create-permission");
            }
            if(canCreate) {
                return AJS.$.extend(true, this._super(), {
                    userEnteredOptionsMsg: "New Component"
                });
            } else {
                return this._super(opts);
            }
        },

        _selectionHandler: function (selected, e) {
            var allExistingDescriptors = this.model.getDisplayableSelectedDescriptors().concat(this.model.getDisplayableUnSelectedDescriptors());
            var selectedDescriptor = selected.data("descriptor");
            var existingDescriptor = _.find(allExistingDescriptors, function(descriptor) {
                return descriptor.label() === selectedDescriptor.label();
            });
            if(!existingDescriptor)
            {
                selectedDescriptor.properties.value = "nv_" + selectedDescriptor.value();
                JIRA.trigger("Issue.Component.new.selected", [selectedDescriptor.value()]);
            }
            this._super(selected, e);
        }
    });


    function createPicker($selectField) {
        new JIRA.ComponentPicker({
            element: $selectField,
            itemAttrDisplayed: "label",
            errorMessage: "{0} is not a valid component.",
            maxInlineResultsDisplayed: 15,
            expandAllResults: true
        });
    }

    function locateSelect(parent) {

        var $parent = AJS.$(parent),
            $selectField;

        if ($parent.is("select")) {
            $selectField = $parent;
        } else {
            $selectField = $parent.find("select");
        }

        return $selectField;
    }

    var DEFAULT_SELECTORS = [
        "div.aui-field-componentspicker.frother-control-renderer", // aui forms
        "td.aui-field-componentspicker.frother-control-renderer", // convert to subtask and move
        "tr.aui-field-componentspicker.frother-control-renderer" // bulk edit
    ];

    function findComponentSelectAndConvertToPicker(context, selector) {

        selector = selector || DEFAULT_SELECTORS.join(", ");

        AJS.$(selector, context).each(function () {

            var $selectField = locateSelect(this);

            if ($selectField.length) {
                createPicker($selectField);
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            findComponentSelectAndConvertToPicker(context);
        }
    });
})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initMultiselectPickers.js' */
/*
 Copied over from initComponentPickers.js
 Slightly changed the way the Multiselect component is initialized.
 */

(function () {

    function createPicker($selectField) {
        new AJS.MultiSelect({
            element: $selectField,
            itemAttrDisplayed: "label",
            errorMessage: "{0} is not a valid value.",
            maxInlineResultsDisplayed: 15,
            submitInputVal: true,
            expandAllResults: true
        });
    }

    function locateSelect(parent) {

        var $parent = AJS.$(parent),
            $selectField;

        if ($parent.is("select")) {
            $selectField = $parent;
        } else {
            $selectField = $parent.find("select");
        }

        return $selectField;
    }

    var DEFAULT_SELECTORS = [
        "div.aui-field-multiselectpicker.frother-control-renderer" // aui forms
    ];

    function findComponentSelectAndConvertToPicker(context, selector) {

        selector = selector || DEFAULT_SELECTORS.join(", ");

        AJS.$(selector, context).each(function () {

            var $selectField = locateSelect(this);

            if ($selectField.length) {
                createPicker($selectField);
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            findComponentSelectAndConvertToPicker(context);
        }
    });
})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initDatePickers.js' */
(function () {

    function initDatePicker(el) {
        AJS.$(el || document.body).find('div.aui-field-datepicker').add('tr.aui-field-datepicker').add('td.aui-field-datepicker').each(function () {
            var $container = AJS.$(this),
                field = $container.find('input:text'),
                defaultCheckbox = $container.find('#useCurrentDate'),
                params = JIRA.parseOptionsFromFieldset($container.find('fieldset.datepicker-params'));

            params.context = el;

            Calendar.setup(params);

            function toggleField() {
                field.prop('disabled',defaultCheckbox.is(':checked'));
            }

            if (defaultCheckbox.length) {
                toggleField();
                defaultCheckbox.click(toggleField);
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context,reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initDatePicker(context);
        }

    });

})();

;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initLegacyGroupPickers.js' */
(function () {


    /**
     * USE initMultiGroupPicker instead.
     *
     * @deprecated
     * @param el
     */
    function initLegacyGroupPicker(el) {
        AJS.$(el || document.body).find('div.aui-field-grouppicker').add('tr.aui-field-grouppicker').add('td.aui-field-grouppicker').each(function () {
            var $container = AJS.$(this),
                trigger = $container.find('a.grouppicker-trigger'),
                url = trigger.attr('href');

            function openGroupPickerWindow(e) {
                e.preventDefault();
                window.open(url, 'GroupPicker', 'status=yes,resizable=yes,top=100,left=100,width=800,height=750,scrollbars=yes');
            }

            trigger.click(openGroupPickerWindow);
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initLegacyGroupPicker(context);
        }
    });

})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initIssuePickers.js' */
;(function() {
    var IssuePicker = require('jira/field/issue-picker');
    var Events = require('jira/util/events');
    var Types = require('jira/util/events/types');
    var Reasons = require('jira/util/events/reasons');
    var $ = require('jquery');

    function initIssuePicker(el) {
        $(el || document.body).find('.aui-field-issuepicker').each(function () {
            new IssuePicker({
                element: $(this),
                userEnteredOptionsMsg: "Enter issue key",
                uppercaseUserEnteredOnSelect: true
            });
        });
    }

    Events.bind(Types.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== Reasons.panelRefreshed) {
            initIssuePicker(context);
        }
    });
})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initLabelPickers.js' */
define('jira/field/label-picker-factory', [
    'jira/field/label-picker',
    'jira/data/parse-options-from-fieldset',
    'jquery',
    'exports'
], function(
    LabelPicker,
    parseOptionsFromFieldset,
    $,
    exports
) {
    exports.createPicker = function($fieldset, context) {

        var opts = parseOptionsFromFieldset($fieldset),
            $select = $('#' + opts.id, context),
            issueId = opts.issueId,
            data = {};

        if (/customfield_\d/.test(opts.id)) {
            data.customFieldId = parseInt(opts.id.replace('customfield_', ''), 10);
        }

        new LabelPicker({
            element: $select,
            ajaxOptions: {
                url: contextPath + '/rest/api/1.0/labels' + (issueId ? '/' + issueId : '') + '/suggest',
                data: data
            }
        });
    };

});

(function() {
    var LabelPickerFactory = require('jira/field/label-picker-factory');
    var Events = require('jira/util/events');
    var Types = require('jira/util/events/types');
    var Reasons = require('jira/util/events/reasons');
    var $ = require('jquery');

    var FIELDSET_SELECTOR = "fieldset.labelpicker-params";

    function locateFieldset(parent) {
        var $parent = $(parent),
            $fieldset;

        if ($parent.is(FIELDSET_SELECTOR)) {
            $fieldset = $parent;
        } else {
            $fieldset = $parent.find(FIELDSET_SELECTOR);
        }

        return $fieldset;
    }

    function findLabelsFieldsetAndConvertToPicker(context, selector) {
        selector = selector || ".aui-field-labelpicker";

        $(selector, context).each(function () {
            var $fieldset = locateFieldset(this);

            if ($fieldset.length > 0) {
                LabelPickerFactory.createPicker($fieldset, context);
            }
        });
    }

    Events.bind(Types.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== Reasons.panelRefreshed) {
            findLabelsFieldsetAndConvertToPicker(context);
        }
    });
})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initVersionPickers.js' */
(function () {

    JIRA.VersionPicker = AJS.MultiSelect.extend({

        init: function(options) {
            this._super(options);
            this.suggestionsHandler = new AJS.OnlyNewItemsSuggestHandler(this.options, this.model);
        },

        _getDefaultOptions: function (opts) {
            var canCreate = false;
            if(opts && opts.element) {
                canCreate = AJS.$(opts.element).data("create-permission");
            }
            if(canCreate) {
                return AJS.$.extend(true, this._super(), {
                    userEnteredOptionsMsg: "New Version"
                });
            } else {
                return this._super(opts);
            }
        },

        _selectionHandler: function (selected, e) {
            var allExistingVersionDescriptors = this.model.getDisplayableSelectedDescriptors().concat(this.model.getDisplayableUnSelectedDescriptors());
            var selectedDescriptor = selected.data("descriptor");
            var existingVersion = _.find(allExistingVersionDescriptors, function(descriptor) {
                return descriptor.label() === selectedDescriptor.label();
            });
            if(!existingVersion)
            {
                selectedDescriptor.properties.value = "nv_" + selectedDescriptor.value();
                JIRA.trigger("Issue.Version.new.selected", [selectedDescriptor.value()]);
            }
            this._super(selected, e);
        }
    });

    function createPicker($selectField) {
        new JIRA.VersionPicker({
            element: $selectField,
            itemAttrDisplayed: "label",
            removeOnUnSelect: false,
            submitInputVal: true,
            errorMessage: "{0} is not a valid version.",
            maxInlineResultsDisplayed: 15,
            expandAllResults: true
        });
    }

    function locateSelect(parent) {
        var $parent = AJS.$(parent),
            $selectField;

        if ($parent.is("select")) {
            $selectField = $parent;
        } else {
            $selectField = $parent.find("select");
        }

        return $selectField;
    }

    function findVersionSelectAndConvertToPicker(context, selector) {
        selector = selector || ".aui-field-versionspicker.frother-control-renderer";
        AJS.$(selector, context).each(function () {
            var $selectField = locateSelect(this);
            if ($selectField.length) {
                createPicker($selectField);
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            findVersionSelectAndConvertToPicker(context);
        }
    });

})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initCommentControls.js' */
(function () {
    var skate = require('jira/skate');
    var SecurityLevelSelect = require('jira/ajs/select/security-level-select');
    var wikiPreview = require('jira/wikipreview/wiki-preview');

    /**
     *
     */
    skate('jira-wikifield', {
        type: skate.type.CLASSNAME,
        created: function(el) {
            var prefs = {
                fieldId: el.getAttribute('field-id'),
                trigger: el.querySelector('.wiki-preview').id,
                issueKey: el.getAttribute('issue-key'),
                rendererType: el.getAttribute('renderer-type')
            };
            wikiPreview(prefs, el).init();
        }
    });

    skate('security-level', {
        type: skate.type.CLASSNAME,
        created: function(el) {
            var commentLevel = el.querySelector('#commentLevel');
            if (commentLevel) {
                new SecurityLevelSelect(commentLevel);
            }
        }
    });

})();
;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initLogWorkControls.js' */
(function ($) {

    JIRA.Events.VALIDATE_TIMETRACKING = "validateTimeTracking";

    function toggleTimeTrackingContainer(context, activate) {

        var $logWorkContainer = $(context).find("#worklog-logworkcontainer"),
            $timeTrackingContainer = $(context).find("#worklog-timetrackingcontainer"),
            $logWorkCheckbox = $(context).find("#log-work-activate");

        if (activate) {
            $logWorkContainer.removeClass("hidden");
            $timeTrackingContainer.addClass("hidden");
            $logWorkCheckbox.prop("checked", true);
        } else {
            $logWorkContainer.addClass("hidden");
            $timeTrackingContainer.removeClass("hidden");
            $logWorkCheckbox.prop("checked", false);
        }
    }

    function applyLogworkControls(context) {

        $('#log-work-adjust-estimate-new-value, #log-work-adjust-estimate-manual-value', context).attr('disabled','disabled');

        $('#log-work-adjust-estimate-'+$('input[name=worklog_adjustEstimate]:checked,input[name=adjustEstimate]:checked', context).val()+'-value', context).removeAttr('disabled');
        $('input[name=worklog_adjustEstimate],input[name=adjustEstimate]', context).change(function(){
            $('#log-work-adjust-estimate-new-value,#log-work-adjust-estimate-manual-value', context).attr('disabled','disabled');
            $('#log-work-adjust-estimate-'+$(this).val()+'-value', context).removeAttr('disabled');
        });

        $("#delete-log-work-adjust-estimate-new-value").change(function() {
            $("#delete-log-work-adjust-estimate-new").prop("checked", true);
        });
        $("#delete-log-work-adjust-estimate-manual-value").change(function() {
            $("#delete-log-work-adjust-estimate-manual").prop("checked", true);
        });

        $(context).find("#log-work-activate").change(function() {
            toggleTimeTrackingContainer(context, $(this).is(":checked"));
        });
    }

    // In Quick Edit/Create we need to ensure the container is visible to append error messages
    JIRA.bind(JIRA.Events.VALIDATE_TIMETRACKING, function (e, context) {
        toggleTimeTrackingContainer(context, true);
    });

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            applyLogworkControls(context);
        }
    });

})(AJS.$);;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initPriorityPickers.js' */
(function ($) {

    function createPriorityPicker(context) {
        context.find("select#priority").each(function (i, el) {
            new AJS.SingleSelect({
                element: el,
                revertOnInvalid: true
            });
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            createPriorityPicker(context);
        }
    });

})(AJS.$);;
;
/* module-key = 'jira.webresources:jira-fields', location = '/includes/jira/field/initInlineAttach.js' */
;(function() {
    var Events = require('jira/util/events');
    var Types = require('jira/util/events/types');
    var Reasons = require('jira/util/events/reasons');
    require('jira/jquery/plugins/attachment/inline-attach'); // Ensure jQuery plugin is defined)

    /**
     * @param {jQuery} context
     */
    function createInlineAttach(context) {
        context.find("input[type=file]:not('.ignore-inline-attach')").inlineAttach();
    }

    Events.bind(Types.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== Reasons.panelRefreshed) {
            createInlineAttach(context);
        }
    });
})();
;
;
/* module-key = 'com.atlassian.jira.jira-share-plugin:share-resources', location = 'templates/share-dialog.soy' */
// This file was automatically generated from share-dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Dialogs.Share.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Dialogs == 'undefined') { JIRA.Templates.Dialogs = {}; }
if (typeof JIRA.Templates.Dialogs.Share == 'undefined') { JIRA.Templates.Dialogs.Share = {}; }


JIRA.Templates.Dialogs.Share.contentPopup = function(opt_data, opt_ignored) {
  return '<form action="#" method="post" class="aui recipients-form share-content-popup ' + ((opt_data.shareData.issue) ? ' viewissue ' : (opt_data.shareData.filter) ? ' issuenav ' : '') + '">' + JIRA.Templates.Dialogs.Share.shareLink(opt_data) + '<fieldset class="padding">' + ((opt_data.showForm) ? JIRA.Templates.Dialogs.Share.shareForm(opt_data) : JIRA.Templates.Dialogs.Share.disabledMailMessage(soy.$$augmentMap(opt_data.isAdmin, {isAdmin: opt_data.isAdmin}))) + '</fieldset></form>';
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.Share.contentPopup.soyTemplateName = 'JIRA.Templates.Dialogs.Share.contentPopup';
}


JIRA.Templates.Dialogs.Share.shareForm = function(opt_data, opt_ignored) {
  return '<label for="sharenames-multi-select">' + soy.$$escapeHtml("User name or email") + '</label><div class="autocomplete-user-target"><select id="sharenames" name="sharenames" class="share-user-picker hidden" multiple="multiple"></select></div><ol class="recipients"></ol><div><label for="note">' + soy.$$escapeHtml("Note") + '</label></div><textarea class="textarea long-field" id="note" placeholder="' + soy.$$escapeHtml("Add an optional note") + '"/><div class="button-panel"><div class="status"><div class="icon"></div><div class="progress-messages"></div></div><div class="buttons"><input accesskey="' + soy.$$escapeHtml("s") + '" id="submitShare" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to submit this form","s",opt_data.modifierKey)) + '" class="button submit" type="submit" value="' + soy.$$escapeHtml("Share") + '" disabled/> <a accesskey="' + soy.$$escapeHtml("`") + '" id="cancelShare" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to cancel","`",opt_data.modifierKey)) + '" class="close-dialog" href="javascript:">' + soy.$$escapeHtml("Cancel") + '</a></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.Share.shareForm.soyTemplateName = 'JIRA.Templates.Dialogs.Share.shareForm';
}


JIRA.Templates.Dialogs.Share.disabledMailMessage = function(opt_data, opt_ignored) {
  return '' + ((! opt_data.isAdmin) ? aui.message.generic({content: '<p>' + soy.$$escapeHtml("Outgoing mail is not configured. Please contact your JIRA administrator to enable sharing.") + '</p>', extraClasses: 'disabled-mail-message'}) : aui.message.generic({content: '<p>' + soy.$$escapeHtml("Outgoing mail is not configured. You can configure it here") + '<a class="aui-list-item-link" id="configure_mail_server" href="' + soy.$$escapeHtml("/jira") + '/secure/admin/OutgoingMailServers.jspa"><em> ' + soy.$$escapeHtml("Outgoing mail") + '</em></a>.</p>', extraClasses: 'disabled-mail-message'}));
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.Share.disabledMailMessage.soyTemplateName = 'JIRA.Templates.Dialogs.Share.disabledMailMessage';
}


JIRA.Templates.Dialogs.Share.shareLink = function(opt_data, opt_ignored) {
  return '' + ((opt_data.shareData.permlink) ? '<div class="issuenav-permalink padding"><label>' + ((opt_data.shareData.issue) ? soy.$$escapeHtml("Link to Issue") : (opt_data.shareData.filter) ? soy.$$escapeHtml("Link to Filter") : '') + '</label><input class="permalink text long-field" value="' + soy.$$escapeHtml(opt_data.shareData.permlink) + '" readonly></div>' : '');
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.Share.shareLink.soyTemplateName = 'JIRA.Templates.Dialogs.Share.shareLink';
}
;
;
/* module-key = 'com.atlassian.jira.jira-share-plugin:share-resources', location = 'js/share-user-multi-select.js' */
define('jira/share-plugin/share-user-picker', [
    'jira/skate',
    'jquery'
], function(skate, $) {
    var MultiUserListPicker = JIRA.MultiUserListPicker;
    var $doc = $(document);

    return skate('share-user-picker', {
        type: skate.type.CLASSNAME,
        attached: function shareUserPickerAttached(element) {
            var $el = $(element);
            var control = new MultiUserListPicker({
                layerId: $el.attr('id') + '-layer',
                element: $el,
                freeEmailInput: true
            });
            $doc.trigger('ready.multi-select.share-user', control);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-share-plugin:share-resources', location = 'js/share-dialog.js' */
define('jira/share-plugin/share-plugin-dialog', [
    'underscore',
    'jira/share-plugin/share-user-picker',
    'jira/ajs/layer/inline-layer',
    'jira/ajs/ajax/smart-ajax',
    'jira/util/events',
    'jira/util/events/types',
    'jira/util/data/meta',
    'jira/util/events/reasons',
    'aui/inline-dialog',
    'jquery'
], function(
    _,
    ShareUserPickerElement,
    InlineLayer,
    SmartAjax,
    JiraEvents,
    JiraEventTypes,
    Meta,
    JiraEventReasons,
    InlineDialog,
    jQuery
) {
    return function () {
        var shareDialog,
            currentShareLink,
            dialogContents,
            allowDialogHide = true;

        this.resetAndHide = function resetAndHide() {
            // We have to bind to the event triggered by the inline-dialog hide code, as the actual hide runs in a
            // setTimeout callback. This caused JRADEV-7962 when trying to empty the contents synchronously.
            jQuery(document).one("hideLayer", function (e, type, dialog) {
                if (type === "inlineDialog" && dialog.popup === shareDialog) {
                    jQuery(document).unbind('.share-dialog');
                    dialogContents.empty();
                    dialogContents = undefined;
                    currentShareLink = undefined;
                }
            });
            return this.hideDialog();
        };

        this.hideDialog = function hideDialog() {
            shareDialog.hide();
            return false;
        };

        function getUsernameValue() {
            return jQuery(this).attr("data-username");
        };

        function getEmailValue() {
            return jQuery(this).attr("data-email");
        };

        this._buildSendShareUrl = function buildSendShareUrl(options, data) {
            var url = AJS.contextPath() + '/rest/share/1.0';
            if (options.issue) {
                // Share Issue
                url += '/issue/' + options.issueKey;
            }
            else if (options.filter) {
                // Share Search
                if (options.filterId) {
                    // A saved search
                    url += '/filter/' + options.filterId;
                }
                else {
                    // A JQL search
                    data.jql = options.jql;
                    url += '/search';
                }
            }
            return url;
        };

        this._successShareHandler = function successShareHandler()
        {
            var icon = dialogContents.find(".button-panel .icon");
            icon.removeClass("throbber loading")
                .addClass('icon-tick');

            var messages = dialogContents.find(".progress-messages");
            messages.removeClass("sending")
                .addClass("success")
                .text("Sent");
            setTimeout(_.bind(this.resetAndHide, this), 1000);
        };

        this._errorShareHandler = function errorShareHandler()
        {
            var icon = dialogContents.find(".button-panel .icon");
            icon.removeClass("throbber loading")
                .addClass('icon-cross');
            var messages = dialogContents.find(".progress-messages");
            messages.removeClass("sending")
                .addClass("error")
                .text("Error while sending");
        };

        /**
         * Sets up the state and send a share ajax request
         *
         * @param data
         * @param data.usernames A list of users to share to
         * @param data.emails A list of emails to share to
         * @param data.message An optional share message
         * @param options.issueKey {undefined | string} The issue key to share
         * @param options.filterId {undefined | string} The filter id to share
         * @param options.issue {undefined | true} Whether the share target is issue
         * @param options.filter {undefined | true} Whether the share target is filter
         */
        this._sendShare = function sendShare(data, options) {
            jQuery("button,input,textarea", this).attr("disabled", "disabled");

            var icon = dialogContents.find(".button-panel .icon");
            icon.addClass("throbber loading");

            var messages = dialogContents.find(".progress-messages");
            messages.text("Sending");
            messages.addClass("sending");

            var url = this._buildSendShareUrl(options, data);

            JIRA.trace("jira.plugins.share.send", _.defaults({
                url: url
            }, data));

            var requestOptions = {
                type: "POST",
                contentType: "application/json",
                dataType: "json",
                url: url,
                data: JSON.stringify(data),
                success: _.bind(this._successShareHandler, this),
                error: _.bind(this._errorShareHandler, this)
            };
            SmartAjax.makeRequest(requestOptions);
        };

        this._collectMailData = function collectMailData() {
            var recipients = dialogContents.find('.recipients');
            var users = recipients.find('li[data-username]').map(getUsernameValue).toArray();
            var emails = recipients.find('li[data-email]').map(getEmailValue).toArray();

            if (!(users.length || emails.length)) {
                return false;
            }

            var message = dialogContents.find("#note").val();
            var data = {
                usernames: users,
                emails: emails,
                message: message
            };
            return data;
        };

        this.submit = function submit(shareData) {
            var mailData = this._collectMailData();
            if(mailData) {
                this._sendShare(mailData, shareData);
            }
            return false;
        };

        this._enableSubmit = function enableSubmit(enabled) {
            dialogContents.find(".submit").prop("disabled", !enabled);
        };

        /**
         * Invoke a bunch of magical JS event delegation to make sure that we only trigger the execution of the
         * functions attached to the access keys defined within this dialog's form.
         *
         * @param shareDialogForm the share dialog's form.
         */
        this.enableAccessKeys = function enableAccessKeys(shareDialogForm) {
            jQuery(shareDialogForm).handleAccessKeys({
                selective: false // only trigger the access keys defined in this form.
            });
        };

        this._getShareData = function getShareData(trigger) {
            var $trigger = jQuery(trigger),
                shareTarget,
                permlinkFull;

            if ($trigger.hasClass("viewissue-share")) {
                shareTarget = "issue";
                permlinkFull = Meta.get("viewissue-permlink");
            } else if ($trigger.hasClass("issuenav-share")) {
                shareTarget = "filter";
                permlinkFull = Meta.get("issuenav-permlink");
            }

            var shareData = {
                issueKey: JIRA.Meta.getIssueKey(),
                filterId: Meta.get('filter-id'),
                jql: Meta.get('filter-jql'),
                permlink: permlinkFull
            };
            shareData[shareTarget] = true;

            return shareData;
        };

        this._enableSubmitWhenIsRecipient = function enableSubmitWhenIsRecipient() {
            var shareNames = dialogContents.find('#sharenames').val();
            var isUserProvided = (shareNames != null) && (shareNames.length > 0);
            this._enableSubmit(isUserProvided);
        };

        this._addInteractionHandlersToDialog = function addInteractionHandlersToDialog(shareData) {
            dialogContents.find('#sharenames').bind('change unselect', _.bind(this._enableSubmitWhenIsRecipient, this));
            dialogContents.find(".close-dialog").click(_.bind(this.resetAndHide, this));
            dialogContents.find("form").submit(_.bind(this.submit, this, shareData));
            dialogContents.find(".issuenav-permalink .text").click(function (e) {
                e.target.select();
                return false;
            });
            jQuery(document).bind('keyup.share-dialog', _.bind(function (e) {
                if (e.keyCode === jQuery.ui.keyCode.ESCAPE) {
                    return this.hideDialog();   // leave the dialog contents alone
                }
                return true;
            }, this));
            jQuery(document).bind("showLayer.share-dialog", function (e, type, dialog) {
                if (type === "inlineDialog" && dialog.popup === shareDialog) {
                    dialogContents.find("#sharenames-textarea").focus();
                }
            });
        };

        this._renderDialogContent = function renderDialogContent(shareData) {
            dialogContents.html(JIRA.Templates.Dialogs.Share.contentPopup({
                shareData: shareData,
                modifierKey: Meta.get("keyboard-accesskey-modifier"),
                //Only show the share form when outgoing mail is enabled
                showForm: Meta.get("outgoing-mail-enabled"),
                isAdmin: Meta.get("is-admin")
            }));
        };

        this._generatePopup = function generatePopup(contents, trigger, doShowPopup) {
            var shareData = this._getShareData(trigger);

            //If the share dialog has already been rendered and still on the issue it was rendered in
            if (dialogContents && currentShareLink === shareData.permlink) {
                dialogContents = contents;
                doShowPopup();
                return;
            }
            currentShareLink = shareData.permlink;
            dialogContents = contents;
            this._renderDialogContent(shareData);
            if (jQuery.browser.msie) {
                dialogContents.find("form").ieImitationPlaceholder();
            }
            this._enableSubmit(false);
            this._addInteractionHandlersToDialog.call(this, shareData);
            this.enableAccessKeys(jQuery("form", dialogContents));

            doShowPopup();

            JiraEvents.trigger(JiraEventTypes.NEW_CONTENT_ADDED, [dialogContents, JiraEventReasons.shareDialogOpened]);
        };

        this._scrollIntoViewForAuto = function _scrollIntoViewForAuto() {
            var self = this;
            var $context = jQuery(this.context);
            $context.scrollIntoViewForAuto({
                complete: function ()
                {
                    // $(this) is the element being scrolled to reveal the trigger.
                    var scrollers = jQuery(this).add(window);

                    // JRA-27476 - share dialog doesn't stalk. So hide it, without reset, when the page is
                    // scrolled. Delay to avoid catching the scroll events caused by scrollIntoViewForAuto()
                    _.delay(function ()
                    {
                        scrollers.one("scroll", function ()
                        {
                            jQuery(document.activeElement).blur();
                            self.hideDialog();
                        });
                    }, 20);
                }
            });
        };

        this._createDialogOptions = function _createDialogOptions(dialogId) {
            var offsetX = (dialogId.indexOf("issuenav") !== -1) ? -110 : -170;
            var dialogOptions = {
                preHideCallback: function () {
                    return allowDialogHide;
                },
                hideCallback: function () {
                    jQuery(".dashboard-actions .explanation").hide();
                },
                offsetY: 17,
                offsetX: offsetX,
                hideDelay: 36e5,         // needed for debugging! Sit for an hour.
                useLiveEvents: true,
                // Before showing the dialog, we want to ensure the trigger is scrolled into view, transitively this
                // will ensure that the dialog is visible. The page might be scrolled down to the bottom when the
                // user presses 's'.
                initCallback: _.bind(this._scrollIntoViewForAuto, this)
            };
            return dialogOptions;
        };

        this._addAJSInlineLayerEventHandlers = function _addAJSInlineLayerEventHandlers() {
            JiraEvents.bind(InlineLayer.EVENTS.beforeShow, function (e, layer, id) {
                if (id === "sharenames-layer") {
                    allowDialogHide = false;
                }
            });
            JiraEvents.bind(InlineLayer.EVENTS.hide, function (e, layer, reason, id) {
                if (id === "sharenames-layer") {
                    setTimeout(function () { allowDialogHide = true; }, 0);
                }
            });
        };

        this._initShareDialog = function _initShareDialog(dialogId, context) {
            var self = this;
            this.context = context;

            this._addAJSInlineLayerEventHandlers();

            var dialogOptions = this._createDialogOptions(dialogId);

            shareDialog = InlineDialog(jQuery(context), dialogId, _.bind(self._generatePopup, self), dialogOptions);

            shareDialog[0].popup._validateClickToClose = function(event) {
                return validationResult = shareDialog.has(event.target).length === 0;
            };

            // JRADEV-8136 - Clicking the share button again doesn't close the share dialog.
            jQuery(context).live("click", function() {
                if (shareDialog.find(".contents:visible").length) {
                    shareDialog.find("a.close-dialog").click();
                }
            });

            jQuery(document).bind("keydown", function (e) {
                // special case for when user hover is open at same time
                if (e.keyCode === jQuery.ui.keyCode.ESCAPE &&
                        InlineDialog.current !== shareDialog && shareDialog.is(":visible")) {
                    if (InlineDialog.current) {
                        InlineDialog.current.hide();
                    }
                    shareDialog.hide();
                }
            });
        };

        this._overrideContents = function overrideContents(newContents) {
            dialogContents = newContents;
        };

        this._getCurrentDialogContent = function getCurrentDialogContent() {
            return dialogContents;
        };

        this._getAllowDialogHide = function _getAllowDialogHide(){
            return allowDialogHide;
        };
    };
});

AJS.namespace('JIRA.JiraSharePlugin.SharePluginDialog', null, require('jira/share-plugin/share-plugin-dialog'));
;
;
/* module-key = 'com.atlassian.jira.jira-share-plugin:share-resources-init', location = 'js/share-dialog-init.js' */
// There may be multiple share button on the page, for example split view
// This is to ensure both works within its own scope and not affect each other

define('jira/share-plugin/initialiser', [
    'underscore',
    'jira/share-plugin/share-plugin-dialog',
    'jquery'
], function (
    _,
    SharePluginDialog,
    jQuery
) {
    return {
        init: _.once (function initShareDialogs() {
            var exports = {};
            exports.viewIssueDialog = new SharePluginDialog(jQuery);
            exports.issueNavDialog = new SharePluginDialog(jQuery);

            jQuery(_.bind(exports.viewIssueDialog._initShareDialog, exports.viewIssueDialog,
                    "share-entity-popup-viewissue", "#jira-share-trigger.viewissue-share"));
            jQuery(_.bind(exports.issueNavDialog._initShareDialog, exports.issueNavDialog,
                    "share-entity-popup-issuenav", "#jira-share-trigger.issuenav-share"));

            return exports;
        })
    };
});

// This IIFE will immediately and synchronously require the initialiser
// (thus create the dialogs), and immediately place the dialogs
// in to the global namespace. Use of AJS.namespace will add
// a deprecation warning whenever the global is accessed by other code.
(function(initialiser) {
    var dialogs = initialiser.init();
    AJS.namespace('JIRA.JiraSharePlugin.viewIssueDialog', null, dialogs.viewIssueDialog);
    AJS.namespace('JIRA.JiraSharePlugin.issueNavDialog', null, dialogs.issueNavDialog);
}(require('jira/share-plugin/initialiser')));
;
;
/* module-key = 'com.atlassian.plugin.jslibs:marionette-2.1.0-factory', location = 'factories/marionette/2.1.0/marionette-2.1.0-factory.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
  define('atlassian/libs/factories/marionette-2.1.0', function() {
    return function(_, Backbone) {
      var env = {
        _: _,
        Backbone: Backbone
      };
      factory.call(env);
      return env.Marionette.noConflict();
    }
  });
})(function(){
/////// End of Atlassian modification ///////

  // MarionetteJS (Backbone.Marionette)
  // ----------------------------------
  // v2.1.0
  //
  // Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.
  // Distributed under MIT license
  //
  // http://marionettejs.com


  /*!
   * Includes BabySitter
   * https://github.com/marionettejs/backbone.babysitter/
   *
   * Includes Wreqr
   * https://github.com/marionettejs/backbone.wreqr/
   */


  (function(root, factory) {

    if (typeof define === 'function' && define.amd) {
      define(['backbone', 'underscore'], function(Backbone, _) {
        return (root.Marionette = factory(root, Backbone, _));
      });
    } else if (typeof exports !== 'undefined') {
      var Backbone = require('backbone');
      var _ = require('underscore');
      module.exports = factory(root, Backbone, _);
    } else {
      root.Marionette = factory(root, root.Backbone, root._);
    }

  }(this, function(root, Backbone, _) {
    'use strict';

    // Backbone.BabySitter
    // -------------------
    // v0.1.4
    //
    // Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.
    // Distributed under MIT license
    //
    // http://github.com/marionettejs/backbone.babysitter
    (function(Backbone, _) {
      "use strict";
      var previousChildViewContainer = Backbone.ChildViewContainer;
      // BabySitter.ChildViewContainer
      // -----------------------------
      //
      // Provide a container to store, retrieve and
      // shut down child views.
      Backbone.ChildViewContainer = function(Backbone, _) {
        // Container Constructor
        // ---------------------
        var Container = function(views) {
          this._views = {};
          this._indexByModel = {};
          this._indexByCustom = {};
          this._updateLength();
          _.each(views, this.add, this);
        };
        // Container Methods
        // -----------------
        _.extend(Container.prototype, {
          // Add a view to this container. Stores the view
          // by `cid` and makes it searchable by the model
          // cid (and model itself). Optionally specify
          // a custom key to store an retrieve the view.
          add: function(view, customIndex) {
            var viewCid = view.cid;
            // store the view
            this._views[viewCid] = view;
            // index it by model
            if (view.model) {
              this._indexByModel[view.model.cid] = viewCid;
            }
            // index by custom
            if (customIndex) {
              this._indexByCustom[customIndex] = viewCid;
            }
            this._updateLength();
            return this;
          },
          // Find a view by the model that was attached to
          // it. Uses the model's `cid` to find it.
          findByModel: function(model) {
            return this.findByModelCid(model.cid);
          },
          // Find a view by the `cid` of the model that was attached to
          // it. Uses the model's `cid` to find the view `cid` and
          // retrieve the view using it.
          findByModelCid: function(modelCid) {
            var viewCid = this._indexByModel[modelCid];
            return this.findByCid(viewCid);
          },
          // Find a view by a custom indexer.
          findByCustom: function(index) {
            var viewCid = this._indexByCustom[index];
            return this.findByCid(viewCid);
          },
          // Find by index. This is not guaranteed to be a
          // stable index.
          findByIndex: function(index) {
            return _.values(this._views)[index];
          },
          // retrieve a view by its `cid` directly
          findByCid: function(cid) {
            return this._views[cid];
          },
          // Remove a view
          remove: function(view) {
            var viewCid = view.cid;
            // delete model index
            if (view.model) {
              delete this._indexByModel[view.model.cid];
            }
            // delete custom index
            _.any(this._indexByCustom, function(cid, key) {
              if (cid === viewCid) {
                delete this._indexByCustom[key];
                return true;
              }
            }, this);
            // remove the view from the container
            delete this._views[viewCid];
            // update the length
            this._updateLength();
            return this;
          },
          // Call a method on every view in the container,
          // passing parameters to the call method one at a
          // time, like `function.call`.
          call: function(method) {
            this.apply(method, _.tail(arguments));
          },
          // Apply a method on every view in the container,
          // passing parameters to the call method one at a
          // time, like `function.apply`.
          apply: function(method, args) {
            _.each(this._views, function(view) {
              if (_.isFunction(view[method])) {
                view[method].apply(view, args || []);
              }
            });
          },
          // Update the `.length` attribute on this container
          _updateLength: function() {
            this.length = _.size(this._views);
          }
        });
        // Borrowing this code from Backbone.Collection:
        // http://backbonejs.org/docs/backbone.html#section-106
        //
        // Mix in methods from Underscore, for iteration, and other
        // collection related features.
        var methods = [ "forEach", "each", "map", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "toArray", "first", "initial", "rest", "last", "without", "isEmpty", "pluck" ];
        _.each(methods, function(method) {
          Container.prototype[method] = function() {
            var views = _.values(this._views);
            var args = [ views ].concat(_.toArray(arguments));
            return _[method].apply(_, args);
          };
        });
        // return the public API
        return Container;
      }(Backbone, _);
      Backbone.ChildViewContainer.VERSION = "0.1.4";
      Backbone.ChildViewContainer.noConflict = function() {
        Backbone.ChildViewContainer = previousChildViewContainer;
        return this;
      };
      return Backbone.ChildViewContainer;
    })(Backbone, _);
    // Backbone.Wreqr (Backbone.Marionette)
    // ----------------------------------
    // v1.3.1
    //
    // Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.
    // Distributed under MIT license
    //
    // http://github.com/marionettejs/backbone.wreqr
    (function(Backbone, _) {
      "use strict";
      var previousWreqr = Backbone.Wreqr;
      var Wreqr = Backbone.Wreqr = {};
      Backbone.Wreqr.VERSION = "1.3.1";
      Backbone.Wreqr.noConflict = function() {
        Backbone.Wreqr = previousWreqr;
        return this;
      };
      // Handlers
      // --------
      // A registry of functions to call, given a name
      Wreqr.Handlers = function(Backbone, _) {
        "use strict";
        // Constructor
        // -----------
        var Handlers = function(options) {
          this.options = options;
          this._wreqrHandlers = {};
          if (_.isFunction(this.initialize)) {
            this.initialize(options);
          }
        };
        Handlers.extend = Backbone.Model.extend;
        // Instance Members
        // ----------------
        _.extend(Handlers.prototype, Backbone.Events, {
          // Add multiple handlers using an object literal configuration
          setHandlers: function(handlers) {
            _.each(handlers, function(handler, name) {
              var context = null;
              if (_.isObject(handler) && !_.isFunction(handler)) {
                context = handler.context;
                handler = handler.callback;
              }
              this.setHandler(name, handler, context);
            }, this);
          },
          // Add a handler for the given name, with an
          // optional context to run the handler within
          setHandler: function(name, handler, context) {
            var config = {
              callback: handler,
              context: context
            };
            this._wreqrHandlers[name] = config;
            this.trigger("handler:add", name, handler, context);
          },
          // Determine whether or not a handler is registered
          hasHandler: function(name) {
            return !!this._wreqrHandlers[name];
          },
          // Get the currently registered handler for
          // the specified name. Throws an exception if
          // no handler is found.
          getHandler: function(name) {
            var config = this._wreqrHandlers[name];
            if (!config) {
              return;
            }
            return function() {
              var args = Array.prototype.slice.apply(arguments);
              return config.callback.apply(config.context, args);
            };
          },
          // Remove a handler for the specified name
          removeHandler: function(name) {
            delete this._wreqrHandlers[name];
          },
          // Remove all handlers from this registry
          removeAllHandlers: function() {
            this._wreqrHandlers = {};
          }
        });
        return Handlers;
      }(Backbone, _);
      // Wreqr.CommandStorage
      // --------------------
      //
      // Store and retrieve commands for execution.
      Wreqr.CommandStorage = function() {
        "use strict";
        // Constructor function
        var CommandStorage = function(options) {
          this.options = options;
          this._commands = {};
          if (_.isFunction(this.initialize)) {
            this.initialize(options);
          }
        };
        // Instance methods
        _.extend(CommandStorage.prototype, Backbone.Events, {
          // Get an object literal by command name, that contains
          // the `commandName` and the `instances` of all commands
          // represented as an array of arguments to process
          getCommands: function(commandName) {
            var commands = this._commands[commandName];
            // we don't have it, so add it
            if (!commands) {
              // build the configuration
              commands = {
                command: commandName,
                instances: []
              };
              // store it
              this._commands[commandName] = commands;
            }
            return commands;
          },
          // Add a command by name, to the storage and store the
          // args for the command
          addCommand: function(commandName, args) {
            var command = this.getCommands(commandName);
            command.instances.push(args);
          },
          // Clear all commands for the given `commandName`
          clearCommands: function(commandName) {
            var command = this.getCommands(commandName);
            command.instances = [];
          }
        });
        return CommandStorage;
      }();
      // Wreqr.Commands
      // --------------
      //
      // A simple command pattern implementation. Register a command
      // handler and execute it.
      Wreqr.Commands = function(Wreqr) {
        "use strict";
        return Wreqr.Handlers.extend({
          // default storage type
          storageType: Wreqr.CommandStorage,
          constructor: function(options) {
            this.options = options || {};
            this._initializeStorage(this.options);
            this.on("handler:add", this._executeCommands, this);
            var args = Array.prototype.slice.call(arguments);
            Wreqr.Handlers.prototype.constructor.apply(this, args);
          },
          // Execute a named command with the supplied args
          execute: function(name, args) {
            name = arguments[0];
            args = Array.prototype.slice.call(arguments, 1);
            if (this.hasHandler(name)) {
              this.getHandler(name).apply(this, args);
            } else {
              this.storage.addCommand(name, args);
            }
          },
          // Internal method to handle bulk execution of stored commands
          _executeCommands: function(name, handler, context) {
            var command = this.storage.getCommands(name);
            // loop through and execute all the stored command instances
            _.each(command.instances, function(args) {
              handler.apply(context, args);
            });
            this.storage.clearCommands(name);
          },
          // Internal method to initialize storage either from the type's
          // `storageType` or the instance `options.storageType`.
          _initializeStorage: function(options) {
            var storage;
            var StorageType = options.storageType || this.storageType;
            if (_.isFunction(StorageType)) {
              storage = new StorageType();
            } else {
              storage = StorageType;
            }
            this.storage = storage;
          }
        });
      }(Wreqr);
      // Wreqr.RequestResponse
      // ---------------------
      //
      // A simple request/response implementation. Register a
      // request handler, and return a response from it
      Wreqr.RequestResponse = function(Wreqr) {
        "use strict";
        return Wreqr.Handlers.extend({
          request: function() {
            var name = arguments[0];
            var args = Array.prototype.slice.call(arguments, 1);
            if (this.hasHandler(name)) {
              return this.getHandler(name).apply(this, args);
            }
          }
        });
      }(Wreqr);
      // Event Aggregator
      // ----------------
      // A pub-sub object that can be used to decouple various parts
      // of an application through event-driven architecture.
      Wreqr.EventAggregator = function(Backbone, _) {
        "use strict";
        var EA = function() {};
        // Copy the `extend` function used by Backbone's classes
        EA.extend = Backbone.Model.extend;
        // Copy the basic Backbone.Events on to the event aggregator
        _.extend(EA.prototype, Backbone.Events);
        return EA;
      }(Backbone, _);
      // Wreqr.Channel
      // --------------
      //
      // An object that wraps the three messaging systems:
      // EventAggregator, RequestResponse, Commands
      Wreqr.Channel = function(Wreqr) {
        "use strict";
        var Channel = function(channelName) {
          /////////// Modified by Atlassian ///////////
          this.vent = new Wreqr.EventAggregator();
          this.reqres = new Wreqr.RequestResponse();
          this.commands = new Wreqr.Commands();
          /////// End of Atlassian modification ///////
          this.channelName = channelName;
        };
        _.extend(Channel.prototype, {
          // Remove all handlers from the messaging systems of this channel
          reset: function() {
            this.vent.off();
            this.vent.stopListening();
            this.reqres.removeAllHandlers();
            this.commands.removeAllHandlers();
            return this;
          },
          // Connect a hash of events; one for each messaging system
          connectEvents: function(hash, context) {
            this._connect("vent", hash, context);
            return this;
          },
          connectCommands: function(hash, context) {
            this._connect("commands", hash, context);
            return this;
          },
          connectRequests: function(hash, context) {
            this._connect("reqres", hash, context);
            return this;
          },
          // Attach the handlers to a given message system `type`
          _connect: function(type, hash, context) {
            if (!hash) {
              return;
            }
            context = context || this;
            var method = type === "vent" ? "on" : "setHandler";
            _.each(hash, function(fn, eventName) {
              this[type][method](eventName, _.bind(fn, context));
            }, this);
          }
        });
        return Channel;
      }(Wreqr);
      // Wreqr.Radio
      // --------------
      //
      // An object that lets you communicate with many channels.
      Wreqr.radio = function(Wreqr) {
        "use strict";
        var Radio = function() {
          this._channels = {};
          this.vent = {};
          this.commands = {};
          this.reqres = {};
          this._proxyMethods();
        };
        _.extend(Radio.prototype, {
          channel: function(channelName) {
            if (!channelName) {
              throw new Error("Channel must receive a name");
            }
            return this._getChannel(channelName);
          },
          _getChannel: function(channelName) {
            var channel = this._channels[channelName];
            if (!channel) {
              channel = new Wreqr.Channel(channelName);
              this._channels[channelName] = channel;
            }
            return channel;
          },
          _proxyMethods: function() {
            _.each([ "vent", "commands", "reqres" ], function(system) {
              _.each(messageSystems[system], function(method) {
                this[system][method] = proxyMethod(this, system, method);
              }, this);
            }, this);
          }
        });
        var messageSystems = {
          vent: [ "on", "off", "trigger", "once", "stopListening", "listenTo", "listenToOnce" ],
          commands: [ "execute", "setHandler", "setHandlers", "removeHandler", "removeAllHandlers" ],
          reqres: [ "request", "setHandler", "setHandlers", "removeHandler", "removeAllHandlers" ]
        };
        var proxyMethod = function(radio, system, method) {
          return function(channelName) {
            var messageSystem = radio._getChannel(channelName)[system];
            var args = Array.prototype.slice.call(arguments, 1);
            return messageSystem[method].apply(messageSystem, args);
          };
        };
        return new Radio();
      }(Wreqr);
      return Backbone.Wreqr;
    })(Backbone, _);

    /////////// Modified by Atlassian ///////////
    var BackboneChildViewContainer = Backbone.ChildViewContainer.noConflict();
    var BackboneWreqr = Backbone.Wreqr.noConflict();
    /////// End of Atlassian modification ///////

    var previousMarionette = root.Marionette;

    var Marionette = Backbone.Marionette = {};

    Marionette.VERSION = '2.1.0';

    Marionette.noConflict = function() {
      root.Marionette = previousMarionette;
      return this;
    };

    Backbone.Marionette = Marionette;

    // Get the Deferred creator for later use
    Marionette.Deferred = Backbone.$.Deferred;

    /* jshint unused: false */

    // Helpers
    // -------

    // For slicing `arguments` in functions
    var slice = Array.prototype.slice;

    function throwError(message, name) {
      var error = new Error(message);
      error.name = name || 'Error';
      throw error;
    }

    // Marionette.extend
    // -----------------

    // Borrow the Backbone `extend` method so we can use it as needed
    Marionette.extend = Backbone.Model.extend;

    // Marionette.getOption
    // --------------------

    // Retrieve an object, function or other value from a target
    // object or its `options`, with `options` taking precedence.
    Marionette.getOption = function(target, optionName) {
      if (!target || !optionName) { return; }
      var value;

      if (target.options && (target.options[optionName] !== undefined)) {
        value = target.options[optionName];
      } else {
        value = target[optionName];
      }

      return value;
    };

    // Proxy `Marionette.getOption`
    Marionette.proxyGetOption = function(optionName) {
      return Marionette.getOption(this, optionName);
    };

    // Marionette.normalizeMethods
    // ----------------------

    // Pass in a mapping of events => functions or function names
    // and return a mapping of events => functions
    Marionette.normalizeMethods = function(hash) {
      var normalizedHash = {};
      _.each(hash, function(method, name) {
        if (!_.isFunction(method)) {
          method = this[method];
        }
        if (!method) {
          return;
        }
        normalizedHash[name] = method;
      }, this);
      return normalizedHash;
    };


    // allows for the use of the @ui. syntax within
    // a given key for triggers and events
    // swaps the @ui with the associated selector
    Marionette.normalizeUIKeys = function(hash, ui) {
      if (typeof(hash) === 'undefined') {
        return;
      }

      _.each(_.keys(hash), function(v) {
        var pattern = /@ui\.[a-zA-Z_$0-9]*/g;
        if (v.match(pattern)) {
          hash[v.replace(pattern, function(r) {
            return ui[r.slice(4)];
          })] = hash[v];
          delete hash[v];
        }
      });

      return hash;
    };

    // Mix in methods from Underscore, for iteration, and other
    // collection related features.
    // Borrowing this code from Backbone.Collection:
    // http://backbonejs.org/docs/backbone.html#section-121
    Marionette.actAsCollection = function(object, listProperty) {
      var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
        'select', 'reject', 'every', 'all', 'some', 'any', 'include',
        'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
        'last', 'without', 'isEmpty', 'pluck'];

      _.each(methods, function(method) {
        object[method] = function() {
          var list = _.values(_.result(this, listProperty));
          var args = [list].concat(_.toArray(arguments));
          return _[method].apply(_, args);
        };
      });
    };

    // Trigger an event and/or a corresponding method name. Examples:
    //
    // `this.triggerMethod("foo")` will trigger the "foo" event and
    // call the "onFoo" method.
    //
    // `this.triggerMethod("foo:bar")` will trigger the "foo:bar" event and
    // call the "onFooBar" method.
    Marionette.triggerMethod = (function() {

      // split the event name on the ":"
      var splitter = /(^|:)(\w)/gi;

      // take the event section ("section1:section2:section3")
      // and turn it in to uppercase name
      function getEventName(match, prefix, eventName) {
        return eventName.toUpperCase();
      }

      // actual triggerMethod implementation
      var triggerMethod = function(event) {
        // get the method name from the event name
        var methodName = 'on' + event.replace(splitter, getEventName);
        var method = this[methodName];
        var result;

        // call the onMethodName if it exists
        if (_.isFunction(method)) {
          // pass all arguments, except the event name
          result = method.apply(this, _.tail(arguments));
        }

        // trigger the event, if a trigger method exists
        if (_.isFunction(this.trigger)) {
          this.trigger.apply(this, arguments);
        }

        return result;
      };

      return triggerMethod;
    })();

    // DOMRefresh
    // ----------
    //
    // Monitor a view's state, and after it has been rendered and shown
    // in the DOM, trigger a "dom:refresh" event every time it is
    // re-rendered.

    Marionette.MonitorDOMRefresh = (function(documentElement) {
      // track when the view has been shown in the DOM,
      // using a Marionette.Region (or by other means of triggering "show")
      function handleShow(view) {
        view._isShown = true;
        triggerDOMRefresh(view);
      }

      // track when the view has been rendered
      function handleRender(view) {
        view._isRendered = true;
        triggerDOMRefresh(view);
      }

      // Trigger the "dom:refresh" event and corresponding "onDomRefresh" method
      function triggerDOMRefresh(view) {
        if (view._isShown && view._isRendered && isInDOM(view)) {
          if (_.isFunction(view.triggerMethod)) {
            view.triggerMethod('dom:refresh');
          }
        }
      }

      function isInDOM(view) {
        return Backbone.$.contains(documentElement, view.el);
      }

      // Export public API
      return function(view) {
        view.listenTo(view, 'show', function() {
          handleShow(view);
        });

        view.listenTo(view, 'render', function() {
          handleRender(view);
        });
      };
    })(document.documentElement);


    /* jshint maxparams: 5 */

    // Marionette.bindEntityEvents & unbindEntityEvents
    // ---------------------------
    //
    // These methods are used to bind/unbind a backbone "entity" (collection/model)
    // to methods on a target object.
    //
    // The first parameter, `target`, must have a `listenTo` method from the
    // EventBinder object.
    //
    // The second parameter is the entity (Backbone.Model or Backbone.Collection)
    // to bind the events from.
    //
    // The third parameter is a hash of { "event:name": "eventHandler" }
    // configuration. Multiple handlers can be separated by a space. A
    // function can be supplied instead of a string handler name.

    (function(Marionette) {
      'use strict';

      // Bind the event to handlers specified as a string of
      // handler names on the target object
      function bindFromStrings(target, entity, evt, methods) {
        var methodNames = methods.split(/\s+/);

        _.each(methodNames, function(methodName) {

          var method = target[methodName];
          if (!method) {
            throwError('Method "' + methodName +
              '" was configured as an event handler, but does not exist.');
          }

          target.listenTo(entity, evt, method);
        });
      }

      // Bind the event to a supplied callback function
      function bindToFunction(target, entity, evt, method) {
        target.listenTo(entity, evt, method);
      }

      // Bind the event to handlers specified as a string of
      // handler names on the target object
      function unbindFromStrings(target, entity, evt, methods) {
        var methodNames = methods.split(/\s+/);

        _.each(methodNames, function(methodName) {
          var method = target[methodName];
          target.stopListening(entity, evt, method);
        });
      }

      // Bind the event to a supplied callback function
      function unbindToFunction(target, entity, evt, method) {
        target.stopListening(entity, evt, method);
      }


      // generic looping function
      function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {
        if (!entity || !bindings) { return; }

        // allow the bindings to be a function
        if (_.isFunction(bindings)) {
          bindings = bindings.call(target);
        }

        // iterate the bindings and bind them
        _.each(bindings, function(methods, evt) {

          // allow for a function as the handler,
          // or a list of event names as a string
          if (_.isFunction(methods)) {
            functionCallback(target, entity, evt, methods);
          } else {
            stringCallback(target, entity, evt, methods);
          }

        });
      }

      // Export Public API
      Marionette.bindEntityEvents = function(target, entity, bindings) {
        iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);
      };

      Marionette.unbindEntityEvents = function(target, entity, bindings) {
        iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);
      };

      // Proxy `bindEntityEvents`
      Marionette.proxyBindEntityEvents = function(entity, bindings) {
        return Marionette.bindEntityEvents(this, entity, bindings);
      };

      // Proxy `unbindEntityEvents`
      Marionette.proxyUnbindEntityEvents = function(entity, bindings) {
        return Marionette.unbindEntityEvents(this, entity, bindings);
      };
    })(Marionette);


    // Callbacks
    // ---------

    // A simple way of managing a collection of callbacks
    // and executing them at a later point in time, using jQuery's
    // `Deferred` object.
    Marionette.Callbacks = function() {
      this._deferred = Marionette.Deferred();
      this._callbacks = [];
    };

    _.extend(Marionette.Callbacks.prototype, {

      // Add a callback to be executed. Callbacks added here are
      // guaranteed to execute, even if they are added after the
      // `run` method is called.
      add: function(callback, contextOverride) {
        var promise = _.result(this._deferred, 'promise');

        this._callbacks.push({cb: callback, ctx: contextOverride});

        promise.then(function(args) {
          if (contextOverride){ args.context = contextOverride; }
          callback.call(args.context, args.options);
        });
      },

      // Run all registered callbacks with the context specified.
      // Additional callbacks can be added after this has been run
      // and they will still be executed.
      run: function(options, context) {
        this._deferred.resolve({
          options: options,
          context: context
        });
      },

      // Resets the list of callbacks to be run, allowing the same list
      // to be run multiple times - whenever the `run` method is called.
      reset: function() {
        var callbacks = this._callbacks;
        this._deferred = Marionette.Deferred();
        this._callbacks = [];

        _.each(callbacks, function(cb) {
          this.add(cb.cb, cb.ctx);
        }, this);
      }
    });

    // Marionette Controller
    // ---------------------
    //
    // A multi-purpose object to use as a controller for
    // modules and routers, and as a mediator for workflow
    // and coordination of other objects, views, and more.
    Marionette.Controller = function(options) {
      this.options = options || {};

      if (_.isFunction(this.initialize)) {
        this.initialize(this.options);
      }
    };

    Marionette.Controller.extend = Marionette.extend;

    // Controller Methods
    // --------------

    // Ensure it can trigger events with Backbone.Events
    _.extend(Marionette.Controller.prototype, Backbone.Events, {
      destroy: function() {
        var args = slice.call(arguments);
        this.triggerMethod.apply(this, ['before:destroy'].concat(args));
        this.triggerMethod.apply(this, ['destroy'].concat(args));

        this.stopListening();
        this.off();
        return this;
      },

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod,

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption

    });

    // Marionette Object
    // ---------------------
    //
    // A Base Class that other Classes should descend from.
    // Object borrows many conventions and utilities from Backbone.
    Marionette.Object = function(options) {

      this.options = _.extend({}, _.result(this, 'options'), options);

      this.initialize(this.options);
    };

    Marionette.Object.extend = Marionette.extend;

    // Object Methods
    // --------------

    _.extend(Marionette.Object.prototype, {

      //this is a noop method intended to be overridden by classes that extend from this base
      initialize: function() {},

      destroy: function() {
        this.triggerMethod('before:destroy');
        this.triggerMethod('destroy');
        this.stopListening();
      },

      // Import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod,

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption,

      // Proxy `unbindEntityEvents` to enable binding view's events from another entity.
      bindEntityEvents: Marionette.proxyBindEntityEvents,

      // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
      unbindEntityEvents: Marionette.proxyUnbindEntityEvents
    });

    // Ensure it can trigger events with Backbone.Events
    _.extend(Marionette.Object.prototype, Backbone.Events);

    /* jshint maxcomplexity: 10, maxstatements: 29 */

    // Region
    // ------
    //
    // Manage the visual regions of your composite application. See
    // http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/

    Marionette.Region = function(options) {
      this.options = options || {};
      this.el = this.getOption('el');

      // Handle when this.el is passed in as a $ wrapped element.
      this.el = this.el instanceof Backbone.$ ? this.el[0] : this.el;

      if (!this.el) {
        throwError('An "el" must be specified for a region.', 'NoElError');
      }

      this.$el = this.getEl(this.el);

      if (this.initialize) {
        var args = slice.apply(arguments);
        this.initialize.apply(this, args);
      }
    };


    // Region Class methods
    // -------------------

    _.extend(Marionette.Region, {

      // Build an instance of a region by passing in a configuration object
      // and a default region class to use if none is specified in the config.
      //
      // The config object should either be a string as a jQuery DOM selector,
      // a Region class directly, or an object literal that specifies both
      // a selector and regionClass:
      //
      // ```js
      // {
      //   selector: "#foo",
      //   regionClass: MyCustomRegion
      // }
      // ```
      //
      buildRegion: function(regionConfig, DefaultRegionClass) {
        if (_.isString(regionConfig)) {
          return this._buildRegionFromSelector(regionConfig, DefaultRegionClass);
        }

        if (regionConfig.selector || regionConfig.el || regionConfig.regionClass) {
          return this._buildRegionFromObject(regionConfig, DefaultRegionClass);
        }

        if (_.isFunction(regionConfig)) {
          return this._buildRegionFromRegionClass(regionConfig);
        }

        throwError('Improper region configuration type. Please refer ' +
          'to http://marionettejs.com/docs/marionette.region.html#region-configuration-types');
      },

      // Build the region from a string selector like '#foo-region'
      _buildRegionFromSelector: function(selector, DefaultRegionClass) {
        return new DefaultRegionClass({ el: selector });
      },

      // Build the region from a configuration object
      // ```js
      // { selector: '#foo', regionClass: FooRegion }
      // ```
      _buildRegionFromObject: function(regionConfig, DefaultRegionClass) {
        var RegionClass = regionConfig.regionClass || DefaultRegionClass;
        var options = _.omit(regionConfig, 'selector', 'regionClass');

        if (regionConfig.selector && !options.el) {
          options.el = regionConfig.selector;
        }

        var region = new RegionClass(options);

        // override the `getEl` function if we have a parentEl
        // this must be overridden to ensure the selector is found
        // on the first use of the region. if we try to assign the
        // region's `el` to `parentEl.find(selector)` in the object
        // literal to build the region, the element will not be
        // guaranteed to be in the DOM already, and will cause problems
        if (regionConfig.parentEl) {
          region.getEl = function(el) {
            if (_.isObject(el)) {
              return Backbone.$(el);
            }
            var parentEl = regionConfig.parentEl;
            if (_.isFunction(parentEl)) {
              parentEl = parentEl();
            }
            return parentEl.find(el);
          };
        }

        return region;
      },

      // Build the region directly from a given `RegionClass`
      _buildRegionFromRegionClass: function(RegionClass) {
        return new RegionClass();
      }

    });

    // Region Instance Methods
    // -----------------------

    _.extend(Marionette.Region.prototype, Backbone.Events, {

      // Displays a backbone view instance inside of the region.
      // Handles calling the `render` method for you. Reads content
      // directly from the `el` attribute. Also calls an optional
      // `onShow` and `onDestroy` method on your view, just after showing
      // or just before destroying the view, respectively.
      // The `preventDestroy` option can be used to prevent a view from
      // the old view being destroyed on show.
      // The `forceShow` option can be used to force a view to be
      // re-rendered if it's already shown in the region.

      show: function(view, options){
        this._ensureElement();

        var showOptions = options || {};
        var isDifferentView = view !== this.currentView;
        var preventDestroy =  !!showOptions.preventDestroy;
        var forceShow = !!showOptions.forceShow;

        // we are only changing the view if there is a view to change to begin with
        var isChangingView = !!this.currentView;

        // only destroy the view if we don't want to preventDestroy and the view is different
        var _shouldDestroyView = !preventDestroy && isDifferentView;

        if (_shouldDestroyView) {
          this.empty();
        }

        // show the view if the view is different or if you want to re-show the view
        var _shouldShowView = isDifferentView || forceShow;

        if (_shouldShowView) {

          // We need to listen for if a view is destroyed
          // in a way other than through the region.
          // If this happens we need to remove the reference
          // to the currentView since once a view has been destroyed
          // we can not reuse it.
          view.once('destroy', _.bind(this.empty, this));
          view.render();

          if (isChangingView) {
            this.triggerMethod('before:swap', view);
          }

          this.triggerMethod('before:show', view);

          if (_.isFunction(view.triggerMethod)) {
            view.triggerMethod('before:show');
          } else {
            this.triggerMethod.call(view, 'before:show');
          }

          this.attachHtml(view);
          this.currentView = view;

          if (isChangingView) {
            this.triggerMethod('swap', view);
          }

          this.triggerMethod('show', view);

          if (_.isFunction(view.triggerMethod)) {
            view.triggerMethod('show');
          } else {
            this.triggerMethod.call(view, 'show');
          }

          return this;
        }

        return this;
      },

      _ensureElement: function(){
        if (!_.isObject(this.el)) {
          this.$el = this.getEl(this.el);
          this.el = this.$el[0];
        }

        if (!this.$el || this.$el.length === 0) {
          throwError('An "el" ' + this.$el.selector + ' must exist in DOM');
        }
      },

      // Override this method to change how the region finds the
      // DOM element that it manages. Return a jQuery selector object.
      getEl: function(el) {
        return Backbone.$(el);
      },

      // Override this method to change how the new view is
      // appended to the `$el` that the region is managing
      attachHtml: function(view) {
        // empty the node and append new view
        this.el.innerHTML='';
        this.el.appendChild(view.el);
      },

      // Destroy the current view, if there is one. If there is no
      // current view, it does nothing and returns immediately.
      empty: function() {
        var view = this.currentView;

        // If there is no view in the region
        // we should not remove anything
        if (!view) { return; }

        this.triggerMethod('before:empty', view);
        this._destroyView();
        this.triggerMethod('empty', view);

        // Remove region pointer to the currentView
        delete this.currentView;
        return this;
      },

      // call 'destroy' or 'remove', depending on which is found
      // on the view (if showing a raw Backbone view or a Marionette View)
      _destroyView: function() {
        var view = this.currentView;

        if (view.destroy && !view.isDestroyed) {
          view.destroy();
        } else if (view.remove) {
          view.remove();
        }
      },

      // Attach an existing view to the region. This
      // will not call `render` or `onShow` for the new view,
      // and will not replace the current HTML for the `el`
      // of the region.
      attachView: function(view) {
        this.currentView = view;
        return this;
      },

      // Checks whether a view is currently present within
      // the region. Returns `true` if there is and `false` if
      // no view is present.
      hasView: function() {
        return !!this.currentView;
      },

      // Reset the region by destroying any existing view and
      // clearing out the cached `$el`. The next time a view
      // is shown via this region, the region will re-query the
      // DOM for the region's `el`.
      reset: function() {
        this.empty();

        if (this.$el) {
          this.el = this.$el.selector;
        }

        delete this.$el;
        return this;
      },

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption,

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod
    });

    // Copy the `extend` function used by Backbone's classes
    Marionette.Region.extend = Marionette.extend;

    // Marionette.RegionManager
    // ------------------------
    //
    // Manage one or more related `Marionette.Region` objects.
    Marionette.RegionManager = (function(Marionette) {

      var RegionManager = Marionette.Controller.extend({
        constructor: function(options) {
          this._regions = {};
          Marionette.Controller.call(this, options);
        },

        // Add multiple regions using an object literal or a
        // function that returns an object literal, where
        // each key becomes the region name, and each value is
        // the region definition.
        addRegions: function(regionDefinitions, defaults) {
          if (_.isFunction(regionDefinitions)) {
            regionDefinitions = regionDefinitions.apply(this, arguments);
          }

          var regions = {};

          _.each(regionDefinitions, function(definition, name) {
            if (_.isString(definition)) {
              definition = {selector: definition};
            }

            if (definition.selector) {
              definition = _.defaults({}, definition, defaults);
            }

            var region = this.addRegion(name, definition);
            regions[name] = region;
          }, this);

          return regions;
        },

        // Add an individual region to the region manager,
        // and return the region instance
        addRegion: function(name, definition) {
          var region;

          var isObject = _.isObject(definition);
          var isString = _.isString(definition);
          var hasSelector = !!definition.selector;

          if (isString || (isObject && hasSelector)) {
            region = Marionette.Region.buildRegion(definition, Marionette.Region);
          } else if (_.isFunction(definition)) {
            region = Marionette.Region.buildRegion(definition, Marionette.Region);
          } else {
            region = definition;
          }

          this.triggerMethod('before:add:region', name, region);

          this._store(name, region);

          this.triggerMethod('add:region', name, region);
          return region;
        },

        // Get a region by name
        get: function(name) {
          return this._regions[name];
        },

        // Gets all the regions contained within
        // the `regionManager` instance.
        getRegions: function(){
          return _.clone(this._regions);
        },

        // Remove a region by name
        removeRegion: function(name) {
          var region = this._regions[name];
          this._remove(name, region);

          return region;
        },

        // Empty all regions in the region manager, and
        // remove them
        removeRegions: function() {
          var regions = this.getRegions();
          _.each(this._regions, function(region, name) {
            this._remove(name, region);
          }, this);

          return regions;
        },

        // Empty all regions in the region manager, but
        // leave them attached
        emptyRegions: function() {
          var regions = this.getRegions();
          _.each(regions, function(region) {
            region.empty();
          }, this);

          return regions;
        },

        // Destroy all regions and shut down the region
        // manager entirely
        destroy: function() {
          this.removeRegions();
          return Marionette.Controller.prototype.destroy.apply(this, arguments);
        },

        // internal method to store regions
        _store: function(name, region) {
          this._regions[name] = region;
          this._setLength();
        },

        // internal method to remove a region
        _remove: function(name, region) {
          this.triggerMethod('before:remove:region', name, region);
          region.empty();
          region.stopListening();
          delete this._regions[name];
          this._setLength();
          this.triggerMethod('remove:region', name, region);
        },

        // set the number of regions current held
        _setLength: function() {
          this.length = _.size(this._regions);
        }

      });

      Marionette.actAsCollection(RegionManager.prototype, '_regions');

      return RegionManager;
    })(Marionette);


    // Template Cache
    // --------------

    // Manage templates stored in `<script>` blocks,
    // caching them for faster access.
    Marionette.TemplateCache = function(templateId) {
      this.templateId = templateId;
    };

    // TemplateCache object-level methods. Manage the template
    // caches from these method calls instead of creating
    // your own TemplateCache instances
    _.extend(Marionette.TemplateCache, {
      templateCaches: {},

      // Get the specified template by id. Either
      // retrieves the cached version, or loads it
      // from the DOM.
      get: function(templateId) {
        var cachedTemplate = this.templateCaches[templateId];

        if (!cachedTemplate) {
          cachedTemplate = new Marionette.TemplateCache(templateId);
          this.templateCaches[templateId] = cachedTemplate;
        }

        return cachedTemplate.load();
      },

      // Clear templates from the cache. If no arguments
      // are specified, clears all templates:
      // `clear()`
      //
      // If arguments are specified, clears each of the
      // specified templates from the cache:
      // `clear("#t1", "#t2", "...")`
      clear: function() {
        var i;
        var args = slice.call(arguments);
        var length = args.length;

        if (length > 0) {
          for (i = 0; i < length; i++) {
            delete this.templateCaches[args[i]];
          }
        } else {
          this.templateCaches = {};
        }
      }
    });

    // TemplateCache instance methods, allowing each
    // template cache object to manage its own state
    // and know whether or not it has been loaded
    _.extend(Marionette.TemplateCache.prototype, {

      // Internal method to load the template
      load: function() {
        // Guard clause to prevent loading this template more than once
        if (this.compiledTemplate) {
          return this.compiledTemplate;
        }

        // Load the template and compile it
        var template = this.loadTemplate(this.templateId);
        this.compiledTemplate = this.compileTemplate(template);

        return this.compiledTemplate;
      },

      // Load a template from the DOM, by default. Override
      // this method to provide your own template retrieval
      // For asynchronous loading with AMD/RequireJS, consider
      // using a template-loader plugin as described here:
      // https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs
      loadTemplate: function(templateId) {
        var template = Backbone.$(templateId).html();

        if (!template || template.length === 0) {
          throwError('Could not find template: "' + templateId + '"', 'NoTemplateError');
        }

        return template;
      },

      // Pre-compile the template before caching it. Override
      // this method if you do not need to pre-compile a template
      // (JST / RequireJS for example) or if you want to change
      // the template engine used (Handebars, etc).
      compileTemplate: function(rawTemplate) {
        return _.template(rawTemplate);
      }
    });

    // Renderer
    // --------

    // Render a template with data by passing in the template
    // selector and the data to render.
    Marionette.Renderer = {

      // Render a template with data. The `template` parameter is
      // passed to the `TemplateCache` object to retrieve the
      // template function. Override this method to provide your own
      // custom rendering and template handling for all of Marionette.
      render: function(template, data) {
        if (!template) {
          throwError('Cannot render the template since its false, null or undefined.',
            'TemplateNotFoundError');
        }

        var templateFunc;
        if (typeof template === 'function') {
          templateFunc = template;
        } else {
          templateFunc = Marionette.TemplateCache.get(template);
        }

        return templateFunc(data);
      }
    };


    /* jshint maxlen: 114, nonew: false */
    // Marionette.View
    // ---------------

    // The core view class that other Marionette views extend from.
    Marionette.View = Backbone.View.extend({

      constructor: function(options) {
        _.bindAll(this, 'render');

        // this exposes view options to the view initializer
        // this is a backfill since backbone removed the assignment
        // of this.options
        // at some point however this may be removed
        this.options = _.extend({}, _.result(this, 'options'), _.isFunction(options) ? options.call(this) : options);
        // parses out the @ui DSL for events
        this.events = this.normalizeUIKeys(_.result(this, 'events'));

        if (_.isObject(this.behaviors)) {
          new Marionette.Behaviors(this);
        }

        Backbone.View.apply(this, arguments);

        Marionette.MonitorDOMRefresh(this);
        this.listenTo(this, 'show', this.onShowCalled);
      },

      // Get the template for this view
      // instance. You can set a `template` attribute in the view
      // definition or pass a `template: "whatever"` parameter in
      // to the constructor options.
      getTemplate: function() {
        return this.getOption('template');
      },

      // Serialize a model by returning its attributes. Clones
      // the attributes to allow modification.
      serializeModel: function(model){
        return model.toJSON.apply(model, slice.call(arguments, 1));
      },

      // Mix in template helper methods. Looks for a
      // `templateHelpers` attribute, which can either be an
      // object literal, or a function that returns an object
      // literal. All methods and attributes from this object
      // are copies to the object passed in.
      mixinTemplateHelpers: function(target) {
        target = target || {};
        var templateHelpers = this.getOption('templateHelpers');
        if (_.isFunction(templateHelpers)) {
          templateHelpers = templateHelpers.call(this);
        }
        return _.extend(target, templateHelpers);
      },


      normalizeUIKeys: function(hash) {
        var ui = _.result(this, 'ui');
        var uiBindings = _.result(this, '_uiBindings');
        return Marionette.normalizeUIKeys(hash, uiBindings || ui);
      },

      // Configure `triggers` to forward DOM events to view
      // events. `triggers: {"click .foo": "do:foo"}`
      configureTriggers: function() {
        if (!this.triggers) { return; }

        var triggerEvents = {};

        // Allow `triggers` to be configured as a function
        var triggers = this.normalizeUIKeys(_.result(this, 'triggers'));

        // Configure the triggers, prevent default
        // action and stop propagation of DOM events
        _.each(triggers, function(value, key) {

          var hasOptions = _.isObject(value);
          var eventName = hasOptions ? value.event : value;

          // build the event handler function for the DOM event
          triggerEvents[key] = function(e) {

            // stop the event in its tracks
            if (e) {
              var prevent = e.preventDefault;
              var stop = e.stopPropagation;

              var shouldPrevent = hasOptions ? value.preventDefault : prevent;
              var shouldStop = hasOptions ? value.stopPropagation : stop;

              if (shouldPrevent && prevent) { prevent.apply(e); }
              if (shouldStop && stop) { stop.apply(e); }
            }

            // build the args for the event
            var args = {
              view: this,
              model: this.model,
              collection: this.collection
            };

            // trigger the event
            this.triggerMethod(eventName, args);
          };

        }, this);

        return triggerEvents;
      },

      // Overriding Backbone.View's delegateEvents to handle
      // the `triggers`, `modelEvents`, and `collectionEvents` configuration
      delegateEvents: function(events) {
        this._delegateDOMEvents(events);
        this.bindEntityEvents(this.model, this.getOption('modelEvents'));
        this.bindEntityEvents(this.collection, this.getOption('collectionEvents'));
        return this;
      },

      // internal method to delegate DOM events and triggers
      _delegateDOMEvents: function(events) {
        events = events || this.events;
        if (_.isFunction(events)) { events = events.call(this); }

        // normalize ui keys
        events = this.normalizeUIKeys(events);

        var combinedEvents = {};

        // look up if this view has behavior events
        var behaviorEvents = _.result(this, 'behaviorEvents') || {};
        var triggers = this.configureTriggers();

        // behavior events will be overriden by view events and or triggers
        _.extend(combinedEvents, behaviorEvents, events, triggers);

        Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
      },

      // Overriding Backbone.View's undelegateEvents to handle unbinding
      // the `triggers`, `modelEvents`, and `collectionEvents` config
      undelegateEvents: function() {
        var args = slice.call(arguments);
        Backbone.View.prototype.undelegateEvents.apply(this, args);
        this.unbindEntityEvents(this.model, this.getOption('modelEvents'));
        this.unbindEntityEvents(this.collection, this.getOption('collectionEvents'));
        return this;
      },

      // Internal method, handles the `show` event.
      onShowCalled: function() {},

      // Internal helper method to verify whether the view hasn't been destroyed
      _ensureViewIsIntact: function() {
        if (this.isDestroyed) {
          var err = new Error('Cannot use a view thats already been destroyed.');
          err.name = 'ViewDestroyedError';
          throw err;
        }
      },

      // Default `destroy` implementation, for removing a view from the
      // DOM and unbinding it. Regions will call this method
      // for you. You can specify an `onDestroy` method in your view to
      // add custom code that is called after the view is destroyed.
      destroy: function() {
        if (this.isDestroyed) { return; }

        var args = slice.call(arguments);

        this.triggerMethod.apply(this, ['before:destroy'].concat(args));

        // mark as destroyed before doing the actual destroy, to
        // prevent infinite loops within "destroy" event handlers
        // that are trying to destroy other views
        this.isDestroyed = true;
        this.triggerMethod.apply(this, ['destroy'].concat(args));

        // unbind UI elements
        this.unbindUIElements();

        // remove the view from the DOM
        this.remove();
        return this;
      },

      // This method binds the elements specified in the "ui" hash inside the view's code with
      // the associated jQuery selectors.
      bindUIElements: function() {
        if (!this.ui) { return; }

        // store the ui hash in _uiBindings so they can be reset later
        // and so re-rendering the view will be able to find the bindings
        if (!this._uiBindings) {
          this._uiBindings = this.ui;
        }

        // get the bindings result, as a function or otherwise
        var bindings = _.result(this, '_uiBindings');

        // empty the ui so we don't have anything to start with
        this.ui = {};

        // bind each of the selectors
        _.each(_.keys(bindings), function(key) {
          var selector = bindings[key];
          this.ui[key] = this.$(selector);
        }, this);
      },

      // This method unbinds the elements specified in the "ui" hash
      unbindUIElements: function() {
        if (!this.ui || !this._uiBindings) { return; }

        // delete all of the existing ui bindings
        _.each(this.ui, function($el, name) {
          delete this.ui[name];
        }, this);

        // reset the ui element to the original bindings configuration
        this.ui = this._uiBindings;
        delete this._uiBindings;
      },

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod,

      // Imports the "normalizeMethods" to transform hashes of
      // events=>function references/names to a hash of events=>function references
      normalizeMethods: Marionette.normalizeMethods,

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption,

      // Proxy `unbindEntityEvents` to enable binding view's events from another entity.
      bindEntityEvents: Marionette.proxyBindEntityEvents,

      // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
      unbindEntityEvents: Marionette.proxyUnbindEntityEvents
    });

    // Item View
    // ---------

    // A single item view implementation that contains code for rendering
    // with underscore.js templates, serializing the view's model or collection,
    // and calling several methods on extended views, such as `onRender`.
    Marionette.ItemView = Marionette.View.extend({

      // Setting up the inheritance chain which allows changes to
      // Marionette.View.prototype.constructor which allows overriding
      constructor: function() {
        Marionette.View.apply(this, arguments);
      },

      // Serialize the model or collection for the view. If a model is
      // found, the view's `serializeModel` is called. If a collection is found,
      // each model in the collection is serialized by calling
      // the view's `serializeCollection` and put into an `items` array in
      // the resulting data. If both are found, defaults to the model.
      // You can override the `serializeData` method in your own view definition,
      // to provide custom serialization for your view's data.
      serializeData: function(){
        var data = {};

        if (this.model) {
          data = _.partial(this.serializeModel, this.model).apply(this, arguments);
        }
        else if (this.collection) {
          data = { items: _.partial(this.serializeCollection, this.collection).apply(this, arguments) };
        }

        return data;
      },

      // Serialize a collection by serializing each of its models.
      serializeCollection: function(collection){
        return collection.toJSON.apply(collection, slice.call(arguments, 1));
      },

      // Render the view, defaulting to underscore.js templates.
      // You can override this in your view definition to provide
      // a very specific rendering for your view. In general, though,
      // you should override the `Marionette.Renderer` object to
      // change how Marionette renders views.
      render: function() {
        this._ensureViewIsIntact();

        this.triggerMethod('before:render', this);

        this._renderTemplate();
        this.bindUIElements();

        this.triggerMethod('render', this);

        return this;
      },

      // Internal method to render the template with the serialized data
      // and template helpers via the `Marionette.Renderer` object.
      // Throws an `UndefinedTemplateError` error if the template is
      // any falsely value but literal `false`.
      _renderTemplate: function() {
        var template = this.getTemplate();

        // Allow template-less item views
        if (template === false) {
          return;
        }

        if (!template) {
          throwError('Cannot render the template since it is null or undefined.',
            'UndefinedTemplateError');
        }

        // Add in entity data and template helpers
        var data = this.serializeData();
        data = this.mixinTemplateHelpers(data);

        // Render and add to el
        var html = Marionette.Renderer.render(template, data, this);
        this.attachElContent(html);

        return this;
      },

      // Attaches the content of a given view.
      // This method can be overriden to optimize rendering,
      // or to render in a non standard way.
      //
      // For example, using `innerHTML` instead of `$el.html`
      //
      // ```js
      // attachElContent: function(html) {
      //   this.el.innerHTML = html;
      //   return this;
      // }
      // ```
      attachElContent: function(html) {
        this.$el.html(html);

        return this;
      },

      // Override the default destroy event to add a few
      // more events that are triggered.
      destroy: function() {
        if (this.isDestroyed) { return; }

        return Marionette.View.prototype.destroy.apply(this, arguments);
      }
    });

    /* jshint maxstatements: 14 */

    // Collection View
    // ---------------

    // A view that iterates over a Backbone.Collection
    // and renders an individual child view for each model.
    Marionette.CollectionView = Marionette.View.extend({

      // used as the prefix for child view events
      // that are forwarded through the collectionview
      childViewEventPrefix: 'childview',

      // constructor
      // option to pass `{sort: false}` to prevent the `CollectionView` from
      // maintaining the sorted order of the collection.
      // This will fallback onto appending childView's to the end.
      constructor: function(options){
        var initOptions = options || {};
        this.sort = _.isUndefined(initOptions.sort) ? true : initOptions.sort;

        this._initChildViewStorage();

        Marionette.View.apply(this, arguments);

        this._initialEvents();
        this.initRenderBuffer();
      },

      // Instead of inserting elements one by one into the page,
      // it's much more performant to insert elements into a document
      // fragment and then insert that document fragment into the page
      initRenderBuffer: function() {
        this.elBuffer = document.createDocumentFragment();
        this._bufferedChildren = [];
      },

      startBuffering: function() {
        this.initRenderBuffer();
        this.isBuffering = true;
      },

      endBuffering: function() {
        this.isBuffering = false;
        this._triggerBeforeShowBufferedChildren();
        this.attachBuffer(this, this.elBuffer);
        this._triggerShowBufferedChildren();
        this.initRenderBuffer();
      },

      _triggerBeforeShowBufferedChildren: function() {
        if (this._isShown) {
          _.invoke(this._bufferedChildren, 'triggerMethod', 'before:show');
        }
      },

      _triggerShowBufferedChildren: function() {
        if (this._isShown) {
          _.each(this._bufferedChildren, function (child) {
            if (_.isFunction(child.triggerMethod)) {
              child.triggerMethod('show');
            } else {
              Marionette.triggerMethod.call(child, 'show');
            }
          });
          this._bufferedChildren = [];
        }
      },

      // Configured the initial events that the collection view
      // binds to.
      _initialEvents: function() {
        if (this.collection) {
          this.listenTo(this.collection, 'add', this._onCollectionAdd);
          this.listenTo(this.collection, 'remove', this._onCollectionRemove);
          this.listenTo(this.collection, 'reset', this.render);

          if (this.sort) {
            this.listenTo(this.collection, 'sort', this._sortViews);
          }
        }
      },

      // Handle a child added to the collection
      _onCollectionAdd: function(child) {
        this.destroyEmptyView();
        var ChildView = this.getChildView(child);
        var index = this.collection.indexOf(child);
        this.addChild(child, ChildView, index);
      },

      // get the child view by model it holds, and remove it
      _onCollectionRemove: function(model) {
        var view = this.children.findByModel(model);
        this.removeChildView(view);
        this.checkEmpty();
      },

      // Override from `Marionette.View` to trigger show on child views
      onShowCalled: function(){
        this.children.each(function(child){
          if (_.isFunction(child.triggerMethod)) {
            child.triggerMethod('show');
          } else {
            Marionette.triggerMethod.call(child, 'show');
          }
        });
      },

      // Render children views. Override this method to
      // provide your own implementation of a render function for
      // the collection view.
      render: function() {
        this._ensureViewIsIntact();
        this.triggerMethod('before:render', this);
        this._renderChildren();
        this.triggerMethod('render', this);
        return this;
      },

      // Render view after sorting. Override this method to
      // change how the view renders after a `sort` on the collection.
      // An example of this would be to only `renderChildren` in a `CompositeView`
      // rather than the full view.
      resortView: function() {
        this.render();
      },

      // Internal method. This checks for any changes in the order of the collection.
      // If the index of any view doesn't match, it will render.
      _sortViews: function() {
        // check for any changes in sort order of views
        var orderChanged = this.collection.find(function(item, index){
          var view = this.children.findByModel(item);
          return !view || view._index !== index;
        }, this);

        if (orderChanged) {
          this.resortView();
        }
      },

      // Internal method. Separated so that CompositeView can have
      // more control over events being triggered, around the rendering
      // process
      _renderChildren: function() {
        this.destroyEmptyView();
        this.destroyChildren();

        if (this.isEmpty(this.collection)) {
          this.showEmptyView();
        } else {
          this.triggerMethod('before:render:collection', this);
          this.startBuffering();
          this.showCollection();
          this.endBuffering();
          this.triggerMethod('render:collection', this);
        }
      },

      // Internal method to loop through collection and show each child view.
      showCollection: function() {
        var ChildView;
        this.collection.each(function(child, index) {
          ChildView = this.getChildView(child);
          this.addChild(child, ChildView, index);
        }, this);
      },

      // Internal method to show an empty view in place of
      // a collection of child views, when the collection is empty
      showEmptyView: function() {
        var EmptyView = this.getEmptyView();

        if (EmptyView && !this._showingEmptyView) {
          this.triggerMethod('before:render:empty');

          this._showingEmptyView = true;
          var model = new Backbone.Model();
          this.addEmptyView(model, EmptyView);

          this.triggerMethod('render:empty');
        }
      },

      // Internal method to destroy an existing emptyView instance
      // if one exists. Called when a collection view has been
      // rendered empty, and then a child is added to the collection.
      destroyEmptyView: function() {
        if (this._showingEmptyView) {
          this.destroyChildren();
          delete this._showingEmptyView;
        }
      },

      // Retrieve the empty view class
      getEmptyView: function() {
        return this.getOption('emptyView');
      },

      // Render and show the emptyView. Similar to addChild method
      // but "child:added" events are not fired, and the event from
      // emptyView are not forwarded
      addEmptyView: function(child, EmptyView){

        // get the emptyViewOptions, falling back to childViewOptions
        var emptyViewOptions = this.getOption('emptyViewOptions') ||
                              this.getOption('childViewOptions');

        if (_.isFunction(emptyViewOptions)){
          emptyViewOptions = emptyViewOptions.call(this);
        }

        // build the empty view
        var view = this.buildChildView(child, EmptyView, emptyViewOptions);

        // trigger the 'before:show' event on `view` if the collection view
        // has already been shown
        if (this._isShown){
          this.triggerMethod.call(view, 'before:show');
        }

        // Store the `emptyView` like a `childView` so we can properly
        // remove and/or close it later
        this.children.add(view);

        // Render it and show it
        this.renderChildView(view, -1);

        // call the 'show' method if the collection view
        // has already been shown
        if (this._isShown){
          this.triggerMethod.call(view, 'show');
        }
      },

      // Retrieve the `childView` class, either from `this.options.childView`
      // or from the `childView` in the object definition. The "options"
      // takes precedence.
      // This method receives the model that will be passed to the instance
      // created from this `childView`. Overriding methods may use the child
      // to determine what `childView` class to return.
      getChildView: function(child) {
        var childView = this.getOption('childView');

        if (!childView) {
          throwError('A "childView" must be specified', 'NoChildViewError');
        }

        return childView;
      },

      // Render the child's view and add it to the
      // HTML for the collection view at a given index.
      // This will also update the indices of later views in the collection
      // in order to keep the children in sync with the collection.
      addChild: function(child, ChildView, index) {
        var childViewOptions = this.getOption('childViewOptions');
        if (_.isFunction(childViewOptions)) {
          childViewOptions = childViewOptions.call(this, child, index);
        }

        var view = this.buildChildView(child, ChildView, childViewOptions);

        // increment indices of views after this one
        this._updateIndices(view, true, index);

        this._addChildView(view, index);

        return view;
      },

      // Internal method. This decrements or increments the indices of views after the
      // added/removed view to keep in sync with the collection.
      _updateIndices: function(view, increment, index) {
        if (!this.sort) {
          return;
        }

        if (increment) {
          // assign the index to the view
          view._index = index;

          // increment the index of views after this one
          this.children.each(function (laterView) {
            if (laterView._index >= view._index) {
              laterView._index++;
            }
          });
        }
        else {
          // decrement the index of views after this one
          this.children.each(function (laterView) {
            if (laterView._index >= view._index) {
              laterView._index--;
            }
          });
        }
      },


      // Internal Method. Add the view to children and render it at
      // the given index.
      _addChildView: function(view, index) {
        // set up the child view event forwarding
        this.proxyChildEvents(view);

        this.triggerMethod('before:add:child', view);

        // Store the child view itself so we can properly
        // remove and/or destroy it later
        this.children.add(view);
        this.renderChildView(view, index);

        if (this._isShown && !this.isBuffering){
          if (_.isFunction(view.triggerMethod)) {
            view.triggerMethod('show');
          } else {
            Marionette.triggerMethod.call(view, 'show');
          }
        }

        this.triggerMethod('add:child', view);
      },

      // render the child view
      renderChildView: function(view, index) {
        view.render();
        this.attachHtml(this, view, index);
        return view;
      },

      // Build a `childView` for a model in the collection.
      buildChildView: function(child, ChildViewClass, childViewOptions) {
        var options = _.extend({model: child}, childViewOptions);
        return new ChildViewClass(options);
      },

      // Remove the child view and destroy it.
      // This function also updates the indices of
      // later views in the collection in order to keep
      // the children in sync with the collection.
      removeChildView: function(view) {

        if (view) {
          this.triggerMethod('before:remove:child', view);
          // call 'destroy' or 'remove', depending on which is found
          if (view.destroy) { view.destroy(); }
          else if (view.remove) { view.remove(); }

          this.stopListening(view);
          this.children.remove(view);
          this.triggerMethod('remove:child', view);

          // decrement the index of views after this one
          this._updateIndices(view, false);
        }

        return view;
      },

      // check if the collection is empty
      isEmpty: function(collection) {
        return !this.collection || this.collection.length === 0;
      },

      // If empty, show the empty view
      checkEmpty: function() {
        if (this.isEmpty(this.collection)) {
          this.showEmptyView();
        }
      },

      // You might need to override this if you've overridden attachHtml
      attachBuffer: function(collectionView, buffer) {
        collectionView.$el.append(buffer);
      },

      // Append the HTML to the collection's `el`.
      // Override this method to do something other
      // than `.append`.
      attachHtml: function(collectionView, childView, index) {
        if (collectionView.isBuffering) {
          // buffering happens on reset events and initial renders
          // in order to reduce the number of inserts into the
          // document, which are expensive.
          collectionView.elBuffer.appendChild(childView.el);
          collectionView._bufferedChildren.push(childView);
        }
        else {
          // If we've already rendered the main collection, append
          // the new child into the correct order if we need to. Otherwise
          // append to the end.
          if (!collectionView._insertBefore(childView, index)){
            collectionView._insertAfter(childView);
          }
        }
      },

      // Internal method. Check whether we need to insert the view into
      // the correct position.
      _insertBefore: function(childView, index) {
        var currentView;
        var findPosition = this.sort && (index < this.children.length - 1);
        if (findPosition) {
          // Find the view after this one
          currentView = this.children.find(function (view) {
            return view._index === index + 1;
          });
        }

        if (currentView) {
          currentView.$el.before(childView.el);
          return true;
        }

        return false;
      },

      // Internal method. Append a view to the end of the $el
      _insertAfter: function(childView) {
        this.$el.append(childView.el);
      },

      // Internal method to set up the `children` object for
      // storing all of the child views
      _initChildViewStorage: function() {
        this.children = new BackboneChildViewContainer();
      },

      // Handle cleanup and other destroying needs for the collection of views
      destroy: function() {
        if (this.isDestroyed) { return; }

        this.triggerMethod('before:destroy:collection');
        this.destroyChildren();
        this.triggerMethod('destroy:collection');

        return Marionette.View.prototype.destroy.apply(this, arguments);
      },

      // Destroy the child views that this collection view
      // is holding on to, if any
      destroyChildren: function() {
        var childViews = this.children.map(_.identity);
        this.children.each(this.removeChildView, this);
        this.checkEmpty();
        return childViews;
      },

      // Set up the child view event forwarding. Uses a "childview:"
      // prefix in front of all forwarded events.
      proxyChildEvents: function(view) {
        var prefix = this.getOption('childViewEventPrefix');

        // Forward all child view events through the parent,
        // prepending "childview:" to the event name
        this.listenTo(view, 'all', function() {
          var args = slice.call(arguments);
          var rootEvent = args[0];
          var childEvents = this.normalizeMethods(_.result(this, 'childEvents'));

          args[0] = prefix + ':' + rootEvent;
          args.splice(1, 0, view);

          // call collectionView childEvent if defined
          if (typeof childEvents !== 'undefined' && _.isFunction(childEvents[rootEvent])) {
            childEvents[rootEvent].apply(this, args.slice(1));
          }

          this.triggerMethod.apply(this, args);
        }, this);
      }
    });

    /* jshint maxstatements: 17, maxlen: 117 */

    // Composite View
    // --------------

    // Used for rendering a branch-leaf, hierarchical structure.
    // Extends directly from CollectionView and also renders an
    // a child view as `modelView`, for the top leaf
    Marionette.CompositeView = Marionette.CollectionView.extend({

      // Setting up the inheritance chain which allows changes to
      // Marionette.CollectionView.prototype.constructor which allows overriding
      // option to pass '{sort: false}' to prevent the CompositeView from
      // maintaining the sorted order of the collection.
      // This will fallback onto appending childView's to the end.
      constructor: function() {
        Marionette.CollectionView.apply(this, arguments);
      },

      // Configured the initial events that the composite view
      // binds to. Override this method to prevent the initial
      // events, or to add your own initial events.
      _initialEvents: function() {

        // Bind only after composite view is rendered to avoid adding child views
        // to nonexistent childViewContainer
        this.once('render', function() {
          if (this.collection) {
            this.listenTo(this.collection, 'add', this._onCollectionAdd);
            this.listenTo(this.collection, 'remove', this._onCollectionRemove);
            this.listenTo(this.collection, 'reset', this._renderChildren);

            if (this.sort) {
              this.listenTo(this.collection, 'sort', this._sortViews);
            }
          }
        });

      },

      // Retrieve the `childView` to be used when rendering each of
      // the items in the collection. The default is to return
      // `this.childView` or Marionette.CompositeView if no `childView`
      // has been defined
      getChildView: function(child) {
        var childView = this.getOption('childView') || this.constructor;

        if (!childView) {
          throwError('A "childView" must be specified', 'NoChildViewError');
        }

        return childView;
      },

      // Serialize the collection for the view.
      // You can override the `serializeData` method in your own view
      // definition, to provide custom serialization for your view's data.
      serializeData: function() {
        var data = {};

        if (this.model){
          data = _.partial(this.serializeModel, this.model).apply(this, arguments);
        }

        return data;
      },

      // Renders the model once, and the collection once. Calling
      // this again will tell the model's view to re-render itself
      // but the collection will not re-render.
      render: function() {
        this._ensureViewIsIntact();
        this.isRendered = true;
        this.resetChildViewContainer();

        this.triggerMethod('before:render', this);

        this._renderTemplate();
        this._renderChildren();

        this.triggerMethod('render', this);
        return this;
      },

      _renderChildren: function() {
        if (this.isRendered) {
          Marionette.CollectionView.prototype._renderChildren.call(this);
        }
      },

      // Render the root template that the children
      // views are appended to
      _renderTemplate: function() {
        var data = {};
        data = this.serializeData();
        data = this.mixinTemplateHelpers(data);

        this.triggerMethod('before:render:template');

        var template = this.getTemplate();
        var html = Marionette.Renderer.render(template, data, this);
        this.attachElContent(html);

        // the ui bindings is done here and not at the end of render since they
        // will not be available until after the model is rendered, but should be
        // available before the collection is rendered.
        this.bindUIElements();
        this.triggerMethod('render:template');
      },

      // Attaches the content of the root.
      // This method can be overriden to optimize rendering,
      // or to render in a non standard way.
      //
      // For example, using `innerHTML` instead of `$el.html`
      //
      // ```js
      // attachElContent: function(html) {
      //   this.el.innerHTML = html;
      //   return this;
      // }
      // ```
      attachElContent: function(html) {
        this.$el.html(html);

        return this;
      },

      // You might need to override this if you've overridden attachHtml
      attachBuffer: function(compositeView, buffer) {
        var $container = this.getChildViewContainer(compositeView);
        $container.append(buffer);
      },

      // Internal method. Append a view to the end of the $el.
      // Overidden from CollectionView to ensure view is appended to
      // childViewContainer
      _insertAfter: function (childView) {
        var $container = this.getChildViewContainer(this);
        $container.append(childView.el);
      },

      // Internal method to ensure an `$childViewContainer` exists, for the
      // `attachHtml` method to use.
      getChildViewContainer: function(containerView) {
        if ('$childViewContainer' in containerView) {
          return containerView.$childViewContainer;
        }

        var container;
        var childViewContainer = Marionette.getOption(containerView, 'childViewContainer');
        if (childViewContainer) {

          var selector = _.isFunction(childViewContainer) ? childViewContainer.call(containerView) : childViewContainer;

          if (selector.charAt(0) === '@' && containerView.ui) {
            container = containerView.ui[selector.substr(4)];
          } else {
            container = containerView.$(selector);
          }

          if (container.length <= 0) {
            throwError('The specified "childViewContainer" was not found: ' +
              containerView.childViewContainer, 'ChildViewContainerMissingError');
          }

        } else {
          container = containerView.$el;
        }

        containerView.$childViewContainer = container;
        return container;
      },

      // Internal method to reset the `$childViewContainer` on render
      resetChildViewContainer: function() {
        if (this.$childViewContainer) {
          delete this.$childViewContainer;
        }
      }
    });

    // LayoutView
    // ----------

    // Used for managing application layoutViews, nested layoutViews and
    // multiple regions within an application or sub-application.
    //
    // A specialized view class that renders an area of HTML and then
    // attaches `Region` instances to the specified `regions`.
    // Used for composite view management and sub-application areas.
    Marionette.LayoutView = Marionette.ItemView.extend({
      regionClass: Marionette.Region,

      // Ensure the regions are available when the `initialize` method
      // is called.
      constructor: function(options) {
        options = options || {};

        this._firstRender = true;
        this._initializeRegions(options);

        Marionette.ItemView.call(this, options);
      },

      // LayoutView's render will use the existing region objects the
      // first time it is called. Subsequent calls will destroy the
      // views that the regions are showing and then reset the `el`
      // for the regions to the newly rendered DOM elements.
      render: function() {
        this._ensureViewIsIntact();

        if (this._firstRender) {
          // if this is the first render, don't do anything to
          // reset the regions
          this._firstRender = false;
        } else {
          // If this is not the first render call, then we need to
          // re-initialize the `el` for each region
          this._reInitializeRegions();
        }

        return Marionette.ItemView.prototype.render.apply(this, arguments);
      },

      // Handle destroying regions, and then destroy the view itself.
      destroy: function() {
        if (this.isDestroyed) { return this; }

        this.regionManager.destroy();
        return Marionette.ItemView.prototype.destroy.apply(this, arguments);
      },

      // Add a single region, by name, to the layoutView
      addRegion: function(name, definition) {
        this.triggerMethod('before:region:add', name);
        var regions = {};
        regions[name] = definition;
        return this._buildRegions(regions)[name];
      },

      // Add multiple regions as a {name: definition, name2: def2} object literal
      addRegions: function(regions) {
        this.regions = _.extend({}, this.regions, regions);
        return this._buildRegions(regions);
      },

      // Remove a single region from the LayoutView, by name
      removeRegion: function(name) {
        this.triggerMethod('before:region:remove', name);
        delete this.regions[name];
        return this.regionManager.removeRegion(name);
      },

      // Provides alternative access to regions
      // Accepts the region name
      // getRegion('main')
      getRegion: function(region) {
        return this.regionManager.get(region);
      },

      // Get all regions
      getRegions: function(){
        return this.regionManager.getRegions();
      },

      // internal method to build regions
      _buildRegions: function(regions) {
        var that = this;

        var defaults = {
          regionClass: this.getOption('regionClass'),
          parentEl: function() { return that.$el; }
        };

        return this.regionManager.addRegions(regions, defaults);
      },

      // Internal method to initialize the regions that have been defined in a
      // `regions` attribute on this layoutView.
      _initializeRegions: function(options) {
        var regions;
        this._initRegionManager();

        if (_.isFunction(this.regions)) {
          regions = this.regions(options);
        } else {
          regions = this.regions || {};
        }

        // Enable users to define `regions` as instance options.
        var regionOptions = this.getOption.call(options, 'regions');

        // enable region options to be a function
        if (_.isFunction(regionOptions)) {
          regionOptions = regionOptions.call(this, options);
        }

        _.extend(regions, regionOptions);

        this.addRegions(regions);
      },

      // Internal method to re-initialize all of the regions by updating the `el` that
      // they point to
      _reInitializeRegions: function() {
        this.regionManager.emptyRegions();
        this.regionManager.each(function(region) {
          region.reset();
        });
      },

      // Enable easy overiding of the default `RegionManager`
      // for customized region interactions and buisness specific
      // view logic for better control over single regions.
      getRegionManager: function() {
        return new Marionette.RegionManager();
      },

      // Internal method to initialize the region manager
      // and all regions in it
      _initRegionManager: function() {
        this.regionManager = this.getRegionManager();

        this.listenTo(this.regionManager, 'before:add:region', function(name) {
          this.triggerMethod('before:add:region', name);
        });

        this.listenTo(this.regionManager, 'add:region', function(name, region) {
          this[name] = region;
          this.triggerMethod('add:region', name, region);
        });

        this.listenTo(this.regionManager, 'before:remove:region', function(name) {
          this.triggerMethod('before:remove:region', name);
        });

        this.listenTo(this.regionManager, 'remove:region', function(name, region) {
          delete this[name];
          this.triggerMethod('remove:region', name, region);
        });
      }
    });


    // Behavior
    // -----------

    // A Behavior is an isolated set of DOM /
    // user interactions that can be mixed into any View.
    // Behaviors allow you to blackbox View specific interactions
    // into portable logical chunks, keeping your views simple and your code DRY.

    Marionette.Behavior = (function(_, Backbone) {
      function Behavior(options, view) {
        // Setup reference to the view.
        // this comes in handle when a behavior
        // wants to directly talk up the chain
        // to the view.
        this.view = view;
        this.defaults = _.result(this, 'defaults') || {};
        this.options  = _.extend({}, this.defaults, options);

        // proxy behavior $ method to the view
        // this is useful for doing jquery DOM lookups
        // scoped to behaviors view.
        this.$ = function() {
          return this.view.$.apply(this.view, arguments);
        };

        // Call the initialize method passing
        // the arguments from the instance constructor
        this.initialize.apply(this, arguments);
      }

      _.extend(Behavior.prototype, Backbone.Events, {
        initialize: function() {},

        // stopListening to behavior `onListen` events.
        destroy: function() {
          this.stopListening();
        },

        // import the `triggerMethod` to trigger events with corresponding
        // methods if the method exists
        triggerMethod: Marionette.triggerMethod,

        // Proxy `getOption` to enable getting options from this or this.options by name.
        getOption: Marionette.proxyGetOption,

        // Proxy `unbindEntityEvents` to enable binding view's events from another entity.
        bindEntityEvents: Marionette.proxyBindEntityEvents,

        // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
        unbindEntityEvents: Marionette.proxyUnbindEntityEvents
      });

      // Borrow Backbones extend implementation
      // this allows us to setup a proper
      // inheritence pattern that follow in suite
      // with the rest of Marionette views.
      Behavior.extend = Marionette.extend;

      return Behavior;
    })(_, Backbone);

    /* jshint maxlen: 143, nonew: false */
    // Marionette.Behaviors
    // --------

    // Behaviors is a utility class that takes care of
    // glueing your behavior instances to their given View.
    // The most important part of this class is that you
    // **MUST** override the class level behaviorsLookup
    // method for things to work properly.

    Marionette.Behaviors = (function(Marionette, _) {

      function Behaviors(view, behaviors) {
        // Behaviors defined on a view can be a flat object literal
        // or it can be a function that returns an object.
        behaviors = Behaviors.parseBehaviors(view, behaviors || _.result(view, 'behaviors'));

        // Wraps several of the view's methods
        // calling the methods first on each behavior
        // and then eventually calling the method on the view.
        Behaviors.wrap(view, behaviors, _.keys(methods));
      }

      var methods = {
        setElement: function(setElement, behaviors) {
          setElement.apply(this, _.tail(arguments, 2));

          // proxy behavior $el to the view's $el.
          // This is needed because a view's $el proxy
          // is not set until after setElement is called.
          _.each(behaviors, function(b) {
            b.$el = this.$el;
            b.el = this.el;
          }, this);

          return this;
        },

        destroy: function(destroy, behaviors) {
          var args = _.tail(arguments, 2);
          destroy.apply(this, args);

          // Call destroy on each behavior after
          // destroying the view.
          // This unbinds event listeners
          // that behaviors have registerd for.
          _.invoke(behaviors, 'destroy', args);
          return this;
        },

        bindUIElements: function(bindUIElements, behaviors) {
          bindUIElements.apply(this);
          _.invoke(behaviors, bindUIElements);
        },

        unbindUIElements: function(unbindUIElements, behaviors) {
          unbindUIElements.apply(this);
          _.invoke(behaviors, unbindUIElements);
        },

        triggerMethod: function(triggerMethod, behaviors) {
          var args = _.tail(arguments, 2);
          triggerMethod.apply(this, args);

          _.each(behaviors, function(b) {
            triggerMethod.apply(b, args);
          });
        },

        delegateEvents: function(delegateEvents, behaviors) {
          var args = _.tail(arguments, 2);
          delegateEvents.apply(this, args);

          _.each(behaviors, function(b) {
            Marionette.bindEntityEvents(b, this.model, Marionette.getOption(b, 'modelEvents'));
            Marionette.bindEntityEvents(b, this.collection, Marionette.getOption(b, 'collectionEvents'));
          }, this);

          return this;
        },

        undelegateEvents: function(undelegateEvents, behaviors) {
          var args = _.tail(arguments, 2);
          undelegateEvents.apply(this, args);

          _.each(behaviors, function(b) {
            Marionette.unbindEntityEvents(b, this.model, Marionette.getOption(b, 'modelEvents'));
            Marionette.unbindEntityEvents(b, this.collection, Marionette.getOption(b, 'collectionEvents'));
          }, this);

          return this;
        },

        behaviorEvents: function(behaviorEvents, behaviors) {
          var _behaviorsEvents = {};
          var viewUI = _.result(this, 'ui');

          _.each(behaviors, function(b, i) {
            var _events = {};
            var behaviorEvents = _.clone(_.result(b, 'events')) || {};
            var behaviorUI = _.result(b, 'ui');

            // Construct an internal UI hash first using
            // the views UI hash and then the behaviors UI hash.
            // This allows the user to use UI hash elements
            // defined in the parent view as well as those
            // defined in the given behavior.
            var ui = _.extend({}, viewUI, behaviorUI);

            // Normalize behavior events hash to allow
            // a user to use the @ui. syntax.
            behaviorEvents = Marionette.normalizeUIKeys(behaviorEvents, ui);

            _.each(_.keys(behaviorEvents), function(key) {
              // Append white-space at the end of each key to prevent behavior key collisions.
              // This is relying on the fact that backbone events considers "click .foo" the same as
              // "click .foo ".

              // +2 is used because new Array(1) or 0 is "" and not " "
              var whitespace = (new Array(i + 2)).join(' ');
              var eventKey   = key + whitespace;
              var handler    = _.isFunction(behaviorEvents[key]) ? behaviorEvents[key] : b[behaviorEvents[key]];

              _events[eventKey] = _.bind(handler, b);
            });

            _behaviorsEvents = _.extend(_behaviorsEvents, _events);
          });

          return _behaviorsEvents;
        }
      };

      _.extend(Behaviors, {

        // Placeholder method to be extended by the user.
        // The method should define the object that stores the behaviors.
        // i.e.
        //
        // ```js
        // Marionette.Behaviors.behaviorsLookup: function() {
        //   return App.Behaviors
        // }
        // ```
        behaviorsLookup: function() {
          throw new Error('You must define where your behaviors are stored.' +
            'See https://github.com/marionettejs/backbone.marionette' +
            '/blob/master/docs/marionette.behaviors.md#behaviorslookup');
        },

        // Takes care of getting the behavior class
        // given options and a key.
        // If a user passes in options.behaviorClass
        // default to using that. Otherwise delegate
        // the lookup to the users `behaviorsLookup` implementation.
        getBehaviorClass: function(options, key) {
          if (options.behaviorClass) {
            return options.behaviorClass;
          }

          // Get behavior class can be either a flat object or a method
          return _.isFunction(Behaviors.behaviorsLookup) ? Behaviors.behaviorsLookup.apply(this, arguments)[key] : Behaviors.behaviorsLookup[key];
        },

        // Iterate over the behaviors object, for each behavior
        // instantiate it and get its grouped behaviors.
        parseBehaviors: function(view, behaviors) {
          return _.chain(behaviors).map(function(options, key) {
            var BehaviorClass = Behaviors.getBehaviorClass(options, key);

            var behavior = new BehaviorClass(options, view);
            var nestedBehaviors = Behaviors.parseBehaviors(view, _.result(behavior, 'behaviors'));

            return [behavior].concat(nestedBehaviors);
          }).flatten().value();
        },

        // Wrap view internal methods so that they delegate to behaviors. For example,
        // `onDestroy` should trigger destroy on all of the behaviors and then destroy itself.
        // i.e.
        //
        // `view.delegateEvents = _.partial(methods.delegateEvents, view.delegateEvents, behaviors);`
        wrap: function(view, behaviors, methodNames) {
          _.each(methodNames, function(methodName) {
            view[methodName] = _.partial(methods[methodName], view[methodName], behaviors);
          });
        }
      });

      return Behaviors;

    })(Marionette, _);


    // AppRouter
    // ---------

    // Reduce the boilerplate code of handling route events
    // and then calling a single method on another object.
    // Have your routers configured to call the method on
    // your object, directly.
    //
    // Configure an AppRouter with `appRoutes`.
    //
    // App routers can only take one `controller` object.
    // It is recommended that you divide your controller
    // objects in to smaller pieces of related functionality
    // and have multiple routers / controllers, instead of
    // just one giant router and controller.
    //
    // You can also add standard routes to an AppRouter.

    Marionette.AppRouter = Backbone.Router.extend({

      constructor: function(options) {
        Backbone.Router.apply(this, arguments);

        this.options = options || {};

        var appRoutes = this.getOption('appRoutes');
        var controller = this._getController();
        this.processAppRoutes(controller, appRoutes);
        this.on('route', this._processOnRoute, this);
      },

      // Similar to route method on a Backbone Router but
      // method is called on the controller
      appRoute: function(route, methodName) {
        var controller = this._getController();
        this._addAppRoute(controller, route, methodName);
      },

      // process the route event and trigger the onRoute
      // method call, if it exists
      _processOnRoute: function(routeName, routeArgs) {
        // find the path that matched
        var routePath = _.invert(this.getOption('appRoutes'))[routeName];

        // make sure an onRoute is there, and call it
        if (_.isFunction(this.onRoute)) {
          this.onRoute(routeName, routePath, routeArgs);
        }
      },

      // Internal method to process the `appRoutes` for the
      // router, and turn them in to routes that trigger the
      // specified method on the specified `controller`.
      processAppRoutes: function(controller, appRoutes) {
        if (!appRoutes) { return; }

        var routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes

        _.each(routeNames, function(route) {
          this._addAppRoute(controller, route, appRoutes[route]);
        }, this);
      },

      _getController: function() {
        return this.getOption('controller');
      },

      _addAppRoute: function(controller, route, methodName) {
        var method = controller[methodName];

        if (!method) {
          throwError('Method "' + methodName + '" was not found on the controller');
        }

        this.route(route, methodName, _.bind(method, controller));
      },

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption
    });

    // Application
    // -----------

    // Contain and manage the composite application as a whole.
    // Stores and starts up `Region` objects, includes an
    // event aggregator as `app.vent`
    Marionette.Application = function(options) {
      this._initializeRegions(options);
      this._initCallbacks = new Marionette.Callbacks();
      this.submodules = {};
      _.extend(this, options);
      this._initChannel();
    };

    _.extend(Marionette.Application.prototype, Backbone.Events, {
      // Command execution, facilitated by Backbone.Wreqr.Commands
      execute: function() {
        this.commands.execute.apply(this.commands, arguments);
      },

      // Request/response, facilitated by Backbone.Wreqr.RequestResponse
      request: function() {
        return this.reqres.request.apply(this.reqres, arguments);
      },

      // Add an initializer that is either run at when the `start`
      // method is called, or run immediately if added after `start`
      // has already been called.
      addInitializer: function(initializer) {
        this._initCallbacks.add(initializer);
      },

      // kick off all of the application's processes.
      // initializes all of the regions that have been added
      // to the app, and runs all of the initializer functions
      start: function(options) {
        this.triggerMethod('before:start', options);
        this._initCallbacks.run(options, this);
        this.triggerMethod('start', options);
      },

      // Add regions to your app.
      // Accepts a hash of named strings or Region objects
      // addRegions({something: "#someRegion"})
      // addRegions({something: Region.extend({el: "#someRegion"}) });
      addRegions: function(regions) {
        return this._regionManager.addRegions(regions);
      },

      // Empty all regions in the app, without removing them
      emptyRegions: function() {
        return this._regionManager.emptyRegions();
      },

      // Removes a region from your app, by name
      // Accepts the regions name
      // removeRegion('myRegion')
      removeRegion: function(region) {
        return this._regionManager.removeRegion(region);
      },

      // Provides alternative access to regions
      // Accepts the region name
      // getRegion('main')
      getRegion: function(region) {
        return this._regionManager.get(region);
      },

      // Get all the regions from the region manager
      getRegions: function(){
        return this._regionManager.getRegions();
      },

      // Create a module, attached to the application
      module: function(moduleNames, moduleDefinition) {

        // Overwrite the module class if the user specifies one
        var ModuleClass = Marionette.Module.getClass(moduleDefinition);

        // slice the args, and add this application object as the
        // first argument of the array
        var args = slice.call(arguments);
        args.unshift(this);

        // see the Marionette.Module object for more information
        return ModuleClass.create.apply(ModuleClass, args);
      },

      // Enable easy overriding of the default `RegionManager`
      // for customized region interactions and business-specific
      // view logic for better control over single regions.
      getRegionManager: function() {
        return new Marionette.RegionManager();
      },

      // Internal method to initialize the regions that have been defined in a
      // `regions` attribute on the application instance
      _initializeRegions: function(options) {
        var regions = _.isFunction(this.regions) ? this.regions(options) : this.regions || {};

        this._initRegionManager();

        // Enable users to define `regions` in instance options.
        var optionRegions = Marionette.getOption(options, 'regions');

        // Enable region options to be a function
        if (_.isFunction(optionRegions)) {
          optionRegions = optionRegions.call(this, options);
        }

        // Overwrite current regions with those passed in options
        _.extend(regions, optionRegions);

        this.addRegions(regions);

        return this;
      },

      // Internal method to set up the region manager
      _initRegionManager: function() {
        this._regionManager = this.getRegionManager();

        this.listenTo(this._regionManager, 'before:add:region', function(name) {
          this.triggerMethod('before:add:region', name);
        });

        this.listenTo(this._regionManager, 'add:region', function(name, region) {
          this[name] = region;
          this.triggerMethod('add:region', name, region);
        });

        this.listenTo(this._regionManager, 'before:remove:region', function(name) {
          this.triggerMethod('before:remove:region', name);
        });

        this.listenTo(this._regionManager, 'remove:region', function(name, region) {
          delete this[name];
          this.triggerMethod('remove:region', name, region);
        });
      },

      // Internal method to setup the Wreqr.radio channel
      _initChannel: function() {
        this.channelName = _.result(this, 'channelName') || 'global';
        this.channel = _.result(this, 'channel') || BackboneWreqr.radio.channel(this.channelName);
        this.vent = _.result(this, 'vent') || this.channel.vent;
        this.commands = _.result(this, 'commands') || this.channel.commands;
        this.reqres = _.result(this, 'reqres') || this.channel.reqres;
      },

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod,

      // Proxy `getOption` to enable getting options from this or this.options by name.
      getOption: Marionette.proxyGetOption
    });

    // Copy the `extend` function used by Backbone's classes
    Marionette.Application.extend = Marionette.extend;

    /* jshint maxparams: 9 */

    // Module
    // ------

    // A simple module system, used to create privacy and encapsulation in
    // Marionette applications
    Marionette.Module = function(moduleName, app, options) {
      this.moduleName = moduleName;
      this.options = _.extend({}, this.options, options);
      // Allow for a user to overide the initialize
      // for a given module instance.
      this.initialize = options.initialize || this.initialize;

      // Set up an internal store for sub-modules.
      this.submodules = {};

      this._setupInitializersAndFinalizers();

      // Set an internal reference to the app
      // within a module.
      this.app = app;

      // By default modules start with their parents.
      this.startWithParent = true;

      if (_.isFunction(this.initialize)) {
        this.initialize(moduleName, app, this.options);
      }
    };

    Marionette.Module.extend = Marionette.extend;

    // Extend the Module prototype with events / listenTo, so that the module
    // can be used as an event aggregator or pub/sub.
    _.extend(Marionette.Module.prototype, Backbone.Events, {

      // Initialize is an empty function by default. Override it with your own
      // initialization logic when extending Marionette.Module.
      initialize: function() {},

      // Initializer for a specific module. Initializers are run when the
      // module's `start` method is called.
      addInitializer: function(callback) {
        this._initializerCallbacks.add(callback);
      },

      // Finalizers are run when a module is stopped. They are used to teardown
      // and finalize any variables, references, events and other code that the
      // module had set up.
      addFinalizer: function(callback) {
        this._finalizerCallbacks.add(callback);
      },

      // Start the module, and run all of its initializers
      start: function(options) {
        // Prevent re-starting a module that is already started
        if (this._isInitialized) { return; }

        // start the sub-modules (depth-first hierarchy)
        _.each(this.submodules, function(mod) {
          // check to see if we should start the sub-module with this parent
          if (mod.startWithParent) {
            mod.start(options);
          }
        });

        // run the callbacks to "start" the current module
        this.triggerMethod('before:start', options);

        this._initializerCallbacks.run(options, this);
        this._isInitialized = true;

        this.triggerMethod('start', options);
      },

      // Stop this module by running its finalizers and then stop all of
      // the sub-modules for this module
      stop: function() {
        // if we are not initialized, don't bother finalizing
        if (!this._isInitialized) { return; }
        this._isInitialized = false;

        this.triggerMethod('before:stop');

        // stop the sub-modules; depth-first, to make sure the
        // sub-modules are stopped / finalized before parents
        _.each(this.submodules, function(mod) { mod.stop(); });

        // run the finalizers
        this._finalizerCallbacks.run(undefined, this);

        // reset the initializers and finalizers
        this._initializerCallbacks.reset();
        this._finalizerCallbacks.reset();

        this.triggerMethod('stop');
      },

      // Configure the module with a definition function and any custom args
      // that are to be passed in to the definition function
      addDefinition: function(moduleDefinition, customArgs) {
        this._runModuleDefinition(moduleDefinition, customArgs);
      },

      // Internal method: run the module definition function with the correct
      // arguments
      _runModuleDefinition: function(definition, customArgs) {
        // If there is no definition short circut the method.
        if (!definition) { return; }

        // build the correct list of arguments for the module definition
        var args = _.flatten([
          this,
          this.app,
          Backbone,
          Marionette,
          Backbone.$, _,
          customArgs
        ]);

        definition.apply(this, args);
      },

      // Internal method: set up new copies of initializers and finalizers.
      // Calling this method will wipe out all existing initializers and
      // finalizers.
      _setupInitializersAndFinalizers: function() {
        this._initializerCallbacks = new Marionette.Callbacks();
        this._finalizerCallbacks = new Marionette.Callbacks();
      },

      // import the `triggerMethod` to trigger events with corresponding
      // methods if the method exists
      triggerMethod: Marionette.triggerMethod
    });

    // Class methods to create modules
    _.extend(Marionette.Module, {

      // Create a module, hanging off the app parameter as the parent object.
      create: function(app, moduleNames, moduleDefinition) {
        var module = app;

        // get the custom args passed in after the module definition and
        // get rid of the module name and definition function
        var customArgs = slice.call(arguments);
        customArgs.splice(0, 3);

        // Split the module names and get the number of submodules.
        // i.e. an example module name of `Doge.Wow.Amaze` would
        // then have the potential for 3 module definitions.
        moduleNames = moduleNames.split('.');
        var length = moduleNames.length;

        // store the module definition for the last module in the chain
        var moduleDefinitions = [];
        moduleDefinitions[length - 1] = moduleDefinition;

        // Loop through all the parts of the module definition
        _.each(moduleNames, function(moduleName, i) {
          var parentModule = module;
          module = this._getModule(parentModule, moduleName, app, moduleDefinition);
          this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs);
        }, this);

        // Return the last module in the definition chain
        return module;
      },

      _getModule: function(parentModule, moduleName, app, def, args) {
        var options = _.extend({}, def);
        var ModuleClass = this.getClass(def);

        // Get an existing module of this name if we have one
        var module = parentModule[moduleName];

        if (!module) {
          // Create a new module if we don't have one
          module = new ModuleClass(moduleName, app, options);
          parentModule[moduleName] = module;
          // store the module on the parent
          parentModule.submodules[moduleName] = module;
        }

        return module;
      },

      // ## Module Classes
      //
      // Module classes can be used as an alternative to the define pattern.
      // The extend function of a Module is identical to the extend functions
      // on other Backbone and Marionette classes.
      // This allows module lifecyle events like `onStart` and `onStop` to be called directly.
      getClass: function(moduleDefinition) {
        var ModuleClass = Marionette.Module;

        if (!moduleDefinition) {
          return ModuleClass;
        }

        // If all of the module's functionality is defined inside its class,
        // then the class can be passed in directly. `MyApp.module("Foo", FooModule)`.
        if (moduleDefinition.prototype instanceof ModuleClass) {
          return moduleDefinition;
        }

        return moduleDefinition.moduleClass || ModuleClass;
      },

      // Add the module definition and add a startWithParent initializer function.
      // This is complicated because module definitions are heavily overloaded
      // and support an anonymous function, module class, or options object
      _addModuleDefinition: function(parentModule, module, def, args) {
        var fn = this._getDefine(def);
        var startWithParent = this._getStartWithParent(def, module);

        if (fn) {
          module.addDefinition(fn, args);
        }

        this._addStartWithParent(parentModule, module, startWithParent);
      },

      _getStartWithParent: function(def, module) {
        var swp;

        if (_.isFunction(def) && (def.prototype instanceof Marionette.Module)) {
          swp = module.constructor.prototype.startWithParent;
          return _.isUndefined(swp) ? true : swp;
        }

        if (_.isObject(def)) {
          swp = def.startWithParent;
          return _.isUndefined(swp) ? true : swp;
        }

        return true;
      },

      _getDefine: function(def) {
        if (_.isFunction(def) && !(def.prototype instanceof Marionette.Module)) {
          return def;
        }

        if (_.isObject(def)) {
          return def.define;
        }

        return null;
      },

      _addStartWithParent: function(parentModule, module, startWithParent) {
        module.startWithParent = module.startWithParent && startWithParent;

        if (!module.startWithParent || !!module.startWithParentIsConfigured) {
          return;
        }

        module.startWithParentIsConfigured = true;

        parentModule.addInitializer(function(options) {
          if (module.startWithParent) {
            module.start(options);
          }
        });
      }
    });


    return Marionette;
  }));

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:marionette', location = 'lib/backbone/marionette/backbone.marionette-amd.js' */
define('jira/view-issue-plugin/lib/marionette', [
    'backbone',
    'underscore',
    'atlassian/libs/factories/marionette-2.1.0'
], function defineMarionette(Backbone, _, MarionetteFactory) {
    return MarionetteFactory(_, Backbone);
});
;
;
/* module-key = 'jira.webresources:jquery-easing', location = '/includes/jquery/plugins/easing/jquery.easing.1.3.js' */
/*
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Uses the built in easing capabilities added In jQuery 1.1
 * to offer multiple easing options
 *
 * TERMS OF USE - jQuery Easing
 * 
 * Open source under the BSD License. 
 * 
 * Copyright © 2008 George McGinley Smith
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this list of 
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list 
 * of conditions and the following disclaimer in the documentation and/or other materials 
 * provided with the distribution.
 * 
 * Neither the name of the author nor the names of contributors may be used to endorse 
 * or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 *
*/

// t: current time, b: begInnIng value, c: change In value, d: duration
jQuery.easing['jswing'] = jQuery.easing['swing'];

jQuery.extend( jQuery.easing,
{
	def: 'easeOutQuad',
	swing: function (x, t, b, c, d) {
		//alert(jQuery.easing.default);
		return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158; 
		if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t < d/2) return jQuery.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return jQuery.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 * 
 * Open source under the BSD License. 
 * 
 * Copyright © 2001 Robert Penner
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this list of 
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list 
 * of conditions and the following disclaimer in the documentation and/or other materials 
 * provided with the distribution.
 * 
 * Neither the name of the author nor the names of contributors may be used to endorse 
 * or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 *
 */;
;
/* module-key = 'jira.webresources:jquery-fancybox', location = '/includes/jquery/plugins/fancybox/jquery.fancybox-1.3.4.js' */
/*
 * FancyBox - jQuery Plugin
 * Simple and fancy lightbox alternative
 *
 * Examples and documentation at: http://fancybox.net
 *
 * Copyright (c) 2008 - 2010 Janis Skarnelis
 * That said, it is hardly a one-person project. Many people have submitted bugs, code, and offered their advice freely. Their support is greatly appreciated.
 *
 * Version: 1.3.4 (11/11/2010)
 * Requires: jQuery v1.3+
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */

;(function($) {
	var tmp, loading, overlay, wrap, outer, content, close, title, nav_left, nav_right,

		selectedIndex = 0, selectedOpts = {}, selectedArray = [], currentIndex = 0, currentOpts = {}, currentArray = [],

		ajaxLoader = null, imgPreloader = new Image(), imgRegExp = /\.(jpg|gif|png|bmp|jpeg)(.*)?$/i, swfRegExp = /[^\.]\.(swf)\s*$/i,

		loadingTimer, loadingFrame = 1,

		titleHeight = 0, titleStr = '', start_pos, final_pos, busy = false, fx = $.extend($('<div/>')[0], { prop: 0 }),

		isIE6 = $.browser.msie && $.browser.version < 7 && !window.XMLHttpRequest,

		/*
		 * Private methods 
		 */

		_abort = function() {
			loading.hide();

			imgPreloader.onerror = imgPreloader.onload = null;

			if (ajaxLoader) {
				ajaxLoader.abort();
			}

			tmp.empty();
		},

		_error = function() {
			if (false === selectedOpts.onError(selectedArray, selectedIndex, selectedOpts)) {
				loading.hide();
				busy = false;
				return;
			}

			selectedOpts.titleShow = false;

			selectedOpts.width = 'auto';
			selectedOpts.height = 'auto';

			tmp.html( '<p id="fancybox-error">The requested content cannot be loaded.<br />Please try again later.</p>' );

			_process_inline();
		},

		_start = function() {
			var obj = selectedArray[ selectedIndex ],
				href, 
				type, 
				title,
				str,
				emb,
				ret;

			_abort();

			selectedOpts = $.extend({}, $.fn.fancybox.defaults, (typeof $(obj).data('fancybox') == 'undefined' ? selectedOpts : $(obj).data('fancybox')));

			ret = selectedOpts.onStart(selectedArray, selectedIndex, selectedOpts);

			if (ret === false) {
				busy = false;
				return;
			} else if (typeof ret == 'object') {
				selectedOpts = $.extend(selectedOpts, ret);
			}

			title = selectedOpts.title || (obj.nodeName ? $(obj).attr('title') : obj.title) || '';

			if (obj.nodeName && !selectedOpts.orig) {
				selectedOpts.orig = $(obj).children("img:first").length ? $(obj).children("img:first") : $(obj);
			}

			if (title === '' && selectedOpts.orig && selectedOpts.titleFromAlt) {
				title = selectedOpts.orig.attr('alt');
			}

			href = selectedOpts.href || (obj.nodeName ? $(obj).attr('href') : obj.href) || null;

			if ((/^(?:javascript)/i).test(href) || href == '#') {
				href = null;
			}

			if (selectedOpts.type) {
				type = selectedOpts.type;

				if (!href) {
					href = selectedOpts.content;
				}

			} else if (selectedOpts.content) {
				type = 'html';

			} else if (href) {
				if (href.match(imgRegExp)) {
					type = 'image';

				} else if (href.match(swfRegExp)) {
					type = 'swf';

				} else if ($(obj).hasClass("iframe")) {
					type = 'iframe';

				} else if (href.indexOf("#") === 0) {
					type = 'inline';

				} else {
					type = 'ajax';
				}
			}

			if (!type) {
				_error();
				return;
			}

			if (type == 'inline') {
				obj	= href.substr(href.indexOf("#"));
				type = $(obj).length > 0 ? 'inline' : 'ajax';
			}

			selectedOpts.type = type;
			selectedOpts.href = href;
			selectedOpts.title = title;

			if (selectedOpts.autoDimensions) {
				if (selectedOpts.type == 'html' || selectedOpts.type == 'inline' || selectedOpts.type == 'ajax') {
					selectedOpts.width = 'auto';
					selectedOpts.height = 'auto';
				} else {
					selectedOpts.autoDimensions = false;	
				}
			}

			if (selectedOpts.modal) {
				selectedOpts.overlayShow = true;
				selectedOpts.hideOnOverlayClick = false;
				selectedOpts.hideOnContentClick = false;
				selectedOpts.enableEscapeButton = false;
				selectedOpts.showCloseButton = false;
			}

			selectedOpts.padding = parseInt(selectedOpts.padding, 10);
			selectedOpts.margin = parseInt(selectedOpts.margin, 10);

			tmp.css('padding', (selectedOpts.padding + selectedOpts.margin));

			$('.fancybox-inline-tmp').unbind('fancybox-cancel').bind('fancybox-change', function() {
				$(this).replaceWith(content.children());				
			});

			switch (type) {
				case 'html' :
					tmp.html( selectedOpts.content );
					_process_inline();
				break;

				case 'inline' :
					if ( $(obj).parent().is('#fancybox-content') === true) {
						busy = false;
						return;
					}

					$('<div class="fancybox-inline-tmp" />')
						.hide()
						.insertBefore( $(obj) )
						.bind('fancybox-cleanup', function() {
							$(this).replaceWith(content.children());
						}).bind('fancybox-cancel', function() {
							$(this).replaceWith(tmp.children());
						});

					$(obj).appendTo(tmp);

					_process_inline();
				break;

				case 'image':
					busy = false;

					$.fancybox.showActivity();

					imgPreloader = new Image();

					imgPreloader.onerror = function() {
						_error();
					};

					imgPreloader.onload = function() {
						busy = true;

						imgPreloader.onerror = imgPreloader.onload = null;

						_process_image();
					};

					imgPreloader.src = href;
				break;

				case 'swf':
					selectedOpts.scrolling = 'no';

					str = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="' + selectedOpts.width + '" height="' + selectedOpts.height + '"><param name="movie" value="' + href + '"></param>';
					emb = '';

					$.each(selectedOpts.swf, function(name, val) {
						str += '<param name="' + name + '" value="' + val + '"></param>';
						emb += ' ' + name + '="' + val + '"';
					});

					str += '<embed src="' + href + '" type="application/x-shockwave-flash" width="' + selectedOpts.width + '" height="' + selectedOpts.height + '"' + emb + '></embed></object>';

					tmp.html(str);

					_process_inline();
				break;

				case 'ajax':
					busy = false;

					$.fancybox.showActivity();

					selectedOpts.ajax.win = selectedOpts.ajax.success;

					ajaxLoader = $.ajax($.extend({}, selectedOpts.ajax, {
						url	: href,
						data : selectedOpts.ajax.data || {},
						error : function(XMLHttpRequest, textStatus, errorThrown) {
							if ( XMLHttpRequest.status > 0 ) {
								_error();
							}
						},
						success : function(data, textStatus, XMLHttpRequest) {
							var o = typeof XMLHttpRequest == 'object' ? XMLHttpRequest : ajaxLoader;
							if (o.status == 200) {
								if ( typeof selectedOpts.ajax.win == 'function' ) {
									ret = selectedOpts.ajax.win(href, data, textStatus, XMLHttpRequest);

									if (ret === false) {
										loading.hide();
										return;
									} else if (typeof ret == 'string' || typeof ret == 'object') {
										data = ret;
									}
								}

								tmp.html( data );
								_process_inline();
							}
						}
					}));

				break;

				case 'iframe':
					_show();
				break;
			}
		},

		_process_inline = function() {
			var
				w = selectedOpts.width,
				h = selectedOpts.height;

			if (w.toString().indexOf('%') > -1) {
				w = parseInt( ($(window).width() - (selectedOpts.margin * 2)) * parseFloat(w) / 100, 10) + 'px';

			} else {
				w = w == 'auto' ? 'auto' : w + 'px';	
			}

			if (h.toString().indexOf('%') > -1) {
				h = parseInt( ($(window).height() - (selectedOpts.margin * 2)) * parseFloat(h) / 100, 10) + 'px';

			} else {
				h = h == 'auto' ? 'auto' : h + 'px';	
			}

			tmp.wrapInner('<div style="width:' + w + ';height:' + h + ';overflow: ' + (selectedOpts.scrolling == 'auto' ? 'auto' : (selectedOpts.scrolling == 'yes' ? 'scroll' : 'hidden')) + ';position:relative;"></div>');

			selectedOpts.width = tmp.width();
			selectedOpts.height = tmp.height();

			_show();
		},

		_process_image = function() {
			selectedOpts.width = imgPreloader.width;
			selectedOpts.height = imgPreloader.height;

			$("<img />").attr({
				'id' : 'fancybox-img',
				'src' : imgPreloader.src,
				'alt' : selectedOpts.title
			}).appendTo( tmp );

			_show();
		},

		_show = function() {
			var pos, equal;

			loading.hide();

			if (wrap.is(":visible") && false === currentOpts.onCleanup(currentArray, currentIndex, currentOpts)) {
				$.event.trigger('fancybox-cancel');

				busy = false;
				return;
			}

			busy = true;

			$(content.add( overlay )).unbind();

			$(window).unbind("resize.fb scroll.fb");
			$(document).unbind('keydown.fb');

			if (wrap.is(":visible") && currentOpts.titlePosition !== 'outside') {
				wrap.css('height', wrap.height());
			}

			currentArray = selectedArray;
			currentIndex = selectedIndex;
			currentOpts = selectedOpts;

			if (currentOpts.overlayShow) {
				overlay.css({
					'background-color' : currentOpts.overlayColor,
					'opacity' : currentOpts.overlayOpacity,
					'cursor' : currentOpts.hideOnOverlayClick ? 'pointer' : 'auto',
					'height' : $(document).height()
				});

				if (!overlay.is(':visible')) {
					if (isIE6) {
						$('select:not(#fancybox-tmp select)').filter(function() {
							return this.style.visibility !== 'hidden';
						}).css({'visibility' : 'hidden'}).one('fancybox-cleanup', function() {
							this.style.visibility = 'inherit';
						});
					}

					overlay.show();
				}
			} else {
				overlay.hide();
			}

			final_pos = _get_zoom_to();

			_process_title();

			if (wrap.is(":visible")) {
				$( close.add( nav_left ).add( nav_right ) ).hide();

				pos = wrap.position(),

				start_pos = {
					top	 : pos.top,
					left : pos.left,
					width : wrap.width(),
					height : wrap.height()
				};

				equal = (start_pos.width == final_pos.width && start_pos.height == final_pos.height);

				content.fadeTo(currentOpts.changeFade, 0.3, function() {
					var finish_resizing = function() {
						content.html( tmp.contents() ).fadeTo(currentOpts.changeFade, 1, _finish);
					};

					$.event.trigger('fancybox-change');

					content
						.empty()
						.removeAttr('filter')
						.css({
							'border-width' : currentOpts.padding,
							'width'	: final_pos.width - currentOpts.padding * 2,
							'height' : selectedOpts.autoDimensions ? 'auto' : final_pos.height - titleHeight - currentOpts.padding * 2
						});

					if (equal) {
						finish_resizing();

					} else {
						fx.prop = 0;

						$(fx).animate({prop: 1}, {
							 duration : currentOpts.changeSpeed,
							 easing : currentOpts.easingChange,
							 step : _draw,
							 complete : finish_resizing
						});
					}
				});

				return;
			}

			wrap.removeAttr("style");

			content.css('border-width', currentOpts.padding);

			if (currentOpts.transitionIn == 'elastic') {
				start_pos = _get_zoom_from();

				content.html( tmp.contents() );

				wrap.show();

				if (currentOpts.opacity) {
					final_pos.opacity = 0;
				}

				fx.prop = 0;

				$(fx).animate({prop: 1}, {
					 duration : currentOpts.speedIn,
					 easing : currentOpts.easingIn,
					 step : _draw,
					 complete : _finish
				});

				return;
			}

			if (currentOpts.titlePosition == 'inside' && titleHeight > 0) {	
				title.show();	
			}

			content
				.css({
					'width' : final_pos.width - currentOpts.padding * 2,
					'height' : selectedOpts.autoDimensions ? 'auto' : final_pos.height - titleHeight - currentOpts.padding * 2
				})
				.html( tmp.contents() );

			wrap
				.css(final_pos)
				.fadeIn( currentOpts.transitionIn == 'none' ? 0 : currentOpts.speedIn, _finish );
		},

		_format_title = function(title) {
			if (title && title.length) {
				if (currentOpts.titlePosition == 'float') {
					return '<table id="fancybox-title-float-wrap" cellpadding="0" cellspacing="0"><tr><td id="fancybox-title-float-left"></td><td id="fancybox-title-float-main">' + title + '</td><td id="fancybox-title-float-right"></td></tr></table>';
				}

				return '<div id="fancybox-title-' + currentOpts.titlePosition + '">' + title + '</div>';
			}

			return false;
		},

		_process_title = function() {
			titleStr = currentOpts.title || '';
			titleHeight = 0;

			title
				.empty()
				.removeAttr('style')
				.removeClass();

			if (currentOpts.titleShow === false) {
				title.hide();
				return;
			}

			titleStr = $.isFunction(currentOpts.titleFormat) ? currentOpts.titleFormat(titleStr, currentArray, currentIndex, currentOpts) : _format_title(titleStr);

			if (!titleStr || titleStr === '') {
				title.hide();
				return;
			}

			title
				.addClass('fancybox-title-' + currentOpts.titlePosition)
				.html( titleStr )
				.appendTo( 'body' )
				.show();

			switch (currentOpts.titlePosition) {
				case 'inside':
					title
						.css({
							'width' : final_pos.width - (currentOpts.padding * 2),
							'marginLeft' : currentOpts.padding,
							'marginRight' : currentOpts.padding
						});

					titleHeight = title.outerHeight(true);

					title.appendTo( outer );

					final_pos.height += titleHeight;
				break;

				case 'over':
					title
						.css({
							'marginLeft' : currentOpts.padding,
							'width'	: final_pos.width - (currentOpts.padding * 2),
							'bottom' : currentOpts.padding
						})
						.appendTo( outer );
				break;

				case 'float':
					title
						.css('left', parseInt((title.width() - final_pos.width - 40)/ 2, 10) * -1)
						.appendTo( wrap );
				break;

				default:
					title
						.css({
							'width' : final_pos.width - (currentOpts.padding * 2),
							'paddingLeft' : currentOpts.padding,
							'paddingRight' : currentOpts.padding
						})
						.appendTo( wrap );
				break;
			}

			title.hide();
		},

		_set_navigation = function() {
			if (currentOpts.enableEscapeButton || currentOpts.enableKeyboardNav) {
				$(document).bind('keydown.fb', function(e) {
					if (e.keyCode == 27 && currentOpts.enableEscapeButton) {
						e.preventDefault();
						$.fancybox.close();

					} else if ((e.keyCode == 37 || e.keyCode == 39) && currentOpts.enableKeyboardNav && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'SELECT') {
						e.preventDefault();
						$.fancybox[ e.keyCode == 37 ? 'prev' : 'next']();
					}
				});
			}

			if (!currentOpts.showNavArrows) { 
				nav_left.hide();
				nav_right.hide();
				return;
			}

			if ((currentOpts.cyclic && currentArray.length > 1) || currentIndex !== 0) {
				nav_left.show();
			}

			if ((currentOpts.cyclic && currentArray.length > 1) || currentIndex != (currentArray.length -1)) {
				nav_right.show();
			}
		},

		_finish = function () {
			if (!$.support.opacity) {
				content.get(0).style.removeAttribute('filter');
				wrap.get(0).style.removeAttribute('filter');
			}

			if (selectedOpts.autoDimensions) {
				content.css('height', 'auto');
			}

			wrap.css('height', 'auto');

			if (titleStr && titleStr.length) {
				title.show();
			}

			if (currentOpts.showCloseButton) {
				close.show();
			}

			_set_navigation();
	
			if (currentOpts.hideOnContentClick)	{
				content.bind('click', $.fancybox.close);
			}

			if (currentOpts.hideOnOverlayClick)	{
				overlay.bind('click', $.fancybox.close);
			}

			$(window).bind("resize.fb", $.fancybox.resize);

			if (currentOpts.centerOnScroll) {
				$(window).bind("scroll.fb", $.fancybox.center);
			}

			if (currentOpts.type == 'iframe') {
				$('<iframe id="fancybox-frame" name="fancybox-frame' + new Date().getTime() + '" frameborder="0" hspace="0" ' + ($.browser.msie ? 'allowtransparency="true""' : '') + ' scrolling="' + selectedOpts.scrolling + '" src="' + currentOpts.href + '"></iframe>').appendTo(content);
			}

			wrap.show();

			busy = false;

			$.fancybox.center();

			currentOpts.onComplete(currentArray, currentIndex, currentOpts);

			_preload_images();
		},

		_preload_images = function() {
			var href, 
				objNext;

			if ((currentArray.length -1) > currentIndex) {
				href = currentArray[ currentIndex + 1 ].href;

				if (typeof href !== 'undefined' && href.match(imgRegExp)) {
					objNext = new Image();
					objNext.src = href;
				}
			}

			if (currentIndex > 0) {
				href = currentArray[ currentIndex - 1 ].href;

				if (typeof href !== 'undefined' && href.match(imgRegExp)) {
					objNext = new Image();
					objNext.src = href;
				}
			}
		},

		_draw = function(pos) {
			var dim = {
				width : parseInt(start_pos.width + (final_pos.width - start_pos.width) * pos, 10),
				height : parseInt(start_pos.height + (final_pos.height - start_pos.height) * pos, 10),

				top : parseInt(start_pos.top + (final_pos.top - start_pos.top) * pos, 10),
				left : parseInt(start_pos.left + (final_pos.left - start_pos.left) * pos, 10)
			};

			if (typeof final_pos.opacity !== 'undefined') {
				dim.opacity = pos < 0.5 ? 0.5 : pos;
			}

			wrap.css(dim);

			content.css({
				'width' : dim.width - currentOpts.padding * 2,
				'height' : dim.height - (titleHeight * pos) - currentOpts.padding * 2
			});
		},

		_get_viewport = function() {
			return [
				$(window).width() - (currentOpts.margin * 2),
				$(window).height() - (currentOpts.margin * 2),
				$(document).scrollLeft() + currentOpts.margin,
				$(document).scrollTop() + currentOpts.margin
			];
		},

		_get_zoom_to = function () {
			var view = _get_viewport(),
				to = {},
				resize = currentOpts.autoScale,
				double_padding = currentOpts.padding * 2,
				ratio;

			if (currentOpts.width.toString().indexOf('%') > -1) {
				to.width = parseInt((view[0] * parseFloat(currentOpts.width)) / 100, 10);
			} else {
				to.width = currentOpts.width + double_padding;
			}

			if (currentOpts.height.toString().indexOf('%') > -1) {
				to.height = parseInt((view[1] * parseFloat(currentOpts.height)) / 100, 10);
			} else {
				to.height = currentOpts.height + double_padding;
			}

			if (resize && (to.width > view[0] || to.height > view[1])) {
				if (selectedOpts.type == 'image' || selectedOpts.type == 'swf') {
					ratio = (currentOpts.width ) / (currentOpts.height );

					if ((to.width ) > view[0]) {
						to.width = view[0];
						to.height = parseInt(((to.width - double_padding) / ratio) + double_padding, 10);
					}

					if ((to.height) > view[1]) {
						to.height = view[1];
						to.width = parseInt(((to.height - double_padding) * ratio) + double_padding, 10);
					}

				} else {
					to.width = Math.min(to.width, view[0]);
					to.height = Math.min(to.height, view[1]);
				}
			}

			to.top = parseInt(Math.max(view[3] - 20, view[3] + ((view[1] - to.height - 40) * 0.5)), 10);
			to.left = parseInt(Math.max(view[2] - 20, view[2] + ((view[0] - to.width - 40) * 0.5)), 10);

			return to;
		},

		_get_obj_pos = function(obj) {
			var pos = obj.offset();

			pos.top += parseInt( obj.css('paddingTop'), 10 ) || 0;
			pos.left += parseInt( obj.css('paddingLeft'), 10 ) || 0;

			pos.top += parseInt( obj.css('border-top-width'), 10 ) || 0;
			pos.left += parseInt( obj.css('border-left-width'), 10 ) || 0;

			pos.width = obj.width();
			pos.height = obj.height();

			return pos;
		},

		_get_zoom_from = function() {
			var orig = selectedOpts.orig ? $(selectedOpts.orig) : false,
				from = {},
				pos,
				view;

			if (orig && orig.length) {
				pos = _get_obj_pos(orig);

				from = {
					width : pos.width + (currentOpts.padding * 2),
					height : pos.height + (currentOpts.padding * 2),
					top	: pos.top - currentOpts.padding - 20,
					left : pos.left - currentOpts.padding - 20
				};

			} else {
				view = _get_viewport();

				from = {
					width : currentOpts.padding * 2,
					height : currentOpts.padding * 2,
					top	: parseInt(view[3] + view[1] * 0.5, 10),
					left : parseInt(view[2] + view[0] * 0.5, 10)
				};
			}

			return from;
		},

		_animate_loading = function() {
			if (!loading.is(':visible')){
				clearInterval(loadingTimer);
				return;
			}

			$('div', loading).css('top', (loadingFrame * -40) + 'px');

			loadingFrame = (loadingFrame + 1) % 12;
		};

	/*
	 * Public methods 
	 */

	$.fn.fancybox = function(options) {
		if (!$(this).length) {
			return this;
		}

		$(this)
			.data('fancybox', $.extend({}, options, ($.metadata ? $(this).metadata() : {})))
			.unbind('click.fb')
			.bind('click.fb', function(e) {
				e.preventDefault();

				if (busy) {
					return;
				}

				busy = true;

				$(this).blur();

				selectedArray = [];
				selectedIndex = 0;

				var rel = $(this).attr('rel') || '';

				if (!rel || rel == '' || rel === 'nofollow') {
					selectedArray.push(this);

				} else {
					selectedArray = $("a[rel=" + rel + "], area[rel=" + rel + "]");
					selectedIndex = selectedArray.index( this );
				}

				_start();

				return;
			});

		return this;
	};

	$.fancybox = function(obj) {
		var opts;

		if (busy) {
			return;
		}

		busy = true;
		opts = typeof arguments[1] !== 'undefined' ? arguments[1] : {};

		selectedArray = [];
		selectedIndex = parseInt(opts.index, 10) || 0;

		if ($.isArray(obj)) {
			for (var i = 0, j = obj.length; i < j; i++) {
				if (typeof obj[i] == 'object') {
					$(obj[i]).data('fancybox', $.extend({}, opts, obj[i]));
				} else {
					obj[i] = $({}).data('fancybox', $.extend({content : obj[i]}, opts));
				}
			}

			selectedArray = jQuery.merge(selectedArray, obj);

		} else {
			if (typeof obj == 'object') {
				$(obj).data('fancybox', $.extend({}, opts, obj));
			} else {
				obj = $({}).data('fancybox', $.extend({content : obj}, opts));
			}

			selectedArray.push(obj);
		}

		if (selectedIndex > selectedArray.length || selectedIndex < 0) {
			selectedIndex = 0;
		}

		_start();
	};

	$.fancybox.showActivity = function() {
		clearInterval(loadingTimer);

		loading.show();
		loadingTimer = setInterval(_animate_loading, 66);
	};

	$.fancybox.hideActivity = function() {
		loading.hide();
	};

	$.fancybox.next = function() {
		return $.fancybox.pos( currentIndex + 1);
	};

	$.fancybox.prev = function() {
		return $.fancybox.pos( currentIndex - 1);
	};

	$.fancybox.pos = function(pos) {
		if (busy) {
			return;
		}

		pos = parseInt(pos);

		selectedArray = currentArray;

		if (pos > -1 && pos < currentArray.length) {
			selectedIndex = pos;
			_start();

		} else if (currentOpts.cyclic && currentArray.length > 1) {
			selectedIndex = pos >= currentArray.length ? 0 : currentArray.length - 1;
			_start();
		}

		return;
	};

	$.fancybox.cancel = function() {
		if (busy) {
			return;
		}

		busy = true;

		$.event.trigger('fancybox-cancel');

		_abort();

		selectedOpts.onCancel(selectedArray, selectedIndex, selectedOpts);

		busy = false;
	};

	// Note: within an iframe use - parent.$.fancybox.close();
	$.fancybox.close = function() {
		if (busy || wrap.is(':hidden')) {
			return;
		}

		busy = true;

		if (currentOpts && false === currentOpts.onCleanup(currentArray, currentIndex, currentOpts)) {
			busy = false;
			return;
		}

		_abort();

		$(close.add( nav_left ).add( nav_right )).hide();

		$(content.add( overlay )).unbind();

		$(window).unbind("resize.fb scroll.fb");
		$(document).unbind('keydown.fb');

		content.find('iframe').attr('src', isIE6 && /^https/i.test(window.location.href || '') ? 'javascript:void(false)' : 'about:blank');

		if (currentOpts.titlePosition !== 'inside') {
			title.empty();
		}

		wrap.stop();

		function _cleanup() {
			overlay.fadeOut('fast');

			title.empty().hide();
			wrap.hide();

			$.event.trigger('fancybox-cleanup');

			content.empty();

			currentOpts.onClosed(currentArray, currentIndex, currentOpts);

			currentArray = selectedOpts	= [];
			currentIndex = selectedIndex = 0;
			currentOpts = selectedOpts	= {};

			busy = false;
		}

		if (currentOpts.transitionOut == 'elastic') {
			start_pos = _get_zoom_from();

			var pos = wrap.position();

			final_pos = {
				top	 : pos.top ,
				left : pos.left,
				width :	wrap.width(),
				height : wrap.height()
			};

			if (currentOpts.opacity) {
				final_pos.opacity = 1;
			}

			title.empty().hide();

			fx.prop = 1;

			$(fx).animate({ prop: 0 }, {
				 duration : currentOpts.speedOut,
				 easing : currentOpts.easingOut,
				 step : _draw,
				 complete : _cleanup
			});

		} else {
			wrap.fadeOut( currentOpts.transitionOut == 'none' ? 0 : currentOpts.speedOut, _cleanup);
		}
	};

	$.fancybox.resize = function() {
		if (overlay.is(':visible')) {
			overlay.css('height', $(document).height());
		}

		$.fancybox.center(true);
	};

	$.fancybox.center = function() {
		var view, align;

		if (busy) {
			return;	
		}

		align = arguments[0] === true ? 1 : 0;
		view = _get_viewport();

		if (!align && (wrap.width() > view[0] || wrap.height() > view[1])) {
			return;	
		}

		wrap
			.stop()
			.animate({
				'top' : parseInt(Math.max(view[3] - 20, view[3] + ((view[1] - content.height() - 40) * 0.5) - currentOpts.padding)),
				'left' : parseInt(Math.max(view[2] - 20, view[2] + ((view[0] - content.width() - 40) * 0.5) - currentOpts.padding))
			}, typeof arguments[0] == 'number' ? arguments[0] : 200);
	};

	$.fancybox.init = function() {
		if ($("#fancybox-wrap").length) {
			return;
		}

		$('body').append(
			tmp	= $('<div id="fancybox-tmp"></div>'),
			loading	= $('<div id="fancybox-loading"><div></div></div>'),
			overlay	= $('<div id="fancybox-overlay"></div>'),
			wrap = $('<div id="fancybox-wrap"></div>')
		);

		outer = $('<div id="fancybox-outer"></div>')
			.append('<div class="fancybox-bg" id="fancybox-bg-n"></div><div class="fancybox-bg" id="fancybox-bg-ne"></div><div class="fancybox-bg" id="fancybox-bg-e"></div><div class="fancybox-bg" id="fancybox-bg-se"></div><div class="fancybox-bg" id="fancybox-bg-s"></div><div class="fancybox-bg" id="fancybox-bg-sw"></div><div class="fancybox-bg" id="fancybox-bg-w"></div><div class="fancybox-bg" id="fancybox-bg-nw"></div>')
			.appendTo( wrap );

		outer.append(
			content = $('<div id="fancybox-content"></div>'),
			close = $('<a id="fancybox-close"></a>'),
			title = $('<div id="fancybox-title"></div>'),

			nav_left = $('<a href="javascript:;" id="fancybox-left"><span class="fancy-ico" id="fancybox-left-ico"></span></a>'),
			nav_right = $('<a href="javascript:;" id="fancybox-right"><span class="fancy-ico" id="fancybox-right-ico"></span></a>')
		);

		close.click($.fancybox.close);
		loading.click($.fancybox.cancel);

		nav_left.click(function(e) {
			e.preventDefault();
			$.fancybox.prev();
		});

		nav_right.click(function(e) {
			e.preventDefault();
			$.fancybox.next();
		});

		if ($.fn.mousewheel) {
			wrap.bind('mousewheel.fb', function(e, delta) {
				if (busy) {
					e.preventDefault();

				} else if ($(e.target).get(0).clientHeight == 0 || $(e.target).get(0).scrollHeight === $(e.target).get(0).clientHeight) {
					e.preventDefault();
					$.fancybox[ delta > 0 ? 'prev' : 'next']();
				}
			});
		}

		if (!$.support.opacity) {
			wrap.addClass('fancybox-ie');
		}

		if (isIE6) {
			loading.addClass('fancybox-ie6');
			wrap.addClass('fancybox-ie6');

			$('<iframe id="fancybox-hide-sel-frame" src="' + (/^https/i.test(window.location.href || '') ? 'javascript:void(false)' : 'about:blank' ) + '" scrolling="no" border="0" frameborder="0" tabindex="-1"></iframe>').prependTo(outer);
		}
	};

	$.fn.fancybox.defaults = {
		padding : 10,
		margin : 40,
		opacity : false,
		modal : false,
		cyclic : false,
		scrolling : 'auto',	// 'auto', 'yes' or 'no'

		width : 560,
		height : 340,

		autoScale : true,
		autoDimensions : true,
		centerOnScroll : false,

		ajax : {},
		swf : { wmode: 'transparent' },

		hideOnOverlayClick : true,
		hideOnContentClick : false,

		overlayShow : true,
		overlayOpacity : 0.7,
		overlayColor : '#777',

		titleShow : true,
		titlePosition : 'float', // 'float', 'outside', 'inside' or 'over'
		titleFormat : null,
		titleFromAlt : false,

		transitionIn : 'fade', // 'elastic', 'fade' or 'none'
		transitionOut : 'fade', // 'elastic', 'fade' or 'none'

		speedIn : 300,
		speedOut : 300,

		changeSpeed : 300,
		changeFade : 'fast',

		easingIn : 'swing',
		easingOut : 'swing',

		showCloseButton	 : true,
		showNavArrows : true,
		enableEscapeButton : true,
		enableKeyboardNav : true,

		onStart : function(){},
		onCancel : function(){},
		onComplete : function(){},
		onCleanup : function(){},
		onClosed : function(){},
		onError : function(){}
	};

	$(document).ready(function() {
		$.fancybox.init();
	});

})(jQuery);
;
;
/* module-key = 'jira.webresources:jquery-fancybox', location = '/includes/jquery/plugins/fancybox/jquery.fancybox.jira.js' */
AJS.$.fn.fancybox.defaults.titleFormat = function(title) {
    if (title && title.length) {
        title = AJS.escapeHtml(title);
        if (this.titlePosition == 'float') {
            return '<table id="fancybox-title-float-wrap" cellpadding="0" cellspacing="0"><tr><td id="fancybox-title-float-left"></td><td id="fancybox-title-float-main">' + title + '</td><td id="fancybox-title-float-right"></td></tr></table>';
        }
        return '<div id="fancybox-title-' + this.titlePosition + '">' + title + '</div>';
    }
};
;
;
/* module-key = 'jira.webresources:jquery-livestamp', location = '/includes/jquery/plugins/livestamp/time.js' */
/**
 * @note Mostly copied from Stash by skalsi on 10/01/14.
 * @module jira/jquery/plugins/livestamp/time
 */
define('jira/jquery/plugins/livestamp/time', [
    'jquery',
    'jira/moment',
    'jira/util/data/meta'
], function ($, moment, Meta) {

    'use strict';

    /** @exports jira/jquery/plugins/livestamp/time */
    var Time = {};

    function Type(str, isAge) {
        this.key = str;
        this.isAge = isAge;
    }

    var relativize = Meta.getBoolean("date-relativize");

    Type.types = {};

    for (var a = ['shortAge', 'longAge', 'fullAge', 'short', 'long', 'full', 'timestamp'], i = 0, l = a.length, t; i < l; i++) {
        t = a[i];
        Type.types[t] = new Type(t, t.toLowerCase().indexOf('age') !== -1);
    }

    var momentTranslations = {};
    Time.FormatType = Type;

    function getTextForRelativeAge(age, type, param) {
        // NOTE: AJS cannot be an AMD dependency as the minifier then changes the AJS.I18n.getText references
        // NOTE: and the transformer doesn't do any translation. IMO this is a webresources _bug_ (https://ecosystem.atlassian.net/browse/PLUGWEB-17).
        if (age in momentTranslations) {
            return AJS.format(momentTranslations[age], param);
        } else {
            return null;
        }
    }

    // TODO These should match http://developer-fe.stg.internal.atlassian.com/design/1.3/foundations/dates/
    // by default.
    function getFormatString(type) {
        switch (type.key) {
            case 'short':
            case 'shortAge':
                return 'll';
            case 'long':
            case 'longAge':
                return 'LL';
            case 'full':
            case 'fullAge':
                return 'LLL';
            case 'timestamp':
                return "LLL";
            default:
                return null;
        }
    }

    function beginningOfDay(time)
    {
        return time.clone().hours(0).minutes(0).seconds(0).milliseconds(0);
    }

    function isYesterday(now, date) {
        var end = beginningOfDay(now);
        var start = end.clone().subtract('d', 1);
        return start <= date && date < end;
    }

    function isTomorrow(now, date) {
        var start = beginningOfDay(now).add('d', 1);
        var end = start.clone().add('d', 1);
        return start <= date && date < end;
    }

    function getMinutesBetween(start, end) {
        return Math.floor(end.diff(start, 'minutes', true));
    }

    function getHoursBetween(start, end) {
        var hourDiff = end.diff(start, 'hours', true);  // Moment's diff does a floor rather than a round so we pass 'true' for a float value
        return Math.round(hourDiff);                    // Then round it ourself
    }

    function getDaysBetween(start, end) {
        return Math.floor(end.diff(start, 'days', true));
    }

    function formatDateWithFormatString(date, type) {
        var formatString = getFormatString(type);
        return date.format(formatString);
    }

    function formatDateWithRelativeAge(date, type, now) {
        now = now || moment();

        if (date <= now) {
            if (date > now.clone().subtract('m', 1)) {
                return getTextForRelativeAge('aMomentAgo', type);
            } else if (date > now.clone().subtract('m', 2)) {
                return getTextForRelativeAge('oneMinuteAgo', type);
            } else if (date > now.clone().subtract('m', 50)) {
                return getTextForRelativeAge('xMinutesAgo', type, getMinutesBetween(date, now));
            } else if (date > now.clone().subtract('m', 90)) {
                return getTextForRelativeAge('oneHourAgo', type);
            } else if (isYesterday(now, date) && date < now.clone().subtract('h', 5)) {
                return getTextForRelativeAge('oneDayAgo', type);
            } else if (date > now.clone().subtract('d', 1)) {
                return getTextForRelativeAge('xHoursAgo', type, getHoursBetween(date, now));
            } else if (date > now.clone().subtract('d', 7)) {
                return getTextForRelativeAge('xDaysAgo', type, Math.max(getDaysBetween(date, now), 2));// if it's not yesterday then don't say it's one day ago
            } else if (date > now.clone().subtract('d', 8)) {
                return getTextForRelativeAge('oneWeekAgo', type);
            }
        } else {
            if (date < now.clone().add('m', 1)) {
                return getTextForRelativeAge('inAMoment', type);
            } else if (date < now.clone().add('m', 2)) {
                return getTextForRelativeAge('inOneMinute', type);
            } else if (date < now.clone().add('m', 50)) {
                return getTextForRelativeAge('inXMinutes', type, getMinutesBetween(now, date));
            } else if (date < now.clone().add('m', 90)) {
                return getTextForRelativeAge('inOneHour', type);
            } else if (isTomorrow(now, date) && date > now.clone().add('h', 5)) {
                return getTextForRelativeAge('inOneDay', type);
            } else if (date < now.clone().add('d', 1)) {
                return getTextForRelativeAge('inXHours', type, getHoursBetween(now, date));
            } else if (date < now.clone().add('d', 7)) {
                return getTextForRelativeAge('inXDays', type, Math.max(getDaysBetween(now, date), 2));// if it's not yesterday then don't say it's one day ago
            } else if (date < now.clone().add('d', 8)) {
                return getTextForRelativeAge('inOneWeek', type);
            }
        }
        return formatDateWithFormatString(date, type);
    }

    Time.formatDate = function formatDate(momentDate, type, forceRelativize) {
        if (momentDate && type) {
            if ((relativize || forceRelativize) && type.isAge) {
                return formatDateWithRelativeAge(momentDate, type);
            } else {
                return formatDateWithFormatString(momentDate, type);
            }
        } else {
            return null;
        }
    };

    Time.setRelativeTranslations = function(values) {
        for (var k in values) {
            momentTranslations[k] = values[k];
        }
    };

    Time.restoreDefaultRelativeTranslations = function() {
        this.setRelativeTranslations({
            'inAMoment': "Now",
            'inOneMinute': "In 1 minute",
            'inXMinutes': "In {0} minutes",
            'inOneHour': "In 1 hour",
            'inXHours': "In {0} hours",
            'inOneDay': "Tomorrow",
            'inXDays': "In {0} days",
            'inOneWeek': "In 1 week",
            'aMomentAgo': "Just now",
            'oneMinuteAgo': "1 minute ago",
            'xMinutesAgo': "{0} minutes ago",
            'oneHourAgo': "1 hour ago",
            'xHoursAgo': "{0} hours ago",
            'oneDayAgo': "Yesterday",
            'xDaysAgo': "{0} days ago",
            'oneWeekAgo': "1 week ago"
        });
    };
    Time.restoreDefaultRelativeTranslations();

    Time.formatDateWithRelativeAge = formatDateWithRelativeAge;
    Time.formatDateWithFormatString = formatDateWithFormatString;

    return Time;
});

AJS.namespace('JIRA.Time', null, require('jira/jquery/plugins/livestamp/time'));
;
;
/* module-key = 'jira.webresources:jquery-livestamp', location = '/includes/jquery/plugins/livestamp/livestamp.js' */
define('jira/jquery/plugins/livestamp/livestamp', [
    'jquery',
    'jira/moment',
    'jira/util/data/meta',
    'jira/jquery/plugins/livestamp/time'
], function ($, moment, Meta, Time) {

    "use strict";

    var timeout,

        updateInterval = 6000,

        relativize = Meta.getBoolean("date-relativize"),

        livestamps = [],

        prep = function ($el, timestamp) {
            $el.data("livestampdata", timestamp);
            livestamps.push($el);
        },

        run = function () {
            clearTimeout(timeout);
            update();
            timeout = setTimeout(run, updateInterval);
        },

        update = function () {
            livestamps = $.grep(livestamps, function ($el) {
                var timestamp = $el.data("livestampdata"),
                    forceRelativize = $el.data('relativize'),
                    from,
                    to;
                if (!moment.isMoment(timestamp) || !$el.closest("html").length) {
                    $el.removeData("livestampdata");
                } else {
                    from = $el.text();
                    var tsFormat = $el.data("datetime-format");

                    tsFormat = tsFormat ? tsFormat : "fullAge"; // TODO We should transition to longAge.
                    if (!(relativize || forceRelativize)) {
                        // We should try not to have any tsFormats like 'AgeAge'
                        tsFormat = tsFormat.replace("Age", "");
                    }

                    to = Time.formatDate(timestamp, Time.FormatType.types[tsFormat], forceRelativize);

                    if (from !== to) {
                        $el.text(to);
                    }
                }
                return !!$el.data("livestampdata");
            });
        },

        add = function ($el) {
            $el.each(function () {
                var $this = $(this),
                    timestamp = $this.attr("datetime");
                if (timestamp) {
                    //reset the timezone to what's specified by the timestamp
                    var timestampMoment = isNaN(timestamp) ?
                        // assuming iso8601 timestamp, let moment#zone() handle it
                        moment(timestamp).zone(timestamp) :
                        // unix epoch timestamp (in milli-seconds)
                        moment(parseInt(timestamp, 10));
                    prep($this, timestampMoment);
                }
            });
            run();
            return $el;
        };

    $.fn.livestamp = function () {
        return add(this);
    };

    return add;
});

// Make extension available in global scope immediately / synchronously.
// TODO INC-71 - remove synchronous require
(function() {
    require('jira/jquery/plugins/livestamp/livestamp');
})();
;
;
/* module-key = 'com.atlassian.jira.jira-fileviewer-plugin:fileviewer', location = '/file-service.js' */
define('jira/fileviewer/file-service', [
    "featureflags/feature-manager",
    "jquery"
], function (
    featureManager,
    $
) {
    'use strict';

    var selectors = {
        image: [
            "a[file-preview-type=image]"
        ],
        document: []
    };

    if (!featureManager.isFeatureEnabled("jira.fileviewer.disable.pdf")) {
        selectors.document.push("a[file-preview-type=document]");
    }

    function getPreviewableFileSelector() {
        return Object.keys(selectors)
            .map(function(k) {
                return selectors[k].join(", ");
            })
            .join(", ");
    }

    function pushSingleOrArray(target, toPush) {
        if (Array.isArray(toPush)) {
            // we do not .concat as this would create a new array with a different reference
            target.push.apply(target, toPush);
        } else {
            target.push(toPush);
        }
    }

    return {
        findFiles: function findPreviewableFiles(context) {
            return $(context || document.body).find(getPreviewableFileSelector());
        },
        getFileSelector: getPreviewableFileSelector,

        getImageSelector: function getPreviewableImageSelector() {
            return selectors.image.join(", ");
        },
        addImageSelector: function addImageSelector(sel) {
            pushSingleOrArray(selectors.image, sel);
        },

        getDocumentSelector: function getPreviewableDocumentSelector() {
            return selectors.document.join(", ");
        },
        addDocumentSelector: function addDocumentSelector(sel) {
            pushSingleOrArray(selectors.document, sel);
        }
    };
});;
;
/* module-key = 'com.atlassian.jira.jira-fileviewer-plugin:fileviewer', location = '/fileviewer.js' */
define('jira/fileviewer', [
    "jira/fileviewer/file-service",
    "jira/loading/loading",
    "jira/ajs/keyboardshortcut/keyboard-shortcut-toggle",
    "jquery",
    "underscore"
], function (
    fileService,
    Loading,
    KeyboardShortcuts,
    $,
    _
) {
    'use strict';

    var viewerReady;
    var viewer;

    function getDownloadUrl($fileElement) {
        return $fileElement.data("download-url") || $fileElement.attr("href")
    }

    function initViewer() {
        if (!viewerReady) {
            viewerReady = WRM.require(['wr!com.atlassian.jira.jira-fileviewer-plugin:atlassian-fileviewer']);
            viewerReady
                .done(function () {
                    viewer = new FileViewer({
                        enableMiniMode: true,
                        viewers: ["image", "document"],
                        // we require these modules just now because they arrive with the fileviewer
                        moduleBackend: require("jira/fileviewer/module-backend/asynchronous"),
                        analyticsBackend: require("jira/fileviewer/module-backend/analytics")
                    });
                    viewer.on('fv.open', KeyboardShortcuts.disable);
                    viewer.on('fv.close', KeyboardShortcuts.enable);
                });
        }
        return viewerReady;
    }

    function closeViewer() {
        if (viewer) {
            viewer.close();
        }
    }

    function updateFiles() {
        var files = [];
        var imageSelector = fileService.getImageSelector();
        var documentSelector = fileService.getDocumentSelector();
        var $files = $(imageSelector + ", " + documentSelector);

        $files.each(function () {
            var $el = $(this).closest('a');
            if ($el.is(imageSelector)) {
                files.push({
                    type: 'image/png',
                    id: $el.attr("file-preview-id"),
                    src: getDownloadUrl($el),
                    title: $el.attr("file-preview-title"),
                    thumbnail: $el.attr("file-preview-url") || $el.attr("data-download-url") || $el.find("img").attr("src")
                });
            }
            if ($el.is(documentSelector)) {
                files.push({
                    type: 'application/pdf',
                    id: $el.attr("file-preview-id"),
                    src: getDownloadUrl($el),
                    title: $el.attr("file-preview-title")
                });
            }
        });

        var uniqFiles = _.uniq(files, false, function (el) {
            return el.id;
        });
        viewer.setFiles(uniqFiles);
        $files
            .off("simpleClick.fvOpen")
            .on("simpleClick.fvOpen",function(e) {
                e.preventDefault();
                viewer.open({
                    id: $(this).attr("file-preview-id")
                });
            });
    }

    function initializePreviews(searchContext) {
        if (!viewer) {
            var $files = fileService.findFiles(searchContext);
            $files
                .off("simpleClick.fvInit")
                .on("simpleClick.fvInit", function(e) {
                    e.preventDefault();
                    var $file = $(this);
                    Loading.showLoadingIndicator();
                    AJS.dim();
                    initViewer()
                        .done(function() {
                            updateFiles();
                            viewer.open({ id: $file.attr("file-preview-id") });
                        })
                        .fail(function() {
                            window.location = getDownloadUrl($file);
                        })
                        .always(function() {
                            $files.off("simpleClick.fvInit");
                            AJS.undim();
                            Loading.hideLoadingIndicator();
                        });
                });
        } else {
            updateFiles();
        }
    }

    return {
        attachToElements: initializePreviews,

        closeViewer: closeViewer,

        addImageSelector: function(sel) {
            fileService.addImageSelector(sel);
        },
        addDocumentSelector: function(sel) {
            fileService.addDocumentSelector(sel);
        }
    };
});;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/issuecomponents.soy' */
// This file was automatically generated from issuecomponents.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Issue.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Issue == 'undefined') { JIRA.Templates.Issue = {}; }


JIRA.Templates.Issue.watchersWithBrowse = function(opt_data, opt_ignored) {
  var output = '<form action="#" method="post" class="aui recipients-form"><a href="#" class="cancel" role="button"><span class="icon-default aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Close") + '</span></a><fieldset><label class="js-add-watchers-label">' + soy.$$escapeHtml("Add Watchers") + '</label><div class="autocomplete-user-target"><select id="watchers" name="watchers" data-description="' + soy.$$escapeHtml("Start Typing for Users") + '" class="watchers-user-picker hidden" multiple="multiple">';
  var watcherList10 = opt_data.watchers;
  var watcherListLen10 = watcherList10.length;
  for (var watcherIndex10 = 0; watcherIndex10 < watcherListLen10; watcherIndex10++) {
    var watcherData10 = watcherList10[watcherIndex10];
    output += '<option style="background-image:url(\'' + soy.$$escapeHtml(watcherData10.avatarUrls['16x16']) + '\')" selected="selected" value="' + soy.$$escapeHtml(watcherData10.name) + '">' + soy.$$escapeHtml(watcherData10.displayName) + '</option>';
  }
  output += '</select></div></fieldset></form>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Issue.watchersWithBrowse.soyTemplateName = 'JIRA.Templates.Issue.watchersWithBrowse';
}


JIRA.Templates.Issue.watchersNoBrowse = function(opt_data, opt_ignored) {
  var output = '<form action="#" method="post" class="aui recipients-form"><a href="#" class="cancel" role="button"><span class="icon-default aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Close") + '</span></a><fieldset><label for="watchers-multi-select">' + soy.$$escapeHtml("Add Watchers") + '</label><div><input type="text" class="text" id="watchers-nosearch" /><div class="description">' + soy.$$escapeHtml("Type username and press enter.") + '</div></div><div class="recipients"><ol class="watchers">';
  var watcherList28 = opt_data.watchers;
  var watcherListLen28 = watcherList28.length;
  for (var watcherIndex28 = 0; watcherIndex28 < watcherListLen28; watcherIndex28++) {
    var watcherData28 = watcherList28[watcherIndex28];
    output += JIRA.Templates.Fields.recipientUsername({username: watcherData28.name, icon: watcherData28.avatarUrls['16x16'], displayName: watcherData28.displayName, escape: true});
  }
  output += '</ol></div></fieldset></form>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Issue.watchersNoBrowse.soyTemplateName = 'JIRA.Templates.Issue.watchersNoBrowse';
}


JIRA.Templates.Issue.error = function(opt_data, opt_ignored) {
  var output = '<p>' + soy.$$escapeHtml(opt_data.msg) + '</p><ul>';
  var messageList40 = opt_data.errors;
  var messageListLen40 = messageList40.length;
  for (var messageIndex40 = 0; messageIndex40 < messageListLen40; messageIndex40++) {
    var messageData40 = messageList40[messageIndex40];
    output += '<li>' + soy.$$escapeHtml(messageData40) + '</li>';
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Issue.error.soyTemplateName = 'JIRA.Templates.Issue.error';
}


JIRA.Templates.Issue.usersListReadOnly = function(opt_data, opt_ignored) {
  var output = '<form class="aui recipients-form"><a href="#" class="cancel" role="button"><span class="icon-default aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Close") + '</span></a><fieldset><div class="recipients"><ol class="voters">';
  var voterList50 = opt_data.users;
  var voterListLen50 = voterList50.length;
  for (var voterIndex50 = 0; voterIndex50 < voterListLen50; voterIndex50++) {
    var voterData50 = voterList50[voterIndex50];
    output += JIRA.Templates.Fields.recipientUsername({username: voterData50.name, icon: voterData50.avatarUrls['16x16'], displayName: voterData50.displayName, readOnly: true, escape: true});
  }
  output += '</ol></div></fieldset></form>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Issue.usersListReadOnly.soyTemplateName = 'JIRA.Templates.Issue.usersListReadOnly';
}
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/entities/user-collection.js' */
define('jira/viewissue/watchers-voters/entities/user-collection', ['require'], function(require) {
    var Messages = require('jira/message');
    var Backbone = require('backbone');
    var _ = require('underscore');
    var $ = require('jquery');
    var contextPath = require('wrm/context-path');
    var TEMPLATES = JIRA.Templates.Issue;

    var JIRAUserModel = Backbone.Model.extend({
        idAttribute: "key"
    });

    return Backbone.Collection.extend({
        model: JIRAUserModel,

        initialize: function(options) {
            if(options === undefined) {
                throw new Error("Must supply options");
            }
            if(options.issueKey) {
                this.issueKey = options.issueKey;
            }else{
                throw new Error("Must supply issue key");
            }

            if(options.endpoint) {
                this.endpoint = options.endpoint;
            }else{
                throw new Error("Must supply an endpoint");
            }

            if(options.modelKey) {
                this.modelKey = options.modelKey;
            }else{
                throw new Error("Must supply an model key");
            }

        },

        url: function() {
            return [contextPath(), 'rest/api/2/issue', this.issueKey, this.endpoint].join("/");
        },

        parse: function(response) {
            return (response && response[this.modelKey]) ? response[this.modelKey]: [];
        },

        ajax:function(options) {
            options = _.extend({
                url: this.url(),
                headers: {"Content-Type": "application/json"},
                success: _.bind(function () {
                    this.fetch();
                }, this),
                error: _.bind(function (xhr) {
                    if (xhr.status !== 404) {
                        this.handleErrorResponse(xhr, "There was an error adding watcher");
                    }
                }, this)
            }, options);
            return $.ajax(options);
        },

        getUser: function (username) {
            return $.ajax({
                url: contextPath() + "/rest/api/2/user?username=" + encodeURIComponent(username),
                error:_.bind(function (xhr) {
                    if (xhr.status !== 404) {
                        this.handleErrorResponse(xhr, "There was an error adding watcher");
                    }
                }, this)
            });
        },

        handleErrorResponse: function (xhr, msg) {
            var errorCollection = this._parseResponse(xhr.responseText);
            if (errorCollection.errorMessages) {
                var html = TEMPLATES.error({
                    msg: msg,
                    errors: errorCollection.errorMessages
                });
                Messages.showErrorMsg(html, {
                    closeable: true
                });
            }
            this.trigger("errorOccurred");
        },

        _parseResponse: function(responseText) {
            try {
                return JSON.parse(responseText);
            } catch (e) {
                // parse JSON failed
                this._showFatalErrorMessage();
                return null;
            }
        },

        _showFatalErrorMessage: function() {
            // TODO: would be nice to extract this error from smartAjax and make it uniform in JIRA
            var msg = '<p>' + "Communications Breakdown" + '</p>' +
                '<p>' + "Close this dialog and press refresh in your browser" + '</p>';
            Messages.showErrorMsg(msg, {
                closeable: true
            });
        }
    });

});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/entities/voters-user-collection.js' */
define('jira/viewissue/watchers-voters/entities/voters-user-collection', [
    'jira/viewissue/watchers-voters/entities/user-collection'
], function(WatchersAndVoterUsers) {

    return WatchersAndVoterUsers.extend({
        initialize: function(issueKey) {
            // add options for the underlying Collection
            var options = { issueKey:issueKey, endpoint:"votes", modelKey:"voters" };
            // super initialize
            WatchersAndVoterUsers.prototype.initialize.apply(this, [options]);
        },

        vote: function() {
            return this.ajax({ type:"POST" });
        },

        unvote: function() {
            return this.ajax({ type:"DELETE" });
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/entities/watchers-user-collection.js' */
define('jira/viewissue/watchers-voters/entities/watchers-user-collection', [
    'jira/viewissue/watchers-voters/entities/user-collection',
    'jira/util/data/meta'
], function(WatchersAndVoterUsers, Meta) {

    return WatchersAndVoterUsers.extend({
        initialize: function(issueKey) {
            this.canBrowseUsers = Meta.get("can-search-users");
            this.isReadOnly = !Meta.get("can-edit-watchers");

            // add options for the underlying Collection
            var options = { issueKey:issueKey, endpoint:"watchers", modelKey:"watchers" };
            // super initialize
            WatchersAndVoterUsers.prototype.initialize.apply(this, [options]);
        },

        addWatcher: function(user) {
            return this.ajax({ type: "POST", data: '"' + user + '"' });
        },

        removeWatcher: function(user) {
            return this.ajax({ type: "DELETE", url: this.url() + "?username=" + user});
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/views/voters-view.js' */
define('jira/viewissue/watchers-voters/views/voters-view', ['require'], function(require) {
    var AuiMessages = require('aui/message');
    var Backbone = require('backbone');
    var _ = require('underscore');
    var jQuery = require('jquery');
    var TEMPLATES = JIRA.Templates.Issue;

    /**
     * View for Voters
     * @class VotersView
     * @extends Backbone.View
     */
    return Backbone.View.extend({
        $empty: undefined,

        initialize: function(options) {
            this.collection = options.collection;
            this.collection.bind("replace reset add remove", this.render, this);
        },

        renderNoWatchers: function () {
            if (this.$(".recipients li").length === 0) {
                this.$empty = AuiMessages.info({
                    closeable: false,
                    body: "There are no voters for this issue"
                });
                this.$("fieldset").append(this.$empty);
            } else if (this.$empty) {
                this.$empty.remove();
            }
        },

        /**
         * Goes to server to get watchers before rendering contents
         *
         * @return {jQuery.Deferred}
         */
        render: function () {
            var deferred = jQuery.Deferred();
            this.collection.fetch().done(_.bind(function () {
                this.$el.html(TEMPLATES.usersListReadOnly({ users: this.collection.toJSON() }));
                this.renderNoWatchers();
                deferred.resolve(this.$el);
            }, this));
            return deferred.promise();
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/views/abstract-watchers-view.js' */
define('jira/viewissue/watchers-voters/views/abstract-watchers-view', ['require'], function(require) {
    var AuiMessages = require('aui/message');
    var Backbone = require('backbone');
    var _ = require('underscore');
    var jQuery = require('jquery');

    /**
     * Views for watchers
     * @class AbstractWatchersView
     * @extends Backbone.View
     * @abstract
     */
    return Backbone.View.extend({
        $empty: undefined,

        renderNoWatchers: function () {
            if (this.$(".recipients li").length === 0) {
                this.$empty = AuiMessages.info({
                    closeable: false,
                    body: "There are no watchers."
                });
                this.$("fieldset").append(this.$empty);
            } else if (this.$empty) {
                this.$empty.remove();
            }
        },

        /**
         * Goes to server to get watchers before rendering contents
         *
         * @return {jQuery.Deferred}
         */
        render: function () {
            var deferred = jQuery.Deferred();
            this.collection.fetch().done(_.bind(function () {
                this._render();
                this.renderNoWatchers();
                deferred.resolve(this.$el);
                setTimeout(_.bind(function () {
                    this.focus();
                }, this), 0);
            }, this));
            return deferred.promise();
        },

        watch: function () {
            jQuery("#watching-toggle").text("Stop watching this issue");
        },

        unwatch: function () {
            jQuery("#watching-toggle").text("Start watching this issue");
        },

        /**
         * Focuses input field
         * @abstract
         * @function
         */
        focus: jQuery.noop,

        /**
         * Increments watcher count by 1
         * @private
         */
        _incrementWatcherCount: function () {
            var $el = jQuery("#watcher-data");
            var currentCount = parseInt($el.text(), 10);
            $el.text(currentCount + 1);
            this.renderNoWatchers();
        },

        /**
         * Decrements watcher count by 1
         * @private
         */
        _decrementWatcherCount: function () {
            var $el = jQuery("#watcher-data");
            var currentCount = parseInt($el.text(), 10);
            $el.text(currentCount - 1);
            this.renderNoWatchers();
        }
    });
});

;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/views/watchers-view.js' */
define('jira/viewissue/watchers-voters/views/watchers-view', ['require'], function(require) {
    var AbstractWatchersView = require('jira/viewissue/watchers-voters/views/abstract-watchers-view');
    var MultiUserListPicker = JIRA.MultiUserListPicker;
    var Meta = require('jira/util/data/meta');
    var _ = require('underscore');
    var TEMPLATES = JIRA.Templates.Issue;

    /**
     * View to handles internal content of inline dialog
     *
     * @class WatchersView
     * @extends AbstractWatchersView
     */
    return AbstractWatchersView.extend({

        events: {
            selected: "addWatcherToModel",
            unselect: "removeWatcherFromModel"
        },

        /**
         * Renders contents. Should only be called when watchers have been fetched.
         * @private
         */
        _render: function () {
            this.$el.html(TEMPLATES.watchersWithBrowse({ watchers: this.collection.toJSON() }));
            var picker = new MultiUserListPicker({
                element: this.$el.find(".watchers-user-picker"),
                width: 220
            });
            this.$el.find('.js-add-watchers-label').attr('for', picker.$field.attr('id'));
        },

        /**
         * @inheritdoc
         */
        focus: function () {
            this.$el.find("#watchers-textarea").focus();
        },

        /**
         * Adds watcher on server
         * @param e
         * @param descriptor
         */
        addWatcherToModel: function (e, descriptor) {
            e.preventDefault();
            this.collection.addWatcher(descriptor.value()).done(_.bind(function () {
                this._incrementWatcherCount();
                if (descriptor.value() === Meta.get("remote-user")) {
                    this.watch();
                }
            }, this));
        },

        /**
         * Removes watcher on server
         * @param e
         * @param descriptor
         */
        removeWatcherFromModel: function (e, descriptor) {
            this.collection.removeWatcher(descriptor.value()).done(_.bind(function () {
                this._decrementWatcherCount();
                if (descriptor.value() === Meta.get("remote-user")) {
                    this.unwatch();
                    JIRA.trace("jira.issue.watcher.deleted");
                }
            }, this));
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/views/watchers-no-browse-view.js' */
define('jira/viewissue/watchers-voters/views/watchers-no-browse-view', ['require'], function(require) {
    var AbstractWatchersView = require('jira/viewissue/watchers-voters/views/abstract-watchers-view');
    var Meta = require('jira/util/data/meta');
    var _ = require('underscore');
    var $ = require('jquery');
    var TEMPLATES = JIRA.Templates.Issue;

    /**
     * @class WatchersNoBrowseView
     * @extends AbstractWatchersView
     */
    return AbstractWatchersView.extend({

        events: {
            "click .remove-recipient" : "removeWatcher",
            "submit" : "addWatcher"
        },

        addWatcher: function (e) {
            e.preventDefault();
            this.removeInlineError();
            var $field = $("#watchers-nosearch");
            var username = $.trim($field.val());
            $field.attr("disabled", "disabled");
            if (this.hasUsername(username)) {
                $field.removeAttr("disabled");
                this.showInlineError(AJS.format("User {0} is already watching this issue", username));
                $field.val("");
            } else {
                this.collection.getUser(username).done(_.bind(function (data) {
                    var html = JIRA.Templates.Fields.recipientUsername({
                        icon: data.avatarUrls["16x16"],
                        username: data.name,
                        displayName: data.displayName
                    });
                    if (username === Meta.get("remote-user")) {
                        this.watch();
                    }
                    $field.val("");
                    this.$(".watchers").append(html);
                    this.collection.addWatcher(data.name);
                    this._incrementWatcherCount();
                }, this)).fail(_.bind(function (xhr) {
                    if (xhr.status === 404) {
                        this.showInlineError("User does not exist");
                    }
                }, this)).always(function () {
                    $field.removeAttr("disabled").focus();
                });
            }

        },

        hasUsername: function (username) {
            var result = false;
            this.$(".watchers li").each(function () {
                if ($(this).attr("data-username") === username) {
                    result = true;
                    return false;
                }
            });
            return result;
        },

        removeInlineError: function () {
            this.$(".error").remove();
        },

        showInlineError: function (msg) {
            $("<div />").addClass("error").text(msg).insertAfter(this.$(".description"));
        },

        focus: function () {
            $("#watchers-nosearch").focus();
        },

        removeWatcher: function (e) {
            e.preventDefault();
            var $item = $(e.target).closest("li");
            var username = $item.attr("data-username");
            if (username) {
                $item.remove();
                this.collection.removeWatcher(username);
                this._decrementWatcherCount();
                if (username === Meta.get("remote-user")) {
                    this.unwatch();
                }
            }
            JIRA.trace("jira.issue.watcher.deleted");
        },
        _render: function () {
            this.$el.html(TEMPLATES.watchersNoBrowse({ watchers: this.collection.toJSON() }));
        }
    });

});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/views/watchers-read-only-view.js' */
define('jira/viewissue/watchers-voters/views/watchers-read-only-view', ['require'], function(require) {
    var AbstractWatchersView = require('jira/viewissue/watchers-voters/views/abstract-watchers-view');
    var TEMPLATES = JIRA.Templates.Issue;

    /**
     * @class WatchersReadOnlyView
     * @extends AbstractWatchersView
     */
    return AbstractWatchersView.extend({
        _render: function () {
            this.$el.html(TEMPLATES.usersListReadOnly({ users: this.collection.toJSON() }));
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/views/watchers-inline-dialog-view.js' */
define('jira/viewissue/watchers-voters/views/watchers-inline-dialog-view', ['require'], function (require) {
    var InlineDialog = require('aui/inline-dialog');
    var InlineDialog2 = require('aui/inline-dialog2'); // Initialises our view dialog
    var Backbone = require('backbone');
    var skate = require('jira/skate');

    var _setElement = Backbone.View.prototype.setElement;

    /**
     * A wrapper layer to house an AUI Inline Dialog for the Watchers list.
     * Exists because inline dialogs are finicky things and their API changes
     * across multiple versions of AUI.
     */
    return Backbone.View.extend({
        tagName: 'aui-inline-dialog2',
        className: 'aui-layer aui-inline-dialog',

        events: {
            'click .cancel': function(e) {
                e.preventDefault();
                this.hide();
            }
        },

        setElement: function(val) {
            var el = (val instanceof Backbone.$) ? val.get(0) : val;
            if (!el) {
                return; // don't set an empty element.
            }
            if (this.el && this.el !== el) {
                this.el.remove(); // detach from DOM, allow for GC.
            }
            _setElement.call(this, el);
            skate.init(this.el);
            return this;
        },
        contents: function(html) {
            this.$el.find('.aui-inline-dialog-contents').html(html);
        },
        show: function() {
            this.el.show(); // will break in AUI 5.9
        },
        hide: function() {
            this.el.hide(); // will break in AUI 5.9
        },
        isVisible: function() {
            return this.el.isVisible ? this.el.isVisible() : this.$el.is(':visible');
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/watchers.js' */
define('jira/viewissue/watchers-voters/watchers', ['require'], function (require) {
    'use strict';

    var WatchersReadOnlyView = require('jira/viewissue/watchers-voters/views/watchers-read-only-view');
    var WatchersNoBrowseView = require('jira/viewissue/watchers-voters/views/watchers-no-browse-view');
    var WatchersView = require('jira/viewissue/watchers-voters/views/watchers-view');
    var WatchersUsersCollection = require('jira/viewissue/watchers-voters/entities/watchers-user-collection');
    var WatchersInlineDialogView = require('jira/viewissue/watchers-voters/views/watchers-inline-dialog-view');
    var Events = require('jira/util/events');
    var Types = require('jira/util/events/types');
    var Reasons = require('jira/util/events/reasons');
    var Issue = require('jira/issue');
    var InlineDialog = require('aui/inline-dialog');
    var $ = require('jquery');

    var dialogView = null;

    function getDialog() {
        if (!dialogView) {
            dialogView = new WatchersInlineDialogView({
                el: $('#inline-dialog-watchers').get(0)
            });
        }
        return dialogView;
    }

    function getView(collection) {
        if (collection.isReadOnly) {
            return WatchersReadOnlyView;
        } else if (collection.canBrowseUsers) {
            return WatchersView;
        } else {
            return WatchersNoBrowseView;
        }
    }

    $(document).on('click', '#view-watcher-list', function (e) {
        e.preventDefault();
        var dialog = getDialog();
        var loadingIcon = $('#watching-toggle').next('.icon');
        var collection = new WatchersUsersCollection(Issue.getIssueKey());
        loadingIcon.addClass('loading');
        var ViewClass = getView(collection);
        new ViewClass({
            collection: collection
        }).render().done(function(viewHtml) {
            loadingIcon.removeClass('loading');
            dialog.contents(viewHtml);
            dialog.show();
        });
        collection.on('errorOccurred', function () {
            dialog.hide();
        });
    });

    $(document).on('keydown', function (e) {
        if (dialogView) {
            // special case for when user hover is open at same time
            if (e.keyCode === 27 && InlineDialog.current !== dialogView.el && dialogView.isVisible()) {
                if (InlineDialog.current) {
                    InlineDialog.current.hide();
                }
                dialogView.hide();
            }
        }
    });

    // JRA-28786 Clicking any whitespace outside of the Watch dialog should dismiss the dialog
    $(document).on('click', function (e) {
        if (dialogView) {
            var watchersDialogOrSuggestionClicked = $(e.target).closest('#inline-dialog-watchers, #watchers-suggestions').length;
            if (watchersDialogOrSuggestionClicked === 0 && dialogView.isVisible()) {
                dialogView.hide();
            }
        }
    });

    Events.bind(Types.NEW_CONTENT_ADDED, function(e, context, reason) {
        //-- remove existing floating #inline-dialog-watchers before refresh adds another one
        if (reason === Reasons.panelRefreshed && context.is('#peoplemodule')) {
            getDialog().setElement(context.find('#inline-dialog-watchers').get(0));
        }
    });

});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/voters.js' */
define('jira/viewissue/watchers-voters/voters', ['require'], function (require) {
    'use strict';

    var VotersUsersCollection = require('jira/viewissue/watchers-voters/entities/voters-user-collection');
    var VotersView = require('jira/viewissue/watchers-voters/views/voters-view');
    var Issue = require('jira/issue');
    var InlineLayer = require('jira/ajs/layer/inline-layer');
    var InlineDialog = require('aui/inline-dialog');
    var $ = require('jquery');

    // Wire up inline dialog to our Backbone view
    var dialog = InlineDialog("#view-voter-list", "voters", function (contents, trigger, doShowPopup) {
                var loadingIcon = $('#vote-toggle').next('.icon');
                var collection = new VotersUsersCollection(Issue.getIssueKey());
                loadingIcon.addClass("loading");
                new VotersView({
                    collection: collection
                }).render().done(function (viewHtml) {
                            contents.html(viewHtml);
                            contents.find(".cancel").click(function (e) {
                                dialog.hide();
                                e.preventDefault();
                            });
                            loadingIcon.removeClass('loading');
                            doShowPopup();
                        });
                collection.on("errorOccurred", function () {
                    dialog.hide();
                });
            },
            {
                width: 240,
                useLiveEvents: true,
                items: "#view-voters-list",
                preHideCallback: function () {
                    return !InlineLayer.current; // Don't close if we have inline layer shown
                }
            });

    $(document).bind("keydown", function (e) {
        // special case for when user hover is open at same time
        if (e.keyCode === 27 && InlineDialog.current !== dialog && dialog.is(":visible")) {
            if (InlineDialog.current) {
                InlineDialog.current.hide();
            }
            dialog.hide();
        }
    });

    // Clicking any whitespace outside of the dialog should dismiss the dialog
    $(document).click(function (e) {
        var currentDialog = InlineDialog.current;
        if (currentDialog && currentDialog.id === "voters") {
            if (!$(e.target).closest("#inline-dialog-voters").length) {
                // I am not a child of the inline dialog
                currentDialog.hide();
            }
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/watchers-voters/toggler.js' */
define('jira/viewissue/watchers-voters/toggler', ['require'], function(require) {
    var SmartAjax = require('jira/ajs/ajax/smart-ajax');
    var Messages = require('jira/flag');
    var $ = require('jquery');
    var contextPath = require('wrm/context-path');

    var toggleVotingAndWatching = function(trigger, className, resultContainer, issueOpTrigger, i18n) {

        var classNameOn = className + "-on";
        var classNameOff = className + "-off";
        var restPath = "/voters";
        var spinner = trigger.next('.icon');
        var data;
        var method = "POST";

        if(trigger.hasClass(classNameOn)) {
            method = "DELETE";
        }

        if(className.indexOf("watch") !== -1) {
            restPath = "/watchers";
        }
        trigger.removeClass(classNameOn).removeClass(classNameOff);

        if (method === "POST") {
            // If we are a post we want to include dummy data to prevent JRA-20675 BUT we cannot have data for DELETE
            // otherwise we introduce JRA-23257
            data = {
                dummy: true
            };
        }

        $(SmartAjax.makeRequest({
            url:contextPath() + "/rest/api/1.0/issues/" + trigger.attr("rel") + restPath,
            type: method,
            dataType: "json",
            data: data,
            contentType: "application/json",
            complete: function (xhr, textStatus, smartAjaxResult) {
                var optIn = method === "POST";
                if (smartAjaxResult.successful) {
                    if(optIn) {
                        trigger.addClass(classNameOn);
                        trigger.text(i18n.titleOn);
                        issueOpTrigger.attr("title", i18n.titleOn).text(i18n.textOn);
                    } else {
                        trigger.addClass(classNameOff);
                        trigger.text(i18n.titleOff);
                        issueOpTrigger.attr("title", i18n.titleOff).text(i18n.textOff);
                    }

                    resultContainer.text(smartAjaxResult.data.count);
                    resultContainer[optIn ? "addClass" : "removeClass"](classNameOn);
                    resultContainer[optIn ? "removeClass" : "addClass"](classNameOff);
                } else {
                    if (!smartAjaxResult.aborted) {
                        displayErrorMessage(smartAjaxResult);
                    }
                    if(optIn) {
                        trigger.addClass(classNameOff);
                        trigger.text(i18n.titleOff);
                        issueOpTrigger.attr("title", i18n.titleOff).text(i18n.textOff);
                    } else {
                        trigger.addClass(classNameOn);
                        trigger.text(i18n.titleOn);
                        issueOpTrigger.attr("title", i18n.titleOn).text(i18n.textOn);
                    }
                }
            }
        })).throbber({target: spinner});
    };

    var displayErrorMessage = function(smartAjaxResult) {
        var message = SmartAjax.buildSimpleErrorContent(smartAjaxResult,{ alert : true });
        if (smartAjaxResult.hasData) {
            var data = JSON.parse(smartAjaxResult.data);
            if (data.errorMessages) {
                message = data.errorMessages[0];
            }
        }
        Messages.showErrorMsg(message, { closeable: true });
    };

    $(document).delegate("#toggle-vote-issue", "click", function(e) {
        e.preventDefault();
        $("#vote-toggle").click();
    });

    $(document).delegate("#toggle-watch-issue", "click", function(e) {
        e.preventDefault();
        $("#watching-toggle").click();
    });

    var addI18nErrorCodes = function(i18n) {
        $("input[type=hidden][id|=error]").each(function(index, elem) {
            var i18n_id = elem.id.replace("error-", "");
            i18n[i18n_id] = elem.value;
        });
    };

    $(document).delegate("#vote-toggle", "click", function(e) {
        e.preventDefault();
        var i18n = {
            titleOn: "Remove vote for this issue",
            titleOff: "Vote for this issue",
            textOn: "Remove Vote",
            textOff: "Add Vote",
            actionTextOff: "Vote",
            actionTextOn: "Voted"
        };
        var trigger = $(this);
        var resultContainer = $(document.querySelectorAll("#vote-data"));
        var issueOpTrigger = $(document.querySelectorAll("#toggle-vote-issue"));
        addI18nErrorCodes(i18n);
        toggleVotingAndWatching(trigger, "vote-state", resultContainer, issueOpTrigger, i18n);
    });

    $(document).delegate("#watching-toggle", "click", function(e) {
        e.preventDefault();
        var i18n = {
            titleOn: "Stop watching this issue",
            titleOff: "Start watching this issue",
            textOn: "Stop Watching",
            textOff: "Watch Issue",
            actionTextOff: "Watch",
            actionTextOn: "Watching"
        };
        var trigger = $(this);
        var resultContainer = $(document.querySelectorAll("#watcher-data"));
        var issueOpTrigger = $(document.querySelectorAll("#toggle-watch-issue"));
        addI18nErrorCodes(i18n);
        toggleVotingAndWatching(trigger, "watch-state", resultContainer, issueOpTrigger, i18n);
    });
});
;
;
/* module-key = 'jira.webresources:viewissue-watchers-and-voters', location = '/includes/jira/viewissue/initWatchersAndVoters.js' */
require([
    'jira/viewissue/watchers-voters/watchers',
    'jira/viewissue/watchers-voters/voters',
    'jira/viewissue/watchers-voters/toggler'
], function() {
    // Watchers and voters initialised
});

//
// Legacy namespacing for watchers and voters
// Deprecated since JIRA 7.1
//
AJS.namespace('JIRA.VotersUsersCollection', null, require('jira/viewissue/watchers-voters/entities/voters-user-collection'));
AJS.namespace('JIRA.WatchersUsersCollection', null, require('jira/viewissue/watchers-voters/entities/watchers-user-collection'));
AJS.namespace('JIRA.VotersView', null, require('jira/viewissue/watchers-voters/views/voters-view'));

AJS.namespace('JIRA.WatchersView', null, require('jira/viewissue/watchers-voters/views/watchers-view'));
AJS.namespace('JIRA.WatchersNoBrowseView', null, require('jira/viewissue/watchers-voters/views/watchers-no-browse-view'));
AJS.namespace('JIRA.WatchersReadOnly', null, require('jira/viewissue/watchers-voters/views/watchers-read-only-view'));
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/AnalyticsUtils.js' */
define("jira/viewissue/analytics-utils", [
    'jira/util/data/meta',
    'jira/issuenavigator/issue-navigator',
    'jira/util/strings',
    'wrm/context-path',
    'jquery',
    'exports'
], function(
    Meta,
    IssueNav,
    StringUtils,
    ContextPath,
    jQuery,
    exports
) {
    function isFullscreenIssue() {
        return jQuery(document.body).hasClass("navigator-issue-only");
    }

    function isServiceDeskQueue() {
        return !!Meta.get("is-servicedesk-rendered");
    }

    function isIssueNav() {
        return IssueNav.isNavigator();
    }

    function isIssueNavFullScreen() {
        return isFullscreenIssue() && StringUtils.contains(location.search, "jql=");
    }

    function isProjectView() {
        return StringUtils.startsWith(location.pathname, ContextPath() + "/projects/");
    }

    exports.context = function() {
        if (isIssueNavFullScreen()) {
            return "fullscreen-issuenav";
        }

        if (isFullscreenIssue()) {
            return "fullscreen";
        }

        if (isServiceDeskQueue()) {
            return "sd-queue";
        }

        if (isIssueNav()) {
            return "issuenav";
        }

        if (isProjectView()) {
            return "project";
        }

        return "unknown";
    };
});

;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/slideshow/slideshow-configuration.js' */
define('jira/viewissue/slideshow/slideshow-configuration', [
    'jira/ajs/keyboardshortcut/keyboard-shortcut-toggle',
    'jquery'
], function(KST, $) {

    var defaultOpts = {
        type: 'image',
        centerOnScroll: true,

        // disable JIRA's keyboard shortcuts when displaying a lightbox
        onStart: KST.disable,
        onClosed: KST.enable
    };

    var transition = 'elastic';

    return $.extend({}, defaultOpts, {
        transitionIn: transition,
        transitionOut: transition
    });
});
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/element/image-wrap.js' */
define('jira/viewissue/element/image-wrap', [
    'jira/fileviewer',
    'jira/skate',
    'featureflags/feature-manager',
    'underscore'
], function(
    fileviewer,
    skate,
    featureManager,
    _
) {
    if (featureManager.isFeatureEnabled("jira.fileviewer.disabled")) {
        return;
    }

    skate('file-preview-type', {
        type: skate.type.ATTRIBUTE,
        attached: _.debounce(function elementAttachedHandler() {
            fileviewer.attachToElements();
        }, 0),
        detached: function() {
            fileviewer.closeViewer();
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jquery/plugins/shorten/shorten.js' */
define('jira/ajs/shorten/shortener', [
    'jira/ajs/control',
    'jira/data/local-storage',
//    'aui',
    'jquery'
], function(
    Control,
    localStorage,
//    AJS,
    jQuery
) {
    /**
     * Shorten long lists with an ellipsis
     *
     * <h4>Use </h4>
     *
     * <h5>Markup:</h5>
     *
     * <pre>
     * <div id="mylist">
     *      <a href='#'>a</a>
     *      <a href='#'>b</a>
     *      <a href='#'>c</a>
     *      <a href='#'>d</a>
     *      <a href='#'>e</a>
     *      <a href='#'>f</a>
     *      <a href='#'>g</a>
     *      <a href='#'>h</a>
     *      <a href='#'>i</a>
     *      <a href='#'>j</a>
     *      <a href='#'>k</a>
     * </div>
     * </pre>
     *
     * <h5>JavaScript</h5>
     *
     * <pre>
     * // no options
     * new AJS.Shortener("#mylist");
     *
     * // with options
     * new AJS.Shortener({
     *      element: "#myList",
     *      numRows: 2
     * });
     * </pre>
     *
     * @class Shortener
     * @extends Control
     *
     */
    return Control.extend({

        _getDefaultOptions: function () {
            return {
                items: "a, span",
                numRows: 1,
                shortenText: "hide",
                shortenOnInit: true,
                persist: true,
                expandButtonTooltip: "Click to view {0} more",
                collapseButtonTooltip: "Hide"
            };
        },

        /**
         * Creates a shorten control
         *
         * @constructs
         * @param {Object} options
         * @param {String |jQuery} [options.items=a,span] - selector or jQuery collection specifying items
         * @param {Number} [options.numRows=1] - Number of rows to display when shortened
         * @param {String} [options.shortenText=hide] - Text to display in link at the end of the list when expanded
         * @param {Boolean} [options.shortenOnInit=true] - If true will shorten onload
         */
        init: function (options) {

            if (typeof options === "string") {
                options = {element: options};
            }

            options = options || {};

            this.options = jQuery.extend(this._getDefaultOptions(), options);
            this._timerId = 0;
            this.expanded = false;

            this.$container = jQuery(this.options.element);
            this._assignEvents("body", document.body);
            this._ready();
        },

        /**
         * Validate initialization
         * @return {Boolean}
         */
        _isValid: function () {
            return !this.initialized && this.$container.is(":visible") && this.$container.children().length > 0;
        },

        /**
         * Lazy initialization, so that we can init on dom ready if it is visible or when a activating a tab makes it visible
         * @private
         */
        _ready: function () {
            if (this._isValid()) {

                this.$items = this.$container.children(this.options.items);
                this.$expandButton = this._render("expandButton");
                this.$collapseButton = this._render("collapseButton");

                this._assignEvents("expand-button", ".shortener-expand");
                this._assignEvents("collapse-button", ".shortener-collapse");

                if (!jQuery.browser.msie || jQuery.browser.version >= "9") {
                    // IE8 is excluded from reflowing on "resize" events. Rendering this thing
                    // is very expensive in IE8 and "resize" events occur too frequently.
                    this._assignEvents("resize-region", window);
                }

                if (this._isCollapsedOnInit()) {
                    this.collapse();
                } else {
                    this.expand();
                }

                this.initialized = true;
            }
        },


        _renders: {

            /**
             * Creates the jQuery object representing an ellipsis. The ellipsis appended to the shortened list of items. It
             * contains text representing how many items have been hidden. When clicked it reveals the full list.
             * The ellipsis has a class of <strong>ellipsis</strong> and styling should be controlled in css.
             *
             * @method #_renders.expandButton
             * @private
             * @param {number} itemsHidden - number of items hidden
             * @return {jQuery} jQuery wrapped HTML element
             *
             */
            "expandButton": function () {
                return jQuery("<a href='#' class='ellipsis shortener-expand' title='" + this.options.expandButtonTooltip + "'></a><br>");
            },

            /**
             * Creates the jQuery object representing the shorten tip. The shorten tip is appended to the expanded list of
             * items. When clicked it shortens the list to the user specified paramater <strong>numRows</strong> Ellipsis has
             * a calss of <strong>icon-hide</strong> and styling should be controlled in css.
             *
             * @method #_renders.shortenTip
             * @private
             * @param {string} removeText - number of items hidden
             * @return {jQuery} jQuery wrapped HTML element
             *
             */
            "collapseButton": function () {
                return jQuery("<a title='Hide' class='icon icon-hide shortener-collapse' href='#'><span>" + this.options.collapseButtonTooltip + "</span></a>");
            }
        },

        _events: {
            "expand-button": {
                "click": function(event) {
                    if (event.currentTarget === this.$expandButton[0]) {
                        event.preventDefault();
                        this.expand();
                        this._saveState("expanded");
                    }
                }
            },
            "collapse-button": {
                "click": function(event) {
                    if (event.currentTarget === this.$collapseButton[0]) {
                        event.preventDefault();
                        this.collapse();
                        this._saveState("collapsed");
                        this.$container.scrollIntoView();
                    }
                }
            },
            "resize-region": {
                "resize": function() {
                    clearTimeout(this._timerId);
                    if (!this.expanded) {
                        var instance = this;
                        this._timerId = setTimeout(function() {
                            instance.collapse();
                        }, 400);
                    }
                }
            },
            "body": {
                // handling for the case where control is in a tab, and as a result hidden.
                tabSelect: function () {
                    this._ready();
                }
            }
        },

        /**
         * @private
         * @param {string} value
         */
        _saveState: function(value) {
            try {
                localStorage.setItem("AJS.Shortener#" + this.$container.closest("[id]").attr("id"), value);
            } catch (QUOTA_EXCEEDED_ERR) {
                // ignore
            }
        },

        /**
         * @private
         * @return {?string}
         */
        _loadState: function() {
            return localStorage.getItem("AJS.Shortener#" + this.$container.closest("[id]").attr("id"));
        },

        /**
         * Should list should be shortened on load. This is determined by cookie, if persist options is true, or "shortenOnInit"
         * option. Please not that if persist option is set to true, the list will not be shortened if use has expanded it previously
         * regardless of the shortenOnInit set to true.
         *
         * @private
         * @return boolean
         */
        _isCollapsedOnInit: function() {
            var shortenOnInit = this._loadState();
            if (shortenOnInit !== null) {
                return shortenOnInit !== "expanded";
            }
            return this.options.shortenOnInit;
        },

        /**
         * Removes $expandButton and $collapseButton.
         *
         * @private
         */
        _removeButtons: function () {
            this.$expandButton.remove();
            this.$collapseButton.remove();
        },

        /**
         * Get the index within this.$items of the first element that flows over
         * the allowed number of lines, or (-1) if all items fit within the limit.
         *
         * Note: The first item in the list is never considered overflowing, even
         * when it contains several words that might wrap multiple lines, so this
         * function will never return 0.
         *
         * @private
         * @return {number}
         */
        _getOverflowIndex: function() {

            if (this.$items.length > 1) {

                var currentRow = 1;
                var prevItemPageX = -1;

                for (var i = 0; i < this.$items.length; i++) {
                    var itemPageX = this.$items.eq(i).offset().left;
                    if (itemPageX <= prevItemPageX) {
                        // This item flows to a new line.
                        currentRow++;
                        if (currentRow > this.options.numRows) {
                            // This item exceeds the allowed number of lines.
                            return i;
                        }
                    }
                    prevItemPageX = itemPageX;
                }
            }

            return -1;
        },

        /**
         * Expands list to full height, adding a link to shorten
         */
        expand: function() {

            this._removeButtons();

            if (this._getOverflowIndex() > 0) {

                this.$collapseButton = this._render("collapseButton");

                this.$container.append(this.$collapseButton);
                this.$container.css("height", "auto");

                // Ensure IE8 renders the new layout.
                if (jQuery.browser.msie && jQuery.browser.version < "9") {
                    jQuery('body').toggleClass('reflow');
                }
            }

            this.expanded = true;
        },

        /**
         * Contracts list to user specified number of rows, adding a link to shorten.
         */
        collapse: function() {

            this._removeButtons();

            var i = this._getOverflowIndex();

            if (i > 0) {
                // Isolate $container in render tree while we make adjustments.
                this.$container.css({
                    "position": "absolute",
                    "visibility": "hidden",
                    "width": this.$container[0].clientWidth + "px"
                });

                var $expandButtonContent = this.$expandButton.first();

                do {
                    var remainingItemCount = (this.$items.length - i);

                    $expandButtonContent.text("(" + remainingItemCount + ")");
                    this.$expandButton.insertBefore(this.$items[i]);

                    // Check that $expandButton fits on the same line as the previous item,
                    // otherwise try again with the item before that.
                    i--;

                    var oi = this.$items.eq(i).offset();
                    var ob = this.$expandButton.offset();

                    if (oi.left < ob.left && ob.top < oi.top + 10) {
                        // It fits! We assume $expandButton is on the same line as the previous
                        // item if it's offsetTop is less than a line-height below the item's
                        // offsetTop. Hard-coding 10px is a best approximation of line-height.
                        break;
                    }
                } while (i > 0);

                // Set the $container height required to clip the item immediately after $expandButton.
                var height = (i < this.$items.length - 1)
                           ? (this.$items.eq(i + 1).offset().top - this.$container.offset().top) + "px"
                           : "auto";

                this.$container.css({
                    "height": height,
                    "position": "static",
                    "visibility": "visible",
                    "width": "auto"
                });

                $expandButtonContent.attr("title", AJS.format(this.options.expandButtonTooltip, remainingItemCount));

                // Ensure IE8 renders the new layout.
                // Otherwise, shortening a field in the "People" group will leave the things below it hanging.
                if (jQuery.browser.msie && jQuery.browser.version < "9") {
                    jQuery('body').toggleClass('reflow');
                }

            } else {
                // Make sure no items are being clipped.
                this.$container.css("height", "auto");
            }

            this.expanded = false;
        }
    });
});

define('jira/jquery/plugins/shorten/shorten', [
    'jira/ajs/shorten/shortener',
    'jquery'
], function(
    Shortener,
    jQuery
) {
    /**
     *
     * jQuery plugin to shorten long lists with an ellipsis.
     *
     * For full options see {@link Shortener}
     *
     * @note Delegates to {@link Shortener}
     *
     * @example
     *
     * // no options
     * jQuery("#my-container").shorten();
     *
     * // options
     * jQuery("#my-container").shorten({
     *      numRows: 5
     * });
     *
     * @function external:"jQuery.fn".shorten
     * @param {Object} [options]
     * @param {HTMLElement | jQuery} options.element
     */
    jQuery.fn.shorten = function (options) {

        var res = [];
        options = options || {};

        this.each(function () {
            options.element = this;
            res.push(new Shortener(options));
        });

        return res;
    };
});

AJS.namespace('AJS.Shortener', null, require('jira/ajs/shorten/shortener'));

// Make extension available in global scope immediately / synchronously.
// TODO INC-71 - remove synchronous require
(function() {
    require('jira/jquery/plugins/shorten/shorten');
})();
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/element/shorten.js' */
define('jira/viewissue/element/shorten', [
    'jira/ajs/shorten/shortener',
    'jira/skate'
], function(Shortener, skate) {
    return skate('shorten', {
        type: skate.type.CLASSNAME,
        attached: function(element) {
            var options = {};
            options.element = element;
            new Shortener(options);
        }
    });
});
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/initToggleBlock.js' */
AJS.$(function() {
    new JIRA.ToggleBlock({
        blockSelector: ".toggle-wrap",
        triggerSelector: ".mod-header .toggle-title",
        storageCollectionName: "block-states"
    });

    // When we refresh the issue page we also need make sure we restore twixi block state
    if (JIRA.Events.ISSUE_REFRESHED) {
        JIRA.bind(JIRA.Events.ISSUE_REFRESHED, function () {
            if (JIRA.Events.REFRESH_TOGGLE_BLOCKS) {
                JIRA.trigger(JIRA.Events.REFRESH_TOGGLE_BLOCKS);
            }
        });
    }
});;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/initComment.js' */
(function ($) {

    /**
     * This is used to control the logic of showing confirmation dialog.
     * If the comment form is being submitted, there should be no confirmation dialog appearing at all.
     * Its value will be changed when successfully submitting the form and start opening a new form.
     * @type {boolean}
     */
    var commentFormIsBeingSubmitted = false;
    var isInPreviewMode = false;
    var commentForm = JIRA.Issue.CommentForm = {
        /**
         * Cancels a comment. This means clearing the text area, resetting the
         * dirty state for the closes form, and collapsing the comment box.
         *
         * If comment preview mode is enabled, this function disables it before
         * attempting to clear the comment textarea.
         */
        setCaretAtEndOfCommentField: function () {
            var $field = this.getField(),
                field = $field[0],
                length;
            if ($field.length) {
                length = $field.val().length;
                $field.scrollTop($field.attr("scrollHeight"));
                if (field.setSelectionRange && length > 0) {
                    field.setSelectionRange(length, length);
                }
            }
        },

        /**
         * When we submit disable all the fields to avoid mods and double submit
         */
        disable: function () {
            this.getForm().find("textarea").attr("readonly", "readonly");
            this.getForm().find("input[type=submit]").attr("disabled", "disabled");
        },

        /**
         * Check if value has changed
         *
         * @return {Boolean}
         */
        isDirty: function () {
            var field = this.getField();
            if (field.length) {
                return field[0].value !== field[0].defaultValue;
            }
            return false;
        },

        handleBrowseAway: function () {
            // If the form isn't dirty, no point continuing.
            if (!commentForm.isDirty()) return;

            // If the form isn't visible, then don't show a dirty warning. This
            // is particularly important for the issue search single-page-app.
            var form = commentForm.getForm();
            var isVisible = form.length && form.is(":visible");

            if (isVisible) {
                return "You have entered a comment on this issue. If you navigate away from this page without first saving, the comment will be lost.";
            }
        },

        isVisibilityAvailble: function() {
            return this.getForm().find("#commentLevel :selected").val() != 'none';
        },

        setSubmitState: function () {
            if (jQuery.trim(this.getField().val()).length > 0 && this.isVisibilityAvailble()) {
                this.getForm().find("#issue-comment-add-submit").removeAttr("disabled");
            } else {
                this.getForm().find("#issue-comment-add-submit").attr("disabled", "disabled");
            }
        },

        /**
         * Enables the comment form
         */
        enable: function () {
            this.getForm().find("textarea").removeAttr("readonly");
            this.getForm().find("input[type=submit]").removeAttr("disabled");
        },

        /**
         * Get comment visibility permission.
         *
         * @return {Object} -- null if no value has been selected
         */
        getCommentVisibility: function() {
            var visibility = this.getForm().find("#commentLevel :selected").val();
            if (visibility) {
                var split_v = visibility.split(':');
                return {
                    "type" : split_v[0],
                    "value" : this.getForm().find("#commentLevel :selected").text()
                };
            }
            return null;
        },

        /**
         * Submits comments via ajax, used in kickass
         */
        ajaxSubmit: function (callback) {
            var $loading = jQuery('<span class="icon throbber loading"></span>');
            var issueId = JIRA.Issue.getIssueId();
            var issueKey = JIRA.Issue.getIssueKey();
            var restURL = contextPath + "/rest/api/2/issue/" + issueKey + "/comment";
            //build rest request
            var newComment = {
                // set line ending to CRLF for consistency with other comment methods
                // for example: add comment in new tab (midlde click), add comment in edit issue, or edit comment - they all use CRLF
                "body":this.getField()[0].value.replace(/\r?\n/g, "\r\n")
            };
            var visibility = this.getCommentVisibility();
            if (visibility) {
                newComment["visibility"] = visibility;
            }

            $.ajax({
                url:restURL,
                type:"POST",
                contentType:"application/json",
                data:JSON.stringify(newComment),
                success:function (data)
                {
                    JIRA.trigger(JIRA.Events.UNLOCK_PANEL_REFRESHING, ["addcommentmodule"]);
                    JIRA.trigger(JIRA.Events.REFRESH_ISSUE_PAGE, [issueId, {
                        complete:function () {
                            //highlight comment, set anchor
                            var newCommentId = "comment-" + data.id;
                            //Do not append the hash to the url (to let browser scroll the element into view)
                            //Appending the hash will add a new history point and as of 6.0 it will be incompatible,
                            //as back/forward button will be navigation between issues, instead of the states in the current issue.
                            //Instead manually scroll the element into view
                            jQuery("#" + newCommentId).scrollIntoView({
                                marginBottom: 200,
                                marginTop: 200
                            });
                            //remove the focusing from any other comments
                            var $focusedTabs = $("#issue_actions_container > .issue-data-block.focused");
                            $focusedTabs.removeClass("focused");
                            var $newfocusedTab = $("#" + newCommentId);
                            //assume only one focused comment
                            $newfocusedTab.addClass("focused");
                            $loading.remove();
                            footerComment.hide(true); //hiding both?
                            // Re-enable the comment form after successful complete in preparation for future use.
                            commentForm.enable();
                        }
                    }]);
                },
                error: function (xhr) {
                    function buildErrorDialog(errorMessage) {
                        var errorContent =
                            '<h2>' + "Error" + '</h2>' +
                            '<div class="ajaxerror">' +
                                '<div class="aui-message error">' +
                                    '<span class="aui-icon icon-warning"/>' +
                                    errorMessage +
                                '</div>' +
                            '</div>';
                        return $(errorContent);
                    }

                    var response = $.parseJSON(xhr.responseText);
                    var content;
                    if (response && response.errors && response.errors.comment) {
                        content = buildErrorDialog(response.errors.comment);
                    } else {
                        content = JIRA.SmartAjax.buildDialogErrorContent(xhr);
                    }
                    new JIRA.FormDialog({
                        content: content
                    }).show();
                    $loading.remove();
                    commentForm.enable();
                }
            });
            $loading.appendTo(this.getForm().find("input[type=submit]").parent());
        },

        /**
         * Gets form from dom or cached one
         *
         * @return {jQuery}
         */
        getForm: function () {
            var $form = $("form#issue-comment-add");
            if ($form.length === 1) {
                // on page load or panels have been refeshed and we have another comment form
                this.$form = $form;
            }
            return this.$form || $();
        },

        /**
         * Gets the comment textarea
         * @return {jQuery}
         */
        getField: function () {
            return this.getForm().find("#comment");
        },

        getSubmitButton: function () {
            return this.getForm().find("#issue-comment-add-submit");
        },

        /**
         * Hides form by removing it from dom
         *
         * @param cancel
         */
        hide: function (cancel) {
            if (cancel) {
                this.cancel();
            }
            this.getForm().detach();
            if (JIRA.Events.UNLOCK_PANEL_REFRESHING) {
                // disable panel refreshing in kickass
                JIRA.trigger(JIRA.Events.UNLOCK_PANEL_REFRESHING, ["addcommentmodule"]);
            }
        },

        /**
         * Focuses form
         */
        show: function () {
            this.focus();
            if (JIRA.Events.LOCK_PANEL_REFRESHING) {
                // disable panel refreshing in kickass
                JIRA.trigger(JIRA.Events.LOCK_PANEL_REFRESHING, ["addcommentmodule"]);
            }
        },

        /**
         * Focuses field and puts cursor at end of text
         */
        focus: function () {
            this.focusField();
            this.setCaretAtEndOfCommentField();
        },

        focusField: function() {
            this.getField().focus().trigger("keyup");

            this.getSubmitButton().scrollIntoView({
                marginBottom: 200
            });
        },

        /**
         *
         * @param e
         * @return {Boolean} - Did it show message or not
         */
        showNoCommentMsg: function (e) {
            if (this.getField().val() === "") {
                $("#emptyCommentErrMsg").show();
                return true;
            }
        },
        /**
         * Cancels comment, removing the value from the textarea
         */
        cancel: function () {
            var instance = this;
            // now clear the input value.  Need to do this in a timeout since FF 3.0 otherwise doesn't
            //clear things.
            setTimeout(function() {instance.getField().val('');}, 100);
            // JRADEV-3411: disable preview if necessary so the comment gets cleared properly
            $('#comment-preview_link.selected').click();
        }
    };


    var footerComment = {
        /**
         * Gets comment module
         * @return {jQuery}
         */
        getModule: function () {
            return $("#addcomment");
        },
        /**
         * Is the comment area visible
         * @return {*}
         */
        isActive: function () {
            return this.getModule().hasClass("active");
        },
        /**
         * Hides comment area
         *
         * @param cancel - clear textarea
         */
        hide: function (cancel) {
            if (this.isActive()) {
                var dirtyMessage = commentForm.handleBrowseAway();
                if (isInPreviewMode || commentFormIsBeingSubmitted || !dirtyMessage || confirm(dirtyMessage)) {
                    this.getModule().removeClass("active");
                    commentForm.hide(cancel);
                }
            }
        },
        ajaxSubmit: function () {
            commentFormIsBeingSubmitted = true;
            commentForm.ajaxSubmit(function () {
                footerComment.hide();
            });
        },
        /**
         * Shows comment area
         */
        show: function () {
            if (!this.isActive()) {
                commentFormIsBeingSubmitted = false;
                this.getModule().addClass("active");
                this.appendForm();
                commentForm.show();
            } else {
                commentForm.focusField();
            }
        },
        /**
         * Appends form to correct location
         */
        appendForm: function () {
            this.getModule().find(".mod-content").append(commentForm.getForm());
        }
    };

    var oldBeforeUnload = window.onbeforeunload;

    $(document)
        // issue comments are always ajax submitted
        .delegate("#addcomment #issue-comment-add", "submit", function (e) {
            footerComment.ajaxSubmit();
            e.preventDefault();
        })
        // show/hide of comment in header
        .delegate(".issue-header #comment-issue", "click", function (e) {
            footerComment.show();
            e.preventDefault();
        })
        // show/hide of comment in footer
        .delegate("#footer-comment-button", "click", function (e) {
            footerComment.show();

            commentForm.getForm().find('#commentLevel').bind('change', function() {
                commentForm.setSubmitState();
            });
            commentForm.setSubmitState();
            e.preventDefault();
        })
        // Cancel comment in footer
        .delegate("#addcomment .cancel", "click", function (e) {
            e.preventDefault();
            footerComment.hide(true);
        })
        .delegate("#issue-comment-add", "submit", function () {
            window.setTimeout(function () { // JRADEV-11111 - IE8 requires a timeout
                commentForm.disable();
            }, 0);
        })
        .delegate("#issue-comment-add #comment", "input", function () {
            commentForm.setSubmitState();
        })
        .delegate("#issue-comment-add input[type='submit']", "click", function (e) {
            if (commentForm.showNoCommentMsg()) {
                e.preventDefault();
            }
        })
        .bind("showWikiInput", function () {
            isInPreviewMode = false;
            var $commentField = commentForm.getField();
            if ($commentField.is(":visible:enabled")) {
                JIRA.Issue.getStalker().trigger("stalkerHeightUpdated");
                if ($commentField.length > 0) {
                    $commentField.focus();
                }
                commentForm.setCaretAtEndOfCommentField();
            }
        })
        .bind("showWikiPreview", function () {
            isInPreviewMode = true;
            JIRA.Issue.getStalker().trigger("stalkerHeightUpdated");
        });

    // Why not just use jQuery I hear you say?? Well it doesn't work for IE!
    // JRADEV-11612
    window.onbeforeunload = function () {
        return oldBeforeUnload.apply(this, arguments) ||
            commentForm.handleBrowseAway.apply(this, arguments);
    };

    /**
     * Construct a dirty comment warning if the comment form is dirty.
     *
     * @returns {string|undefined} A dirty comment warning or undefined.
     */
    JIRA.Issue.getDirtyCommentWarning = commentForm.handleBrowseAway;

    /**
     * Invoke the most appropriate comment trigger on page.
     * If the header toolbar trigger is present then invoke that.
     * Otherwise invoke the first link with ".add-issue-comment" class (needed for adding comments in Issue Nav list view).
     */
    JIRA.Issue.invokeCommentTrigger = function() {
        var addIssueComment = AJS.$(".add-issue-comment");
        if (addIssueComment.length === 0) {
            return;
        }

        var toolbarTrigger = addIssueComment.filter(".toolbar-trigger");
        if (toolbarTrigger.length > 0) {
            // Click issue page toolbar trigger if it's present.
            toolbarTrigger.click();
        } else {
            // Otherwise click the first link on page (needed for Issue Nav list view).
            addIssueComment.click();
        }
    };
})(AJS.$);

/**
 * Check for add-comment anchor and open the bottom comment box
 */
AJS.$(function () {
    if (parseUri(window.location.href).anchor === "add-comment") {
        AJS.$("#footer-comment-button").click();
    }
});
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/initCustomFieldTabs.js' */
(function ($, scope) {
    var activateTab = function(tabName) {
        var tabTrigger;
        if (typeof tabName !== "string" && tabName.length > 0) return;
        if (tabName[0] !== "#") tabName = "#" + tabName; // Ensure there's a hash. It'll work for both jQuery + href selectors

        console.log("activating tab", tabName);
        tabTrigger = $("a[href='" + tabName +"']", scope);
        if (tabTrigger.length) {
            AJS.tabs.change(tabTrigger);
        }
    };

    var revealer = function(e) {
        var $containingTab = $(e.target).closest(".tabs-pane");
        if ($containingTab.length > 0) {
            activateTab($containingTab.attr("id"));
        }
    };

    $(function () {
        if (JIRA.Events.NEW_CONTENT_ADDED) {
            JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, $context) {
                // Bind the revealer to new content.
                var $customFieldModule = $context.find(scope);
                $customFieldModule.unbind("reveal");
                $customFieldModule.bind("reveal", revealer);

                // Set up and tabs in the new content.
                AJS.tabs.setup();
            });
        }

        // Preserve the active custom field tab when refreshing the details panel.
        if (JIRA.Events.PANEL_REFRESHED) {
            JIRA.bind(JIRA.Events.PANEL_REFRESHED, function (e, panel, $new, $existing) {
                if (panel === "details-module") {
                    var $activeTab = $existing.find(scope).find(".active-tab");
                    if ($activeTab.length === 1) {
                        activateTab($activeTab.find("a").attr("href"));
                    }
                }
            });
        }

        $(scope).bind("reveal", revealer);
    });
})(AJS.$, "#customfieldmodule");;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/initSubtaskTimeLogging.js' */
(function ($) {
    $(document).delegate("#tt_include_subtasks input", "click", function(e) {
        if (AJS.$(this).is(":checked")){
            AJS.$("#tt_info_single").hide();
            AJS.$("#tt_info_aggregate").show();
        } else {
            AJS.$("#tt_info_aggregate").hide();
            AJS.$("#tt_info_single").show();
        }
    });
})(AJS.$);;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/ViewIssueTabs.soy' */
// This file was automatically generated from ViewIssueTabs.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Issue.Tabs.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Issue == 'undefined') { JIRA.Templates.Issue = {}; }
if (typeof JIRA.Templates.Issue.Tabs == 'undefined') { JIRA.Templates.Issue.Tabs = {}; }


JIRA.Templates.Issue.Tabs.label = function(opt_data, opt_ignored) {
  return '<strong>' + soy.$$escapeHtml(opt_data.text) + '</strong>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issue.Tabs.label.soyTemplateName = 'JIRA.Templates.Issue.Tabs.label';
}


JIRA.Templates.Issue.Tabs.tab = function(opt_data, opt_ignored) {
  return '<a id="' + soy.$$escapeHtml(opt_data.id) + '" href="' + soy.$$escapeHtml(opt_data.href) + '" class="' + soy.$$escapeHtml(opt_data.linkClass) + '">' + JIRA.Templates.Issue.Tabs.label(opt_data) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issue.Tabs.tab.soyTemplateName = 'JIRA.Templates.Issue.Tabs.tab';
}
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/ViewIssueTabsAnalytics.js' */
define("jira/viewissue/tabs/analytics", [
    'jquery',
    'jira/util/strings',
    'jira/viewissue/analytics-utils',
    'underscore'
], function (
    jQuery,
    StringUtils,
    AnalyticsUtils,
    _
) {
    var Trigger = AJS.trigger;

    var privacyPolicyWhitlistedTabs = [
        "com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel",
        "com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel",
        "com.atlassian.jira.plugin.system.issuetabpanels:worklog-tabpanel",
        "com.atlassian.jira.plugin.system.issuetabpanels:changehistory-tabpanel",
        "com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab"
    ];

    function whitelistedTabId (tabId) {
        if (privacyPolicyWhitlistedTabs.indexOf(tabId) > -1) {
            return tabId;
        }
        return StringUtils.hashCode(tabId);
    }

    function getTabData($tabElement) {
        return {
            tab: whitelistedTabId($tabElement.attr('data-key')),
            tabPosition: $tabElement.index()
        }
    }

    function baseEventData(openedInNewWindow, triggeredByKeyboard) {
        return {
            inNewWindow: openedInNewWindow,
            keyboard: triggeredByKeyboard,
            context: AnalyticsUtils.context()
        }
    }

    return {
        tabClicked: function($elementClicked, openedInNewWindow, triggeredByKeyboard) {
            var $parent = $elementClicked.parent();
            var data = _.extend({}, baseEventData(openedInNewWindow, triggeredByKeyboard), getTabData($parent));
            Trigger("analyticsEvent", {
                name: "jira.viewissue.tab.clicked",
                data: data
            });
        },

        buttonClicked: function($elementClicked, openedInNewWindow, triggeredByKeyboard) {
            if (!$elementClicked.is("[data-tab-sort]")) {
                return;
            }

            var order = $elementClicked.data("order");
            var $activeTab = $elementClicked.parents(".tabwrap").find("li.active");

            Trigger("analyticsEvent", {
                name: "jira.viewissue.tabsort.clicked",
                data: _.extend({}, baseEventData(openedInNewWindow, triggeredByKeyboard), getTabData($activeTab), {
                    order: order
                })
            });
        }
    };
});;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/ViewIssueTabs.js' */
/**
 * This module encapsulates issue tab-related functionality

 * @namespace JIRA.ViewIssueTabs
 * @requires jQuery
 * @requires JIRA.Dialog
 */
define("jira/viewissue/tabs", [
    "jquery",
    "jira/util/data/meta",
    "jira/dialog/form-dialog",
    "jira/ajs/ajax/smart-ajax",
    "jira/userhover/userhover",
    "jira/viewissue/tabs/analytics"
], function(
    jQuery,
    Meta,
    FormDialog,
    SmartAjax,
    Userhover,
    Analytics
) {
    var Format = AJS.format;
    var Templates = JIRA.Templates.Issue.Tabs;

    /**
     * Whether to use the HTML5 History API when switching between tabs. Setting this to false will cause tab switching
     * to just use a plain AJAX request without changing the URL.
     *
     * @type {Boolean}
     */
    var useHistoryApi = Meta.get('viewissue-use-history-api') !== false;

    /**
     * The CSS class used to mark issue tab panel links that can be loaded using AJAX.
     */
    var AJAX_LOAD_CLASS = 'ajax-activity-content';

    /**
     * The selector for container that should contain contents be loaded using AJAX.
     */
    var CONTAINER_SELECTOR = '#activitymodule div.mod-content';

    /**
     * The selector for links that should be loaded using AJAX.
     */
    var AJAX_LINK_SELECTOR = Format('a.{0}', AJAX_LOAD_CLASS);

    /**
     *
     * This array holds the functions that will be called after a issue tab is loaded.
     */
    var issueTabLoadedListeners = [];

    /**
     * These are used to display progress and the tab contents.
     */
    var $tabWrapper,
        $tabContents;

    /**
     * The XHR that's currently in progress and hasn't been aborted, or null.
     */
    var xhrInProgress;

    /**
     * Dispatches the "issue tab loaded" event to the registered listeners.
     *
     * @param container the DOM node that was loaded (may be a tab or the whole document)
     */
    function dispatchIssueTabLoadedEvent(container) {
        container = container || document;
        jQuery.each(issueTabLoadedListeners, function (i, fn) {
            fn(container);
        });
    }

    /**
     * Binds this class's $tabWrapper and $tabContents vars to the loaded tab.
     *
     * @param container the tab
     */
    function bindToTabDivs(container) {
        // these are the DOM elements we'll manipulate

        // JRADEV-17627 - Don't overwrite old elements if the container doesn't contain them.
        //
        // This method is called as a listener to the event JIRA.Events.NEW_CONTENT_ADDED, and that event is fired
        // twice. The first time it is fired when the page is loaded and container == document. The second time is fired
        // with container == some other div. In that second case, the container doesn't contain the elements we are after.
        var $newTabWrapper = jQuery(container).find('.issuePanelWrapper');
        var $newTabContents = jQuery(container).find('#issue_actions_container');
        $tabContents = $newTabContents.length ? $newTabContents : $tabContents;
        $tabWrapper = $newTabWrapper.length ? $newTabWrapper : $tabWrapper;
    }

    /**
     * Dispatches the "issue tab error" event to the registered listeners.
     */
    function dispatchIssueTabErrorEvent(smartAjaxResult, activeTabKey) {
        var errorPopup = new FormDialog({
            id: 'issue-tab-error-dialog',
            widthClass: 'small',
            content: SmartAjax.buildDialogErrorContent(smartAjaxResult, false)
        });

        // restore the previously-active tab before showing the pop-up
        setActiveTab(activeTabKey);
        $tabContents.show();

        errorPopup.show();
    }

    function setActiveTab(activeTabKey) {
        jQuery('#issue-tabs li').each(function() {
            var $li = jQuery(this);

            // activate the right tab
            var tabKey = $li.data('key');
            var tabLabel = $li.data('label');
            if (tabKey == activeTabKey)
            {
                $li.addClass('active');
                $li.html(Templates.label({
                    text: tabLabel
                }));
            }
            else
            {
                $li.removeClass('active');
                var id = $li.data('id');
                var href = $li.data('href');
                $li.html(Templates.tab({
                    id: id,
                    href: href,
                    linkClass: AJAX_LOAD_CLASS,
                    text: tabLabel
                }));
            }
        });

        enableAjaxOnLinks(jQuery('#issue-tabs'));
    }

    /**
     * Puts a tab in the loading state: marks the tab title as active, hides the previous tab's content, and shows a
     * "loading" image.
     */
    function putTabInLoadingState(activeTabKey) {
        setActiveTab(activeTabKey);
    }

    /**
     * Detect if event trigger by keyboard or mouse based on position
     * because we cannot based on event.type (always return "click" inner click handler function
     */

    function isTriggerByKeyBoard(event, $trigger){
        var eventX = event.pageX;
        var eventY = event.pageY;
        var triggerOffset = $trigger.offset();
        var triggerWidth = $trigger.outerWidth();
        var triggerHeight = $trigger.outerHeight();

        if(eventX == 0 && eventY == 0) {
            return true;
        }
        else {
            return ! (eventX >= triggerOffset.left && eventX <= (triggerOffset.left + triggerWidth) && eventY >= triggerOffset.top && eventY <= (triggerOffset.top + triggerHeight));
        }
    }

    /**
     * Make all activitymodule links PJAX-enabled.
     */
    function enableAjaxOnLinks(context) {
        var activeTabKey = jQuery(context).find('li.active').data('key');
        jQuery(context).find(AJAX_LINK_SELECTOR).click(function (event) {
            var $trigger = jQuery(this);

            var isTriggerByKeyboard = isTriggerByKeyBoard(event, $trigger);

            // hide the contents, and activate the other tab
            var loadingTabKey = $trigger.parent().data('key');

            var openInNewWindow = event.metaKey;

            if (loadingTabKey) {
                Analytics.tabClicked($trigger, openInNewWindow, isTriggerByKeyboard);
            } else {
                Analytics.buttonClicked($trigger, openInNewWindow, isTriggerByKeyboard);
            }

            if (openInNewWindow) {
                // allow people to meta-click to open link in a new tab or window
                return;
            }

            event.preventDefault();

            // not all links change tabs - e.g. sort icon
            if (loadingTabKey) {
                putTabInLoadingState(loadingTabKey);
            }


            handleAjaxContentsLoading(activeTabKey, $trigger.attr("href"))
                .done(function($container){
                    if(!isTriggerByKeyboard){
                        //if user trigger action by mouse , we don't get focus
                        return;
                    }
                    //focus into tab or sort action element after update content
                    if(loadingTabKey) {
                        //focus into active tab
                        $container.find("#"+$trigger.attr("id")+" > :first-child").focus();
                    }
                    else {
                        //focus into sort action
                        $container.find(".sortwrap  > :first-child").focus();
                    }
                })
                .done(dispatchIssueTabLoadedEvent);
        });
    }

    /**
     * Loading new content by Ajax and update dom content based on the Ajax'result
     */
    function handleAjaxContentsLoading(activeTabKey, loadingUrl){
        var deferred = jQuery.Deferred();
        // cancel any pending requests
        if (xhrInProgress) {
            xhrInProgress.abort();
        }

        var xhr = SmartAjax.makeRequest({
            jqueryAjaxFn: useHistoryApi ? jQuery.pjax : jQuery.ajax,
            headers: { "X-PJAX": true }, // needed for the ViewIssue action to return only the activity panel
            container: CONTAINER_SELECTOR,
            url: loadingUrl,
            timeout: null,
            complete: function (xhr, status, smartAjaxResult) {
                if (status != 'abort') {
                    xhrInProgress = null;

                    if (!smartAjaxResult.successful)
                    {
                        // don't display error when we're going to redirect anyway
                        if (smartAjaxResult.status < 300 || smartAjaxResult.status >= 400)
                        {
                            dispatchIssueTabErrorEvent(smartAjaxResult, activeTabKey);
                        }

                        return;
                    }

                    var $container = jQuery(this.container);
                    /**
                     * var newElements = AJS.$(smartAjaxResult.data);
                     * Above line of code caused the RangeError: Maximum call stack size exceeds error,
                     * when trying to wrap the huge smartAjaxResult.data.
                     */

                    var newElementsHtml = document.createElement("div");
                    newElementsHtml.innerHTML = smartAjaxResult.data;
                    var newElements = document.createDocumentFragment().appendChild(newElementsHtml);
                    if (!useHistoryApi) {
                        // if not using PJAX then we need to manually write the retrieved content into the page
                        smartUpdate($container, newElements);
                    }

                    JIRA.trace('jira.issue.tab.loaded');

                    deferred.resolve($container);
                }
            }
        });
        jQuery(xhr).throbber({target: $tabWrapper});
        xhrInProgress = xhr;
        return deferred;
    }

    /**
     * Attempts to find tab and content elements in newElements and update the respective elements in the container.
     * If the elements can't be matched up, it simply replaces the contents of container with newElements.
     * @param container
     * @param newElements
     */
    function smartUpdate(container, newElements) {
        var newTabs = newElements.querySelectorAll('.tabwrap');
        var oldTabs = container.find('.tabwrap');
        var newContents = jQuery(newElements.querySelectorAll("#issue_actions_container")).contents();
        var oldContents = $tabContents.contents();
        if (newTabs.length && oldTabs.length && newContents.length && oldContents.length) {
            // Replace the tabs
            oldTabs.replaceWith(newTabs);

            var currentContentHeight = $tabContents.height();
            // If the new content would cause the page to 'jump' due to being shorter than the
            // previous content, animate it smoothly from the edge of the window.
            // Otherwise, simply replace the content.
            $tabContents.append(newContents);
            var newContentHeight = $tabContents.height() - currentContentHeight;
            var visibleHeightDifference = jQuery(window).scrollTop() + jQuery(window).height() - ($tabContents.offset().top + newContentHeight);
            if (visibleHeightDifference > 0) {
                $tabContents.css('height', newContentHeight + visibleHeightDifference);
                oldContents.remove();

                // Delay the animation so the user has time to recognise that it is shrinking due to
                // the extra whitespace.
                var preDelay = 150;
                setTimeout(function() {
                    var pixelsPerSecond = 500;
                    var animSpeed = visibleHeightDifference / pixelsPerSecond * 1000;
                    $tabContents.animate({
                        height: newContentHeight
                    }, animSpeed, 'easeOutQuart', function() {
                        $tabContents.css('height', 'auto');
                    });
                }, preDelay);
            } else {
                $tabContents.empty().append(newContents);
            }

            // jQuery pulls out inline <script> elements from the hierarchy and places them at the top level
            // Execute any such scripts at the end
            jQuery(newElements.querySelectorAll('script')).each(function() {
                jQuery.globalEval(this.text || this.textContent || this.innerHTML || '');
            });
        } else {
            container.empty().append(newElements);
        }
    }

    /**
     * Appends "#issue-tabs" to each activity module link, in order to
     * maintain the legacy behaviour.
     */
    function appendHashCodeToLinks(context) {
        jQuery(context).find(AJAX_LINK_SELECTOR).each(function () {
            var $a = jQuery(this);

            $a.attr('href', $a.attr('href') + '#issue-tabs');
        });
    }

    /**
     * Either appends "#issue-tabs" to each link or PJAXifies them, depending
     * on whether the browser supports the pushState API.
     */
    function processActivityModuleLinks(context) {
        if (!useHistoryApi || jQuery.support.pjax) {
            enableAjaxOnLinks(context);
        } else {
            appendHashCodeToLinks(context);
        }
    }

    function setupMouseoverBehaviour(context) {
        jQuery(context).bind("moveToFinished", function (event, target) {
            jQuery("a.twixi:visible", target).focus();
        });
    }

    function initLivestamp(context) {
        context.find("time.livestamp").livestamp();
    }

    function onTabReady(listener) {
        // Prevent duplicate listeners.
        if (jQuery.inArray(listener, issueTabLoadedListeners) < 0) {
            issueTabLoadedListeners.push(listener);
        }
    }

    // sprinkle AJAX magic all over the tab links after they are loaded
    onTabReady(bindToTabDivs);
    onTabReady(processActivityModuleLinks);
    onTabReady(setupMouseoverBehaviour);
    onTabReady(Userhover);
    onTabReady(initLivestamp);

    /**
     * @borrows onTabReady
     * @borrows dispatchIssueTabLoadedEvent as domReady
     */
    return {
        onTabReady: onTabReady,
        domReady: dispatchIssueTabLoadedEvent
    };
});

AJS.namespace('JIRA.ViewIssueTabs', null, require('jira/viewissue/tabs'));
;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/initViewIssueTabs.js' */
(function () {
    var jQuery =  require('jquery');
    var Events =  require('jira/util/events');
    var Types =  require('jira/util/events/types');
    var Tabs = require('jira/viewissue/tabs');

    jQuery(function () {
        // Remembering focused activity after we refresh panel
        if (Types.PANEL_REFRESHED) {
            // kickass
            Events.bind(Types.PANEL_REFRESHED, function (e, panel, $new, $existing) {
                if (panel === "activitymodule") {
                    var $focusedTab = $existing.find("#issue_actions_container > .issue-data-block.focused");
                    //assume only one focused tab
                    if ($focusedTab.length === 1) {
                        $new.find("#" + $focusedTab.attr("id")).addClass("focused");
                    }
                }
            });
        }
    });

    Events.bind(Types.NEW_CONTENT_ADDED, function(event, $el) {
        Tabs.domReady($el);
    });
})();;
;
/* module-key = 'jira.webresources:viewissue', location = '/includes/jira/viewissue/initViewissue.js' */
require([
    'jira/viewissue/element/shorten',
    'jira/viewissue/element/image-wrap'
], function() {
    // View issue components initialised
});
;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:asynchronous-attachment-expansion', location = 'viewissue/attachment/attachment-contents-view.js' */
/**
 * @module jira/view-issue-plugin/attachment/attachment-contents-view
 * @requires module:jira/view-issue-plugin/lib/marionette
 */
define('jira/view-issue-plugin/attachment/attachment-contents-view', [
    'jira/view-issue-plugin/lib/marionette'
], function defineAttachmentContentsView(Marionette) {
    'use strict';

    return Marionette.ItemView.extend({
        template: JIRA.Templates.ViewIssue.attachmentContents,

        initialize: function initialize(options) {
            this.attachment = options.attachment;
            this.issueId = options.issueId;
            this.baseUrl = options.baseUrl;
        },

        serializeData: function serializeData() {
            return {
                attachment: this.attachment,
                issueId: this.issueId,
                baseUrl: this.baseUrl
            };
        }

    });
});

/**
 * @module jira/attachment/attachment-contents-view
 * @deprecated use {@link module:jira/view-issue-plugin/attachment/attachment-contents-view}
 */
define('jira/attachment/attachment-contents-view', ['jira/view-issue-plugin/attachment/attachment-contents-view'], function(View) { return View; });
;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:asynchronous-attachment-expansion', location = 'viewissue/attachment/attachment-element.js' */
/**
 * @module jira/view-issue-plugin/attachment/attachment-element
 *
 * @requires module:jira/attachment/attachment-contents-view
 * @requires module:jira/viewissue/slideshow/slideshow-configuration
 * @requires module:jira/view-issue-plugin/lib/marionette
 * @requires module:jira/skate
 * @requires external:jQuery
 */
define('jira/view-issue-plugin/attachment/attachment-element', [
    'jquery',
    'jira/skate',
    'jira/viewissue/slideshow/slideshow-configuration',
    'jira/view-issue-plugin/lib/marionette',
    'jira/attachment/attachment-contents-view'
], function($, skate, galleryOpts, Marionette, AttachmentContentsView) {
    'use strict';

    /**
     * @skate js-file-attachment
     */
    return skate('js-file-attachment', {
        type: skate.type.CLASSNAME,
        attached: function elementAttachedHandler(element) {
            $(element).find('.expander').one('expandBlock', function elementExpandedHandler() {
                expandArchive(element);
            });
            JIRA.trace('jira.plugins.viewissue.expansion.wired');
        },
        events: {
            'click .attachment-title': function elementClickedHandler(element, e) {
                if (e.which !== 1) {
                    return;
                }
                var $thumb = element.getThumbnailImage();
                if ($thumb.length) {
                    $thumb.click();
                    e.preventDefault();
                }
            }
        },
        prototype: {
            getThumbnailImage: function() {
                var element = this;
                return $('.gallery', element);
            }
        }
    });

    function expandArchive(element) {
        var $attachmentRow = $(element);
        var attachmentId = $attachmentRow.data('attachment-id');
        var issueId = $attachmentRow.data('issue-id');
        var expansionResource = AJS.contextPath() + "/rest/api/2/attachment/" + attachmentId + "/expand/human";
        var promise = $.get(expansionResource);
        promise.done(function renderAttachmentContents(data) {
            var region = new Marionette.Region({
                el: $attachmentRow.find('.zip-contents').first()
            });
            var view = new AttachmentContentsView({
                attachment: data,
                issueId: issueId,
                baseUrl: window.location.protocol + "//" + window.location.host + AJS.contextPath()
            });
            region.show(view);
        });
        promise.error(function handleAttachmentExpansionError(data) {
            console.error(data);
        });
    }

});
;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:asynchronous-attachment-expansion', location = 'viewissue/attachment/attachment.soy' */
// This file was automatically generated from attachment.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ViewIssue.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ViewIssue == 'undefined') { JIRA.Templates.ViewIssue = {}; }


JIRA.Templates.ViewIssue.attachmentContents = function(opt_data, opt_ignored) {
  var output = '<ol class="archive-expanded">';
  var entries__soy4 = opt_data.attachment.entries;
  var entryList5 = entries__soy4;
  var entryListLen5 = entryList5.length;
  for (var entryIndex5 = 0; entryIndex5 < entryListLen5; entryIndex5++) {
    var entryData5 = entryList5[entryIndex5];
    output += JIRA.Templates.ViewIssue.attachmentArchiveEntry(soy.$$augmentMap(opt_data, {entry: entryData5}));
  }
  output += ((opt_data.attachment.totalEntryCount == 0) ? '<li><div class="aui-message aui-message-warning" style="display: inline-block"><p>' + soy.$$escapeHtml("This archive is either corrupt, empty or not an archive at all") + '.</p></div></li>' : '') + '</ol><span class="zip-contents-trailer">' + ((entries__soy4.length < opt_data.attachment.totalEntryCount) ? '<span class="limit-info">' + soy.$$escapeHtml(AJS.format("Showing {0} of {1} items",entries__soy4.length,opt_data.attachment.totalEntryCount)) + ' </span>' : '');
  var attachmentUrl__soy20 = soy.$$escapeHtml(opt_data.baseUrl) + '/secure/attachment/' + soy.$$escapeHtml(opt_data.attachment.id) + '/';
  output += '<a href="' + soy.$$escapeHtml(attachmentUrl__soy20) + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(opt_data.attachment.mediaType) + ':' + soy.$$escapeHtml(opt_data.attachment.name) + ':' + soy.$$escapeHtml(attachmentUrl__soy20) + '">' + soy.$$escapeHtml("Download Zip") + '</a></span>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.attachmentContents.soyTemplateName = 'JIRA.Templates.ViewIssue.attachmentContents';
}


JIRA.Templates.ViewIssue.attachmentArchiveEntry = function(opt_data, opt_ignored) {
  var output = '';
  var entryUrl__soy37 = soy.$$escapeHtml(opt_data.baseUrl) + '/secure/attachmentzip/unzip/' + soy.$$escapeHtml(opt_data.issueId) + '/' + soy.$$escapeHtml(opt_data.attachment.id) + '%5B' + soy.$$escapeHtml(opt_data.entry.index) + '%5D/';
  var entryDownloadUrl__soy49 = soy.$$filterNoAutoescape(opt_data.entry.mediaType) + ':' + soy.$$filterNoAutoescape(opt_data.entry.path) + ':' + soy.$$filterNoAutoescape(entryUrl__soy37);
  output += '<li class="archive-entry" data-entry-index="' + soy.$$escapeHtml(opt_data.entry.index) + '"><div class="attachment-thumb"><a href="' + soy.$$escapeHtml(entryUrl__soy37) + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(entryDownloadUrl__soy49) + '"' + JIRA.Templates.ViewIssue.tagFilePreview({id: opt_data.attachment.id + '/' + opt_data.entry.index, title: opt_data.entry.label, mimeType: opt_data.entry.mediaType}) + '>' + JIRA.Templates.ViewIssue.renderAttachmentIcon({mimetype: opt_data.entry.mediaType, baseurl: opt_data.baseUrl}) + '</a></div><a class="file-path" href="' + soy.$$escapeHtml(entryUrl__soy37) + '" title="' + soy.$$escapeHtml(opt_data.entry.path) + '" draggable="true" data-downloadurl="' + soy.$$escapeHtml(entryDownloadUrl__soy49) + '"' + JIRA.Templates.ViewIssue.tagFilePreview({id: opt_data.attachment.id + '/' + opt_data.entry.index, title: opt_data.entry.label, mimeType: opt_data.entry.mediaType}) + '>' + soy.$$escapeHtml(opt_data.entry.label) + '</a><span class="attachment-size">' + soy.$$escapeHtml(opt_data.entry.size) + '</span></li>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ViewIssue.attachmentArchiveEntry.soyTemplateName = 'JIRA.Templates.ViewIssue.attachmentArchiveEntry';
}
;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:draggableattachment', location = 'viewissue/initDraggableAttachment.js' */
define('jira/view-issue-plugin/init-draggable-attachment', ['jquery'], function($) {
    $.event.props.push("dataTransfer");

    $('[draggable=true]').live("dragstart", function(evt) {
        var $this = $(this);
        var dataTransfer = evt.dataTransfer;
        dataTransfer.effectAllowed = 'copy';
        dataTransfer.dropEffect = 'copy';
        dataTransfer.setData("DownloadURL", $this.data('downloadurl'));
        if (!$this.find('img').length) {
            dataTransfer.setDragImage($this.closest('li').find('img:visible')[0], 8, 8);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:analytics', location = 'viewissue/analytics.js' */
/**
 * Reports bulk move events to analytics.
 */
define('jira/view-issue-plugin/analytics', ['jquery'], function ($) {
    var $doc = $(document);

    $doc.on('click', '#subtasks-bulk-operation', function () {
        AJS.trigger('analyticsEvent', {name: "jira.bulk.move.click.subtasks-bulk-operation"});
    });
    $doc.on('click', '#subtasks-open-issue-navigator', function () {
        AJS.trigger('analyticsEvent', {name: "jira.bulk.move.click.subtasks-open-issue-navigator"});
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-view-issue-plugin:initialiser', location = 'viewissue/initViewIssue.js' */
require([
    'jira/view-issue-plugin/attachment/attachment-element',
    'jira/view-issue-plugin/init-draggable-attachment',
    'jira/view-issue-plugin/analytics'
]);
;
;
/* module-key = 'com.atlassian.jira.jira-quick-edit-plugin:loading-indicator', location = 'js/util/loading-indicator.js' */
define('quick-edit/util/loading-indicator',[
    'jira/loading/loading',
    'jira/flag'
], function (
    Loading,
    Flag
) {
    var dim = AJS.dim;
    var undim = AJS.undim;

    return {
        showLoadingIndicator: function () {
            dim();
            Loading.showLoadingIndicator();
        },

        hideLoadingIndicator: function (showErrorFlag) {
            undim();
            Loading.hideLoadingIndicator();
            if (showErrorFlag) {
                Flag.showErrorMsg(null, "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.");
            }
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.jira-quick-edit-plugin:quick-edit-issue-bootstrap', location = 'js/init/edit-bootstrap-wrm.js' */
require([
    'jquery',
    'underscore',
    'wrm/require',
    'quick-edit/util/loading-indicator',
    'jira/ajs/keyboardshortcut/keyboard-shortcut-toggle'
], function (
    jQuery,
    _,
    wrmRequire,
    LoadingIndicator,
    KeyboardShortcutToggle
) {
        var showLoadingIndicator = function () {
            KeyboardShortcutToggle.disable();
            LoadingIndicator.showLoadingIndicator();
        };
        var hideLoadingIndicator = function () {
            LoadingIndicator.hideLoadingIndicator(true);
            KeyboardShortcutToggle.enable();
        };

        var dialog;
        var bootstrapFunction = function (event) {
            event.preventDefault();
            showLoadingIndicator();
            var resourceKey = 'wr!com.atlassian.jira.jira-quick-edit-plugin:quick-edit-issue';
            var wrmRequireDeferred = wrmRequire([resourceKey]);
            wrmRequireDeferred.then(function () {
                var initEditDialogFactory = require('quick-edit/init/edit');
                // Creates edit issue dialog
                if (!dialog) {
                    dialog = initEditDialogFactory.initDialog();
                }
                dialog._events.trigger.simpleClick.call(dialog, event, jQuery(event.target));
                KeyboardShortcutToggle.enable();
            }, function onFail() {
                hideLoadingIndicator();
            });
        };

        jQuery(document).delegate('.issueaction-edit-issue', 'click', bootstrapFunction);
});


;
;
/* module-key = 'jira.webresources:attach-screenshot-resources', location = '/includes/jira/issue/attachScreenshot.js' */

AJS.namespace('JIRA.Issue.AttachScreenshot');

(function initializeAttachScreenshot () {
    "use strict";

    AJS.EventQueue = AJS.EventQueue || [];

    // Atlassian Analytics - Capture 'Attach Screenshot' click events for Java Applet
    AJS.$(document).on("click", "#attach-screenshot", function () {
        AJS.EventQueue.push({
            name: "attach.screenshot.display",
            properties: {}
        });
    });
})();;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:hipchat-user-link-support', location = 'user/hipchat-user-link.js' */
AJS.toInit(function ($) {

    var Routes = {
        removeLink: AJS.contextPath() + '/rest/hipchat/integration/latest/oauth2'
    };

    var pluginKey = "com.atlassian.plugins.base-hipchat-integration-plugin";
    var wrmData = WRM.data instanceof Function ? WRM.data : WRM.data.claim;
    var userLinkContext = wrmData(pluginKey + ":hipchat-user-link-support.user-link-context");
    function getRedirect() {
        var location = window.location;
        var contextPath = AJS.contextPath();
        var path = location.pathname;
        if(path.indexOf(contextPath) === 0) {
            path = path.substr(contextPath.length);
        }
        var query = location.search;
        if(query) {
            query = query.substr(1); // remove leading ?
        }
        return {
            path: path,
            query: query
        };
    }

    function doRedirect(hipchatOauthUri) {
        window.location.assign(hipchatOauthUri);
    }

    function getFragmentFrom(container){

        if(container){
            var redirectHash = container.attr("href");
            if(redirectHash !== undefined &&
                    redirectHash.length > 1 &&
                    redirectHash.indexOf("#") === 0){
                return redirectHash.substr(1); // We remove the hash
            }
        }
        return "";
    }

    var centerSpinner = function() {
        var center = $("<div></div>");
        center.css({
            position: "fixed",
            left: "50%",
            top: "50%"
        });
        $("body").append(center);
        center.spin("large");
    };

    /**
     * Starts the user link process.
     *
     * @param e the event if initiated by an event (optional).
     *          Meant to preventing the default behaviour of the event.
     */
    var startUserLink = function (e) {
        var redirect = getRedirect();
        var postData = {
            url: userLinkContext.beginOauth,
            type: "POST",
            dataType: 'json',
            contentType: 'application/json',
            data: JSON.stringify({
                redirect: redirect.path,
                redirectQuery: redirect.query,
                redirectFragment : e && e.target && getFragmentFrom($(e.target))
            })
        };

        $.ajax(postData)
            .done(doRedirect);

        e && e.preventDefault && e.preventDefault();

        centerSpinner();
    };

    $(document).on('click', '.hipchat-user-link', startUserLink);

    var userUnlink = function (e) {
        var deleteData = {
            url: Routes.removeLink,
            type: 'DELETE',
            contentType: 'application/json'
        };
        $.ajax(deleteData)
            .always(function() {
                window.location.reload();
            });
        e && e.preventDefault && e.preventDefault();

        centerSpinner();
    };

    $(document).delegate('.hipchat-user-unlink', 'click', userUnlink);

    // exports
    window.HipChat = window.HipChat || {};
    window.HipChat.UserLink = window.HipChat.UserLink || {};
    window.HipChat.UserLink.context = userLinkContext;
    window.HipChat.UserLink.linkUser = startUserLink;
    window.HipChat.UserLink.unlinkUser = userUnlink;
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:hipchat-links-support', location = 'links/hipchat-links.js' */
/**
 * this script will be used to redirect to the web client
 * or the hipchat client depending on the user preferences.
 * We are going to store this in a cookie to avoid problems if the
 * user changes from computer.
 *
 * hipchat-room-link-url will need api-url, room-id, user-id
 */
(function ($) {

    var HIPCHAT_NATIVE_LINK_ENABLED = "HIPCHAT_NATIVE_LINK_ENABLED";

    function isHipChatNativeLinkEnabled() {
        return AJS.Cookie.read(HIPCHAT_NATIVE_LINK_ENABLED) === "true";
    }

    function getDomainFromUrl(url) {
        var tmp = document.createElement('a');
        tmp.href = url;
        return tmp.hostname;
    }

    function createUrl(baseUrl, path) {
        return baseUrl + (endsWith(baseUrl, "/") ? "" : "/") + path;
    }

    function endsWith(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }

    function sendAnalyticEvent() {
        var linkType = isHipChatNativeLinkEnabled() ? "inapp" : "web";
        var nativeEnabled = navigator.platform.toUpperCase().indexOf('MAC') >= 0 ? "native.enabled" : "native.disabled";
        var metric  = 'notifications.hipchat.link.clicked.' + linkType  + '.' + nativeEnabled;
        AJS.trigger('analyticsEvent', {name: metric});
    }

    function findTheRightElement(element, tagName) {
        var levels = 2;
        while (levels > 0 && element.prop("tagName").toLowerCase() !== tagName.toLowerCase()) {
            element = element.parent();
            levels--;
        }
        return element;
    }

    $(document).on("click", ".hipchat-room-link-url", function (event) {

        event.preventDefault();

        var target = findTheRightElement($(event.target), "A");
        var url = target.data("api-url");
        var roomId = target.data("room-id");

        if (isHipChatNativeLinkEnabled()) {
            window.location = "hipchat://" + getDomainFromUrl(url) + "/room/" + roomId;
        } else {
            window.open(createUrl(url, "chat/room/" + roomId), "hipchat");
        }

        sendAnalyticEvent();
    });


    $(document).on("click", ".hipchat-user-link-url", function (event) {

        event.preventDefault();

        var target = findTheRightElement($(event.target), "A");
        var url = target.data("api-url");
        var userId = target.data("user-id");

        if (isHipChatNativeLinkEnabled()) {
            window.location = "hipchat://" + getDomainFromUrl(url) + "/user/" + userId;
        } else {
            window.open(createUrl(url, "chat/user/" + userId), "hipchat");
        }

        sendAnalyticEvent();
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:almond', location = 'lib/amd/almond-noconflict-pre.js' */
window.__require = window.require;
window.__requirejs = window.requirejs;
window.__define = window.define;
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:almond', location = 'lib/amd/almond.js' */
/**
 * MODIFIED BY ATLASSIAN
 *
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

//    ATLASSIAN PATCH (CQ-102)
//    define.amd = {
//        jQuery: true
//    };
//    END ATLASSIAN PATCH
}());
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:almond', location = 'lib/amd/almond-noconflict-post.js' */
// noConflict
if (window.__require) {
    window.require = window.__require;
    window.requirejs = window.__requirejs;
    window.define = window.__define;
} else {
    // Patch our own version of Almond.
    //
    // If "define.amd" is truthy, some 3rd-party libs (e.g. jQuery, spin.js)
    // automatically register themselves via define(). We don't want that,
    // we'll take care of calling define() for each lib.
    delete window.define.amd;
}

// IE8 doesn't support delete window.?
try { delete window.__require; } catch (e) { window.__require = undefined; }
try { delete window.__requirejs; } catch (e) { window.__requirejs = undefined; }
try { delete window.__define; } catch (e) { window.__define = undefined; }
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:almond', location = 'lib/amd/ajs-amd.js' */
define("ajs", function () {
    return AJS;
});;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:wrm-amd', location = 'lib/amd/wrm-amd.js' */
define("wrm", function () {

    if (WRM.data instanceof Function) {
        // WRM.data.claim does not exist in 5.3
        WRM.data.claim = WRM.data;
    }

    return WRM;
});;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:backbone-amd', location = 'lib/amd/backbone-amd.js' */
define("backbone", function () {
    return Backbone;
});;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:jquery-amd', location = 'lib/amd/jquery-amd.js' */
define('jquery', function () {
    return AJS.$;
});;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin-api:underscore-amd', location = 'lib/amd/underscore-amd.js' */
define('underscore', function () {
    return _;
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:configure-integration-data', location = 'admin/configure-integration-data.js' */
define('hipchat/admin/configure-integration-data', [
    'jquery'
], function (
    $
) {
    var pluginKey = "com.atlassian.plugins.base-hipchat-integration-plugin";
    var resourceKey = "configure-integration-data";
    var providerKey = "configure-integration";
    var wrmData = WRM.data instanceof Function ? WRM.data : WRM.data.claim;
    var context = wrmData(pluginKey + ":" + resourceKey + "." + providerKey);
    return context;
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:connection-status-resources', location = 'feature/connectionstatus/connectionstatus.soy' */
// This file was automatically generated from connectionstatus.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace HipChat.Templates.Configuration.ConnectionStatus.
 */

if (typeof HipChat == 'undefined') { var HipChat = {}; }
if (typeof HipChat.Templates == 'undefined') { HipChat.Templates = {}; }
if (typeof HipChat.Templates.Configuration == 'undefined') { HipChat.Templates.Configuration = {}; }
if (typeof HipChat.Templates.Configuration.ConnectionStatus == 'undefined') { HipChat.Templates.Configuration.ConnectionStatus = {}; }


HipChat.Templates.Configuration.ConnectionStatus.status = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<h6 class="hipchat-connection-status-container">' + ((opt_data.label) ? soy.$$escapeHtml(opt_data.label) : soy.$$escapeHtml("Connection status")) + '<span class="hipchat-connection-status"></span></h6>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.status.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.status';
}


HipChat.Templates.Configuration.ConnectionStatus.lozenge = function(opt_data, opt_ignored) {
  return '<' + soy.$$escapeHtml(opt_data.tagName ? opt_data.tagName : 'span') + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ((opt_data.title) ? ' title="' + soy.$$escapeHtml(opt_data.title) + '"' : '') + ' class="aui-lozenge' + soy.$$escapeHtml(opt_data.type ? ' aui-lozenge-' + opt_data.type : '') + soy.$$escapeHtml(opt_data.isSubtle ? ' aui-lozenge-subtle' : '') + '">' + ((opt_data.maxLength) ? soy.$$truncate(soy.$$escapeHtml(opt_data.text), opt_data.maxLength, true) : soy.$$escapeHtml(opt_data.text)) + '</' + soy.$$escapeHtml(opt_data.tagName ? opt_data.tagName : 'span') + '>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.lozenge.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.lozenge';
}


HipChat.Templates.Configuration.ConnectionStatus.connectedStatus = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.ConnectionStatus.lozenge({text: "Connected", type: 'success', isSubtle: true, extraClasses: opt_data.extraClasses});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.connectedStatus.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.connectedStatus';
}


HipChat.Templates.Configuration.ConnectionStatus.partialConnectivityStatus = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.ConnectionStatus.lozenge({text: "Limited", type: 'current', isSubtle: true, extraClasses: opt_data.extraClasses});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.partialConnectivityStatus.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.partialConnectivityStatus';
}


HipChat.Templates.Configuration.ConnectionStatus.unknownStatus = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.ConnectionStatus.lozenge({text: "Unknown", type: '', isSubtle: true, extraClasses: opt_data.extraClasses});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.unknownStatus.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.unknownStatus';
}


HipChat.Templates.Configuration.ConnectionStatus.notConnectedStatus = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.ConnectionStatus.lozenge({text: "Not connected", type: 'error', isSubtle: true, extraClasses: opt_data.extraClasses});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.notConnectedStatus.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.notConnectedStatus';
}


HipChat.Templates.Configuration.ConnectionStatus.oauthFailureStatus = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.ConnectionStatus.lozenge({text: "Oauth Failure", type: 'error', isSubtle: true, extraClasses: opt_data.extraClasses});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.oauthFailureStatus.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.oauthFailureStatus';
}


HipChat.Templates.Configuration.ConnectionStatus.connectivityTooltip = function(opt_data, opt_ignored) {
  return '<div class="hipchat-connection-status-tooltip"><h6>' + soy.$$escapeHtml(opt_data.title) + '</h6><p>' + soy.$$filterNoAutoescape(opt_data.description) + '</p>' + ((opt_data.link) ? '<p><a href="' + soy.$$escapeHtml(opt_data.link.href) + '">' + soy.$$escapeHtml(opt_data.link.text) + '</a></p>' : '') + '</div>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.ConnectionStatus.connectivityTooltip.soyTemplateName = 'HipChat.Templates.Configuration.ConnectionStatus.connectivityTooltip';
}
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:connection-status-resources', location = 'feature/connectionstatus/connectionstatus.js' */
require([
    "jquery"
], function (
    $
) {
    var connectionStatusTemplateMap = {
        "CONNECTED": "connectedStatus",
        "PARTIAL_CONNECTIVITY": "partialConnectivityStatus",
        "NOT_CONNECTED": "notConnectedStatus",
        "UNKNOWN": "unknownStatus",
        "OAUTH_FAILURE": "oauthFailureStatus"
    };

    var connectionStatusViews = {
        "CONNECTED": {
            status: HipChat.Templates.Configuration.ConnectionStatus.connectedStatus
        },
        "PARTIALLY_CONNECTED": {
            status: HipChat.Templates.Configuration.ConnectionStatus.partialConnectivityStatus,
            toolTipTitle: "Connectivity issues",
            toolTipDescription: "HipChat cannot connect to your JIRA server - it may be behind a firewall. \u003cbr\u003e You can still receive messages from JIRA in HipChat, but some functionality (such as Issue Preview) may not work."
        },
        "NO_CONNECTION": {
            status: HipChat.Templates.Configuration.ConnectionStatus.notConnectedStatus,
            toolTipTitle: "Connectivity issues",
            toolTipDescription: "Could not connect to the HipChat server. Integration features will be unavailable until the connection is restored."
        },
        "UNKNOWN": {
            status: HipChat.Templates.Configuration.ConnectionStatus.unknownStatus,
            toolTipTitle: "\u00af\\_(\u30c4)_/\u00af",
            toolTipDescription: "We cannot determine the connection status. You\'re probably using an old version of HipChat."
        },
        "OAUTH_FAILURE": {
            status: HipChat.Templates.Configuration.ConnectionStatus.oauthFailureStatus,
            toolTipTitle: "Error authenticating with HipChat",
            toolTipDescription: "The integration may have been removed from HipChat. Please remove and reinstall the integration in JIRA."
        }
    };

    function getViewDataForStatus(data) {
        var view = connectionStatusViews[data];
        if (view === undefined) {
            view = connectionStatusTemplateMap.UNKNOWN;
        }

        return view;
    }

    function getConnectionStatusHtml(data) {
        var view = getViewDataForStatus(data);

        return view.status({extraClasses: view.toolTipDescription !== undefined ? "has-tooltip" : ""});
    }

    function getConnectionStatus() {
        return $.ajax({
            url: AJS.contextPath() + "/rest/hipchat/integration/1.0/connection-status",
            cache: false,
            dataType: 'json',
            type: "GET"
        });
    }

    function initConnectionStatusTooltip($connectionStatus, data) {
        var viewData = getViewDataForStatus(data);
        if (viewData.toolTipDescription !== undefined) {
            AJS.InlineDialog($connectionStatus, "connection-status-tooltip", function (content, trigger, showPopup) {

                var html = HipChat.Templates.Configuration.ConnectionStatus.connectivityTooltip({
                    title: viewData.toolTipTitle,
                    description: viewData.toolTipDescription,
                    link: viewData.toolTipLink
                });
                content.html(html);

                showPopup();
            }, {
                onHover: true,
                gravity: 'w'
            });
        }
    }

    function updateConnectionStatus(status) {
        var $connectionStatus = $(".hipchat-connection-status");
        $connectionStatus.html(getConnectionStatusHtml(status));
        initConnectionStatusTooltip($connectionStatus, status);
    }

    AJS.toInit(function($) {
        var $connectionStatus = $(".hipchat-connection-status");
        if ($connectionStatus.length > 0) {
            $connectionStatus.spin();
            getConnectionStatus().done(function(status) {
                updateConnectionStatus(status);
            }).fail(function() {
                updateConnectionStatus("UNKNOWN");
            }).always(function() {
                $connectionStatus.spinStop();
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:integration-steps-resources', location = 'feature/invites/invite-hipchat-enabler.js' */
define('hipchat/invite/enabler', [
    'jquery'
], function (
    $
) {

    var INVITE_VISITED_KEY = "hipchat-invite-visited";
    var enableInviteData = null;
    var discoveryDisabled = false;

    function enableInviteButtonIfFreePlan() {
        if (!enableInviteData) {
            var pluginKey = "com.atlassian.plugins.base-hipchat-integration-plugin";
            var wrmData = WRM.data instanceof Function ? WRM.data : WRM.data.claim;
            enableInviteData = wrmData(pluginKey + ":integration-steps-resources.enable-invite");
        }
        if (!enableInviteData.inviteToHipChatEnabled) {
            return;
        }
        var isInvitationsToGroupAllowedURI = enableInviteData.isInvitationsToGroupAllowedURI;
        $.ajax(isInvitationsToGroupAllowedURI, {
            type: "GET"
        })
            .done(function (isInvitationsToGroupAllowedURI) {
                var inviteButton = $('#hipchat-invite-button');
                inviteButton.click(handleInvitePageVisit);

                if (isInvitationsToGroupAllowedURI && isInvitationsToGroupAllowedURI.free) {
                    inviteButton.removeClass("hidden");
                    conditionallyShowInviteDiscovery(inviteButton);
                } else {
                    $("#hipchat-integration-invite-step-normal-text").hide({
                        complete: function() {
                            $("#hipchat-integration-invite-step-unable-text").show();
                        }
                    });
                }
            });
    }

    function handleInvitePageVisit() {
        try {
            AJS.Cookie.save(INVITE_VISITED_KEY, "true");
        } catch (e) {
            discoveryDisabled = true;
        }
    }

    function hasVistedInvitePage() {
        try {
            var visited = AJS.Cookie.read(INVITE_VISITED_KEY);
            return visited;
        } catch (e) {
            discoveryDisabled = true;
        }
    }

    function conditionallyShowInviteDiscovery(inviteButton) {
        if (AJS.HelpTip && !hasVistedInvitePage() && !discoveryDisabled) {
            var inviteUsersHelpTip = new AJS.HelpTip({
                id: 'hipchat-invite-user-help',
                title: 'Invite users to HipChat',
                bodyHtml: "If you would like to invite users in the future, click here.",
                anchor: inviteButton
            });
            inviteUsersHelpTip.show();
            inviteUsersHelpTip.view.popup.addClass('hipchat-invite-user-help');
        }
    }

    return {
        enableInviteButtonIfFreePlan: enableInviteButtonIfFreePlan
    }
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:integration-steps-resources', location = 'feature/integrationsteps/integrationsteps.js' */
require([
    'hipchat/invite/enabler'
], function (
    hipchatInviteEnabler
) {
    AJS.toInit(function($) {
        var $steps = $(".hipchat-integration-steps");

        $steps.on('mapping-added.integration-steps', function () {
            $steps.addClass("complete");
            hipchatInviteEnabler.enableInviteButtonIfFreePlan();
        });

        var inviteButtonWaitingForMapping = $('#inviteButtonWaitingForMapping').val();
        if (inviteButtonWaitingForMapping === 'false') {
            hipchatInviteEnabler.enableInviteButtonIfFreePlan();
        }
    });
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:invites-soy-resources', location = 'feature/invites/invite-hipchat-client.soy' */
// This file was automatically generated from invite-hipchat-client.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace HipChat.Templates.Configuration.
 */

if (typeof HipChat == 'undefined') { var HipChat = {}; }
if (typeof HipChat.Templates == 'undefined') { HipChat.Templates = {}; }
if (typeof HipChat.Templates.Configuration == 'undefined') { HipChat.Templates.Configuration = {}; }


HipChat.Templates.Configuration.inviteeList = function(opt_data, opt_ignored) {
  return '<ul class="hipchat-invitee-list"></ul>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.inviteeList.soyTemplateName = 'HipChat.Templates.Configuration.inviteeList';
}


HipChat.Templates.Configuration.invitee = function(opt_data, opt_ignored) {
  var output = '';
  var userUrl__soy5 = '' + HipChat.Templates.Invite.Support.userLinkUrl(opt_data);
  output += '<li class="hipchat-invitee" data-username="' + soy.$$escapeHtml(opt_data.username) + '"><img class="hipchat-invitee-avatar" src="' + soy.$$escapeHtml(opt_data.avatarUrl) + '"><div class="lines"><div class="line hipchat-invitee-name-container" title="' + soy.$$escapeHtml(opt_data.fullname) + '"><a href="' + soy.$$escapeHtml(userUrl__soy5) + '" class="hipchat-invitee-name invitee-line-1" target="_blank">' + soy.$$escapeHtml(opt_data.fullname) + '</a></div><div class="line"><span data-invite-processing="running" class="aui-lozenge aui-lozenge-current aui-lozenge-subtle hidden">' + soy.$$escapeHtml("inviting...") + '</span>' + ((opt_data.email) ? '<div class="email-container" title="' + soy.$$escapeHtml(opt_data.email) + '"><span class="email">' + soy.$$escapeHtml(opt_data.emailDomain) + '</span></div>' : '<span>&nbsp;</span>') + '<span class="aui-lozenge aui-lozenge-current aui-lozenge-subtle" style="display:none"></span><span class="aui-lozenge aui-lozenge-success aui-lozenge-subtle" style="display:none"></span></div></div><div class="icon-holder"><button class="remove-invite-button aui-button aui-button-link">' + aui.icons.icon({useIconFont: true, icon: 'remove'}) + '</button></div><div class="status-icon-holder"><span class="aui-icon aui-icon-small aui-iconfont-approve success"> </span><span class="aui-icon aui-icon-small aui-iconfont-error failure"> </span></div></li>';
  return output;
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.invitee.soyTemplateName = 'HipChat.Templates.Configuration.invitee';
}
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:resources', location = 'admin/configure-hipchat.js' */
require([
        'hipchat/admin/configure-integration-data'
    ],

    function (integrationData) {
        'use strict';

        AJS.toInit(function ($) {
            "use strict";

            /**
             * Hipchat configuration state
             * @type {String} The current configuration state of hipchat
             */
            var state = $("#hipchat-integration-configuration").val();

            var localStorage = window.localStorage;

            // If the state element is not present, do not load the rest as this is
            //   the wrong page
            if (state) {

                /**
                 * Routes used in directing requests/redirects
                 */
                var routes = {
                    self: $("#hipchat-route-config").val(),
                    serverPing: $("#hipchat-route-check-server-connectivity").val(),
                    clientPing: $("#hipchat-route-check-client-connectivity").val(),
                    beginInstall: $("#hipchat-route-begin-install").val(),
                    completeInstall: $("#hipchat-route-complete-install").val(),
                    installableUrl:  $("#hipchat-route-installable-url").val(),
                    uninstall: $("#hipchat-route-uninstall").val(),
                    redirectUrl: $("#hipchat-route-redirectUrl").val()
                };

                /**
                 * Resource urls
                 */
                var resources = {
                    screenshotResource: $("#hipchat-server-resource-screenshot").val(),
                    screenshotResource2x: $("#hipchat-server-resource-screenshot-2x").val(),
                    uninstalling: $("#hipchat-server-resource-uninstalling").val()
                };

                /**
                 * Misc other values/imports
                 */
                var Templates = HipChat.Templates.Configuration;
                var panel = $("#hipchat-configuration-panel");
                if (integrationData.link) {
                    var linkId = integrationData.link.id;
                }

                /**
                 * All views for this page
                 */
                var Views = (function () {
                    var confirmDialog;

                    return {
                        /**
                         * Load configure template
                         */
                        installing: function () {
                            $('#hipchat-installing .hipchat-install-message').spin('large');
                        },
                        /**
                         * Load error template
                         * @param msg {String} Error message to display
                         */
                        error: function (msg) {
                            panel.html(Templates.error({msg: msg}));
                        },
                        /**
                         * Load uninstall error template
                         */
                        uninstallError: function (msg) {
                            if (msg.status == 401) {
                                panel.html(Templates.uninstallPermissionError());
                            } else {
                                panel.html(Templates.uninstallConnectionError());
                            }
                        },
                        /**
                         * Confirms removal of the link to HipChat
                         *
                         * @return promise resolved if the user confirms removed, rejected if they cancel
                         */
                        confirmUninstall: function () {
                            var deferred = $.Deferred();

                            if (!confirmDialog) {
                                // TODO CONFDEV-28519 ADG 2 - new confirmation dialog (and remove related CSS)
                                confirmDialog = new AJS.Dialog(600, 300, "hipchat-remove-link-dialog");
                                confirmDialog.addHeader("Remove integration", "remove-warning");
                                confirmDialog.addPanel("Message Panel", Templates.removeLinkMessage());
                                confirmDialog.addButton("Remove integration", function () {
                                    confirmDialog.hide();
                                    Views.uninstall();
                                    deferred.resolve();
                                });
                                confirmDialog.addCancel("Cancel", function () {
                                    confirmDialog.hide();
                                    deferred.reject();
                                });
                            }
                            confirmDialog.show();

                            return deferred.promise();
                        },
                        uninstall: function () {
                            panel.html(Templates.uninstalling({
                                uninstallingImage: resources.uninstalling
                            }));
                            $('#hipchat-uninstalling .hipchat-install-message').spin('large');
                        },
                        reinstallationSucceeded: function () {
                            try {
                                var flag = require('aui/flag');
                                flag({
                                    type: "success",
                                    title: "HipChat Integration updated",
                                    persistent: false,
                                    body: "Your HipChat Integration has been successfully updated to the latest version, enjoy the new features."
                                });
                            } catch (e) {
                                // AUI flag is not available, do not bother.
                            }
                        }
                    };
                })();

                /**
                 * Remote APIs service
                 */
                var Remote = {
                    /**
                     * Begin a server request to ping the hipchat server
                     *  to ensure server is visible
                     * @returns {*}
                     */
                    serverPing: function () {
                        return $.ajax(routes.serverPing, {
                            type: "GET"
                        });
                    },

                    /**
                     * Server ping with a specific url
                     * @param url
                     * @returns {*}
                     */
                    serverPingToUrl: function (url) {
                        var paramDelimiter = (routes.serverPing.indexOf("?") < 0) ? "?" : "&";
                        return $.ajax(routes.serverPing + paramDelimiter + "url=" + encodeURIComponent(url), {
                            type: "GET"
                        });
                    },

                    /**
                     * Request information to begin installing a hipchat
                     *  plugin. This request also sets a cookie which is
                     *  used for XSRF protection
                     * @returns {*}
                     */
                    beginInstall: function (url, reinstall) {
                        return $.ajax(routes.beginInstall, {
                            type: "POST",
                            dataType: 'json',
                            contentType: 'application/json',
                            data: JSON.stringify({
                                installableUrl: url,
                                reinstall: reinstall
                            })
                        })
                    },
                    /**
                     * Submit the installation completion data to the server
                     * @param url
                     * @returns {*}
                     */
                    completeInstall: function (url) {
                        return $.ajax(routes.completeInstall, {
                            type: "POST",
                            dataType: 'json',
                            contentType: 'application/json',
                            data: JSON.stringify({
                                installableUrl: url
                            })
                        })
                    },
                    /**
                     * Remove link with the given id
                     * @param linkId
                     * @returns {*}
                     */
                    remove: function (linkId) {
                        return $.ajax({
                            url: routes.uninstall + "/" + linkId,
                            type: "POST",
                            dataType: 'json',
                            contentType: 'application/json',
                            data: JSON.stringify({})
                        })
                    },

                    reinstall: function (linkId) {
                        return $.ajax({
                            url: routes.uninstall + "/" + linkId,
                            type: "POST",
                            dataType: 'json',
                            contentType: 'application/json',
                            data: JSON.stringify({
                                reinstall: true
                            })
                        })
                    },

                    removeDefault: function () {
                        return $.ajax(routes.uninstall, {
                            type: "POST",
                            dataType: 'json',
                            contentType: 'application/json',
                            data: JSON.stringify({})
                        })
                    }
                };

                /**
                 * Code related to the various actions on this page
                 */
                var Actions = {
                    /**
                     * Setup the initial state of the screen
                     * @param state
                     */
                    initialize: function (state) {
                        switch (state) {
                            case "installing":
                                Actions.installing();
                                break;

                            case "installed":
                                Actions.installed(linkId);
                                break;

                            case "uninstalling":
                                Actions.uninstalling();
                                break;

                            case "reinstall":
                                Actions.reinstalling();
                                break;

                            case "configure":
                            default:
                                Actions.configure();
                        }
                    },

                    /**
                     * Utility function to redirect the client's browser (current url is not in history)
                     * @param url
                     */
                    redirect: function (url) {
                        window.location.replace(url);
                    },

                    /**
                     * Utility function to redirect the client's browser while keeping the current url in the browser history.
                     */
                    navigate: function (url) {
                        window.location.assign(url);
                    },

                    /**
                     * Load the configuration screen
                     *
                     * Trigger a server ping, if successful request
                     *  installation information and redirect to hipchat
                     *  plugin installation.
                     */
                    configure: function () {
                        Remote.serverPing()
                            .done(function () {
                                $("#hipchat-install").removeAttr("disabled");
                            })
                            .fail(function () {
                                $("#hipchat-server-failure").removeClass("hidden");
                            })
                            .always(function () {
                                $("#hipchat-loading").hide();
                            });

                        $("#hipchat-install").click(function (e) {
                            e.preventDefault();
                            if ($(this).attr('aria-disabled')) {
                                return;
                            }
                            $(this).attr('aria-disabled', 'true');

                            AJS.trigger('analyticsEvent', {
                                name: 'notifications.hipchat.server.registration.started',
                                data: {}
                            });

                            Remote.beginInstall(undefined, false)
                                .done(Actions.navigate);
                        });

                        $('#enable-btf-install').click(function (e) {
                            e.preventDefault();
                            window.onbeforeunload = null; // Prevent "Are you sure you want to navigate away" dialog to appear

                            enableHipChatBTF();
                        });

                        //Fire analytics event
                        AJS.trigger('analyticsEvent', {
                            name: 'notifications.hipchat.server.discovered',
                            data: {}
                        });

                        /**
                         * We enable the page to set a url
                         */
                        function enableHipChatBTF() {
                            $('.hipchat-install-form').toggleClass("hipchat-btf");
                            $('#btf-url').focus();
                            $('#btf-install').click(function (j) {
                                $("#btf-error").hide();
                                j.preventDefault();
                                var url = $('#btf-url').val();
                                var regex = /^https?:\/\//i;

                                // If the user did not put anything we put https on the url
                                if (!regex.test(url)) {
                                    url = 'https://' + url;
                                }

                                Remote.serverPingToUrl(url)
                                    .done(function () {
                                        Remote.beginInstall(url, false).done(Actions.navigate)
                                    })
                                    .fail(function () {
                                        $("#btf-error").show();
                                    });
                            });
                        }

                        $('#btf-install-cancel').click(function (e) {
                            e.preventDefault();
                            $('.hipchat-install-form').toggleClass("hipchat-btf");
                        });
                    },

                    /**
                     * Load the installing screen
                     *
                     * Posts the installation information to the server.
                     *
                     * Done using javascript as this lets the process be sort
                     *  of async, and the user gets some feedback on slow connections
                     *  instead of just seeing a white screen.
                     */
                    installing: function () {
                        Views.installing();
                        Remote.completeInstall(routes.installableUrl)
                            .done(function (data) {
                                Actions.redirect(routes.self);
                            }).error(Views.error)
                    },

                    /**
                     * Load the installed screen
                     */
                    installed: function () {
                        $("#hipchat-uninstall").click(function (e) {
                            e.preventDefault();
                            if ($(this).attr('aria-disabled')) {
                                return;
                            }
                            Views.confirmUninstall().done(function () {
                                Remote.remove(linkId).done(Actions.redirect).error(Views.uninstallError);
                            });

                        });

                        $(".hipchat-reinstall").click(function () {
                            if ($(this).attr('aria-disabled')) {
                                return;
                            }

                            var $el = $(this);
                            $el.attr('aria-disabled', true);
                            $el.find(".aui-icon-wait").css("display", "inline-block");

                            Remote.reinstall(linkId).done(Actions.redirect).error(Views.uninstallError);
                        });

                        if (localStorage.getItem("hipchat-reinstalling")) {
                            Views.reinstallationSucceeded();
                            localStorage.removeItem("hipchat-reinstalling");
                        }
                    },

                    uninstalling: function () {
                        Remote.removeDefault().done(function () {
                            Actions.redirect(routes.redirectUrl)
                        }).error(Views.uninstallError)
                    },

                    reinstalling: function () {
                        function getURLParameter(sParam) {
                            var sPageURL = window.location.search.substring(1);
                            var sURLVariables = sPageURL.split('&');
                            for (var i = 0; i < sURLVariables.length; i++)
                            {
                                var sParameterName = sURLVariables[i].split('=');
                                if (sParameterName[0] == sParam)
                                {
                                    if (sParameterName.length > 1) {
                                        return sParameterName[1];
                                    } else {
                                        return null;
                                    }
                                }
                            }
                        }
                        var paramValue = getURLParameter("installable_url");
                        if (paramValue === undefined) {
                            console.log("ERROR: the 'installable_url' parameter was missing from the request URL:'" + window.location.search + "'");
                        } else {
                            var url = decodeURIComponent(paramValue);
                            var a = document.createElement('a');
                            a.href = url;
                            var hipchatUrl = a.protocol + "//" + a.host;
                            Remote.serverPingToUrl(hipchatUrl)
                                    .done(function () {
                                        localStorage.setItem("hipchat-reinstalling", true);
                                        Remote.beginInstall(hipchatUrl, true).done(Actions.navigate)
                                    })
                                    .fail(function () {
                                        $("#btf-error").show();
                                    });
                        }
                    }

                };

                Actions.initialize(state);
            }
        }
    )

});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:resources', location = 'admin/configure-hipchat.soy' */
// This file was automatically generated from configure-hipchat.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace HipChat.Templates.Configuration.
 */

if (typeof HipChat == 'undefined') { var HipChat = {}; }
if (typeof HipChat.Templates == 'undefined') { HipChat.Templates = {}; }
if (typeof HipChat.Templates.Configuration == 'undefined') { HipChat.Templates.Configuration = {}; }


HipChat.Templates.Configuration.installing = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.connected({id: 'hipchat-installing', installHeading: "Integrating with HipChat", installImage: opt_data.installingImage, showRemove: false});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.installing.soyTemplateName = 'HipChat.Templates.Configuration.installing';
}


HipChat.Templates.Configuration.uninstalling = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.connected({id: 'hipchat-uninstalling', installHeading: "Removing HipChat Integration", installImage: opt_data.uninstallingImage, showRemove: false});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.uninstalling.soyTemplateName = 'HipChat.Templates.Configuration.uninstalling';
}


HipChat.Templates.Configuration.connected = function(opt_data, opt_ignored) {
  return '<div id="' + soy.$$escapeHtml(opt_data.id) + '">' + ((opt_data.showRemove) ? HipChat.Templates.Configuration.uninstallButton(null) : '') + ((opt_data.installImage) ? '<img src="' + soy.$$escapeHtml(opt_data.installImage) + '" />' : '') + ((opt_data.installHeading) ? '<h5>' + soy.$$escapeHtml(opt_data.installHeading) + '</h5>' : '') + '<hr/><div class="hipchat-install-message">' + ((opt_data.installMessageHtml) ? '<p>' + soy.$$filterNoAutoescape(opt_data.installMessageHtml) + '</p>' : '') + '</div></div>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.connected.soyTemplateName = 'HipChat.Templates.Configuration.connected';
}


HipChat.Templates.Configuration.error = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.message({type: 'error', title: "Error encountered creating your hipchat link", content: soy.$$escapeHtml("Something went wrong integrating JIRA and HipChat. We probably had trouble connecting to the HipChat server. Check that the connection between your server and HipChat is working correctly and try again.") + '<p>' + soy.$$escapeHtml("Try uninstalling the existing integration from HipChat before trying again.") + '</p>'});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.error.soyTemplateName = 'HipChat.Templates.Configuration.error';
}


HipChat.Templates.Configuration.uninstallConnectionError = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.message({type: 'error', title: "Error encountered removing your hipchat link", content: '' + soy.$$escapeHtml("Something went wrong removing the integration in HipChat. We probably had trouble connecting to the HipChat server. You may need to remove the integration from HipChat\'s admin page. The link has been removed from JIRA.")});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.uninstallConnectionError.soyTemplateName = 'HipChat.Templates.Configuration.uninstallConnectionError';
}


HipChat.Templates.Configuration.uninstallPermissionError = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.message({type: 'error', title: "Error encountered removing your hipchat link", content: '' + soy.$$escapeHtml("You do not have permission to remove this integration, please contact your site admin if you wish to remove the HipChat integration.")});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.uninstallPermissionError.soyTemplateName = 'HipChat.Templates.Configuration.uninstallPermissionError';
}


HipChat.Templates.Configuration.refreshToken = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.message({type: 'error', title: 'Setting up your HipChat link', content: '' + soy.$$escapeHtml("Error encountered creating your hipchat link")});
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.refreshToken.soyTemplateName = 'HipChat.Templates.Configuration.refreshToken';
}


HipChat.Templates.Configuration.message = function(opt_data, opt_ignored) {
  return '<div class="aui-message ' + soy.$$escapeHtml(opt_data.type) + ' ' + ((opt_data.altClass) ? soy.$$escapeHtml(opt_data.altClass) : '') + '"><p class="title"><span class="aui-icon icon-' + soy.$$escapeHtml(opt_data.type) + '"></span><strong>' + soy.$$escapeHtml(opt_data.title) + '</strong></p>' + ((opt_data.content) ? '<p>' + soy.$$filterNoAutoescape(opt_data.content) + '</p>' : '') + '</div>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.message.soyTemplateName = 'HipChat.Templates.Configuration.message';
}


HipChat.Templates.Configuration.removeLinkMessage = function(opt_data, opt_ignored) {
  return '<div class=\'remove-link-message\'>' + soy.$$filterNoAutoescape("\u003cp>Are you sure you want to completely remove your HipChat integration?\u003c\/p>\u003cp>The JIRA plugin will not be removed from HipChat.\u003c\/p>") + '</div>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.removeLinkMessage.soyTemplateName = 'HipChat.Templates.Configuration.removeLinkMessage';
}


HipChat.Templates.Configuration.installButton = function(opt_data, opt_ignored) {
  return '<div class="hipchat-install-form"><button class="aui-button aui-button-primary" type="submit" id="hipchat-install" disabled="disabled">' + soy.$$escapeHtml("Connect HipChat") + '</button><div id="hipchat-loading"><span class="aui-icon aui-icon-wait"></span> ' + soy.$$escapeHtml("Checking your server can see HipChat") + '</div><div id="hipchat-server-failure" class="hidden"><p><span class="aui-icon aui-icon-small aui-iconfont-warning hipchat-failure-marker"></span> ' + soy.$$escapeHtml("Unable to reach HipChat") + '</p><p class="details">' + soy.$$escapeHtml("If JIRA does not have access to the internet you won\'t be able to integrate with HipChat.") + '</p></div><div><button class="cancel aui-link aui-button aui-button-link" id="enable-btf-install">' + soy.$$escapeHtml("Or, if you\x27re using HipChat Server, click here.") + '</button>' + HipChat.Templates.Configuration.btfInstall(null) + '</div></div>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.installButton.soyTemplateName = 'HipChat.Templates.Configuration.installButton';
}


HipChat.Templates.Configuration.btfInstall = function(opt_data, opt_ignored) {
  return '<form class="aui top-label" id="hipchat-btf-install"><fieldset class="top-label"><div class="field-group top-label"><label for="hipchat-btf-url" style="text-align:center">' + soy.$$escapeHtml("First things first, let us know where we can find your HipChat Server:") + '</label><input class="text long-field" type="text" id="btf-url" name="btf-url" data-aui-notification-field="" placeholder="http://www.hipchat.com"></input><div class="error" id="btf-error">' + soy.$$escapeHtml("We couldn\x27t reach your server") + '</div></div></fieldset><div class="buttons-container"><button class="aui-button aui-button-primary" type="submit" id="btf-install">' + soy.$$escapeHtml("Connect HipChat") + '</button><a class="cancel" href="#" id="btf-install-cancel">Cancel</a></div></form>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.btfInstall.soyTemplateName = 'HipChat.Templates.Configuration.btfInstall';
}


HipChat.Templates.Configuration.uninstallButton = function(opt_data, opt_ignored) {
  return '<button class="aui-button aui-button-subtle" id="hipchat-uninstall"><span class="aui-icon aui-icon-small aui-iconfont-delete">Configure</span> ' + soy.$$escapeHtml("Remove integration") + '</button>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.uninstallButton.soyTemplateName = 'HipChat.Templates.Configuration.uninstallButton';
}


HipChat.Templates.Configuration.inviteButton = function(opt_data, opt_ignored) {
  return '<input type="hidden" id="inviteButtonWaitingForMapping" value="' + soy.$$escapeHtml(opt_data.inviteButtonWaitingForMapping) + '"/><a class="aui-button aui-button-subtle hidden" id="hipchat-invite-button" href="' + soy.$$escapeHtml(opt_data.adminInviteUrl) + '"><span class="aui-icon aui-icon-small aui-iconfont-space-personal">Invite</span> ' + soy.$$escapeHtml("Invite users to HipChat") + '</a>';
};
if (goog.DEBUG) {
  HipChat.Templates.Configuration.inviteButton.soyTemplateName = 'HipChat.Templates.Configuration.inviteButton';
}
;
;
/* module-key = 'com.atlassian.auiplugin:aui-select2', location = 'js-vendor/jquery/plugins/jquery.select2.js' */
/*
 Copyright 2012 Igor Vaynberg

 Version: 3.4.5 Timestamp: Mon Nov  4 08:22:42 PST 2013

 This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
 General Public License version 2 (the "GPL License"). You may choose either license to govern your
 use of this software only upon the condition that you accept all of the terms of either the Apache
 License or the GPL License.

 You may obtain a copy of the Apache License and the GPL License at:

 http://www.apache.org/licenses/LICENSE-2.0
 http://www.gnu.org/licenses/gpl-2.0.html

 Unless required by applicable law or agreed to in writing, software distributed under the
 Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
 the specific language governing permissions and limitations under the Apache License and the GPL License.
 */
(function ($) {
    if(typeof $.fn.each2 == "undefined") {
        $.extend($.fn, {
            /*
             * 4-10 times faster .each replacement
             * use it carefully, as it overrides jQuery context of element on each iteration
             */
            each2 : function (c) {
                var j = $([0]), i = -1, l = this.length;
                while (
                    ++i < l
                        && (j.context = j[0] = this[i])
                        && c.call(j[0], i, j) !== false //"this"=DOM, i=index, j=jQuery object
                    );
                return this;
            }
        });
    }
})(jQuery);

(function ($, undefined) {
    "use strict";
    /*global document, window, jQuery, console */

    if (window.Select2 !== undefined) {
        return;
    }

    var KEY, AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
        lastMousePosition={x:0,y:0}, $document, scrollBarDimensions,

        KEY = {
            TAB: 9,
            ENTER: 13,
            ESC: 27,
            SPACE: 32,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            HOME: 36,
            END: 35,
            BACKSPACE: 8,
            DELETE: 46,
            isArrow: function (k) {
                k = k.which ? k.which : k;
                switch (k) {
                    case KEY.LEFT:
                    case KEY.RIGHT:
                    case KEY.UP:
                    case KEY.DOWN:
                        return true;
                }
                return false;
            },
            isControl: function (e) {
                var k = e.which;
                switch (k) {
                    case KEY.SHIFT:
                    case KEY.CTRL:
                    case KEY.ALT:
                        return true;
                }

                if (e.metaKey) return true;

                return false;
            },
            isFunctionKey: function (k) {
                k = k.which ? k.which : k;
                return k >= 112 && k <= 123;
            }
        },
        MEASURE_SCROLLBAR_TEMPLATE = "<div class='select2-measure-scrollbar'></div>",

        DIACRITICS = {"\u24B6":"A","\uFF21":"A","\u00C0":"A","\u00C1":"A","\u00C2":"A","\u1EA6":"A","\u1EA4":"A","\u1EAA":"A","\u1EA8":"A","\u00C3":"A","\u0100":"A","\u0102":"A","\u1EB0":"A","\u1EAE":"A","\u1EB4":"A","\u1EB2":"A","\u0226":"A","\u01E0":"A","\u00C4":"A","\u01DE":"A","\u1EA2":"A","\u00C5":"A","\u01FA":"A","\u01CD":"A","\u0200":"A","\u0202":"A","\u1EA0":"A","\u1EAC":"A","\u1EB6":"A","\u1E00":"A","\u0104":"A","\u023A":"A","\u2C6F":"A","\uA732":"AA","\u00C6":"AE","\u01FC":"AE","\u01E2":"AE","\uA734":"AO","\uA736":"AU","\uA738":"AV","\uA73A":"AV","\uA73C":"AY","\u24B7":"B","\uFF22":"B","\u1E02":"B","\u1E04":"B","\u1E06":"B","\u0243":"B","\u0182":"B","\u0181":"B","\u24B8":"C","\uFF23":"C","\u0106":"C","\u0108":"C","\u010A":"C","\u010C":"C","\u00C7":"C","\u1E08":"C","\u0187":"C","\u023B":"C","\uA73E":"C","\u24B9":"D","\uFF24":"D","\u1E0A":"D","\u010E":"D","\u1E0C":"D","\u1E10":"D","\u1E12":"D","\u1E0E":"D","\u0110":"D","\u018B":"D","\u018A":"D","\u0189":"D","\uA779":"D","\u01F1":"DZ","\u01C4":"DZ","\u01F2":"Dz","\u01C5":"Dz","\u24BA":"E","\uFF25":"E","\u00C8":"E","\u00C9":"E","\u00CA":"E","\u1EC0":"E","\u1EBE":"E","\u1EC4":"E","\u1EC2":"E","\u1EBC":"E","\u0112":"E","\u1E14":"E","\u1E16":"E","\u0114":"E","\u0116":"E","\u00CB":"E","\u1EBA":"E","\u011A":"E","\u0204":"E","\u0206":"E","\u1EB8":"E","\u1EC6":"E","\u0228":"E","\u1E1C":"E","\u0118":"E","\u1E18":"E","\u1E1A":"E","\u0190":"E","\u018E":"E","\u24BB":"F","\uFF26":"F","\u1E1E":"F","\u0191":"F","\uA77B":"F","\u24BC":"G","\uFF27":"G","\u01F4":"G","\u011C":"G","\u1E20":"G","\u011E":"G","\u0120":"G","\u01E6":"G","\u0122":"G","\u01E4":"G","\u0193":"G","\uA7A0":"G","\uA77D":"G","\uA77E":"G","\u24BD":"H","\uFF28":"H","\u0124":"H","\u1E22":"H","\u1E26":"H","\u021E":"H","\u1E24":"H","\u1E28":"H","\u1E2A":"H","\u0126":"H","\u2C67":"H","\u2C75":"H","\uA78D":"H","\u24BE":"I","\uFF29":"I","\u00CC":"I","\u00CD":"I","\u00CE":"I","\u0128":"I","\u012A":"I","\u012C":"I","\u0130":"I","\u00CF":"I","\u1E2E":"I","\u1EC8":"I","\u01CF":"I","\u0208":"I","\u020A":"I","\u1ECA":"I","\u012E":"I","\u1E2C":"I","\u0197":"I","\u24BF":"J","\uFF2A":"J","\u0134":"J","\u0248":"J","\u24C0":"K","\uFF2B":"K","\u1E30":"K","\u01E8":"K","\u1E32":"K","\u0136":"K","\u1E34":"K","\u0198":"K","\u2C69":"K","\uA740":"K","\uA742":"K","\uA744":"K","\uA7A2":"K","\u24C1":"L","\uFF2C":"L","\u013F":"L","\u0139":"L","\u013D":"L","\u1E36":"L","\u1E38":"L","\u013B":"L","\u1E3C":"L","\u1E3A":"L","\u0141":"L","\u023D":"L","\u2C62":"L","\u2C60":"L","\uA748":"L","\uA746":"L","\uA780":"L","\u01C7":"LJ","\u01C8":"Lj","\u24C2":"M","\uFF2D":"M","\u1E3E":"M","\u1E40":"M","\u1E42":"M","\u2C6E":"M","\u019C":"M","\u24C3":"N","\uFF2E":"N","\u01F8":"N","\u0143":"N","\u00D1":"N","\u1E44":"N","\u0147":"N","\u1E46":"N","\u0145":"N","\u1E4A":"N","\u1E48":"N","\u0220":"N","\u019D":"N","\uA790":"N","\uA7A4":"N","\u01CA":"NJ","\u01CB":"Nj","\u24C4":"O","\uFF2F":"O","\u00D2":"O","\u00D3":"O","\u00D4":"O","\u1ED2":"O","\u1ED0":"O","\u1ED6":"O","\u1ED4":"O","\u00D5":"O","\u1E4C":"O","\u022C":"O","\u1E4E":"O","\u014C":"O","\u1E50":"O","\u1E52":"O","\u014E":"O","\u022E":"O","\u0230":"O","\u00D6":"O","\u022A":"O","\u1ECE":"O","\u0150":"O","\u01D1":"O","\u020C":"O","\u020E":"O","\u01A0":"O","\u1EDC":"O","\u1EDA":"O","\u1EE0":"O","\u1EDE":"O","\u1EE2":"O","\u1ECC":"O","\u1ED8":"O","\u01EA":"O","\u01EC":"O","\u00D8":"O","\u01FE":"O","\u0186":"O","\u019F":"O","\uA74A":"O","\uA74C":"O","\u01A2":"OI","\uA74E":"OO","\u0222":"OU","\u24C5":"P","\uFF30":"P","\u1E54":"P","\u1E56":"P","\u01A4":"P","\u2C63":"P","\uA750":"P","\uA752":"P","\uA754":"P","\u24C6":"Q","\uFF31":"Q","\uA756":"Q","\uA758":"Q","\u024A":"Q","\u24C7":"R","\uFF32":"R","\u0154":"R","\u1E58":"R","\u0158":"R","\u0210":"R","\u0212":"R","\u1E5A":"R","\u1E5C":"R","\u0156":"R","\u1E5E":"R","\u024C":"R","\u2C64":"R","\uA75A":"R","\uA7A6":"R","\uA782":"R","\u24C8":"S","\uFF33":"S","\u1E9E":"S","\u015A":"S","\u1E64":"S","\u015C":"S","\u1E60":"S","\u0160":"S","\u1E66":"S","\u1E62":"S","\u1E68":"S","\u0218":"S","\u015E":"S","\u2C7E":"S","\uA7A8":"S","\uA784":"S","\u24C9":"T","\uFF34":"T","\u1E6A":"T","\u0164":"T","\u1E6C":"T","\u021A":"T","\u0162":"T","\u1E70":"T","\u1E6E":"T","\u0166":"T","\u01AC":"T","\u01AE":"T","\u023E":"T","\uA786":"T","\uA728":"TZ","\u24CA":"U","\uFF35":"U","\u00D9":"U","\u00DA":"U","\u00DB":"U","\u0168":"U","\u1E78":"U","\u016A":"U","\u1E7A":"U","\u016C":"U","\u00DC":"U","\u01DB":"U","\u01D7":"U","\u01D5":"U","\u01D9":"U","\u1EE6":"U","\u016E":"U","\u0170":"U","\u01D3":"U","\u0214":"U","\u0216":"U","\u01AF":"U","\u1EEA":"U","\u1EE8":"U","\u1EEE":"U","\u1EEC":"U","\u1EF0":"U","\u1EE4":"U","\u1E72":"U","\u0172":"U","\u1E76":"U","\u1E74":"U","\u0244":"U","\u24CB":"V","\uFF36":"V","\u1E7C":"V","\u1E7E":"V","\u01B2":"V","\uA75E":"V","\u0245":"V","\uA760":"VY","\u24CC":"W","\uFF37":"W","\u1E80":"W","\u1E82":"W","\u0174":"W","\u1E86":"W","\u1E84":"W","\u1E88":"W","\u2C72":"W","\u24CD":"X","\uFF38":"X","\u1E8A":"X","\u1E8C":"X","\u24CE":"Y","\uFF39":"Y","\u1EF2":"Y","\u00DD":"Y","\u0176":"Y","\u1EF8":"Y","\u0232":"Y","\u1E8E":"Y","\u0178":"Y","\u1EF6":"Y","\u1EF4":"Y","\u01B3":"Y","\u024E":"Y","\u1EFE":"Y","\u24CF":"Z","\uFF3A":"Z","\u0179":"Z","\u1E90":"Z","\u017B":"Z","\u017D":"Z","\u1E92":"Z","\u1E94":"Z","\u01B5":"Z","\u0224":"Z","\u2C7F":"Z","\u2C6B":"Z","\uA762":"Z","\u24D0":"a","\uFF41":"a","\u1E9A":"a","\u00E0":"a","\u00E1":"a","\u00E2":"a","\u1EA7":"a","\u1EA5":"a","\u1EAB":"a","\u1EA9":"a","\u00E3":"a","\u0101":"a","\u0103":"a","\u1EB1":"a","\u1EAF":"a","\u1EB5":"a","\u1EB3":"a","\u0227":"a","\u01E1":"a","\u00E4":"a","\u01DF":"a","\u1EA3":"a","\u00E5":"a","\u01FB":"a","\u01CE":"a","\u0201":"a","\u0203":"a","\u1EA1":"a","\u1EAD":"a","\u1EB7":"a","\u1E01":"a","\u0105":"a","\u2C65":"a","\u0250":"a","\uA733":"aa","\u00E6":"ae","\u01FD":"ae","\u01E3":"ae","\uA735":"ao","\uA737":"au","\uA739":"av","\uA73B":"av","\uA73D":"ay","\u24D1":"b","\uFF42":"b","\u1E03":"b","\u1E05":"b","\u1E07":"b","\u0180":"b","\u0183":"b","\u0253":"b","\u24D2":"c","\uFF43":"c","\u0107":"c","\u0109":"c","\u010B":"c","\u010D":"c","\u00E7":"c","\u1E09":"c","\u0188":"c","\u023C":"c","\uA73F":"c","\u2184":"c","\u24D3":"d","\uFF44":"d","\u1E0B":"d","\u010F":"d","\u1E0D":"d","\u1E11":"d","\u1E13":"d","\u1E0F":"d","\u0111":"d","\u018C":"d","\u0256":"d","\u0257":"d","\uA77A":"d","\u01F3":"dz","\u01C6":"dz","\u24D4":"e","\uFF45":"e","\u00E8":"e","\u00E9":"e","\u00EA":"e","\u1EC1":"e","\u1EBF":"e","\u1EC5":"e","\u1EC3":"e","\u1EBD":"e","\u0113":"e","\u1E15":"e","\u1E17":"e","\u0115":"e","\u0117":"e","\u00EB":"e","\u1EBB":"e","\u011B":"e","\u0205":"e","\u0207":"e","\u1EB9":"e","\u1EC7":"e","\u0229":"e","\u1E1D":"e","\u0119":"e","\u1E19":"e","\u1E1B":"e","\u0247":"e","\u025B":"e","\u01DD":"e","\u24D5":"f","\uFF46":"f","\u1E1F":"f","\u0192":"f","\uA77C":"f","\u24D6":"g","\uFF47":"g","\u01F5":"g","\u011D":"g","\u1E21":"g","\u011F":"g","\u0121":"g","\u01E7":"g","\u0123":"g","\u01E5":"g","\u0260":"g","\uA7A1":"g","\u1D79":"g","\uA77F":"g","\u24D7":"h","\uFF48":"h","\u0125":"h","\u1E23":"h","\u1E27":"h","\u021F":"h","\u1E25":"h","\u1E29":"h","\u1E2B":"h","\u1E96":"h","\u0127":"h","\u2C68":"h","\u2C76":"h","\u0265":"h","\u0195":"hv","\u24D8":"i","\uFF49":"i","\u00EC":"i","\u00ED":"i","\u00EE":"i","\u0129":"i","\u012B":"i","\u012D":"i","\u00EF":"i","\u1E2F":"i","\u1EC9":"i","\u01D0":"i","\u0209":"i","\u020B":"i","\u1ECB":"i","\u012F":"i","\u1E2D":"i","\u0268":"i","\u0131":"i","\u24D9":"j","\uFF4A":"j","\u0135":"j","\u01F0":"j","\u0249":"j","\u24DA":"k","\uFF4B":"k","\u1E31":"k","\u01E9":"k","\u1E33":"k","\u0137":"k","\u1E35":"k","\u0199":"k","\u2C6A":"k","\uA741":"k","\uA743":"k","\uA745":"k","\uA7A3":"k","\u24DB":"l","\uFF4C":"l","\u0140":"l","\u013A":"l","\u013E":"l","\u1E37":"l","\u1E39":"l","\u013C":"l","\u1E3D":"l","\u1E3B":"l","\u017F":"l","\u0142":"l","\u019A":"l","\u026B":"l","\u2C61":"l","\uA749":"l","\uA781":"l","\uA747":"l","\u01C9":"lj","\u24DC":"m","\uFF4D":"m","\u1E3F":"m","\u1E41":"m","\u1E43":"m","\u0271":"m","\u026F":"m","\u24DD":"n","\uFF4E":"n","\u01F9":"n","\u0144":"n","\u00F1":"n","\u1E45":"n","\u0148":"n","\u1E47":"n","\u0146":"n","\u1E4B":"n","\u1E49":"n","\u019E":"n","\u0272":"n","\u0149":"n","\uA791":"n","\uA7A5":"n","\u01CC":"nj","\u24DE":"o","\uFF4F":"o","\u00F2":"o","\u00F3":"o","\u00F4":"o","\u1ED3":"o","\u1ED1":"o","\u1ED7":"o","\u1ED5":"o","\u00F5":"o","\u1E4D":"o","\u022D":"o","\u1E4F":"o","\u014D":"o","\u1E51":"o","\u1E53":"o","\u014F":"o","\u022F":"o","\u0231":"o","\u00F6":"o","\u022B":"o","\u1ECF":"o","\u0151":"o","\u01D2":"o","\u020D":"o","\u020F":"o","\u01A1":"o","\u1EDD":"o","\u1EDB":"o","\u1EE1":"o","\u1EDF":"o","\u1EE3":"o","\u1ECD":"o","\u1ED9":"o","\u01EB":"o","\u01ED":"o","\u00F8":"o","\u01FF":"o","\u0254":"o","\uA74B":"o","\uA74D":"o","\u0275":"o","\u01A3":"oi","\u0223":"ou","\uA74F":"oo","\u24DF":"p","\uFF50":"p","\u1E55":"p","\u1E57":"p","\u01A5":"p","\u1D7D":"p","\uA751":"p","\uA753":"p","\uA755":"p","\u24E0":"q","\uFF51":"q","\u024B":"q","\uA757":"q","\uA759":"q","\u24E1":"r","\uFF52":"r","\u0155":"r","\u1E59":"r","\u0159":"r","\u0211":"r","\u0213":"r","\u1E5B":"r","\u1E5D":"r","\u0157":"r","\u1E5F":"r","\u024D":"r","\u027D":"r","\uA75B":"r","\uA7A7":"r","\uA783":"r","\u24E2":"s","\uFF53":"s","\u00DF":"s","\u015B":"s","\u1E65":"s","\u015D":"s","\u1E61":"s","\u0161":"s","\u1E67":"s","\u1E63":"s","\u1E69":"s","\u0219":"s","\u015F":"s","\u023F":"s","\uA7A9":"s","\uA785":"s","\u1E9B":"s","\u24E3":"t","\uFF54":"t","\u1E6B":"t","\u1E97":"t","\u0165":"t","\u1E6D":"t","\u021B":"t","\u0163":"t","\u1E71":"t","\u1E6F":"t","\u0167":"t","\u01AD":"t","\u0288":"t","\u2C66":"t","\uA787":"t","\uA729":"tz","\u24E4":"u","\uFF55":"u","\u00F9":"u","\u00FA":"u","\u00FB":"u","\u0169":"u","\u1E79":"u","\u016B":"u","\u1E7B":"u","\u016D":"u","\u00FC":"u","\u01DC":"u","\u01D8":"u","\u01D6":"u","\u01DA":"u","\u1EE7":"u","\u016F":"u","\u0171":"u","\u01D4":"u","\u0215":"u","\u0217":"u","\u01B0":"u","\u1EEB":"u","\u1EE9":"u","\u1EEF":"u","\u1EED":"u","\u1EF1":"u","\u1EE5":"u","\u1E73":"u","\u0173":"u","\u1E77":"u","\u1E75":"u","\u0289":"u","\u24E5":"v","\uFF56":"v","\u1E7D":"v","\u1E7F":"v","\u028B":"v","\uA75F":"v","\u028C":"v","\uA761":"vy","\u24E6":"w","\uFF57":"w","\u1E81":"w","\u1E83":"w","\u0175":"w","\u1E87":"w","\u1E85":"w","\u1E98":"w","\u1E89":"w","\u2C73":"w","\u24E7":"x","\uFF58":"x","\u1E8B":"x","\u1E8D":"x","\u24E8":"y","\uFF59":"y","\u1EF3":"y","\u00FD":"y","\u0177":"y","\u1EF9":"y","\u0233":"y","\u1E8F":"y","\u00FF":"y","\u1EF7":"y","\u1E99":"y","\u1EF5":"y","\u01B4":"y","\u024F":"y","\u1EFF":"y","\u24E9":"z","\uFF5A":"z","\u017A":"z","\u1E91":"z","\u017C":"z","\u017E":"z","\u1E93":"z","\u1E95":"z","\u01B6":"z","\u0225":"z","\u0240":"z","\u2C6C":"z","\uA763":"z"};

    $document = $(document);

    nextUid=(function() { var counter=1; return function() { return counter++; }; }());


    function stripDiacritics(str) {
        var ret, i, l, c;

        if (!str || str.length < 1) return str;

        ret = "";
        for (i = 0, l = str.length; i < l; i++) {
            c = str.charAt(i);
            ret += DIACRITICS[c] || c;
        }
        return ret;
    }

    function indexOf(value, array) {
        var i = 0, l = array.length;
        for (; i < l; i = i + 1) {
            if (equal(value, array[i])) return i;
        }
        return -1;
    }

    function measureScrollbar () {
        var $template = $( MEASURE_SCROLLBAR_TEMPLATE );
        $template.appendTo('body');

        var dim = {
            width: $template.width() - $template[0].clientWidth,
            height: $template.height() - $template[0].clientHeight
        };
        $template.remove();

        return dim;
    }

    /**
     * Compares equality of a and b
     * @param a
     * @param b
     */
    function equal(a, b) {
        if (a === b) return true;
        if (a === undefined || b === undefined) return false;
        if (a === null || b === null) return false;
        // Check whether 'a' or 'b' is a string (primitive or object).
        // The concatenation of an empty string (+'') converts its argument to a string's primitive.
        if (a.constructor === String) return a+'' === b+''; // a+'' - in case 'a' is a String object
        if (b.constructor === String) return b+'' === a+''; // b+'' - in case 'b' is a String object
        return false;
    }

    /**
     * Splits the string into an array of values, trimming each value. An empty array is returned for nulls or empty
     * strings
     * @param string
     * @param separator
     */
    function splitVal(string, separator) {
        var val, i, l;
        if (string === null || string.length < 1) return [];
        val = string.split(separator);
        for (i = 0, l = val.length; i < l; i = i + 1) val[i] = $.trim(val[i]);
        return val;
    }

    function getSideBorderPadding(element) {
        return element.outerWidth(false) - element.width();
    }

    function installKeyUpChangeEvent(element) {
        var key="keyup-change-value";
        element.on("keydown", function () {
            if ($.data(element, key) === undefined) {
                $.data(element, key, element.val());
            }
        });
        element.on("keyup", function () {
            var val= $.data(element, key);
            if (val !== undefined && element.val() !== val) {
                $.removeData(element, key);
                element.trigger("keyup-change");
            }
        });
    }

    $document.on("mousemove", function (e) {
        lastMousePosition.x = e.pageX;
        lastMousePosition.y = e.pageY;
    });

    /**
     * filters mouse events so an event is fired only if the mouse moved.
     *
     * filters out mouse events that occur when mouse is stationary but
     * the elements under the pointer are scrolled.
     */
    function installFilteredMouseMove(element) {
        element.on("mousemove", function (e) {
            var lastpos = lastMousePosition;
            if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
                $(e.target).trigger("mousemove-filtered", e);
            }
        });
    }

    /**
     * Debounces a function. Returns a function that calls the original fn function only if no invocations have been made
     * within the last quietMillis milliseconds.
     *
     * @param quietMillis number of milliseconds to wait before invoking fn
     * @param fn function to be debounced
     * @param ctx object to be used as this reference within fn
     * @return debounced version of fn
     */
    function debounce(quietMillis, fn, ctx) {
        ctx = ctx || undefined;
        var timeout;
        return function () {
            var args = arguments;
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function() {
                fn.apply(ctx, args);
            }, quietMillis);
        };
    }

    /**
     * A simple implementation of a thunk
     * @param formula function used to lazily initialize the thunk
     * @return {Function}
     */
    function thunk(formula) {
        var evaluated = false,
            value;
        return function() {
            if (evaluated === false) { value = formula(); evaluated = true; }
            return value;
        };
    };

    function installDebouncedScroll(threshold, element) {
        var notify = debounce(threshold, function (e) { element.trigger("scroll-debounced", e);});
        element.on("scroll", function (e) {
            if (indexOf(e.target, element.get()) >= 0) notify(e);
        });
    }

    function focus($el) {
        if ($el[0] === document.activeElement) return;

        /* set the focus in a 0 timeout - that way the focus is set after the processing
         of the current event has finished - which seems like the only reliable way
         to set focus */
        window.setTimeout(function() {
            var el=$el[0], pos=$el.val().length, range;

            $el.focus();

            /* make sure el received focus so we do not error out when trying to manipulate the caret.
             sometimes modals or others listeners may steal it after its set */
            if ($el.is(":visible") && el === document.activeElement) {

                /* after the focus is set move the caret to the end, necessary when we val()
                 just before setting focus */
                if(el.setSelectionRange)
                {
                    el.setSelectionRange(pos, pos);
                }
                else if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                }
            }
        }, 0);
    }

    function getCursorInfo(el) {
        el = $(el)[0];
        var offset = 0;
        var length = 0;
        if ('selectionStart' in el) {
            offset = el.selectionStart;
            length = el.selectionEnd - offset;
        } else if ('selection' in document) {
            el.focus();
            var sel = document.selection.createRange();
            length = document.selection.createRange().text.length;
            sel.moveStart('character', -el.value.length);
            offset = sel.text.length - length;
        }
        return { offset: offset, length: length };
    }

    function killEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    function killEventImmediately(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    function measureTextWidth(e) {
        if (!sizer){
            var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
            sizer = $(document.createElement("div")).css({
                position: "absolute",
                left: "-10000px",
                top: "-10000px",
                display: "none",
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                fontStyle: style.fontStyle,
                fontWeight: style.fontWeight,
                letterSpacing: style.letterSpacing,
                textTransform: style.textTransform,
                whiteSpace: "nowrap"
            });
            sizer.attr("class","select2-sizer");
            $("body").append(sizer);
        }
        sizer.text(e.val());
        return sizer.width();
    }

    function syncCssClasses(dest, src, adapter) {
        var classes, replacements = [], adapted;

        classes = dest.attr("class");
        if (classes) {
            classes = '' + classes; // for IE which returns object
            $(classes.split(" ")).each2(function() {
                if (this.indexOf("select2-") === 0) {
                    replacements.push(this);
                }
            });
        }
        classes = src.attr("class");
        if (classes) {
            classes = '' + classes; // for IE which returns object
            $(classes.split(" ")).each2(function() {
                if (this.indexOf("select2-") !== 0) {
                    adapted = adapter(this);
                    if (adapted) {
                        replacements.push(adapted);
                    }
                }
            });
        }
        dest.attr("class", replacements.join(" "));
    }


    function markMatch(text, term, markup, escapeMarkup) {
        var match=stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())),
            tl=term.length;

        if (match<0) {
            markup.push(escapeMarkup(text));
            return;
        }

        markup.push(escapeMarkup(text.substring(0, match)));
        markup.push("<span class='select2-match'>");
        markup.push(escapeMarkup(text.substring(match, match + tl)));
        markup.push("</span>");
        markup.push(escapeMarkup(text.substring(match + tl, text.length)));
    }

    function defaultEscapeMarkup(markup) {
        var replace_map = {
            '\\': '&#92;',
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            "/": '&#47;'
        };

        return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
            return replace_map[match];
        });
    }

    /**
     * Produces an ajax-based query function
     *
     * @param options object containing configuration paramters
     * @param options.params parameter map for the transport ajax call, can contain such options as cache, jsonpCallback, etc. see $.ajax
     * @param options.transport function that will be used to execute the ajax request. must be compatible with parameters supported by $.ajax
     * @param options.url url for the data
     * @param options.data a function(searchTerm, pageNumber, context) that should return an object containing query string parameters for the above url.
     * @param options.dataType request data type: ajax, jsonp, other datatatypes supported by jQuery's $.ajax function or the transport function if specified
     * @param options.quietMillis (optional) milliseconds to wait before making the ajaxRequest, helps debounce the ajax function if invoked too often
     * @param options.results a function(remoteData, pageNumber) that converts data returned form the remote request to the format expected by Select2.
     *      The expected format is an object containing the following keys:
     *      results array of objects that will be used as choices
     *      more (optional) boolean indicating whether there are more results available
     *      Example: {results:[{id:1, text:'Red'},{id:2, text:'Blue'}], more:true}
     */
    function ajax(options) {
        var timeout, // current scheduled but not yet executed request
            handler = null,
            quietMillis = options.quietMillis || 100,
            ajaxUrl = options.url,
            self = this;

        return function (query) {
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                var data = options.data, // ajax data function
                    url = ajaxUrl, // ajax url string or function
                    transport = options.transport || $.fn.select2.ajaxDefaults.transport,
                // deprecated - to be removed in 4.0  - use params instead
                    deprecated = {
                        type: options.type || 'GET', // set type of request (GET or POST)
                        cache: options.cache || false,
                        jsonpCallback: options.jsonpCallback||undefined,
                        dataType: options.dataType||"json"
                    },
                    params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);

                data = data ? data.call(self, query.term, query.page, query.context) : null;
                url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;

                if (handler) { handler.abort(); }

                if (options.params) {
                    if ($.isFunction(options.params)) {
                        $.extend(params, options.params.call(self));
                    } else {
                        $.extend(params, options.params);
                    }
                }

                $.extend(params, {
                    url: url,
                    dataType: options.dataType,
                    data: data,
                    success: function (data) {
                        // TODO - replace query.page with query so users have access to term, page, etc.
                        var results = options.results(data, query.page);
                        query.callback(results);
                    }
                });
                handler = transport.call(self, params);
            }, quietMillis);
        };
    }

    /**
     * Produces a query function that works with a local array
     *
     * @param options object containing configuration parameters. The options parameter can either be an array or an
     * object.
     *
     * If the array form is used it is assumed that it contains objects with 'id' and 'text' keys.
     *
     * If the object form is used ti is assumed that it contains 'data' and 'text' keys. The 'data' key should contain
     * an array of objects that will be used as choices. These objects must contain at least an 'id' key. The 'text'
     * key can either be a String in which case it is expected that each element in the 'data' array has a key with the
     * value of 'text' which will be used to match choices. Alternatively, text can be a function(item) that can extract
     * the text.
     */
    function local(options) {
        var data = options, // data elements
            dataText,
            tmp,
            text = function (item) { return ""+item.text; }; // function used to retrieve the text portion of a data item that is matched against the search

        if ($.isArray(data)) {
            tmp = data;
            data = { results: tmp };
        }

        if ($.isFunction(data) === false) {
            tmp = data;
            data = function() { return tmp; };
        }

        var dataItem = data();
        if (dataItem.text) {
            text = dataItem.text;
            // if text is not a function we assume it to be a key name
            if (!$.isFunction(text)) {
                dataText = dataItem.text; // we need to store this in a separate variable because in the next step data gets reset and data.text is no longer available
                text = function (item) { return item[dataText]; };
            }
        }

        return function (query) {
            var t = query.term, filtered = { results: [] }, process;
            if (t === "") {
                query.callback(data());
                return;
            }

            process = function(datum, collection) {
                var group, attr;
                datum = datum[0];
                if (datum.children) {
                    group = {};
                    for (attr in datum) {
                        if (datum.hasOwnProperty(attr)) group[attr]=datum[attr];
                    }
                    group.children=[];
                    $(datum.children).each2(function(i, childDatum) { process(childDatum, group.children); });
                    if (group.children.length || query.matcher(t, text(group), datum)) {
                        collection.push(group);
                    }
                } else {
                    if (query.matcher(t, text(datum), datum)) {
                        collection.push(datum);
                    }
                }
            };

            $(data().results).each2(function(i, datum) { process(datum, filtered.results); });
            query.callback(filtered);
        };
    }

    // TODO javadoc
    function tags(data) {
        var isFunc = $.isFunction(data);
        return function (query) {
            var t = query.term, filtered = {results: []};
            $(isFunc ? data() : data).each(function () {
                var isObject = this.text !== undefined,
                    text = isObject ? this.text : this;
                if (t === "" || query.matcher(t, text)) {
                    filtered.results.push(isObject ? this : {id: this, text: this});
                }
            });
            query.callback(filtered);
        };
    }

    /**
     * Checks if the formatter function should be used.
     *
     * Throws an error if it is not a function. Returns true if it should be used,
     * false if no formatting should be performed.
     *
     * @param formatter
     */
    function checkFormatter(formatter, formatterName) {
        if ($.isFunction(formatter)) return true;
        if (!formatter) return false;
        throw new Error(formatterName +" must be a function or a falsy value");
    }

    function evaluate(val) {
        return $.isFunction(val) ? val() : val;
    }

    function countResults(results) {
        var count = 0;
        $.each(results, function(i, item) {
            if (item.children) {
                count += countResults(item.children);
            } else {
                count++;
            }
        });
        return count;
    }

    /**
     * Default tokenizer. This function uses breaks the input on substring match of any string from the
     * opts.tokenSeparators array and uses opts.createSearchChoice to create the choice object. Both of those
     * two options have to be defined in order for the tokenizer to work.
     *
     * @param input text user has typed so far or pasted into the search field
     * @param selection currently selected choices
     * @param selectCallback function(choice) callback tho add the choice to selection
     * @param opts select2's opts
     * @return undefined/null to leave the current input unchanged, or a string to change the input to the returned value
     */
    function defaultTokenizer(input, selection, selectCallback, opts) {
        var original = input, // store the original so we can compare and know if we need to tell the search to update its text
            dupe = false, // check for whether a token we extracted represents a duplicate selected choice
            token, // token
            index, // position at which the separator was found
            i, l, // looping variables
            separator; // the matched separator

        if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) return undefined;

        while (true) {
            index = -1;

            for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
                separator = opts.tokenSeparators[i];
                index = input.indexOf(separator);
                if (index >= 0) break;
            }

            if (index < 0) break; // did not find any token separator in the input string, bail

            token = input.substring(0, index);
            input = input.substring(index + separator.length);

            if (token.length > 0) {
                token = opts.createSearchChoice.call(this, token, selection);
                if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
                    dupe = false;
                    for (i = 0, l = selection.length; i < l; i++) {
                        if (equal(opts.id(token), opts.id(selection[i]))) {
                            dupe = true; break;
                        }
                    }

                    if (!dupe) selectCallback(token);
                }
            }
        }

        if (original!==input) return input;
    }

    /**
     * Creates a new class
     *
     * @param superClass
     * @param methods
     */
    function clazz(SuperClass, methods) {
        var constructor = function () {};
        constructor.prototype = new SuperClass;
        constructor.prototype.constructor = constructor;
        constructor.prototype.parent = SuperClass.prototype;
        constructor.prototype = $.extend(constructor.prototype, methods);
        return constructor;
    }

    AbstractSelect2 = clazz(Object, {

        // abstract
        bind: function (func) {
            var self = this;
            return function () {
                func.apply(self, arguments);
            };
        },

        // abstract
        init: function (opts) {
            var results, search, resultsSelector = ".select2-results";

            // prepare options
            this.opts = opts = this.prepareOpts(opts);

            this.id=opts.id;

            // destroy if called on an existing component
            if (opts.element.data("select2") !== undefined &&
                opts.element.data("select2") !== null) {
                opts.element.data("select2").destroy();
            }

            this.container = this.createContainer();

            this.containerId="s2id_"+(opts.element.attr("id") || "autogen"+nextUid());
            this.containerSelector="#"+this.containerId.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
            this.container.attr("id", this.containerId);

            // cache the body so future lookups are cheap
            this.body = thunk(function() { return opts.element.closest("body"); });

            syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);

            this.container.attr("style", opts.element.attr("style"));
            this.container.css(evaluate(opts.containerCss));
            this.container.addClass(evaluate(opts.containerCssClass));

            this.elementTabIndex = this.opts.element.attr("tabindex");

            // swap container for the element
            this.opts.element
                .data("select2", this)
                .attr("tabindex", "-1")
                .before(this.container)
                .on("click.select2", killEvent); // do not leak click events

            this.container.data("select2", this);

            this.dropdown = this.container.find(".select2-drop");

            syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);

            this.dropdown.addClass(evaluate(opts.dropdownCssClass));
            this.dropdown.data("select2", this);
            this.dropdown.on("click", killEvent);

            this.results = results = this.container.find(resultsSelector);
            this.search = search = this.container.find("input.select2-input");

            this.queryCount = 0;
            this.resultsPage = 0;
            this.context = null;

            // initialize the container
            this.initContainer();

            this.container.on("click", killEvent);

            installFilteredMouseMove(this.results);
            this.dropdown.on("mousemove-filtered touchstart touchmove touchend", resultsSelector, this.bind(this.highlightUnderEvent));

            installDebouncedScroll(80, this.results);
            this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));

            // do not propagate change event from the search field out of the component
            $(this.container).on("change", ".select2-input", function(e) {e.stopPropagation();});
            $(this.dropdown).on("change", ".select2-input", function(e) {e.stopPropagation();});

            // if jquery.mousewheel plugin is installed we can prevent out-of-bounds scrolling of results via mousewheel
            if ($.fn.mousewheel) {
                results.mousewheel(function (e, delta, deltaX, deltaY) {
                    var top = results.scrollTop();
                    if (deltaY > 0 && top - deltaY <= 0) {
                        results.scrollTop(0);
                        killEvent(e);
                    } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
                        results.scrollTop(results.get(0).scrollHeight - results.height());
                        killEvent(e);
                    }
                });
            }

            installKeyUpChangeEvent(search);
            search.on("keyup-change input paste", this.bind(this.updateResults));
            search.on("focus", function () { search.addClass("select2-focused"); });
            search.on("blur", function () { search.removeClass("select2-focused");});

            this.dropdown.on("mouseup", resultsSelector, this.bind(function (e) {
                if ($(e.target).closest(".select2-result-selectable").length > 0) {
                    this.highlightUnderEvent(e);
                    this.selectHighlighted(e);
                }
            }));

            // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
            // for mouse events outside of itself so it can close itself. since the dropdown is now outside the select2's
            // dom it will trigger the popup close, which is not what we want
            this.dropdown.on("click mouseup mousedown", function (e) { e.stopPropagation(); });

            if ($.isFunction(this.opts.initSelection)) {
                // initialize selection based on the current value of the source element
                this.initSelection();

                // if the user has provided a function that can set selection based on the value of the source element
                // we monitor the change event on the element and trigger it, allowing for two way synchronization
                this.monitorSource();
            }

            if (opts.maximumInputLength !== null) {
                this.search.attr("maxlength", opts.maximumInputLength);
            }

            var disabled = opts.element.prop("disabled");
            if (disabled === undefined) disabled = false;
            this.enable(!disabled);

            var readonly = opts.element.prop("readonly");
            if (readonly === undefined) readonly = false;
            this.readonly(readonly);

            // Calculate size of scrollbar
            scrollBarDimensions = scrollBarDimensions || measureScrollbar();

            this.autofocus = opts.element.prop("autofocus");
            opts.element.prop("autofocus", false);
            if (this.autofocus) this.focus();

            this.nextSearchTerm = undefined;
        },

        // abstract
        destroy: function () {
            var element=this.opts.element, select2 = element.data("select2");

            this.close();

            if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }

            if (select2 !== undefined) {
                select2.container.remove();
                select2.dropdown.remove();
                element
                    .removeClass("select2-offscreen")
                    .removeData("select2")
                    .off(".select2")
                    .prop("autofocus", this.autofocus || false);
                if (this.elementTabIndex) {
                    element.attr({tabindex: this.elementTabIndex});
                } else {
                    element.removeAttr("tabindex");
                }
                element.show();
            }
        },

        // abstract
        optionToData: function(element) {
            if (element.is("option")) {
                return {
                    id:element.prop("value"),
                    text:element.text(),
                    element: element.get(),
                    css: element.attr("class"),
                    disabled: element.prop("disabled"),
                    locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
                };
            } else if (element.is("optgroup")) {
                return {
                    text:element.attr("label"),
                    children:[],
                    element: element.get(),
                    css: element.attr("class")
                };
            }
        },

        // abstract
        prepareOpts: function (opts) {
            var element, select, idKey, ajaxUrl, self = this;

            element = opts.element;

            if (element.get(0).tagName.toLowerCase() === "select") {
                this.select = select = opts.element;
            }

            if (select) {
                // these options are not allowed when attached to a select because they are picked up off the element itself
                $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function () {
                    if (this in opts) {
                        throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                    }
                });
            }

            opts = $.extend({}, {
                populateResults: function(container, results, query) {
                    var populate, id=this.opts.id;

                    populate=function(results, container, depth) {

                        var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;

                        results = opts.sortResults(results, container, query);

                        for (i = 0, l = results.length; i < l; i = i + 1) {

                            result=results[i];

                            disabled = (result.disabled === true);
                            selectable = (!disabled) && (id(result) !== undefined);

                            compound=result.children && result.children.length > 0;

                            node=$("<li></li>");
                            node.addClass("select2-results-dept-"+depth);
                            node.addClass("select2-result");
                            node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
                            if (disabled) { node.addClass("select2-disabled"); }
                            if (compound) { node.addClass("select2-result-with-children"); }
                            node.addClass(self.opts.formatResultCssClass(result));

                            label=$(document.createElement("div"));
                            label.addClass("select2-result-label");

                            formatted=opts.formatResult(result, label, query, self.opts.escapeMarkup);
                            if (formatted!==undefined) {
                                label.html(formatted);
                            }

                            node.append(label);

                            if (compound) {

                                innerContainer=$("<ul></ul>");
                                innerContainer.addClass("select2-result-sub");
                                populate(result.children, innerContainer, depth+1);
                                node.append(innerContainer);
                            }

                            node.data("select2-data", result);
                            container.append(node);
                        }
                    };

                    populate(results, container, 0);
                }
            }, $.fn.select2.defaults, opts);

            if (typeof(opts.id) !== "function") {
                idKey = opts.id;
                opts.id = function (e) { return e[idKey]; };
            }

            if ($.isArray(opts.element.data("select2Tags"))) {
                if ("tags" in opts) {
                    throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
                }
                opts.tags=opts.element.data("select2Tags");
            }

            if (select) {
                opts.query = this.bind(function (query) {
                    var data = { results: [], more: false },
                        term = query.term,
                        children, placeholderOption, process;

                    process=function(element, collection) {
                        var group;
                        if (element.is("option")) {
                            if (query.matcher(term, element.text(), element)) {
                                collection.push(self.optionToData(element));
                            }
                        } else if (element.is("optgroup")) {
                            group=self.optionToData(element);
                            element.children().each2(function(i, elm) { process(elm, group.children); });
                            if (group.children.length>0) {
                                collection.push(group);
                            }
                        }
                    };

                    children=element.children();

                    // ignore the placeholder option if there is one
                    if (this.getPlaceholder() !== undefined && children.length > 0) {
                        placeholderOption = this.getPlaceholderOption();
                        if (placeholderOption) {
                            children=children.not(placeholderOption);
                        }
                    }

                    children.each2(function(i, elm) { process(elm, data.results); });

                    query.callback(data);
                });
                // this is needed because inside val() we construct choices from options and there id is hardcoded
                opts.id=function(e) { return e.id; };
                opts.formatResultCssClass = function(data) { return data.css; };
            } else {
                if (!("query" in opts)) {

                    if ("ajax" in opts) {
                        ajaxUrl = opts.element.data("ajax-url");
                        if (ajaxUrl && ajaxUrl.length > 0) {
                            opts.ajax.url = ajaxUrl;
                        }
                        opts.query = ajax.call(opts.element, opts.ajax);
                    } else if ("data" in opts) {
                        opts.query = local(opts.data);
                    } else if ("tags" in opts) {
                        opts.query = tags(opts.tags);
                        if (opts.createSearchChoice === undefined) {
                            opts.createSearchChoice = function (term) { return {id: $.trim(term), text: $.trim(term)}; };
                        }
                        if (opts.initSelection === undefined) {
                            opts.initSelection = function (element, callback) {
                                var data = [];
                                $(splitVal(element.val(), opts.separator)).each(function () {
                                    var obj = { id: this, text: this },
                                        tags = opts.tags;
                                    if ($.isFunction(tags)) tags=tags();
                                    $(tags).each(function() { if (equal(this.id, obj.id)) { obj = this; return false; } });
                                    data.push(obj);
                                });

                                callback(data);
                            };
                        }
                    }
                }
            }
            if (typeof(opts.query) !== "function") {
                throw "query function not defined for Select2 " + opts.element.attr("id");
            }

            return opts;
        },

        /**
         * Monitor the original element for changes and update select2 accordingly
         */
        // abstract
        monitorSource: function () {
            var el = this.opts.element, sync, observer;

            el.on("change.select2", this.bind(function (e) {
                if (this.opts.element.data("select2-change-triggered") !== true) {
                    this.initSelection();
                }
            }));

            sync = this.bind(function () {

                // sync enabled state
                var disabled = el.prop("disabled");
                if (disabled === undefined) disabled = false;
                this.enable(!disabled);

                var readonly = el.prop("readonly");
                if (readonly === undefined) readonly = false;
                this.readonly(readonly);

                syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
                this.container.addClass(evaluate(this.opts.containerCssClass));

                syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
                this.dropdown.addClass(evaluate(this.opts.dropdownCssClass));

            });

            // IE8-10
            el.on("propertychange.select2", sync);

            // hold onto a reference of the callback to work around a chromium bug
            if (this.mutationCallback === undefined) {
                this.mutationCallback = function (mutations) {
                    mutations.forEach(sync);
                }
            }

            // safari, chrome, firefox, IE11
            observer = window.MutationObserver || window.WebKitMutationObserver|| window.MozMutationObserver;
            if (observer !== undefined) {
                if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }
                this.propertyObserver = new observer(this.mutationCallback);
                this.propertyObserver.observe(el.get(0), { attributes:true, subtree:false });
            }
        },

        // abstract
        triggerSelect: function(data) {
            var evt = $.Event("select2-selecting", { val: this.id(data), object: data });
            this.opts.element.trigger(evt);
            return !evt.isDefaultPrevented();
        },

        /**
         * Triggers the change event on the source element
         */
        // abstract
        triggerChange: function (details) {

            details = details || {};
            details= $.extend({}, details, { type: "change", val: this.val() });
            // prevents recursive triggering
            this.opts.element.data("select2-change-triggered", true);
            this.opts.element.trigger(details);
            this.opts.element.data("select2-change-triggered", false);

            // some validation frameworks ignore the change event and listen instead to keyup, click for selects
            // so here we trigger the click event manually
            this.opts.element.click();

            // ValidationEngine ignorea the change event and listens instead to blur
            // so here we trigger the blur event manually if so desired
            if (this.opts.blurOnChange)
                this.opts.element.blur();
        },

        //abstract
        isInterfaceEnabled: function()
        {
            return this.enabledInterface === true;
        },

        // abstract
        enableInterface: function() {
            var enabled = this._enabled && !this._readonly,
                disabled = !enabled;

            if (enabled === this.enabledInterface) return false;

            this.container.toggleClass("select2-container-disabled", disabled);
            this.close();
            this.enabledInterface = enabled;

            return true;
        },

        // abstract
        enable: function(enabled) {
            if (enabled === undefined) enabled = true;
            if (this._enabled === enabled) return;
            this._enabled = enabled;

            this.opts.element.prop("disabled", !enabled);
            this.enableInterface();
        },

        // abstract
        disable: function() {
            this.enable(false);
        },

        // abstract
        readonly: function(enabled) {
            if (enabled === undefined) enabled = false;
            if (this._readonly === enabled) return false;
            this._readonly = enabled;

            this.opts.element.prop("readonly", enabled);
            this.enableInterface();
            return true;
        },

        // abstract
        opened: function () {
            return this.container.hasClass("select2-dropdown-open");
        },

        // abstract
        positionDropdown: function() {
            var $dropdown = this.dropdown,
                offset = this.container.offset(),
                height = this.container.outerHeight(false),
                width = this.container.outerWidth(false),
                dropHeight = $dropdown.outerHeight(false),
                $window = $(window),
                windowWidth = $window.width(),
                windowHeight = $window.height(),
                viewPortRight = $window.scrollLeft() + windowWidth,
                viewportBottom = $window.scrollTop() + windowHeight,
                dropTop = offset.top + height,
                dropLeft = offset.left,
                enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
                enoughRoomAbove = (offset.top - dropHeight) >= this.body().scrollTop(),
                dropWidth = $dropdown.outerWidth(false),
                enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight,
                aboveNow = $dropdown.hasClass("select2-drop-above"),
                bodyOffset,
                above,
                changeDirection,
                css,
                resultsListNode;

            // always prefer the current above/below alignment, unless there is not enough room
            if (aboveNow) {
                above = true;
                if (!enoughRoomAbove && enoughRoomBelow) {
                    changeDirection = true;
                    above = false;
                }
            } else {
                above = false;
                if (!enoughRoomBelow && enoughRoomAbove) {
                    changeDirection = true;
                    above = true;
                }
            }

            //if we are changing direction we need to get positions when dropdown is hidden;
            if (changeDirection) {
                $dropdown.hide();
                offset = this.container.offset();
                height = this.container.outerHeight(false);
                width = this.container.outerWidth(false);
                dropHeight = $dropdown.outerHeight(false);
                viewPortRight = $window.scrollLeft() + windowWidth;
                viewportBottom = $window.scrollTop() + windowHeight;
                dropTop = offset.top + height;
                dropLeft = offset.left;
                dropWidth = $dropdown.outerWidth(false);
                enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
                $dropdown.show();
            }

            if (this.opts.dropdownAutoWidth) {
                resultsListNode = $('.select2-results', $dropdown)[0];
                $dropdown.addClass('select2-drop-auto-width');
                $dropdown.css('width', '');
                // Add scrollbar width to dropdown if vertical scrollbar is present
                dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
                dropWidth > width ? width = dropWidth : dropWidth = width;
                enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
            }
            else {
                this.container.removeClass('select2-drop-auto-width');
            }

            //console.log("below/ droptop:", dropTop, "dropHeight", dropHeight, "sum", (dropTop+dropHeight)+" viewport bottom", viewportBottom, "enough?", enoughRoomBelow);
            //console.log("above/ offset.top", offset.top, "dropHeight", dropHeight, "top", (offset.top-dropHeight), "scrollTop", this.body().scrollTop(), "enough?", enoughRoomAbove);

            // fix positioning when body has an offset and is not position: static
            if (this.body().css('position') !== 'static') {
                bodyOffset = this.body().offset();
                dropTop -= bodyOffset.top;
                dropLeft -= bodyOffset.left;
            }

            if (!enoughRoomOnRight) {
                dropLeft = offset.left + width - dropWidth;
            }

            css =  {
                left: dropLeft,
                width: width
            };

            if (above) {
                css.bottom = windowHeight - offset.top;
                css.top = 'auto';
                this.container.addClass("select2-drop-above");
                $dropdown.addClass("select2-drop-above");
            }
            else {
                css.top = dropTop;
                css.bottom = 'auto';
                this.container.removeClass("select2-drop-above");
                $dropdown.removeClass("select2-drop-above");
            }
            css = $.extend(css, evaluate(this.opts.dropdownCss));

            $dropdown.css(css);
        },

        // abstract
        shouldOpen: function() {
            var event;

            if (this.opened()) return false;

            if (this._enabled === false || this._readonly === true) return false;

            event = $.Event("select2-opening");
            this.opts.element.trigger(event);
            return !event.isDefaultPrevented();
        },

        // abstract
        clearDropdownAlignmentPreference: function() {
            // clear the classes used to figure out the preference of where the dropdown should be opened
            this.container.removeClass("select2-drop-above");
            this.dropdown.removeClass("select2-drop-above");
        },

        /**
         * Opens the dropdown
         *
         * @return {Boolean} whether or not dropdown was opened. This method will return false if, for example,
         * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
         */
        // abstract
        open: function () {

            if (!this.shouldOpen()) return false;

            this.opening();

            return true;
        },

        /**
         * Performs the opening of the dropdown
         */
        // abstract
        opening: function() {
            var cid = this.containerId,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid,
                mask;

            this.container.addClass("select2-dropdown-open").addClass("select2-container-active");

            this.clearDropdownAlignmentPreference();

            if(this.dropdown[0] !== this.body().children().last()[0]) {
                this.dropdown.detach().appendTo(this.body());
            }

            // create the dropdown mask if doesnt already exist
            mask = $("#select2-drop-mask");
            if (mask.length == 0) {
                mask = $(document.createElement("div"));
                mask.attr("id","select2-drop-mask").attr("class","select2-drop-mask");
                mask.hide();
                mask.appendTo(this.body());
                mask.on("mousedown touchstart click", function (e) {
                    var dropdown = $("#select2-drop"), self;
                    if (dropdown.length > 0) {
                        self=dropdown.data("select2");
                        if (self.opts.selectOnBlur) {
                            self.selectHighlighted({noFocus: true});
                        }
                        self.close({focus:true});
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
            }

            // ensure the mask is always right before the dropdown
            if (this.dropdown.prev()[0] !== mask[0]) {
                this.dropdown.before(mask);
            }

            // move the global id to the correct dropdown
            $("#select2-drop").removeAttr("id");
            this.dropdown.attr("id", "select2-drop");

            // show the elements
            mask.show();

            this.positionDropdown();
            this.dropdown.show();
            this.positionDropdown();

            this.dropdown.addClass("select2-drop-active");

            // attach listeners to events that can change the position of the container and thus require
            // the position of the dropdown to be updated as well so it does not come unglued from the container
            var that = this;
            this.container.parents().add(window).each(function () {
                $(this).on(resize+" "+scroll+" "+orient, function (e) {
                    that.positionDropdown();
                });
            });


        },

        // abstract
        close: function () {
            if (!this.opened()) return;

            var cid = this.containerId,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid;

            // unbind event listeners
            this.container.parents().add(window).each(function () { $(this).off(scroll).off(resize).off(orient); });

            this.clearDropdownAlignmentPreference();

            $("#select2-drop-mask").hide();
            this.dropdown.removeAttr("id"); // only the active dropdown has the select2-drop id
            this.dropdown.hide();
            this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
            this.results.empty();


            this.clearSearch();
            this.search.removeClass("select2-active");
            this.opts.element.trigger($.Event("select2-close"));
        },

        /**
         * Opens control, sets input value, and updates results.
         */
        // abstract
        externalSearch: function (term) {
            this.open();
            this.search.val(term);
            this.updateResults(false);
        },

        // abstract
        clearSearch: function () {

        },

        //abstract
        getMaximumSelectionSize: function() {
            return evaluate(this.opts.maximumSelectionSize);
        },

        // abstract
        ensureHighlightVisible: function () {
            var results = this.results, children, index, child, hb, rb, y, more;

            index = this.highlight();

            if (index < 0) return;

            if (index == 0) {

                // if the first element is highlighted scroll all the way to the top,
                // that way any unselectable headers above it will also be scrolled
                // into view

                results.scrollTop(0);
                return;
            }

            children = this.findHighlightableChoices().find('.select2-result-label');

            child = $(children[index]);

            hb = child.offset().top + child.outerHeight(true);

            // if this is the last child lets also make sure select2-more-results is visible
            if (index === children.length - 1) {
                more = results.find("li.select2-more-results");
                if (more.length > 0) {
                    hb = more.offset().top + more.outerHeight(true);
                }
            }

            rb = results.offset().top + results.outerHeight(true);
            if (hb > rb) {
                results.scrollTop(results.scrollTop() + (hb - rb));
            }
            y = child.offset().top - results.offset().top;

            // make sure the top of the element is visible
            if (y < 0 && child.css('display') != 'none' ) {
                results.scrollTop(results.scrollTop() + y); // y is negative
            }
        },

        // abstract
        findHighlightableChoices: function() {
            return this.results.find(".select2-result-selectable:not(.select2-disabled, .select2-selected)");
        },

        // abstract
        moveHighlight: function (delta) {
            var choices = this.findHighlightableChoices(),
                index = this.highlight();

            while (index > -1 && index < choices.length) {
                index += delta;
                var choice = $(choices[index]);
                if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
                    this.highlight(index);
                    break;
                }
            }
        },

        // abstract
        highlight: function (index) {
            var choices = this.findHighlightableChoices(),
                choice,
                data;

            if (arguments.length === 0) {
                return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
            }

            if (index >= choices.length) index = choices.length - 1;
            if (index < 0) index = 0;

            this.removeHighlight();

            choice = $(choices[index]);
            choice.addClass("select2-highlighted");

            this.ensureHighlightVisible();

            data = choice.data("select2-data");
            if (data) {
                this.opts.element.trigger({ type: "select2-highlight", val: this.id(data), choice: data });
            }
        },

        removeHighlight: function() {
            this.results.find(".select2-highlighted").removeClass("select2-highlighted");
        },

        // abstract
        countSelectableResults: function() {
            return this.findHighlightableChoices().length;
        },

        // abstract
        highlightUnderEvent: function (event) {
            var el = $(event.target).closest(".select2-result-selectable");
            if (el.length > 0 && !el.is(".select2-highlighted")) {
                var choices = this.findHighlightableChoices();
                this.highlight(choices.index(el));
            } else if (el.length == 0) {
                // if we are over an unselectable item remove all highlights
                this.removeHighlight();
            }
        },

        // abstract
        loadMoreIfNeeded: function () {
            var results = this.results,
                more = results.find("li.select2-more-results"),
                below, // pixels the element is below the scroll fold, below==0 is when the element is starting to be visible
                page = this.resultsPage + 1,
                self=this,
                term=this.search.val(),
                context=this.context;

            if (more.length === 0) return;
            below = more.offset().top - results.offset().top - results.height();

            if (below <= this.opts.loadMorePadding) {
                more.addClass("select2-active");
                this.opts.query({
                    element: this.opts.element,
                    term: term,
                    page: page,
                    context: context,
                    matcher: this.opts.matcher,
                    callback: this.bind(function (data) {

                        // ignore a response if the select2 has been closed before it was received
                        if (!self.opened()) return;


                        self.opts.populateResults.call(this, results, data.results, {term: term, page: page, context:context});
                        self.postprocessResults(data, false, false);

                        if (data.more===true) {
                            more.detach().appendTo(results).text(self.opts.formatLoadMore(page+1));
                            window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                        } else {
                            more.remove();
                        }
                        self.positionDropdown();
                        self.resultsPage = page;
                        self.context = data.context;
                        this.opts.element.trigger({ type: "select2-loaded", items: data });
                    })});
            }
        },

        /**
         * Default tokenizer function which does nothing
         */
        tokenize: function() {

        },

        /**
         * @param initial whether or not this is the call to this method right after the dropdown has been opened
         */
        // abstract
        updateResults: function (initial) {
            var search = this.search,
                results = this.results,
                opts = this.opts,
                data,
                self = this,
                input,
                term = search.val(),
                lastTerm = $.data(this.container, "select2-last-term"),
            // sequence number used to drop out-of-order responses
                queryNumber;

            // prevent duplicate queries against the same term
            if (initial !== true && lastTerm && equal(term, lastTerm)) return;

            $.data(this.container, "select2-last-term", term);

            // if the search is currently hidden we do not alter the results
            if (initial !== true && (this.showSearchInput === false || !this.opened())) {
                return;
            }

            function postRender() {
                search.removeClass("select2-active");
                self.positionDropdown();
            }

            function render(html) {
                results.html(html);
                postRender();
            }

            queryNumber = ++this.queryCount;

            var maxSelSize = this.getMaximumSelectionSize();
            if (maxSelSize >=1) {
                data = this.data();
                if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
                    render("<li class='select2-selection-limit'>" + opts.formatSelectionTooBig(maxSelSize) + "</li>");
                    return;
                }
            }

            if (search.val().length < opts.minimumInputLength) {
                if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
                    render("<li class='select2-no-results'>" + opts.formatInputTooShort(search.val(), opts.minimumInputLength) + "</li>");
                } else {
                    render("");
                }
                if (initial && this.showSearch) this.showSearch(true);
                return;
            }

            if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
                if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
                    render("<li class='select2-no-results'>" + opts.formatInputTooLong(search.val(), opts.maximumInputLength) + "</li>");
                } else {
                    render("");
                }
                return;
            }

            if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
                render("<li class='select2-searching'>" + opts.formatSearching() + "</li>");
            }

            search.addClass("select2-active");

            this.removeHighlight();

            // give the tokenizer a chance to pre-process the input
            input = this.tokenize();
            if (input != undefined && input != null) {
                search.val(input);
            }

            this.resultsPage = 1;

            opts.query({
                element: opts.element,
                term: search.val(),
                page: this.resultsPage,
                context: null,
                matcher: opts.matcher,
                callback: this.bind(function (data) {
                    var def; // default choice

                    // ignore old responses
                    if (queryNumber != this.queryCount) {
                        return;
                    }

                    // ignore a response if the select2 has been closed before it was received
                    if (!this.opened()) {
                        this.search.removeClass("select2-active");
                        return;
                    }

                    // save context, if any
                    this.context = (data.context===undefined) ? null : data.context;
                    // create a default choice and prepend it to the list
                    if (this.opts.createSearchChoice && search.val() !== "") {
                        def = this.opts.createSearchChoice.call(self, search.val(), data.results);
                        if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
                            if ($(data.results).filter(
                                function () {
                                    return equal(self.id(this), self.id(def));
                                }).length === 0) {
                                data.results.unshift(def);
                            }
                        }
                    }

                    if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
                        render("<li class='select2-no-results'>" + opts.formatNoMatches(search.val()) + "</li>");
                        return;
                    }

                    results.empty();
                    self.opts.populateResults.call(this, results, data.results, {term: search.val(), page: this.resultsPage, context:null});

                    if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
                        results.append("<li class='select2-more-results'>" + self.opts.escapeMarkup(opts.formatLoadMore(this.resultsPage)) + "</li>");
                        window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                    }

                    this.postprocessResults(data, initial);

                    postRender();

                    this.opts.element.trigger({ type: "select2-loaded", items: data });
                })});
        },

        // abstract
        cancel: function () {
            this.close();
        },

        // abstract
        blur: function () {
            // if selectOnBlur == true, select the currently highlighted option
            if (this.opts.selectOnBlur)
                this.selectHighlighted({noFocus: true});

            this.close();
            this.container.removeClass("select2-container-active");
            // synonymous to .is(':focus'), which is available in jquery >= 1.6
            if (this.search[0] === document.activeElement) { this.search.blur(); }
            this.clearSearch();
            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
        },

        // abstract
        focusSearch: function () {
            focus(this.search);
        },

        // abstract
        selectHighlighted: function (options) {
            var index=this.highlight(),
                highlighted=this.results.find(".select2-highlighted"),
                data = highlighted.closest('.select2-result').data("select2-data");

            if (data) {
                this.highlight(index);
                this.onSelect(data, options);
            } else if (options && options.noFocus) {
                this.close();
            }
        },

        // abstract
        getPlaceholder: function () {
            var placeholderOption;
            return this.opts.element.attr("placeholder") ||
                this.opts.element.attr("data-placeholder") || // jquery 1.4 compat
                this.opts.element.data("placeholder") ||
                this.opts.placeholder ||
                ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
        },

        // abstract
        getPlaceholderOption: function() {
            if (this.select) {
                var firstOption = this.select.children('option').first();
                if (this.opts.placeholderOption !== undefined ) {
                    //Determine the placeholder option based on the specified placeholderOption setting
                    return (this.opts.placeholderOption === "first" && firstOption) ||
                        (typeof this.opts.placeholderOption === "function" && this.opts.placeholderOption(this.select));
                } else if (firstOption.text() === "" && firstOption.val() === "") {
                    //No explicit placeholder option specified, use the first if it's blank
                    return firstOption;
                }
            }
        },

        /**
         * Get the desired width for the container element.  This is
         * derived first from option `width` passed to select2, then
         * the inline 'style' on the original element, and finally
         * falls back to the jQuery calculated element width.
         */
        // abstract
        initContainerWidth: function () {
            function resolveContainerWidth() {
                var style, attrs, matches, i, l, attr;

                if (this.opts.width === "off") {
                    return null;
                } else if (this.opts.width === "element"){
                    return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
                } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
                    // check if there is inline style on the element that contains width
                    style = this.opts.element.attr('style');
                    if (style !== undefined) {
                        attrs = style.split(';');
                        for (i = 0, l = attrs.length; i < l; i = i + 1) {
                            attr = attrs[i].replace(/\s/g, '');
                            matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
                            if (matches !== null && matches.length >= 1)
                                return matches[1];
                        }
                    }

                    if (this.opts.width === "resolve") {
                        // next check if css('width') can resolve a width that is percent based, this is sometimes possible
                        // when attached to input type=hidden or elements hidden via css
                        style = this.opts.element.css('width');
                        if (style.indexOf("%") > 0) return style;

                        // finally, fallback on the calculated width of the element
                        return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
                    }

                    return null;
                } else if ($.isFunction(this.opts.width)) {
                    return this.opts.width();
                } else {
                    return this.opts.width;
                }
            };

            var width = resolveContainerWidth.call(this);
            if (width !== null) {
                this.container.css("width", width);
            }
        }
    });

    SingleSelect2 = clazz(AbstractSelect2, {

        // single

        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container"
            }).html([
                    "<a href='javascript:void(0)' onclick='return false;' class='select2-choice' tabindex='-1'>",
                    "   <span class='select2-chosen'>&nbsp;</span><abbr class='select2-search-choice-close'></abbr>",
                    "   <span class='select2-arrow'><b></b></span>",
                    "</a>",
                    "<input class='select2-focusser select2-offscreen' type='text'/>",
                    "<div class='select2-drop select2-display-none'>",
                    "   <div class='select2-search'>",
                    "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'/>",
                    "   </div>",
                    "   <ul class='select2-results'>",
                    "   </ul>",
                    "</div>"].join(""));
            return container;
        },

        // single
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.focusser.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // single
        opening: function () {
            var el, range, len;

            if (this.opts.minimumResultsForSearch >= 0) {
                this.showSearch(true);
            }

            this.parent.opening.apply(this, arguments);

            if (this.showSearchInput !== false) {
                // IE appends focusser.val() at the end of field :/ so we manually insert it at the beginning using a range
                // all other browsers handle this just fine

                this.search.val(this.focusser.val());
            }
            this.search.focus();
            // move the cursor to the end after focussing, otherwise it will be at the beginning and
            // new text will appear *before* focusser.val()
            el = this.search.get(0);
            if (el.createTextRange) {
                range = el.createTextRange();
                range.collapse(false);
                range.select();
            } else if (el.setSelectionRange) {
                len = this.search.val().length;
                el.setSelectionRange(len, len);
            }

            // initializes search's value with nextSearchTerm (if defined by user)
            // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
            if(this.search.val() === "") {
                if(this.nextSearchTerm != undefined){
                    this.search.val(this.nextSearchTerm);
                    this.search.select();
                }
            }

            this.focusser.prop("disabled", true).val("");
            this.updateResults(true);
            this.opts.element.trigger($.Event("select2-open"));
        },

        // single
        close: function (params) {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);

            params = params || {focus: true};
            this.focusser.removeAttr("disabled");

            if (params.focus) {
                this.focusser.focus();
            }
        },

        // single
        focus: function () {
            if (this.opened()) {
                this.close();
            } else {
                this.focusser.removeAttr("disabled");
                this.focusser.focus();
            }
        },

        // single
        isFocused: function () {
            return this.container.hasClass("select2-container-active");
        },

        // single
        cancel: function () {
            this.parent.cancel.apply(this, arguments);
            this.focusser.removeAttr("disabled");
            this.focusser.focus();
        },

        // single
        destroy: function() {
            $("label[for='" + this.focusser.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);
        },

        // single
        initContainer: function () {

            var selection,
                container = this.container,
                dropdown = this.dropdown;

            if (this.opts.minimumResultsForSearch < 0) {
                this.showSearch(false);
            } else {
                this.showSearch(true);
            }

            this.selection = selection = container.find(".select2-choice");

            this.focusser = container.find(".select2-focusser");

            // rewrite labels from original element to focusser
            this.focusser.attr("id", "s2id_autogen"+nextUid());

            $("label[for='" + this.opts.element.attr("id") + "']")
                .attr('for', this.focusser.attr('id'));

            this.focusser.attr("tabindex", this.elementTabIndex);

            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                    return;
                }

                switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({noFocus: true});
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                }
            }));

            this.search.on("blur", this.bind(function(e) {
                // a workaround for chrome to keep the search field focussed when the scroll bar is used to scroll the dropdown.
                // without this the search field loses focus which is annoying
                if (document.activeElement === this.body().get(0)) {
                    window.setTimeout(this.bind(function() {
                        this.search.focus();
                    }), 0);
                }
            }));

            this.focusser.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                    return;
                }

                if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DOWN || e.which == KEY.UP
                    || (e.which == KEY.ENTER && this.opts.openOnEnter)) {

                    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) return;

                    this.open();
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
                    if (this.opts.allowClear) {
                        this.clear();
                    }
                    killEvent(e);
                    return;
                }
            }));


            installKeyUpChangeEvent(this.focusser);
            this.focusser.on("keyup-change input", this.bind(function(e) {
                if (this.opts.minimumResultsForSearch >= 0) {
                    e.stopPropagation();
                    if (this.opened()) return;
                    this.open();
                }
            }));

            selection.on("mousedown", "abbr", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;
                this.clear();
                killEventImmediately(e);
                this.close();
                this.selection.focus();
            }));

            selection.on("mousedown", this.bind(function (e) {

                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }

                if (this.opened()) {
                    this.close();
                } else if (this.isInterfaceEnabled()) {
                    this.open();
                }

                killEvent(e);
            }));

            dropdown.on("mousedown", this.bind(function() { this.search.focus(); }));

            selection.on("focus", this.bind(function(e) {
                killEvent(e);
            }));

            this.focusser.on("focus", this.bind(function(){
                    if (!this.container.hasClass("select2-container-active")) {
                        this.opts.element.trigger($.Event("select2-focus"));
                    }
                    this.container.addClass("select2-container-active");
                })).on("blur", this.bind(function() {
                    if (!this.opened()) {
                        this.container.removeClass("select2-container-active");
                        this.opts.element.trigger($.Event("select2-blur"));
                    }
                }));
            this.search.on("focus", this.bind(function(){
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            }));

            this.initContainerWidth();
            this.opts.element.addClass("select2-offscreen");
            this.setPlaceholder();

        },

        // single
        clear: function(triggerChange) {
            var data=this.selection.data("select2-data");
            if (data) { // guard against queued quick consecutive clicks
                var evt = $.Event("select2-clearing");
                this.opts.element.trigger(evt);
                if (evt.isDefaultPrevented()) {
                    return;
                }
                var placeholderOption = this.getPlaceholderOption();
                this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
                this.selection.find(".select2-chosen").empty();
                this.selection.removeData("select2-data");
                this.setPlaceholder();

                if (triggerChange !== false){
                    this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
                    this.triggerChange({removed:data});
                }
            }
        },

        /**
         * Sets selection based on source element's value
         */
        // single
        initSelection: function () {
            var selected;
            if (this.isPlaceholderOptionSelected()) {
                this.updateSelection(null);
                this.close();
                this.setPlaceholder();
            } else {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(selected){
                    if (selected !== undefined && selected !== null) {
                        self.updateSelection(selected);
                        self.close();
                        self.setPlaceholder();
                    }
                });
            }
        },

        isPlaceholderOptionSelected: function() {
            var placeholderOption;
            if (!this.getPlaceholder()) return false; // no placeholder specified so no option should be considered
            return ((placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop("selected"))
                || (this.opts.element.val() === "")
                || (this.opts.element.val() === undefined)
                || (this.opts.element.val() === null);
        },

        // single
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install the selection initializer
                opts.initSelection = function (element, callback) {
                    var selected = element.find("option").filter(function() { return this.selected });
                    // a single select box always has a value, no need to null check 'selected'
                    callback(self.optionToData(selected));
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var id = element.val();
                    //search in data by id, storing the actual matching item
                    var match = null;
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = equal(id, opts.id(el));
                            if (is_match) {
                                match = el;
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            callback(match);
                        }
                    });
                };
            }

            return opts;
        },

        // single
        getPlaceholder: function() {
            // if a placeholder is specified on a single select without a valid placeholder option ignore it
            if (this.select) {
                if (this.getPlaceholderOption() === undefined) {
                    return undefined;
                }
            }

            return this.parent.getPlaceholder.apply(this, arguments);
        },

        // single
        setPlaceholder: function () {
            var placeholder = this.getPlaceholder();

            if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {

                // check for a placeholder option if attached to a select
                if (this.select && this.getPlaceholderOption() === undefined) return;

                this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));

                this.selection.addClass("select2-default");

                this.container.removeClass("select2-allowclear");
            }
        },

        // single
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var selected = 0, self = this, showSearchInput = true;

            // find the selected element in the result list

            this.findHighlightableChoices().each2(function (i, elm) {
                if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
                    selected = i;
                    return false;
                }
            });

            // and highlight it
            if (noHighlightUpdate !== false) {
                if (initial === true && selected >= 0) {
                    this.highlight(selected);
                } else {
                    this.highlight(0);
                }
            }

            // hide the search box if this is the first we got the results and there are enough of them for search

            if (initial === true) {
                var min = this.opts.minimumResultsForSearch;
                if (min >= 0) {
                    this.showSearch(countResults(data.results) >= min);
                }
            }
        },

        // single
        showSearch: function(showSearchInput) {
            if (this.showSearchInput === showSearchInput) return;

            this.showSearchInput = showSearchInput;

            this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
            this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
            //add "select2-with-searchbox" to the container if search box is shown
            $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
        },

        // single
        onSelect: function (data, options) {

            if (!this.triggerSelect(data)) { return; }

            var old = this.opts.element.val(),
                oldData = this.data();

            this.opts.element.val(this.id(data));
            this.updateSelection(data);

            this.opts.element.trigger({ type: "select2-selected", val: this.id(data), choice: data });

            this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
            this.close();

            if (!options || !options.noFocus)
                this.focusser.focus();

            if (!equal(old, this.id(data))) { this.triggerChange({added:data,removed:oldData}); }
        },

        // single
        updateSelection: function (data) {

            var container=this.selection.find(".select2-chosen"), formatted, cssClass;

            this.selection.data("select2-data", data);

            container.empty();
            if (data !== null) {
                formatted=this.opts.formatSelection(data, container, this.opts.escapeMarkup);
            }
            if (formatted !== undefined) {
                container.append(formatted);
            }
            cssClass=this.opts.formatSelectionCssClass(data, container);
            if (cssClass !== undefined) {
                container.addClass(cssClass);
            }

            this.selection.removeClass("select2-default");

            if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
                this.container.addClass("select2-allowclear");
            }
        },

        // single
        val: function () {
            var val,
                triggerChange = false,
                data = null,
                self = this,
                oldData = this.data();

            if (arguments.length === 0) {
                return this.opts.element.val();
            }

            val = arguments[0];

            if (arguments.length > 1) {
                triggerChange = arguments[1];
            }

            if (this.select) {
                this.select
                    .val(val)
                    .find("option").filter(function() { return this.selected }).each2(function (i, elm) {
                        data = self.optionToData(elm);
                        return false;
                    });
                this.updateSelection(data);
                this.setPlaceholder();
                if (triggerChange) {
                    this.triggerChange({added: data, removed:oldData});
                }
            } else {
                // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
                if (!val && val !== 0) {
                    this.clear(triggerChange);
                    return;
                }
                if (this.opts.initSelection === undefined) {
                    throw new Error("cannot call val() if initSelection() is not defined");
                }
                this.opts.element.val(val);
                this.opts.initSelection(this.opts.element, function(data){
                    self.opts.element.val(!data ? "" : self.id(data));
                    self.updateSelection(data);
                    self.setPlaceholder();
                    if (triggerChange) {
                        self.triggerChange({added: data, removed:oldData});
                    }
                });
            }
        },

        // single
        clearSearch: function () {
            this.search.val("");
            this.focusser.val("");
        },

        // single
        data: function(value) {
            var data,
                triggerChange = false;

            if (arguments.length === 0) {
                data = this.selection.data("select2-data");
                if (data == undefined) data = null;
                return data;
            } else {
                if (arguments.length > 1) {
                    triggerChange = arguments[1];
                }
                if (!value) {
                    this.clear(triggerChange);
                } else {
                    data = this.data();
                    this.opts.element.val(!value ? "" : this.id(value));
                    this.updateSelection(value);
                    if (triggerChange) {
                        this.triggerChange({added: value, removed:data});
                    }
                }
            }
        }
    });

    MultiSelect2 = clazz(AbstractSelect2, {

        // multi
        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container select2-container-multi"
            }).html([
                    "<ul class='select2-choices'>",
                    "  <li class='select2-search-field'>",
                    "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>",
                    "  </li>",
                    "</ul>",
                    "<div class='select2-drop select2-drop-multi select2-display-none'>",
                    "   <ul class='select2-results'>",
                    "   </ul>",
                    "</div>"].join(""));
            return container;
        },

        // multi
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            // TODO validate placeholder is a string if specified

            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install sthe selection initializer
                opts.initSelection = function (element, callback) {

                    var data = [];

                    element.find("option").filter(function() { return this.selected }).each2(function (i, elm) {
                        data.push(self.optionToData(elm));
                    });
                    callback(data);
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var ids = splitVal(element.val(), opts.separator);
                    //search in data by array of ids, storing matching items in a list
                    var matches = [];
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = $.grep(ids, function(id) {
                                return equal(id, opts.id(el));
                            }).length;
                            if (is_match) {
                                matches.push(el);
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            // reorder matches based on the order they appear in the ids array because right now
                            // they are in the order in which they appear in data array
                            var ordered = [];
                            for (var i = 0; i < ids.length; i++) {
                                var id = ids[i];
                                for (var j = 0; j < matches.length; j++) {
                                    var match = matches[j];
                                    if (equal(id, opts.id(match))) {
                                        ordered.push(match);
                                        matches.splice(j, 1);
                                        break;
                                    }
                                }
                            }
                            callback(ordered);
                        }
                    });
                };
            }

            return opts;
        },

        // multi
        selectChoice: function (choice) {

            var selected = this.container.find(".select2-search-choice-focus");
            if (selected.length && choice && choice[0] == selected[0]) {

            } else {
                if (selected.length) {
                    this.opts.element.trigger("choice-deselected", selected);
                }
                selected.removeClass("select2-search-choice-focus");
                if (choice && choice.length) {
                    this.close();
                    choice.addClass("select2-search-choice-focus");
                    this.opts.element.trigger("choice-selected", choice);
                }
            }
        },

        // multi
        destroy: function() {
            $("label[for='" + this.search.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);
        },

        // multi
        initContainer: function () {

            var selector = ".select2-choices", selection;

            this.searchContainer = this.container.find(".select2-search-field");
            this.selection = selection = this.container.find(selector);

            var _this = this;
            this.selection.on("click", ".select2-search-choice:not(.select2-locked)", function (e) {
                //killEvent(e);
                _this.search[0].focus();
                _this.selectChoice($(this));
            });

            // rewrite labels from original element to focusser
            this.search.attr("id", "s2id_autogen"+nextUid());
            $("label[for='" + this.opts.element.attr("id") + "']")
                .attr('for', this.search.attr('id'));

            this.search.on("input paste", this.bind(function() {
                if (!this.isInterfaceEnabled()) return;
                if (!this.opened()) {
                    this.open();
                }
            }));

            this.search.attr("tabindex", this.elementTabIndex);

            this.keydowns = 0;
            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                ++this.keydowns;
                var selected = selection.find(".select2-search-choice-focus");
                var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
                var next = selected.next(".select2-search-choice:not(.select2-locked)");
                var pos = getCursorInfo(this.search);

                if (selected.length &&
                    (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
                    var selectedChoice = selected;
                    if (e.which == KEY.LEFT && prev.length) {
                        selectedChoice = prev;
                    }
                    else if (e.which == KEY.RIGHT) {
                        selectedChoice = next.length ? next : null;
                    }
                    else if (e.which === KEY.BACKSPACE) {
                        this.unselect(selected.first());
                        this.search.width(10);
                        selectedChoice = prev.length ? prev : next;
                    } else if (e.which == KEY.DELETE) {
                        this.unselect(selected.first());
                        this.search.width(10);
                        selectedChoice = next.length ? next : null;
                    } else if (e.which == KEY.ENTER) {
                        selectedChoice = null;
                    }

                    this.selectChoice(selectedChoice);
                    killEvent(e);
                    if (!selectedChoice || !selectedChoice.length) {
                        this.open();
                    }
                    return;
                } else if (((e.which === KEY.BACKSPACE && this.keydowns == 1)
                    || e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {

                    this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
                    killEvent(e);
                    return;
                } else {
                    this.selectChoice(null);
                }

                if (this.opened()) {
                    switch (e.which) {
                        case KEY.UP:
                        case KEY.DOWN:
                            this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                            killEvent(e);
                            return;
                        case KEY.ENTER:
                            this.selectHighlighted();
                            killEvent(e);
                            return;
                        case KEY.TAB:
                            this.selectHighlighted({noFocus:true});
                            this.close();
                            return;
                        case KEY.ESC:
                            this.cancel(e);
                            killEvent(e);
                            return;
                    }
                }

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e)
                    || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
                    return;
                }

                if (e.which === KEY.ENTER) {
                    if (this.opts.openOnEnter === false) {
                        return;
                    } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                        return;
                    }
                }

                this.open();

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                }

                if (e.which === KEY.ENTER) {
                    // prevent form from being submitted
                    killEvent(e);
                }

            }));

            this.search.on("keyup", this.bind(function (e) {
                this.keydowns = 0;
                this.resizeSearch();
            })
            );

            this.search.on("blur", this.bind(function(e) {
                this.container.removeClass("select2-container-active");
                this.search.removeClass("select2-focused");
                this.selectChoice(null);
                if (!this.opened()) this.clearSearch();
                e.stopImmediatePropagation();
                this.opts.element.trigger($.Event("select2-blur"));
            }));

            this.container.on("click", selector, this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;
                if ($(e.target).closest(".select2-search-choice").length > 0) {
                    // clicked inside a select2 search choice, do not open
                    return;
                }
                this.selectChoice(null);
                this.clearPlaceholder();
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.open();
                this.focusSearch();
                e.preventDefault();
            }));

            this.container.on("focus", selector, this.bind(function () {
                if (!this.isInterfaceEnabled()) return;
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
                this.dropdown.addClass("select2-drop-active");
                this.clearPlaceholder();
            }));

            this.initContainerWidth();
            this.opts.element.addClass("select2-offscreen");

            // set the placeholder if necessary
            this.clearSearch();
        },

        // multi
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.search.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // multi
        initSelection: function () {
            var data;
            if (this.opts.element.val() === "" && this.opts.element.text() === "") {
                this.updateSelection([]);
                this.close();
                // set the placeholder if necessary
                this.clearSearch();
            }
            if (this.select || this.opts.element.val() !== "") {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(data){
                    if (data !== undefined && data !== null) {
                        self.updateSelection(data);
                        self.close();
                        // set the placeholder if necessary
                        self.clearSearch();
                    }
                });
            }
        },

        // multi
        clearSearch: function () {
            var placeholder = this.getPlaceholder(),
                maxWidth = this.getMaxSearchWidth();

            if (placeholder !== undefined  && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
                this.search.val(placeholder).addClass("select2-default");
                // stretch the search box to full width of the container so as much of the placeholder is visible as possible
                // we could call this.resizeSearch(), but we do not because that requires a sizer and we do not want to create one so early because of a firefox bug, see #944
                this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
            } else {
                this.search.val("").width(10);
            }
        },

        // multi
        clearPlaceholder: function () {
            if (this.search.hasClass("select2-default")) {
                this.search.val("").removeClass("select2-default");
            }
        },

        // multi
        opening: function () {
            this.clearPlaceholder(); // should be done before super so placeholder is not used to search
            this.resizeSearch();

            this.parent.opening.apply(this, arguments);

            this.focusSearch();

            this.updateResults(true);
            this.search.focus();
            this.opts.element.trigger($.Event("select2-open"));
        },

        // multi
        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);
        },

        // multi
        focus: function () {
            this.close();
            this.search.focus();
        },

        // multi
        isFocused: function () {
            return this.search.hasClass("select2-focused");
        },

        // multi
        updateSelection: function (data) {
            var ids = [], filtered = [], self = this;

            // filter out duplicates
            $(data).each(function () {
                if (indexOf(self.id(this), ids) < 0) {
                    ids.push(self.id(this));
                    filtered.push(this);
                }
            });
            data = filtered;

            this.selection.find(".select2-search-choice").remove();
            $(data).each(function () {
                self.addSelectedChoice(this);
            });
            self.postprocessResults();
        },

        // multi
        tokenize: function() {
            var input = this.search.val();
            input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
            if (input != null && input != undefined) {
                this.search.val(input);
                if (input.length > 0) {
                    this.open();
                }
            }

        },

        // multi
        onSelect: function (data, options) {

            if (!this.triggerSelect(data)) { return; }

            this.addSelectedChoice(data);

            this.opts.element.trigger({ type: "selected", val: this.id(data), choice: data });

            if (this.select || !this.opts.closeOnSelect) this.postprocessResults(data, false, this.opts.closeOnSelect===true);

            if (this.opts.closeOnSelect) {
                this.close();
                this.search.width(10);
            } else {
                if (this.countSelectableResults()>0) {
                    this.search.width(10);
                    this.resizeSearch();
                    if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
                        // if we reached max selection size repaint the results so choices
                        // are replaced with the max selection reached message
                        this.updateResults(true);
                    }
                    this.positionDropdown();
                } else {
                    // if nothing left to select close
                    this.close();
                    this.search.width(10);
                }
            }

            // since its not possible to select an element that has already been
            // added we do not need to check if this is a new element before firing change
            this.triggerChange({ added: data });

            if (!options || !options.noFocus)
                this.focusSearch();
        },

        // multi
        cancel: function () {
            this.close();
            this.focusSearch();
        },

        addSelectedChoice: function (data) {
            var enableChoice = !data.locked,
                enabledItem = $(
                    "<li class='select2-search-choice'>" +
                        "    <div></div>" +
                        "    <a href='#' onclick='return false;' class='select2-search-choice-close' tabindex='-1'></a>" +
                        "</li>"),
                disabledItem = $(
                    "<li class='select2-search-choice select2-locked'>" +
                        "<div></div>" +
                        "</li>");
            var choice = enableChoice ? enabledItem : disabledItem,
                id = this.id(data),
                val = this.getVal(),
                formatted,
                cssClass;

            formatted=this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
            if (formatted != undefined) {
                choice.find("div").replaceWith("<div>"+formatted+"</div>");
            }
            cssClass=this.opts.formatSelectionCssClass(data, choice.find("div"));
            if (cssClass != undefined) {
                choice.addClass(cssClass);
            }

            if(enableChoice){
                choice.find(".select2-search-choice-close")
                    .on("mousedown", killEvent)
                    .on("click dblclick", this.bind(function (e) {
                        if (!this.isInterfaceEnabled()) return;

                        $(e.target).closest(".select2-search-choice").fadeOut('fast', this.bind(function(){
                            this.unselect($(e.target));
                            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                            this.close();
                            this.focusSearch();
                        })).dequeue();
                        killEvent(e);
                    })).on("focus", this.bind(function () {
                        if (!this.isInterfaceEnabled()) return;
                        this.container.addClass("select2-container-active");
                        this.dropdown.addClass("select2-drop-active");
                    }));
            }

            choice.data("select2-data", data);
            choice.insertBefore(this.searchContainer);

            val.push(id);
            this.setVal(val);
        },

        // multi
        unselect: function (selected) {
            var val = this.getVal(),
                data,
                index;
            selected = selected.closest(".select2-search-choice");

            if (selected.length === 0) {
                throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
            }

            data = selected.data("select2-data");

            if (!data) {
                // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
                // and invoked on an element already removed
                return;
            }

            while((index = indexOf(this.id(data), val)) >= 0) {
                val.splice(index, 1);
                this.setVal(val);
                if (this.select) this.postprocessResults();
            }

            var evt = $.Event("select2-removing");
            evt.val = this.id(data);
            evt.choice = data;
            this.opts.element.trigger(evt);

            if (evt.isDefaultPrevented()) {
                return;
            }

            selected.remove();

            this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
            this.triggerChange({ removed: data });
        },

        // multi
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var val = this.getVal(),
                choices = this.results.find(".select2-result"),
                compound = this.results.find(".select2-result-with-children"),
                self = this;

            choices.each2(function (i, choice) {
                var id = self.id(choice.data("select2-data"));
                if (indexOf(id, val) >= 0) {
                    choice.addClass("select2-selected");
                    // mark all children of the selected parent as selected
                    choice.find(".select2-result-selectable").addClass("select2-selected");
                }
            });

            compound.each2(function(i, choice) {
                // hide an optgroup if it doesnt have any selectable children
                if (!choice.is('.select2-result-selectable')
                    && choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
                    choice.addClass("select2-selected");
                }
            });

            if (this.highlight() == -1 && noHighlightUpdate !== false){
                self.highlight(0);
            }

            //If all results are chosen render formatNoMAtches
            if(!this.opts.createSearchChoice && !choices.filter('.select2-result:not(.select2-selected)').length > 0){
                if(!data || data && !data.more && this.results.find(".select2-no-results").length === 0) {
                    if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
                        this.results.append("<li class='select2-no-results'>" + self.opts.formatNoMatches(self.search.val()) + "</li>");
                    }
                }
            }

        },

        // multi
        getMaxSearchWidth: function() {
            return this.selection.width() - getSideBorderPadding(this.search);
        },

        // multi
        resizeSearch: function () {
            var minimumWidth, left, maxWidth, containerLeft, searchWidth,
                sideBorderPadding = getSideBorderPadding(this.search);

            minimumWidth = measureTextWidth(this.search) + 10;

            left = this.search.offset().left;

            maxWidth = this.selection.width();
            containerLeft = this.selection.offset().left;

            searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;

            if (searchWidth < minimumWidth) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth < 40) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth <= 0) {
                searchWidth = minimumWidth;
            }

            this.search.width(Math.floor(searchWidth));
        },

        // multi
        getVal: function () {
            var val;
            if (this.select) {
                val = this.select.val();
                return val === null ? [] : val;
            } else {
                val = this.opts.element.val();
                return splitVal(val, this.opts.separator);
            }
        },

        // multi
        setVal: function (val) {
            var unique;
            if (this.select) {
                this.select.val(val);
            } else {
                unique = [];
                // filter out duplicates
                $(val).each(function () {
                    if (indexOf(this, unique) < 0) unique.push(this);
                });
                this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
            }
        },

        // multi
        buildChangeDetails: function (old, current) {
            var current = current.slice(0),
                old = old.slice(0);

            // remove intersection from each array
            for (var i = 0; i < current.length; i++) {
                for (var j = 0; j < old.length; j++) {
                    if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
                        current.splice(i, 1);
                        if(i>0){
                            i--;
                        }
                        old.splice(j, 1);
                        j--;
                    }
                }
            }

            return {added: current, removed: old};
        },


        // multi
        val: function (val, triggerChange) {
            var oldData, self=this;

            if (arguments.length === 0) {
                return this.getVal();
            }

            oldData=this.data();
            if (!oldData.length) oldData=[];

            // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
            if (!val && val !== 0) {
                this.opts.element.val("");
                this.updateSelection([]);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange({added: this.data(), removed: oldData});
                }
                return;
            }

            // val is a list of ids
            this.setVal(val);

            if (this.select) {
                this.opts.initSelection(this.select, this.bind(this.updateSelection));
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(oldData, this.data()));
                }
            } else {
                if (this.opts.initSelection === undefined) {
                    throw new Error("val() cannot be called if initSelection() is not defined");
                }

                this.opts.initSelection(this.opts.element, function(data){
                    var ids=$.map(data, self.id);
                    self.setVal(ids);
                    self.updateSelection(data);
                    self.clearSearch();
                    if (triggerChange) {
                        self.triggerChange(self.buildChangeDetails(oldData, self.data()));
                    }
                });
            }
            this.clearSearch();
        },

        // multi
        onSortStart: function() {
            if (this.select) {
                throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
            }

            // collapse search field into 0 width so its container can be collapsed as well
            this.search.width(0);
            // hide the container
            this.searchContainer.hide();
        },

        // multi
        onSortEnd:function() {

            var val=[], self=this;

            // show search and move it to the end of the list
            this.searchContainer.show();
            // make sure the search container is the last item in the list
            this.searchContainer.appendTo(this.searchContainer.parent());
            // since we collapsed the width in dragStarted, we resize it here
            this.resizeSearch();

            // update selection
            this.selection.find(".select2-search-choice").each(function() {
                val.push(self.opts.id($(this).data("select2-data")));
            });
            this.setVal(val);
            this.triggerChange();
        },

        // multi
        data: function(values, triggerChange) {
            var self=this, ids, old;
            if (arguments.length === 0) {
                return this.selection
                    .find(".select2-search-choice")
                    .map(function() { return $(this).data("select2-data"); })
                    .get();
            } else {
                old = this.data();
                if (!values) { values = []; }
                ids = $.map(values, function(e) { return self.opts.id(e); });
                this.setVal(ids);
                this.updateSelection(values);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(old, this.data()));
                }
            }
        }
    });

    $.fn.select2 = function () {

        var args = Array.prototype.slice.call(arguments, 0),
            opts,
            select2,
            method, value, multiple,
            allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search"],
            valueMethods = ["opened", "isFocused", "container", "dropdown"],
            propertyMethods = ["val", "data"],
            methodsMap = { search: "externalSearch" };

        this.each(function () {
            if (args.length === 0 || typeof(args[0]) === "object") {
                opts = args.length === 0 ? {} : $.extend({}, args[0]);
                opts.element = $(this);

                if (opts.element.get(0).tagName.toLowerCase() === "select") {
                    multiple = opts.element.prop("multiple");
                } else {
                    multiple = opts.multiple || false;
                    if ("tags" in opts) {opts.multiple = multiple = true;}
                }

                select2 = multiple ? new MultiSelect2() : new SingleSelect2();
                select2.init(opts);
            } else if (typeof(args[0]) === "string") {

                if (indexOf(args[0], allowedMethods) < 0) {
                    throw "Unknown method: " + args[0];
                }

                value = undefined;
                select2 = $(this).data("select2");
                if (select2 === undefined) return;

                method=args[0];

                if (method === "container") {
                    value = select2.container;
                } else if (method === "dropdown") {
                    value = select2.dropdown;
                } else {
                    if (methodsMap[method]) method = methodsMap[method];

                    value = select2[method].apply(select2, args.slice(1));
                }
                if (indexOf(args[0], valueMethods) >= 0
                    || (indexOf(args[0], propertyMethods) && args.length == 1)) {
                    return false; // abort the iteration, ready to return first matched value
                }
            } else {
                throw "Invalid arguments to select2 plugin: " + args;
            }
        });
        return (value === undefined) ? this : value;
    };

    // plugin defaults, accessible to users
    $.fn.select2.defaults = {
        width: "copy",
        loadMorePadding: 0,
        closeOnSelect: true,
        openOnEnter: true,
        containerCss: {},
        dropdownCss: {},
        containerCssClass: "",
        dropdownCssClass: "",
        formatResult: function(result, container, query, escapeMarkup) {
            var markup=[];
            markMatch(result.text, query.term, markup, escapeMarkup);
            return markup.join("");
        },
        formatSelection: function (data, container, escapeMarkup) {
            return data ? escapeMarkup(data.text) : undefined;
        },
        sortResults: function (results, container, query) {
            return results;
        },
        formatResultCssClass: function(data) {return undefined;},
        formatSelectionCssClass: function(data, container) {return undefined;},
        formatNoMatches: function () { return "No matches found"; },
        formatInputTooShort: function (input, min) { var n = min - input.length; return "Please enter " + n + " more character" + (n == 1? "" : "s"); },
        formatInputTooLong: function (input, max) { var n = input.length - max; return "Please delete " + n + " character" + (n == 1? "" : "s"); },
        formatSelectionTooBig: function (limit) { return "You can only select " + limit + " item" + (limit == 1 ? "" : "s"); },
        formatLoadMore: function (pageNumber) { return "Loading more results..."; },
        formatSearching: function () { return "Searching..."; },
        minimumResultsForSearch: 0,
        minimumInputLength: 0,
        maximumInputLength: null,
        maximumSelectionSize: 0,
        id: function (e) { return e.id; },
        matcher: function(term, text) {
            return stripDiacritics(''+text).toUpperCase().indexOf(stripDiacritics(''+term).toUpperCase()) >= 0;
        },
        separator: ",",
        tokenSeparators: [],
        tokenizer: defaultTokenizer,
        escapeMarkup: defaultEscapeMarkup,
        blurOnChange: false,
        selectOnBlur: false,
        adaptContainerCssClass: function(c) { return c; },
        adaptDropdownCssClass: function(c) { return null; },
        nextSearchTerm: function(selectedObject, currentSearchTerm) { return undefined; }
    };

    $.fn.select2.ajaxDefaults = {
        transport: $.ajax,
        params: {
            type: "GET",
            cache: false,
            dataType: "json"
        }
    };

    // exports
    window.Select2 = {
        query: {
            ajax: ajax,
            local: local,
            tags: tags
        }, util: {
            debounce: debounce,
            markMatch: markMatch,
            escapeMarkup: defaultEscapeMarkup,
            stripDiacritics: stripDiacritics
        }, "class": {
            "abstract": AbstractSelect2,
            "single": SingleSelect2,
            "multi": MultiSelect2
        }
    };

}(jQuery));
;
;
/* module-key = 'com.atlassian.auiplugin:aui-select2', location = 'js/aui-select2.js' */
/**
 * Wraps a vanilla Select2 with ADG _style_, as an auiSelect2 method on jQuery objects.
 *
 * @since 5.2
 */
(function ($) {

    /**
     * We make a copy of the original select2 so that later we might re-specify $.fn.auiSelect2 as $.fn.select2. That
     * way, calling code will be able to call $thing.select2() as if they were calling the original library,
     * and ADG styling will just magically happen.
     */
    var originalSelect2 = $.fn.select2;

    // AUI-specific classes
    var auiContainer = 'aui-select2-container';
    var auiDropdown = 'aui-select2-drop aui-dropdown2 aui-style-default';
    var auiHasAvatar = 'aui-has-avatar';

    $.fn.auiSelect2 = function (first) {
        var updatedArgs;

        if ($.isPlainObject(first)) {
            var auiOpts = $.extend({}, first);
            var auiAvatarClass = auiOpts.hasAvatar ? ' ' + auiHasAvatar : '';
            //add our classes in addition to those the caller specified
            auiOpts.containerCssClass  = auiContainer + auiAvatarClass + (auiOpts.containerCssClass ? ' ' + auiOpts.containerCssClass : '');
            auiOpts.dropdownCssClass  = auiDropdown + auiAvatarClass + (auiOpts.dropdownCssClass  ? ' ' + auiOpts.dropdownCssClass : '');
            updatedArgs = Array.prototype.slice.call(arguments, 1);
            updatedArgs.unshift(auiOpts);
        }
        else if (!arguments.length) {
            updatedArgs = [{
                containerCssClass: auiContainer,
                dropdownCssClass: auiDropdown
            }];
        }
        else {
            updatedArgs = arguments;
        }

        return originalSelect2.apply(this, updatedArgs);
    };

})(AJS.$);
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:invites-resources', location = 'feature/invites/invite-hipchat-service.js' */
define('hipchat/invite/service', [
    'hipchat/admin/configure-integration-data',
    'jquery',
    'underscore'
], function (
    integrationData,
    $,
    _
) {

    var MAX_INVITATIONS_PER_REQUEST = 24;
    var MAX_USER_PRE_POPULATION_COUNT = 12;

    var users = [];
    var events = $({});
    var uiConfig = {};

    var routes = {
        inviteUsersURL: AJS.contextPath() + '/rest/hipchat/integration/latest/users/invite'
    };

    function getMaxInvitationsPerRequest() {
        return MAX_INVITATIONS_PER_REQUEST;
    }

    function getUsers() {
        return users;
    }

    function findUser(username) {
        return _.find(users, function(userInList) {
            if (userInList.username == username) {
                return userInList;
            }
        });
    }

    function addUser(user) {
        user.username = $("<div/>").text(user.username).html();
        var foundUser = findUser(user.username);
        if (!_.contains(users, foundUser)) {
            users.push(user);
            events.trigger('user-added', user);
            checkInvitationLimit();
        }
    }

    function removeUser(username) {
        var user = findUser(username);

        if(user.isSuggested) {
            AJS.trigger('analyticsEvent', {name: 'notifications.hipchat.user.invite.remove.suggested', data: {}});
        }

        if (_.contains(users, user)) {
            users = _.filter(users, function(userInList) {
                return userInList.username != username;
            });
            events.trigger('user-removed', user.username);
            checkInvitationLimit();
        }
    }

    function checkInvitationLimit() {
        var userCount = users.length;
        if (userCount >= MAX_INVITATIONS_PER_REQUEST) {
            $("#invite-users-picker-container").hide();
            $("#inviation-limit-message").show();
        } else {
            $("#inviation-limit-message").hide();
            $("#invite-users-picker-container").show();
        }
    }

    function clear() {
        users = [];
        events.off();
    }

    function sendInvitations() {
        AJS.$("#invite-users-picker-container input[type='text']").prop("disabled", true);
        AJS.$('#hipchat-invite-form').on('select2-opening', function(e) { e.preventDefault(); });
        uiConfig.invitationProcessingStartedRenderer.call();
        var usernames = _.map(getUsers(), function(user) {
            return user.username;
        });
        var userNamesJson = JSON.stringify({"user-names": usernames});
        $.ajax({
            url: routes.inviteUsersURL,
            type: "POST",
            contentType: 'application/json',
            data: userNamesJson
        })
        .done(function(invitationResults) {
            for (var i = 0; i < invitationResults.resultSet.length; i++) {
                var result = invitationResults.resultSet[i];
                uiConfig.resultRenderer(result.userName, result.errorMessage);
            }
            uiConfig.renderDoneStep.call();
        })
        .fail(function(xhr) {
            var title = "Error";
            var messageText = AJS.escapeHtml(xhr.responseText);
            var messageReason = AJS.escapeHtml(AJS.format("Reason: {1} ({0})", xhr.status, xhr.statusText));
            uiConfig.errorRenderer.call(this, title, messageText, messageReason);
        })
        .always(function() {
            uiConfig.invitationProcessingCompletedRenderer.call();
        });
    }

    function handleDone() {
        var adminConfigurationPageURI = $("#admin-configuration-page-uri").val();
        window.location = adminConfigurationPageURI;
    }

    function initialise(
            invitationProcessingStartedRenderer,
            invitationProcessingCompletedRenderer,
            resultRenderer,
            renderDoneStep,
            errorRenderer) {
        uiConfig.invitationProcessingStartedRenderer = invitationProcessingStartedRenderer;
        uiConfig.invitationProcessingCompletedRenderer = invitationProcessingCompletedRenderer;
        uiConfig.resultRenderer = resultRenderer;
        uiConfig.renderDoneStep = renderDoneStep;
        uiConfig.errorRenderer = errorRenderer;
        routes.findInviteUsersURL = $("#hipchat-find-invite-users-uri").val() + "?max-results=" + MAX_USER_PRE_POPULATION_COUNT;
        $.ajax(routes.findInviteUsersURL, {
            type: "GET"
        })
            .done(function(userReferenceSet) {
                var listHasBeenManuallyPopulated = users.length > 0;
                if (listHasBeenManuallyPopulated) {
                    // QA decision: don't auto populate the list since it would be disruptive to the user.
                } else {
                    if (userReferenceSet.users) {
                        var userCount = userReferenceSet.users.length;
                        var usersToDisplay = Math.min(userCount, MAX_USER_PRE_POPULATION_COUNT);
                        for (var i = 0; i < usersToDisplay; i++) {
                            var userReference = userReferenceSet.users[i];
                            var uiUser = {
                                username: userReference.name,
                                avatarUrl: userReference.extraSmallPictureURI,
                                fullname: userReference.displayName,
                                email: userReference.email,
                                isSuggested: true
                            };
                            addUser(uiUser);
                        }
                    }
                }
            });
    }

    return {
        getMaxInvitationsPerRequest: getMaxInvitationsPerRequest,
        getUsers: getUsers,
        addUser: addUser,
        removeUser: removeUser,
        clear: clear,
        initialise: initialise,
        sendInvitations: sendInvitations,
        handleDone: handleDone,
        events: events
    }
});
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:invites-resources', location = 'feature/invites/invite-hipchat.js' */
require([
        'hipchat/invite/service'
    ],
    /**
     * Internal ui integration services for invite configuration.
     *
     * @tainted HipChat.Templates.Configuration (soy template)
     */
    function (inviteService) {
        'use strict';

        AJS.toInit(function ($) {
            var form = $('#hipchat-invite-form');
            var inviteeTemplate = HipChat.Templates.Configuration.invitee;
            var inviteeList = form.find('.hipchat-invitee-list');
            var sendInvitesButton = form.find('.send-invites-button');
            var cancelButton = form.find('.cancel');
            var doneButton = form.find('.done-button');
            var authorizeNotNowLink = $('#authorize-not-now-link');
            var inviteNotNowLink = $('#invite-not-now-link');

            window.onbeforeunload = null; // Prevent the "Are you sure you want to navigate away" dialog from appearing

            inviteNotNowLink.click(function() {
                AJS.trigger('analyticsEvent', {name: 'notifications.hipchat.user.invite.wizard.dropout.invite.notnow', data: {}});
            });

            authorizeNotNowLink.click(function() {
                AJS.trigger('analyticsEvent', {name: 'notifications.hipchat.user.invite.wizard.dropout.authorize.notnow', data: {}});
            });

            var maxInvitationsPerRequest = inviteService.getMaxInvitationsPerRequest();
            $("#invite-explanation-message").html(AJS.format("Inviting your teammates to HipChat creates a HipChat account and sends them an activation email. Note that only {0} invitations can be sent at a time, but you can always return here to invite more users.", maxInvitationsPerRequest));

            if (form.length == 0) {
                return;
            }

            form.on('user-picker-user-selected', function (e, user) {
                inviteService.addUser(user);
            });
            inviteeList.on('click', '.remove-invite-button', function (e) {
                e.preventDefault();
                var invitee = $(this).closest('.hipchat-invitee');
                inviteService.removeUser(invitee.attr('data-username'));
            });

            // Tooltips
            $('.hipchat-invitee-name-container').tipsy({live: true, gravity: 's'});
            $('.hipchat-invitee .email-container, .hipchat-invitee .aui-lozenge').tipsy({live: true, gravity: 'n'});

            function getEmailDomain(email) {
                var atIdx;
                if(email && (atIdx = email.indexOf('@')) && atIdx >= 0) {
                    return email.substr(atIdx);
                }
                // Fallback
                return email;
            }

            function renderUser(e, user) {
                if(!user.emailDomain) {
                    user.emailDomain = getEmailDomain(user.email);
                }
                inviteeList.append(inviteeTemplate(user));
                sendInvitesButton.prop('disabled', false);
                sendInvitesButton.removeAttr('aria-disabled');
            }

            function removeUser(e, username) {
                var invitee = inviteeList.find("[data-username='" + username + "']");
                invitee.remove();
                if (!inviteService.getUsers().length) {
                    sendInvitesButton.prop('disabled', true);
                    sendInvitesButton.attr('aria-disabled', true);
                }
            }

            function invitationProcessingStartedRenderer() {
                sendInvitesButton.attr('aria-disabled', true);

                var inviteProcessingIdleIndicators = $("[data-invite-processing='idle']");
                inviteProcessingIdleIndicators.addClass("hidden");

                var inviteProcessingRunningIndicators = $("[data-invite-processing='running']");
                inviteProcessingRunningIndicators.removeClass("hidden");

                var emailHolders = $(".email");
                emailHolders.hide();

                var removeButton = $(".remove-invite-button");
                removeButton.hide();
            }

            function invitationProcessingCompletedRenderer() {
                var inviteProcessingRunningIndicators = $("[data-invite-processing='running']");
                inviteProcessingRunningIndicators.addClass("hidden");

                var inviteProcessingIdleIndicators = $("[data-invite-processing='idle']");
                inviteProcessingIdleIndicators.removeClass("hidden");
            }

            function resultRenderer(userName, errorMessage) {
                var userDiv = $("[data-username='" + userName + "']");
                var successStatusHolder = userDiv.find(".aui-lozenge-success");
                var errorStatusHolder = userDiv.find(".aui-lozenge-current");
                if (errorMessage) {
                    errorStatusHolder.text("Unable to invite");
                    errorStatusHolder.show();
                    successStatusHolder.hide();

                    errorStatusHolder.tooltip({
                        title: function () {
                            return errorMessage;
                        }
                    });
                } else {
                    successStatusHolder.text("sent");
                    successStatusHolder.show();
                    errorStatusHolder.hide();
                }
            }

            function renderDoneStep() {
                sendInvitesButton.hide();
                cancelButton.hide();
                doneButton.show();
                doneButton.removeAttr('aria-disabled');
                doneButton.removeAttr('disabled');
            }

            function errorRenderer(title, messageText, messageReason) {
                var messageContainer = $('#invite-banner-messages');
                messageContainer.empty();
                AJS.messages.error("#invite-banner-messages", {
                    title: title,
                    body: "<p>" + messageText + "<br/>" + messageReason + "</p>"
                });
            }

            inviteService.events.on('user-added.invite-hipchat', renderUser);
            inviteService.events.on('user-removed', removeUser);

            inviteService.initialise(
                invitationProcessingStartedRenderer,
                invitationProcessingCompletedRenderer,
                resultRenderer,
                renderDoneStep,
                errorRenderer);

            form.on('submit', function (e) {
                e.preventDefault();
                inviteService.sendInvitations();
            });

            doneButton.click(function (e) {
                e.preventDefault();
                inviteService.handleDone();
            });
        });
    });
;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:invites-resources', location = 'feature/invites/user-picker.js' */
define('hipchat/invite/user-picker', [
    'jquery'
], function ($) {

    return function (field, form, options) {
        field = $(field);
        form = $(form);

        field.auiSelect2({
            ajax: {
                url: options.url,
                dataType: 'json',
                delay: 200,
                data: options.params,
                results: options.results,
                cache: true
            },
            multiple: true,
            minimumInputLength: 2
        });

        field.select2('focus');

        function onSelect(e) {
            var user = options.choice(e.choice);

            if(user.always) {
                // looks like a promise, so must be a duck,  wait for it to be done...
                user.always(function(user) {
                    if (!user.isRejected || !user.isRejected())
                        selectUser(user);
                });
            } else {
                // assume it's must be a user
                selectUser(user);
            }
        }

        function selectUser(user) {
            form.trigger('user-picker-user-selected', user);
            field.select2('val', '');
        }

        field.on('selected', onSelect);
    };

});
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:amd', location = 'js/lib/amd/jira/jira-components-query-amd.js' */
define("hipchat/jira/query-component", function () {
    return JIRA.Components.Query;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:amd', location = 'js/lib/amd/jira/jira-issues-amd.js' */
define("hipchat/jira/issues/searcher-collection", function () {
    return JIRA.Issues.SearcherCollection;
});

define("hipchat/jira/issues/query-state-model", function () {
    return JIRA.Issues.QueryStateModel;
});

define("hipchat/jira/issues/criteria-model", function () {
    return JIRA.Issues.CriteriaModel;
});

define("hipchat/jira/issues/criteria-view", function () {
    return JIRA.Issues.CriteriaView;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:amd', location = 'js/lib/amd/hipchat-scopes-provider-amd.js' */
define("hipchat/scopes-provider", function () {
    return HipChat.ScopesProvider;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:global', location = 'js/base.js' */
/**
 * Top level configuration/information object.
 */
define("hipchat/base", [ "underscore", "backbone", "exports" ], function (_, Backbone, exports) {
    if (typeof HipChat === "undefined" || !HipChat) {
        window.HipChat = {};
    }

    /**
     * Provide our own sub classes of the backbone objects for common methods.
     */
    function setupBackbone() {
        exports.View = Backbone.View;

        exports.Model = Backbone.Model.extend({

            saveWrapper: function(saveFunction) {
                this.trigger("waitingToSave");
                saveFunction.apply(this);
                this.trigger("saved");
            },

            addDebounceSave: function(milliseconds) {
                this.save = _.wrap(_.debounce(this.save, milliseconds), this.saveWrapper);
            },

            /**
             * Observes this model for request/sync/error events and logs the beginning and the end.
             * This is mainly used for testing to tell page objects when ajax operations have finished.
             *
             * @param {string} [traceSuffix] suffix to append to the trace key
             */
            traceAjaxRequests: function(traceSuffix) {
                var attribute = null;
                var request = attribute ? "request:" + attribute : "request";
                var sync = attribute ? "sync:" + attribute : "sync";
                var error = attribute ? "error:" + attribute : "error";
                var observed = this;

                observed.on(request, function () {
                    JIRA.trace("ajax.request.started." + traceSuffix);
                }, this);

                observed.on(sync + " " + error, function () {
                    JIRA.trace("ajax.request.completed." + traceSuffix);
                }, this);
            }

        });

        exports.Collection = Backbone.Collection;
        exports.Events = Backbone.Events;
    }

    setupBackbone();
});;
;
/* module-key = 'com.atlassian.plugins.base-hipchat-integration-plugin:hipchat-installed-scopes', location = 'install/hipchat-scopes-provider.js' */
(function() {

    function ScopesProvider() {

        var pluginKey = "com.atlassian.plugins.base-hipchat-integration-plugin";
        var wrmData = WRM.data instanceof Function ? WRM.data : WRM.data.claim;
        var installedScopes = wrmData(pluginKey + ":hipchat-installed-scopes.scopes");

        function hasScope(scopeName) {
            return installedScopes[scopeName] !== undefined;
        }

        return {
            hasScope: hasScope
        }
    }

    // exports
    window.HipChat = window.HipChat || {};
    window.HipChat.ScopesProvider = ScopesProvider();

})();;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:widget-roomselector', location = 'js/widget/roomselector/roommapping-service.js' */
define("hipchat/widget/roomselector/roommapping-service",
[
    "ajs",
    "jquery",
    "underscore"
],
function (
    AJS,
    $,
    _
) {

    var roomServicePromise = (function() {
        var roomMap = {}; // { "roomId": { roomId: "roomId", roomName: "roomName" }, ... }
        var rooms = []; // cache of [ { id: "roomId", text: "roomName } ] for use by select2 query. Derived from roomMap
        var listeners = {};

        function rebuildRoomData() {
            rooms = _.map(roomMap, function(item) { return {id: item.roomId, text: item.roomName, isPrivate: item.isPrivate}; });
            rooms = _.sortBy(rooms, function (item) { return item.text.toLocaleLowerCase(); });
            _.each(listeners, function(fn) {
                fn.apply(null, [ rooms ]);
            });
        }

        function createRoom(name) {
            // Note that we set cache to false to prevent IE9 caching previous results. See CONFDEV-29008.
            var dfd = $.Deferred();
            $.ajax({
                url: AJS.contextPath() + '/rest/hipchat/integration/1.0/rooms?roomName=' + name,
                type: 'POST',
                dataType: 'json',
                cache: false
            }).done(function(data) {
                var room = {
                    roomId: data.id,
                    roomName: data.name
                };
                addRoom(room);

                dfd.resolve(room);
            }).fail(function(err) {
                dfd.reject(err);
            });

            return dfd;
        }

        function addRoom(room) {
            roomMap[room.roomId] = room;
            rebuildRoomData();
        }

        function removeRoom(room) {
            delete roomMap[room.roomId];
            rebuildRoomData();
        }

        function onChange(fn) {
            listeners[fn] = fn;
        }

        function offChange(fn) {
            delete listeners[fn];
        }

        function getRoomById(roomId) {
            return roomMap[roomId];
        }

        function getRooms() {
            return rooms;
        }

        var roomService = {
            createRoom: createRoom,
            addRoom: addRoom,
            removeRoom: removeRoom,
            getRoomById: getRoomById,
            getRooms: getRooms,
            onChange: onChange,
            offChange: offChange
        };

        var roomsAvailablePromise = (function (isHipChatConfigured, projectKey) {
            var roomLoader = $.Deferred();
            if (isHipChatConfigured) {
                // Note that we set cache to false to prevent IE9 caching previous results. See CONFDEV-29008.
                $.ajax({
                    url: AJS.contextPath() + '/rest/hipchat/integration/1.0/rooms?projectKey=' + (_.isString(projectKey) ?
                            projectKey : ""),
                    dataType: 'json',
                    cache: false
                }).done(function (data) {
                    roomMap = _.object(_.map(data, function (item) {
                        return [item.id, {
                            roomId: item.id,
                            roomName: item.name,
                            isPrivate: item["private"]
                        }];
                    }));
                    rebuildRoomData(roomMap);
                    roomLoader.resolve(roomService);
                }).fail(function (err) {
                    roomLoader.reject(err);
                });
            } else {
                roomLoader.resolve(roomService);
            }
            return roomLoader.promise();
        });

        var promises = {};
        var promiseBuilder = function (isHipChatConfigured, projectKey) {
            if (promises[projectKey] === undefined) {
                promises[projectKey] = roomsAvailablePromise(isHipChatConfigured, projectKey);
            }

            return promises[projectKey];
        };
        promiseBuilder.reset = function() {
            promises = {};
        };

        return promiseBuilder;
    })();

    return {
        roomServicePromise: roomServicePromise
    };
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:widget-roomselector', location = 'js/widget/roomselector/roomselector-view.js' */
define("hipchat/widget/roomselector/roomselector-view",
        [
            "jquery",
            "backbone",
            "hipchat/widget/roomselector/roommapping-service",
            "hipchat/scopes-provider"
        ], function (
                $,
                Backbone,
                RoomMappingService,
                HipChatScopesProvider
        ) {

            var PRIVATE_ROOM_CLASS = "private-room";
            var PUBLIC_ROOM_CLASS = "public-room";

            function escapeResult(markup) {
                var replace_map = {
                    '\\': '&#92;',
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;',
                    "/": '&#47;'
                };

                return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
                    return replace_map[match];
                });
            }

            function getProjectKey() {
                return $("[name='projectKey']").attr("content");
            }

            function makeSuggestionsHandler(loggedIn, hasManageRoomScope) {
                //this is only called when the integration is installed
                var roomServicePromise = RoomMappingService.roomServicePromise(true, getProjectKey());

                return Class.extend({
                    _formatResponse: function(rooms, query, showCreateRoom) {
                        var groupDescriptors = [];
                        if (rooms.length > 0) {

                            var suggestionsGroupDescriptor = new AJS.GroupDescriptor({
                                weight: 0,
                                label: loggedIn? "All rooms" :
                                        "Public rooms"
                            });

                            _.each(rooms, function(item) {
                                suggestionsGroupDescriptor.addItem(new AJS.ItemDescriptor({
                                    value: item.id,
                                    label: item.text,
                                    html: escapeResult(item.text),
                                    title: item.text,
                                    meta: {
                                        roomId: item.id,
                                        roomName: item.roomName || item.text,
                                        existing: true
                                    },
                                    styleClass: item.isPrivate ? PRIVATE_ROOM_CLASS : PUBLIC_ROOM_CLASS
                                }));
                            });

                            groupDescriptors.push(suggestionsGroupDescriptor);
                        }


                        if (!loggedIn) {
                            var roomActionsGroupDescriptor = new AJS.GroupDescriptor({
                                weight: 1,
                                footerHtml: JIRA.Templates.HipChat.RoomSelector.loginDropdownFooter({
                                    hasManageRoomScope: hasManageRoomScope
                                })
                            });
                            roomActionsGroupDescriptor.addItem(new AJS.ItemDescriptor({
                                label: "filler",
                                html: "filler",
                                highlighted: true
                            }));

                            groupDescriptors.push(roomActionsGroupDescriptor);
                        } else if (showCreateRoom) {
                            var createRoomGroupDescriptor = new AJS.GroupDescriptor({
                                weight: 1,
                                label: "Create room"
                            });

                            createRoomGroupDescriptor.addItem(new AJS.ItemDescriptor({
                                value: query,
                                label: query,
                                html: escapeResult(query) + "<span class='aui-lozenge aui-lozenge-subtle aui-lozenge-complete'>new</span>",
                                title: query,
                                meta: {
                                    roomId: query,
                                    roomName: query,
                                    existing: false
                                },
                                highlighted: true,
                                styleClass: PUBLIC_ROOM_CLASS
                            }));

                            groupDescriptors.push(createRoomGroupDescriptor);
                        }

                        return groupDescriptors;
                    },

                    execute: function(query) {
                        var deferred = jQuery.Deferred();
                        var self = this;
                        roomServicePromise.done(function(roomService) {
                            var rooms = roomService.getRooms();
                            var searchStr = query.toLocaleLowerCase();
                            var exactMatch = false;
                            var filteredRooms = _.filter(rooms, function(item) {
                                var lowerCasedItem = item.text.toLocaleLowerCase();
                                if (lowerCasedItem === searchStr) {
                                    exactMatch = true;
                                }

                                return lowerCasedItem.indexOf(searchStr) >= 0;
                            });

                            var showCreateRoom = hasManageRoomScope && (!exactMatch && searchStr.length > 0);
                            var suggestions = self._formatResponse(filteredRooms, query, showCreateRoom);

                            JIRA.trace("ajax.request.completed.RoomSelector");
                            deferred.resolve(suggestions, query);
                        }).fail(function(err) {
                            if (loggedIn && (err.status == 403 || err.status == 401)) {
                                var dialog = new AJS.Dialog({
                                    width: 600,
                                    height: 200,
                                    id: "oauth-failure",
                                    closeOnOutsideClick: true
                                });
                                dialog.addHeader("Authentication Failure");
                                dialog.addPanel("panel 0", JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage({}));
                                dialog.show();
                                deferred.reject(err);
                            } else {
                                var errorGroupDescriptor = new AJS.GroupDescriptor({
                                    weight: 1,
                                    footerHtml: JIRA.Templates.HipChat.RoomSelector.errorDropdownFooter({})
                                });
                                errorGroupDescriptor.addItem(new AJS.ItemDescriptor({
                                    label: "filler",
                                    html: "filler",
                                    highlighted: true
                                }));

                                deferred.resolve([errorGroupDescriptor], query);
                            }
                        });

                        return deferred;
                    }
                });
            }

            function initRoomSelector($el, loggedIn, maxWidth) {

                var hasManageRoomScope = HipChatScopesProvider.hasScope("manage_rooms");
                return new AJS.SingleSelect({
                    element: $el,
                    width: maxWidth,
                    suggestionsHandler: makeSuggestionsHandler(loggedIn, hasManageRoomScope),
                    submitInputVal: true,
                    matchingStrategy: "(.*)()({0})(.*)" // expected groups: prefix, spaceOrParenthesis (ignored), match, suffix
                });
            }

            var RoomSelectorView = Backbone.View.extend({

                events: {
                },

                initialize: function(options) {

                    if (!this.$el.length) {
                        return;
                    }

                    this.roomSelector = initRoomSelector(this.$el, options.loggedIn, options.maxWidth);
                    var self = this;
                    this.roomSelector.model.$element.on("selected", function(e, itemDescriptor) {
                        if (itemDescriptor.properties.value !== "") {
                            self.roomSelector.$field.addClass(itemDescriptor.properties.styleClass);
                            self.trigger("change");
                        } else {
                            self.roomSelector.$field.removeClass(PUBLIC_ROOM_CLASS).removeClass(PRIVATE_ROOM_CLASS);
                            self.trigger("clear");
                        }
                    });

                    this.roomSelector.model.$element.on("unselect", function(e) {
                        self.trigger("clear");
                    });
                },

                getSelectedRoom: function() {
                    var selectedDescriptor = this.roomSelector.getSelectedDescriptor();
                    var meta = JSON.parse(selectedDescriptor.properties.meta);
                    return {
                        id: meta.roomId,
                        roomName: meta.roomName,
                        existing: meta.existing
                    };
                },

                clearSelectedRoom: function() {
                    this.roomSelector.clear();
                    this.roomSelector._deactivate(); // We need that to get the placeholder back
                }
            });


            return RoomSelectorView;
        });;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:widget-roomselector', location = 'soy/widget/roomselector/roomselector-client.soy' */
// This file was automatically generated from roomselector-client.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.RoomSelector.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.RoomSelector == 'undefined') { JIRA.Templates.HipChat.RoomSelector = {}; }


JIRA.Templates.HipChat.RoomSelector.loginDropdownFooter = function(opt_data, opt_ignored) {
  return '<div class="hipchat-login-dropdown-footer"><h6>' + soy.$$escapeHtml("Rooms") + '</h6><p>' + ((opt_data.hasManageRoomScope) ? soy.$$filterNoAutoescape("\x3ca href\x3d\x22#\x22 class\x3d\x22hipchat-user-link\x22\x3eConfirm access to your HipChat account\x3c/a\x3e, to view private rooms and create new rooms.") : soy.$$filterNoAutoescape("\x3ca href\x3d\x22#\x22 class\x3d\x22hipchat-user-link\x22\x3eConfirm access to your HipChat account\x3ca/\x3e, to view private rooms.")) + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.RoomSelector.loginDropdownFooter.soyTemplateName = 'JIRA.Templates.HipChat.RoomSelector.loginDropdownFooter';
}


JIRA.Templates.HipChat.RoomSelector.errorDropdownFooter = function(opt_data, opt_ignored) {
  return '<div class="hipchat-login-dropdown-footer error"><h6>' + soy.$$escapeHtml("Error") + '</h6><p>' + soy.$$escapeHtml("Failed to load the list of rooms from HipChat.") + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.RoomSelector.errorDropdownFooter.soyTemplateName = 'JIRA.Templates.HipChat.RoomSelector.errorDropdownFooter';
}
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:widget-roomselector', location = 'soy/issuepanel/issuepanel-client.soy' */
// This file was automatically generated from issuepanel-client.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.Project.IssuePanel.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.Project == 'undefined') { JIRA.Templates.HipChat.Project = {}; }
if (typeof JIRA.Templates.HipChat.Project.IssuePanel == 'undefined') { JIRA.Templates.HipChat.Project.IssuePanel = {}; }


JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription = function(opt_data, opt_ignored) {
  var output = '';
  var noOfMentionRooms__soy3 = opt_data.mentionedRooms.length;
  output += ((noOfMentionRooms__soy3 > 0) ? '<a id="hipchat-issue-mentions-list" href="' + soy.$$escapeHtml("/jira" + '/secure/HipChatMentionedRooms.jspa?issueKey=' + opt_data.issueKey) + '"' + ((opt_data.userLoggedIntoHipChat) ? 'class="trigger-dialog-large">' : 'class="trigger-dialog">') : '<span>') + soy.$$escapeHtml(AJS.format("Issue mentioned in {0} {0,choice,0#rooms|1#room|1\x3crooms}",noOfMentionRooms__soy3)) + ((noOfMentionRooms__soy3 > 0) ? '</a>' : '</span>');
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription';
}


JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails = function(opt_data, opt_ignored) {
  return '<div class="hipchat-dedicated-room"><div class="hipchat-dedicated-room-icon ' + ((opt_data.justLinked) ? 'success' : '') + '"><span class="aui-icon aui-icon-small aui-iconfont-approve"> </span>' + ((opt_data.dedicatedRoom.privateRoom) ? '<span class="aui-icon private-room"> </span>' : '<span class="aui-icon public-room"> </span>') + '</div><a href="#" class="hipchat-dedicated-room-name public-room hipchat-room-link-url" data-api-url="' + soy.$$escapeHtml(opt_data.dedicatedRoom.apiUrl) + '" data-room-id="' + soy.$$escapeHtml(opt_data.dedicatedRoom.roomId) + '" data-issue-id="' + soy.$$escapeHtml(opt_data.dedicatedRoom.issueId) + '" data-room="' + soy.$$escapeHtml(opt_data.dedicatedRoom.roomId) + '">' + soy.$$escapeHtml(opt_data.dedicatedRoom.name) + '</a>' + ((! opt_data.hideUnlink) ? '<a class="trash-dedicated-room" href="#" title="' + soy.$$escapeHtml("Unlink room") + '"><span class="aui-icon aui-icon-small aui-iconfont-remove-label">Delete</span></a>' : '') + '<div class="hc-button-spinner"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails';
}


JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm = function(opt_data, opt_ignored) {
  return '<div class="hipchat-no-dedicated-room">' + ((opt_data.canAssignRoom) ? '<div id="hipchat-dedicated-room-buttons" class="buttons-container">' + ((opt_data.canCreateRoom || opt_data.isAdmin) ? aui.buttons.button({text: "Create a room", extraClasses: 'hipchat-create-dedicated-room hipchat-issue-panel-button'}) : '') + '<a id="hipchat-select-dedicated-room" href="' + soy.$$escapeHtml("/jira" + '/secure/HipChatSelectRoom.jspa?issueKey=' + opt_data.issueKey) + '" class="hipchat-issue-panel-button hipchat-select-dedicated-room trigger-dialog-select-room">' + soy.$$escapeHtml("Choose a room") + '</a><div class="hc-button-spinner"></div></div>' : '<div>' + soy.$$escapeHtml("None") + '</div>') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm';
}


JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content">' + ((opt_data.action == 'create') ? '<p>' + soy.$$filterNoAutoescape("\x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#create-dedicated-room\x22\x3eConfirm access to your HipChat account\x3c/a\x3e to create a dedicated room for this issue.") + '</p>' : (opt_data.action == 'delete') ? '<p>' + soy.$$filterNoAutoescape("\x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#delete-dedicated-room\x22\x3eConfirm access to your HipChat account\x3c/a\x3e to delete the dedicated room for this issue.") + '</p>' : '') + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage';
}


JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content"><p>' + soy.$$filterNoAutoescape("Please \x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#create-dedicated-room\x22\x3ereconfirm access to your HipChat account\x3c/a\x3e.") + '</p></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom';
}


JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content"><p>' + soy.$$filterNoAutoescape("Please \x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22\x22\x3ereconfirm access to your HipChat account\x3c/a\x3e.") + '</p></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage';
}


JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content"><p>' + soy.$$filterNoAutoescape(AJS.format("HipChat integration \x3ca href\x3d\x22{0}\x22\x3ehas to be reinstalled\x3c/a\x3e in order to create dedicated rooms.","/jira" + '/plugins/servlet/hipchat/configure')) + '</p></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage';
}


JIRA.Templates.HipChat.Project.IssuePanel.invitee = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.invitee({username: opt_data.user.userKey, avatarUrl: opt_data.user.avatarUrl, fullname: opt_data.user.displayName, email: opt_data.user.emailAddress, emailDomain: opt_data.user.emailDomain});
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.invitee.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.invitee';
}
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'soy/invites/hipchat-invite-jira-support.soy' */
// This file was automatically generated from hipchat-invite-jira-support.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace HipChat.Templates.Invite.Support.
 */

if (typeof HipChat == 'undefined') { var HipChat = {}; }
if (typeof HipChat.Templates == 'undefined') { HipChat.Templates = {}; }
if (typeof HipChat.Templates.Invite == 'undefined') { HipChat.Templates.Invite = {}; }
if (typeof HipChat.Templates.Invite.Support == 'undefined') { HipChat.Templates.Invite.Support = {}; }


HipChat.Templates.Invite.Support.userLinkUrl = function(opt_data, opt_ignored) {
  return soy.$$escapeHtml("/jira") + '/secure/ViewProfile.jspa?name=' + soy.$$escapeHtml(opt_data.username);
};
if (goog.DEBUG) {
  HipChat.Templates.Invite.Support.userLinkUrl.soyTemplateName = 'HipChat.Templates.Invite.Support.userLinkUrl';
}
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'soy/issuepanel/issuepanel.soy' */
// This file was automatically generated from issuepanel.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.Project.IssuePanel.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.Project == 'undefined') { JIRA.Templates.HipChat.Project = {}; }
if (typeof JIRA.Templates.HipChat.Project.IssuePanel == 'undefined') { JIRA.Templates.HipChat.Project.IssuePanel = {}; }


JIRA.Templates.HipChat.Project.IssuePanel.hipChatPanel = function(opt_data, opt_ignored) {
  return '<div class="hipchat-issue-panel" data-issue-key="' + soy.$$escapeHtml(opt_data.issueKey) + '">' + ((! opt_data.hipChatConfigured) ? JIRA.Templates.HipChat.Project.IssuePanel.hipChatNotConfigured(opt_data) : (opt_data.jirauser && ! opt_data.hipChatUserName) ? soy.$$filterNoAutoescape("\x3ca href\x3d\x22#\x22 class\x3d\x22hipchat-user-link\x22\x3eConfirm access to your HipChat account\x3c/a\x3e for more information.") + '<p>' : (opt_data.privateRoom && opt_data.hipChatUserName && ! opt_data.personalToken) ? soy.$$filterNoAutoescape("\x3ca href\x3d\x22#\x22 class\x3d\x22hipchat-user-link\x22\x3eConfirm access to your HipChat account\x3c/a\x3e for more information.") + '<p>' : '<div id="hipchat-issue-panel-rooms-container" data-logged-in="' + soy.$$escapeHtml(opt_data.personalToken) + '" data-can-create-room="' + soy.$$escapeHtml(opt_data.canCreateRoom) + '" data-can-assign-room="' + soy.$$escapeHtml(opt_data.canAssignRoom) + '" data-hipchat-configured="' + soy.$$escapeHtml(opt_data.hipChatConfigured) + '"' + ((opt_data.hipChatUserName) ? 'data-hipchat-username="' + soy.$$escapeHtml(opt_data.hipChatUserName) + '"' : '') + ((opt_data.dedicatedRoom) ? 'data-dedicated-room-id="' + soy.$$escapeHtml(opt_data.dedicatedRoom.roomId) + '"' : '') + '><ul class="item-details">' + ((opt_data.privateRoom && opt_data.hipChatUserName && opt_data.personalToken && ! opt_data.userCanAccessPrivateRoom) ? soy.$$escapeHtml("The dedicated room for this issue is private.") + '<p>' : JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomSection({issueKey: opt_data.issueKey, dedicatedRoom: opt_data.dedicatedRoom, loggedIn: opt_data.personalToken, canCreateRoom: opt_data.canCreateRoom, canAssignRoom: opt_data.canAssignRoom, isAdmin: opt_data.isAdmin})) + ((opt_data.connectionStatus == 'CONNECTED') ? JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomSection(null) : '') + '</ul></div>') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.hipChatPanel.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.hipChatPanel';
}


JIRA.Templates.HipChat.Project.IssuePanel.hipChatNotConfigured = function(opt_data, opt_ignored) {
  var output = '<div id="hipchat-issue-panel-rooms-container" data-project-key="' + soy.$$escapeHtml(opt_data.projectKey) + '">';
  var configureUrl__soy62 = '' + ((opt_data.isAdmin) ? soy.$$escapeHtml("/jira" + '/plugins/servlet/hipchat/configure?source=issue-panel') : (opt_data.isProjectAdmin) ? soy.$$escapeHtml("/jira" + '/secure/ConfigureHipChat.jspa?source=issue-panel&projectKey=' + opt_data.projectKey) : '');
  output += '<p>' + soy.$$filterNoAutoescape(AJS.format("Do you want to discuss this issue? Connect to HipChat.",configureUrl__soy62)) + '</p><p>' + aui.buttons.button({id: 'hipchat-issue-panel-configure-button', text: "Connect", extraAttributes: 'data-configure-url="' + configureUrl__soy62 + '"'}) + '<a id="hipchat-issue-panel-hide" href="#">' + soy.$$escapeHtml("Dismiss") + '</a></p></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.hipChatNotConfigured.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.hipChatNotConfigured';
}


JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomSection = function(opt_data, opt_ignored) {
  return '<li id="hipchat-dedicated-room-section"><div class="hipchat-settings-button"><span class="aui-icon aui-icon-small aui-iconfont-configure hidden" id="hipchat-panel-settings"></span></div><dl><dt class="dedicated-room-label">' + soy.$$escapeHtml("Dedicated room") + ':</dt><dd class="hipchat-dedicated-room-content">' + ((opt_data.dedicatedRoom) ? JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails(opt_data) : JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm(opt_data)) + '</dd></dl><div id="hipchat-dedicated-room-footer"><div id="hipchat-dedicated-room-errors" class="errors"/><div id="dedicated-room-message-bar" /></div></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomSection.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomSection';
}


JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialog = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<h1>' + soy.$$escapeHtml("Choose a room") + '</h1>' + ((opt_data.hipChatUserName) ? '<div class="dialog-panel-body"><form class="hipchat-room-select-form aui"><div class="dialog-panel-body-header aui-item">' + soy.$$escapeHtml("Discuss this issue and be notified of any changes in a room of your choice.") + '</div><div class="field-group"><div id="hipchat-dedicated-room-select-container" class="hipchat-room-selector-container" ' + ((opt_data.hipChatUserName) ? 'data-hipchat-username="' + soy.$$escapeHtml(opt_data.hipChatUserName) + '"' : '') + '><select id="hipchat-dedicated-room-select" class="hidden hipchat-room-selector"><option value="" disabled selected>' + soy.$$escapeHtml("Select HipChat room") + '</option></select></div></div><div class="dialog-errors error"></div></form></div><div class="buttons-container form-footer">' + JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialogButtons(null) + '</div>' : '<div class="dialog-panel-body"><p>' + soy.$$filterNoAutoescape("\x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#choose-room\x22\x3eConfirm access to your HipChat account\x3c/a\x3e to choose a dedicated room for this issue.") + '</p></div>');
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialog.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialog';
}


JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialogButtons = function(opt_data, opt_ignored) {
  return '<div class="buttons"><button class="aui-button submit" id="hipchat-select-dedicated-room-dialog-submit">' + soy.$$escapeHtml("Select") + '</button><button class="aui-button aui-button-link cancel" id="hipchat-select-dedicated-room-dialog-close">' + soy.$$escapeHtml("Cancel") + '</button></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialogButtons.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.selectRoomDialogButtons';
}


JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomSection = function(opt_data, opt_ignored) {
  return '<li id="hipchat-mentioned-rooms-section"><dl><dt class="mentions-label">' + soy.$$escapeHtml("Other rooms:") + '</dt><dd class="hipchat-mentioned-rooms-content"><span class="aui-icon aui-icon-wait"></span></dd></dl></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomSection.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomSection';
}


JIRA.Templates.HipChat.Project.IssuePanel.loginMentionsDialog = function(opt_data, opt_ignored) {
  return '<div class="hipchat-mentions-dialog-login"><h6>' + soy.$$escapeHtml("HipChat discussions") + '</h6><p>' + soy.$$filterNoAutoescape("\x3ca href\x3d\x22#open-issue-mentions\x22 class\x3d\x22hipchat-user-link\x22\x3eConfirm access to your HipChat account\x3c/a\x3e to see issue mention details") + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.loginMentionsDialog.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.loginMentionsDialog';
}


JIRA.Templates.HipChat.Project.IssuePanel.errorPage = function(opt_data, opt_ignored) {
  var output = '<h1>' + soy.$$escapeHtml("HipChat discussions") + '</h1><div class="hipchat-mentions-dialog-content">';
  var param141 = '<ul>';
  var errorList143 = opt_data.errors;
  var errorListLen143 = errorList143.length;
  for (var errorIndex143 = 0; errorIndex143 < errorListLen143; errorIndex143++) {
    var errorData143 = errorList143[errorIndex143];
    param141 += '<li>' + soy.$$escapeHtml(errorData143) + '</li>';
  }
  param141 += '</ul>';
  output += aui.message.error({titleContent: "Failed to get issue mention details", content: param141});
  output += '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.errorPage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.errorPage';
}


JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomDialog = function(opt_data, opt_ignored) {
  var output = '<h1>' + soy.$$escapeHtml("HipChat discussions") + '</h1><div class="hipchat-mentions-dialog-content">';
  var roomsMentionsLength__soy155 = opt_data.mentionRooms.length;
  var roomsNotAvailable__soy156 = opt_data.totalRooms - roomsMentionsLength__soy155;
  output += '<h4>' + soy.$$escapeHtml(AJS.format("{0} {0,choice,0#mentions|1#mention|1\x3cmentions} in {1} {1,choice,0#rooms|1#room|1\x3crooms}",opt_data.issueMentions.length,roomsMentionsLength__soy155)) + '</h4>' + ((roomsNotAvailable__soy156 > 0) ? '<h7>' + soy.$$escapeHtml(AJS.format("There are mentions in {0} private room(s) you do not have access to.",roomsNotAvailable__soy156)) + '</h7>' : '') + '<table class="aui"><thead><tr><th id="hipchat-mentioned-author">' + soy.$$escapeHtml("Author") + '</th><th id="hipchat-mentioned-room">' + soy.$$escapeHtml("Room") + '</th><th id="hipchat-mentioned-message">' + soy.$$escapeHtml("Message") + '</th><th id="hipchat-mentioned-date">' + soy.$$escapeHtml("Date") + '</th></tr></thead><tbody>';
  var mentionList174 = opt_data.issueMentions;
  var mentionListLen174 = mentionList174.length;
  for (var mentionIndex174 = 0; mentionIndex174 < mentionListLen174; mentionIndex174++) {
    var mentionData174 = mentionList174[mentionIndex174];
    var mentionMessage__soy175 = mentionData174.message;
    var mentionRoom__soy176 = mentionData174.room;
    var mentionUser__soy177 = mentionData174.user;
    output += '<tr><td headers="hipchat-mentioned-author"><a href="#" class="hipchat-user-link-url" data-user-id="' + soy.$$escapeHtml(mentionUser__soy177.id) + '" data-api-url="' + soy.$$escapeHtml(opt_data.apiUrl) + '">' + soy.$$truncate(soy.$$escapeHtml(mentionUser__soy177.name), 50, true) + '</a></td><td headers="hipchat-mentioned-room"><a href="#" class="hipchat-dedicated-room-name public-room hipchat-room-link-url" data-api-url="' + soy.$$escapeHtml(opt_data.apiUrl) + '" data-room-id="' + soy.$$escapeHtml(mentionRoom__soy176.id) + '">' + soy.$$truncate(soy.$$escapeHtml(mentionRoom__soy176.name), 50, true) + '</a></td><td headers="hipchat-mentioned-message" title="' + soy.$$escapeHtml(mentionMessage__soy175.text) + '">' + soy.$$truncate(soy.$$escapeHtml(mentionMessage__soy175.text), 100, true) + '</td><td headers="hipchat-mentioned-date"><time class="livestamp date user-tz" data-datetime-format="fullAge" datetime="' + soy.$$escapeHtml(mentionData174.localizedMessageDate) + '">$' + soy.$$escapeHtml(mentionData174.localizedMessageDate) + '</time></td></tr>';
  }
  output += '</tbody></table></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomDialog.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomDialog';
}


JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialog = function(opt_data, opt_ignored) {
  return '<h1>' + soy.$$escapeHtml("Invite users to room") + '</h1>' + ((opt_data.hipChatUserName) ? (opt_data.dedicatedRoom) ? '<div class="dialog-panel-body"><form id="hipchat-invite-contributors-form" class="hipchat-invite-contributors-form aui" data-dedicated-room-id="' + soy.$$escapeHtml(opt_data.dedicatedRoom.roomId) + '"><div class="dialog-panel-body-header aui-item">' + JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails({loggedIn: opt_data.hipChatUserName, dedicatedRoom: opt_data.dedicatedRoom, hideUnlink: true, justLinked: false}) + '</div><div id="dedicated-room-invite-users-picker-container" class="field-group dedicated-room-invite-user-field"><label for="dedicated-room-invite-user">' + soy.$$escapeHtml("Search for collaborators") + '</label><input type="hidden" name="dedicated-room-invite-user" id="dedicated-room-invite-user" placeholder="' + soy.$$escapeHtml("Search for collaborators") + '"/><div class="user-picker-errors"></div></div>' + HipChat.Templates.Configuration.inviteeList(null) + '<div class="dialog-errors"></div></form></div><div class="buttons-container form-footer">' + JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialogButtons(null) + '</div>' : '<div class="dialog-panel-body"><p>' + soy.$$escapeHtml("Couldn\x27t find the dedicated room for this issue.") + '</p></div>' : '<div class="dialog-panel-body"><p>' + soy.$$filterNoAutoescape("You cannot invite people without granting JIRA access to your HipChat account.") + '</p></div>');
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialog.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialog';
}


JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialogButtons = function(opt_data, opt_ignored) {
  return '<div class="buttons"><button class="aui-button submit" id="hipchat-invite-contributors-dialog-submit">' + soy.$$escapeHtml("Invite") + '</button><button class="aui-button aui-button-link cancel" id="hipchat-invite-contributors-dialog-close">' + soy.$$escapeHtml("Close") + '</button></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialogButtons.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.inviteContributorsDialogButtons';
}
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'soy/issuepanel/issuepanel-client.soy' */
// This file was automatically generated from issuepanel-client.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.Project.IssuePanel.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.Project == 'undefined') { JIRA.Templates.HipChat.Project = {}; }
if (typeof JIRA.Templates.HipChat.Project.IssuePanel == 'undefined') { JIRA.Templates.HipChat.Project.IssuePanel = {}; }


JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription = function(opt_data, opt_ignored) {
  var output = '';
  var noOfMentionRooms__soy3 = opt_data.mentionedRooms.length;
  output += ((noOfMentionRooms__soy3 > 0) ? '<a id="hipchat-issue-mentions-list" href="' + soy.$$escapeHtml("/jira" + '/secure/HipChatMentionedRooms.jspa?issueKey=' + opt_data.issueKey) + '"' + ((opt_data.userLoggedIntoHipChat) ? 'class="trigger-dialog-large">' : 'class="trigger-dialog">') : '<span>') + soy.$$escapeHtml(AJS.format("Issue mentioned in {0} {0,choice,0#rooms|1#room|1\x3crooms}",noOfMentionRooms__soy3)) + ((noOfMentionRooms__soy3 > 0) ? '</a>' : '</span>');
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription';
}


JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails = function(opt_data, opt_ignored) {
  return '<div class="hipchat-dedicated-room"><div class="hipchat-dedicated-room-icon ' + ((opt_data.justLinked) ? 'success' : '') + '"><span class="aui-icon aui-icon-small aui-iconfont-approve"> </span>' + ((opt_data.dedicatedRoom.privateRoom) ? '<span class="aui-icon private-room"> </span>' : '<span class="aui-icon public-room"> </span>') + '</div><a href="#" class="hipchat-dedicated-room-name public-room hipchat-room-link-url" data-api-url="' + soy.$$escapeHtml(opt_data.dedicatedRoom.apiUrl) + '" data-room-id="' + soy.$$escapeHtml(opt_data.dedicatedRoom.roomId) + '" data-issue-id="' + soy.$$escapeHtml(opt_data.dedicatedRoom.issueId) + '" data-room="' + soy.$$escapeHtml(opt_data.dedicatedRoom.roomId) + '">' + soy.$$escapeHtml(opt_data.dedicatedRoom.name) + '</a>' + ((! opt_data.hideUnlink) ? '<a class="trash-dedicated-room" href="#" title="' + soy.$$escapeHtml("Unlink room") + '"><span class="aui-icon aui-icon-small aui-iconfont-remove-label">Delete</span></a>' : '') + '<div class="hc-button-spinner"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails';
}


JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm = function(opt_data, opt_ignored) {
  return '<div class="hipchat-no-dedicated-room">' + ((opt_data.canAssignRoom) ? '<div id="hipchat-dedicated-room-buttons" class="buttons-container">' + ((opt_data.canCreateRoom || opt_data.isAdmin) ? aui.buttons.button({text: "Create a room", extraClasses: 'hipchat-create-dedicated-room hipchat-issue-panel-button'}) : '') + '<a id="hipchat-select-dedicated-room" href="' + soy.$$escapeHtml("/jira" + '/secure/HipChatSelectRoom.jspa?issueKey=' + opt_data.issueKey) + '" class="hipchat-issue-panel-button hipchat-select-dedicated-room trigger-dialog-select-room">' + soy.$$escapeHtml("Choose a room") + '</a><div class="hc-button-spinner"></div></div>' : '<div>' + soy.$$escapeHtml("None") + '</div>') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm';
}


JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content">' + ((opt_data.action == 'create') ? '<p>' + soy.$$filterNoAutoescape("\x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#create-dedicated-room\x22\x3eConfirm access to your HipChat account\x3c/a\x3e to create a dedicated room for this issue.") + '</p>' : (opt_data.action == 'delete') ? '<p>' + soy.$$filterNoAutoescape("\x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#delete-dedicated-room\x22\x3eConfirm access to your HipChat account\x3c/a\x3e to delete the dedicated room for this issue.") + '</p>' : '') + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage';
}


JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content"><p>' + soy.$$filterNoAutoescape("Please \x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22#create-dedicated-room\x22\x3ereconfirm access to your HipChat account\x3c/a\x3e.") + '</p></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom';
}


JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content"><p>' + soy.$$filterNoAutoescape("Please \x3ca class\x3d\x22hipchat-user-link\x22 href\x3d\x22\x22\x3ereconfirm access to your HipChat account\x3c/a\x3e.") + '</p></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessage';
}


JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage = function(opt_data, opt_ignored) {
  return '<div class="aui-help aui-help-text hipchat-dedicated-room-not-logged-in"><div class="aui-help-content"><p>' + soy.$$filterNoAutoescape(AJS.format("HipChat integration \x3ca href\x3d\x22{0}\x22\x3ehas to be reinstalled\x3c/a\x3e in order to create dedicated rooms.","/jira" + '/plugins/servlet/hipchat/configure')) + '</p></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage';
}


JIRA.Templates.HipChat.Project.IssuePanel.invitee = function(opt_data, opt_ignored) {
  return '' + HipChat.Templates.Configuration.invitee({username: opt_data.user.userKey, avatarUrl: opt_data.user.avatarUrl, fullname: opt_data.user.displayName, email: opt_data.user.emailAddress, emailDomain: opt_data.user.emailDomain});
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Project.IssuePanel.invitee.soyTemplateName = 'JIRA.Templates.HipChat.Project.IssuePanel.invitee';
}
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/invitecontributors.js' */
define("hipchat/feature/issuepanel/invitecontributors",
[
    "jquery",
    "backbone"
], function (
    $,
    Backbone
) {

    var InviteContributors = Backbone.Model.extend({

        defaults : {
            hipChatUsersMap: {},
            appUsersMap: {}
        },

        initialize: function() {
            this.attributes.hipChatUsersMap = {};
            this.attributes.appUsersMap = {};
        },

        url: function () {
            return AJS.contextPath() + '/rest/hipchat/integrations/1.0/invite/issue/' + this.attributes.issueKey;
        },

        destroy: function () {
            // By default, Backbone doesn't send anything on destroy
            //this.id = this.get("configurationGroupId") + "-" + this.get("name");
            var options = {
                data: JSON.stringify(this.toJSON()),
                contentType: 'application/json'
            };

            return Backbone.Model.prototype.destroy.call(this, options);
        }
    });

    return InviteContributors;

});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/invitecontributors-view.js' */
define("hipchat/feature/issuepanel/invitecontributors-view",
[
    "jquery",
    "backbone",
    "hipchat/base",
    "hipchat/feature/issuepanel/invitecontributors",
    "hipchat/invite/user-picker"
], function (
        $,
        Backbone,
        HipChat,
        InviteContributors,
        UserPicker
) {
    var InviteContributorsView = HipChat.View.extend({

        events: {
        },

        initialize: function (options) {
            this.loggedIn = options.loggedIn;
            this.canCreateRoom = options.canCreateRoom;
            this.canAssignRoom = options.canAssignRoom;
            this.isAdmin = options.isAdmin;
            this.hipChatUserName = options.hipChatUserName;
            this.issueKey = options.issueKey;
        },

        close: function () {
            this.unbind();
        },

        openInviteDialog: function (roomId) {
            var self = this;
            var issueKey = self.issueKey;
            if (!self.dialog) {
                self.dialog = new JIRA.FormDialog({
                    id: "hipchat-invite-contributors-dialog",
                    ajaxOptions: {
                        url: AJS.contextPath() + '/secure/HipChatInviteContributors.jspa?issueKey=' + issueKey,
                        data: {
                            decorator: "dialog",
                            inline: "false"
                        }
                    },
                    width: 400
                });
                self.initInviteContributorsDialog(self.dialog);
            }

            self.dialog.show();
        },

        initInviteContributorsDialog: function (dialog) {
            var self = this;
            self.dialogContentReadyCallback = function(e, data) {
                if (data.options.id === "hipchat-invite-contributors-dialog") {
                    self.initializeDialogUi();
                    self.initializeUserPicker();
                    self.initializeContributorsList();
                    // To make sure this block runs only once.
                    $(document).unbind("dialogContentReady", self.dialogContentReadyCallback);
                }
            };
            $(document).bind("dialogContentReady", {}, self.dialogContentReadyCallback);
        },

        getEmailDomain: function (email) {
                var atIdx;
                if(email && (atIdx = email.indexOf('@')) && atIdx >= 0) {
                    return email.substr(atIdx);
                }
                // Fallback
                return email;
        },

        setInviteButtonStatus: function() {
            var self = this;
            var hipChatUsersMap = self.model.get("hipChatUsersMap");
            var anyoneToInvite = false;
            var userKeys = Object.keys(hipChatUsersMap);
            userKeys.forEach(function (userKey) {
                if (!hipChatUsersMap[userKey].invitedAlready)
                    anyoneToInvite = true;
            });
            self.$inviteButton.prop('disabled', !anyoneToInvite);
        },

        addHipChatUser: function (hipChatUser) {
            var self = this;
            var hipChatUsersMap = self.model.get("hipChatUsersMap");
            if (hipChatUser.userKey in hipChatUsersMap) {
                console.log("User " + hipChatUser.userKey + " is already in the list, ignoring.");
                return;
            }
            if (!hipChatUser.emailDomain) {
                hipChatUser.emailDomain = self.getEmailDomain(hipChatUser.emailAddress);
            }
            hipChatUsersMap[ hipChatUser.userKey ] = hipChatUser;
            self.$inviteeList.append(self.inviteeTemplate({user: hipChatUser}));
            self.setInviteButtonStatus();
        },

        removeHipChatUser: function (userKey) {
            var self = this;
            var invitee = self.$inviteeList.find("[data-username='" + userKey + "']");
            invitee.remove();
            var hipChatUsersMap = self.model.get("hipChatUsersMap");
            if (!(userKey in hipChatUsersMap)) {
                console.log("User " + userKey + " is not in the list but it is asked to be removed, WTF?");
                return;
            }
            hipChatUsersMap = _.omit(hipChatUsersMap, userKey);
            self.model.set("hipChatUsersMap", hipChatUsersMap);
            self.setInviteButtonStatus();
        },

        submitInviteContributorsDialog: function () {
            var self = this;

            self.$inviteButton.attr("disabled", "disabled");
            self.$userFieldContainer.prop('disabled', "disabled");
            self.dialog.showFooterLoadingIndicator();
            var $errorContainer = $("#hipchat-invite-contributors-dialog").find(".dialog-errors");
            var dfd = $.Deferred();

            $errorContainer.empty();
            var hipChatUsersMap = self.model.get("hipChatUsersMap");
            var userKeys = Object.keys(hipChatUsersMap);
            if (!userKeys.length) {
                console.log("No user to be invited but this method is called, WTF?");
                return;
            }
            var mentionNames = [];
            userKeys.forEach(function (userKey) {
                var mentionName = hipChatUsersMap[userKey].mentionName;
                if (!hipChatUsersMap[userKey].invitedAlready && mentionNames.indexOf(mentionName) < 0)
                    mentionNames.push(mentionName);
            });
            self.model.save({mentionNames: mentionNames})
                    .done(function (response) {
                        dfd.resolve();
                        self.dialog.hideFooterLoadingIndicator();
                    }).fail(function (err) {
                        console.log('An error occurred while making a server-side call to invite contributors.');
                        dfd.reject(err);
                    });

            var updateStatus = function(success) {
                // Hide the remove buttons
                var inviteeIcons = self.$form.find(".icon-holder");
                inviteeIcons.each(function(index) {
                    $(this).hide();
                });
                // Show success icons
                var $inviteeStatuses = self.$form.find(".status-icon-holder");
                $inviteeStatuses.show();
                $inviteeStatuses.each(function(index) {
                    var $element = $(this);
                    if (!$element.data('already-invited')) {
                        if (success) {
                            $element.data('already-invited', true);
                        }
                        var $successIcon = $(this).find(".success");
                        var $failureIcon = $(this).find(".failure");
                        setTimeout(function() {
                            $($successIcon).css('display', success ? 'inline-block' : 'none');
                            $($failureIcon).css('display', success ? 'none' : 'inline-block');
                        }, 100 * index);
                    }
                });
            };

            dfd.done(function (room) {
                updateStatus(true);
                // Mark users
                var hipChatUsersMap = self.model.get("hipChatUsersMap");
                var userKeys = Object.keys(hipChatUsersMap);
                userKeys.forEach(function (userKey) {
                    hipChatUsersMap[userKey].invitedAlready = true;
                });
                self.model.set("hipChatUsersMap", hipChatUsersMap);
                JIRA.trace("hipchat.invite.contributors.successful");
                // $('#hipchat-invite-contributors-dialog-close').click();
            }).fail(function (err) {
                updateStatus(false);
                $errorContainer.empty();
                $errorContainer.append(AJS.format("Failed to invite users: {0}", err.statusText));
                self.$inviteButton.removeAttr("disabled");
                self.$userFieldContainer.removeAttr("disabled");
            }).always(function () {
                self.dialog.hideFooterLoadingIndicator();
            });
        },

        initializeDialogUi: function () {
            var self = this;
            self.$form = $("#hipchat-invite-contributors-dialog").find("form");
            self.$userFieldContainer = self.$form.find('#dedicated-room-invite-users-picker-container');
            self.$userField = self.$form.find('#dedicated-room-invite-user');
            self.$closeButton = $('#hipchat-invite-contributors-dialog-close');
            self.$inviteButton = $('#hipchat-invite-contributors-dialog-submit');
            self.$inviteeList = self.$form.find('.hipchat-invitee-list');
            self.inviteeTemplate = JIRA.Templates.HipChat.Project.IssuePanel.invitee;

            self.$inviteeList.on('click', '.remove-invite-button', function (e) {
                e.preventDefault();
                var invitee = $(this).closest('.hipchat-invitee');
                self.removeHipChatUser(invitee.attr('data-username'));
            });

            self.$form.on('user-picker-user-selected', function (e, user) {
                self.addHipChatUser(user);
            });

            self.$inviteButton.on("click", function (e) {
                self.submitInviteContributorsDialog();
            });
        },

        initializeContributorsList: function() {
            var self = this;
            var issueKey = AJS.Meta.get("issue-key");
            self.model = new InviteContributors({issueKey: issueKey});
            self.setInviteButtonStatus();
            var $errorContainer = $("#hipchat-invite-contributors-dialog").find(".dialog-errors");
            $errorContainer.empty();
            var $spinner = self.$form.find('.hc-button-spinner');
            $spinner.css({display: "inline-block"});
            $spinner.spin();
            self.model.fetch({
                success: function (result) {
                    $spinner.spinStop();
                    $spinner.css({display: "none"});
                    self.$inviteeList.empty();
                    result.attributes.hipChatUsers.forEach(function (hipChatUser) {
                        self.addHipChatUser(hipChatUser);
                    });
                },
                error: function (result) {
                    $spinner.spinStop();
                    $spinner.css({display: "none"});
                    $errorContainer.empty();
                    $errorContainer.append("Failed to fetch list of issue contributors.");
                }
            });
        },

        initializeUserPicker: function () {
            var self = this;

            function makeParams(val) {
                return {
                    maxResults: 10,
                    query: val,
                    showAvatar: true
                };
            }

            function processResults(data, page) {
                var results = _.reduce(data.users, function (m, item) {
                    m.push({
                        id: item.name,
                        text: item.displayName,
                        restObj: item
                    });
                    return m;
                }, []);
                return {
                    results: results
                };
            }

            function processChoice(props) {
                var deferred = $.Deferred();
                var $errorContainer = $("#dedicated-room-invite-users-picker-container").find(".user-picker-errors");

                $errorContainer.empty();
                var $spinner = self.$form.find('.hc-button-spinner');
                $spinner.css({display: "inline-block"});
                $spinner.spin();
                getExtraData(props.restObj.key).done(function (contributor) {
                    deferred.resolve(contributor);
                }).always(function () {
                    $spinner.spinStop();
                    $spinner.css({display: "none"});
                }).fail(function (err) {
                    $errorContainer.empty();
                    $errorContainer.append("Sorry, this user doesn\'t have a HipChat account.");
                    self.$userField.select2('val', '');
                    deferred.reject(err);
                });

                return deferred.promise();
            }

            function getExtraData(userKey) {
                var url = AJS.contextPath() + '/rest/hipchat/integrations/1.0/invite/user/' + userKey;
                var deferred = $.Deferred();
                $.ajax(url, {
                    type: "GET",
                    dataType: 'json'
                }).done(function (contributor) {
                    if (contributor.hipChatUser)
                        deferred.resolve(contributor);
                    else
                        deferred.reject();
                }).fail(function (err) {
                    deferred.reject(err);
                });
                return deferred.promise();
            }

            UserPicker(self.$userField, self.$form, {
                url: AJS.contextPath() + "/rest/api/2/user/picker",
                params: makeParams,
                results: processResults,
                choice: processChoice
            });
        }
    });

    return InviteContributorsView;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/dedicatedroom.js' */
define("hipchat/feature/issuepanel/dedicatedroom",
[
    "jquery",
    "backbone"
], function (
    $,
    Backbone
) {

    var DedicatedRoom = Backbone.Model.extend({

        url: function () {
            return AJS.contextPath() + '/rest/hipchat/integrations/1.0/dedicatedroom/';
        },

        destroy: function () {
            // By default, Backbone doesn't send anything on destroy
            //this.id = this.get("configurationGroupId") + "-" + this.get("name");
            var options = {
                data: JSON.stringify(this.toJSON()),
                contentType: 'application/json'
            };

            this.id = -1;
            return Backbone.Model.prototype.destroy.call(this, options);
        }
    });

    return DedicatedRoom;

});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/dedicatedroom-view.js' */
define("hipchat/feature/issuepanel/dedicatedroom-view",
[
    "jquery",
    "backbone",
    "hipchat/base",
    "hipchat/feature/issuepanel/dedicatedroom",
    "hipchat/widget/roomselector/roommapping-service",
    "hipchat/widget/roomselector/roomselector-view",
    "hipchat/feature/issuepanel/invitecontributors",
    "hipchat/feature/issuepanel/invitecontributors-view"
], function (
        $,
        Backbone,
        HipChat,
        DedicatedRoom,
        RoomMappingService,
        RoomSelectorView,
        InviteContributors,
        InviteContributorsView
) {
    var DedicatedRoomView = HipChat.View.extend({

        events: {
            "click .hipchat-create-dedicated-room": "createDedicatedRoom",
            "click a.trigger-dialog-select-room": "openSelectRoomDialog",
            "click .trash-dedicated-room": "unassignDedicatedRoom"
        },

        initialize: function (options) {
            this.loggedIn = options.loggedIn;
            this.canCreateRoom = options.canCreateRoom;
            this.canAssignRoom = options.canAssignRoom;
            this.isAdmin = options.isAdmin;
            this.hipChatUserName = options.hipChatUserName;
            this.issueKey = options.issueKey;
        },

        initInviteContributorsView: function(issueKey) {
            var inviteContributorsOptions = {
                issueKey: issueKey
            };
            var inviteModel = new InviteContributors(inviteContributorsOptions);

            var options = _.extend(this.options, {
                model: inviteModel
            });
            this.inviteContributorsView = new InviteContributorsView(options);
        },

        close: function () {
            if (this.inviteContributorsView) {
                this.inviteContributorsView.close();
            }
            if (this.dialogContentReadycallback) {
                $(document).unbind("dialogContentReady", this.dialogContentReadycallback);
            }
            this.unbind();
        },

        createDedicatedRoom: function (e) {
            var $createButton = this.$(".hipchat-create-dedicated-room");

            var self = this;
            if (self.loggedIn && self.canCreateRoom) {
                $createButton.attr("disabled", "disabled");
                self.createOrAssignDedicatedRoom().done(function (dedicatedRoom) {
                    JIRA.trace("hipchat.dedicated.room.created");
                    if (!dedicatedRoom.privateRoom)
                        self.inviteContributorsView.openInviteDialog(dedicatedRoom.roomId);
                }).always(function () {
                    $createButton.removeAttr("disabled");
                });
            } else {
                if (!self.loggedIn || !self.canCreateRoom) {
                    var dialog = AJS.InlineDialog($createButton, "dedicated-room-not-logged-in-dialog", function (content, trigger, showPopup) {

                        var html;
                        if (!self.canCreateRoom && self.isAdmin) {
                            html = JIRA.Templates.HipChat.Project.IssuePanel.cantCreateRoomMessage({});
                        } else {
                            html = JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage({action: "create"});
                        }

                        content.html(html);

                        showPopup();
                    }, self.dialogConfig());

                    dialog.show(e, $createButton);
                }
            }
        },

        createOrAssignDedicatedRoom: function (roomId) {
            var self = this;
            var issueKey = self.issueKey;
            var dfd = $.Deferred();

            var $errorsContainer = self.$("#hipchat-dedicated-room-errors");
            self.clearError($errorsContainer);
            var $spinner = self.$('.hc-button-spinner');
            $spinner.css({display: "inline-block"});
            $spinner.spin();

            self.model.save({issue_key: issueKey, room_id: roomId})
                    .done(function (dedicatedRoom) {
                var html = JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomDetails({
                    loggedIn: self.loggedIn,
                    dedicatedRoom: dedicatedRoom,
                    created: true
                });

                self.$(".hipchat-dedicated-room-content")
                        .hide()
                        .html(html)
                        .fadeIn({
                            complete: function () {
                                setTimeout(function () {
                                    self.$(".hipchat-dedicated-room-icon").removeClass("success");
                                }, 1500);
                            }
                        });

                var $panelContainer = $("#hipchat-issue-panel-rooms-container");
                $panelContainer.data("dedicated-room-id", dedicatedRoom.roomId);

                JIRA.trace("hipchat.dedicated.room.created");
                self.initInviteContributorsView(self.issueKey);
                dfd.resolve(dedicatedRoom);
            }).fail(function (err) {
                if (self.loggedIn && (err.status == 403 || err.status == 401)) {
                    var dialog = new AJS.Dialog({
                        width: 500,
                        height: 300,
                        id: "oauth-failure",
                        closeOnOutsideClick: true
                    });
                    dialog.addHeader("Authentication Failure");
                    dialog.addPanel("panel 0", JIRA.Templates.HipChat.Project.IssuePanel.oauthNoLongerValidMessageDedicatedRoom({}));
                    dialog.show();
                } else {
                    self.displayError($errorsContainer,
                            roomId === undefined ?
                                    "Failed to create a dedicated room" :
                                    "We can\'t assign that name. The room name may already be taken or you don\'t have access to it.", err);
                }
                dfd.reject(err);
            }).always(function () {
                $spinner.spinStop();
                $spinner.css({display: "none"});
                var $createButton = $(".hipchat-create-dedicated-room");
                $createButton.removeAttr("disabled");
            });

            return dfd;
        },

        openSelectRoomDialog: function (e) {
            e.preventDefault();
            var target = e.currentTarget;
            if (this.dialog === undefined) {
                this.dialog = new JIRA.FormDialog({
                    id: target.id + "-dialog",
                    ajaxOptions: {
                        url: target.href,
                        data: {
                            decorator: "dialog",
                            inline: "false"
                        }
                    },
                    width: 400
                });
                this.initSelectRoomDialog(this.dialog);
            }

            this.dialog.show();
        },

        initSelectRoomDialog: function (dialog) {
            var self = this;
            self.dialogContentReadycallback = function (e, data) {
                if (data.options.id === "hipchat-select-dedicated-room-dialog") {
                    var roomServicePromise = RoomMappingService.roomServicePromise(true);
                    //var loggedIn = $("#hipchat-issue-panel-rooms-container").data("hipchat-username") !== undefined;
                    if (!self.loggedIn) {
                        return;
                    }
                    var roomSelector = new RoomSelectorView({
                        el: $('#hipchat-dedicated-room-select'),
                        loggedIn: self.loggedIn,
                        maxWidth: "480px"
                    });
                    var roomSelectorWatcher = {
                        roomSelector: roomSelector,
                        clearSelectedRoom: function () {
                            this.roomSelector.clearSelectedRoom();
                            this.disableSubmitButton();
                        },
                        enableSubmitButton: function () {
                            var selectedRoom = this.roomSelector.getSelectedRoom();
                            if (selectedRoom && selectedRoom.id !== "") {
                                $("#hipchat-select-dedicated-room-dialog-submit").removeAttr('aria-disabled').removeAttr('disabled');
                            }
                        },
                        disableSubmitButton: function () {
                            $('#hipchat-select-dedicated-room-dialog-submit').attr({
                                'aria-disabled': 'true',
                                'disabled': ''
                            });
                        },
                        roomSelected: function () {
                            return $('#hipchat-select-dedicated-room-dialog-submit').attr("disabled") === undefined;
                        },
                        init: function () {
                            this.roomSelector.on("change", this.enableSubmitButton, this);
                            this.roomSelector.on("clear", this.disableSubmitButton, this);
                        }
                    };
                    roomSelectorWatcher.init();

                    var submitSelectRoomDialog = function () {
                        dialog.showFooterLoadingIndicator();

                        var dfd = $.Deferred();
                        var selectedRoom = roomSelector.getSelectedRoom();
                        if (!selectedRoom.existing) {
                            // create room first
                            var roomServicePromise = RoomMappingService.roomServicePromise(true);
                            roomServicePromise.done(function (roomService) {
                                dfd = roomService.createRoom(selectedRoom.roomName);
                                dfd.fail(function(createRoomError) {
                                   dfd.reject(createRoomError);
                                });
                            }).fail(function (err) {
                                dfd.reject(err);
                            });
                        } else {
                            dfd.resolve(selectedRoom);
                        }

                        dfd.done(function (room) {
                            $('#hipchat-select-dedicated-room-dialog-close').click();

                            // The object returned by roomSelector has id, while the one returned by createRoom has roomId.
                            var roomId = room.id || room.roomId;
                            self.createOrAssignDedicatedRoom(roomId).done(function (dedicatedRoom) {
                                JIRA.trace("hipchat.dedicated.room.selected");
                                if (!dedicatedRoom.privateRoom)
                                    self.inviteContributorsView.openInviteDialog(dedicatedRoom.roomId);
                            });
                        }).fail(function (err) {

                            var $errorContainer = $("#hipchat-select-dedicated-room-dialog").find(".dialog-errors");
                            var text = "We can\'t assign that name. The room name may already be taken or you don\'t have access to it.";
                            self.displayError($errorContainer, text, err);

                        }).always(function () {
                            dialog.hideFooterLoadingIndicator();
                        });
                    };

                    var $form = $("#hipchat-select-dedicated-room-dialog").find("form");
                    $form.on("before-submit", function (e) {
                        e.preventDefault();

                        if (roomSelectorWatcher.roomSelected()) {
                            submitSelectRoomDialog();
                        }
                    });

                    roomServicePromise.done(function (roomService) {
                        roomSelectorWatcher.disableSubmitButton();
                    }).fail(function () {
                        roomSelectorWatcher.disableSubmitButton();
                    });

                    $('#hipchat-select-dedicated-room-dialog-submit').on("click", submitSelectRoomDialog);
                }
            };
            $(document).bind("dialogContentReady", {}, self.dialogContentReadycallback);
        },

        clearError: function ($errorsContainer) {
            $errorsContainer.hide();
            $errorsContainer.empty();
        },

        displayError: function ($errorsContainer, title, err) {
            $errorsContainer.show();
            $errorsContainer.empty();

            var msg;
            if (err.status === 503) {
                msg = "Unable to connect to HipChat.";
            } else {
                msg = title;
            }

            $errorsContainer.append(msg);
        },

        unassignDedicatedRoom: function (e) {
            e.preventDefault();

            var self = this;

            if (!self.loggedIn) {

                var $button = self.$(".trash-dedicated-room");
                var dialog = AJS.InlineDialog($button, "dedicated-room-not-logged-in-dialog", function (content, trigger, showPopup) {

                    var html = JIRA.Templates.HipChat.Project.IssuePanel.notLoggedInMessage({ action: "delete"});
                    content.html(html);
                    showPopup();
                }, self.dialogConfig());

                dialog.show(e, $button);

            } else {

                var dfd = $.Deferred();

                var $errorsContainer = self.$("#hipchat-dedicated-room-errors");
                self.clearError($errorsContainer);
                self.showSpinner();

                self.$(".trash-dedicated-room").hide();
                self.model.destroy().always(function () {
                    self.hideSpinner();
                    var $unlinkButton = self.$(".trash-dedicated-room");
                    $unlinkButton.data("hide-for-progress", false);
                }).done(function () {
                    self.model = new DedicatedRoom({});

                    var html = JIRA.Templates.HipChat.Project.IssuePanel.dedicatedRoomForm({
                        canAssignRoom: self.canAssignRoom,
                        canCreateRoom: self.canCreateRoom,
                        isAdmin: self.isAdmin,
                        issueKey: self.issueKey
                    });

                    self.$(".hipchat-dedicated-room-content").html(html);
                    AJS.messages.success('#dedicated-room-message-bar', {
                        title: "Success",
                        body: "The HipChat room will no longer receive notifications about this issue.",
                        fadeout: true
                    });

                    JIRA.trace("hipchat.dedicated.room.deleted");
                    dfd.resolve();
                }).fail(function (err) {
                    self.displayError($errorsContainer, "Failed to un-assign a dedicated room", err);
                    dfd.reject(err);
                });

                return dfd;
            }

        },

        dialogConfig: function() {
            return {
                noBind: true,
                hideDelay: null
            };
        },

        showSpinner: function() {
            var $spinner = this.$('.hc-button-spinner');
            if ($spinner) {
                $spinner.css({display: "inline-block"});
                $spinner.spin();
            }
        },

        hideSpinner: function() {
            var $spinner = this.$('.hc-button-spinner');
            if ($spinner) {
                $spinner.spinStop();
                $spinner.css({display: "none"});
            }
        }

        });

    return DedicatedRoomView;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/issuemention.js' */
define("hipchat/feature/issuepanel/issuemention",
[
    "jquery",
    "backbone"
], function (
    $,
    Backbone
) {

    var IssueMention = Backbone.Model.extend({

        initialize: function(options) {

        },

        url: function() {
            return AJS.contextPath() + '/rest/hipchat/integrations/1.0/issue-mentions/' + this.get("issue_key") + '/rooms';
        },

        parse: function(data) {
            this.set("issueMentionRooms", data);
        }
    });

    return IssueMention;

});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/issuemention-view.js' */
define("hipchat/feature/issuepanel/issuemention-view",
[
    "jquery",
    "backbone",
    "hipchat/base"
], function (
    $,
    Backbone,
    HipChat
) {
    var IssueMentionView = HipChat.View.extend({

        events: {
            "click a.trigger-dialog-large": "openMentionDialog"
        },

        initialize: function(options) {
            this.loggedIn = options.loggedIn;
            this.canCreateRoom = options.canCreateRoom;
            this.isAdmin = options.isAdmin;
            this.issueKey = options.issueKey;
            this.hipChatUserName = options.hipChatUserName;
            this.hipChatConfigured = options.hipChatConfigured;

            this.model.on("sync", this.updateMentionCount, this);
            this.model.on("sync", this.ready, this);
            this.model.on("error", this.displayError, this);

            if (this.hipChatConfigured) {
                this.model.fetch();
            }
        },

        close: function() {
            this.unbind();
        },

        openMentionDialog: function(e) {
            e.preventDefault();

            var target = e.currentTarget;
            if (this.dialog === undefined) {
                this.dialog = new JIRA.FormDialog({
                    id: target.id + "-dialog",
                    ajaxOptions: {
                        url: target.href,
                        data: {
                            decorator: "dialog",
                            inline: "false"
                        }
                    },
                    width: 900
                });
            }

            this.dialog.show();
        },

        updateMentionCount: function() {
            var html = JIRA.Templates.HipChat.Project.IssuePanel.mentionedRoomsDescription({
                mentionedRooms: this.model.get("issueMentionRooms"),
                issueKey: this.issueKey,
                userLoggedIntoHipChat: this.loggedIn
            });

            this.$(".hipchat-mentioned-rooms-content").html(html);

            JIRA.trace("hipchat.mentioned.rooms.fetched");
        },

        ready: function() {
            this.trigger("ready");
        },

        displayError: function(model, resp, options) {
            var errorsContainer = this.$(".hipchat-mentioned-rooms-content");
            errorsContainer.empty();
            errorsContainer.append("<span class='errors'>" + "Failed to get issue room mention information" + "</span>");
        }
    });

    return IssueMentionView;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/issuepanel-view.js' */
define("hipchat/feature/issuepanel/issuepanel-view",
[
    "jquery",
    "backbone",
    "hipchat/base",
    "hipchat/feature/issuepanel/dedicatedroom",
    "hipchat/feature/issuepanel/dedicatedroom-view",
    "hipchat/feature/issuepanel/issuemention",
    "hipchat/feature/issuepanel/issuemention-view"
], function (
    $,
    Backbone,
    HipChat,
    DedicatedRoom,
    DedicatedRoomView,
    IssueMention,
    IssueMentionView
) {
        var hipchatLinkClickedKey = "hipchat.inapp.links.first.clicked";
        var hipchatNativeLinksFeatureDiscovery = "hipchat.inapp.links";
        var cookieExpiresInDays = 1;

        var IssuePanelView = HipChat.View.extend({
        events: {
            "click #hipchat-issue-panel-configure-button": "configure",
            "click #hipchat-issue-panel-hide": "dismissPanel"
        },

        initialize: function(options) {
            this.initDedicatedView();
            this.initIssueMentionView();
            this.initPanelSettings();
        },

        initDedicatedView: function() {
            var issuePanelDetails = this.getIssuePanelDetails();
            var dedicatedRoomOptions = {};
            if (issuePanelDetails.dedicatedRoomId) {
                dedicatedRoomOptions = {
                    issue_key: issuePanelDetails.issueKey,
                    room_id: issuePanelDetails.dedicatedRoomId
                };
            }
            var model = new DedicatedRoom(dedicatedRoomOptions);

            var options = _.extend(issuePanelDetails, {
                el: this.$("#hipchat-dedicated-room-section"),
                model: model
            });
            this.dedicatedRoomView = new DedicatedRoomView(options);
        },

        initIssueMentionView: function() {
            var issuePanelDetails = this.getIssuePanelDetails();
            var options = _.extend({
                el: this.$("#hipchat-mentioned-rooms-section"),
                model: new IssueMention({ issue_key: issuePanelDetails.issueKey })
            }, issuePanelDetails);
            this.issueMentionView = new IssueMentionView(options);

            this.issueMentionView.on("ready", this.ready, this);
        },

        close: function() {
            this.dedicatedRoomView.close();
            this.issueMentionView.close();
        },

        ready: function() {
            this.trigger("ready");
        },

        getIssuePanelDetails: function() {
            var $panelContainer = this.$el;
            var loggedIn = $panelContainer.data("logged-in");
            var canCreateRoom = $panelContainer.data("can-create-room");
            var canAssignRoom = $panelContainer.data("can-assign-room");
            var isAdmin = AJS.Meta.get("is-admin");
            var hipChatUserName = $panelContainer.data("hipchat-username");
            var dedicatedRoomId = $panelContainer.data("dedicated-room-id");
            var hipChatConfigured = $panelContainer.data("hipchat-configured");
            var issueKey = AJS.Meta.get("issue-key");
            return {
                loggedIn: loggedIn,
                canCreateRoom: canCreateRoom,
                canAssignRoom: canAssignRoom,
                isAdmin: isAdmin,
                hipChatUserName: hipChatUserName,
                dedicatedRoomId: dedicatedRoomId,
                hipChatConfigured: hipChatConfigured,
                issueKey: issueKey
            };
        },

        dismissPanel: function(e) {
            e.preventDefault();

            var $panelContainer = this.$el;
            var projectKey = $panelContainer.data("project-key");
            var self = this;
            $.ajax({
                type: "POST",
                url: AJS.contextPath() + '/rest/hipchat/integrations/1.0/issuepanel/hide?projectKey=' + projectKey,
                dataType: 'json',
                cache: false
            }).done(function() {
                self.close();
                $("#hipchat-viewissue-panel").remove();
            }).fail(function() {

            });
        },

        configure: function(e) {
            var target = $(e.currentTarget);
            window.location = target.data("configure-url");
        },

        initPanelSettings: function() {

            // We only show the panel if the user is a MAC user
            if(navigator.platform.toUpperCase().indexOf('MAC') >= 0 && AJS.Meta.get("issue-key") !== undefined){

                var $panel = $("#hipchat-panel-settings");

                if($panel === undefined){
                    return; //Maybe the panel is not there.
                }

                $panel.removeClass("hidden");

                $panel.click(function (event) {
                    event.preventDefault();
                    showDialog($(event.target), false);
                });

                // If someone enabled/disabled the advanced settings
                $(document).on("click", "#hipchat-inapp-links", function (event) {
                    var enabled = $(event.target).is(":checked");
                    AJS.Cookie.save("HIPCHAT_NATIVE_LINK_ENABLED", enabled);

                    var analyticEvent  = "hipchat.issuepanel.native.link." + (enabled ? "enabled" : "disabled");
                    AJS.trigger('analyticsEvent', {name: analyticEvent});
                });

                $(document).on("click", ".hipchat-room-link-url", function (event) {
                    setUserClickedALink();
                });

                $(document).on("click", ".hipchat-user-link-url", function (event) {
                    setUserClickedALink();
                });

                validateFirstTime($panel);
            }

            var confirmDialog;

            function showDialog($target, firstTime) {
                if (!confirmDialog) {
                    // we need to remove any existing dialog, which may have been left behind from previous issues
                    // when a new issue is Ajax loaded
                    AJS.$("#inline-dialog-hipchat-link-dialog").remove();
                    
                    confirmDialog = AJS.InlineDialog($target, "hipchat-link-dialog",
                            function (content, trigger, showPopup) {
                                var params = {isAppLinkEnable: AJS.Cookie.read("HIPCHAT_NATIVE_LINK_ENABLED") === "true"};
                                content.html(JIRA.Templates.HipChat.Config.LinkSettings.enableInAppLinksForHipChat(params));
                                showPopup();
                                return false;
                            }, {
                                hideDelay: null
                            });
                }
                confirmDialog.show();

                var url = AJS.contextPath() + '/rest/api/2/mypreferences?key=';

                // Now we set the variable so the feature discovery ends...
                $.ajax({
                    url: url + hipchatNativeLinksFeatureDiscovery,
                    contentType: 'application/json',
                    cache: false,
                    type: "PUT",
                    data: "true"
                });

                if(firstTime){
                    AJS.trigger('analyticsEvent', {name: 'hipchat.issuepanel.native.link.discovery'});
                }

                saveCookie(hipchatNativeLinksFeatureDiscovery, true);
            }


            /**
             * We clicked a link so we are going to store this in a cookie and a preference, and in the next
             * refresh if the user did not get the feature discovery then we show it.
             */
            function setUserClickedALink() {

                var linkClicked = getCookieForUser(hipchatLinkClickedKey);

                if(linkClicked === "undefined" || linkClicked === "false"){
                    saveCookie(hipchatLinkClickedKey , true);
                    var url = AJS.contextPath() + '/rest/api/2/mypreferences?key=' + hipchatLinkClickedKey;
                    $.ajax({ url: url, contentType: 'application/json', cache: false, type: "PUT", data: "true"});
                }
            }

            /**
             * We save the cookie with the user id, to guarantee that
             * we can login/logout without having problems
             * @param cookie the cookie
             * @param value the value to store
             */
            function saveCookie(cookie, value){
                var username = AJS.Meta.get("remote-user")
                var cookieName = cookie + "." + username;
                AJS.Cookie.save(cookieName, value, cookieExpiresInDays);
            }

            function getCookieForUser(cookie){
                var username = AJS.Meta.get("remote-user")
                var cookieName = cookie + "." + username;
                return AJS.Cookie.read(cookieName);
            }

            /**
             * First we check the cookies, if the cookies say true/true then we already checked and we forget about this
             * If no cookies are set then we ask first if something was clicked, if it was then we check if it was shown or not
             * Depending on that we show the popup.
             * This is the way to verify that the user is using the functionality and showing the things they need.
             * @param $panel the panel
             */
            function validateFirstTime($panel) {

                var url = AJS.contextPath() + '/rest/api/2/mypreferences?key=';

                // If both cookies are true it means that the user clicked a link, and we already showed
                // the popup. This is much better than asking every time the issue loads for this 2 user preferences
                var linkClicked = getCookieForUser(hipchatLinkClickedKey);

                if (linkClicked === "true") {

                    if (getCookieForUser(hipchatNativeLinksFeatureDiscovery) === "true") {
                        return;
                    }

                    $.ajax({
                        url: url + hipchatNativeLinksFeatureDiscovery,
                        dataType: 'json',
                        cache: false
                    }).fail(function (data) {

                        if (data.status == 404) {

                            showDialog($panel, true);

                        }
                    }).success(function (onsuccess) {
                        // This happened in other browser or other session
                        saveCookie(hipchatNativeLinksFeatureDiscovery, true)
                    });

                } else if (linkClicked === undefined) { // Only if we don't know anything about the link we evaluate

                    $.ajax({
                        url: url + hipchatLinkClickedKey,
                        dataType: 'json',
                        cache: false
                    }).success(function (data) {

                        saveCookie(hipchatLinkClickedKey, true);
                        validateFirstTime($panel); //We do the logic again

                    }).fail(function (failure) {
                        saveCookie(hipchatLinkClickedKey, false);
                    });
                }
            }
        }
    });

    return IssuePanelView;
});;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'js/feature/issuepanel/issuepanel-init.js' */
(function ($,
        AJS,
        IssuePanelView
) {

    /**
     * We track any hash actions to be able to know if we are being redirected
     * from other place
     */
    function evaluateImmediateActions() {
        var hash = window.location.hash;

        if (hash === "#choose-room") {
            $("#hipchat-select-dedicated-room").click();
            cleanHash();
        } else if (hash === "#create-dedicated-room") {
            $(".hipchat-create-dedicated-room").click();
            cleanHash();
        } else if (hash === "#open-issue-mentions") {
            $("#hipchat-issue-mentions-list").click();
            cleanHash();
        } else if(hash === "#delete-dedicated-room") {
            $(".trash-dedicated-room").click();
        }
    }

    function cleanHash() {
        window.location.hash = "";
    }

    function createIssuePanelView() {
        return new IssuePanelView({
            el: $("#hipchat-issue-panel-rooms-container")
        });
    }

    var issuePanelView = null;
    function init() {
        getTemplate();

        JIRA.bind(JIRA.Events.ISSUE_REFRESHED, function () {
            // HC-11688: Actions on the issue (transition, edit...) will refresh the content of the sidebar.

            if (issuePanelView !== null){
                issuePanelView.close();
            }
            getTemplate();
        });
    }

    function getTemplate() {
        var issueKey = AJS.Meta.get("issue-key");
        if (issueKey) {
            var $issuePanel = AJS.$("#hipchat-issue-panel");
            var $spinner = AJS.$("#hipchat-issue-panel-spinner");
            var $errors = AJS.$("#hipchat-issue-panel-errors");
            $spinner.spin();
            return AJS.$.ajax({
                url: AJS.contextPath() + "/rest/hipchat/integrations/1.0/issuepanel/data/" + issueKey,
                cache: false,
                dataType: 'json',
                type: "GET"
            }).done(function (data) {
                var template = JIRA.Templates.HipChat.Project.IssuePanel.hipChatPanel(data);
                $issuePanel.html(template);

                issuePanelView = createIssuePanelView();
                issuePanelView.on("ready", evaluateImmediateActions);
            }).fail(function (jqXHR, textStatus) {
                $errors.append("Error getting HipChat data from JIRA");
            }).always(function() {
                $spinner.spinStop();
            });
        }
    }

    $(function () {
        init();
    });
})(
        AJS.$,
        require("ajs"),
        require("hipchat/feature/issuepanel/issuepanel-view")
);
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:hipchat-viewissue-panel-resources', location = 'soy/configure/hipchat-link-dialog.soy' */
// This file was automatically generated from hipchat-link-dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.Config.LinkSettings.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.Config == 'undefined') { JIRA.Templates.HipChat.Config = {}; }
if (typeof JIRA.Templates.HipChat.Config.LinkSettings == 'undefined') { JIRA.Templates.HipChat.Config.LinkSettings = {}; }


JIRA.Templates.HipChat.Config.LinkSettings.enableInAppLinksForHipChat = function(opt_data, opt_ignored) {
  return '<div class="hipchat-settings-panel"><h6>' + soy.$$escapeHtml("Use the HipChat App") + '</h6><p>' + soy.$$escapeHtml("Would you rather open links in the HipChat application instead of your browser?") + '</p><p></p><input type="checkbox" class="matcher-type" id="hipchat-inapp-links" autocomplete="off" ' + ((opt_data.isAppLinkEnable) ? ' checked' : '') + '/><label for="hipchat-inapp-links">' + soy.$$escapeHtml("Open in the HipChat App") + '</label><p>' + soy.$$filterNoAutoescape("Don\x27t have the app?  \x3ca href\x3d\x22http://hipchat.com/downloads\x22 target\x3d\x22_blank\x22\x3eGet it\x3c/a\x3e!") + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Config.LinkSettings.enableInAppLinksForHipChat.soyTemplateName = 'JIRA.Templates.HipChat.Config.LinkSettings.enableInAppLinksForHipChat';
}
;
;
/* module-key = 'com.atlassian.jira.jira-quick-edit-plugin:create-linked-issue-init', location = '/js/create-linked-issue/create-linked-issue-init.js' */
require([
    'jquery',
    'wrm/require',
    'quick-edit/util/loading-indicator'
], function (
    jQuery,
    wrmRequire,
    LoadingIndicator
) {
    var showLoadingIndicator = function () {
        LoadingIndicator.showLoadingIndicator();
    };
    var hideLoadingIndicator = function () {
        LoadingIndicator.hideLoadingIndicator(true);
    };

    var createIssueDialogLoading = false;
    jQuery(document).on("click", ".issueaction-create-linked-issue", function(e) {
        e.preventDefault();
        if( !createIssueDialogLoading ) {
            createIssueDialogLoading = true;
            showLoadingIndicator();

            wrmRequire(['wr!com.atlassian.jira.jira-quick-edit-plugin:create-linked-issue'])
                .done(function () {
                    var formFactory = require('quick-edit/create-linked-issue/create-linked-issue-form-factory');

                    formFactory().asDialog({
                        id: "create-linked-issue-dialog",
                        windowTitle: "Create linked issue"
                    }).show();

                    createIssueDialogLoading = false;
                })
                .fail(function () {
                    hideLoadingIndicator();
                    createIssueDialogLoading = false;
                });
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:underscore', location = 'js/lib/underscore-adapter.js' */
define("workflow-designer/underscore", [
    "underscore"
], function(
    _
) {
    return _;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:workflow-designer-loader', location = 'js/require.js' */
define("workflow-designer/application-loader", [
    "wrm/require",
    "require"
], function(
    wrmRequire,
    require
) {
    return {
        /**
         * Load the resources required for the workflow designer, then execute a callback.
         *
         * This method can be safely called multiple times, the resources will only be loaded once.
         *
         * @param {function} [done] A callback to execute after the resources have been loaded. It's given the workflow designer
         *   application constructor.
         * @returns a jQuery promise that is resolved on success, or rejected on failure.
         */
        load: function requireWorkflowDesigner(done) {
            return wrmRequire(["wrc!com.atlassian.jira.plugins.jira-workflow-designer.workflow-designer"], function () {
                done && done(require("workflow-designer/application"));
            });
        }
    };

});

AJS.namespace("JIRA.WorkflowDesigner.require", null, require("workflow-designer/application-loader").load);;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:workflow-designer-templates', location = 'js/templates-amd.js' */
define('workflow-designer/templates', [], function () {

    // make sure that the template namespace is in place
    AJS.namespace("JIRA.WorkflowDesigner.Templates");

    return JIRA.WorkflowDesigner.Templates;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:dialog', location = 'js/util/DialogSizeCalculator.js' */
define("workflow-designer/dialog-size-calculator", [
    "workflow-designer/underscore",
    "jquery"
], function(
    _,
    jQuery
) {

    /**
     * An object for calculating the size of the workflow designer dialog.
     *
     * @namespace
     */
    return {
       /**
        * The distance from the edge of the window for size calculations.
        *
        * @type {number}
        * @constant
        * @default
        */
        DISTANCE_FROM_EDGE: 100,

        /**
         * Calculate the dialog size to make it fill the available space.
         *
         * @param {object} dialog The dialog to calculate size for.
         * @param {object} options
         * @param {number} [options.windowHeight] The height of the window.
         * @param {number} [options.windowWidth] The width of the window.
         * @param {number} [options.dialogHeaderHeight] The height of the dialog header.
         * @param {number} [options.dialogFooterHeight] The height of the dialog footer.
         * @returns {{height: number, width: number}}
         */
        calculateDialogSize: function(dialog, options) {
            this.dialog = dialog;
            options = _.defaults(options || {}, {
                windowHeight: this._getWindowHeight(),
                windowWidth: this._getWindowWidth(),
                dialogHeaderHeight: this._getDialogHeaderHeight(),
                dialogFooterHeight: this._getDialogFooterHeight()
            });

            return {
                height: this._calculateDialogHeight(options.windowHeight, options.dialogHeaderHeight, options.dialogFooterHeight),
                width: this._calculateDialogWidth(options.windowWidth)
            };
        },

        /**
         * Calculate the dialog height to be 100 pixels from the edge of the window on each side.
         * @returns {number} The height
         * @private
         */
        _calculateDialogHeight: function(windowHeight, dialogHeaderHeight, dialogFooterHeight) {
            return windowHeight - dialogHeaderHeight - dialogFooterHeight - (this.DISTANCE_FROM_EDGE * 2);
        },

        /**
         * Calculate the dialog width to be 100 pixels from the edge of the window on each side.
         * @returns {number} The width
         * @private
         */
        _calculateDialogWidth: function(windowWidth) {
            return windowWidth - (this.DISTANCE_FROM_EDGE * 2);
        },

        /**
         * Get the window height.
         * @returns {number}
         * @private
         */
        _getWindowHeight: function() {
            return jQuery(window).height();
        },

        /**
         * Get the window width.
         * @returns {number}
         * @private
         */
        _getWindowWidth: function() {
            return jQuery(window).width();
        },

        /**
         * Get the dialog header height.
         * @returns {number}
         * @private
         */
        _getDialogHeaderHeight: function() {
            return this.dialog.$popupHeading.outerHeight();
        },

        /**
         * Get the dialog header width.
         * @returns {number}
         * @private
         */
        _getDialogFooterHeight: function() {
            return this.dialog.$buttonContainer.outerHeight();
        }
    };
});

AJS.namespace("JIRA.WorkflowDesigner.DialogSizeCalculator", null, require("workflow-designer/dialog-size-calculator"));;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:dialog', location = 'js/views/dialogs/Dialog.js' */
define("workflow-designer/dialog", [
    "workflow-designer/dialog-size-calculator",
    "jira/dialog/form-dialog",
    "workflow-designer/application-loader",
    "workflow-designer/templates",
    "jira/dialog/dialog",
    "workflow-designer/underscore",
    "jquery"
], function(
    DialogSizeCalculator,
    FormDialog,
    ApplicationLoader,
    Templates,
    JIRADialog,
    _,
    jQuery
) {
    return FormDialog.extend(
    /** @lends JIRA.WorkflowDesigner.Dialog# */
    {
        /**
         * Initialises the dialog.
         *
         * Passes options through to <tt>JIRA.FormDialog</tt>.
         *
         * @constructs
         * @extends JIRA.FormDialog
         * @classdesc JIRA.FormDialog which displays the workflow designer.
         * @param {object} options
         * @param {function|string} [options.currentStepId] The ID of the current step.
         * @param {function|boolean} [options.isDraft=false] Whether the workflow is a draft.
         * @param {function|object} [options.layoutData] The workflow designer's layout data.
         * @param {function|string} [options.workflowId] The ID of the workflow to load.
         */
        init: function (options) {
            _.bindAll(this, "_sizeAndPositionDialog");

            options = _.defaults({}, options, {
                content: this.createDialogContent,
                isDraft: false,
                onContentRefresh: this._showWorkflowDesigner,
                widthClass: "large"
            });

            this.options = options;
            this.sizeAndPositionDialog = _.throttle(this._sizeAndPositionDialog, 100);

            this._super(options);
            this.onContentReady(this._addLabelHint);
        },

        /**
         * Creates the content structure of this dialog.
         *
         * @param {function} callback Callback that we must pass the dialog content to.
         */
        createDialogContent: function(callback) {
            callback(Templates.Dialog.workflowDialog({
                title: _.result(this.options, "workflowId")
            }));
        },

        /**
         * @method
         */
        show: function() {
            this._super.apply(this, arguments);

            jQuery(window).on("resize", this.sizeAndPositionDialog);
        },

        /**
         * @method
         */
        hide: function() {
            this._designer && this._designer.destroy();

            this._super.apply(this, arguments);

            jQuery(window).off("resize", this.sizeAndPositionDialog);
        },

        /**
         * Set the width and height of the current dialog and position it accordingly.
         * Note, this removes the max-height attribute as it causes the dialog to 'jump' when resizing and is
         * not necessary as the height and is managed.
         *
         * @private
         */
        _sizeAndPositionDialog: function () {
            var formBody,
                size;

            if (JIRADialog.current === this) {
                size = DialogSizeCalculator.calculateDialogSize(this);
                this.options.width = size.width;

                formBody = this.$popup.find(".form-body");
                formBody.css({
                    height: size.height,
                    maxHeight: ""
                });

                this._positionInCenter();
            }
        },

        /**
         * Creates the workflow designer.
         *
         * @private
         */
        _showWorkflowDesigner: function() {
            var dialog = this;

            this._sizeAndPositionDialog();

            ApplicationLoader.load(function (Application) {
                if (dialog.isCurrent()) {
                    dialog._designer = new Application({
                        actions: false,
                        element: dialog.get$popup().find(".form-body"),
                        immutable: true,
                        draft: _.result(dialog.options, "isDraft"),
                        layoutData: _.result(dialog.options, "layoutData"),
                        workflowId: _.result(dialog.options, "workflowId"),
                        currentStepId: _.result(dialog.options, "currentStepId")
                    });
                }
            });
        },

        /**
         * Adds a transition label related hint message to the dialog's footer.
         */
        _addLabelHint: function() {
            this.getButtonsContainer().prepend(Templates.Dialog.labelMouseOverHint());
        }
    });
});

AJS.namespace("JIRA.WorkflowDesigner.Dialog", null, require("workflow-designer/dialog"));;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:dialog', location = 'soy/Dialog.soy' */
// This file was automatically generated from Dialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.WorkflowDesigner.Templates.Dialog.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.WorkflowDesigner == 'undefined') { JIRA.WorkflowDesigner = {}; }
if (typeof JIRA.WorkflowDesigner.Templates == 'undefined') { JIRA.WorkflowDesigner.Templates = {}; }
if (typeof JIRA.WorkflowDesigner.Templates.Dialog == 'undefined') { JIRA.WorkflowDesigner.Templates.Dialog = {}; }


JIRA.WorkflowDesigner.Templates.Dialog.workflowDialog = function(opt_data, opt_ignored) {
  return '<div class="aui-dialog-content"><h2 class="dialog-title">' + soy.$$escapeHtml(opt_data.title) + '</h2><div class="form-body"></div></div>';
};
if (goog.DEBUG) {
  JIRA.WorkflowDesigner.Templates.Dialog.workflowDialog.soyTemplateName = 'JIRA.WorkflowDesigner.Templates.Dialog.workflowDialog';
}


JIRA.WorkflowDesigner.Templates.Dialog.labelMouseOverHint = function(opt_data, opt_ignored) {
  return '<div class="buttons-container-left"><small>' + soy.$$escapeHtml("Mouse over objects to see transition names.") + '</small></div>';
};
if (goog.DEBUG) {
  JIRA.WorkflowDesigner.Templates.Dialog.labelMouseOverHint.soyTemplateName = 'JIRA.WorkflowDesigner.Templates.Dialog.labelMouseOverHint';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:workflow-designer-browser-is-supported', location = 'js/browserIsSupported.js' */
define("workflow-designer/browser-support", [
    "jira/util/navigator"
], function(
    navigator
) {
    /**
     * @returns {boolean} Whether the current browser is capable of running
     *     the workflow designer.
     */
    return {
        browserIsSupported: function browserIsSupported() {
            return !(navigator.isIE() && parseInt(navigator.majorVersion(), 10) < 10);
        }
    };
});

AJS.namespace("JIRA.WorkflowDesigner.browserIsSupported", null, require("workflow-designer/browser-support").browserIsSupported);;
;
/* module-key = 'com.atlassian.jira.plugins.jira-workflow-designer:view-issue-page-workflow-designer', location = 'js/views/ViewIssue.js' */
(function () {
    var ApplicationLoader = require("workflow-designer/application-loader");
    var Dialog = require('workflow-designer/dialog');
    var jQuery = require("jquery");
    var skate = require("jira/skate");

    var WorkflowDataReader;
    var WorkflowAJAXManager;
    var Messages;

    function requireDependencies() {
        WorkflowDataReader = require("workflow-designer/io/workflow-data-reader");
        WorkflowAJAXManager = require("workflow-designer/io/ajax/workflow-ajax-manager");
        Messages = require("workflow-designer/messages");
    }



    /**
     * Current step id
     *
     * @inner
     * @type {number}
     */
    var currentStepId;

    /**
     * Cache for layout data
     *
     * @inner
     * @type {object}
     */
    var layoutData;

    /**
     * Dialog
     *
     * @inner
     * @type {JIRA.WorkflowDesigner.Dialog}
     */
    var workflowDialog;

    /**
     * Name of the workflow
     *
     * @inner
     * @type {string}
     */
    var workflowName;

    /**
     * Extract a parameter from a workflow image URL.
     *
     * @inner
     * @param {string} imageURL The workflow image URL.
     * @param {string} key The key of the parameter to extract.
     * @return {string} The value corresponding to <tt>key</tt> in <tt>imageURL</tt>'s query string.
     */
    function getImageURLParameter(imageURL, key) {
        var value = parseUri(imageURL).queryKey[key] || "";
        return decodeURIComponent(value.replace(/\+/g, "%20"));
    }

    /**
     * Load the layout data of the current issue's workflow.
     *
     * @inner
     * @return {jQuery.Deferred} A deferred that is resolved when the layout data has loaded.
     */
    function loadLayoutData() {
        var request;

        if (layoutData) {
            return jQuery.Deferred().resolve(layoutData).promise();
        } else {
            request = WorkflowAJAXManager.load(workflowName);
            request.done(function (models, response) {
                layoutData = response;
            });

            return request;
        }
    }

    workflowDialog = new Dialog({
        content: function (callback) {
            var dialog = this;

            ApplicationLoader.load()
                .pipe(requireDependencies)
                .pipe(loadLayoutData)
                .done(function () {
                    dialog.createDialogContent(callback);
                })
                .fail(function (errorMessage) {
                    errorMessage = errorMessage || "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.";
                    Messages.showErrorMessage(errorMessage);
                    workflowDialog.hide(true);
                });
        },
        id: "view-workflow-dialog",
        workflowId: function() {
            return workflowName;
        },
        currentStepId: function() {
            return currentStepId;
        },
        layoutData: function() {
            return WorkflowDataReader.read(layoutData);
        }
    });


    var CLASS_TYPE = (skate.type) ? skate.type.CLASSNAME : skate.types.CLASS;

    /**
     * @skate jira-workflow-designer-link
     */
    skate('jira-workflow-designer-link', {
        type: CLASS_TYPE,
        created: function(element) {
            var el = (this instanceof Element) ? this : element;
            el.classList.add('new-workflow-designer');
        },
        attached: function(element) {
            var el = (this instanceof Element) ? this : element;
            var workflowImageURL = el.getAttribute("href");
            workflowName = getImageURLParameter(workflowImageURL, "workflowName");
            currentStepId = parseInt(getImageURLParameter(workflowImageURL, "stepId"), 10);
            layoutData = null;
        },
        events: {
            "click": function(element, e) {
                workflowDialog && workflowDialog.show();
                e.preventDefault();
            }
        }
    });

}());


/**
 * Code related to showing a read-only version of the new workflow designer on the view issue page.
 *
 * @function JIRA.WorkflowDesigner.ViewIssue.replaceViewWorkflowLink
 * @deprecated Since JIRA 7.0. This module is unnecessary now that the {@link skate:jira-workflow-designer-link} component exists.
 */
AJS.namespace("JIRA.WorkflowDesigner.ViewIssue.replaceViewWorkflowLink", null, jQuery.noop);

/**
 * @function JIRA.WorkflowDesigner.Templates.ViewIssue.viewWorkflowLink
 * @deprecated Since JIRA 7.0. This module is unnecessary now that the {@link skate:jira-workflow-designer-link} component exists.
 */
AJS.namespace("JIRA.WorkflowDesigner.Templates.ViewIssue.viewWorkflowLink", null, jQuery.noop);
;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/rpc.js' */
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Remote procedure call library for gadget-to-container,
 * container-to-gadget, and gadget-to-gadget (thru container) communication.
 *
 *
 */

var gadgets = gadgets || {};

/**
 * @static
 * @class Provides operations for making rpc calls.
 * @name gadgets.rpc
 */
gadgets.rpc = function() {
  // General constants.
  var CALLBACK_NAME = '__cb';
  var DEFAULT_NAME = '';

  // Consts for FrameElement.
  var FE_G2C_CHANNEL = '__g2c_rpc';
  var FE_C2G_CHANNEL = '__c2g_rpc';

  var services = {};
  var iframePool = [];
  var relayUrl = {};
  var useLegacyProtocol = {};
  var authToken = {};
  var callId = 0;
  var callbacks = {};
  var setup = {};
  var sameDomain = {};

  var params = {};

  // Load the authentication token for speaking to the container
  // from the gadget's parameters, or default to '0' if not found.
  if (gadgets.util) {
    params = gadgets.util.getUrlParameters();
  }

  authToken['..'] = params.rpctoken || params.ifpctok || 0;

  /*
   * Return a short code representing the best available cross-domain
   * message transport available to the browser.
   *
   * + For those browsers that support native messaging (various implementations
   *   of the HTML5 postMessage method), use that. Officially defined at
   *   http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html.
   *
   *   postMessage is a native implementation of XDC. A page registers that
   *   it would like to receive messages by listening the the "message" event
   *   on the window (document in DPM) object. In turn, another page can
   *   raise that event by calling window.postMessage (document.postMessage
   *   in DPM) with a string representing the message and a string
   *   indicating on which domain the receiving page must be to receive
   *   the message. The target page will then have its "message" event raised
   *   if the domain matches and can, in turn, check the origin of the message
   *   and process the data contained within.
   *
   *     wpm: postMessage on the window object.
   *        - Internet Explorer 8+
   *        - Safari (latest nightlies as of 26/6/2008)
   *        - Firefox 3+
   *        - Opera 9+
   *
   *     dpm: postMessage on the document object.
   *        - Opera 8+
   *
   * + For Gecko-based browsers, the security model allows a child to call a
   *   function on the frameElement of the iframe, even if the child is in
   *   a different domain. This method is dubbed "frameElement" (fe).
   *
   *   The ability to add and call such functions on the frameElement allows
   *   a bidirectional channel to be setup via the adding of simple function
   *   references on the frameElement object itself. In this implementation,
   *   when the container sets up the authentication information for that gadget
   *   (by calling setAuth(...)) it as well adds a special function on the
   *   gadget's iframe. This function can then be used by the gadget to send
   *   messages to the container. In turn, when the gadget tries to send a
   *   message, it checks to see if this function has its own function stored
   *   that can be used by the container to call the gadget. If not, the
   *   function is created and subsequently used by the container.
   *   Note that as a result, FE can only be used by a container to call a
   *   particular gadget *after* that gadget has called the container at
   *   least once via FE.
   *
   *     fe: Gecko-specific frameElement trick.
   *        - Firefox 1+
   *
   * + For all others, we have a fallback mechanism known as "ifpc". IFPC
   *   exploits the fact that while same-origin policy prohibits a frame from
   *   accessing members on a window not in the same domain, that frame can,
   *   however, navigate the window heirarchy (via parent). This is exploited by
   *   having a page on domain A that wants to talk to domain B create an iframe
   *   on domain B pointing to a special relay file and with a message encoded
   *   after the hash (#). This relay, in turn, finds the page on domain B, and
   *   can call a receipt function with the message given to it. The relay URL
   *   used by each caller is set via the gadgets.rpc.setRelayUrl(..) and
   *   *must* be called before the call method is used.
   *
   *     ifpc: Iframe-based method, utilizing a relay page, to send a message.
   */
  function getRelayChannel() {
    return typeof window.postMessage === 'function' ? 'wpm' :
        typeof document.postMessage === 'function' ? 'dpm' :
            navigator.product === 'Gecko' ? 'fe' :
                'ifpc';
  }

  /**
   * Conducts any initial global work necessary to setup the
   * channel type chosen.
   */
  function setupChannel() {
    // If the channel type is one of the native
    // postMessage based ones, setup the handler to receive
    // messages.
    if (relayChannel === 'dpm' || relayChannel === 'wpm') {
      window.addEventListener('message', function(packet) {
        // JRA-36335: Anyone could be publishing a 'message' so need to make sure
        // we handle errors more gracefully in case the packet doesn't contain what
        // was expected
        try {
          if (packet && packet.origin && packet.origin !== "null" && typeof packet.data === 'string' ) {
            AJS.$.get(AJS.contextPath() + '/rest/whitelist/1/check', {url: packet.origin})
                .done(function (result) {
                  if (result && result.inbound && result.inbound === true) {
                    process(gadgets.json.parse(packet.data));
                  }
                  else {
                    if(AJS.debug) {
                      AJS.log("RPC: request rejected (bad origin): " + (packet && packet.origin ? packet.origin : "undefined origin"));
                    }
                  }
                })
                .fail(function (jqXHR, textStatus, errorThrown) {
                  AJS.log('RPC: REST ' + textStatus, errorThrown);
                });
          } else {
            if(AJS.debug) {
              AJS.log("RPC: request rejected (bad origin): " + (packet && packet.origin ? packet.origin : "undefined origin"));
            }
          }
        } catch (e) {
          if (AJS.debug) {
            var origin = packet && packet.origin ? packet.origin : "undefined origin";
            AJS.log("Error processing gadget rpc message from '" + origin + "': " + e);
          }
        }
      }, false);
    }
  }

  // Pick the most efficient RPC relay mechanism
  var relayChannel = getRelayChannel();

  // Conduct any setup necessary for the chosen channel.
  setupChannel();

  // Create the Default RPC handler.
  services[DEFAULT_NAME] = function() {
    throw new Error('Unknown RPC service: ' + this.s);
  };

  // Create a Special RPC handler for callbacks.
  services[CALLBACK_NAME] = function(callbackId, result) {
    var callback = callbacks[callbackId];
    if (callback) {
      delete callbacks[callbackId];
      callback(result);
    }
  };

  /**
   * Conducts any frame-specific work necessary to setup
   * the channel type chosen. This method is called when
   * the container page first registers the gadget in the
   * RPC mechanism. Gadgets, in turn, will complete the setup
   * of the channel once they send their first messages.
   */
  function setupFrame(frameId) {
    if (setup[frameId]) {
      return;
    }

    if (relayChannel === 'fe') {
      try {
        var frame = document.getElementById(frameId);
        frame[FE_G2C_CHANNEL] = function(args) {
          process(gadgets.json.parse(args));
        };
      } catch (e) {
        // Something went wrong. System will fallback to
        // IFPC.
      }
    }

    setup[frameId] = true;
  }

  /**
   * Encodes arguments for the legacy IFPC wire format.
   *
   * @param {Object} args
   * @return {String} the encoded args
   */
  function encodeLegacyData(args) {
    var stringify = gadgets.json.stringify;
    var argsEscaped = [];
    for(var i = 0, j = args.length; i < j; ++i) {
      argsEscaped.push(encodeURIComponent(stringify(args[i])));
    }
    return argsEscaped.join('&');
  }

  /**
   * Helper function to process an RPC request
   * @param {Object} rpc RPC request object
   * @private
   */
  function process(rpc) {
    //
    // RPC object contents:
    //   s: Service Name
    //   f: From
    //   c: The callback ID or 0 if none.
    //   a: The arguments for this RPC call.
    //   t: The authentication token.
    //
    if (rpc && typeof rpc.s === 'string' && typeof rpc.f === 'string' &&
        rpc.a instanceof Array) {

      // Validate auth token.
      if (authToken[rpc.f]) {
        // We allow type coercion here because all the url params are strings.
        if (authToken[rpc.f] != rpc.t) {
          if (AJS.debug) {
            console.log('Invalid auth token received for operation: ' + rpc.s);
          }
          return;
        }
      }

      // If there is a callback for this service, attach a callback function
      // to the rpc context object for asynchronous rpc services.
      //
      // Synchronous rpc request handlers should simply ignore it and return a
      // value as usual.
      // Asynchronous rpc request handlers, on the other hand, should pass its
      // result to this callback function and not return a value on exit.
      //
      // For example, the following rpc handler passes the first parameter back
      // to its rpc client with a one-second delay.
      //
      // function asyncRpcHandler(param) {
      //   var me = this;
      //   setTimeout(function() {
      //     me.callback(param);
      //   }, 1000);
      // }
      if (rpc.c) {
        rpc.callback = function(result) {
          gadgets.rpc.call(rpc.f, CALLBACK_NAME, null, rpc.c, result);
        };
      }

      // Call the requested RPC service.
      var result = (services[rpc.s] ||
      services[DEFAULT_NAME]).apply(rpc, rpc.a);

      // If the rpc request handler returns a value, immediately pass it back
      // to the callback. Otherwise, do nothing, assuming that the rpc handler
      // will make an asynchronous call later.
      if (rpc.c && typeof result != 'undefined') {
        gadgets.rpc.call(rpc.f, CALLBACK_NAME, null, rpc.c, result);
      }
    }
  }

  /**
   * Attempts to conduct an RPC call to the specified
   * target with the specified data via the FrameElement
   * method. If this method fails, the system attempts again
   * using the known default of IFPC.
   *
   * @param {String} targetId Module Id of the RPC service provider.
   * @param {String} serviceName Service name to call.
   * @param {String} from Module Id of the calling provider.
   * @param {Object} rpcData The RPC data for this call.
   * @param {Array.<Object>} callArgs Original arguments to call()
   */
  function callFrameElement(targetId, serviceName, from, rpcData, callArgs) {
    try {
      if (from != '..') {
        // Call from gadget to the container.
        var fe = window.frameElement;

        if (typeof fe[FE_G2C_CHANNEL] === 'function') {
          // Complete the setup of the FE channel if need be.
          if (typeof fe[FE_G2C_CHANNEL][FE_C2G_CHANNEL] !== 'function') {
            fe[FE_G2C_CHANNEL][FE_C2G_CHANNEL] = function(args) {
              process(gadgets.json.parse(args));
            };
          }

          // Conduct the RPC call.
          fe[FE_G2C_CHANNEL](rpcData);
          return;
        }
      } else {
        // Call from container to gadget[targetId].
        var frame = document.getElementById(targetId);

        if (typeof frame[FE_G2C_CHANNEL] === 'function' &&
            typeof frame[FE_G2C_CHANNEL][FE_C2G_CHANNEL] === 'function') {

          // Conduct the RPC call.
          frame[FE_G2C_CHANNEL][FE_C2G_CHANNEL](rpcData);
          return;
        }
      }
    } catch (e) {
    }

    // If we have reached this point, something has failed
    // with the FrameElement method, so we default to using
    // IFPC for this call.
    callIfpc(targetId, serviceName, from, rpcData, callArgs);
  }

  /**
   * Conducts an RPC call to the specified
   * target with the specified data via the IFPC
   * method.
   *
   * @param {String} targetId Module Id of the RPC service provider.
   * @param {String} serviceName Service name to call.
   * @param {String} from Module Id of the calling provider.
   * @param {Object} rpcData The RPC data for this call.
   * @param {Array.<Object>} callArgs Original arguments to call()
   */
  function callIfpc(targetId, serviceName, from, rpcData, callArgs) {
    // Retrieve the relay file used by IFPC. Note that
    // this must be set before the call, and so we conduct
    // an extra check to ensure it is not blank.
    var relay = gadgets.rpc.getRelayUrl(targetId);

    if (!relay) {
      throw new Error('No relay file assigned for IFPC');
    }

    // The RPC mechanism supports two formats for IFPC (legacy and current).
    var src = null;
    if (useLegacyProtocol[targetId]) {
      // Format: #iframe_id&callId&num_packets&packet_num&block_of_data
      src = [relay, '#', encodeLegacyData([from, callId, 1, 0,
        encodeLegacyData([from, serviceName, '', '', from].concat(
            callArgs))])].join('');
    } else {
      // Format: #targetId & sourceId@callId & packetNum & packetId & packetData
      src = [relay, '#', targetId, '&', from, '@', callId,
        '&1&0&', encodeURIComponent(rpcData)].join('');
    }

    // Conduct the IFPC call by creating the Iframe with
    // the relay URL and appended message.
    emitInvisibleIframe(src);
  }


  /**
   * Helper function to emit an invisible IFrame.
   * @param {String} src SRC attribute of the IFrame to emit.
   * @private
   */
  function emitInvisibleIframe(src) {
    var iframe;
    // Recycle IFrames
    for (var i = iframePool.length - 1; i >=0; --i) {
      var ifr = iframePool[i];
      try {
        if (ifr && (ifr.recyclable || ifr.readyState === 'complete')) {
          ifr.parentNode.removeChild(ifr);
          if (window.ActiveXObject) {
            // For MSIE, delete any iframes that are no longer being used. MSIE
            // cannot reuse the IFRAME because a navigational click sound will
            // be triggered when we set the SRC attribute.
            // Other browsers scan the pool for a free iframe to reuse.
            iframePool[i] = ifr = null;
            iframePool.splice(i, 1);
          } else {
            ifr.recyclable = false;
            iframe = ifr;
            break;
          }
        }
      } catch (e) {
        // Ignore; IE7 throws an exception when trying to read readyState and
        // readyState isn't set.
      }
    }
    // Create IFrame if necessary
    if (!iframe) {
      iframe = document.createElement('iframe');
      iframe.style.border = iframe.style.width = iframe.style.height = '0px';
      iframe.style.visibility = 'hidden';
      iframe.style.position = 'absolute';
      iframe.onload = function() { this.recyclable = true; };
      iframePool.push(iframe);
    }
    iframe.src = src;
    setTimeout(function() { document.body.appendChild(iframe); }, 0);
  }

  /**
   * Attempts to make an rpc by calling the target's receive method directly.
   * This works when gadgets are rendered on the same domain as their container,
   * a potentially useful optimization for trusted content which keeps
   * RPC behind a consistent interface.
   * @param {String} target Module id of the rpc service provider
   * @param {String} from Module id of the caller (this)
   * @param {String} callbackId Id of the call
   * @param {String} rpcData JSON-encoded RPC payload
   * @return
   */
  function callSameDomain(target, rpc) {
    if (typeof sameDomain[target] === 'undefined') {
      // Seed with a negative, typed value to avoid
      // hitting this code path repeatedly
      sameDomain[target] = false;
      var targetEl = null;
      if (target === '..') {
        targetEl = parent;
      } else {
        targetEl = frames[target];
      }
      try {
        // If this succeeds, then same-domain policy applied
        sameDomain[target] = targetEl.gadgets.rpc.receiveSameDomain;
      } catch (e) {
        // Usual case: different domains
      }
    }

    if (typeof sameDomain[target] === 'function') {
      // Call target's receive method
      sameDomain[target](rpc);
      return true;
    }

    return false;
  }

  // gadgets.config might not be available, such as when serving container js.
  if (gadgets.config) {
    /**
     * Initializes RPC from the provided configuration.
     */
    function init(config) {
      // Allow for wild card parent relay files as long as it's from a
      // white listed domain. This is enforced by the rendering servlet.
      if (config.rpc.parentRelayUrl.substring(0, 7) === 'http://') {
        relayUrl['..'] = config.rpc.parentRelayUrl;
      } else {
        // It's a relative path, and we must append to the parent.
        // We're relying on the server validating the parent parameter in this
        // case. Because of this, parent may only be passed in the query, not
        // the fragment.
        var params = document.location.search.substring(0).split("&");
        var parentParam = "";
        for (var i = 0, param; param = params[i]; ++i) {
          // Only the first parent can be validated.
          if (param.indexOf("parent=") === 0) {
            parentParam = decodeURIComponent(param.substring(7));
            break;
          }
        }
        relayUrl['..'] = parentParam + config.rpc.parentRelayUrl;
      }
      useLegacyProtocol['..'] = !!config.rpc.useLegacyProtocol;
    }

    var requiredConfig = {
      parentRelayUrl : gadgets.config.NonEmptyStringValidator
    };
    gadgets.config.register("rpc", requiredConfig, init);
  }

  return /** @scope gadgets.rpc */ {
    /**
     * Registers an RPC service.
     * @param {String} serviceName Service name to register.
     * @param {Function} handler Service handler.
     *
     * @member gadgets.rpc
     */
    register: function(serviceName, handler) {
      if (serviceName == CALLBACK_NAME) {
        throw new Error("Cannot overwrite callback service");
      }

      if (serviceName == DEFAULT_NAME) {
        throw new Error("Cannot overwrite default service:"
            + " use registerDefault");
      }

      services[serviceName] = handler;
    },

    /**
     * Unregisters an RPC service.
     * @param {String} serviceName Service name to unregister.
     *
     * @member gadgets.rpc
     */
    unregister: function(serviceName) {
      if (serviceName == CALLBACK_NAME) {
        throw new Error("Cannot delete callback service");
      }

      if (serviceName == DEFAULT_NAME) {
        throw new Error("Cannot delete default service:"
            + " use unregisterDefault");
      }

      delete services[serviceName];
    },

    /**
     * Registers a default service handler to processes all unknown
     * RPC calls which raise an exception by default.
     * @param {Function} handler Service handler.
     *
     * @member gadgets.rpc
     */
    registerDefault: function(handler) {
      services[''] = handler;
    },

    /**
     * Unregisters the default service handler. Future unknown RPC
     * calls will fail silently.
     *
     * @member gadgets.rpc
     */
    unregisterDefault: function() {
      delete services[''];
    },

    /**
     * Calls an RPC service.
     * @param {String} targetId Module Id of the RPC service provider.
     *                          Empty if calling the parent container.
     * @param {String} serviceName Service name to call.
     * @param {Function|null} callback Callback function (if any) to process
     *                                 the return value of the RPC request.
     * @param {*} var_args Parameters for the RPC request.
     *
     * @member gadgets.rpc
     */
    call: function(targetId, serviceName, callback, var_args) {
      ++callId;
      targetId = targetId || '..';
      if (callback) {
        callbacks[callId] = callback;
      }

      // Default to the container calling.
      var from = '..';

      if (targetId === '..') {
        from = window.name;
      }

      // Not used by legacy, create it anyway...
      var rpc = {
        s: serviceName,
        f: from,
        c: callback ? callId : 0,
        a: Array.prototype.slice.call(arguments, 3),
        t: authToken[targetId]
      };

      // If target is on the same domain, call method directly
      if (callSameDomain(targetId, rpc)) {
        return;
      }

      var rpcData = gadgets.json.stringify(rpc);

      var channelType = relayChannel;

      // If we are told to use the legacy format, then we must
      // default to IFPC.
      if (useLegacyProtocol[targetId]) {
        channelType = 'ifpc';
      }

      switch (channelType) {
        case 'dpm': // use document.postMessage.
          var targetDoc = targetId === '..' ? parent.document :
              frames[targetId].document;
          targetDoc.postMessage(rpcData);
          break;

        case 'wpm': // use window.postMessage.
          var targetWin = targetId === '..' ? parent : frames[targetId];
          targetWin.postMessage(rpcData, relayUrl[targetId]);
          break;

        case 'fe': // use FrameElement.
          callFrameElement(targetId, serviceName, from, rpcData, rpc.a);
          break;

        default: // use 'ifpc' as a fallback mechanism.
          callIfpc(targetId, serviceName, from, rpcData, rpc.a);
          break;
      }
    },

    /**
     * Gets the relay URL of a target frame.
     * @param {String} targetId Name of the target frame.
     * @return {String|undefined} Relay URL of the target frame.
     *
     * @member gadgets.rpc
     */
    getRelayUrl: function(targetId) {
      return relayUrl[targetId];
    },

    /**
     * Sets the relay URL of a target frame.
     * @param {String} targetId Name of the target frame.
     * @param {String} url Full relay URL of the target frame.
     * @param {Boolean} opt_useLegacy True if this relay needs the legacy IFPC
     *     wire format.
     *
     * @member gadgets.rpc
     */
    setRelayUrl: function(targetId, url, opt_useLegacy) {
      relayUrl[targetId] = url;
      useLegacyProtocol[targetId] = !!opt_useLegacy;
    },

    /**
     * Sets the auth token of a target frame.
     * @param {String} targetId Name of the target frame.
     * @param {String} token The authentication token to use for all
     *     calls to or from this target id.
     *
     * @member gadgets.rpc
     */
    setAuthToken: function(targetId, token) {
      authToken[targetId] = token;
      setupFrame(targetId);
    },

    /**
     * Gets the RPC relay mechanism.
     * @return {String} RPC relay mechanism. See above for
     *   a list of supported types.
     *
     * @member gadgets.rpc
     */
    getRelayChannel: function() {
      return relayChannel;
    },

    /**
     * Receives and processes an RPC request. (Not to be used directly.)
     * @param {Array.<String>} fragment An RPC request fragment encoded as
     *        an array. The first 4 elements are target id, source id & call id,
     *        total packet number, packet id. The last element stores the actual
     *        JSON-encoded and URI escaped packet data.
     *
     * @member gadgets.rpc
     */
    receive: function(fragment) {
      if (fragment.length > 4) {
        // TODO parse fragment[1..3] to merge multi-fragment messages
        process(gadgets.json.parse(
            decodeURIComponent(fragment[fragment.length - 1])));
      }
    },

    /**
     * Receives and processes an RPC request sent via the same domain.
     * (Not to be used directly). Converts the inbound rpc object's
     * Array into a local Array to pass the process() Array test.
     * @param {Object} rpc RPC object containing all request params
     */
    receiveSameDomain: function(rpc) {
      // Pass through to local process method but converting to a local Array
      rpc.a = Array.prototype.slice.call(rpc.a);
      window.setTimeout(function() { process(rpc) }, 0);
    }
  };
}();

;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/util.js' */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Utility functions for the Open Gadget Container
 */

Function.prototype.inherits = function(parentCtor) {
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  this.superClass_ = parentCtor.prototype;
  this.prototype = new tempCtor();
  this.prototype.constructor = this;
};;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/json.js' */
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * @fileoverview
 * The global object gadgets.json contains two methods.
 *
 * gadgets.json.stringify(value) takes a JavaScript value and produces a JSON
 * text. The value must not be cyclical.
 *
 * gadgets.json.parse(text) takes a JSON text and produces a JavaScript value.
 * It will return false if there is an error.
*/

var gadgets = gadgets || {};

/**
 * @static
 * @class Provides operations for translating objects to and from JSON.
 * @name gadgets.json
 */

/**
 * Port of the public domain JSON library by Douglas Crockford.
 * See: http://www.json.org/json2.js
 */
gadgets.json = function () {

  /**
   * Formats integers to 2 digits.
   * @param {Number} n
   */
  function f(n) {
    return n < 10 ? '0' + n : n;
  }

  Date.prototype.toJSON = function () {
    return [this.getUTCFullYear(), '-',
           f(this.getUTCMonth() + 1), '-',
           f(this.getUTCDate()), 'T',
           f(this.getUTCHours()), ':',
           f(this.getUTCMinutes()), ':',
           f(this.getUTCSeconds()), 'Z'].join("");
  };

  // table of character substitutions
  var m = {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '"' : '\\"',
    '\\': '\\\\'
  };

  /**
   * Converts a json object into a string.
   */
  function stringify(value) {
    var a,          // The array holding the partial texts.
        i,          // The loop counter.
        k,          // The member key.
        l,          // Length.
        r = /["\\\x00-\x1f\x7f-\x9f]/g,
        v;          // The member value.

    switch (typeof value) {
    case 'string':
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe ones.
      return r.test(value) ?
          '"' + value.replace(r, function (a) {
            var c = m[a];
            if (c) {
              return c;
            }
            c = a.charCodeAt();
            return '\\u00' + Math.floor(c / 16).toString(16) +
                (c % 16).toString(16);
            }) + '"'
          : '"' + value + '"';
    case 'number':
    // JSON numbers must be finite. Encode non-finite numbers as null.
      return isFinite(value) ? String(value) : 'null';
    case 'boolean':
    case 'null':
      return String(value);
    case 'object':
    // Due to a specification blunder in ECMAScript,
    // typeof null is 'object', so watch out for that case.
      if (!value) {
        return 'null';
      }
      // toJSON check removed; re-implement when it doesn't break other libs.
      a = [];
      if (typeof value.length === 'number' &&
          !(value.propertyIsEnumerable('length'))) {
        // The object is an array. Stringify every element. Use null as a
        // placeholder for non-JSON values.
        l = value.length;
        for (i = 0; i < l; i += 1) {
          a.push(stringify(value[i]) || 'null');
        }
        // Join all of the elements together and wrap them in brackets.
        return '[' + a.join(',') + ']';
      }
      // Otherwise, iterate through all of the keys in the object.
      for (k in value) if (value.hasOwnProperty(k)) {
        if (typeof k === 'string') {
          v = stringify(value[k]);
          if (v) {
            a.push(stringify(k) + ':' + v);
          }
        }
      }
      // Join all of the member texts together and wrap them in braces.
      return '{' + a.join(',') + '}';
    }
  }

  return {
    stringify: stringify,
    parse: function (text) {
// Parsing happens in three stages. In the first stage, we run the text against
// regular expressions that look for non-JSON patterns. We are especially
// concerned with '()' and 'new' because they can cause invocation, and '='
// because it can cause mutation. But just to be safe, we want to reject all
// unexpected forms.

// We split the first stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace all backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

      if (/^[\],:{}\s]*$/.test(text.replace(/\\["\\\/b-u]/g, '@').
          replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
          replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
        return eval('(' + text + ')');
      }
      // If the text is not JSON parseable, then return false.

      return false;
    }
  };
}();

;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/gadgets-core.js' */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

var gadgets = gadgets || {};

gadgets.error = {};
gadgets.error.SUBCLASS_RESPONSIBILITY = 'subclass responsibility';
gadgets.error.TO_BE_DONE = 'to be done';

gadgets.log = function(message) {
  if (window.console && console.log) {
    console.log(message);
  } else {
    var logEntry = document.createElement('div');
    logEntry.className = 'gadgets-log-entry';
    logEntry.innerHTML = message;
    document.body.appendChild(logEntry);
  }
};


//----------
//Extensible

gadgets.Extensible = function() {
};

/**
* Sets the dependencies.
* @param {Object} dependencies Object whose properties are set on this
*     container as dependencies
*/
gadgets.Extensible.prototype.setDependencies = function(dependencies) {
    for (var p in dependencies) {
        this[p] = dependencies[p];
    }
};

/**
* Returns a dependency given its name.
* @param {String} name Name of dependency
* @return {Object} Dependency with that name or undefined if not found
*/
gadgets.Extensible.prototype.getDependencies = function(name) {
    return this[name];
};


//-------------
//UserPrefStore

/**
* User preference store interface.
* @constructor
*/
gadgets.UserPrefStore = function() {
};

/**
* Gets all user preferences of a gadget.
* @param {Object} gadget Gadget object
* @return {Object} All user preference of given gadget
*/
gadgets.UserPrefStore.prototype.getPrefs = function(gadget) {
throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

/**
* Saves user preferences of a gadget in the store.
* @param {Object} gadget Gadget object
* @param {Object} prefs User preferences
*/
gadgets.UserPrefStore.prototype.savePrefs = function(gadget) {
throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};


//-------------
//DefaultUserPrefStore

/**
* User preference store implementation.
* TODO: Turn this into a real implementation that is production safe
* @constructor
*/
gadgets.DefaultUserPrefStore = function() {
gadgets.UserPrefStore.call(this);
};
gadgets.DefaultUserPrefStore.inherits(gadgets.UserPrefStore);

gadgets.DefaultUserPrefStore.prototype.getPrefs = function(gadget) { };

gadgets.DefaultUserPrefStore.prototype.savePrefs = function(gadget) { };


//-------------
//GadgetService

/**
* Interface of service provided to gadgets for resizing gadgets,
* setting title, etc.
* @constructor
*/
gadgets.GadgetService = function() {
};

gadgets.GadgetService.prototype.setHeight = function(elementId, height) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

gadgets.GadgetService.prototype.setTitle = function(gadget, title) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

gadgets.GadgetService.prototype.setUserPref = function(id) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

//----------------
//IfrGadgetService

/**
* Base implementation of GadgetService.  This implementation does not implement setting the title or user prefs as it
* is meant for gadgets that are standalone on a page.  
* @constructor
*/
gadgets.IfrGadgetService = function() {
    gadgets.GadgetService.call(this);
    
    /**
     * This is a bit funky looking but we need to be sure we always call the right method, even if the implementation
     * has been overridden after an IfrGadgetService is instantiated.
     */
    var service = this;
    gadgets.rpc.register('resize_iframe', function() { service.setHeight.apply(this, arguments); });
    gadgets.rpc.register('set_pref', function() { service.setUserPref.apply(this, arguments); });
    gadgets.rpc.register('set_title', function() { service.setTitle.apply(this, arguments); });
    gadgets.rpc.register('requestNavigateTo', function() { service.requestNavigateTo.apply(this, arguments); });
};

gadgets.IfrGadgetService.inherits(gadgets.GadgetService);

gadgets.IfrGadgetService.prototype.setHeight = function(height) {
    if (height > gadgets.container.maxheight_) {
        height = gadgets.container.maxheight_;
    }

    var element = document.getElementById(this.f);
    if (element) {
        element.style.height = height + 'px';
    }
};
    
/**
* Navigates the page to a new url based on a gadgets requested view and
* parameters.
*/
gadgets.IfrGadgetService.prototype.requestNavigateTo = function(view, opt_params) {
    var id = this.getGadgetIdFromModuleId(this.f);
    var url = this.getUrlForView(view);

    if (opt_params) {
        var paramStr = JSON.stringify(opt_params);
        if (paramStr.length > 0) {
            url += '&appParams=' + encodeURIComponent(paramStr);
        }
    }

    if (url && document.location.href.indexOf(url) == -1) {
        document.location.href = url;
    }
};

/**
* This is a silly implementation that will need to be overriden by almost all
* real containers.
* TODO: Find a better default for this function
*
* @param view The view name to get the url for
*/
gadgets.IfrGadgetService.prototype.getUrlForView = function(view) {
    if (view === 'canvas') {
        return '/canvas';
    } else if (view === 'profile') {
        return '/profile';
    } else {
        return null;
    }
};

gadgets.IfrGadgetService.prototype.getGadgetIdFromModuleId = function(moduleId) {
    // Quick hack to extract the gadget id from module id
    return parseInt(moduleId.match(/_([0-9]+)$/)[1], 10);
};

//-------------
//LayoutManager

/**
* Layout manager interface.
* @constructor
*/
gadgets.LayoutManager = function() {
};

/**
* Gets the HTML element that is the chrome of a gadget into which the content
* of the gadget can be rendered.
* @param {Object} gadget Gadget instance
* @return {Object} HTML element that is the chrome for the given gadget
*/
gadgets.LayoutManager.prototype.getGadgetChrome = function(gadget) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

//-------------------
//StaticLayoutManager

/**
* Static layout manager where gadget ids have a 1:1 mapping to chrome ids.
* @constructor
*/
gadgets.StaticLayoutManager = function() {
    gadgets.LayoutManager.call(this);
};

gadgets.StaticLayoutManager.inherits(gadgets.LayoutManager);

/**
* Sets chrome ids, whose indexes are gadget instance ids (starting from 0).
* @param {Array} gadgetIdToChromeIdMap Gadget id to chrome id map
*/
gadgets.StaticLayoutManager.prototype.setGadgetChromeIds = function(gadgetChromeIds) {
    this.gadgetChromeIds_ = gadgetChromeIds;
};

gadgets.StaticLayoutManager.prototype.getGadgetChrome = function(gadget) {
    var chromeId = this.gadgetChromeIds_[gadget.id];
    return chromeId ? document.getElementById(chromeId) : null;
};


//----------------------
//FloatLeftLayoutManager

/**
* FloatLeft layout manager where gadget ids have a 1:1 mapping to chrome ids.
* @constructor
* @param {String} layoutRootId Id of the element that is the parent of all
*     gadgets.
*/
gadgets.FloatLeftLayoutManager = function(layoutRootId) {
    gadgets.LayoutManager.call(this);
    this.layoutRootId_ = layoutRootId;
};

gadgets.FloatLeftLayoutManager.inherits(gadgets.LayoutManager);

gadgets.FloatLeftLayoutManager.prototype.getGadgetChrome = function(gadget) {
    var layoutRoot = document.getElementById(this.layoutRootId_);
    if (layoutRoot) {
        var chrome = document.createElement('div');
        chrome.className = 'gadgets-gadget-chrome';
        chrome.style.cssFloat = 'left';
        layoutRoot.appendChild(chrome);
        return chrome;
    } else {
        return null;
    }
};

;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-container-resources', location = 'js/gadgets-container.js' */
// ---------
// Container

/**
 * Container interface.
 * @constructor
 */
gadgets.Container = function() {
  this.parentUrl_ = 'http://' + document.location.host;
  this.country_ = 'ALL';
  this.language_ = 'ALL';
  this.view_ = 'default';
  this.nocache_ = 1;

  // signed max int
  this.maxheight_ = 0x7FFFFFFF;
};

gadgets.Container.inherits(gadgets.Extensible);

/**
 * Known dependencies:
 *     userPrefStore: instance of a subclass of gadgets.UserPrefStore
 *     gadgetService: instance of a subclass of gadgets.GadgetService
 *     layoutManager: instance of a subclass of gadgets.LayoutManager
 */

gadgets.Container.prototype.userPrefStore = new gadgets.DefaultUserPrefStore();

gadgets.Container.prototype.gadgetService = new gadgets.GadgetService();

gadgets.Container.prototype.layoutManager =
    new gadgets.StaticLayoutManager();

gadgets.Container.prototype.setParentUrl = function(url) {
  this.parentUrl_ = url;
};

gadgets.Container.prototype.setCountry = function(country) {
  this.country_ = country;
};

gadgets.Container.prototype.setNoCache = function(nocache) {
  this.nocache_ = nocache;
};

gadgets.Container.prototype.setLanguage = function(language) {
  this.language_ = language;
};

gadgets.Container.prototype.setView = function(view) {
  this.view_ = view;
};

gadgets.Container.prototype.setMaxHeight = function(maxheight) {
  this.maxheight_ = maxheight;
};

gadgets.Container.prototype.getGadgetKey_ = function(instanceId) {
  return 'gadget_' + instanceId;
};


// ------------
// IfrContainer

/**
 * Container that renders gadget using ifr.
 * @constructor
 */
gadgets.IfrContainer = function() {
  gadgets.Container.call(this);
};

gadgets.IfrContainer.inherits(gadgets.Container);

gadgets.IfrContainer.prototype.gadgetService = new gadgets.IfrGadgetService();

gadgets.IfrContainer.prototype.setParentUrl = function(url) {
  if (!url.match(/^http[s]?:\/\//)) {
    url = document.location.href.match(/^[^?#]+\//)[0] + url;
  }

  this.parentUrl_ = url;
};

/**
 * Default container.
 */
gadgets.container = new gadgets.IfrContainer();
;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-standalone-resources', location = 'js/gadgets-standalone.js' */
// implementations of setTitle and setPrefs would go here

new gadgets.IfrGadgetService();

gadgets.IfrGadgetService.prototype.setTitle = function(title) {
    //Ignore this call silently to avoid javascript exceptions & errors! (AG-1289)
};;
;
/* module-key = 'com.atlassian.plugins.helptips.jira-help-tips:common', location = 'js/HelpTip.js' */
(function($) {
    function nope() { return false; }
    function yep() { return true; }

    var HELP_TIP_CLASSNAMES = 'jira-help-tip aui-help';

    var cidCounter = 0, seed = new Date().getTime();

    // to un-fuck graphite event names
    function cleanAnalyticsName(name) {
        name = "" + (name || "");
        return name.replace(/\./g, "-");
    }

    function analytics(eventId, model) {
        if (AJS.EventQueue && model && model.attributes.id) {
            var event = {};
            var cleanId = cleanAnalyticsName(model.attributes.id);
            var eventPrefix = "";

            if (model.attributes.eventPrefix) {
                eventPrefix = model.attributes.eventPrefix;
                // Ensure a dot at the end of the event prefix
                if (eventPrefix.charAt(eventPrefix.length - 1) !== ".") {
                    eventPrefix += ".";
                }
            }

            event.name = eventPrefix + "helptips." + cleanId + "." + eventId;
            event.properties = {};
            AJS.EventQueue.push(event);
        }
    }

    function getCid() {
        return "jira-help-tip-" + seed + (cidCounter++);
    }

    /**
     * @param attributes
     * @param attributes.id
     * @param attributes.callbacks callbacks used by helptip and passed into AJS.InlineDialog
     * @param attributes.callbacks.beforeShow {jQuery.Deferred() | Function} called before rendering the helptip
     * @param attributes.callbacks.init {Function} passed into AJS.InlineDialog as initCallback param
     * @param attributes.callbacks.hide {Function} passed into AJS.InlineDialog as hideCallback param
     * @param attributes.isSequence {Boolean} to indicate whether this helptip should be shown in sequence
     *        see https://developer.atlassian.com/design/latest/feature-discovery.html
     * @param attributes.weight {Integer} the weight of the helptip determining the order to be shown in sequence
     * @param attributes.body {String} the HTML body content of the helptip
     * @param attributes.bodyHtml {String} same as attributes.body
     * @param attributes.inlineDialogOpts {Map} passed into AJS.InlineDialog as options, This will replace all the defaults specified by HelpTip
     * @param attributes.eventPrefix {String} The prefix to use for all analytics events
     * @param attributes.nextButtonText {String} The text to be displayed on the 'next' button
     * @param attributes.closeButtonText {String} The text to be displayed on the 'close' button
     * @param attributes.showCloseButton {Boolean} Whether the 'close' button should be displayed on the helptip
     *
     * @type {Function}
     */
    var HelpTip = AJS.HelpTip = function(attributes) {
        var anchor;
        this.attributes = $.extend({}, attributes);
        this.attributes.id || (this.attributes.id = false);
        this.attributes.callbacks || (this.attributes.callbacks = {});

        //Allows the helptip to be shown in sequence via next button
        if (this.attributes.isSequence) {
            if(!this.attributes.weight) {
                this.attributes.weight = Number.MAX_VALUE;
            }
            AJS.HelpTip.Manager.sequences.push(this);
        }

        // Map renamed attribute body to bodyHtml
        if (this.attributes.body) {
            this.attributes.bodyHtml = this.attributes.body;
            delete this.attributes.body;
        }
        this.cid = getCid();
        anchor = this.attributes['anchor'];
        delete this.attributes['anchor'];

        this.view = (anchor) ? new AnchoredView(this, anchor) : new UnanchoredView(this);
    };

    $.extend(HelpTip.prototype, {
        /**
         * @param options.force render the helptip regardless of the display controller
         */
        show: function(options) {
            options = options || {};

            var self = this;
            var showDeferred = $.Deferred();
            if (this.attributes.callbacks.beforeShow) {
                var beforeShowDeferred = this.attributes.callbacks.beforeShow();
                if (beforeShowDeferred && _.isFunction(beforeShowDeferred.done)) {
                    beforeShowDeferred.done(showDeferred.resolve)
                } else {
                    showDeferred.resolve();
                }
            } else {
                showDeferred.resolve();
            }

            showDeferred.done(function() {
                AJS.HelpTip.Manager.show(function() {
                    if (!self.isDismissed()) {
                        if (!options.force && AJS.Popups && AJS.Popups.DisplayController) {
                            AJS.Popups.DisplayController.request({
                                name:self.id,
                                weight:1000,
                                show:function () {
                                    self.view.show();
                                }})
                        } else {
                            self.view.show();
                        }
                        analytics("shown", self);
                    }
                });
            });
        },
        dismiss: function() {
            var reason = cleanAnalyticsName(arguments[0] || "programmatically");
            this.view.dismiss();
            //Clicking close should stop other helptip in sequence from showing
            if (reason === "close-button" && this.attributes.isSequence) {
                AJS.HelpTip.Manager.clearSequences();
            }
            if (!this.isDismissed()) {
                AJS.HelpTip.Manager.dismiss(this);
                analytics("dismissed." + reason, this);
            }
        },
        isVisible: function() {
            return this.view.$el.is(":visible");
        },
        isDismissed: function() {
            return AJS.HelpTip.Manager.isDismissed(this);
        },

        /**
         * Redraws the help tip.
         *  - If a selector was passed as the anchor, it will check if the actual element has changed and reanchor
         *    if necessary
         *  - If the anchor is not visible, it will hide the help tip
         *  - If the anchor has moved, it will re-position the help tip
         */
        refresh: function() {
            if (!this.isDismissed()) {
                this.view.refresh();
            }
        },

        /**
         * Hide the help tip without dismissing it
         */
        hide: function() {
            if (!this.isDismissed()) {
                this.view.dismiss();
            }
        },

        /**
         * Advance to the next help tip if this help tip
         * is part of a sequence and is not the last help
         * tip in the sequence. Useful in the situation where
         * user can progress by performing some action in addition to
         * clicking the next button.
         */
        showNextHelpTipInSequence: function() {
            this.view.clickNext();
        }
    });

    var AnchoredView = function(model, anchor) {
        this.initialize(model, anchor);
    };

    $.extend(AnchoredView.prototype, {
        initialize: function(model, anchor) {
            this.model = model;
            this.anchorSelector = anchor;
            this.anchor = AJS.$(anchor);
            this._initDialog(anchor);
            AJS.$(document).bind("showLayer",function(e,type,layer) {
                if (type === "inlineDialog" && layer.id === model.cid) {
                    AJS.InlineDialog.current = null; // Tips shouldn't be considered InlineDialogs.
                    AJS.$(document.body).unbind("click."+model.cid+".inline-dialog-check");
                    layer._validateClickToClose = nope;
                    layer.hide = nope;
                }
            });
        },
        show: function() {
            this.beforeHide = nope;
            this.popup.show();
        },
        refresh: function() {
            var maybeNewAnchor = AJS.$(this.anchorSelector);
            if (!maybeNewAnchor.is(':visible')) {
                this.dismiss(); // hide
            } else if (maybeNewAnchor.get(0) !== this.anchor.get(0)) {
                this.changeAnchor(maybeNewAnchor);
            } else if (!this.isVisible()) {
                this.show();
            } else {
                this.popup.refresh();
            }
        },
        changeAnchor: function(anchor) {
            var wasVisible = this.isVisible();
            this.dismiss();
            this.$el.remove();
            this.anchor = anchor;
            this._initDialog(anchor);
            if (wasVisible) {
                this.show();
            }
        },
        dismiss: function() {
            this.beforeHide = yep;
            this._popupHide();
        },
        clickNext: function() {
            var nextButton = AJS.$(this.$el).find(".helptip-next");
            if (nextButton.length > 0) {
                nextButton.click();
            }
        },
        isVisible: function() {
            return this.$el.is(':visible');
        },
        _initDialog: function(anchor) {
            var self = this;
            var model = this.model;
            this.popup = AJS.InlineDialog($(anchor), model.cid, _.bind(this._createDialog, this), _.extend({
                // Use a container other than body, so that the positioning works when there are client-rendered banner messages
                container: "#content",
                noBind: true,
                preHideCallback: function() { return self.beforeHide() },
                calculatePositions: function(popup, targetPosition, mousePosition, opts) {
                    // Adjust positions relative to the container
                    var cssData = AJS.InlineDialog.opts.calculatePositions(popup, targetPosition, mousePosition, opts);
                    var $container = $(this.container);
                    var offset = $container.offset();
                    if (cssData.popupCss.left !== 'auto') {
                        cssData.popupCss.left -= offset.left;
                        // Inline dialog has a bug where in some scenarios both left and right pos of the popup is set.
                        cssData.popupCss.right = 'auto';
                    }
                    cssData.popupCss.top -= offset.top;
                    return cssData;
                },
                addActiveClass: false,
                initCallback: model.attributes.callbacks.init,
                hideCallback: model.attributes.callbacks.hide,
                persistent: true
            }, model.attributes.inlineDialogOpts));
            this._popupHide = this.popup.hide;
            this.popup.hide = nope;
            this.$el = $(this.popup[0]);
            this.$el.addClass(HELP_TIP_CLASSNAMES);
        },
        _createDialog: function(content, trigger, show) {
            var instance = this;
            var sequenceDialogs = AJS.HelpTip.Manager.sequences;
            var position = this.model.attributes.position;
            var isSequence = this.model.attributes.isSequence;

            content.removeClass('contents');

            content.html($(AJS.Templates.HelpTip.tipContent(_.extend({
                showNextButton: isSequence && (sequenceDialogs.length > 1 && (position+1 < sequenceDialogs.length)),
                length: sequenceDialogs.length,
                position: position,
                showCloseButton: true
            }, this.model.attributes))));

            content.unbind('mouseover mouseout');
            content.find(".helptip-link").click(function() {
                analytics("learn-more.clicked", instance.model);
            });
            content.find(".helptip-close").click(function(e) {
                e.preventDefault();
                instance.model.dismiss("close-button");
            });
            content.find(".helptip-next").click(function(e) {
                e.preventDefault();
                instance.model.dismiss("next-button");
                var next = position + 1;
                sequenceDialogs[next] && (sequenceDialogs[next].show({force: true}));
            });
            show();
        }
    });

    var UnanchoredView = function(model) {
        this.initialize(model);
    };

    $.extend(UnanchoredView.prototype, {
        initialize: function() {
            this.$el = $("<div></div>");
            this.$el.addClass(HELP_TIP_CLASSNAMES);
        },
        show: function() { },
        dismiss: function() { }
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.plugins.helptips.jira-help-tips:common', location = 'js/HelpTipManager.js' */
(function($) {
    var restUrl = AJS.contextPath() + "/rest/helptips/1.0/tips";
    var tipWRMData = undefined;
    if (WRM && WRM.data) {
        tipWRMData = WRM.data.claim("com.atlassian.plugins.helptips.jira-help-tips:common.JiraHelpTipData");
    }

    var Manager = {
        dismissedTipIds: [],
        sequences: [],
        loaded: $.Deferred(),
        url: function() { return restUrl; },
        sync: function(verb, data) {
            var result = $.Deferred();
            verb || (verb = "get");
            data || (data = null);
            if (verb === "get" && tipWRMData && tipWRMData.dismissed) {
                result.resolve(tipWRMData.dismissed);
            } else {
                $.ajax(this.url(), {
                    type: verb,
                    dataType: "json",
                    contentType: "application/json",
                    data: data && JSON.stringify(data),
                    processData: false
                })
                    .done(function(data) {
                        result.resolve(data);
                    })
                    .fail(function() {
                        result.reject();
                    });
            }
            return result.promise();
        },
        fetch: function() {
            var result = this.sync();
            result.done($.proxy(function(response) {
                $.merge(this.dismissedTipIds, response);
                this.loaded.resolve();
            }, this));
            return result.promise();
        },
        show: function(showFunction) {
            this.loaded.done(showFunction);
        },
        dismiss: function(tip) {
            var id = tip.attributes.id;
            if (!id) {
                tip._dismissed = true;
            } else {
                this.dismissedTipIds.push(id);
                this.sync("post", {id:id});
            }
        },
        undismiss: function(tip) {
            var id = tip.attributes.id;
            if (!id) {
                tip._dismissed = false;
            } else {
                this.dismissedTipIds.splice($.inArray(id, this.dismissedTipIds), 1);
                this.sync("delete", {id:id});
            }
        },
        isDismissed: function(tip) {
            var id = tip.attributes.id;
            return (id) ? $.inArray(id, this.dismissedTipIds) >= 0 : tip._dismissed;
        },
        /**
         * Clear the list of helptips that would be shown in sequence
         */
        clearSequences: function() {
            this.sequences = [];
        },
        /**
         * Hide all the helptips that would be shown in sequence
         */
        hideSequences: function() {
            _.each(this.sequences, function(helptip) {
                helptip.view.dismiss();
            });
        },
        /**
         * Initiate the rendering of helptips in sequence starting from the first one
         */
        showSequences: function() {
            if (!this._showStarted) {
                var instance = this;
                var index = 0;
                this._showStarted = true;
                $.when(this.loaded).done(function() {
                    //Sort by weight
                    instance.sequences.sort(function(a, b) {
                        return a.attributes.weight - b.attributes.weight;
                    });
                    //Remove any helptips that have already been dismissed
                    instance.sequences = _.filter(instance.sequences, function(dialog) {
                        var shouldShow = _.indexOf(instance.dismissedTipIds, dialog.attributes.id) === -1;
                        if (shouldShow) {
                            dialog.attributes.position = index++;
                        }
                        return shouldShow;
                    });
                    if (instance.sequences.length > 0) {
                        //SW-1740: Ensure the last tip part of a sequence always shows the close button. Filtering out already dismissed
                        // tips above may have changed the original last tip.
                        _.last(instance.sequences).attributes.showCloseButton = true;

                        instance.sequences[0].show({force: true});
                    }
                    instance._showStarted = false;
                });
            }
        }
    };

    // Check if the user is logged in, otherwise the REST resource will return a status of 401 (Unauthorized)
    if (!JIRA.Users.LoggedInUser.isAnonymous()) {
        AJS.HelpTip.Manager = Manager;
        // Load up the user's dismissed tips.
        Manager.fetch();
    }
})(AJS.$);;
;
/* module-key = 'com.atlassian.plugins.helptips.jira-help-tips:common', location = 'templates/HelpTip.soy' */
// This file was automatically generated from HelpTip.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace AJS.Templates.HelpTip.
 */

if (typeof AJS == 'undefined') { var AJS = {}; }
if (typeof AJS.Templates == 'undefined') { AJS.Templates = {}; }
if (typeof AJS.Templates.HelpTip == 'undefined') { AJS.Templates.HelpTip = {}; }


AJS.Templates.HelpTip.tipContent = function(opt_data, opt_ignored) {
  return ((opt_data.title) ? '<h2 class="helptip-title">' + soy.$$escapeHtml(opt_data.title) + '</h2>' : '') + '<p class="helptip-body">' + soy.$$filterNoAutoescape(opt_data.bodyHtml) + '</p>' + ((opt_data.url) ? '<p><a class="helptip-link" href="' + soy.$$escapeHtml(opt_data.url) + '" target="_blank">' + ((opt_data.linkText) ? soy.$$escapeHtml(opt_data.linkText) : soy.$$escapeHtml("Learn more")) + '</a></p>' : '') + AJS.Templates.HelpTip.tipFooter(opt_data);
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.tipContent.soyTemplateName = 'AJS.Templates.HelpTip.tipContent';
}


AJS.Templates.HelpTip.tipFooter = function(opt_data, opt_ignored) {
  return '<form class="tip-footer">' + AJS.Templates.HelpTip.nextButton(opt_data) + AJS.Templates.HelpTip.closeButton(opt_data) + AJS.Templates.HelpTip.sequencePaging(opt_data) + '</form>';
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.tipFooter.soyTemplateName = 'AJS.Templates.HelpTip.tipFooter';
}


AJS.Templates.HelpTip.nextButton = function(opt_data, opt_ignored) {
  return '' + ((opt_data.showNextButton) ? '<button class="aui-button helptip-next" type="button">' + ((opt_data.nextButtonText) ? soy.$$escapeHtml(opt_data.nextButtonText) : soy.$$escapeHtml("Next")) + '</button>' : '');
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.nextButton.soyTemplateName = 'AJS.Templates.HelpTip.nextButton';
}


AJS.Templates.HelpTip.closeButton = function(opt_data, opt_ignored) {
  return '' + ((opt_data.showCloseButton) ? '<button class="aui-button ' + ((opt_data.showNextButton) ? ' aui-button-link ' : '') + ' helptip-close" type="button">' + ((opt_data.closeButtonText) ? soy.$$escapeHtml(opt_data.closeButtonText) : soy.$$escapeHtml("Close")) + '</button>' : '');
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.closeButton.soyTemplateName = 'AJS.Templates.HelpTip.closeButton';
}


AJS.Templates.HelpTip.sequencePaging = function(opt_data, opt_ignored) {
  return '' + ((opt_data.isSequence && opt_data.length > 1) ? '<span class="helptip-sequence-paging">' + soy.$$escapeHtml(opt_data.position + 1) + '/' + soy.$$escapeHtml(opt_data.length) + '</span>' : '');
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.sequencePaging.soyTemplateName = 'AJS.Templates.HelpTip.sequencePaging';
}
;
;
/* module-key = 'jira.webresources:version-blocks', location = '/includes/jira/versionblocks/VersionBlocks.js' */
JIRA.VersionBlocks = {};
JIRA.VersionBlocks.ClassNames = {
    VERSION_LIST: "versions-list",
    VERSION_CONTAINER: "version-block-container",
    EXPANDED_CONTENT_CONTAINER: "version-issue-table"
};
JIRA.VersionBlocks.init = (function () {
    var classNames = JIRA.VersionBlocks.ClassNames;
    var dataElement = AJS.$("."+classNames.VERSION_LIST).first();
    var urlEndpoint = getUrl();

    AJS.$(document).on("click", "a[data-version-block]", function(e) {
        var $a = AJS.$(this),
                $root = $a.closest("."+classNames.VERSION_CONTAINER);
        var isActive = $root.data("expanded");
        var $container = $root.find("."+classNames.EXPANDED_CONTENT_CONTAINER);
        var $spinner = AJS.$("<span class='icon loading'></span>");

        if (!$container.size()) {
            $container = AJS.$("<div/>").addClass(classNames.EXPANDED_CONTENT_CONTAINER).hide().appendTo($root);
        }

        // Tell the server about the state we want this version to be in now
        var extraParams = {};
        extraParams[(isActive) ? "collapseVersion" : "expandVersion"] = $root.find('[data-version-id]').data("version-id");

        // Make our request for data
        var request = AJS.$.ajax({
            url: urlEndpoint,
            data: getUrlParams(extraParams),
            dataType: "json",
            beforeSend: function() {
                $a.closest("ul").append(AJS.$("<li/>").append($spinner));
            }
        });

        request.always(function() {
            $spinner.parent("li").remove();
        });

        // Handle any errors in transmission or translation
        request.fail(function(jqXHR, textStatus, errorThrown) {
            console.log("Failed to load issues for version. User-facing error to do, sorry :(", arguments);
        });

        // Update our DOM with the result of the toggle
        if (!isActive) {
            request.done(function(data, textStatus, jqXHR) {
                var html = AJS.$("<div/>").html(data.content);
                var content = html.find("."+classNames.EXPANDED_CONTENT_CONTAINER);
                $container.hide().replaceWith(content).show();
            });
        } else {
            request.done(function() {
                $container.hide();
            });
        }

        // Toggle our state
        request.done(function() {
            $root.data("expanded", !isActive);
        });

        e.preventDefault();
    });

    /**
     * The URL we need to hit to get the list of issues we want, sans parameters.
     * Ideally this would be a REST endpoint and it'd return an array of issues.
     * Unfortunately I'm stuck with hitting a crappy overloaded URL that gets its
     * data crappily and renders crappy markup.
     * @private
     */
    function getUrl() {
        var href;
        href = document.location.href;
        href = href.replace(document.location.hash,"");
        href = href.replace(document.location.search,"");

        return href;
    }

    function getUrlParams(opts) {
        var params = {
            decorator: "none",
            contentOnly: true,
            noTitle: true,
            selectedTab: getSelectedTab(),
            pid: dataElement.data("project-id"),
            component: dataElement.data("component-id")
        };

        return jQuery.extend(params, opts);
    }

    function getSelectedTab() {
        var selectedTab = dataElement.data("selected-tab");
        var paramString = "" + document.location.search + document.location.hash;
        if (paramString.indexOf("selectedTab=") > -1) {
            selectedTab = paramString.replace(/^.*selectedTab=(.*?)(?:&.*$|$)/, "$1"); // a regex-ish substringer -- basically, discard everything before and after the value of the selectedTab param.
            selectedTab = decodeURIComponent(selectedTab);
        }
        return selectedTab;
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/lib/backbone.queryparams.js' */
/*! THIS FILE HAS BEEN MODIFIED BY ATLASSIAN, SEE https://github.com/jhudson8/backbone-query-parameters/pull/63/files */
(function (root, factory) {
   if (typeof exports === 'object' && root.require) {
     module.exports = factory(require("underscore"), require("backbone"));
   } else if (typeof define === "function" && define.amd) {
      // AMD. Register as an anonymous module.
      define(["underscore","backbone"], function(_, Backbone) {
        // Use global variables if the locals are undefined.
        return factory(_ || root._, Backbone || root.Backbone);
      });
   } else {
      // RequireJS isn't being used. Assume underscore and backbone are loaded in <script> tags
      factory(_, Backbone);
   }
}(this, function(_, Backbone) {

var queryStringParam = /^\?(.*)/,
    optionalParam = /\((.*?)\)/g,
    namedParam    = /(\(\?)?:\w+/g,
    splatParam    = /\*\w+/g,
    escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g,
    fragmentStrip = /^([^\?]*)/,
    namesPattern = /[\:\*]([^\:\?\/]+)/g,
    routeStripper = /^[#\/]|\s+$/g,
    trailingSlash = /\/$/;
Backbone.Router.arrayValueSplit = '|';

var _getFragment = function(fragment, forcePushState) {
  if (fragment == null) {
    if (this._hasPushState || !this._wantsHashChange || forcePushState) {
      fragment = this.location.pathname;
      var root = this.root.replace(trailingSlash, '');
      var search = this.location.search;
      if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
      if (search) fragment += search;
    } else {
      fragment = this.getHash();
    }
  }
  return fragment.replace(routeStripper, '');
};

function proxy(source, proxy, name) {
  _.each(Array.prototype.slice.call(arguments, 2), function (name) {
    Object.defineProperty(proxy, name, {
      get: function () { return source[name]; },
      set: function (value) { source[name] = value; }
    });
  });
}

proxy.isSupported = (function () {
  try {
    Object.defineProperty({}, 'x', {})
    return true;
  } catch (e) {
    return false;
  }
})();

function LocationRewriter(history) {
  var original = history.location,
      replacement = {};

  proxy(original, replacement, "assign", "ancestorOrigins",
      "origin", "hash", "search", "pathname", "port", "hostname", "host",
      "protocol", "href", "reload");

  replacement.replace = function() {
    original.replace(history.root + '#' + history.fragment);
  };

  replacement.unPatch = function() {
    return history.location = original;
  };

  history.location = replacement;
}

function HistoryRewriter(history) {
  var original = history.history,
      replacement = {};

  proxy(original, replacement, "length", "state", "back", "forward", "go",
      "pushState");

  replacement.replaceState = function(state, title, url) {
    url = history.root + history.fragment;
    return original.replaceState(state, title, url);
  };

  replacement.unPatch = function () {
    history.history = original;
  };

  history.history = replacement;
}

var _start = Backbone.History.prototype.start,
    _loadUrl = Backbone.History.prototype.loadUrl;

_.extend(Backbone.History.prototype, {
  getFragment: _getFragment,

  // this will not perform custom query param serialization specific to the router
  // but will return a map of key/value pairs (the value is a string or array)
  getQueryParameters: function(fragment, forcePushState) {
    fragment = _getFragment.apply(this, arguments);
    // if no query string exists, this will still be the original fragment
    var queryString = fragment.replace(fragmentStrip, '');
    var match = queryString.match(queryStringParam);
    if (match) {
      queryString = match[1];
      var rtn = {};
      iterateQueryString(queryString, function(name, value) {
        // decodeURIComponent doesn't touch '+'
        value = value.replace(/\+/g, '%20');
        value = decodeURIComponent(value);
        if (!rtn[name]) {
          rtn[name] = value;
        } else if (_.isString(rtn[name])) {
          rtn[name] = [rtn[name], value];
        } else {
          rtn[name].push(value);
        }
      });
      return rtn;
    } else {
      // no values
      return {};
    }
  },

  start: function() {
    if (proxy.isSupported) {
      LocationRewriter(this);
      HistoryRewriter(this);
    }
    try {
      return _start.apply(this, arguments);
    } finally {
      this.location.unPatch && this.location.unPatch();
      this.history.unPatch && this.history.unPatch();
    }
  },

  loadUrl: function () {
    this.location && this.location.unPatch && this.location.unPatch();
    this.history && this.history.unPatch && this.history.unPatch();
    return _loadUrl.apply(this, arguments);
  }
});

_.extend(Backbone.Router.prototype, {
  initialize: function(options) {
    this.encodedSplatParts = options && options.encodedSplatParts;
  },

  getFragment: _getFragment,

  _routeToRegExp: function(route) {
    var splatMatch = (splatParam.exec(route) || {index: -1}),
        namedMatch = (namedParam.exec(route) || {index: -1}),
        paramNames = route.match(namesPattern) || [];

    route = route.replace(escapeRegExp, '\\$&')
                 .replace(optionalParam, '(?:$1)?')
                 .replace(namedParam, function(match, optional){
                   return optional ? match : '([^\\/\\?]+)';
                 })
                 // `[^??]` is hacking around a regular expression bug under iOS4.
                 // If only `[^?]` is used then paths like signin/photos will fail
                 // while paths with `?` anywhere, like `signin/photos?`, will succeed.
                 .replace(splatParam, '([^??]*?)');
    route += '(\\?.*)?';
    var rtn = new RegExp('^' + route + '$');

    // use the rtn value to hold some parameter data
    if (splatMatch.index >= 0) {
      // there is a splat
      if (namedMatch >= 0) {
        // negative value will indicate there is a splat match before any named matches
        rtn.splatMatch = splatMatch.index - namedMatch.index;
      } else {
        rtn.splatMatch = -1;
      }
    }
    rtn.paramNames = _.map(paramNames, function(name) { return name.substring(1); });
    rtn.namedParameters = this.namedParameters;

    return rtn;
  },

  /**
   * Given a route, and a URL fragment that it matches, return the array of
   * extracted parameters.
   */
  _extractParameters: function(route, fragment) {
    var params = route.exec(fragment).slice(1),
        namedParams = {};
    if (params.length > 0 && _.isUndefined(params[params.length - 1])) {
    	// remove potential invalid data from query params match
    	params.splice(params.length - 1, 1);
    }

    // do we have an additional query string?
    var match = params.length && params[params.length-1] && params[params.length-1].match(queryStringParam);
    if (match) {
      var queryString = match[1];
      var data = {};
      if (queryString) {
        var self = this;
        iterateQueryString(queryString, function(name, value) {
          self._setParamValue(name, value, data);
        });
      }
      params[params.length-1] = data;
      _.extend(namedParams, data);
    }

    // decode params
    var length = params.length;
    if (route.splatMatch && this.encodedSplatParts) {
      if (route.splatMatch < 0) {
        // splat param is first
        return params;
      } else {
        length = length - 1;
      }
    }

    for (var i=0; i<length; i++) {
      if (_.isString(params[i])) {
        params[i] = decodeURIComponent(params[i]);
        if (route.paramNames && route.paramNames.length >= i-1) {
          namedParams[route.paramNames[i]] = params[i];
        }
      }
    }

    return (Backbone.Router.namedParameters || route.namedParameters) ? [namedParams] : params;
  },

  /**
   * Set the parameter value on the data hash
   */
  _setParamValue: function(key, value, data) {
    // use '.' to define hash separators
    key = key.replace('[]', '');
    var parts = key.split('.');
    var _data = data;
    for (var i=0; i<parts.length; i++) {
      var part = parts[i];
      if (i === parts.length-1) {
        // set the value
        _data[part] = this._decodeParamValue(value, _data[part]);
      } else {
        _data = _data[part] = _data[part] || {};
      }
    }
  },

  /**
   * Decode an individual parameter value (or list of values)
   * @param value the complete value
   * @param currentValue the currently known value (or list of values)
   */
  _decodeParamValue: function(value, currentValue) {
    // decodeURIComponent doesn't translate '+'
    value = value.replace(/\+/g, '%20');

    // '|' will indicate an array.  Array with 1 value is a=|b - multiple values can be a=b|c
    var splitChar = Backbone.Router.arrayValueSplit;
    if (splitChar && value.indexOf(splitChar) >= 0) {
      var values = value.split(splitChar);
      // clean it up
      for (var i=values.length-1; i>=0; i--) {
        if (!values[i]) {
          values.splice(i, 1);
        } else {
          values[i] = decodeURIComponent(values[i]);
        }
      }
      return values;
    }
    value = decodeURIComponent(value);
    if (!currentValue) {
      return value;
    } else if (_.isArray(currentValue)) {
      currentValue.push(value);
      return currentValue;
    } else {
      return [currentValue, value];
    }
  },

  /**
   * Return the route fragment with queryParameters serialized to query parameter string
   */
  toFragment: function(route, queryParameters) {
    if (queryParameters) {
      if (!_.isString(queryParameters)) {
        queryParameters = this._toQueryString(queryParameters);
      }
      if(queryParameters) {
        route += '?' + queryParameters;
      }
    }
    return route;
  },

  /**
   * Serialize the val hash to query parameters and return it.  Use the namePrefix to prefix all param names (for recursion)
   */
  _toQueryString: function(val, namePrefix) {
    var splitChar = Backbone.Router.arrayValueSplit;
    function encodeSplit(val) { return String(val).replace(splitChar, encodeURIComponent(splitChar)); }

    if (!val) return '';
    namePrefix = namePrefix || '';
    var rtn = '';
    for (var name in val) {
      var _val = val[name];
      if (_.isString(_val) || _.isNumber(_val) || _.isBoolean(_val) || _.isDate(_val)) {
        // primitive type
        _val = this._toQueryParam(_val);
        if (_.isBoolean(_val) || _.isNumber(_val) || _.isString(_val) || _val) {
          rtn += (rtn ? '&' : '') + this._toQueryParamName(name, namePrefix) + '=' + encodeSplit(encodeURIComponent(_val));
        }
      } else if (_.isArray(_val)) {
        // arrays use Backbone.Router.arrayValueSplit separator
        var str = '';
        for (var i = 0; i < _val.length; i++) {
          var param = this._toQueryParam(_val[i]);
          if (_.isBoolean(param) || param !== null) {
            str += splitChar + encodeSplit(param);
          }
        }
        if (str) {
          rtn += (rtn ? '&' : '') + this._toQueryParamName(name, namePrefix) + '=' + str;
        }
      } else {
        // dig into hash
        var result = this._toQueryString(_val, this._toQueryParamName(name, namePrefix, true));
        if (result) {
          rtn += (rtn ? '&' : '') + result;
        }
      }
    }
    return rtn;
  },

  /**
   * return the actual parameter name
   * @param name the parameter name
   * @param namePrefix the prefix to the name
   * @param createPrefix true if we're creating a name prefix, false if we're creating the name
   */
  _toQueryParamName: function(name, prefix, isPrefix) {
    return (prefix + name + (isPrefix ? '.' : ''));
  },

  /**
   * Return the string representation of the param used for the query string
   */
  _toQueryParam: function (param) {
    if (_.isNull(param) || _.isUndefined(param)) {
      return null;
    }
    return param;
  }
});

function iterateQueryString(queryString, callback) {
  var keyValues = queryString.split('&');
  _.each(keyValues, function(keyValue) {
    var arr = keyValue.split('=');
    callback(arr.shift(), arr.join('='));
  });
}

}));
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/components/TabLoader/entities/TabModel.js' */
AJS.namespace("JIRA.Projects");

JIRA.Projects.TabModel = Backbone.Model.extend({

    parse: function (data) {
        return {
            html: data || ""
        };
    },

    url: function () {
        return this._url + "&decorator=none&contentOnly=true";
    },

    newTabRequested: function (tabUrl) {
        var model = this,
            oldUrl = this._url;
        this._url = tabUrl;
        this.fetch({
            dataType: "text",
            statusCode: {
                // Need to do this instead of passing in a 'success' handler
                // because we don't get access to the request object otherwise
                200: function(body, statusText, request) {
                    if (request.getResponseHeader('X-Atlassian-Dialog-Control') === 'permissionviolation') {
                        // We've been logged out
                        model.trigger("switch-error", { loggedOut: true }, tabUrl);
                    } else {
                        model.trigger("switch", tabUrl);
                    }
                }
            },
            error: function (model, response) {
                model._url = oldUrl;
                model.trigger("switch-error", response, tabUrl);
            }
        });
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/components/TabLoader/views/TabView.js' */
AJS.namespace("JIRA.Projects");

JIRA.Projects.TabView = Backbone.View.extend({
    initialize: function () {
        var model = this.model;
        this.$stage = this.$el.find("#project-tab");
        this.$sidebarLinks = this.$el.find(".aui-page-panel-nav a");

        this.listenTo(model, 'switch', this.render);

        this.$sidebarLinks.click(function (e) {
            model.newTabRequested(AJS.$(this).attr('href'));
            e.preventDefault();
        });
    },

    render: function () {
        this.$stage.html(this.model.get("html"));
        this.updateTabSelection();
        JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [this.$stage, JIRA.CONTENT_ADDED_REASON.tabUpdated]);
    },

    updateTabSelection: function () {
        var tabFrom = JIRA.Projects.Util.extractSelectedTab;
        var newTab = tabFrom(this.model._url);

        this.$sidebarLinks.parent().removeClass("active");
        var $linkForNewTab = this.$sidebarLinks.filter(function () {
            return tabFrom(AJS.$(this).attr('href')) === newTab;
        });

        $linkForNewTab.parent().addClass("active");
    }
});

;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/components/TabLoader/services/TabPanelRouter.js' */
AJS.namespace("JIRA.Projects");

JIRA.Projects.TabPanelRouter = Backbone.Router.extend({

    /**
     *
     * @param {JIRA.Projects.TabModel} tabModel
     * @param location the window.location object
     */
    initialize: function(tabModel, location) {
        this.route(/[&?]selectedTab=(.*)(&|$)/, 'loadTab');
        this.tabModel = tabModel;
        this.location = location;
    },

    /**
     *
     * @param tabKey the key of the tab to be loaded
     */
    loadTab: function (tabKey) {
        var OLD_PLUGIN_KEY = "com.atlassian.jira.plugin.system.project",
            NEW_PLUGIN_KEY = "com.atlassian.jira.jira-projects-plugin";

        //redirect to load the correct tab panel in case users have bookmarked the old browse project pages.
        tabKey = tabKey.replace(OLD_PLUGIN_KEY, NEW_PLUGIN_KEY);
        this.tabModel.newTabRequested(this.location.pathname + JIRA.Projects.Util.setSelectedTab(this.location.search, tabKey));
    }

});;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/components/TabLoader/main.js' */
AJS.namespace("JIRA.Projects");

JIRA.Projects.TabLoader = {

    init: function ($el, history, location, pushState) {

        var tab = new JIRA.Projects.TabModel();

        tab.on("switch", function (url) {
            var newTabKey = JIRA.Projects.Util.extractSelectedTab(url);
            var newTabQueryString = JIRA.Projects.Util.setSelectedTab(location.href, newTabKey);
            history.navigate(newTabQueryString, false);
        });

        tab.on("switch-error", function (response, target) {
            var msg = JIRA.Messages.showErrorMsg;

            if (response.loggedOut) {
                var login = AJS.contextPath() + "/login.jsp?permissionViolation=true&os_destination=" + target;
                return location.replace(login);
            } else if (response.statusText === "timeout") {
                msg(JIRA.Projects.ErrorMessages.timeout());
            } else if (response.status === 404) {
                msg(JIRA.Projects.ErrorMessages.notFound());
            } else {
                msg(JIRA.Projects.ErrorMessages.genericError());
            }
        });

        new JIRA.Projects.TabView({
            model: tab,
            el: $el
        });

        new JIRA.Projects.TabPanelRouter(tab, location);
        var hasFragment = location.href.indexOf("#") > -1;

        history.start({
            pushState: pushState,
            hashChange: !pushState,
            silent: !hasFragment,
            root: location.pathname
        });

        // Put the tab selection into the url if it isn't there already, so we can get back to it with the 'Back' button
        // We need to update the url if there is no selected tab in the url, or we don't have push state and there's no fragment
        if (!JIRA.Projects.Util.extractSelectedTab(location.href) || !(hasFragment || pushState)) {
            var tabHref = $el.find(".aui-page-panel-nav li.active > a.browse-tab").attr("href");
            var newTab = JIRA.Projects.Util.extractSelectedTab(tabHref);
            var newTabQueryString = JIRA.Projects.Util.setSelectedTab(location.href, newTab);
            history.navigate(newTabQueryString, {trigger: false, replace: true});
        }
    }
};
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/util/selectedTab.js' */
AJS.namespace("JIRA.Projects.Util");

(function () {
    var queryStringFrom = function (url) {
        return url.split('?')[1] || '';
    };

    var accumulateQueryParameter = function(parsedQuery, keyAndValueString) {
        var keyAndValue = keyAndValueString.split('=');
        parsedQuery[keyAndValue[0]] = keyAndValue[1];
        return parsedQuery;
    };

    var queryStringToObject = function (url) {
        var queryStringKeyAndValues = _.compact(queryStringFrom(url).split('&'));
        return _(queryStringKeyAndValues).reduce(accumulateQueryParameter, {});
    };

    /**
     * Transforms the provided url to point to the new selected tab.
     *
     * @param {string} url
     * @return the id of the selected tab from the url's query string, or null if there is none in the query string
     */
    JIRA.Projects.Util.extractSelectedTab = function (url) {
        return queryStringToObject(url).selectedTab || null;
    };

    /**
     * @param {string} url
     * @param {JIRA.Projects.TabModel} selectedTabValue
     * @return string url pointing to the selected tab value specified, with other parameters left intact
     */
    JIRA.Projects.Util.setSelectedTab = function (url, selectedTabValue) {
        var query = queryStringToObject(url);
        query.selectedTab = selectedTabValue;
        return '?' + decodeURIComponent(AJS.$.param(query));
    };
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject', location = '/static/util/errorMessages.js' */
AJS.namespace("JIRA.Projects");

JIRA.Projects.ErrorMessages = {
    notFound: function () {
        return "The requested project tab could not be found for display.";
    },
    genericError: function () {
        return "The JIRA server was contacted but has returned an error response. We are unsure of the result of this operation.";
    },
    timeout : function () {
        return "The connection timed out while trying to load the requested tab.";
    }
};
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:browseproject-init', location = '/static/page/initTabLoader.js' */
AJS.$(function($) {
    if (!AJS.$(".aui-sidebar").length) {
        JIRA.Projects.TabLoader.init($(".aui-page-panel"), Backbone.history, window.location, window.history.pushState);
    }
});
;
;
/* module-key = 'com.atlassian.auiplugin:ajs-raf', location = 'js-vendor/raf/raf.js' */
/*
 * raf.js
 * https://github.com/ngryman/raf.js
 *
 * original requestAnimationFrame polyfill by Erik Möller
 * inspired from paul_irish gist and post
 *
 * Copyright (c) 2013 ngryman
 * Licensed under the MIT license.
 */

(function(window) {
	var lastTime = 0,
		vendors = ['webkit', 'moz'],
		requestAnimationFrame = window.requestAnimationFrame,
		cancelAnimationFrame = window.cancelAnimationFrame,
		i = vendors.length;

	// try to un-prefix existing raf
	while (--i >= 0 && !requestAnimationFrame) {
		requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
		cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'];
	}

	// polyfill with setTimeout fallback
	// heavily inspired from @darius gist mod: https://gist.github.com/paulirish/1579671#comment-837945
	if (!requestAnimationFrame || !cancelAnimationFrame) {
		requestAnimationFrame = function(callback) {
			var now = Date.now(), nextTime = Math.max(lastTime + 16, now);
			return setTimeout(function() {
				callback(lastTime = nextTime);
			}, nextTime - now);
		};

		cancelAnimationFrame = clearTimeout;
	}

	// export to window
	window.requestAnimationFrame = requestAnimationFrame;
	window.cancelAnimationFrame = cancelAnimationFrame;
}(window));;
;
/* module-key = 'com.atlassian.auiplugin:modernizr-touch', location = 'js-vendor/modernizr/modernizr-touch.js' */
/* Modernizr 2.8.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-touch-mq-teststyles-prefixes
 */
;



window.Modernizr = (function( window, document, undefined ) {

    var version = '2.8.3',

    Modernizr = {},


    docElement = document.documentElement,

    mod = 'modernizr',
    modElem = document.createElement(mod),
    mStyle = modElem.style,

    inputElem  ,


    toString = {}.toString,

    prefixes = ' -webkit- -moz- -o- -ms- '.split(' '),



    tests = {},
    inputs = {},
    attrs = {},

    classes = [],

    slice = classes.slice,

    featureName, 


    injectElementWithStyles = function( rule, callback, nodes, testnames ) {

      var style, ret, node, docOverflow,
          div = document.createElement('div'),
                body = document.body,
                fakeBody = body || document.createElement('body');

      if ( parseInt(nodes, 10) ) {
                      while ( nodes-- ) {
              node = document.createElement('div');
              node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
              div.appendChild(node);
          }
      }

                style = ['&#173;','<style id="s', mod, '">', rule, '</style>'].join('');
      div.id = mod;
          (body ? div : fakeBody).innerHTML += style;
      fakeBody.appendChild(div);
      if ( !body ) {
                fakeBody.style.background = '';
                fakeBody.style.overflow = 'hidden';
          docOverflow = docElement.style.overflow;
          docElement.style.overflow = 'hidden';
          docElement.appendChild(fakeBody);
      }

      ret = callback(div, rule);
        if ( !body ) {
          fakeBody.parentNode.removeChild(fakeBody);
          docElement.style.overflow = docOverflow;
      } else {
          div.parentNode.removeChild(div);
      }

      return !!ret;

    },

    testMediaQuery = function( mq ) {

      var matchMedia = window.matchMedia || window.msMatchMedia;
      if ( matchMedia ) {
        return matchMedia(mq) && matchMedia(mq).matches || false;
      }

      var bool;

      injectElementWithStyles('@media ' + mq + ' { #' + mod + ' { position: absolute; } }', function( node ) {
        bool = (window.getComputedStyle ?
                  getComputedStyle(node, null) :
                  node.currentStyle)['position'] == 'absolute';
      });

      return bool;

     },
    _hasOwnProperty = ({}).hasOwnProperty, hasOwnProp;

    if ( !is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined') ) {
      hasOwnProp = function (object, property) {
        return _hasOwnProperty.call(object, property);
      };
    }
    else {
      hasOwnProp = function (object, property) { 
        return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
      };
    }


    if (!Function.prototype.bind) {
      Function.prototype.bind = function bind(that) {

        var target = this;

        if (typeof target != "function") {
            throw new TypeError();
        }

        var args = slice.call(arguments, 1),
            bound = function () {

            if (this instanceof bound) {

              var F = function(){};
              F.prototype = target.prototype;
              var self = new F();

              var result = target.apply(
                  self,
                  args.concat(slice.call(arguments))
              );
              if (Object(result) === result) {
                  return result;
              }
              return self;

            } else {

              return target.apply(
                  that,
                  args.concat(slice.call(arguments))
              );

            }

        };

        return bound;
      };
    }

    function setCss( str ) {
        mStyle.cssText = str;
    }

    function setCssAll( str1, str2 ) {
        return setCss(prefixes.join(str1 + ';') + ( str2 || '' ));
    }

    function is( obj, type ) {
        return typeof obj === type;
    }

    function contains( str, substr ) {
        return !!~('' + str).indexOf(substr);
    }


    function testDOMProps( props, obj, elem ) {
        for ( var i in props ) {
            var item = obj[props[i]];
            if ( item !== undefined) {

                            if (elem === false) return props[i];

                            if (is(item, 'function')){
                                return item.bind(elem || obj);
                }

                            return item;
            }
        }
        return false;
    }
    tests['touch'] = function() {
        var bool;

        if(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
          bool = true;
        } else {
          injectElementWithStyles(['@media (',prefixes.join('touch-enabled),('),mod,')','{#modernizr{top:9px;position:absolute}}'].join(''), function( node ) {
            bool = node.offsetTop === 9;
          });
        }

        return bool;
    };
    for ( var feature in tests ) {
        if ( hasOwnProp(tests, feature) ) {
                                    featureName  = feature.toLowerCase();
            Modernizr[featureName] = tests[feature]();

            classes.push((Modernizr[featureName] ? '' : 'no-') + featureName);
        }
    }



     Modernizr.addTest = function ( feature, test ) {
       if ( typeof feature == 'object' ) {
         for ( var key in feature ) {
           if ( hasOwnProp( feature, key ) ) {
             Modernizr.addTest( key, feature[ key ] );
           }
         }
       } else {

         feature = feature.toLowerCase();

         if ( Modernizr[feature] !== undefined ) {
                                              return Modernizr;
         }

         test = typeof test == 'function' ? test() : test;

         if (typeof enableClasses !== "undefined" && enableClasses) {
           docElement.className += ' ' + (test ? '' : 'no-') + feature;
         }
         Modernizr[feature] = test;

       }

       return Modernizr; 
     };


    setCss('');
    modElem = inputElem = null;


    Modernizr._version      = version;

    Modernizr._prefixes     = prefixes;

    Modernizr.mq            = testMediaQuery;
    Modernizr.testStyles    = injectElementWithStyles;
    return Modernizr;

})(this, this.document);
;;
;
/* module-key = 'com.atlassian.auiplugin:internal-aui-is-input', location = 'js/aui/internal/is-input.js' */
;(function (init) {
    'use strict';

    AJS._internal = AJS._internal || {};
    AJS._internal.isInput = init();
})(function () {
    'use strict';

    return function (el) {
        return 'value' in el || el.isContentEditable;
    };
});
;
;
/* module-key = 'com.atlassian.auiplugin:aui-sidebar', location = 'js/aui-sidebar.js' */
(function ($) {

    'use strict';

    var SUPPORTS_TRANSITIONS = (typeof document.documentElement.style['transition'] !== 'undefined') ||
            (typeof document.documentElement.style['webkitTransition'] !== 'undefined');

    function sidebarOffset (sidebar) {
        return sidebar.offset().top;
    }

    function Sidebar (selector) {
        this.$el = $(selector);
        if (!this.$el.length) {
            return;
        }
        this.$body = $('body');
        this.$wrapper = this.$el.children('.aui-sidebar-wrapper');
        this.submenus = new SubmenuManager();

        // Sidebar users should add class="aui-page-sidebar" to the
        // <body> in the rendered markup (to prevent any potential flicker),
        // so we add it just in case they forgot.
        this.$body.addClass('aui-page-sidebar');

        this._previousScrollTop = null;
        this._previousViewportHeight = null;
        this._previousViewportWidth = null;
        this._previousOffsetTop = null;

        initializeHandlers(this);
    }

    var FORCE_COLLAPSE_WIDTH = 1240;
    var EVENT_PREFIX = '_aui-internal-sidebar-';

    function namespaceEvents (events) {
        return $.map(events.split(' '), function (event) {
            return EVENT_PREFIX + event;
        }).join(' ');
    }

    Sidebar.prototype.on = function () {
        var events = arguments[0];
        var args = Array.prototype.slice.call(arguments, 1);
        var namespacedEvents = namespaceEvents(events);
        this.$el.on.apply(this.$el, [namespacedEvents].concat(args));
        return this;
    };

    Sidebar.prototype.off = function () {
        var events = arguments[0];
        var args = Array.prototype.slice.call(arguments, 1);
        var namespacedEvents = namespaceEvents(events);
        this.$el.off.apply(this.$el, [namespacedEvents].concat(args));
        return this;
    };

    Sidebar.prototype.setHeight = function (scrollTop, viewportHeight, headerHeight) {
        var visibleHeaderHeight = Math.max(0, headerHeight - scrollTop);
        this.$wrapper.height(viewportHeight - visibleHeaderHeight);
        return this;
    };

    Sidebar.prototype.setPosition = function (scrollTop) {
        scrollTop = scrollTop || window.pageYOffset;
        this.$wrapper.toggleClass('aui-is-docked', scrollTop > sidebarOffset(this.$el));
        return this;
    };

    Sidebar.prototype.setCollapsedState = function (viewportWidth) {
        // Reflow behaviour is implemented as a state machine (hence all
        // state transitions are enumerated). The rest of the state machine,
        // e.g., entering the expanded narrow (fly-out) state, is implemented
        // by the toggle() method.
        var transition = {collapsed: {}, expanded: {}};
        transition.collapsed.narrow = {
            narrow: $.noop,
            wide: function (s) {
                s._expand(viewportWidth, true);
            }
        };
        transition.collapsed.wide = {
            narrow: $.noop,  // Becomes collapsed narrow (no visual change).
            wide: $.noop
        };
        transition.expanded.narrow = {
            narrow: $.noop,
            wide: function (s) {
                s.$body.removeClass('aui-sidebar-collapsed');
                s.$el.removeClass('aui-sidebar-fly-out');
            }
        };
        transition.expanded.wide = {
            narrow: function (s) {
                s._collapse(true);
            },
            wide: $.noop
        };

        var collapseState = this.isCollapsed() ? 'collapsed' : 'expanded';
        var oldSize = this.isViewportNarrow(this._previousViewportWidth) ? 'narrow' : 'wide';
        var newSize = this.isViewportNarrow(viewportWidth) ? 'narrow' : 'wide';
        transition[collapseState][oldSize][newSize](this);
        return this;
    };

    Sidebar.prototype._collapse = function (isResponsive) {
        if (this.isCollapsed()) {
            return this;
        }

        var startEvent = $.Event(EVENT_PREFIX + 'collapse-start', {isResponsive: isResponsive});
        this.$el.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) {
            return this;
        }

        this.$body.addClass('aui-sidebar-collapsed');
        this.$el.attr('aria-expanded', 'false');
        this.$el.removeClass('aui-sidebar-fly-out');
        this.$el.find(this.submenuTriggersSelector).attr('tabindex', 0);

        if (!this.isAnimated()) {
            this.$el.trigger($.Event(EVENT_PREFIX + 'collapse-end', {isResponsive: isResponsive}));
        }
        return this;
    };

    Sidebar.prototype.collapse = function () {
        return this._collapse(false);
    };

    Sidebar.prototype._expand = function (viewportWidth, isResponsive) {
        var startEvent = $.Event(EVENT_PREFIX + 'expand-start', {isResponsive: isResponsive});
        this.$el.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) {
            return this;
        }

        var isViewportNarrow = this.isViewportNarrow(viewportWidth);
        this.$el.attr('aria-expanded', 'true');
        this.$body.toggleClass('aui-sidebar-collapsed', isViewportNarrow);
        this.$el.toggleClass('aui-sidebar-fly-out', isViewportNarrow);
        this.$el.find(this.submenuTriggersSelector).removeAttr('tabindex');

        if (!this.isAnimated()) {
            this.$el.trigger($.Event(EVENT_PREFIX + 'expand-end', {isResponsive: isResponsive}));
        }
        return this;
    };

    Sidebar.prototype.expand = function () {
        if (this.isCollapsed()) {
            this._expand(this._previousViewportWidth, false);
        }
        return this;
    };

    Sidebar.prototype.isAnimated = function () {
        return SUPPORTS_TRANSITIONS && this.$el.hasClass('aui-is-animated');
    };

    Sidebar.prototype.isCollapsed = function () {
        return this.$el.attr('aria-expanded') === 'false';
    };

    Sidebar.prototype.isViewportNarrow = function (viewportWidth) {
        viewportWidth = viewportWidth === undefined ? this._previousViewportWidth : viewportWidth;
        return viewportWidth < FORCE_COLLAPSE_WIDTH;
    };

    Sidebar.prototype._removeAllTooltips = function () {
        // tooltips are orphaned when sidebar is expanded, so if there are any visible on the page we remove them all.
        // Can't scope it to the Sidebar (this) because the tooltip div is a direct child of <body>
        $(this.tooltipSelector).remove();
    };

    Sidebar.prototype.reflow = function (scrollTop, viewportHeight, viewportWidth, scrollHeight) {
        scrollTop = scrollTop === undefined ? window.pageYOffset : scrollTop;
        viewportHeight = viewportHeight === undefined ? document.documentElement.clientHeight : viewportHeight;
        scrollHeight = scrollHeight === undefined ? document.documentElement.scrollHeight: scrollHeight;
        viewportWidth = viewportWidth === undefined ? window.innerWidth :viewportWidth;

        // Header height needs to be checked because in Stash it changes when the CSS "transform: translate3d" is changed.
        // If you called reflow() after this change then nothing happened because the scrollTop and viewportHeight hadn't changed.
        var offsetTop = sidebarOffset(this.$el);
        var isInitialPageLoad = this._previousViewportWidth === null;

        if (!(scrollTop === this._previousScrollTop && viewportHeight === this._previousViewportHeight && offsetTop === this._previousOffsetTop)) {
            if (this.isCollapsed() && !isInitialPageLoad && scrollTop !== this._previousScrollTop) {
                // hide submenu and tooltips on scroll
                this.submenus.hide();
                this._removeAllTooltips();
            }

            var isTouch = this.$body.hasClass('aui-page-sidebar-touch');
            var isTrackpadBounce = scrollTop !== this._previousScrollTop && (scrollTop < 0 || scrollTop + viewportHeight > scrollHeight);
            if (!isTouch && (isInitialPageLoad || !isTrackpadBounce)) {
                this.setHeight(scrollTop, viewportHeight, offsetTop);
                this.setPosition(scrollTop);
            }
        }

        var isResponsive = this.$el.attr('data-aui-responsive') !== 'false';
        if (isResponsive) {
            if (isInitialPageLoad) {
                if (!this.isCollapsed() && this.isViewportNarrow(viewportWidth)) {
                    var isAnimated = this.isAnimated();
                    if (isAnimated) {
                        this.$el.removeClass('aui-is-animated');
                    }
                    // This will trigger the "collapse" event before non-sidebar
                    // JS code has a chance to bind listeners; they'll need to
                    // check isCollapsed() if they care about the value at that
                    // time.
                    this.collapse();
                    if (isAnimated) {
                        // We must trigger a CSS reflow (by accessing
                        // offsetHeight) otherwise the transition still runs.
                        // jshint expr:true
                        this.$el[0].offsetHeight;
                        this.$el.addClass('aui-is-animated');
                    }
                }
            }
            else if (viewportWidth !== this._previousViewportWidth) {
                this.setCollapsedState(viewportWidth);
            }
        }
        else {
            var isFlyOut = !this.isCollapsed() && this.isViewportNarrow(viewportWidth);
            this.$el.toggleClass('aui-sidebar-fly-out', isFlyOut);
        }

        this._previousScrollTop = scrollTop;
        this._previousViewportHeight = viewportHeight;
        this._previousViewportWidth = viewportWidth;
        this._previousOffsetTop = offsetTop;
        return this;
    };

    Sidebar.prototype.toggle = function () {
        if (this.isCollapsed()) {
            if (this.submenus.isShowing()) {
                this.submenus.hide(this.expand.bind(this));
            }
            else {
                this.expand();
                this._removeAllTooltips();
            }
        }
        else {
            this.collapse();
        }
        return this;
    };

    /**
     * Returns a jQuery selector string for the trigger elements when the
     * sidebar is in a collapsed state, useful for delegated event binding.
     *
     * When using this selector in event handlers, the element ("this") will
     * either be an <a> (when the trigger was a tier-one menu item) or an
     * element with class "aui-sidebar-group" (for non-tier-one items).
     *
     * For delegated event binding you should bind to $el and check the value
     * of isCollapsed(), e.g.,
     *
     *     sidebar.$el.on('click', sidebar.collapsedTriggersSelector, function (e) {
     *         if (!sidebar.isCollapsed()) {
     *             return;
     *         }
     *     });
     *
     * @returns string
     */
    Sidebar.prototype.submenuTriggersSelector = '.aui-sidebar-group:not(.aui-sidebar-group-tier-one)';

    Sidebar.prototype.collapsedTriggersSelector = [
        Sidebar.prototype.submenuTriggersSelector,
        '.aui-sidebar-group.aui-sidebar-group-tier-one > .aui-nav > li > a',
        '.aui-sidebar-footer > .aui-sidebar-settings-button'
    ].join(', ');

    Sidebar.prototype.toggleSelector = '.aui-sidebar-footer > .aui-sidebar-toggle';

    Sidebar.prototype.tooltipSelector = '.aui-sidebar-section-tooltip';

    function SubmenuManager() {
        this.inlineDialog = AJS.InlineDialog($(), 'sidebar-submenu', this.inlineDialogShowHandler.bind(this), {
            noBind: true,
            addActiveClass: false,
            hideCallback: this.inlineDialogHideHandler.bind(this),
            gravity: 'w',
            hideDelay: 300,
            offsetY: function (popup, targetPosition) {
                var halfTriggerHeight = targetPosition.target.height() / 2;
                var halfPopupHeight = popup.height() / 2;
                return halfPopupHeight - halfTriggerHeight - this.submenuHeadingHeight();
            }.bind(this),
            arrowOffsetY: function (popup, targetPosition) {
                var halfTriggerHeight = targetPosition.target.height() / 2;
                var halfPopupHeight = popup.height() / 2;
                return -halfPopupHeight + this.submenuHeadingHeight() + halfTriggerHeight;
            }.bind(this)
        });

        this.$trigger = null;
        this.$placeholder = null;
        this.$placeholderSubmenu = null;
        this.postHideCallback = null;
    }

    SubmenuManager.prototype.inlineDialogSelector = '#inline-dialog-sidebar-submenu';

    SubmenuManager.prototype.submenu = function ($trigger) {
        return $trigger.is('a') ? $trigger.next('.aui-nav') : $trigger.children('.aui-nav, hr');
    };

    SubmenuManager.prototype.hasSubmenu = function ($trigger) {
        return this.submenu($trigger).length !== 0;
    };

    SubmenuManager.prototype.submenuHeadingHeight = function () {
        // At the time we want to measure the submenu heading (inside the
        // offsetY and arrowOffsetY functions), the submenu heading is not
        // visible in the page (since the sidebar is collapsed), so we don't
        // have a reliable way of measuring its height.
        return 34;
    };

    SubmenuManager.prototype.isShowing = function () {
        return this.$trigger !== null;
    };

    SubmenuManager.prototype.show = function (e, triggerEl) {
        var wasShowing = this.isShowing();
        this.inlineDialog.show(e, triggerEl);
        if (wasShowing) {
            // Redraw the inline dialog in its new position.
            this.inlineDialog.refresh();
        }
        return this;
    };

    SubmenuManager.prototype.hide = function (callback) {
        if (callback !== undefined) {
            this.postHideCallback = callback;
        }
        this.inlineDialog.hide();
        return this;
    };

    // We use a string (INLINE_DIALOG_HTML) rather than soy since AUI
    // components don't depend on AUI templates (for now).
    var INLINE_DIALOG_HTML =
        '<div class="aui-sidebar-submenu">' +
            '<div class="aui-navgroup aui-navgroup-vertical">' +
                '<div class="aui-navgroup-inner">' +
                    '<div class="aui-nav-heading"><strong></strong></div>' +
                '</div>' +
            '</div>' +
        '</div>';

    SubmenuManager.prototype.inlineDialogShowHandler = function ($content, triggerEl, showPopup) {
        if (this.isShowing()) {
            // If the inline dialog is showing we can't simply call
            // this.inlineDialog.hide() since its implementation queues the
            // hiding, i.e., uses setTimeout(0); we update the contents
            // instead.
            this.restoreSubmenu();
            this.$trigger.removeClass('active');
        }

        this.$trigger = $(triggerEl).is('.aui-sidebar-group') ? $(triggerEl) : $(triggerEl).closest('a');
        this.$trigger.addClass('active');

        // TODO The title here should use the same code as what we display
        //      in the tipsy tooltips for the triggers.
        var title = this.$trigger.is('a') ? this.$trigger.text() : this.$trigger.children('.aui-nav-heading').text();
        $content.html(INLINE_DIALOG_HTML);

        var $container = $content.find('.aui-navgroup-inner');
        $container.children('.aui-nav-heading')
            .attr('title', title)
            .children('strong')
                .text(title);

        this.moveSubmenuToInlineDialog(this.submenu(this.$trigger));
        showPopup();
    };

    SubmenuManager.prototype.inlineDialogHideHandler = function () {
        this.restoreSubmenu();
        this.$trigger.removeClass('active');
        this.$trigger = null;

        if (this.postHideCallback !== null) {
            this.postHideCallback();
            this.postHideCallback = null;
        }
    };

    SubmenuManager.prototype.moveSubmenuToInlineDialog = function ($submenu) {
        this.$placeholder = $('<!-- placholder -->');
        // copy submenu along with its events
        this.$placeholderSubmenu = $submenu.clone(true);
        $submenu.replaceWith(this.$placeholder);
        this.inlineDialog.find('.aui-navgroup-inner').append(this.$placeholderSubmenu);
        return this;
    };

    SubmenuManager.prototype.restoreSubmenu = function () {
        this.$placeholder.replaceWith(this.$placeholderSubmenu);
        this.$placeholder = null;
        this.$placeholderSubmenu = null;
        return this;
    };

    var tipsyOpts = {
        trigger: 'manual',
        gravity: 'w',
        className: 'aui-sidebar-section-tooltip',
        title: function () {
            var $item = $(this);
            if ($item.is('a')) {
                return $item.attr('title') || $item.find('.aui-nav-item-label').text() || $item.data('tooltip');
            }
            else {
                return $item.children('.aui-nav').attr('title') || $item.children('.aui-nav-heading').text();
            }
        }
    };

    function showTipsy($trigger) {
        $trigger.tipsy(tipsyOpts).tipsy('show');
        var $tip = $trigger.data('tipsy') && $trigger.data('tipsy').$tip;
        if ($tip) { // if .aui-sidebar-group does not have a title to display
            // Remove "opacity" inline style from Tipsy to allow the our own styles and transitions to be applied
            $tip.css({'opacity': ''}).addClass('tooltip-shown');
        }
    }

    function hideTipsy($trigger) {
        var $tip = $trigger.data('tipsy') && $trigger.data('tipsy').$tip;
        if ($tip) {
            var durationStr = $tip.css('transition-duration');

            if (durationStr) {
                // can be denominated in either s or ms
                var timeoutMs = (durationStr.indexOf('ms') >= 0) ?
                    parseInt(durationStr.substring(0, durationStr.length - 2), 10) :
                    1000 * parseInt(durationStr.substring(0, durationStr.length - 1), 10);

                // use a timeout because the transitionend event is not reliable (yet),
                // more details here: https://bitbucket.atlassian.net/browse/BB-11599
                // an example of this at http://labs.silverorange.com/files/webkit-bug/
                // further caveats here: https://developer.mozilla.org/en-US/docs/Web/Events/transitionend
                // "In the case where a transition is removed before completion,
                // such as if the transition-property is removed, then the event will not fire."
                setTimeout(function () {
                    $trigger.tipsy('hide');
                }, timeoutMs);
            }

            $tip.removeClass('tooltip-shown');
        }
    }

    function initializeHandlers(sidebar) {
        var $sidebar = $('.aui-sidebar');
        if (!$sidebar.length) {
            return;
        }

        // AUI-2542: only enter touch mode on small screen touchable devices
        if (Modernizr.touch && Modernizr.mq('only screen and (max-device-width:1024px)')) {
            $('body').addClass('aui-page-sidebar-touch');
        }

        var pendingReflow = null;
        $(window).on('scroll resize', function () {
            if (pendingReflow === null) {
                pendingReflow = requestAnimationFrame(function () {
                    sidebar.reflow();
                    pendingReflow = null;
                });
            }
        });
        sidebar.reflow();

        if (sidebar.isAnimated()) {
            sidebar.$el.on('transitionend webkitTransitionEnd', function () {
                sidebar.$el.trigger($.Event(EVENT_PREFIX + (sidebar.isCollapsed() ? 'collapse-end' : 'expand-end')));
            });
        }

        sidebar.$el.on('click', '.aui-sidebar-toggle', function (e) {
            e.preventDefault();
            sidebar.toggle();
        });

        $('.aui-page-panel').click(function (e) {
            if (!sidebar.isCollapsed() && sidebar.isViewportNarrow()) {
                sidebar.collapse();
            }
        });

        var toggleShortcutHandler = function (e) {
            if (isNormalSquareBracket(e)) {
                sidebar.toggle();
            }
        };

        //We use keypress because it captures the actual character that was typed and not the physical key that was pressed.
        //This accounts for other keyboard layouts

        $(document).on('keypress', toggleShortcutHandler);

        sidebar._remove = function () {
            this._removeAllTooltips();
            $(this.submenus.inlineDialogSelector).remove();
            this.$el.remove();
            $(document).off('keypress', toggleShortcutHandler);
        };

        sidebar.$el.on('touchend', function (e) {
            if (sidebar.isCollapsed()) {
                sidebar.expand();
                e.preventDefault();
            }
        });

        sidebar.$el.on('mouseenter focus', sidebar.collapsedTriggersSelector, function (e) {
            if (!sidebar.isCollapsed()) {
                return;
            }

            var $trigger = $(this);

            if (sidebar.submenus.hasSubmenu($trigger)) {
                e.preventDefault();
                sidebar.submenus.show(e, this);
            }
            else if ($trigger.hasClass('active') && sidebar.submenus.isShowing()) {
                // prevent triggering the same submenu again and hiding it
                e.stopImmediatePropagation();
            }
            else {
                sidebar.submenus.hide();
                showTipsy($trigger);
            }
        });

        sidebar.$el.on('click blur mouseleave', sidebar.collapsedTriggersSelector, function (e) {
            if (!sidebar.isCollapsed()) {
                return;
            }
            hideTipsy($(this));
        });

        sidebar.$el.on('click', sidebar.collapsedTriggersSelector, function (e) {
            if (sidebar.submenus.isShowing()) {
                // prevent hiding of the submenu if someone clicks on it, since it's already shown on hover
                e.stopImmediatePropagation();
            }
        });

        sidebar.$el.on('mouseenter focus', sidebar.toggleSelector, function () {
            var $trigger = $(this);
            if (sidebar.isCollapsed()) {
                $trigger.data('tooltip', "Expand sidebar ( [ )");
            }
            else {
                $trigger.data('tooltip', "Collapse sidebar ( [ )");
            }
            showTipsy($trigger);
        });

        sidebar.$el.on('click blur mouseleave', sidebar.toggleSelector, function () {
            hideTipsy($(this));
        });

        // workaround for https://ecosystem.atlassian.net/browse/AUI-2555
        // we manually hide the submenus when the mouse leaves the trigger and into the sidebar body
        sidebar.$el.on('mouseover', function (e) {
            var $target = $(e.target);
            if ($target.hasClass('aui-sidebar-wrapper') || $target.hasClass('aui-sidebar-body')) {
                sidebar.submenus.hide();
            }
        });

        function isNormalTab(e) {
            return e.keyCode === AJS.keyCode.TAB && !e.shiftKey && !e.altKey;
        }

        function isNormalSquareBracket(e) {
            return e.which === AJS.keyCode.LEFT_SQUARE_BRACKET && !e.shiftKey && !e.ctrlKey && !e.metaKey && !AJS._internal.isInput(e.target);
        }

        function isShiftTab(e) {
            return e.keyCode === AJS.keyCode.TAB && e.shiftKey;
        }

        function isFirstSubmenuItem(item) {
            return item === sidebar.submenus.$placeholderSubmenu.find(':aui-tabbable')[0];
        }

        function isLastSubmenuItem(item) {
            return item === sidebar.submenus.$placeholderSubmenu.find(':aui-tabbable').last()[0];
        }

        function isFirstTabbableSidebarItem(item) {
            return item === sidebar.$el.find(':aui-tabbable:visible')[0];
        }

        sidebar.$el.on('keydown', sidebar.collapsedTriggersSelector, function (e) {
            if (isNormalTab(e) && sidebar.submenus.isShowing()) {
                e.preventDefault();
                // don't use :aui-tabbable:first as it will select the first tabbable item in EACH nav group
                sidebar.submenus.$placeholderSubmenu.find(':aui-tabbable').first().focus();

                sidebar.submenus.$placeholderSubmenu.on('keydown', function (e) {
                    if (isShiftTab(e) && isFirstSubmenuItem(e.target) || isNormalTab(e) && isLastSubmenuItem(e.target)) {
                        sidebar.submenus.$trigger.focus();
                        // unbind event and close submenu as the focus is out of the submenu
                        $(this).off('keydown');
                        sidebar.submenus.hide();
                    }
                });
            }
            else if (isShiftTab(e) && isFirstTabbableSidebarItem(e.target)) {
                // workaround to hide inline dialog of the first collapsed trigger
                sidebar.submenus.hide();
            }
        });

    }
    AJS.sidebar = AJS._internal.widget('sidebar', Sidebar);

    $(function () {
        AJS.sidebar('.aui-sidebar');
    });

}(AJS.$));
;
;
/* module-key = 'com.atlassian.auiplugin:dialog2', location = 'js/dialog2.js' */
;(function (init) {
    'use strict';

    AJS.dialog2 = init(AJS.$, AJS.layer, AJS._internal.widget);
})(function ($, layerWidget, widget) {
    'use strict';


    var defaults = {
        'aui-focus': 'false', // do not focus by default as it's overridden below
        'aui-blanketed': 'true'
    };

    function applyDefaults($el) {
        $.each(defaults, function (key, value) {
            var dataKey = 'data-' + key;
            if (!$el[0].hasAttribute(dataKey)) {
                $el.attr(dataKey, value);
            }
        });
    }

    function Dialog2(selector) {
        if (selector) {
            this.$el = $(selector);
        }
        else {
            this.$el = $(aui.dialog.dialog2({}));
        }
        applyDefaults(this.$el);
    }

    Dialog2.prototype.on = function (event, fn) {
        layerWidget(this.$el).on(event, fn);
        return this;
    };

    Dialog2.prototype.off = function (event, fn) {
        layerWidget(this.$el).off(event, fn);
        return this;
    };

    Dialog2.prototype.show = function () {
        layerWidget(this.$el).show();
        return this;
    };

    Dialog2.prototype.hide = function () {
        layerWidget(this.$el).hide();
        return this;
    };

    Dialog2.prototype.remove = function () {
        layerWidget(this.$el).remove();
        return this;
    };

    Dialog2.prototype.isVisible = function () {
        return layerWidget(this.$el).isVisible();
    };

    var dialog2Widget = widget('dialog2', Dialog2);

    dialog2Widget.on = function (eventName, fn) {
        layerWidget.on(eventName, '.aui-dialog2', fn);
        return this;
    };

    dialog2Widget.off = function (eventName, fn) {
        layerWidget.off(eventName, '.aui-dialog2', fn);
        return this;
    };

    /* Live events */

    $(document).on('click', '.aui-dialog2-header-close', function (e) {
        e.preventDefault();
        dialog2Widget($(this).closest('.aui-dialog2')).hide();
    });

    dialog2Widget.on('show', function (e, $el) {
        var selectors = ['.aui-dialog2-content', '.aui-dialog2-footer', '.aui-dialog2-header'];
        var $selected;
        selectors.some(function (selector) {
            $selected = $el.find(selector + ' :aui-tabbable');
            return $selected.length;
        });
        $selected && $selected.first().focus();
    });

    dialog2Widget.on('hide', function (e,$el) {
        var layer = layerWidget($el);

        if ($el.data('aui-remove-on-hide')) {
            layer.remove();
        }
    });

    return dialog2Widget;
});
;
;
/* module-key = 'com.atlassian.auiplugin:dialog2', location = 'soy/dialog2.soy' */
// This file was automatically generated from dialog2.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace aui.dialog.
 */

if (typeof aui == 'undefined') { var aui = {}; }
if (typeof aui.dialog == 'undefined') { aui.dialog = {}; }


aui.dialog.dialog2 = function(opt_data, opt_ignored) {
  return '' + aui.dialog.dialog2Chrome({id: opt_data.id, titleId: opt_data.id ? opt_data.id + '-dialog-title' : null, modal: opt_data.modal, tagName: opt_data.tagName, removeOnHide: opt_data.removeOnHide, visible: opt_data.visible, size: opt_data.size, extraClasses: opt_data.extraClasses, extraAttributes: opt_data.extraAttributes, content: '' + aui.dialog.dialog2Content({id: null, titleText: opt_data.titleText, titleContent: opt_data.titleContent, headerActionContent: opt_data.headerActionContent, headerSecondaryContent: opt_data.headerSecondaryContent, modal: opt_data.modal, content: opt_data.content, footerHintText: opt_data.footerHintText, footerHintContent: opt_data.footerHintContent, footerActionContent: opt_data.footerActionContent})});
};
if (goog.DEBUG) {
  aui.dialog.dialog2.soyTemplateName = 'aui.dialog.dialog2';
}


aui.dialog.dialog2Chrome = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<' + soy.$$escapeHtml(opt_data.tagName ? opt_data.tagName : 'section') + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ((opt_data.titleId) ? ' aria-labelledby="' + soy.$$escapeHtml(opt_data.titleId) + '"' : '') + ' role="dialog" class=" aui-layer aui-dialog2 aui-dialog2-' + soy.$$escapeHtml(opt_data.size ? opt_data.size : 'medium') + aui.renderExtraClasses(opt_data) + '"' + ((opt_data.modal) ? 'data-aui-modal="true"' : '') + ((opt_data.removeOnHide) ? 'data-aui-remove-on-hide="true"' : '') + ((opt_data.visible != true) ? 'aria-hidden="true"' : '') + aui.renderExtraAttributes(opt_data) + '>' + ((opt_data.content) ? soy.$$filterNoAutoescape(opt_data.content) : '') + '</' + soy.$$escapeHtml(opt_data.tagName ? opt_data.tagName : 'section') + '>';
};
if (goog.DEBUG) {
  aui.dialog.dialog2Chrome.soyTemplateName = 'aui.dialog.dialog2Chrome';
}


aui.dialog.dialog2Content = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + aui.dialog.dialog2Header({titleId: opt_data.id ? opt_data.id + '-dialog-title' : null, titleText: opt_data.titleText, titleContent: opt_data.titleContent, actionContent: opt_data.headerActionContent, secondaryContent: opt_data.headerSecondaryContent, modal: opt_data.modal}) + aui.dialog.dialog2Panel(opt_data) + aui.dialog.dialog2Footer({hintText: opt_data.footerHintText, hintContent: opt_data.footerHintContent, actionContent: opt_data.footerActionContent});
};
if (goog.DEBUG) {
  aui.dialog.dialog2Content.soyTemplateName = 'aui.dialog.dialog2Content';
}


aui.dialog.dialog2Header = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<header' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ' class="aui-dialog2-header' + aui.renderExtraClasses(opt_data) + '"' + aui.renderExtraAttributes(opt_data) + '><h2 ' + ((opt_data.titleId) ? ' id="' + soy.$$escapeHtml(opt_data.titleId) + '"' : '') + ' class="aui-dialog2-header-main">' + ((opt_data.titleText) ? soy.$$escapeHtml(opt_data.titleText) : '') + ((opt_data.titleContent) ? soy.$$filterNoAutoescape(opt_data.titleContent) : '') + '</h2>' + ((opt_data.actionContent) ? '<div class="aui-dialog2-header-actions">' + soy.$$filterNoAutoescape(opt_data.actionContent) + '</div>' : '') + ((opt_data.secondaryContent) ? '<div class="aui-dialog2-header-secondary">' + soy.$$filterNoAutoescape(opt_data.secondaryContent) + '</div>' : '') + ((opt_data.modal != true) ? '<a class="aui-dialog2-header-close"><span class="aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Close") + '</span></a>' : '') + '</header>';
};
if (goog.DEBUG) {
  aui.dialog.dialog2Header.soyTemplateName = 'aui.dialog.dialog2Header';
}


aui.dialog.dialog2Footer = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<footer' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ' class="aui-dialog2-footer' + aui.renderExtraClasses(opt_data) + '"' + aui.renderExtraAttributes(opt_data) + '>' + ((opt_data.actionContent) ? '<div class="aui-dialog2-footer-actions">' + soy.$$filterNoAutoescape(opt_data.actionContent) + '</div>' : '') + ((opt_data.hintText || opt_data.hintContent) ? '<div class="aui-dialog2-footer-hint">' + ((opt_data.hintText) ? soy.$$escapeHtml(opt_data.hintText) : '') + ((opt_data.hintContent) ? soy.$$filterNoAutoescape(opt_data.hintContent) : '') + '</div>' : '') + '</footer>';
};
if (goog.DEBUG) {
  aui.dialog.dialog2Footer.soyTemplateName = 'aui.dialog.dialog2Footer';
}


aui.dialog.dialog2Panel = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ' class="aui-dialog2-content' + aui.renderExtraClasses(opt_data) + '"' + aui.renderExtraAttributes(opt_data) + '>' + ((opt_data.content) ? soy.$$filterNoAutoescape(opt_data.content) : '') + '</div>';
};
if (goog.DEBUG) {
  aui.dialog.dialog2Panel.soyTemplateName = 'aui.dialog.dialog2Panel';
}
;
;
/* module-key = 'jira.webresources:change-project-type-dialog', location = '/includes/jira/dialog/changeProjectTypeDialog.soy' */
// This file was automatically generated from changeProjectTypeDialog.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.project.ChangeType.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.project == 'undefined') { JIRA.Templates.project = {}; }
if (typeof JIRA.Templates.project.ChangeType == 'undefined') { JIRA.Templates.project.ChangeType = {}; }


JIRA.Templates.project.ChangeType.changeProjectTypeDialog = function(opt_data, opt_ignored) {
  return '<section role="dialog" id="change-project-type-dialog-' + soy.$$escapeHtml(opt_data.projectId) + '" class="aui-layer aui-dialog2 aui-dialog2-medium" aria-hidden="true"><header class="aui-dialog2-header"><h2 class="aui-dialog2-header-main">' + soy.$$escapeHtml("Change project type") + '</h2></header><div class="aui-dialog2-content"></div><footer class="aui-dialog2-footer"><div class="aui-dialog2-footer-actions form-footer"><div class="icon throbber"></div><button class="aui-button aui-button-primary dialog-change-button hidden">' + soy.$$escapeHtml("Change") + '</button><button class="aui-button aui-button-link dialog-close-button">' + soy.$$escapeHtml("Cancel") + '</button></div></footer></section>';
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.changeProjectTypeDialog.soyTemplateName = 'JIRA.Templates.project.ChangeType.changeProjectTypeDialog';
}


JIRA.Templates.project.ChangeType.changeProjectTypeForm = function(opt_data, opt_ignored) {
  var output = '<form class="aui change-project-type-form"><div class="form-body"><div class="aui-group project-type-change-group"><div class="aui-item">' + JIRA.Templates.project.ChangeType.projectAvatar(opt_data) + '</div><div class="aui-item project-type-select-group">' + JIRA.Templates.project.ChangeType.projectTypeDropdown({projectTypeKey: opt_data.project.projectTypeKey, projectTypes: opt_data.projectTypes}) + '</div></div></div></form><p>';
  var helpLinkAnchor__soy21 = '<a href=' + soy.$$escapeHtml(opt_data.helpLink) + ' target="_blank">';
  output += soy.$$filterNoAutoescape(AJS.format("If you change project type, you\x27\x27ll also change what your users can see and do with the project. {0}Check the differences here{1}.",helpLinkAnchor__soy21,'</a>')) + '</p>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.changeProjectTypeForm.soyTemplateName = 'JIRA.Templates.project.ChangeType.changeProjectTypeForm';
}


JIRA.Templates.project.ChangeType.projectTypeDropdown = function(opt_data, opt_ignored) {
  var output = '<select class="project-type-select select" name="project-type">';
  var projectTypeList30 = opt_data.projectTypes;
  var projectTypeListLen30 = projectTypeList30.length;
  for (var projectTypeIndex30 = 0; projectTypeIndex30 < projectTypeListLen30; projectTypeIndex30++) {
    var projectTypeData30 = projectTypeList30[projectTypeIndex30];
    output += '<option class="imagebacked" data-icon="data:image/svg+xml;base64, ' + soy.$$escapeHtml(projectTypeData30.icon) + '" value="' + soy.$$escapeHtml(projectTypeData30.key) + '" ' + ((projectTypeData30.key == opt_data.projectTypeKey) ? ' selected ' : '') + '>' + soy.$$escapeHtml(projectTypeData30.formattedKey) + '</option>';
  }
  output += '</select>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.projectTypeDropdown.soyTemplateName = 'JIRA.Templates.project.ChangeType.projectTypeDropdown';
}


JIRA.Templates.project.ChangeType.updateTargetElement = function(opt_data, opt_ignored) {
  return '<img src="data:image/svg+xml;base64,' + soy.$$escapeHtml(opt_data.icon) + '" class="project-type-icon" /><span>' + soy.$$escapeHtml(opt_data.formattedKey) + '</span>';
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.updateTargetElement.soyTemplateName = 'JIRA.Templates.project.ChangeType.updateTargetElement';
}


JIRA.Templates.project.ChangeType.projectAvatar = function(opt_data, opt_ignored) {
  return '<div class="project-avatar-header"><span class="aui-avatar aui-avatar-large aui-avatar-project"><span class="aui-avatar-inner"><img src="' + soy.$$escapeHtml(opt_data.project.avatarUrls['48x48']) + '" alt="' + soy.$$escapeHtml(opt_data.project.name) + '"></span></span><div class="project-header" title="' + soy.$$escapeHtml(opt_data.project.name) + '">' + soy.$$escapeHtml(opt_data.project.name) + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.projectAvatar.soyTemplateName = 'JIRA.Templates.project.ChangeType.projectAvatar';
}


JIRA.Templates.project.ChangeType.dialogSpinner = function(opt_data, opt_ignored) {
  return '<div class="dialog-spinner"></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.dialogSpinner.soyTemplateName = 'JIRA.Templates.project.ChangeType.dialogSpinner';
}


JIRA.Templates.project.ChangeType.successMsg = function(opt_data, opt_ignored) {
  return '' + soy.$$escapeHtml(AJS.format("You have just changed {0} to a {1} project type.",opt_data.projectName,opt_data.projectTypeName));
};
if (goog.DEBUG) {
  JIRA.Templates.project.ChangeType.successMsg.soyTemplateName = 'JIRA.Templates.project.ChangeType.successMsg';
}
;
;
/* module-key = 'jira.webresources:change-project-type-dialog', location = '/includes/jira/dialog/changeProjectTypeDialog.js' */
define('jira/project/admin/change-project-type-dialog',[
    'jquery',
    'underscore',
    'jira/message',
    'jira/ajs/select/single-select',
    'wrm/context-path'
], function(
    $,
    _,
    message,
    SingleSelect,
    contextPath
) {
    function _getProjectInformation(projectId) {
        return $.ajax({
            url : contextPath() + "/rest/internal/2/projects/" + projectId + "/changetypedata",
            dataType: "json",
            contentType: "application/json",
            type:  "GET"
        });
    }

    function handleChangeProjectType(options){
        var $projectTypeSelect = $(".project-type-select", options.dialogBody);
        var selectedProjectTypeKey = $projectTypeSelect.val()[0];
        var selectedProjectType = _.findWhere(options.projectTypes, {key: selectedProjectTypeKey});
        $(".dialog-change-button", options.dialogBody).attr('disabled', 'disabled');

        $($.ajax({
            url : contextPath() + "/rest/api/2/project/" + options.projectId + "/type/" + selectedProjectTypeKey,
            dataType: "json",
            contentType: "application/json",
            type:  "PUT"
        }).done(function(){
            options.changeProjectTypeDialog.hide();

            if(options.onProjectTypeChanged) {
                options.onProjectTypeChanged(options.trigger, selectedProjectType);
            }

            message.showSuccessMsg(JIRA.Templates.project.ChangeType.successMsg({
                projectName:options.projectName,
                projectTypeName: selectedProjectType.formattedKey
            }));

            AJS.EventQueue.push({
                name: "administration.projecttype.change",
                properties: {
                    projectId: options.projectId,
                    sourceProjectType: _normalizeProjectTypeKey(options.sourceProjectType),
                    destinationProjectType: _normalizeProjectTypeKey(selectedProjectTypeKey)
                }
            });
        }).fail(function(){
            $(".aui-dialog2-content",options.dialogBody).prepend(aui.message.error({
                content: AJS.format("We haven\'\'t been able to complete the project conversion. You could refresh the page and try again. If this doesn\'\'t work, contact {0}Support{1}.", '<a href="https://support.atlassian.com/">', "</a>")
            }));
        })).throbber({target:$(".throbber", options.dialogBody)});
    }

    /**
     * Transform project type key to a format accepted as an analytics event property value
     * E.g. service_desk is not accepted as it contains _
     */
    function _normalizeProjectTypeKey(projectTypeKey) {
        return projectTypeKey && projectTypeKey.replace("_", "");
    }

    function toggleChangeButton(selectedType, currentType, $dialogBody){
        if(selectedType == currentType ){ // eslint-disable-line eqeqeq
            $dialogBody.find(".dialog-change-button").attr("disabled", "disabled");
        }else{
            $dialogBody.find(".dialog-change-button").removeAttr("disabled");
        }
    }
    /**
     * init the change project dialog
     * @param {Object} options
     * {projectIdOrKey: the project to be changed,
     * trigger: the link to trigger this dialog,
     * onProjectTypeChanged: the function to be called after project type is changed. }
     */
    function initDialog(options) {
        var $dialogBody = $(JIRA.Templates.project.ChangeType.changeProjectTypeDialog({projectId:options.projectId}));
        var changeProjectTypeDialog = AJS.dialog2($dialogBody);

        changeProjectTypeDialog.on("show", function() {
            $(".aui-dialog2-content", $dialogBody).html(JIRA.Templates.project.ChangeType.dialogSpinner());
            $(".dialog-spinner", $dialogBody).spin();

            $(".dialog-change-button", $dialogBody).unbind("click").addClass("hidden");
        });

        $(options.trigger).click(function(e) {
            e.preventDefault();

            changeProjectTypeDialog.show();

            _getProjectInformation(options.projectId).done(function(resp) {
                $dialogBody.find(".aui-dialog2-content").html(JIRA.Templates.project.ChangeType.changeProjectTypeForm(resp));
                new SingleSelect({
                    element: $(".project-type-select", $dialogBody),
                    revertOnInvalid: true,
                    width: 165
                });
                $dialogBody.find(".dialog-change-button").removeClass("hidden");

                toggleChangeButton($(".project-type-select", $dialogBody).val(), resp.project.projectTypeKey, $dialogBody) ;

                var $changeData = {
                    dialogBody: $dialogBody,
                    changeProjectTypeDialog: changeProjectTypeDialog,
                    projectName: resp.project.name,
                    projectTypes: resp.projectTypes,
                    trigger: options.trigger,
                    projectId: options.projectId,
                    onProjectTypeChanged: options.onProjectTypeChanged,
                    sourceProjectType: resp.project.projectTypeKey
                };

                $(".dialog-change-button", $dialogBody).click(function(e) {
                    e.preventDefault();
                    handleChangeProjectType($changeData);

                });

                $(".change-project-type-form", $dialogBody).on("submit", function(e) {
                    e.preventDefault();
                    handleChangeProjectType($changeData);
                });

                $(".project-type-select", $dialogBody).on("change", function(e) {
                    toggleChangeButton($(this).val(), resp.project.projectTypeKey, $dialogBody) ;
                });

            }).fail(function() {
                $(".aui-dialog2-content",$dialogBody).html(aui.message.error({
                    content: AJS.format("We were unable to load data required for the project type change. You could refresh the page and try again. If this doesn\'\'t work, contact {0}Support{1}.", '<a href="https://support.atlassian.com/">', "</a>")
                }));
            });
        });

        $(".dialog-close-button", $dialogBody).click(function(e) {
            e.preventDefault();
            changeProjectTypeDialog.hide();
        });
    }

    return function(options) {
        initDialog(options);
    };
});
;
;
/* module-key = 'jira.webresources:project-type-warning', location = '/static/projecttypes/warning/dialog/project-type-warning-dialog.js' */
define("jira/project/types/warning/dialog", [
    "require"
], function(
    require
) {
    "use strict";

    var jQuery = require("jquery");
    var wrmData = require("wrm/data");
    var InlineDialog = require("aui/inline-dialog");

    function attachDialog(dialogData, onProjectTypeChanged) {
        var trigger = jQuery(".project-type-warning-icon");
        InlineDialog(trigger, "uninstalled-warning-dialog", function (content, trigger, showPopup) {
            content.html(JIRA.Project.Types.Warning.dialog({
                title: dialogData.title,
                firstParagraph: dialogData.firstParagraph,
                secondParagraph: dialogData.secondParagraph,
                callToActionText: dialogData.callToActionText
            }));

            var ChangeProjectTypeDialog = require('jira/project/admin/change-project-type-dialog');
            ChangeProjectTypeDialog({
                trigger: jQuery(".warning-dialog-change-project-type"),
                projectId: dialogData.projectId,
                onProjectTypeChanged: onProjectTypeChanged
            });

            showPopup();
            return false;
        }, {
            width: 375,
            gravity: "w"
        });
    }

    var dialogData = wrmData.claim("project.type.warning.dialogs.data");

    return {
        init: function (options) {
            options = options || {};
            attachDialog(dialogData, options.onProjectTypeChanged);
        }
    };
});
;
;
/* module-key = 'jira.webresources:project-type-warning', location = '/static/projecttypes/warning/dialog/templates/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Project.Types.Warning.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Project == 'undefined') { JIRA.Project = {}; }
if (typeof JIRA.Project.Types == 'undefined') { JIRA.Project.Types = {}; }
if (typeof JIRA.Project.Types.Warning == 'undefined') { JIRA.Project.Types.Warning = {}; }


JIRA.Project.Types.Warning.dialog = function(opt_data, opt_ignored) {
  return '<div class="project-type-warning-dialog"><p class="header"><span>' + soy.$$escapeHtml(opt_data.title) + '</span></p><p class="type-not-accessible-message">' + soy.$$escapeHtml(opt_data.firstParagraph) + '</p><p class="available-functionality-message">' + soy.$$escapeHtml(opt_data.secondParagraph) + '</p><div class="actions"><a class="warning-dialog-change-project-type" href="#">' + soy.$$escapeHtml(opt_data.callToActionText) + '</a></div></div>';
};
if (goog.DEBUG) {
  JIRA.Project.Types.Warning.dialog.soyTemplateName = 'JIRA.Project.Types.Warning.dialog';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:marionette', location = '/sidebar/lib/backbone.marionette.adapter.js' */
define("jira/projects/libs/marionette", [
    "backbone",
    "underscore",
    "atlassian/libs/factories/marionette-2.1.0"
], function(Backbone, _, marionetteFactory) {
    "use strict";
    return marionetteFactory(_, Backbone);
});

AJS.namespace("JIRA.Projects.Libs.Marionette", null, require("jira/projects/libs/marionette"));
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:marionette', location = '/sidebar/lib/backbone.marionette.mixins.js' */
(function(){
    "use strict";

    /**
     * Triggers a preventable event.
     *
     * The event will include an EventObject, and the handler can call eventObject.preventDefault() to prevent the event.
     *
     * @param {string} eventName Name of the event being triggered.
     * @param {EventObject} [eventObject] EventObject used as template to construct the actual EventObject used in the event.
     *
     * @returns {EventObject} EventObject passed to the event.
     */
    function triggerPreventable(eventName, eventObject) {
        var instance = this;
        /**
         * EventObject passed to preventable events
         * @typedef {Object} EventObject
         * @property {Object} emitter Original emitter of the event.
         * @property {boolean} isPrevented Whether the event has been prevented by the event handler.
         * @property {Function} preventDefault Syntax sugar for set the `isPrevented` value.
         */
        var event = _.defaults({}, eventObject || {}, {
            isPrevented: false,
            emitter: this,
            preventDefault: function () {
                this.isPrevented = true;
                instance.trigger(eventName + ":prevented", this);
            }
        });

        this.trigger(eventName, event);
        return event;
    }

    function retriggerPreventable(eventName, eventObject) {
        var groupEvent = this.triggerPreventable(eventName, eventObject);
        if (groupEvent.isPrevented) {
            eventObject.preventDefault();
        }
    }

    _.extend(JIRA.Projects.Libs.Marionette.View.prototype, {
        /**
         * This method unwraps the Backbone.View.
         *
         * By default, Backbone will create a <div> and render the template inside. By calling this
         * method, you can get rid of that <div>, so the main element in your template will be the
         * root element in your template.
         */
        unwrapTemplate: function unwrapTemplate() {
            if (this.$el.parent().length) {
                // If the template is already rendered in the page
                var children = this.$el.children();
                this.$el.replaceWith(children);
                this.setElement(children);
            } else {
                // If the template is in memory
                this.setElement(this.$el.children());
            }
        },
        triggerPreventable: triggerPreventable,
        retriggerPreventable: retriggerPreventable
    });

    _.extend(JIRA.Projects.Libs.Marionette.Controller.prototype, {
        triggerPreventable: triggerPreventable,
        retriggerPreventable: retriggerPreventable
    });

    JIRA.Projects.Libs.Marionette.ViewManager = JIRA.Projects.Libs.Marionette.Controller.extend({
        constructor: function() {
            JIRA.Projects.Libs.Marionette.Controller.apply(this, arguments);
            this.views={};
        },

        hideView: function(viewName) {
            var view = this.views[viewName];
            if (view) {
                this.stopListening(view);
                if (!view.isDestroyed) {
                    view.destroy();
                }
                delete this.views[viewName];
            }
        },

        showView: function(viewName, factory) {
            var view = this.buildView(viewName, factory);
            view.render();
        },

        buildView: function(viewName, factory) {
            var view = this.views[viewName];
            if (!view) {
                view = factory.call(this);
                this.listenTo(view, "destroy", function() {
                    this.hideView(viewName);
                });
                this.views[viewName] = view;
            }
            return view;
        },

        getView: function(viewName) {
            return this.views[viewName];
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:data', location = 'data/web-resource-manager.js' */
define('jira/projects/data/WRM', window.WRM);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-component', location = '/sidebar/component/component.js' */
define('jira/projects/sidebar/component',
    ['jira/projects/data/WRM'],
    function(WRM) {
        'use strict';

        var isGlobalSidebar = Boolean(WRM.data.claim('is-global-sidebar'));

        return JIRA.Projects.Libs.Marionette.CompositeView.extend({
            childEvents: {
                'before:select': function(item, itemEvent) {
                    if (!this.hasASelectedItem()) {
                        itemEvent.isInitial = true;
                    }
                    this.retriggerPreventable('before:select', itemEvent);
                    if (!itemEvent.isPrevented) {
                        this.deselectAllGroups();
                    }
                },
                'select': function(child, ev) {
                    this.trigger('select', ev);
                },
                'before:deselect': function(item, itemEvent) {
                    this.retriggerPreventable('before:deselect', itemEvent);
                },
                'deselect': function(child, ev) {
                    this.trigger('deselect', ev);
                },
                'before:navigate': function(item, itemEvent) {
                    this.retriggerPreventable('before:navigate', itemEvent);
                },
                "before:navigate:prevented": function(item, itemEvent) {
                    this.trigger("before:navigate:prevented", itemEvent);
                }
            },

            initialize: function() {
                this.$('.aui-sidebar-group').each(_.bind(function(index, sidebarGroup) {
                    var navigationGroup = new JIRA.Projects.Sidebar.Component.NavigationGroup({
                        el: sidebarGroup
                    });
                    var alreadyExists = !!this.getGroup(navigationGroup.id);
                    if (alreadyExists && AJS.warn) {
                        AJS.warn('Duplicated IDs detected. There are more than one NavigationGroup with id data-id="' + navigationGroup.id + '"');
                    }

                    this.proxyChildEvents(navigationGroup);
                    this.children.add(navigationGroup, navigationGroup.id);
                }, this));
            },

            deselectAllGroups: function() {
                this.children.call('deselect');
            },

            replaceGroup: function(groupname, newGroup) {
                var oldGroup = this.getGroup(groupname);

                // Replace the DOM
                oldGroup.$el.replaceWith(newGroup.$el);

                // Replace the group in the internal list of groups. As we don't have a
                // replace method there, we need to remove the old group and add the new one
                // using the same `cid` to try to preserve the ordering.
                newGroup.cid = oldGroup.cid;
                this.children.remove(oldGroup);
                this.children.add(newGroup, newGroup.id);
            },

            getGroup: function(id) {
                return this.children.findByCustom(id);
            },

            getGroupAt: function(index) {
                return this.children.findByIndex(index);
            },

            getItem: function(id) {
                return this.getDefaultGroup().getItem(id);
            },

            /**
             * Returns HTML element representing sidebar.
             *
             * @returns {HTMLElement} HTML element representing sidebar.
             */
            getElement: function() {
                return this.el;
            },

            getDefaultGroup: function() {
                return this.getGroup('sidebar-navigation-panel');
            },

            isProjectSidebar: function() {
                return !isGlobalSidebar;
            },

            getSelectedScopeFilterId: function() {
                return this.$('.scope-filter a.scope-filter-trigger').attr('data-scope-filter-id');
            },

            setReportsItemLink: function(reportUrl) {
                var sidebarNavigationPanel = this.getGroup('sidebar-navigation-panel');

                // by default, tries to retrieve the project-centric link
                var reportLink = sidebarNavigationPanel.getItem('com.atlassian.jira.jira-projects-plugin:report-page');
                // in case it is not there (global board sidebar), let's get the one provided by Agile
                if (typeof reportLink === 'undefined') {
                    reportLink = sidebarNavigationPanel.getItem('com.pyxis.greenhopper.jira:global-sidebar-report');
                }

                if (reportLink) {
                    reportLink.ui.link.attr('href', reportUrl);
                }
            },

            getAUISidebar: function() {
                return AJS.sidebar('.aui-sidebar');
            },

            getContentContainer: function() {
                return this.$('.aui-sidebar-body .sidebar-content-container');
            },

            getSelectedNavigationItem: function() {
                return this.getDefaultGroup().getSelectedNavigationItem();
            },

            hasASelectedItem: function() {
                return this.getDefaultGroup().hasASelectedItem();
            }
        });
    });

AJS.namespace('JIRA.Projects.Sidebar.Component', null, require('jira/projects/sidebar/component'));;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-component', location = '/sidebar/component/navigation-item.js' */
(function () {
    "use strict";

    /** @namespace JIRA */
    /** @namespace JIRA.Projects */
    /** @namespace JIRA.Projects.Sidebar */
    /** @namespace JIRA.Projects.Sidebar.Component */
    AJS.namespace("JIRA.Projects.Sidebar.Component.NavigationItem");

    JIRA.Projects.Sidebar.Component.NavigationItem = JIRA.Projects.Libs.Marionette.CompositeView.extend(/** @lends JIRA.Projects.Sidebar.Component.NavigationItem# */{
        /**
         * @event JIRA.Projects.Sidebar.Component.NavigationItem#before:select
         * @type {EventObject}
         */

        /**
         * @event JIRA.Projects.Sidebar.Component.NavigationItem#select
         * @type {EventObject}
         */

        /**
         * @event JIRA.Projects.Sidebar.Component.NavigationItem#before:navigate
         * @type {EventObject}
         */

        /**
         * @event JIRA.Projects.Sidebar.Component.NavigationItem#before:deselect
         * @type {EventObject}
         */

        /**
         * @event JIRA.Projects.Sidebar.Component.NavigationItem#deselect
         * @type {EventObject}
         */

        ui: {
            link: "a.aui-nav-item"
        },

        events: {
            'simpleClick @ui.link:not([target="_blank"])': function (ev) {
                ev.preventDefault();
                this.navigate();
            }
        },

        /**
         * @classdesc Represents an individual item in a navigation group.
         *
         * @constructs
         * @extends JIRA.Projects.Libs.Marionette.CompositeView
         */
        initialize: function () {
            // Capture the ID of this item (if any).
            this.id = this.$el.find(">a").attr("data-link-id");

            // Ensure the `ui` and `events` hashes work as expected.
            this.bindUIElements();
        },

        /**
         * Returns HTML element representing sidebar item.
         *
         * @returns {HTMLElement} HTML element representing sidebar item.
         */
        getElement: function() {
            return this.el;
        },

        /**
         * Navigates to the URL specified in the item's href.
         *
         * This method will trigger the preventable event 'before:navigate'. If it is prevented,
         * no navigation will occur.
         *
         * @fires JIRA.Projects.Sidebar.Component.NavigationItem#before:navigate
         *
         * @returns {boolean} False if before:select were prevented, true otherwise.
         */
        navigate: function () {
            // Select the element first, so the consumer has an opportunity to prevent
            // before:select and/or before:deselect
            if (!this.select()) {
                return
            }

            // Trigger before:navigate
            var navigateEvent = this.triggerPreventable("before:navigate");
            if (navigateEvent.isPrevented) {
                return false;
            }

            // Navigate to HREF
            var href = this.ui.link.attr("href");
            if (href) {
                require('jira/util/browser').reloadViaWindowLocation(href);
            }

            return true;
        },

        /**
         * Selects the item.
         *
         * This method will throw two events, in this order:
         *
         *   * before:select (preventable)
         *   * select
         *
         * If the event 'before:select' is prevented, the element is not selected and the current selected item is not
         * deselected .
         *
         * @fires JIRA.Projects.Sidebar.Component.NavigationItem#before:select
         * @fires JIRA.Projects.Sidebar.Component.NavigationItem#select
         *
         * @returns {boolean} False if before:select were prevented, true otherwise.
         */
        select: function () {
            var selectEvent = this.triggerPreventable("before:select");
            if (selectEvent.isPrevented) {
                return false;
            }

            // Main operation
            this.$el.addClass("aui-nav-selected");

            // Trigger select
            this.trigger("select", selectEvent);

            return true;
        },

        /**
         * Deselects the item.
         *
         * This method will throw two events, in this order:
         *
         *   * before:deselect (preventable)
         *   * deselect
         *
         * If the event 'before:deselect' is prevented, the element is not deselected.
         *
         * @fires JIRA.Projects.Sidebar.Component.NavigationItem#before:deselect
         * @fires JIRA.Projects.Sidebar.Component.NavigationItem#deselect
         *
         * @returns {boolean} False if before:deselect was prevented, true otherwise.
         */
        deselect: function () {
            if (!this.isSelected()) {
                return true;
            }

            var event = this.triggerPreventable("before:deselect");
            if (event.isPrevented) {
                return false;
            }

            this.$el.removeClass("aui-nav-selected");
            this.$el.find('a').blur();
            this.trigger("deselect", event);
            return true;
        },

        /**
         * Checks if the element is selected.
         *
         * @returns {Boolean} Whether the element is selected.
         */
        isSelected: function () {
            return this.$el.hasClass("aui-nav-selected");
        },

        /**
         * Removes the badge of this navigation item
         */
        removeBadge: function() {
            this.$el.find('.aui-badge').remove();
        },

        getId: function() {
            return this.id;
        },

        getSelectedNavigationItem: function() {
            if (this.isSelected()) {
                return this;
            }
        },

        hasASelectedItem: function() {
            return this.isSelected();
        }
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-component', location = '/sidebar/component/navigation-group.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.Component.NavigationGroup");

    JIRA.Projects.Sidebar.Component.NavigationGroup = JIRA.Projects.Libs.Marionette.CompositeView.extend({
        childEvents: {
            "before:select": function (item, itemEvent) {
                this.retriggerPreventable("before:select", itemEvent);
                if (itemEvent.isPrevented) {
                    return;
                }

                // Deselect all the items. If they can't be deselected (i.e. someone prevented the before:deselect
                // event), force the before:select event to be prevented as well. This is useful in case someone else
                // is listening for this event.
                var itemWasDeselected = this.deselect();
                if (!itemWasDeselected) {
                    itemEvent.preventDefault();
                }
            },
            "select": function(child, ev) {
                this.trigger("select", ev);
            },
            "before:deselect": function(item, itemEvent) {
                this.retriggerPreventable("before:deselect", itemEvent);
            },
            "deselect": function(child, ev){
                this.trigger("deselect", ev);
            },
            "before:navigate": function(item, itemEvent) {
                this.retriggerPreventable("before:navigate", itemEvent);
            },
            "before:navigate:prevented": function(item, itemEvent) {
                this.trigger("before:navigate:prevented", itemEvent);
            }
        },

        initialize: function () {
            this.id = this.$el.attr("data-id");

            this.$(">ul>li").each(_.bind(function (index, li) {
                var navigationItem = JIRA.Projects.Sidebar.Component.NavigationGroup.build(li);

                var alreadyExists = !!this.getItem(navigationItem.id);
                if (alreadyExists && AJS.warn) {
                    AJS.warn("Duplicated IDs detected. There are more than one NavigationItem with id data-link-id='"+navigationItem.id+"'");
                }

                this.proxyChildEvents(navigationItem);
                this.children.add(navigationItem, navigationItem.id);
            }, this));
        },

        /**
         * Returns HTML element representing sidebar group.
         *
         * @returns {HTMLElement} HTML element representing sidebar group.
         */
        getElement: function() {
            return this.el;
        },

        /**
         * Deselect all the subviews.
         *
         * This method will call 'deselect()' for each item view.
         *
         * @returns {boolean} True if all the views where successfully deselected, false otherwise.
         */
        deselect: function () {
            var groupEvent = this.triggerPreventable("before:deselect");
            if (groupEvent.isPrevented) {
                return false;
            }

            // Can't use _.every() because it will stop the loop when the first 'false' value is found, and we still
            // want to call .deselect() in the rest of the views.
            var isSuccessful = true;
            this.children.each(function(view){
                isSuccessful = view.deselect() && isSuccessful;
            });
            return isSuccessful;
        },

        /**
         * Gets an item from the group.
         *
         * @param {string} id ID of the item to retrieve.
         * @returns {JIRA.Projects.Sidebar.Component.NavigationItem|JIRA.Projects.Sidebar.Component.NavigationSubgroup|undefined}
         */
        getItem: function (id) {
            return this.children.findByCustom(id);
        },

        /**
         * Gets an item based on its position.
         *
         * @param {number} index Position of the item.
         * @returns {JIRA.Projects.Sidebar.Component.NavigationItem|JIRA.Projects.Sidebar.Component.NavigationSubgroup|undefined}
         */
        getItemAt: function (index) {
            return this.children.findByIndex(index);
        },

        getSelectedNavigationItem: function() {
            var selectedItem = this.children.find(function(child) {
                return child.hasASelectedItem();
            });
            if (selectedItem) {
                return selectedItem.getSelectedNavigationItem();
            }
        },

        hasASelectedItem: function() {
            return this.children.any(function(child) {
                return child.hasASelectedItem();
            });
        }
    }, {
        build: function(element) {
            var instance;

            if (AJS.$(element).find("ul").length) {
                instance = new JIRA.Projects.Sidebar.Component.NavigationSubgroup({
                    el: element
                });
            } else {
                instance = new JIRA.Projects.Sidebar.Component.NavigationItem({
                    el: element
                });
            }

            return instance;
        }
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-component', location = '/sidebar/component/navigation-subgroup.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.Component.NavigationSubgroup");

    JIRA.Projects.Sidebar.Component.NavigationSubgroup = JIRA.Projects.Sidebar.Component.NavigationGroup.extend({
        childEvents: {
            "before:select": function (item, itemEvent) {
                JIRA.Projects.Sidebar.Component.NavigationGroup.prototype.childEvents["before:select"].apply(this, arguments);
                if (!itemEvent.isPrevented) {
                    this.expand();
                }
            }
        },

        initialize: function() {
            // Inherit childEvents
            this.childEvents = _.extend({}, JIRA.Projects.Sidebar.Component.NavigationGroup.prototype.childEvents, this.childEvents);

            JIRA.Projects.Sidebar.Component.NavigationGroup.prototype.initialize.apply(this, arguments);
            this.id = this.$el.find(">a[data-link-id]").attr("data-link-id");
        },

        expand: function () {
            // Most of the expand/collapse logic is already handled by AJS.sidebar(). As we can't detect all the
            // expansion events, it is better to not provide events for this action at all.
            this.$el.attr('aria-expanded', 'true');
        },

        collapse: function () {
            // Most of the expand/collapse logic is already handled by AJS.sidebar(). As we can't detect all the
            // expansion events, it is better to not provide events for this action at all.
            this.$el.attr('aria-expanded', 'false');
        },

        isExpanded: function() {
            return this.$el.attr('aria-expanded') === 'true';
        },

        isSelected: function() {
            return this.$el.hasClass("aui-nav-selected");
        },

        getId: function() {
            return this.id;
        },

        getSelectedNavigationItem: function() {
            if (this.isSelected()) {
                return this;
            }
            var selectedItem = this.children.find(function(child) {
                return child.hasASelectedItem();
            });
            if (selectedItem) {
                return selectedItem.getSelectedNavigationItem();
            }
        },

        hasASelectedItem: function() {
            if (this.isSelected()) {
                return true;
            }
            return this.children.any(function(child) {
                return child.hasASelectedItem();
            });
        }
    });
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-api', location = '/sidebar/api.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar");
    AJS.namespace("JIRA.API");

    var sidebarDeferred = AJS.$.Deferred();

    JIRA.API.getSidebar = function() {
        return sidebarDeferred.promise();
    };

    JIRA.Projects.Sidebar.initAPI = function(sidebarComponent) {
        // TODO We should add a simple facade to the component, so we only expose a
        // subset of the component's methods
        JIRA.API.Sidebar = sidebarComponent;
        sidebarDeferred.resolve(JIRA.API.Sidebar);
    };
}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-analytics', location = '/sidebar/analytics/analytics.js' */
(function ($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.Analytics");

    function hashedId(id) {
        return JIRA.Projects.Sidebar.Analytics.Hash.prefixedHash(id || "NONE");
    }

    function triggerAnalyticsEvent(eventName, data) {
        AJS.trigger('analyticsEvent', {
            name: "jira.project.centric.navigation.sidebar." + eventName,
            data: data
        });
    }

    /**
     * Sets up Analytics events to track the usage of the sidebar.
     *
     * This method will trigger two types of events:
     *
     *   * jira.project.centric.navigation.sidebar.load.*: whenever the sidebar (i.e. this file) is loaded
     *   * jira.project.centric.navigation.sidebar.click.link: whenever a a link in the sidebar is clicked.
     *
     * For the click events, the data-link-id attribute (if any exists) will be reported in the event, but
     * will be hashed first in case the id contains sensitive data. Known safe link id prefixes can be
     * excluded from the hash for easier tracking using {@link JIRA.Projects.Sidebar.Analytics.Hash.addPrefix}
     *
     * @param sidebarElement {Element|jQuery|string} the element or selector representing the sidebar
     */
    JIRA.Projects.Sidebar.Analytics = function(sidebarElement) {
        var sidebar = AJS.sidebar(sidebarElement);
        var $sidebar = $();
        $sidebar = $sidebar.add(sidebar.$el);
        $sidebar = $sidebar.add(sidebar.submenus.inlineDialog);

        if (!JIRA.API.Sidebar) {
            throw new Error('Error: cannot start analytics before JIRA.Projects.Sidebar.initAPI is called');
        }

        if (JIRA.API.Sidebar.isProjectSidebar()) {
            triggerAnalyticsEvent('load.project');
        } else {
            triggerAnalyticsEvent('load.global');
        }

        $sidebar.on('click', 'a', function() {
            var hashed = hashedId($(this).attr("data-link-id"));
            var data = {id: hashed.hash, prefix: hashed.prefix};

            var renderMode = AJS.Meta.get("sidebar-source-page");
            if (renderMode) {
                data.sidebarSourcePage = renderMode;
            } else {
                // Fall back to checking for a particular button if no meta is found (old versions of nav plugin)
                // probably this should be deleted eventually (around April/May 2016 once meta data is added).
                if ($(".issue-tools button.expand").length > 0) {
                    data.sidebarSourcePage = "search-el";
                } else if ($(".navigation-tools button.collapse").length > 0) {
                    data.sidebarSourcePage = "fullscreen-el";
                }
            }

            if (SOURCE_PAGE_WHITELIST.indexOf(data.sidebarSourcePage) === -1) {
                data.sidebarSourcePage = "unknown";
            }

            triggerAnalyticsEvent("click.link", data);
        });
    };

    var SOURCE_PAGE_WHITELIST = [
        "search-el",
        "fullscreen-el",
        "search",
        "fullscreen",
        "rapid-board",
        "service-desk"
    ];

})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-analytics', location = '/sidebar/analytics/hash.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.Analytics");

    var prefixes = [];

    function startsWith(string, prefix) {
        return string.indexOf(prefix) === 0;
    }

    function substringAfter(string, prefix) {
        return string.substring(startsWith(string, prefix) ? prefix.length : 0);
    }

    function hashCode (string) {
        var charCode;
        var hash = 0;
        if (!string) {
            return "";
        }

        for (var i = 0; i < string.length; i += 1) {
            charCode = string.charCodeAt(i);
            hash = ((hash * 32) - hash) + charCode;
            hash |= 0; // force 32-bit representation
        }

        return hash;
    }

    JIRA.Projects.Sidebar.Analytics.Hash = {
        /**
         * A hashed version of the provided string (for anonymising analytics data).
         *
         * If the id starts with a 'whitelisted' prefix, the prefix + the hashCode
         * of the remainder will be returned. e.g. "prefix-foo -> prefix-101574"
         *
         * Hashing uses the same algorithm as Java's String.hashCode
         * (good for anonymity, not suitable for security purposes)
         *
         * @param string The string to hash
         * @returns {String} The whitelisted prefix of the string, followed by
         * the 'hash code' of the remainder
         */
        prefixedHash: function (string) {
            var prefix = _.find(prefixes, _.partial(startsWith, string)) || "";
            return {
                prefix: prefix,
                hash: prefix + hashCode(substringAfter(string, prefix))
            };
        },

        /**
         * Register an id prefix as safe for exclusion from the hashing process.
         *
         * e.g. If the prefix "prefix-" is registered then "prefix-foo" will
         * hash to "prefix-101574"
         *
         * @param prefix The prefix to register as safe
         */
        addPrefix: function (prefix) {
            if (prefix && !_.contains(prefixes, prefix)) {
                prefixes.push(prefix);
            }
        },

        /**
         * Clear all whitelisted prefixes (see {@link addPrefix})
         */
        clearPrefixes: function () {
            prefixes.length = 0;
        }
    };

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-expansion-manager', location = '/sidebar/expansion-manager.js' */
(function() {
    "use strict";

    var STORAGE_KEY = 'jira-sidebar-collapsed';

    AJS.namespace('JIRA.Projects.Sidebar');

    /**
     * @param {AJS.sidebar} sidebar An AUI sidebar.
     * @param {Storage} [storage=window.localStorage] The object in which to
     *     persist `sidebar`'s expansion state.
     */
    JIRA.Projects.Sidebar.ExpansionManager = function(sidebar, storage) {
        storage || (storage = window.localStorage);

        var isSidebarCollapsedByDefault = !!WRM.data.claim('sidebar-collapsed-by-default');

        restoreCollapsedState();
        sidebar.on("expand-start", controlCollapsedStateOnResize);
        sidebar.on('expand-end collapse-end', persistCollapsedState);

        function controlCollapsedStateOnResize(event) {
            // prevent auto-expansion if user collapsed the sidebar before
            if (event.isResponsive && storage[STORAGE_KEY] === 'true') {
                event.preventDefault();
            }
        }

        function persistCollapsedState(event) {
            // remember the collapsed state only when it collapses on user's request
            // and viewport is not narrow at the moment
            if (!event.isResponsive && !sidebar.isViewportNarrow()) {
                storage[STORAGE_KEY] = sidebar.isCollapsed().toString();
            }
        }

        function restoreCollapsedState() {
            if (sidebar.reflow() && sidebar.isViewportNarrow()) {
                return;
            }

            if ((isSidebarCollapsedByDefault && storage[STORAGE_KEY] === undefined) || storage[STORAGE_KEY] === 'true') {
                sidebar.collapse();
            } else {
                sidebar.expand();
            }
        }
    };

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:projects-api', location = 'page/projects-api.js' */
define('jira/api/projects', ['jira/projects/data/WRM'], function (WRM) {
    'use strict';

    var projectKey = WRM.data.claim('project-key'),
        projectId = WRM.data.claim('project-id'),
        projectName = WRM.data.claim('project-name');

    return {
        getCurrentProjectId: function () {
            return projectId;
        },
        getCurrentProjectKey: function () {
            return projectKey;
        },
        getCurrentProjectName: function () {
            return projectName;
        }
    };
});

AJS.namespace('JIRA.API.Projects', null, require('jira/api/projects'));;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-last-visited', location = '/sidebar/lastvisited/last-visited-updater.js' */
define("jira/projects/sidebar/lastvisited/updater", [
    "jquery"
], function(
    $
) {
    "use strict";

    function updateLastViewedItem(projectKey, selectedItemId, callback) {
        callback = callback || function () {
            JIRA.trace("last.visited.item.saved");
        };
        $.ajax({
            url: AJS.contextPath() + "/rest/projects/1.0/project/" + encodeURIComponent(projectKey) + "/lastVisited",
            type: "PUT",
            contentType: "application/json",
            data: JSON.stringify({
                id: selectedItemId
            })
        }).done(callback);
    }


    return {
        start: function (sidebar, callback) {
            var currentProjectKey = (JIRA.API && JIRA.API.Projects && JIRA.API.Projects.getCurrentProjectKey()) || null;
            var selectedNavItem = sidebar.getSelectedNavigationItem();
            if (selectedNavItem) {
                updateLastViewedItem(currentProjectKey, selectedNavItem.getId(), callback);
            }
            sidebar.on("before:navigate:prevented", function (event) {
                updateLastViewedItem(currentProjectKey, event.emitter.id, callback);
            });
            sidebar.on("before:select", function (event) {
                if (event.isInitial) {
                    updateLastViewedItem(currentProjectKey, event.emitter.id, callback);
                }
            });
        }
    };
});

AJS.namespace("JIRA.Projects.Sidebar.LastVisited.Updater", null, require("jira/projects/sidebar/lastvisited/updater"));
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-init', location = '/sidebar/main.js' */
AJS.$(function() {
    "use strict";

    // Keep in sync with the list in com.atlassian.jira.projects.util.PageIdHasher
    var prefixWhitelist = [
        // The constant "NONE" will represent id-less links that were clicked
        "NONE",
        "com.atlassian.jira.jira-projects-plugin:project-issue-search-link",
        "com.atlassian.jira.jira-projects-plugin:components-page",
        "com.atlassian.jira.jira-projects-plugin:reports-panel",
        "com.atlassian.jira.jira-projects-plugin:summary-panel",
        "com.atlassian.jira.jira-projects-plugin:summary-page",
        "com.atlassian.jira.jira-projects-plugin:components-page",
        "com.atlassian.jira.jira-projects-plugin:release-page",
        "com.atlassian.jira.jira-projects-plugin:release-sidebar-version-",
        "com.atlassian.jira.jira-projects-plugin:report-page",
        "com.pyxis.greenhopper.jira:global-sidebar-report",
        "com.pyxis.greenhopper.jira:global-sidebar-plan-scrum",
        "com.pyxis.greenhopper.jira:global-sidebar-work-scrum",
        "com.pyxis.greenhopper.jira:global-sidebar-work-kanban",
        "com.pyxis.greenhopper.jira:project-sidebar-plan-scrum",
        "com.pyxis.greenhopper.jira:project-sidebar-work-scrum",
        "com.pyxis.greenhopper.jira:project-sidebar-work-kanban",
        "com.pyxis.greenhopper.jira:project-invite-users-link",
        "com.pyxis.greenhopper.jira:sidebar-feedback-link",
        "com.atlassian.jira.jira-projects-issue-navigator:embedded-issue-navigator-link",
        "com.atlassian.jira.jira-projects-issue-navigator:sidebar-issue-navigator",
        "com.atlassian.jira.jira-projects-plugin:project-invite-users-link",
        "com.atlassian.jira.jira-projects-plugin:sidebar-feedback-link"
    ];

    function initSidebarBadges(sidebar) {
        var badges = AJS.$('.aui-sidebar .aui-badge');
        badges.tooltip({ gravity: 'w' });

        if (sidebar.isCollapsed()) {
            badges.tooltip('disable');
        }

        sidebar.on('collapse-end expand-end', function () {
            AJS.$(".tipsy").remove();
            AJS.$('.aui-sidebar .aui-badge').tooltip('toggleEnabled');
        });
    }

    /**
     * Schedules a reflow of the sidebar, so its height is recomputed periodically.
     *
     * We need this to bring back the bottom of the sidebar, which gets lost when
     * banners get displayed on the top of the page after it's loaded.
     */
    function scheduleSidebarReflow() {
        function reflow() {
            JIRA.API.Sidebar.getAUISidebar().reflow();
        }

        setTimeout(reflow, 200);
        setInterval(reflow, 5 * 60 * 1000);
    }

    function initDropdownCloser(sidebar) {
        sidebar.on('collapse-start', function() {
            var dropdown = sidebar.$el.find(".scope-filter-trigger");
            if (dropdown.hasClass("aui-dropdown2-active")) {
                dropdown.trigger("aui-button-invoke");
            }
        });
    }

    function attachProjectTypesWarningDialog() {
        require("jira/project/types/warning/dialog").init({
            onProjectTypeChanged: function() {
                // we want to take the user to the summary page, just in case the project type
                // change happens from a page for which she will have no access to after the type has changed
                var projectKey = JIRA.API.Projects.getCurrentProjectKey();
                window.location.replace(AJS.contextPath() + "/projects/" + projectKey + "/summary");
            }
        });
        JIRA.trace("project.types.warning.messages.init");
    }

    if (AJS.$('.aui-sidebar').length) {
        var sidebar = AJS.sidebar('.aui-sidebar');

        JIRA.Projects.Sidebar.initAPI(new JIRA.Projects.Sidebar.Component({el: sidebar.$el[0]}));
        JIRA.Projects.Sidebar.ExpansionManager(sidebar);

        _(prefixWhitelist).each(JIRA.Projects.Sidebar.Analytics.Hash.addPrefix);
        JIRA.Projects.Sidebar.Analytics('.aui-sidebar');

        initDropdownCloser(sidebar);
        initSidebarBadges(sidebar);
        scheduleSidebarReflow();
        attachProjectTypesWarningDialog();

        JIRA.API.getSidebar().done(function(sidebar) {
            JIRA.Projects.Sidebar.LastVisited.Updater.start(sidebar);
        });
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:collapsed-scope-filter', location = '/sidebar/scopefilter/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.Sidebar.ScopeFilter.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.Sidebar == 'undefined') { JIRA.Projects.Sidebar = {}; }
if (typeof JIRA.Projects.Sidebar.ScopeFilter == 'undefined') { JIRA.Projects.Sidebar.ScopeFilter = {}; }
if (typeof JIRA.Projects.Sidebar.ScopeFilter.Templates == 'undefined') { JIRA.Projects.Sidebar.ScopeFilter.Templates = {}; }


JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedContainer = function(opt_data, opt_ignored) {
  return '<div class="aui-sidebar-group aui-sidebar-group-actions collapsed-scope-filter-container"></div>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedContainer.soyTemplateName = 'JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedContainer';
}


JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedScopeList = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  var output = '';
  if (opt_data.selectableScopes || opt_data.createActions) {
    output += '<div class="aui-nav-heading" title="' + soy.$$escapeHtml("Boards in this project") + '"><strong class="collapsed-scope-header">' + soy.$$escapeHtml("Boards in this project") + '</strong></div><ul class="aui-nav collapsed-scope-list" title="' + soy.$$escapeHtml("Select a board") + '">';
    if (opt_data.selectedScope) {
      output += '<li class="scope-filter selected-scope-filter" title="' + soy.$$escapeHtml(opt_data.selectedScope.label) + '">' + soy.$$escapeHtml(opt_data.selectedScope.label) + '</li>';
      var scopeFilterList21 = opt_data.selectableScopes;
      var scopeFilterListLen21 = scopeFilterList21.length;
      for (var scopeFilterIndex21 = 0; scopeFilterIndex21 < scopeFilterListLen21; scopeFilterIndex21++) {
        var scopeFilterData21 = scopeFilterList21[scopeFilterIndex21];
        output += JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedSelectableItem({itemClass: 'scope-filter', anchorClass: scopeFilterData21.styleClass, label: scopeFilterData21.label, link: scopeFilterData21.link});
      }
    }
    if (opt_data.createActions) {
      var createActionList30 = opt_data.createActions;
      var createActionListLen30 = createActionList30.length;
      for (var createActionIndex30 = 0; createActionIndex30 < createActionListLen30; createActionIndex30++) {
        var createActionData30 = createActionList30[createActionIndex30];
        output += JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedSelectableItem({itemClass: 'create-scope-action', anchorClass: createActionData30.styleClass, label: createActionData30.label, link: createActionData30.link});
      }
    }
    output += '</ul>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedScopeList.soyTemplateName = 'JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedScopeList';
}


JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedSelectableItem = function(opt_data, opt_ignored) {
  return '<li class="' + soy.$$escapeHtml(opt_data.itemClass) + '"><a href="' + soy.$$escapeHtml(opt_data.link) + '" title="' + soy.$$escapeHtml(opt_data.label) + '"' + ((opt_data.anchorClass) ? ' class="' + soy.$$escapeHtml(opt_data.anchorClass) + '"' : '') + '>' + soy.$$escapeHtml(opt_data.label) + '</a></li>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedSelectableItem.soyTemplateName = 'JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedSelectableItem';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:collapsed-scope-filter', location = '/sidebar/scopefilter/model.js' */
(function() {
    "use strict";

    AJS.namespace('JIRA.Projects.Sidebar.ScopeFilter');

    JIRA.Projects.Sidebar.ScopeFilter.Model = function(data) {
        this.selectedScope = data.selectedScope;
        this.createScopeActions = data.createScopeActions;

        if(this.selectedScope) {
            this.selectableScopes = _.reject(data.scopes, function(scope) {
                return scope.label === this.selectedScope.label && scope.link === this.selectedScope.link;
            }, this);
        } else {
            this.selectableScopes = data.scopes;
        }

        var userCanCreateAScope = this.createScopeActions.length > 0;
        var thereAreScopesToSelect = this.selectableScopes.length > 0;
        this.displayWhenSidebarIsCollapsed = userCanCreateAScope || thereAreScopesToSelect;
    };

    JIRA.Projects.Sidebar.ScopeFilter.Model.prototype.getSelectedScope = function() {
        return this.selectedScope
    };

    JIRA.Projects.Sidebar.ScopeFilter.Model.prototype.getSelectableScopes = function() {
        return this.selectableScopes;
    };

    JIRA.Projects.Sidebar.ScopeFilter.Model.prototype.getCreateScopeActions = function() {
        return this.createScopeActions;
    };

    JIRA.Projects.Sidebar.ScopeFilter.Model.prototype.shouldDisplayWhenSidebarIsCollapsed = function() {
        return this.displayWhenSidebarIsCollapsed;
    }
})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:collapsed-scope-filter', location = '/sidebar/scopefilter/collapsed-view.js' */
(function() {
    "use strict";

    AJS.namespace('JIRA.Projects.Sidebar.ScopeFilter');

    JIRA.Projects.Sidebar.ScopeFilter.CollapsedView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedScopeList,

        serializeData: function() {
            return {
                selectedScope: this.model.getSelectedScope(),
                selectableScopes: this.model.getSelectableScopes(),
                createActions: this.model.getCreateScopeActions()
            }
        },

        onRender: function() {
            this.unwrapTemplate();
        }
    });
})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:collapsed-scope-filter', location = '/sidebar/scopefilter/collapsed-controller.js' */
(function() {
    "use strict";

    AJS.namespace('JIRA.Projects.Sidebar.ScopeFilter');

    JIRA.Projects.Sidebar.ScopeFilter.CollapsedController = JIRA.Projects.Libs.Marionette.Controller.extend({
        initialize: function(options) {
            this.scopeFilter = options.scopeFilter;

            // This special Region uses view.$el (as opposed to view.el), so all the nodes in the child
            // view will be appended to our element.
            var MultiElementRegion = JIRA.Projects.Libs.Marionette.Region.extend({
                attachHtml: function(view) {
                    // empty the node and append new view
                    this.$el.empty().append(view.$el);
                }
            });

            this.collapsedScopeFilterContainer = new MultiElementRegion({
                el: options.collapsedScopeFilterContainer
            });
        },

        render: function() {
            var view = new JIRA.Projects.Sidebar.ScopeFilter.CollapsedView({
                model: this.scopeFilter
            });
            this.collapsedScopeFilterContainer.show(view);
        },

        remove: function() {
            this.collapsedScopeFilterContainer.empty();

            //Unfortunately, we also need to do this as well because the previous line might fail
            //due to AUI inline dialog moving elements around.
            this.collapsedScopeFilterContainer.$el.empty();
        }
    });
})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:collapsed-scope-filter', location = '/sidebar/scopefilter/collapsed-initializer.js' */
(function() {
    "use strict";

    AJS.namespace('JIRA.Projects.Sidebar.ScopeFilter');

    function createCollapsedScopeFilterContainer($sidebarContentContainer) {
        var $collapsedSidebarContainer = AJS.$(JIRA.Projects.Sidebar.ScopeFilter.Templates.collapsedContainer());
        $sidebarContentContainer.prepend($collapsedSidebarContainer);
        return $collapsedSidebarContainer;
    }

    function listenToSidebarEvents(sidebar, collapsedScopeFilterController) {
        sidebar.on('collapse-start', function() {
            collapsedScopeFilterController.render();
            JIRA.trace("sidebar.scopefilter.collapsed");
        });

        sidebar.on('expand-end', function() {
            collapsedScopeFilterController.remove();
        });
    }

    JIRA.Projects.Sidebar.ScopeFilter.CollapsedInitializer = JIRA.Projects.Libs.Marionette.Controller.extend({
        initialize: function(options) {
            this.sidebarAPI = options.sidebarAPI;
            this.scopeFilterData = options.scopeFilterData;
            this.sidebar = options.sidebar;
            this.$sidebarContentContainer = options.$sidebarContentContainer;
        },

        run: function() {
            if(!this.sidebarAPI.isProjectSidebar()) {
                return;
            }

            var scopeFilter = new JIRA.Projects.Sidebar.ScopeFilter.Model(this.scopeFilterData);
            if(!scopeFilter.shouldDisplayWhenSidebarIsCollapsed()) {
                return;
            }

            var $collapsedSidebarContainer = createCollapsedScopeFilterContainer(this.$sidebarContentContainer);
            var collapsedScopeFilterController = new JIRA.Projects.Sidebar.ScopeFilter.CollapsedController({
                scopeFilter: scopeFilter,
                collapsedScopeFilterContainer: $collapsedSidebarContainer
            });
            listenToSidebarEvents(this.sidebar, collapsedScopeFilterController);
            if (this.sidebar.isCollapsed()) {
                collapsedScopeFilterController.render();
            }
        }
    });
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:collapsed-scope-filter', location = '/sidebar/scopefilter/collapsed-init.js' */
(function() {
    "use strict";

    var scopeFilterData = WRM.data.claim('scope-filter-data');
    if (scopeFilterData) {
        JIRA.API.getSidebar().done(function(sidebarAPI) {
            var initializer = new JIRA.Projects.Sidebar.ScopeFilter.CollapsedInitializer({
                sidebarAPI: sidebarAPI,
                scopeFilterData: scopeFilterData,
                sidebar: sidebarAPI.getAUISidebar(),
                $sidebarContentContainer: sidebarAPI.getContentContainer()
            });
            initializer.run();
        });
    }
})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:feature-discovery', location = '/sidebar/feature-discovery/feature-discovery.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.FeatureDiscovery");

    function removeBadgesFor(navigationItems) {
        _.each(navigationItems, function(navigationItemId) {
            var navigationItem = JIRA.API.Sidebar.getItem(navigationItemId);
            if (navigationItem) {
                navigationItem.removeBadge();
            }
        });
    }

    JIRA.Projects.Sidebar.FeatureDiscovery = {
        /**
         * Updates the badges displayed next to the links on the sidebar.
         */
        updateBadges: function() {
            // a global board sidebar does not have a single project key to be used
            if (typeof JIRA.API.Projects.getCurrentProjectKey() === 'undefined') {
                return;
            }

            AJS.$.ajax({
                url: AJS.contextPath() + '/rest/projects/1.0/project/' + encodeURIComponent(JIRA.API.Projects.getCurrentProjectKey()) + '/badges',
                type: "PUT",
                contentType:"application/json"
            }).done(function(response) {
                removeBadgesFor(response.badgesToRemove || []);
            });
        }
    }
}());
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:feedback-issue-collector', location = '/static/page/sidebar/ancillary/feedback/issue-collector.js' */
(function($) {
    "use strict";

    var loadingIndicator = require('jira/loading/loading');
    var loading = false;
    var initializeIssueCollector = downloadResources;

    function downloadResources() {
        if (loading) {
            return;
        }

        loadingStarts();
        // once all the issue collector resources are downloaded and evaluated, there is a call to window.ATL_JQ_PAGE_PROPS.triggerFunction
        window.ATL_JQ_PAGE_PROPS =  {
            "triggerFunction": function(showIssueCollectorDialog) {
                initializeIssueCollector = showIssueCollectorDialog;
                // The downloaded issue collector resources call this method and then create a DOM node to use as the container for the dialog.
                // We need to defer this call so the container is already on the page before showing the dialog.
                _.defer(function() {
                    loadingEnds(true);
                    showIssueCollectorDialog();
                });
            }
        };

        $.ajax({
            url: "https://jira.atlassian.com/s/d41d8cd98f00b204e9800998ecf8427e/en_UK-3tj2he/6322/131/1.4.11/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector-embededjs/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector-embededjs.js?collectorId=55320d27",
            type: "get",
            cache: true,
            timeout: 10000, // timeout before error function will be called - this is needed for errors like bad gateway where jQuery will not reject the promise
            dataType: "script"
        })
            .fail(function(xhr) {
                loadingEnds();
                JIRA.Messages.showErrorMsg(JIRA.SmartAjax.buildSimpleErrorContent(xhr), {
                    closeable: true
                });
            });
    }

    function loadingStarts() {
        loading = true;
        AJS.dim();
        loadingIndicator.showLoadingIndicator();
    }

    function loadingEnds(success) {
        loading = false;
        // remove transition from the dim so there is no "blink" when issue collector gets displayed
        // do not do it on failure, so the layer is disabled smoothly then
        if (success) {
            AJS.dim.$dim.css("transition", "none");
        }
        AJS.undim();

        //Some pages (I'm looking at you, IssueNav) provide a different implementation of AJS.undim()
        //that removes AJS.dim.$dim, so we have to check for that special case here.
        if (success && AJS.dim.$dim) {
            AJS.dim.$dim.css("transition", "");
        }
        loadingIndicator.hideLoadingIndicator();
    }

    var feedbackCollectorData = WRM.data.claim("com.atlassian.jira.jira-projects-plugin:feedback-issue-collector.data");
    if (feedbackCollectorData && feedbackCollectorData.isFeedbackButtonEnabled) {
        $(function() {
            JIRA.API.getSidebar().done(function(Sidebar) {
                var AUISidebar = Sidebar.getAUISidebar();
                var feedbackGroup = Sidebar.getGroup("jira-projects-ancillary-group");

                if (feedbackGroup === undefined) {
                    return;
                }

                var feedbackItem = feedbackGroup.getItem("com.atlassian.jira.jira-projects-plugin:sidebar-feedback-link") || feedbackGroup.getItem("com.pyxis.greenhopper.jira:sidebar-feedback-link");

                var $feedbackLink = feedbackItem.ui.link;

                // Setting the tooltip value here until the NavigationItem can support custom tooltips / descriptions.
                $feedbackLink.data("custom-tooltip", "We\'d love to hear your thoughts on JIRA.");

                var tipsyOpts = {
                    trigger: 'manual',
                    gravity: 'w',
                    className: 'aui-sidebar-section-tooltip',
                    title: function () {
                        return $(this).data("custom-tooltip");
                    }
                };
                function showTipsy(trigger) {
                    var $trigger = $(trigger);
                    $trigger.tipsy(tipsyOpts).tipsy('show');
                    var $tip = $trigger.data('tipsy') && $trigger.data('tipsy').$tip;
                    // Remove "opacity" inline style from Tipsy to allow the our own styles and transitions to be applied
                    $tip.css({'opacity': ''}).addClass('tooltip-shown');
                }

                function hideTipsy(trigger, andDestroy) {
                    var $trigger = $(trigger);
                    var $tip = $trigger.data('tipsy') && $trigger.data('tipsy').$tip;
                    if ($tip) {
                        $tip.on('transitionend', function () {
                            $trigger.tipsy('hide');
                        });
                        $tip.removeClass('tooltip-shown');
                        if (andDestroy) {
                            $tip.remove();
                            $trigger.removeData('tipsy');
                        }
                    }
                }

                AUISidebar.on('expand-end collapse-end', function () {
                    hideTipsy($feedbackLink, true);
                });

                $feedbackLink.on('mouseenter focus', function (e) {
                    showTipsy(e.currentTarget); // using currentTarget to avoid accidentally tipsy-ing child <span>s.
                });

                $feedbackLink.on('click blur mouseleave', function (e) {
                    hideTipsy(e.currentTarget); // using currentTarget to avoid accidentally tipsy-ing child <span>s.
                });

                feedbackItem.on("before:select", function(e) {
                    e.preventDefault();
                });
            });
        });

        $(document).on("click", ".jira-projects-feedback-collector", function(e) {
            e.preventDefault();
            initializeIssueCollector();
        });
    }

})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:project-page', location = '/sidebar/navigation/items.js' */
AJS.$(function($) {
    $(document).on('click', '.aui-nav > [aria-expanded] > a.aui-nav-item[href="#"]', function(e) {
        e.preventDefault();

        AJS.navigation($(this).siblings('.aui-nav')).toggle();
    });
});;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.Sidebar.ProjectShortcuts.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.Sidebar == 'undefined') { JIRA.Projects.Sidebar = {}; }
if (typeof JIRA.Projects.Sidebar.ProjectShortcuts == 'undefined') { JIRA.Projects.Sidebar.ProjectShortcuts = {}; }
if (typeof JIRA.Projects.Sidebar.ProjectShortcuts.Templates == 'undefined') { JIRA.Projects.Sidebar.ProjectShortcuts.Templates = {}; }


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.content = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.canManage || opt_data.numberOfShortcuts > 0) {
    output += '<div class="aui-sidebar-group jira-sidebar-group-with-divider project-shortcuts-group' + ((opt_data.numberOfShortcuts == 0) ? ' project-shortcuts-group_empty' : '') + '" data-id="project-shortcuts-group"><div class="aui-nav-heading">' + soy.$$escapeHtml("Project shortcuts") + '</div>' + ((opt_data.canManage) ? '<p class="project-shortcuts-group__description' + ((opt_data.numberOfShortcuts > 0) ? ' hidden' : '') + '">' + soy.$$escapeHtml("Add a link to useful information for your whole team to see.") + '</p>' : '') + '<ul class="aui-nav project-shortcuts-list">';
    if (opt_data.shortcuts) {
      var shortcutList24 = opt_data.shortcuts;
      var shortcutListLen24 = shortcutList24.length;
      for (var shortcutIndex24 = 0; shortcutIndex24 < shortcutListLen24; shortcutIndex24++) {
        var shortcutData24 = shortcutList24[shortcutIndex24];
        output += JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcut({id: shortcutData24.id, name: shortcutData24.name, url: shortcutData24.url, icon: shortcutData24.icon, canManage: opt_data.canManage, iconsMap: opt_data.iconsMap, isWithIcon: opt_data.isWithIcons});
      }
    }
    output += ((opt_data.canManage) ? '<li><a class="aui-nav-item project-shortcuts-group__add" href="#" data-link-id="project-shortcut-add"><span class="aui-icon aui-icon-large aui-iconfont-add-small"></span><span class="aui-nav-item-label">' + soy.$$escapeHtml("Add link") + '</span></a></li>' : '') + '</ul></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.content.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.content';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcut = function(opt_data, opt_ignored) {
  return '<li class="project-shortcut"><a class="aui-nav-item project-shortcuts-group__link" href="' + soy.$$escapeHtml(opt_data.url) + '" title="' + soy.$$escapeHtml(opt_data.name) + '" target="_blank" data-shortcut-id="' + soy.$$escapeHtml(opt_data.id) + '" data-link-id="project-shortcut-' + soy.$$escapeHtml(opt_data.id) + '">' + ((opt_data.isWithIcon) ? '<span class="aui-icon aui-icon-large ' + JIRA.Projects.Sidebar.ProjectShortcuts.Templates.icon({iconId: opt_data.icon, iconsMap: opt_data.iconsMap}) + '" data-project-shortcuts-icon-id="' + soy.$$escapeHtml(opt_data.icon) + '">' + soy.$$escapeHtml("Project shortcut icon") + '</span>' : '') + '<span class="aui-nav-item-label">' + soy.$$escapeHtml(opt_data.name) + '</span></a>' + ((opt_data.canManage) ? '<a href="#project-shortcuts-dropdown_' + soy.$$escapeHtml(opt_data.id) + '" aria-owns="project-shortcuts-dropdown_' + soy.$$escapeHtml(opt_data.id) + '" aria-haspopup="true" class="aui-dropdown2-trigger project-shortcuts-group__actions"><span>' + soy.$$escapeHtml("Actions") + '</span></a><div id="project-shortcuts-dropdown_' + soy.$$escapeHtml(opt_data.id) + '" class="aui-dropdown2 aui-style-default project-shortcuts-group__dropdown"><ul class="aui-list-truncate"><li><a class="project-shortcuts-group__actions__edit" href="#">' + soy.$$escapeHtml("Edit") + '</a></li><li><a class="project-shortcuts-group__actions__delete  " href="#">' + soy.$$escapeHtml("Delete") + '</a></li></ul></div>' : '') + '</li>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcut.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcut';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.icon = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  var output = '';
  if (opt_data.iconsMap) {
    var id__soy83 = opt_data.iconId && opt_data.iconsMap[opt_data.iconId] ? opt_data.iconId : '1';
    output += (opt_data.iconsMap[id__soy83]) ? soy.$$escapeHtml(opt_data.iconsMap[id__soy83].className) : '';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.icon.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.icon';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcutFormFields = function(opt_data, opt_ignored) {
  return '<div class="project-shortcuts-field-group">' + aui.form.textField({name: 'project-shortcuts-url-' + opt_data.action, id: 'project-shortcuts-url-' + opt_data.action, labelContent: "Web address", placeholderText: "e.g. http://www.atlassian.com", extraClasses: 'project-shortcuts-url', value: opt_data.url ? opt_data.url : '', errorTexts: opt_data.errors.urlError ? [opt_data.errors.urlError] : []}) + '<div class="field-group project-shortcuts-name">' + aui.form.label({forField: 'project-shortcuts-name-' + opt_data.action, content: "Label"}) + '<div class="project-shortcuts-name-icon-block"><div class="project-shortcuts-icon-picker-block"></div>' + aui.form.input({name: 'project-shortcuts-name-' + opt_data.action, id: 'project-shortcuts-name-' + opt_data.action, placeholderText: "e.g. Atlassian website", extraClasses: 'project-shortcuts-name-input' + (opt_data.isWithIcon ? ' project-shortcuts-name-input-with-icon' : ''), value: opt_data.name ? opt_data.name : '', type: 'text'}) + '</div>' + ((opt_data.errors.iconError) ? aui.form.fieldError({message: opt_data.errors.iconError}) : '') + ((opt_data.errors.nameError) ? aui.form.fieldError({message: opt_data.errors.nameError}) : '') + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcutFormFields.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcutFormFields';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsPicker = function(opt_data, opt_ignored) {
  return '<span>' + JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsList(opt_data) + '</span>' + aui.dropdown2.trigger({menu: {id: 'project-shortcuts-icons-list-' + opt_data.cid}, extraClasses: 'aui-button project-shortcuts-icons-picker', iconClasses: 'aui-icon aui-icon-large  ' + soy.$$escapeHtml(opt_data.icon.className), extraAttributes: {href: '#'}});
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsPicker.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsPicker';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsList = function(opt_data, opt_ignored) {
  var output = '<div id="project-shortcuts-icons-list-' + soy.$$escapeHtml(opt_data.cid) + '" aria-hidden="true" class="aui-style-default aui-dropdown2 project-shortcuts-icons-list aui-dropdown2-section"><ul>';
  var iconList136 = opt_data.iconsList;
  var iconListLen136 = iconList136.length;
  for (var iconIndex136 = 0; iconIndex136 < iconListLen136; iconIndex136++) {
    var iconData136 = iconList136[iconIndex136];
    output += '<li><a class="project-shortcuts-icons-icon" data-project-shortcuts-icons-id="' + soy.$$escapeHtml(iconData136.name) + '"><span class="aui-icon aui-icon-large ' + soy.$$escapeHtml(iconData136.className) + '">' + soy.$$escapeHtml("Project shortcut icon") + '</span></a></li>';
  }
  output += '</ul></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsList.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsList';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.addDialog = function(opt_data, opt_ignored) {
  return '<form action="" method="post" class="aui"><h3>' + soy.$$escapeHtml("Add link") + '</h3><fieldset>' + JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcutFormFields(soy.$$augmentMap(opt_data, {action: 'add'})) + '<div class="buttons-container"><div class="buttons"><button class="aui-button project-shortcuts-submit">' + soy.$$escapeHtml("Add") + '</button><button class="aui-button aui-button-link project-shortcuts-cancel">' + soy.$$escapeHtml("Cancel") + '</button></div></div></fieldset></form>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.addDialog.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.addDialog';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialogChrome = function(opt_data, opt_ignored) {
  return '<section role="dialog" id="edit-project-shortcut-dialog" class="aui-layer aui-dialog2 aui-dialog2-small" aria-hidden="true" data-aui-remove-on-hide="true"><header class="aui-dialog2-header"><h2 class="aui-dialog2-header-main">' + soy.$$escapeHtml("Edit link") + '</h2></header></section>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialogChrome.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialogChrome';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialog = function(opt_data, opt_ignored) {
  return '<div class="aui-dialog2-content"><form class="aui" method="post">' + JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcutFormFields(soy.$$augmentMap(opt_data, {action: 'edit'})) + '<button type="submit" class="project-shortcuts-hidden-submit"></button></form></div><footer class="aui-dialog2-footer"><div class="aui-dialog2-footer-actions"><button class="aui-button aui-button-primary project-shortcuts-submit">' + soy.$$escapeHtml("Save") + '</button><button class="aui-button aui-button-link project-shortcuts-cancel">' + soy.$$escapeHtml("Cancel") + '</button></div></footer>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialog.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialog';
}


JIRA.Projects.Sidebar.ProjectShortcuts.Templates.deleteDialog = function(opt_data, opt_ignored) {
  return '<section role="dialog" id="delete-project-shortcut-dialog" class="aui-layer aui-dialog2 aui-dialog2-small" aria-hidden="true" data-aui-remove-on-hide="true"><header class="aui-dialog2-header"><h2 class="aui-dialog2-header-main">' + soy.$$escapeHtml("Delete shortcut") + '</h2></header><div class="aui-dialog2-content"><p>' + soy.$$escapeHtml("Are you sure you want to delete this shortcut?") + '</p></div><footer class="aui-dialog2-footer"><div class="aui-dialog2-footer-actions"><button class="aui-button aui-button-primary project-shortcuts-submit">' + soy.$$escapeHtml("Delete") + '</button><button class="aui-button aui-button-link project-shortcuts-cancel">' + soy.$$escapeHtml("Cancel") + '</button></div></footer></section>';
};
if (goog.DEBUG) {
  JIRA.Projects.Sidebar.ProjectShortcuts.Templates.deleteDialog.soyTemplateName = 'JIRA.Projects.Sidebar.ProjectShortcuts.Templates.deleteDialog';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/aui-sidebar-overrides.js' */
(function () {
    "use strict";
    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.SidebarOverrides");
    JIRA.Projects.Sidebar.ProjectShortcuts.SidebarOverrides.init = function () {
        // Override to sidebar so it doesn't break the DOM that is managed by Marionette.
        // This can be removed when we upgrade to AUI 5.7.900.
        var manager = AJS.sidebar('.aui-sidebar').submenus;
        manager.moveSubmenuToInlineDialog = function ($submenu) {
            this.$placeholderSubmenu = $submenu.clone(true);
            this.inlineDialog.find('.aui-navgroup-inner').append(this.$placeholderSubmenu);
            return this;
        };

        manager.restoreSubmenu = function () {
            delete this.$placeholderSubmenu;
            return this;
        };
    };
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/services/AvailableIcons.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons");
    var _iconsList = [];
    var _iconsMap = {};
    var _isWithIcons = false;

    /**
     * Class to manage set of icons that are available for user.
     * Single icon class contains unique icon name and css class which should be rendered.
     */
    JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons = {
        initialize: function(iconList) {
            _iconsList = iconList || _iconsList;
            /**
             * Fix for bug [HIROL-582] Backlog is failing to load for admin when shortcut icons are enabled
             * _.indexBy is available in underscore >= 1.5.2, using 1.4.4 currently
             */
            _iconsMap = {};
            _.each(iconList, function(element) {
                _iconsMap[element.name] = element;
            });
        },
        getIconsList: function() {
            return _iconsList;
        },

        getIconsMap: function() {
            return _iconsMap;
        },

        getAllIconsClasses: function() {
            return _.reduce(_iconsList, function(memo, current){
                return memo + current.className + " ";
            }, "");
        },

        /**
         * Return single icon class from icons set, based on icon name.
         * If icon does not exists (e.g. icons set changed or icon name is empty), returns first icon from set.
         */
        getIconFromName: function(name) {
            if (this.getIconsMap()[name]){
                return this.getIconsMap()[name];
            }
            if (this.getIconsList()[0]) {
                return this.getIconsList()[0];
            }
            return {};
        },

        setWithIcons: function(isWithIcons) {
            _isWithIcons = isWithIcons;
        },
        isWithIcons: function() {
            return _isWithIcons;
        }
    };

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/entities/Shortcut.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcut");

    function failedResponseToData(response) {
        var data;
        try {
            data = JSON.parse(response.responseText);
        } catch (e) {
            data = {
                message: "We couldnt complete the action as there seems to be a communication issue."
            };
        }

        return data;
    }

    JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcut = Backbone.Model.extend({
        defaults: {
            url: "",
            name: "",
            icon: ""
        },
        initialize: function (data, options) {
            if (!options || !options.projectKey) {
                throw "Project key is required";
            }
            this.projectKey = options.projectKey;
        },
        urlRoot: function urlRoot() {
            return AJS.contextPath() + '/rest/projects/1.0/project/' + encodeURIComponent(this.projectKey) + '/shortcut'
        },
        clear: function clear() {
            this.unset("id");
            this.set("url", this.defaults.url);
            this.set("name", this.defaults.name);
            this.set("icon", this.defaults.icon);
        },

        save: function () {
            if (this.saving == true) {
                return;
            }
            this.saving = true;
            var model = this;
            model.trigger("save:start");
            var method = this.isNew() ? "create" : "update";
            this.sync(method, model)
                .always(function requestFinished() {
                    model.saving = false;
                    model.trigger("save:finish");
                })
                .done(function requestDone(savedModel) {
                    model.set(savedModel, {silent: true});
                    JIRA.trace("jira.projects.shortcuts." + method + ".success");
                    model.trigger("save:success");
                })
                .fail(function requestFailed(response) {
                    var data = failedResponseToData(response);
                    JIRA.trace("jira.projects.shortcuts." + method + ".fail");
                    model.trigger("save:failure", data);
                });
        },
        destroy: function () {
            if (this.saving == true) {
                return;
            }
            this.saving = true;
            var model = this;
            model.trigger("remove:start");
            var result = Backbone.Model.prototype.destroy.apply(this, arguments);
            result
                .always(function () {
                    model.saving = false;
                    model.trigger("remove:finish");
                })
                .done(function requestDone() {
                    model.trigger("remove:success");
                })
                .fail(function requestFailed(response) {
                    var data = failedResponseToData(response);
                    model.trigger("remove:failure", data);
                });
            return result;
        }

    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/entities/ShortcutErrors.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Entities.ShortcutErrors");
    JIRA.Projects.Sidebar.ProjectShortcuts.Entities.ShortcutErrors = Backbone.Model.extend({
        defaults: {
            "urlError": "",
            "nameError": "",
            "iconError": "",
            "generalError": ""
        },
        initialize: function initialize(data, options) {
            var model = options.model;

            this.listenTo(model, "save:failure remove:failure", function failure(errorData) {
                this.set({
                    urlError: errorData.errors && errorData.errors.url,
                    nameError: errorData.errors && errorData.errors.name,
                    iconError: errorData.errors && errorData.errors.icon,
                    generalError: (errorData.message || (errorData.errorMessages && errorData.errorMessages.length > 0))
                        ? errorData.message || errorData.errorMessages[0]
                        : undefined
                });
            });
            this.listenTo(model, "save:success remove:success", this.clear);
        }
    });


})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/entities/Shortcuts.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcuts");

    JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcuts = Backbone.Collection.extend({
        model: JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcut,
        initialize: function(data, options) {
            this.projectKey = options.projectKey;
        }
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/views/IconPickerContent.js' */
(function ($) {
    "use strict";

    var dataIconId = 'projectShortcutsIconsId';
    var activeAUIDropdown2ElementClass = 'active aui-dropdown2-active';

    function changeIconSelectionOnKeyboardEvent(instance, event) {
        var elementsInRow = 5;

        var active = instance.ui.iconList.find('.active');
        var iconsListLength = instance.ui.iconList.find('li').size();
        var step;

        switch (event.keyCode) {
            case AJS.keyCode.LEFT:
                step = -1;
                break;
            case AJS.keyCode.RIGHT:
                step = 1;
                break;
            case AJS.keyCode.DOWN:
                step = elementsInRow;
                break;
            case AJS.keyCode.UP:
                step = -elementsInRow;
                break;
            default :
                step = 0;
        }

        var newActiveElementIndex = active.closest('li').index() + step;
        if (newActiveElementIndex < 0 || newActiveElementIndex >= iconsListLength) {
            newActiveElementIndex += iconsListLength;
            newActiveElementIndex %= iconsListLength;
        }

        active.removeClass(activeAUIDropdown2ElementClass);
        instance.ui.icon.eq(newActiveElementIndex).addClass(activeAUIDropdown2ElementClass);
    }

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Views.IconPickerContent");
    JIRA.Projects.Sidebar.ProjectShortcuts.Views.IconPickerContent = JIRA.Projects.Libs.Marionette.ItemView.extend({

        template: JIRA.Projects.Sidebar.ProjectShortcuts.Templates.iconsPicker,

        ui: {
            icon: ".project-shortcuts-icons-icon",
            iconList: ".project-shortcuts-icons-list",
            iconPicker: ".project-shortcuts-icons-picker"
        },

        modelEvents: {
            "change:icon": function changeCurrentIcon() {
                var icon = this._modelIcon();
                var children = this.ui.iconPicker.children();

                children.removeClass(this.iconFactory.getAllIconsClasses());
                children.addClass(icon.className);
                this.ui.iconPicker.data(dataIconId, icon.name);
            },

            "save:start": function saveStarted() {
                this.ui.iconPicker.attr("aria-disabled", true);
            },

            "save:finish": function saveFinish() {
                this.ui.iconPicker.attr("aria-disabled", false);
            }
        },

        events: {
            "keydown @ui.iconPicker": function pickerMovement(e) {
                if (!this.isPickerActive()) {
                    return;
                }

                switch(e.keyCode) {
                    case AJS.keyCode.LEFT:
                    case AJS.keyCode.RIGHT:
                    case AJS.keyCode.DOWN:
                    case AJS.keyCode.UP:
                        changeIconSelectionOnKeyboardEvent(this, e);
                        e.stopPropagation();
                        e.preventDefault();

                        this.ui.iconList.trigger("aui-dropdown2-item-selected");
                        break;

                    case AJS.keyCode.ESCAPE:
                        this.hideIconPicker();

                        e.stopPropagation();
                        e.preventDefault();

                        break;
                }
            }
        },

        initialize: function(options) {
            this.iconFactory = JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons;
            this.analytics = JIRA.Projects.Sidebar.ProjectShortcuts.Analytics;
        },

        onRender: function() {
            var instance = this;

            this.ui.icon.on("click", function iconClicked() {
                var iconName = $(this).data(dataIconId);

                instance.analytics.iconChangeConfirmed(instance.model, iconName);
                instance.analyticsOldIconId = '';
                instance.analyticsIconClicked = true;
                instance.model.set("icon", iconName);

                instance.ui.iconPicker.focus();
            });

            this.ui.iconList.on("aui-dropdown2-show", function () {
                instance.ui.iconPicker.focus();
                instance.analyticsIconClicked = false;
                instance.analytics.iconPickerOpened(instance.model);
            });

            this.ui.iconList.on("aui-dropdown2-hide", function() {
                instance.analytics.iconPickerClosed(instance.model, instance.analyticsIconClicked);
            });

            // analytics on icon change - include old icon
            this.analyticsOldIconId = '';
            this.ui.iconList.on("aui-dropdown2-item-selected", function(e) {
                var id = AJS.$(this).find(".active").data(dataIconId);
                if (instance.analyticsOldIconId && instance.analyticsOldIconId !== id) {
                    instance.analytics.iconChanged(instance.model, id, instance.analyticsOldIconId);
                }
                instance.analyticsOldIconId = id;
            });

            this.ui.iconPicker.data(dataIconId, this.model.get("icon"));
        },

        hideIconPicker: function() {
            if (this.isPickerActive()) {
                this.ui.iconPicker.trigger('aui-button-invoke');
            }
        },

        isPickerActive: function () {
            return this.ui.iconPicker.hasClass('active');
        },

        _modelIcon: function getIconElement() {
            return this.iconFactory.getIconFromName(this.model.get('icon'));
        },

        onFormSubmit: function setIconInModel() {
            this.model.set("icon", this.ui.iconPicker.data(dataIconId) || "");
        },

        focus: function focusOnPicker() {
            this.ui.iconPicker.focus();
        },

        serializeData: function() {
            return {
                iconsList: this.iconFactory.getIconsList(),
                icon: this._modelIcon(),
                cid: this.cid
            }
        }

    });
})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/views/DialogContent.js' */
(function ($) {
    "use strict";

    function formSubmit(e) {
        e.preventDefault();
        this.ensureProtocolPrefix();
        this.tryToAutomagicallyDeriveNameFromUrl();
        if (this.iconPickerContent) {
            this.iconPickerContent.onFormSubmit();
        }

        this.model.set("url", this.ui.url.val());
        this.model.set("name", this.ui.name.val());
        this.model.save();
    }

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent");
    JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent = JIRA.Projects.Libs.Marionette.LayoutView.extend({
        ui: {
            form: "form",
            inputs: "input, button",
            submit: ".project-shortcuts-submit",
            cancel: ".project-shortcuts-cancel",
            url: ".project-shortcuts-url input",
            name: ".project-shortcuts-name input"
        },

        regions: {
            iconPicker: ".project-shortcuts-icon-picker-block"
        },

        events: {
            "click @ui.cancel": function cancel(e) {
                e.preventDefault();
                this.model.clear();
                this.setNameAutomagically = true;
                this.errorModel.clear();
                this.trigger("cancel");
            },
            "click @ui.submit": formSubmit,
            "submit @ui.form": formSubmit,
            "blur @ui.url": function ensureProtocol() {
                this.ensureProtocolPrefix();
                this.tryToAutomagicallyDeriveNameFromUrl();
            },
            "input @ui.url": function urlChange() {
                this.model.set("url", this.ui.url.val());
                this.tryToAutomagicallyDeriveNameFromUrl();
            },
            "input @ui.name": function nameChange() {
                this.setNameAutomagically = false;
                this.model.set("name", this.ui.name.val());
            },
            "keydown @ui.name": function nameKeydown(e) {
                if (!this.iconPickerContent) return;

                // tabindex doesn't work on Mac when Full Keyboard Access is disabled
                if (e.shiftKey && e.keyCode === AJS.keyCode.TAB) {
                    e.preventDefault();
                    this.iconPickerContent.focus();
                }
            },
            "keydown @ui.url": function nameKeydown(e) {
                if (!this.iconPickerContent) return;

                // tabindex doesn't work on Mac when Full Keyboard Access is disabled
                if (!e.shiftKey && e.keyCode === AJS.keyCode.TAB) {
                    e.preventDefault();
                    this.iconPickerContent.focus();
                }
            }
        },

        modelEvents: {
            "save:start": function saveStarted() {
                this.ui.inputs.prop("disabled", true);
                this.ui.submit.addClass("loading");
                this.ui.submit.spin({className: "spinner"});
            },
            "save:finish": function saveFinish() {
                this.ui.inputs.prop("disabled", false);
                this.ui.submit.removeClass("loading");
                this.ui.submit.spinStop({className: "spinner"});
            },
            "save:failure": function renderWithErrors() {
                this.render();
                if (this.errorModel.get("generalError")) {
                    var flag = require('aui/flag');
                    flag({
                        type: "error",
                        title: "We couldn\'t save the link for you",
                        close: "auto",
                        body: this.errorModel.get("generalError")
                    });
                }
                if (this.errorModel.get("nameError")) {
                    this.ui.name.focus();
                }
                if (this.errorModel.get("urlError")) {
                    this.ui.url.focus();
                }

                return this;
            },
            "save:success": function saveSuccess() {
                this.setNameAutomagically = true;
            }
        },

        initialize: function initialize(options) {
            this.errorModel = options.errorModel;
            var currentName = this.model.get("name");
            this.setNameAutomagically = (currentName.length == 0);
            this.iconFactory = JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons;
        },

        serializeData: function serializeData() {
            return _.extend(this.model.toJSON(), {
                errors: this.errorModel.toJSON(),
                action: this.action,
                isWithIcon: this.iconFactory.isWithIcons()
            });
        },

        onRender: function () {
            if (this.iconFactory.isWithIcons()) {
                this.iconPickerContent = new JIRA.Projects.Sidebar.ProjectShortcuts.Views.IconPickerContent({
                    model: this.model,
                    action: this.action,
                    observable: this
                });

                this.getRegion("iconPicker").show(this.iconPickerContent);
            } else {
                delete this.iconPickerContent;
            }
        },

        hideIconPicker: function() {
            if (!this.iconPickerContent) return;
            
            this.iconPickerContent.hideIconPicker();
        },

        setName: function setName(name) {
            this.ui.name.val(name);
            this.model.set("name", name);
        },
        setUrl: function setUrl(url) {
            this.ui.url.val(url);
            this.model.set("url", url);
        },
        ensureProtocolPrefix: function ensureProtocolPrefix() {
            var currentUrl = this.ui.url.val().trim();
            if (currentUrl.length > 0 && !JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent.urlPattern.test(currentUrl)) {
                this.setUrl('http://' + currentUrl);
            }
        },
        tryToAutomagicallyDeriveNameFromUrl: function tryToAutomagicallyDeriveNameFromUrl() {
            var currentUrl = this.ui.url.val().trim();
            if (this.setNameAutomagically) {
                if (JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent.urlOptionalProtocolPattern.test(currentUrl)) {
                    var matches = JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent.urlOptionalProtocolPattern.exec(currentUrl);
                    this.setName(matches[3]);
                } else {
                    this.setName(currentUrl);
                }
            }
        }
    }, {
        urlPattern: /^[a-zA-Z0-9]+:(\/\/)?([^\/]*).*/,
        urlOptionalProtocolPattern: /^([a-zA-Z0-9]+:(\/\/)?)?([^\/]*).*/
    });
})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/views/AddDialogContent.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Views.AddDialogContent");
    JIRA.Projects.Sidebar.ProjectShortcuts.Views.AddDialogContent = JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent.extend({
        template: JIRA.Projects.Sidebar.ProjectShortcuts.Templates.addDialog
    });
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/views/EditDialogContent.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Views.EditDialogContent");
    JIRA.Projects.Sidebar.ProjectShortcuts.Views.EditDialogContent = JIRA.Projects.Sidebar.ProjectShortcuts.Views.DialogContent.extend({
        template: JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialog
    });
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/views/Shortcut.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Views.Shortcut");
    JIRA.Projects.Sidebar.ProjectShortcuts.Views.Shortcut = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Sidebar.ProjectShortcuts.Templates.shortcut,
        initialize: function initialize() {
            _.bindAll(this, 'toggleDropdown');
            this.iconFactory = JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons;
        },
        ui: {
            del: '.project-shortcuts-group__actions__delete',
            edit: '.project-shortcuts-group__actions__edit',
            trigger: '.project-shortcuts-group__actions',
            dropdown: '.project-shortcuts-group__dropdown',
            link: '.project-shortcuts-group__link'
        },
        modelEvents: {
            'change': 'render'
        },
        events: {
            'click @ui.link': function onLinkClick() {
                this.trigger('click:link', this.model);
            }
        },
        onRender: function() {
            var instance = this;
            this.unwrapTemplate();
            var $window = $(window);
            var $sidebarBody = $('.aui-sidebar-body');

            this.ui.edit.on('click', function onEdit(e) {
                e.preventDefault();
                instance.ui.trigger.blur();
                var editDialog = new JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Edit({
                    model: instance.model
                });
                instance.trigger('edit:open', instance.model);
                
                instance.listenToOnce(editDialog, 'dialog:close', function onDialogClosed(isSave) {
                    instance.trigger('edit:close', instance.model, isSave);
                });
            });
            this.ui.del.on('click', function onDelete(e) {
                e.preventDefault();
                instance.ui.trigger.blur();
                var deleteDialog = new JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Delete({
                    model: instance.model
                });
            });
            this.ui.dropdown.on({
                "aui-dropdown2-show": function() {
                    instance.$el.addClass('aui-nav-selected');
                    $sidebarBody.one('scroll', instance.toggleDropdown);
                    $window.one('scroll', instance.toggleDropdown);
                    // focus on trigger, so it handle all keyboard events
                    instance.ui.trigger.focus();
                },
                "aui-dropdown2-hide": function() {
                    instance.$el.removeClass('aui-nav-selected');
                    $sidebarBody.off('scroll', instance.toggleDropdown);
                    $window.off('scroll', instance.toggleDropdown);
                }
            });
        },

        serializeData: function () {
            var data = _.extend(this.model.toJSON(), {
                canManage: true,
                isWithIcon: this.iconFactory.isWithIcons()
            });
            if (this.iconFactory.isWithIcons()) {
                data = _.extend(data, {
                    iconsMap: JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons.getIconsMap()
                });
            }

            return data;
        },
        toggleDropdown: function toggleDropdown() {
            this.ui.trigger.trigger("aui-button-invoke");
        }
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/views/ShortcutsList.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Views.List");
    JIRA.Projects.Sidebar.ProjectShortcuts.Views.List = JIRA.Projects.Libs.Marionette.CompositeView.extend({
        template: JIRA.Projects.Sidebar.ProjectShortcuts.Templates.content,
        childView: JIRA.Projects.Sidebar.ProjectShortcuts.Views.Shortcut,
        ui: {
            itemsContainer: '.aui-nav',
            description: '.project-shortcuts-group__description',
            add: '.project-shortcuts-group__add'
        },
        collectionEvents: {
            /**
             * Show/hide extra description message when collection goes
             * from 0 to n items or from n to 0 items.
             */
           'add remove': function onCollectionLengthChange() {
               if (this.collection.length == 0 && this.lastCollectionLength != 0
                   || this.collection.length != 0 && this.lastCollectionLength == 0) {
                   this.lastCollectionLength = this.collection.length;
                   this.ui.description.toggleClass("hidden", this.collection.length > 0);
                   this.$el.toggleClass("project-shortcuts-group_empty", this.collection.length == 0)
               }
           }
        },
        initialize: function initialize() {
            /**
             * When sidebar is collapsed we want to hide any of the action dropdowns that
             * might be visible on the page. We do this here to attach only one event handler.
             */
            var instance = this;
            AJS.sidebar('.aui-sidebar').on('collapse-start', function hideDropdownOnSidebarCollapse() {
                instance.$(".project-shortcuts-group__actions.aui-dropdown2-active").trigger("aui-button-invoke");
            });

            this.lastCollectionLength = this.collection.length;
        },

        attachElContent: function(html) {
            var navigationGroup = new JIRA.Projects.Sidebar.Component.NavigationGroup({
                el: html
            });
            JIRA.API.Sidebar.replaceGroup(this.options.targetGroup, navigationGroup);
            this.$el = $(navigationGroup.getElement());
            return this;
        },

        onRender: function onRender() {
            var addDialog = new JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Add({
                sidebarItem: JIRA.API.Sidebar.getGroup('project-shortcuts-group').getItem('project-shortcut-add'),
                projectKey: this.collection.projectKey,
                collection: this.collection
            });
            
            this.listenTo(addDialog, "dialog:open", function propagateOpenEvent() {
                this.trigger("add:open");
            });
            this.listenTo(addDialog, "dialog:close", function propagateCloseEvent(isSave) {
                this.trigger("add:close", isSave);
            });
        },
        serializeData: function serializeData() {
            return {
                canManage: true,
                numberOfShortcuts: this.collection.length
            }
        },
        attachBuffer: function(collectionView, buffer) {
            this.ui.itemsContainer.prepend(buffer);
        },
        onAddChild: function onAddChild(childView){
            this.ui.add.parent().before(childView.$el);
        }
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/dialogs/Delete.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Delete");

    JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Delete = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Sidebar.ProjectShortcuts.Templates.deleteDialog,
        ui: {
            inputs: "input, button",
            submit: ".project-shortcuts-submit",
            cancel: ".project-shortcuts-cancel"
        },
        events: {
            "click @ui.cancel": function cancel(e) {
                e.preventDefault();
                this.dialog.hide();
            },
            "click @ui.submit": function formSubmit(e) {
                e.preventDefault();
                this.model.destroy({wait: true});
            }
        },
        modelEvents: {
            "remove:start": function removeStart() {
                this.ui.inputs.prop("disabled", true);
                this.ui.submit.addClass("loading");
                this.ui.submit.spin({className: "spinner"});
            },
            "remove:finish": function removeFinish() {
                this.ui.inputs.prop("disabled", false);
                this.ui.submit.removeClass("loading");
                this.ui.submit.spinStop({className: "spinner"});
                this.dialog.hide();
                JIRA.trace("jira.projects.shortcuts.deleted");
            },
            "remove:failure": function removeFailure(errorData) {
                if (errorData.message || (errorData.errorMessages && errorData.errorMessages.length > 0)) {
                    var flag = require('aui/flag');
                    flag({
                        type: "error",
                        title: "We couldn\'t delete the link for you",
                        close: "auto",
                        body: errorData.message || errorData.errorMessages[0]
                    });
                }
            }
        },
        initialize: function initialize() {
            this.render();
            this.$el.appendTo("body");

            this.dialog = AJS.dialog2(this.$el);
            this.dialog.show();
            var instance = this;
            this.dialog.on("hide", function() {
                _.defer(function () {
                    instance.destroy();
                });
            });
        },
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });
})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/dialogs/Edit.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Edit");

    JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Edit = JIRA.Projects.Libs.Marionette.Controller.extend({
        initialize: function(options) {
            var instance = this;
            _.bindAll(this, "hide");

            this.model = new JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcut(options.model.toJSON(), {
                projectKey: options.model.projectKey || options.model.collection.projectKey
            });
            this.errorModel = new JIRA.Projects.Sidebar.ProjectShortcuts.Entities.ShortcutErrors(undefined, {
                model: this.model
            });
            this.view = new JIRA.Projects.Sidebar.ProjectShortcuts.Views.EditDialogContent({
                model: this.model,
                errorModel: this.errorModel
            });
            this.analyticsSave = false;

            this.view.render();
            var $dialogElement = $(JIRA.Projects.Sidebar.ProjectShortcuts.Templates.editDialogChrome({}));
            this.view.$el.appendTo($dialogElement);
            this.dialog = AJS.dialog2($dialogElement);
            this.dialog.show();
            this.view.ui.url.focus();

            this._onResizeWindow = function() {
                instance.hideIconPicker();
            };
            $(window).on('resize', this._onResizeWindow);

            this.listenTo(this.view, 'cancel', this.hide);
            this.listenTo(this.model, 'save:success', function onSave() {
                this.analyticsSave = true;
                this.hide();
                options.model.set(instance.model.toJSON());
            });
            this.dialog.on("hide", function onDialogHide() {
                instance.trigger("dialog:close", instance.analyticsSave);
            });
        },

        hideIconPicker: function() {
            this.view.hideIconPicker();
        },

        hide: function hide() {
            this.dialog.hide();
            $(window).off('resize', this._onResizeWindow);
        }
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts', location = '/sidebar/project-shortcuts/dialogs/Add.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Add");

    JIRA.Projects.Sidebar.ProjectShortcuts.Dialogs.Add = JIRA.Projects.Libs.Marionette.Controller.extend({
        initialize: function(options) {
            _.bindAll(this, "hide", "refresh", "focusForm");
            var instance = this;

            this.analyticsSave = false;

            this.sidebarItem = options.sidebarItem;
            this.projectKey = options.projectKey;
            this.collection = options.collection;
            this.model = new JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcut(null, {
                projectKey: this.projectKey
            });
            this.errorModel = new JIRA.Projects.Sidebar.ProjectShortcuts.Entities.ShortcutErrors(null, {
                model: this.model
            });
            this.view = new JIRA.Projects.Sidebar.ProjectShortcuts.Views.AddDialogContent({
                model: this.model,
                errorModel: this.errorModel
            });
            this.view.render();

            var $window = $(window);
            var $document = $(document);
            var $sidebarBody = $('.aui-sidebar-body');

            this.dialog = AJS.InlineDialog(this.sidebarItem.ui.link, 'project-shortcuts-group__add-dialog',
                function(content, trigger, showPopup) {
                    instance.sidebarItem.$el.addClass('aui-nav-selected');
                    instance.view.render();
                    instance.view.$el.appendTo(content);
                    instance.view.ui.url.focus();
                    $window.on('scroll.project-shortcuts', function windowScroll() {
                        instance.refresh();
                    });
                    $sidebarBody.on('scroll.project-shortcuts', function sidebarScroll() {
                        instance.hide();
                    });

                    $document.on("showLayer", instance.focusForm);
                    $window.on("resize", instance.refresh);

                    showPopup();
                    return false;
                }, {
                    gravity: 'w',
                    autoWidth: true,
                    initCallback: function initCallback() {
                        instance.trigger("dialog:open");
                        instance.analyticsSave = false;
                    },
                    hideCallback: function hideCallback() {
                        instance.sidebarItem.$el.removeClass('aui-nav-selected');
                        instance.sidebarItem.ui.link.blur();
                        $window.off('scroll.project-shortcuts');
                        $sidebarBody.off('scroll.project-shortcuts');
                        $document.off("showLayer", instance.focusForm);

                        instance.trigger("dialog:close", instance.analyticsSave);
                    },
                    persistent: true,
                    closeOnTriggerClick: true,
                    offsetY: function offsetY(popup, targetPosition) {
                        var halfTriggerHeight = targetPosition.target.height();
                        var halfPopupHeight = popup.height() / 2;
                        return halfPopupHeight - halfTriggerHeight - 10;
                    },
                    arrowOffsetY: function arrowOffsetY(popup, targetPosition) {
                        var halfTriggerHeight = targetPosition.target.height() / 2;
                        var halfPopupHeight = popup.height() / 2;
                        return -halfPopupHeight + 22 + halfTriggerHeight;
                    }
                }
            );

            this.listenTo(this.view, 'render', this.refresh);
            this.listenTo(this.view, 'cancel', this.hideAndRender);
            this.listenTo(this.model, 'save:success', function onModelSaved() {
                var createdModel = new JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcut(this.model.toJSON(), {
                    projectKey: this.projectKey
                });
                this.model.clear();
                this.collection.add(createdModel);

                this.analyticsSave = true;
                this.hide();
            });
            this.listenTo(this.sidebarItem, 'before:select', function(e) {
                e.preventDefault();
            });

            AJS.sidebar('.aui-sidebar').on('collapse-start', this.hide);
            $('.project-shortcuts-group').on('click', 'li', this.hide);
        },
        hide: function hide() {
            this.view.hideIconPicker();
            this.dialog.hide();
        },
        refresh: function refresh() {
            this.view.hideIconPicker();
            this.dialog.refresh();
        },
        hideAndRender: function hideAndRender() {
            this.hide();
        },
        focusForm: function focusForm() {
            this.view.ui.url.focus();
        }
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts-init', location = '/sidebar/project-shortcuts/project-shortcuts-analytics.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.ProjectShortcuts.Analytics");

    var shortcutLinkSelector = "a.project-shortcuts-group__link";
    var isWithIcons = AJS.DarkFeatures.isEnabled("com.atlassian.jira.projects.ProjectCentricNavigation.ProjectShortcutIcons");

    JIRA.Projects.Sidebar.ProjectShortcuts.Analytics = {
        initialize: function(projectId) {
            this.projectId = projectId;
        },
        
        initShortcutClick: function (shortcutsElement, sidebarElement) {
            var sidebar = AJS.sidebar(sidebarElement);
            var shortcuts = AJS.$(shortcutsElement);
            var instance = this;

            shortcuts.on("click", shortcutLinkSelector, function (e) {
                var shortcutsList = shortcuts.find(shortcutLinkSelector);
                var clickedElement = AJS.$(this);

                AJS.trigger('analyticsEvent', {
                    name: "jira.projects.shortcut.clicked",
                    data: {
                        shortcutId: clickedElement.data("shortcutId"),
                        shortcutPosition: clickedElement.closest("li").index() + 1,
                        shortcutIconName: isWithIcons ? clickedElement.find(".aui-icon").data("projectShortcutsIconId") : "",
                        shortcutCount: shortcutsList.size(),
                        isWithIcons: isWithIcons,
                        isSidebarCollapsed: sidebar.isCollapsed(),
                        projectId: instance.projectId
                    }
                });
            });
        },
        
        initDialogActions: function (shortcutsList) {
            var instance = this;
            
            shortcutsList.on("childview:edit:open", function (view, model) {
                var index = model.collection.indexOf(model) + 1;
                AJS.trigger('analyticsEvent', {
                    name: "jira.projects.shortcut.edit.dialog.opened",
                    data: {
                        isWithIcons: isWithIcons,
                        shortcutId: model.get("id"),
                        shortcutPosition: index,
                        shortcutCount: model.collection.size(),
                        projectId: instance.projectId
                    }
                });
            });
            shortcutsList.on("childview:edit:close", function (view, model, save) {
                var index = model.collection.indexOf(model) + 1;
                AJS.trigger('analyticsEvent', {
                    name: "jira.projects.shortcut.edit.dialog.closed",
                    data: {
                        isWithIcons: isWithIcons,
                        isSave: save,
                        shortcutId: model.get("id"),
                        shortcutPosition: index,
                        shortcutCount: model.collection.size(),
                        projectId: instance.projectId
                    }
                });
            });
            
            shortcutsList.on("add:open", function () {
                AJS.trigger('analyticsEvent', {
                    name: "jira.projects.shortcut.add.dialog.opened",
                    data: {
                        isWithIcons: isWithIcons,
                        projectId: instance.projectId
                    }
                });
            });
            shortcutsList.on("add:close", function (save) {
                AJS.trigger('analyticsEvent', {
                    name: "jira.projects.shortcut.add.dialog.closed",
                    data: {
                        isWithIcons: isWithIcons,
                        isSave: save,
                        projectId: instance.projectId
                    }
                });            
            });
        },

        iconChanged: function (model, iconName, oldIconName) {
            AJS.trigger('analyticsEvent', {
                name: "jira.projects.shortcut.icon.changed",
                data: {
                    iconName: iconName,
                    oldIconName: oldIconName,
                    shortcutId: model.isNew() ? "" : model.get("id"),
                    isNew: model.isNew(),
                    cid: model.cid,
                    projectId: this.projectId
                }
            });
        },

        iconChangeConfirmed: function (model, iconName) {
            AJS.trigger('analyticsEvent', {
                name: "jira.projects.shortcut.icon.confirmed",
                data: {
                    oldIconName: model.get("icon"),
                    iconName: iconName,
                    shortcutId: model.isNew() ? "" : model.get("id"),
                    isNew: model.isNew(),
                    cid: model.cid,
                    projectId: this.projectId
                }
            });
        },

        iconPickerOpened: function (model) {
            AJS.trigger('analyticsEvent', {
                name: "jira.projects.shortcut.icon.picker.opened",
                data: {
                    shortcutId: model.isNew() ? "" : model.get("id"),
                    isNew: model.isNew(),
                    cid: model.cid,
                    projectId: this.projectId
                }
            });
        },

        iconPickerClosed: function (model, save) {
            AJS.trigger('analyticsEvent', {
                name: "jira.projects.shortcut.icon.picker.closed",
                data: {
                    shortcutId: model.isNew() ? "" : model.get("id"),
                    isNew: model.isNew(),
                    cid: model.cid,
                    isSave: save,
                    projectId: this.projectId
                }
            });
        }
    };
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:sidebar-project-shortcuts-init', location = '/sidebar/project-shortcuts/project-shortcuts-init.js' */
AJS.$(function ($) {
    JIRA.API.getSidebar().done(function() {

        var projectId = WRM.data.claim('com.atlassian.jira.projects.shortcuts:project-id');
        JIRA.Projects.Sidebar.ProjectShortcuts.Analytics.initialize(projectId);

        // Start everything up only if user can manage project shortcuts
        if (WRM.data.claim('com.atlassian.jira.projects.shortcuts:can-manage')) {
            JIRA.Projects.Sidebar.ProjectShortcuts.SidebarOverrides.init();

            var isWithIcons = WRM.data.claim('com.atlassian.jira.projects.shortcuts:with-icons');

            if (isWithIcons) {
                JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons.initialize(
                        WRM.data.claim('com.atlassian.jira.projects.shortcuts:icons-list'));
            }
            JIRA.Projects.Sidebar.ProjectShortcuts.Services.AvailableIcons.setWithIcons(isWithIcons);

            var projectKey = JIRA.API.Projects.getCurrentProjectKey();

            var shortcutsCollection = new JIRA.Projects.Sidebar.ProjectShortcuts.Entities.Shortcuts(
                WRM.data.claim('com.atlassian.jira.projects.shortcuts:shortcuts'),
                { projectKey: projectKey }
            );

            var shortcutsView = new JIRA.Projects.Sidebar.ProjectShortcuts.Views.List({
                collection: shortcutsCollection,
                targetGroup: 'project-shortcuts-group'
            });
            shortcutsView.render();

            JIRA.Projects.Sidebar.ProjectShortcuts.Analytics.initDialogActions(shortcutsView);
        }

        JIRA.Projects.Sidebar.ProjectShortcuts.Analytics.initShortcutClick('.project-shortcuts-list', '.aui-sidebar');
    });
});;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:summary-page-assets', location = '/page/project/summary/main.js' */
AJS.$(function ($) {
    $(".most-active-help").tooltip({aria: true});
    $(".project-meta-most-active .user-hover").mouseenter(
            function triggerEventOnEnter() {
                AJS.trigger('analyticsEvent', {
                    name: "jira.projects.mostactive.hovered",
                    data: {
                        index: $(".project-meta-most-active .user-hover").index(this)
                    }
                });
            }
    );
});;
;
/* module-key = 'com.atlassian.plugin.jslibs:backbone.paginator-2.0.2-factory', location = 'factories/backbone.paginator/2.0.2/backbone.paginator-2.0.2-factory.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
    define('atlassian/libs/factories/backbone.paginator-2.0.2', function() {
        return function(_, Backbone) {
            var env = {
                _: _,
                Backbone: Backbone
            };
            factory.call(env);
            var PageableCollection = Backbone.PageableCollection.noConflict();
            PageableCollection.VERSION = "2.0.2";
            return PageableCollection;
        }
    });
})(function(){
/////// End of Atlassian modification ///////

    /*
     backbone.paginator 2.0.2
     http://github.com/backbone-paginator/backbone.paginator

     Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
     Licensed under the MIT @license.
     */

    (function (factory) {
/////////// Modified by Atlassian ///////////
        var root = this;
        var _ = root._;
        var Backbone = root.Backbone;
/////// End of Atlassian modification ///////

        // CommonJS
        if (typeof exports == "object") {
            module.exports = factory(require("underscore"), require("backbone"));
        }
        // AMD
        else if (typeof define == "function" && define.amd) {
            define(["underscore", "backbone"], factory);
        }
        // Browser
        else if (typeof _ !== "undefined" && typeof Backbone !== "undefined") {
            var oldPageableCollection = Backbone.PageableCollection;
            var PageableCollection = factory(_,Backbone);

            /**
             __BROWSER ONLY__

             If you already have an object named `PageableCollection` attached to the
             `Backbone` module, you can use this to return a local reference to this
             Backbone.PageableCollection class and reset the name
             Backbone.PageableCollection to its previous definition.

             // The left hand side gives you a reference to this
             // Backbone.PageableCollection implementation, the right hand side
             // resets Backbone.PageableCollection to your other
             // Backbone.PageableCollection.
             var PageableCollection = Backbone.PageableCollection.noConflict();

             @static
             @member Backbone.PageableCollection
             @return {Backbone.PageableCollection}
             */
            Backbone.PageableCollection.noConflict = function () {
                Backbone.PageableCollection = oldPageableCollection;
                return PageableCollection;
            };
        }

/////////// Modified by Atlassian ///////////
    }).call(this, (function (_, Backbone)
    {
/////// End of Atlassian modification ///////

        "use strict";

        var _extend = _.extend;
        var _omit = _.omit;
        var _clone = _.clone;
        var _each = _.each;
        var _pick = _.pick;
        var _contains = _.contains;
        var _isEmpty = _.isEmpty;
        var _pairs = _.pairs;
        var _invert = _.invert;
        var _isArray = _.isArray;
        var _isFunction = _.isFunction;
        var _isObject = _.isObject;
        var _keys = _.keys;
        var _isUndefined = _.isUndefined;
        var ceil = Math.ceil;
        var floor = Math.floor;
        var max = Math.max;

        var BBColProto = Backbone.Collection.prototype;

        function finiteInt (val, name) {
            if (!_.isNumber(val) || _.isNaN(val) || !_.isFinite(val) || ~~val !== val) {
                throw new TypeError("`" + name + "` must be a finite integer");
            }
            return val;
        }

        function queryStringToParams (qs) {
            var kvp, k, v, ls, params = {}, decode = decodeURIComponent;
            var kvps = qs.split('&');
            for (var i = 0, l = kvps.length; i < l; i++) {
                var param = kvps[i];
                kvp = param.split('='), k = kvp[0], v = kvp[1] || true;
                k = decode(k), v = decode(v), ls = params[k];
                if (_isArray(ls)) ls.push(v);
                else if (ls) params[k] = [ls, v];
                else params[k] = v;
            }
            return params;
        }

        // hack to make sure the whatever event handlers for this event is run
        // before func is, and the event handlers that func will trigger.
        function runOnceAtLastHandler (col, event, func) {
            var eventHandlers = col._events[event];
            if (eventHandlers && eventHandlers.length) {
                var lastHandler = eventHandlers[eventHandlers.length - 1];
                var oldCallback = lastHandler.callback;
                lastHandler.callback = function () {
                    try {
                        oldCallback.apply(this, arguments);
                        func();
                    }
                    catch (e) {
                        throw e;
                    }
                    finally {
                        lastHandler.callback = oldCallback;
                    }
                };
            }
            else func();
        }

        var PARAM_TRIM_RE = /[\s'"]/g;
        var URL_TRIM_RE = /[<>\s'"]/g;

        /**
         Drop-in replacement for Backbone.Collection. Supports server-side and
         client-side pagination and sorting. Client-side mode also support fully
         multi-directional synchronization of changes between pages.

         @class Backbone.PageableCollection
         @extends Backbone.Collection
         */
        var PageableCollection = Backbone.PageableCollection = Backbone.Collection.extend({

            /**
             The container object to store all pagination states.

             You can override the default state by extending this class or specifying
             them in an `options` hash to the constructor.

             @property {Object} state

             @property {0|1} [state.firstPage=1] The first page index. Set to 0 if
             your server API uses 0-based indices. You should only override this value
             during extension, initialization or reset by the server after
             fetching. This value should be read only at other times.

             @property {number} [state.lastPage=null] The last page index. This value
             is __read only__ and it's calculated based on whether `firstPage` is 0 or
             1, during bootstrapping, fetching and resetting. Please don't change this
             value under any circumstances.

             @property {number} [state.currentPage=null] The current page index. You
             should only override this value during extension, initialization or reset
             by the server after fetching. This value should be read only at other
             times. Can be a 0-based or 1-based index, depending on whether
             `firstPage` is 0 or 1. If left as default, it will be set to `firstPage`
             on initialization.

             @property {number} [state.pageSize=25] How many records to show per
             page. This value is __read only__ after initialization, if you want to
             change the page size after initialization, you must call #setPageSize.

             @property {number} [state.totalPages=null] How many pages there are. This
             value is __read only__ and it is calculated from `totalRecords`.

             @property {number} [state.totalRecords=null] How many records there
             are. This value is __required__ under server mode. This value is optional
             for client mode as the number will be the same as the number of models
             during bootstrapping and during fetching, either supplied by the server
             in the metadata, or calculated from the size of the response.

             @property {string} [state.sortKey=null] The model attribute to use for
             sorting.

             @property {-1|0|1} [state.order=-1] The order to use for sorting. Specify
             -1 for ascending order or 1 for descending order. If 0, no client side
             sorting will be done and the order query parameter will not be sent to
             the server during a fetch.
             */
            state: {
                firstPage: 1,
                lastPage: null,
                currentPage: null,
                pageSize: 25,
                totalPages: null,
                totalRecords: null,
                sortKey: null,
                order: -1
            },

            /**
             @property {"server"|"client"|"infinite"} [mode="server"] The mode of
             operations for this collection. `"server"` paginates on the server-side,
             `"client"` paginates on the client-side and `"infinite"` paginates on the
             server-side for APIs that do not support `totalRecords`.
             */
            mode: "server",

            /**
             A translation map to convert Backbone.PageableCollection state attributes
             to the query parameters accepted by your server API.

             You can override the default state by extending this class or specifying
             them in `options.queryParams` object hash to the constructor.

             @property {Object} queryParams
             @property {string} [queryParams.currentPage="page"]
             @property {string} [queryParams.pageSize="per_page"]
             @property {string} [queryParams.totalPages="total_pages"]
             @property {string} [queryParams.totalRecords="total_entries"]
             @property {string} [queryParams.sortKey="sort_by"]
             @property {string} [queryParams.order="order"]
             @property {string} [queryParams.directions={"-1": "asc", "1": "desc"}] A
             map for translating a Backbone.PageableCollection#state.order constant to
             the ones your server API accepts.
             */
            queryParams: {
                currentPage: "page",
                pageSize: "per_page",
                totalPages: "total_pages",
                totalRecords: "total_entries",
                sortKey: "sort_by",
                order: "order",
                directions: {
                    "-1": "asc",
                    "1": "desc"
                }
            },

            /**
             __CLIENT MODE ONLY__

             This collection is the internal storage for the bootstrapped or fetched
             models. You can use this if you want to operate on all the pages.

             @property {Backbone.Collection} fullCollection
             */

            /**
             Given a list of models or model attributues, bootstraps the full
             collection in client mode or infinite mode, or just the page you want in
             server mode.

             If you want to initialize a collection to a different state than the
             default, you can specify them in `options.state`. Any state parameters
             supplied will be merged with the default. If you want to change the
             default mapping from #state keys to your server API's query parameter
             names, you can specifiy an object hash in `option.queryParams`. Likewise,
             any mapping provided will be merged with the default. Lastly, all
             Backbone.Collection constructor options are also accepted.

             See:

             - Backbone.PageableCollection#state
             - Backbone.PageableCollection#queryParams
             - [Backbone.Collection#initialize](http://backbonejs.org/#Collection-constructor)

             @param {Array.<Object>} [models]

             @param {Object} [options]

             @param {function(*, *): number} [options.comparator] If specified, this
             comparator is set to the current page under server mode, or the #fullCollection
             otherwise.

             @param {boolean} [options.full] If `false` and either a
             `options.comparator` or `sortKey` is defined, the comparator is attached
             to the current page. Default is `true` under client or infinite mode and
             the comparator will be attached to the #fullCollection.

             @param {Object} [options.state] The state attributes overriding the defaults.

             @param {string} [options.state.sortKey] The model attribute to use for
             sorting. If specified instead of `options.comparator`, a comparator will
             be automatically created using this value, and optionally a sorting order
             specified in `options.state.order`. The comparator is then attached to
             the new collection instance.

             @param {-1|1} [options.state.order] The order to use for sorting. Specify
             -1 for ascending order and 1 for descending order.

             @param {Object} [options.queryParam]
             */
            constructor: function (models, options) {

                BBColProto.constructor.apply(this, arguments);

                options = options || {};

                var mode = this.mode = options.mode || this.mode || PageableProto.mode;

                var queryParams = _extend({}, PageableProto.queryParams, this.queryParams,
                                options.queryParams || {});

                queryParams.directions = _extend({},
                        PageableProto.queryParams.directions,
                        this.queryParams.directions,
                                queryParams.directions || {});

                this.queryParams = queryParams;

                var state = this.state = _extend({}, PageableProto.state, this.state,
                                options.state || {});

                state.currentPage = state.currentPage == null ?
                        state.firstPage :
                        state.currentPage;

                if (!_isArray(models)) models = models ? [models] : [];
                models = models.slice();

                if (mode != "server" && state.totalRecords == null && !_isEmpty(models)) {
                    state.totalRecords = models.length;
                }

                this.switchMode(mode, _extend({fetch: false,
                    resetState: false,
                    models: models}, options));

                var comparator = options.comparator;

                if (state.sortKey && !comparator) {
                    this.setSorting(state.sortKey, state.order, options);
                }

                if (mode != "server") {
                    var fullCollection = this.fullCollection;

                    if (comparator && options.full) {
                        this.comparator = null;
                        fullCollection.comparator = comparator;
                    }

                    if (options.full) fullCollection.sort();

                    // make sure the models in the current page and full collection have the
                    // same references
                    if (models && !_isEmpty(models)) {
                        this.reset(models, _extend({silent: true}, options));
                        this.getPage(state.currentPage);
                        models.splice.apply(models, [0, models.length].concat(this.models));
                    }
                }

                this._initState = _clone(this.state);
            },

            /**
             Makes a Backbone.Collection that contains all the pages.

             @private
             @param {Array.<Object|Backbone.Model>} models
             @param {Object} options Options for Backbone.Collection constructor.
             @return {Backbone.Collection}
             */
            _makeFullCollection: function (models, options) {

                var properties = ["url", "model", "sync", "comparator"];
                var thisProto = this.constructor.prototype;
                var i, length, prop;

                var proto = {};
                for (i = 0, length = properties.length; i < length; i++) {
                    prop = properties[i];
                    if (!_isUndefined(thisProto[prop])) {
                        proto[prop] = thisProto[prop];
                    }
                }

                var fullCollection = new (Backbone.Collection.extend(proto))(models, options);

                for (i = 0, length = properties.length; i < length; i++) {
                    prop = properties[i];
                    if (this[prop] !== thisProto[prop]) {
                        fullCollection[prop] = this[prop];
                    }
                }

                return fullCollection;
            },

            /**
             Factory method that returns a Backbone event handler that responses to
             the `add`, `remove`, `reset`, and the `sort` events. The returned event
             handler will synchronize the current page collection and the full
             collection's models.

             @private

             @param {Backbone.PageableCollection} pageCol
             @param {Backbone.Collection} fullCol

             @return {function(string, Backbone.Model, Backbone.Collection, Object)}
             Collection event handler
             */
            _makeCollectionEventHandler: function (pageCol, fullCol) {

                return function collectionEventHandler (event, model, collection, options) {

                    var handlers = pageCol._handlers;
                    _each(_keys(handlers), function (event) {
                        var handler = handlers[event];
                        pageCol.off(event, handler);
                        fullCol.off(event, handler);
                    });

                    var state = _clone(pageCol.state);
                    var firstPage = state.firstPage;
                    var currentPage = firstPage === 0 ?
                            state.currentPage :
                            state.currentPage - 1;
                    var pageSize = state.pageSize;
                    var pageStart = currentPage * pageSize, pageEnd = pageStart + pageSize;

                    if (event == "add") {
                        var pageIndex, fullIndex, addAt, colToAdd, options = options || {};
                        if (collection == fullCol) {
                            fullIndex = fullCol.indexOf(model);
                            if (fullIndex >= pageStart && fullIndex < pageEnd) {
                                colToAdd = pageCol;
                                pageIndex = addAt = fullIndex - pageStart;
                            }
                        }
                        else {
                            pageIndex = pageCol.indexOf(model);
                            fullIndex = pageStart + pageIndex;
                            colToAdd = fullCol;
                            var addAt = !_isUndefined(options.at) ?
                                    options.at + pageStart :
                                    fullIndex;
                        }

                        if (!options.onRemove) {
                            ++state.totalRecords;
                            delete options.onRemove;
                        }

                        pageCol.state = pageCol._checkState(state);

                        if (colToAdd) {
                            colToAdd.add(model, _extend({}, options || {}, {at: addAt}));
                            var modelToRemove = pageIndex >= pageSize ?
                                    model :
                                            !_isUndefined(options.at) && addAt < pageEnd && pageCol.length > pageSize ?
                                    pageCol.at(pageSize) :
                                    null;
                            if (modelToRemove) {
                                runOnceAtLastHandler(collection, event, function () {
                                    pageCol.remove(modelToRemove, {onAdd: true});
                                });
                            }
                        }
                    }

                    // remove the model from the other collection as well
                    if (event == "remove") {
                        if (!options.onAdd) {
                            // decrement totalRecords and update totalPages and lastPage
                            if (!--state.totalRecords) {
                                state.totalRecords = null;
                                state.totalPages = null;
                            }
                            else {
                                var totalPages = state.totalPages = ceil(state.totalRecords / pageSize);
                                state.lastPage = firstPage === 0 ? totalPages - 1 : totalPages || firstPage;
                                if (state.currentPage > totalPages) state.currentPage = state.lastPage;
                            }
                            pageCol.state = pageCol._checkState(state);

                            var nextModel, removedIndex = options.index;
                            if (collection == pageCol) {
                                if (nextModel = fullCol.at(pageEnd)) {
                                    runOnceAtLastHandler(pageCol, event, function () {
                                        pageCol.push(nextModel, {onRemove: true});
                                    });
                                }
                                else if (!pageCol.length && state.totalRecords) {
                                    pageCol.reset(fullCol.models.slice(pageStart - pageSize, pageEnd - pageSize),
                                            _extend({}, options, {parse: false}));
                                }
                                fullCol.remove(model);
                            }
                            else if (removedIndex >= pageStart && removedIndex < pageEnd) {
                                if (nextModel = fullCol.at(pageEnd - 1)) {
                                    runOnceAtLastHandler(pageCol, event, function() {
                                        pageCol.push(nextModel, {onRemove: true});
                                    });
                                }
                                pageCol.remove(model);
                                if (!pageCol.length && state.totalRecords) {
                                    pageCol.reset(fullCol.models.slice(pageStart - pageSize, pageEnd - pageSize),
                                            _extend({}, options, {parse: false}));
                                }
                            }
                        }
                        else delete options.onAdd;
                    }

                    if (event == "reset") {
                        options = collection;
                        collection = model;

                        // Reset that's not a result of getPage
                        if (collection == pageCol && options.from == null &&
                                options.to == null) {
                            var head = fullCol.models.slice(0, pageStart);
                            var tail = fullCol.models.slice(pageStart + pageCol.models.length);
                            fullCol.reset(head.concat(pageCol.models).concat(tail), options);
                        }
                        else if (collection == fullCol) {
                            if (!(state.totalRecords = fullCol.models.length)) {
                                state.totalRecords = null;
                                state.totalPages = null;
                            }
                            if (pageCol.mode == "client") {
                                state.lastPage = state.currentPage = state.firstPage;
                            }
                            pageCol.state = pageCol._checkState(state);
                            pageCol.reset(fullCol.models.slice(pageStart, pageEnd),
                                    _extend({}, options, {parse: false}));
                        }
                    }

                    if (event == "sort") {
                        options = collection;
                        collection = model;
                        if (collection === fullCol) {
                            pageCol.reset(fullCol.models.slice(pageStart, pageEnd),
                                    _extend({}, options, {parse: false}));
                        }
                    }

                    _each(_keys(handlers), function (event) {
                        var handler = handlers[event];
                        _each([pageCol, fullCol], function (col) {
                            col.on(event, handler);
                            var callbacks = col._events[event] || [];
                            callbacks.unshift(callbacks.pop());
                        });
                    });
                };
            },

            /**
             Sanity check this collection's pagination states. Only perform checks
             when all the required pagination state values are defined and not null.
             If `totalPages` is undefined or null, it is set to `totalRecords` /
             `pageSize`. `lastPage` is set according to whether `firstPage` is 0 or 1
             when no error occurs.

             @private

             @throws {TypeError} If `totalRecords`, `pageSize`, `currentPage` or
             `firstPage` is not a finite integer.

             @throws {RangeError} If `pageSize`, `currentPage` or `firstPage` is out
             of bounds.

             @return {Object} Returns the `state` object if no error was found.
             */
            _checkState: function (state) {

                var mode = this.mode;
                var links = this.links;
                var totalRecords = state.totalRecords;
                var pageSize = state.pageSize;
                var currentPage = state.currentPage;
                var firstPage = state.firstPage;
                var totalPages = state.totalPages;

                if (totalRecords != null && pageSize != null && currentPage != null &&
                        firstPage != null && (mode == "infinite" ? links : true)) {

                    totalRecords = finiteInt(totalRecords, "totalRecords");
                    pageSize = finiteInt(pageSize, "pageSize");
                    currentPage = finiteInt(currentPage, "currentPage");
                    firstPage = finiteInt(firstPage, "firstPage");

                    if (pageSize < 1) {
                        throw new RangeError("`pageSize` must be >= 1");
                    }

                    totalPages = state.totalPages = ceil(totalRecords / pageSize);

                    if (firstPage < 0 || firstPage > 1) {
                        throw new RangeError("`firstPage must be 0 or 1`");
                    }

                    state.lastPage = firstPage === 0 ? max(0, totalPages - 1) : totalPages || firstPage;

                    if (mode == "infinite") {
                        if (!links[currentPage + '']) {
                            throw new RangeError("No link found for page " + currentPage);
                        }
                    }
                    else if (currentPage < firstPage ||
                            (totalPages > 0 &&
                                    (firstPage ? currentPage > totalPages : currentPage >= totalPages))) {
                        throw new RangeError("`currentPage` must be firstPage <= currentPage " +
                                (firstPage ? ">" : ">=") +
                                " totalPages if " + firstPage + "-based. Got " +
                                currentPage + '.');
                    }
                }

                return state;
            },

            /**
             Change the page size of this collection.

             Under most if not all circumstances, you should call this method to
             change the page size of a pageable collection because it will keep the
             pagination state sane. By default, the method will recalculate the
             current page number to one that will retain the current page's models
             when increasing the page size. When decreasing the page size, this method
             will retain the last models to the current page that will fit into the
             smaller page size.

             If `options.first` is true, changing the page size will also reset the
             current page back to the first page instead of trying to be smart.

             For server mode operations, changing the page size will trigger a #fetch
             and subsequently a `reset` event.

             For client mode operations, changing the page size will `reset` the
             current page by recalculating the current page boundary on the client
             side.

             If `options.fetch` is true, a fetch can be forced if the collection is in
             client mode.

             @param {number} pageSize The new page size to set to #state.
             @param {Object} [options] {@link #fetch} options.
             @param {boolean} [options.first=false] Reset the current page number to
             the first page if `true`.
             @param {boolean} [options.fetch] If `true`, force a fetch in client mode.

             @throws {TypeError} If `pageSize` is not a finite integer.
             @throws {RangeError} If `pageSize` is less than 1.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            setPageSize: function (pageSize, options) {
                pageSize = finiteInt(pageSize, "pageSize");

                options = options || {first: false};

                var state = this.state;
                var totalPages = ceil(state.totalRecords / pageSize);
                var currentPage = totalPages ?
                        max(state.firstPage, floor(totalPages * state.currentPage / state.totalPages)) :
                        state.firstPage;

                state = this.state = this._checkState(_extend({}, state, {
                    pageSize: pageSize,
                    currentPage: options.first ? state.firstPage : currentPage,
                    totalPages: totalPages
                }));

                return this.getPage(state.currentPage, _omit(options, ["first"]));
            },

            /**
             Switching between client, server and infinite mode.

             If switching from client to server mode, the #fullCollection is emptied
             first and then deleted and a fetch is immediately issued for the current
             page from the server. Pass `false` to `options.fetch` to skip fetching.

             If switching to infinite mode, and if `options.models` is given for an
             array of models, #links will be populated with a URL per page, using the
             default URL for this collection.

             If switching from server to client mode, all of the pages are immediately
             refetched. If you have too many pages, you can pass `false` to
             `options.fetch` to skip fetching.

             If switching to any mode from infinite mode, the #links will be deleted.

             @param {"server"|"client"|"infinite"} [mode] The mode to switch to.

             @param {Object} [options]

             @param {boolean} [options.fetch=true] If `false`, no fetching is done.

             @param {boolean} [options.resetState=true] If 'false', the state is not
             reset, but checked for sanity instead.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this if `options.fetch` is `false`.
             */
            switchMode: function (mode, options) {

                if (!_contains(["server", "client", "infinite"], mode)) {
                    throw new TypeError('`mode` must be one of "server", "client" or "infinite"');
                }

                options = options || {fetch: true, resetState: true};

                var state = this.state = options.resetState ?
                        _clone(this._initState) :
                        this._checkState(_extend({}, this.state));

                this.mode = mode;

                var self = this;
                var fullCollection = this.fullCollection;
                var handlers = this._handlers = this._handlers || {}, handler;
                if (mode != "server" && !fullCollection) {
                    fullCollection = this._makeFullCollection(options.models || [], options);
                    fullCollection.pageableCollection = this;
                    this.fullCollection = fullCollection;
                    var allHandler = this._makeCollectionEventHandler(this, fullCollection);
                    _each(["add", "remove", "reset", "sort"], function (event) {
                        handlers[event] = handler = _.bind(allHandler, {}, event);
                        self.on(event, handler);
                        fullCollection.on(event, handler);
                    });
                    fullCollection.comparator = this._fullComparator;
                }
                else if (mode == "server" && fullCollection) {
                    _each(_keys(handlers), function (event) {
                        handler = handlers[event];
                        self.off(event, handler);
                        fullCollection.off(event, handler);
                    });
                    delete this._handlers;
                    this._fullComparator = fullCollection.comparator;
                    delete this.fullCollection;
                }

                if (mode == "infinite") {
                    var links = this.links = {};
                    var firstPage = state.firstPage;
                    var totalPages = ceil(state.totalRecords / state.pageSize);
                    var lastPage = firstPage === 0 ? max(0, totalPages - 1) : totalPages || firstPage;
                    for (var i = state.firstPage; i <= lastPage; i++) {
                        links[i] = this.url;
                    }
                }
                else if (this.links) delete this.links;

                return options.fetch ?
                        this.fetch(_omit(options, "fetch", "resetState")) :
                        this;
            },

            /**
             @return {boolean} `true` if this collection can page backward, `false`
             otherwise.
             */
            hasPreviousPage: function () {
                var state = this.state;
                var currentPage = state.currentPage;
                if (this.mode != "infinite") return currentPage > state.firstPage;
                return !!this.links[currentPage - 1];
            },

            /**
             @return {boolean} `true` if this collection can page forward, `false`
             otherwise.
             */
            hasNextPage: function () {
                var state = this.state;
                var currentPage = this.state.currentPage;
                if (this.mode != "infinite") return currentPage < state.lastPage;
                return !!this.links[currentPage + 1];
            },

            /**
             Fetch the first page in server mode, or reset the current page of this
             collection to the first page in client or infinite mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getFirstPage: function (options) {
                return this.getPage("first", options);
            },

            /**
             Fetch the previous page in server mode, or reset the current page of this
             collection to the previous page in client or infinite mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getPreviousPage: function (options) {
                return this.getPage("prev", options);
            },

            /**
             Fetch the next page in server mode, or reset the current page of this
             collection to the next page in client mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getNextPage: function (options) {
                return this.getPage("next", options);
            },

            /**
             Fetch the last page in server mode, or reset the current page of this
             collection to the last page in client mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getLastPage: function (options) {
                return this.getPage("last", options);
            },

            /**
             Given a page index, set #state.currentPage to that index. If this
             collection is in server mode, fetch the page using the updated state,
             otherwise, reset the current page of this collection to the page
             specified by `index` in client mode. If `options.fetch` is true, a fetch
             can be forced in client mode before resetting the current page. Under
             infinite mode, if the index is less than the current page, a reset is
             done as in client mode. If the index is greater than the current page
             number, a fetch is made with the results **appended** to #fullCollection.
             The current page will then be reset after fetching.

             @param {number|string} index The page index to go to, or the page name to
             look up from #links in infinite mode.
             @param {Object} [options] {@link #fetch} options or
             [reset](http://backbonejs.org/#Collection-reset) options for client mode
             when `options.fetch` is `false`.
             @param {boolean} [options.fetch=false] If true, force a {@link #fetch} in
             client mode.

             @throws {TypeError} If `index` is not a finite integer under server or
             client mode, or does not yield a URL from #links under infinite mode.

             @throws {RangeError} If `index` is out of bounds.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getPage: function (index, options) {

                var mode = this.mode, fullCollection = this.fullCollection;

                options = options || {fetch: false};

                var state = this.state,
                        firstPage = state.firstPage,
                        currentPage = state.currentPage,
                        lastPage = state.lastPage,
                        pageSize = state.pageSize;

                var pageNum = index;
                switch (index) {
                    case "first": pageNum = firstPage; break;
                    case "prev": pageNum = currentPage - 1; break;
                    case "next": pageNum = currentPage + 1; break;
                    case "last": pageNum = lastPage; break;
                    default: pageNum = finiteInt(index, "index");
                }

                this.state = this._checkState(_extend({}, state, {currentPage: pageNum}));

                options.from = currentPage, options.to = pageNum;

                var pageStart = (firstPage === 0 ? pageNum : pageNum - 1) * pageSize;
                var pageModels = fullCollection && fullCollection.length ?
                        fullCollection.models.slice(pageStart, pageStart + pageSize) :
                        [];
                if ((mode == "client" || (mode == "infinite" && !_isEmpty(pageModels))) &&
                        !options.fetch) {
                    this.reset(pageModels, _omit(options, "fetch"));
                    return this;
                }

                if (mode == "infinite") options.url = this.links[pageNum];

                return this.fetch(_omit(options, "fetch"));
            },

            /**
             Fetch the page for the provided item offset in server mode, or reset the current page of this
             collection to the page for the provided item offset in client mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getPageByOffset: function (offset, options) {
                if (offset < 0) {
                    throw new RangeError("`offset must be > 0`");
                }
                offset = finiteInt(offset);

                var page = floor(offset / this.state.pageSize);
                if (this.state.firstPage !== 0) page++;
                if (page > this.state.lastPage) page = this.state.lastPage;
                return this.getPage(page, options);
            },

            /**
             Overidden to make `getPage` compatible with Zepto.

             @param {string} method
             @param {Backbone.Model|Backbone.Collection} model
             @param {Object} [options]

             @return {XMLHttpRequest}
             */
            sync: function (method, model, options) {
                var self = this;
                if (self.mode == "infinite") {
                    var success = options.success;
                    var currentPage = self.state.currentPage;
                    options.success = function (resp, status, xhr) {
                        var links = self.links;
                        var newLinks = self.parseLinks(resp, _extend({xhr: xhr}, options));
                        if (newLinks.first) links[self.state.firstPage] = newLinks.first;
                        if (newLinks.prev) links[currentPage - 1] = newLinks.prev;
                        if (newLinks.next) links[currentPage + 1] = newLinks.next;
                        if (success) success(resp, status, xhr);
                    };
                }

                return (BBColProto.sync || Backbone.sync).call(self, method, model, options);
            },

            /**
             Parse pagination links from the server response. Only valid under
             infinite mode.

             Given a response body and a XMLHttpRequest object, extract pagination
             links from them for infinite paging.

             This default implementation parses the RFC 5988 `Link` header and extract
             3 links from it - `first`, `prev`, `next`. Any subclasses overriding this
             method __must__ return an object hash having only the keys
             above. However, simply returning a `next` link or an empty hash if there
             are no more links should be enough for most implementations.

             @param {*} resp The deserialized response body.
             @param {Object} [options]
             @param {XMLHttpRequest} [options.xhr] The XMLHttpRequest object for this
             response.
             @return {Object}
             */
            parseLinks: function (resp, options) {
                var links = {};
                var linkHeader = options.xhr.getResponseHeader("Link");
                if (linkHeader) {
                    var relations = ["first", "prev", "next"];
                    _each(linkHeader.split(","), function (linkValue) {
                        var linkParts = linkValue.split(";");
                        var url = linkParts[0].replace(URL_TRIM_RE, '');
                        var params = linkParts.slice(1);
                        _each(params, function (param) {
                            var paramParts = param.split("=");
                            var key = paramParts[0].replace(PARAM_TRIM_RE, '');
                            var value = paramParts[1].replace(PARAM_TRIM_RE, '');
                            if (key == "rel" && _contains(relations, value)) links[value] = url;
                        });
                    });
                }

                return links;
            },

            /**
             Parse server response data.

             This default implementation assumes the response data is in one of two
             structures:

             [
             {}, // Your new pagination state
             [{}, ...] // An array of JSON objects
             ]

             Or,

             [{}] // An array of JSON objects

             The first structure is the preferred form because the pagination states
             may have been updated on the server side, sending them down again allows
             this collection to update its states. If the response has a pagination
             state object, it is checked for errors.

             The second structure is the
             [Backbone.Collection#parse](http://backbonejs.org/#Collection-parse)
             default.

             **Note:** this method has been further simplified since 1.1.7. While
             existing #parse implementations will continue to work, new code is
             encouraged to override #parseState and #parseRecords instead.

             @param {Object} resp The deserialized response data from the server.
             @param {Object} the options for the ajax request

             @return {Array.<Object>} An array of model objects
             */
            parse: function (resp, options) {
                var newState = this.parseState(resp, _clone(this.queryParams), _clone(this.state), options);
                if (newState) this.state = this._checkState(_extend({}, this.state, newState));
                return this.parseRecords(resp, options);
            },

            /**
             Parse server response for server pagination state updates. Not applicable
             under infinite mode.

             This default implementation first checks whether the response has any
             state object as documented in #parse. If it exists, a state object is
             returned by mapping the server state keys to this pageable collection
             instance's query parameter keys using `queryParams`.

             It is __NOT__ neccessary to return a full state object complete with all
             the mappings defined in #queryParams. Any state object resulted is merged
             with a copy of the current pageable collection state and checked for
             sanity before actually updating. Most of the time, simply providing a new
             `totalRecords` value is enough to trigger a full pagination state
             recalculation.

             parseState: function (resp, queryParams, state, options) {
                 return {totalRecords: resp.total_entries};
               }

             If you want to use header fields use:

             parseState: function (resp, queryParams, state, options) {
                   return {totalRecords: options.xhr.getResponseHeader("X-total")};
               }

             This method __MUST__ return a new state object instead of directly
             modifying the #state object. The behavior of directly modifying #state is
             undefined.

             @param {Object} resp The deserialized response data from the server.
             @param {Object} queryParams A copy of #queryParams.
             @param {Object} state A copy of #state.
             @param {Object} [options] The options passed through from
             `parse`. (backbone >= 0.9.10 only)

             @return {Object} A new (partial) state object.
             */
            parseState: function (resp, queryParams, state, options) {
                if (resp && resp.length === 2 && _isObject(resp[0]) && _isArray(resp[1])) {

                    var newState = _clone(state);
                    var serverState = resp[0];

                    _each(_pairs(_omit(queryParams, "directions")), function (kvp) {
                        var k = kvp[0], v = kvp[1];
                        var serverVal = serverState[v];
                        if (!_isUndefined(serverVal) && !_.isNull(serverVal)) newState[k] = serverState[v];
                    });

                    if (serverState.order) {
                        newState.order = _invert(queryParams.directions)[serverState.order] * 1;
                    }

                    return newState;
                }
            },

            /**
             Parse server response for an array of model objects.

             This default implementation first checks whether the response has any
             state object as documented in #parse. If it exists, the array of model
             objects is assumed to be the second element, otherwise the entire
             response is returned directly.

             @param {Object} resp The deserialized response data from the server.
             @param {Object} [options] The options passed through from the
             `parse`. (backbone >= 0.9.10 only)

             @return {Array.<Object>} An array of model objects
             */
            parseRecords: function (resp, options) {
                if (resp && resp.length === 2 && _isObject(resp[0]) && _isArray(resp[1])) {
                    return resp[1];
                }

                return resp;
            },

            /**
             Fetch a page from the server in server mode, or all the pages in client
             mode. Under infinite mode, the current page is refetched by default and
             then reset.

             The query string is constructed by translating the current pagination
             state to your server API query parameter using #queryParams. The current
             page will reset after fetch.

             @param {Object} [options] Accepts all
             [Backbone.Collection#fetch](http://backbonejs.org/#Collection-fetch)
             options.

             @return {XMLHttpRequest}
             */
            fetch: function (options) {

                options = options || {};

                var state = this._checkState(this.state);

                var mode = this.mode;

                if (mode == "infinite" && !options.url) {
                    options.url = this.links[state.currentPage];
                }

                var data = options.data || {};

                // dedup query params
                var url = options.url || this.url || "";
                if (_isFunction(url)) url = url.call(this);
                var qsi = url.indexOf('?');
                if (qsi != -1) {
                    _extend(data, queryStringToParams(url.slice(qsi + 1)));
                    url = url.slice(0, qsi);
                }

                options.url = url;
                options.data = data;

                // map params except directions
                var queryParams = this.mode == "client" ?
                        _pick(this.queryParams, "sortKey", "order") :
                        _omit(_pick(this.queryParams, _keys(PageableProto.queryParams)),
                                "directions");

                var i, kvp, k, v, kvps = _pairs(queryParams), thisCopy = _clone(this);
                for (i = 0; i < kvps.length; i++) {
                    kvp = kvps[i], k = kvp[0], v = kvp[1];
                    v = _isFunction(v) ? v.call(thisCopy) : v;
                    if (state[k] != null && v != null) {
                        data[v] = state[k];
                    }
                }

                // fix up sorting parameters
                if (state.sortKey && state.order) {
                    var o = _isFunction(queryParams.order) ?
                            queryParams.order.call(thisCopy) :
                            queryParams.order;
                    data[o] = this.queryParams.directions[state.order + ""];
                }
                else if (!state.sortKey) delete data[queryParams.order];

                // map extra query parameters
                var extraKvps = _pairs(_omit(this.queryParams,
                        _keys(PageableProto.queryParams)));
                for (i = 0; i < extraKvps.length; i++) {
                    kvp = extraKvps[i];
                    v = kvp[1];
                    v = _isFunction(v) ? v.call(thisCopy) : v;
                    if (v != null) data[kvp[0]] = v;
                }

                if (mode != "server") {
                    var self = this, fullCol = this.fullCollection;
                    var success = options.success;
                    options.success = function (col, resp, opts) {

                        // make sure the caller's intent is obeyed
                        opts = opts || {};
                        if (_isUndefined(options.silent)) delete opts.silent;
                        else opts.silent = options.silent;

                        var models = col.models;
                        if (mode == "client") fullCol.reset(models, opts);
                        else {
                            fullCol.add(models, _extend({at: fullCol.length},
                                    _extend(opts, {parse: false})));
                            self.trigger("reset", self, opts);
                        }

                        if (success) success(col, resp, opts);
                    };

                    // silent the first reset from backbone
                    return BBColProto.fetch.call(this, _extend({}, options, {silent: true}));
                }

                return BBColProto.fetch.call(this, options);
            },

            /**
             Convenient method for making a `comparator` sorted by a model attribute
             identified by `sortKey` and ordered by `order`.

             Like a Backbone.Collection, a Backbone.PageableCollection will maintain
             the __current page__ in sorted order on the client side if a `comparator`
             is attached to it. If the collection is in client mode, you can attach a
             comparator to #fullCollection to have all the pages reflect the global
             sorting order by specifying an option `full` to `true`. You __must__ call
             `sort` manually or #fullCollection.sort after calling this method to
             force a resort.

             While you can use this method to sort the current page in server mode,
             the sorting order may not reflect the global sorting order due to the
             additions or removals of the records on the server since the last
             fetch. If you want the most updated page in a global sorting order, it is
             recommended that you set #state.sortKey and optionally #state.order, and
             then call #fetch.

             @protected

             @param {string} [sortKey=this.state.sortKey] See `state.sortKey`.
             @param {number} [order=this.state.order] See `state.order`.
             @param {(function(Backbone.Model, string): Object) | string} [sortValue] See #setSorting.

             See [Backbone.Collection.comparator](http://backbonejs.org/#Collection-comparator).
             */
            _makeComparator: function (sortKey, order, sortValue) {
                var state = this.state;

                sortKey = sortKey || state.sortKey;
                order = order || state.order;

                if (!sortKey || !order) return;

                if (!sortValue) sortValue = function (model, attr) {
                    return model.get(attr);
                };

                return function (left, right) {
                    var l = sortValue(left, sortKey), r = sortValue(right, sortKey), t;
                    if (order === 1) t = l, l = r, r = t;
                    if (l === r) return 0;
                    else if (l < r) return -1;
                    return 1;
                };
            },

            /**
             Adjusts the sorting for this pageable collection.

             Given a `sortKey` and an `order`, sets `state.sortKey` and
             `state.order`. A comparator can be applied on the client side to sort in
             the order defined if `options.side` is `"client"`. By default the
             comparator is applied to the #fullCollection. Set `options.full` to
             `false` to apply a comparator to the current page under any mode. Setting
             `sortKey` to `null` removes the comparator from both the current page and
             the full collection.

             If a `sortValue` function is given, it will be passed the `(model,
             sortKey)` arguments and is used to extract a value from the model during
             comparison sorts. If `sortValue` is not given, `model.get(sortKey)` is
             used for sorting.

             @chainable

             @param {string} sortKey See `state.sortKey`.
             @param {number} [order=this.state.order] See `state.order`.
             @param {Object} [options]
             @param {"server"|"client"} [options.side] By default, `"client"` if
             `mode` is `"client"`, `"server"` otherwise.
             @param {boolean} [options.full=true]
             @param {(function(Backbone.Model, string): Object) | string} [options.sortValue]
             */
            setSorting: function (sortKey, order, options) {

                var state = this.state;

                state.sortKey = sortKey;
                state.order = order = order || state.order;

                var fullCollection = this.fullCollection;

                var delComp = false, delFullComp = false;

                if (!sortKey) delComp = delFullComp = true;

                var mode = this.mode;
                options = _extend({side: mode == "client" ? mode : "server", full: true},
                        options);

                var comparator = this._makeComparator(sortKey, order, options.sortValue);

                var full = options.full, side = options.side;

                if (side == "client") {
                    if (full) {
                        if (fullCollection) fullCollection.comparator = comparator;
                        delComp = true;
                    }
                    else {
                        this.comparator = comparator;
                        delFullComp = true;
                    }
                }
                else if (side == "server" && !full) {
                    this.comparator = comparator;
                }

                if (delComp) this.comparator = null;
                if (delFullComp && fullCollection) fullCollection.comparator = null;

                return this;
            }

        });

        var PageableProto = PageableCollection.prototype;

        return PageableCollection;

/////////// Modified by Atlassian ///////////
    }));

});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:backbone-paginator', location = '/sidebar/lib/backbone.paginator.adapter.js' */
define("jira/projects/libs/backbone.paginator", [
    "backbone",
    "underscore",
    "atlassian/libs/factories/backbone.paginator-2.0.2"
], function(Backbone, _, paginatorFactory) {
    "use strict";
    return paginatorFactory(_, Backbone);
});

AJS.namespace("Backbone.PageableCollection", null, require("jira/projects/libs/backbone.paginator"));
;
;
/* module-key = 'com.atlassian.plugin.jslibs:uri-1.14.1', location = 'libs/uri/1.14.1/uri-1.14.1.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
    define('atlassian/libs/uri-1.14.1', function() {
        var env = {};
        factory.call(env);
        return env.URI.noConflict();
    });
})(function(){
/////// End of Atlassian modification ///////

    /*!
     * URI.js - Mutating URLs
     *
     * Version: 1.14.1
     *
     * Author: Rodney Rehm
     * Web: http://medialize.github.io/URI.js/
     *
     * Licensed under
     *   MIT License http://www.opensource.org/licenses/mit-license
     *   GPL v3 http://opensource.org/licenses/GPL-3.0
     *
     */
    (function (root, factory) {
        'use strict';
        // https://github.com/umdjs/umd/blob/master/returnExports.js

        /////////// Modified by Atlassian ///////////
        //if (typeof exports === 'object') {
        //    // Node
        //    module.exports = factory(require('./punycode'), require('./IPv6'), require('./SecondLevelDomains'));
        //} else if (typeof define === 'function' && define.amd) {
        //    // AMD. Register as an anonymous module.
        //    define(['./punycode', './IPv6', './SecondLevelDomains'], factory);
        //} else {
        //    // Browser globals (root is window)
        //    root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
        //}
        // Bypassing in-library AMD
        root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
        /////// End of Atlassian modification ///////

    }(this, function (punycode, IPv6, SLD, root) {
        'use strict';
        /*global location, escape, unescape */
        // FIXME: v2.0.0 renamce non-camelCase properties to uppercase
        /*jshint camelcase: false */

        // save current URI variable, if any
        var _URI = root && root.URI;

        function URI(url, base) {
            // Allow instantiation without the 'new' keyword
            if (!(this instanceof URI)) {
                return new URI(url, base);
            }

            if (url === undefined) {
                if (typeof location !== 'undefined') {
                    url = location.href + '';
                } else {
                    url = '';
                }
            }

            this.href(url);

            // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor
            if (base !== undefined) {
                return this.absoluteTo(base);
            }

            return this;
        }

        URI.version = '1.14.1';

        var p = URI.prototype;
        var hasOwn = Object.prototype.hasOwnProperty;

        function escapeRegEx(string) {
            // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963
            return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
        }

        function getType(value) {
            // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value
            if (value === undefined) {
                return 'Undefined';
            }

            return String(Object.prototype.toString.call(value)).slice(8, -1);
        }

        function isArray(obj) {
            return getType(obj) === 'Array';
        }

        function filterArrayValues(data, value) {
            var lookup = {};
            var i, length;

            if (isArray(value)) {
                for (i = 0, length = value.length; i < length; i++) {
                    lookup[value[i]] = true;
                }
            } else {
                lookup[value] = true;
            }

            for (i = 0, length = data.length; i < length; i++) {
                if (lookup[data[i]] !== undefined) {
                    data.splice(i, 1);
                    length--;
                    i--;
                }
            }

            return data;
        }

        function arrayContains(list, value) {
            var i, length;

            // value may be string, number, array, regexp
            if (isArray(value)) {
                // Note: this can be optimized to O(n) (instead of current O(m * n))
                for (i = 0, length = value.length; i < length; i++) {
                    if (!arrayContains(list, value[i])) {
                        return false;
                    }
                }

                return true;
            }

            var _type = getType(value);
            for (i = 0, length = list.length; i < length; i++) {
                if (_type === 'RegExp') {
                    if (typeof list[i] === 'string' && list[i].match(value)) {
                        return true;
                    }
                } else if (list[i] === value) {
                    return true;
                }
            }

            return false;
        }

        function arraysEqual(one, two) {
            if (!isArray(one) || !isArray(two)) {
                return false;
            }

            // arrays can't be equal if they have different amount of content
            if (one.length !== two.length) {
                return false;
            }

            one.sort();
            two.sort();

            for (var i = 0, l = one.length; i < l; i++) {
                if (one[i] !== two[i]) {
                    return false;
                }
            }

            return true;
        }

        URI._parts = function() {
            return {
                protocol: null,
                username: null,
                password: null,
                hostname: null,
                urn: null,
                port: null,
                path: null,
                query: null,
                fragment: null,
                // state
                duplicateQueryParameters: URI.duplicateQueryParameters,
                escapeQuerySpace: URI.escapeQuerySpace
            };
        };
        // state: allow duplicate query parameters (a=1&a=1)
        URI.duplicateQueryParameters = false;
        // state: replaces + with %20 (space in query strings)
        URI.escapeQuerySpace = true;
        // static properties
        URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
        URI.idn_expression = /[^a-z0-9\.-]/i;
        URI.punycode_expression = /(xn--)/i;
        // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?
        URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
        // credits to Rich Brown
        // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096
        // specification: http://www.ietf.org/rfc/rfc4291.txt
        URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
        // expression used is "gruber revised" (@gruber v2) determined to be the
        // best solution in a regex-golf we did a couple of ages ago at
        // * http://mathiasbynens.be/demo/url-regex
        // * http://rodneyrehm.de/t/url-regex.html
        URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
        URI.findUri = {
            // valid "scheme://" or "www."
            start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
            // everything up to the next whitespace
            end: /[\s\r\n]|$/,
            // trim trailing punctuation captured by end RegExp
            trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/
        };
        // http://www.iana.org/assignments/uri-schemes.html
        // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports
        URI.defaultPorts = {
            http: '80',
            https: '443',
            ftp: '21',
            gopher: '70',
            ws: '80',
            wss: '443'
        };
        // allowed hostname characters according to RFC 3986
        // ALPHA DIGIT "-" "." "_" "~" "!" "$" "&" "'" "(" ")" "*" "+" "," ";" "=" %encoded
        // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . -
        URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/;
        // map DOM Elements to their URI attribute
        URI.domAttributes = {
            'a': 'href',
            'blockquote': 'cite',
            'link': 'href',
            'base': 'href',
            'script': 'src',
            'form': 'action',
            'img': 'src',
            'area': 'href',
            'iframe': 'src',
            'embed': 'src',
            'source': 'src',
            'track': 'src',
            'input': 'src', // but only if type="image"
            'audio': 'src',
            'video': 'src'
        };
        URI.getDomAttribute = function(node) {
            if (!node || !node.nodeName) {
                return undefined;
            }

            var nodeName = node.nodeName.toLowerCase();
            // <input> should only expose src for type="image"
            if (nodeName === 'input' && node.type !== 'image') {
                return undefined;
            }

            return URI.domAttributes[nodeName];
        };

        function escapeForDumbFirefox36(value) {
            // https://github.com/medialize/URI.js/issues/91
            return escape(value);
        }

        // encoding / decoding according to RFC3986
        function strictEncodeURIComponent(string) {
            // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent
            return encodeURIComponent(string)
                .replace(/[!'()*]/g, escapeForDumbFirefox36)
                .replace(/\*/g, '%2A');
        }
        URI.encode = strictEncodeURIComponent;
        URI.decode = decodeURIComponent;
        URI.iso8859 = function() {
            URI.encode = escape;
            URI.decode = unescape;
        };
        URI.unicode = function() {
            URI.encode = strictEncodeURIComponent;
            URI.decode = decodeURIComponent;
        };
        URI.characters = {
            pathname: {
                encode: {
                    // RFC3986 2.1: For consistency, URI producers and normalizers should
                    // use uppercase hexadecimal digits for all percent-encodings.
                    expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
                    map: {
                        // -._~!'()*
                        '%24': '$',
                        '%26': '&',
                        '%2B': '+',
                        '%2C': ',',
                        '%3B': ';',
                        '%3D': '=',
                        '%3A': ':',
                        '%40': '@'
                    }
                },
                decode: {
                    expression: /[\/\?#]/g,
                    map: {
                        '/': '%2F',
                        '?': '%3F',
                        '#': '%23'
                    }
                }
            },
            reserved: {
                encode: {
                    // RFC3986 2.1: For consistency, URI producers and normalizers should
                    // use uppercase hexadecimal digits for all percent-encodings.
                    expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
                    map: {
                        // gen-delims
                        '%3A': ':',
                        '%2F': '/',
                        '%3F': '?',
                        '%23': '#',
                        '%5B': '[',
                        '%5D': ']',
                        '%40': '@',
                        // sub-delims
                        '%21': '!',
                        '%24': '$',
                        '%26': '&',
                        '%27': '\'',
                        '%28': '(',
                        '%29': ')',
                        '%2A': '*',
                        '%2B': '+',
                        '%2C': ',',
                        '%3B': ';',
                        '%3D': '='
                    }
                }
            }
        };
        URI.encodeQuery = function(string, escapeQuerySpace) {
            var escaped = URI.encode(string + '');
            if (escapeQuerySpace === undefined) {
                escapeQuerySpace = URI.escapeQuerySpace;
            }

            return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
        };
        URI.decodeQuery = function(string, escapeQuerySpace) {
            string += '';
            if (escapeQuerySpace === undefined) {
                escapeQuerySpace = URI.escapeQuerySpace;
            }

            try {
                return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
            } catch(e) {
                // we're not going to mess with weird encodings,
                // give up and return the undecoded original string
                // see https://github.com/medialize/URI.js/issues/87
                // see https://github.com/medialize/URI.js/issues/92
                return string;
            }
        };
        URI.recodePath = function(string) {
            var segments = (string + '').split('/');
            for (var i = 0, length = segments.length; i < length; i++) {
                segments[i] = URI.encodePathSegment(URI.decode(segments[i]));
            }

            return segments.join('/');
        };
        URI.decodePath = function(string) {
            var segments = (string + '').split('/');
            for (var i = 0, length = segments.length; i < length; i++) {
                segments[i] = URI.decodePathSegment(segments[i]);
            }

            return segments.join('/');
        };
        // generate encode/decode path functions
        var _parts = {'encode':'encode', 'decode':'decode'};
        var _part;
        var generateAccessor = function(_group, _part) {
            return function(string) {
                try {
                    return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
                        return URI.characters[_group][_part].map[c];
                    });
                } catch (e) {
                    // we're not going to mess with weird encodings,
                    // give up and return the undecoded original string
                    // see https://github.com/medialize/URI.js/issues/87
                    // see https://github.com/medialize/URI.js/issues/92
                    return string;
                }
            };
        };

        for (_part in _parts) {
            URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
        }

        URI.encodeReserved = generateAccessor('reserved', 'encode');

        URI.parse = function(string, parts) {
            var pos;
            if (!parts) {
                parts = {};
            }
            // [protocol"://"[username[":"password]"@"]hostname[":"port]"/"?][path]["?"querystring]["#"fragment]

            // extract fragment
            pos = string.indexOf('#');
            if (pos > -1) {
                // escaping?
                parts.fragment = string.substring(pos + 1) || null;
                string = string.substring(0, pos);
            }

            // extract query
            pos = string.indexOf('?');
            if (pos > -1) {
                // escaping?
                parts.query = string.substring(pos + 1) || null;
                string = string.substring(0, pos);
            }

            // extract protocol
            if (string.substring(0, 2) === '//') {
                // relative-scheme
                parts.protocol = null;
                string = string.substring(2);
                // extract "user:pass@host:port"
                string = URI.parseAuthority(string, parts);
            } else {
                pos = string.indexOf(':');
                if (pos > -1) {
                    parts.protocol = string.substring(0, pos) || null;
                    if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
                        // : may be within the path
                        parts.protocol = undefined;
                    } else if (string.substring(pos + 1, pos + 3) === '//') {
                        string = string.substring(pos + 3);

                        // extract "user:pass@host:port"
                        string = URI.parseAuthority(string, parts);
                    } else {
                        string = string.substring(pos + 1);
                        parts.urn = true;
                    }
                }
            }

            // what's left must be the path
            parts.path = string;

            // and we're done
            return parts;
        };
        URI.parseHost = function(string, parts) {
            // extract host:port
            var pos = string.indexOf('/');
            var bracketPos;
            var t;

            if (pos === -1) {
                pos = string.length;
            }

            if (string.charAt(0) === '[') {
                // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6
                // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts
                // IPv6+port in the format [2001:db8::1]:80 (for the time being)
                bracketPos = string.indexOf(']');
                parts.hostname = string.substring(1, bracketPos) || null;
                parts.port = string.substring(bracketPos + 2, pos) || null;
                if (parts.port === '/') {
                    parts.port = null;
                }
            } else if (string.indexOf(':') !== string.lastIndexOf(':')) {
                // IPv6 host contains multiple colons - but no port
                // this notation is actually not allowed by RFC 3986, but we're a liberal parser
                parts.hostname = string.substring(0, pos) || null;
                parts.port = null;
            } else {
                t = string.substring(0, pos).split(':');
                parts.hostname = t[0] || null;
                parts.port = t[1] || null;
            }

            if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
                pos++;
                string = '/' + string;
            }

            return string.substring(pos) || '/';
        };
        URI.parseAuthority = function(string, parts) {
            string = URI.parseUserinfo(string, parts);
            return URI.parseHost(string, parts);
        };
        URI.parseUserinfo = function(string, parts) {
            // extract username:password
            var firstSlash = string.indexOf('/');
            var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
            var t;

            // authority@ must come before /path
            if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
                t = string.substring(0, pos).split(':');
                parts.username = t[0] ? URI.decode(t[0]) : null;
                t.shift();
                parts.password = t[0] ? URI.decode(t.join(':')) : null;
                string = string.substring(pos + 1);
            } else {
                parts.username = null;
                parts.password = null;
            }

            return string;
        };
        URI.parseQuery = function(string, escapeQuerySpace) {
            if (!string) {
                return {};
            }

            // throw out the funky business - "?"[name"="value"&"]+
            string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');

            if (!string) {
                return {};
            }

            var items = {};
            var splits = string.split('&');
            var length = splits.length;
            var v, name, value;

            for (var i = 0; i < length; i++) {
                v = splits[i].split('=');
                name = URI.decodeQuery(v.shift(), escapeQuerySpace);
                // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
                value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;

                if (hasOwn.call(items, name)) {
                    if (typeof items[name] === 'string') {
                        items[name] = [items[name]];
                    }

                    items[name].push(value);
                } else {
                    items[name] = value;
                }
            }

            return items;
        };

        URI.build = function(parts) {
            var t = '';

            if (parts.protocol) {
                t += parts.protocol + ':';
            }

            if (!parts.urn && (t || parts.hostname)) {
                t += '//';
            }

            t += (URI.buildAuthority(parts) || '');

            if (typeof parts.path === 'string') {
                if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {
                    t += '/';
                }

                t += parts.path;
            }

            if (typeof parts.query === 'string' && parts.query) {
                t += '?' + parts.query;
            }

            if (typeof parts.fragment === 'string' && parts.fragment) {
                t += '#' + parts.fragment;
            }
            return t;
        };
        URI.buildHost = function(parts) {
            var t = '';

            if (!parts.hostname) {
                return '';
            } else if (URI.ip6_expression.test(parts.hostname)) {
                t += '[' + parts.hostname + ']';
            } else {
                t += parts.hostname;
            }

            if (parts.port) {
                t += ':' + parts.port;
            }

            return t;
        };
        URI.buildAuthority = function(parts) {
            return URI.buildUserinfo(parts) + URI.buildHost(parts);
        };
        URI.buildUserinfo = function(parts) {
            var t = '';

            if (parts.username) {
                t += URI.encode(parts.username);

                if (parts.password) {
                    t += ':' + URI.encode(parts.password);
                }

                t += '@';
            }

            return t;
        };
        URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
            // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html
            // being »-._~!$&'()*+,;=:@/?« %HEX and alnum are allowed
            // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!
            // URI.js treats the query string as being application/x-www-form-urlencoded
            // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type

            var t = '';
            var unique, key, i, length;
            for (key in data) {
                if (hasOwn.call(data, key) && key) {
                    if (isArray(data[key])) {
                        unique = {};
                        for (i = 0, length = data[key].length; i < length; i++) {
                            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
                                t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
                                if (duplicateQueryParameters !== true) {
                                    unique[data[key][i] + ''] = true;
                                }
                            }
                        }
                    } else if (data[key] !== undefined) {
                        t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
                    }
                }
            }

            return t.substring(1);
        };
        URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
            // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded
            // don't append "=" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization
            return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
        };

        URI.addQuery = function(data, name, value) {
            if (typeof name === 'object') {
                for (var key in name) {
                    if (hasOwn.call(name, key)) {
                        URI.addQuery(data, key, name[key]);
                    }
                }
            } else if (typeof name === 'string') {
                if (data[name] === undefined) {
                    data[name] = value;
                    return;
                } else if (typeof data[name] === 'string') {
                    data[name] = [data[name]];
                }

                if (!isArray(value)) {
                    value = [value];
                }

                data[name] = (data[name] || []).concat(value);
            } else {
                throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
            }
        };
        URI.removeQuery = function(data, name, value) {
            var i, length, key;

            if (isArray(name)) {
                for (i = 0, length = name.length; i < length; i++) {
                    data[name[i]] = undefined;
                }
            } else if (typeof name === 'object') {
                for (key in name) {
                    if (hasOwn.call(name, key)) {
                        URI.removeQuery(data, key, name[key]);
                    }
                }
            } else if (typeof name === 'string') {
                if (value !== undefined) {
                    if (data[name] === value) {
                        data[name] = undefined;
                    } else if (isArray(data[name])) {
                        data[name] = filterArrayValues(data[name], value);
                    }
                } else {
                    data[name] = undefined;
                }
            } else {
                throw new TypeError('URI.addQuery() accepts an object, string as the first parameter');
            }
        };
        URI.hasQuery = function(data, name, value, withinArray) {
            if (typeof name === 'object') {
                for (var key in name) {
                    if (hasOwn.call(name, key)) {
                        if (!URI.hasQuery(data, key, name[key])) {
                            return false;
                        }
                    }
                }

                return true;
            } else if (typeof name !== 'string') {
                throw new TypeError('URI.hasQuery() accepts an object, string as the name parameter');
            }

            switch (getType(value)) {
                case 'Undefined':
                    // true if exists (but may be empty)
                    return name in data; // data[name] !== undefined;

                case 'Boolean':
                    // true if exists and non-empty
                    var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
                    return value === _booly;

                case 'Function':
                    // allow complex comparison
                    return !!value(data[name], name, data);

                case 'Array':
                    if (!isArray(data[name])) {
                        return false;
                    }

                    var op = withinArray ? arrayContains : arraysEqual;
                    return op(data[name], value);

                case 'RegExp':
                    if (!isArray(data[name])) {
                        return Boolean(data[name] && data[name].match(value));
                    }

                    if (!withinArray) {
                        return false;
                    }

                    return arrayContains(data[name], value);

                case 'Number':
                    value = String(value);
                /* falls through */
                case 'String':
                    if (!isArray(data[name])) {
                        return data[name] === value;
                    }

                    if (!withinArray) {
                        return false;
                    }

                    return arrayContains(data[name], value);

                default:
                    throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
            }
        };


        URI.commonPath = function(one, two) {
            var length = Math.min(one.length, two.length);
            var pos;

            // find first non-matching character
            for (pos = 0; pos < length; pos++) {
                if (one.charAt(pos) !== two.charAt(pos)) {
                    pos--;
                    break;
                }
            }

            if (pos < 1) {
                return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
            }

            // revert to last /
            if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
                pos = one.substring(0, pos).lastIndexOf('/');
            }

            return one.substring(0, pos + 1);
        };

        URI.withinString = function(string, callback, options) {
            options || (options = {});
            var _start = options.start || URI.findUri.start;
            var _end = options.end || URI.findUri.end;
            var _trim = options.trim || URI.findUri.trim;
            var _attributeOpen = /[a-z0-9-]=["']?$/i;

            _start.lastIndex = 0;
            while (true) {
                var match = _start.exec(string);
                if (!match) {
                    break;
                }

                var start = match.index;
                if (options.ignoreHtml) {
                    // attribut(e=["']?$)
                    var attributeOpen = string.slice(Math.max(start - 3, 0), start);
                    if (attributeOpen && _attributeOpen.test(attributeOpen)) {
                        continue;
                    }
                }

                var end = start + string.slice(start).search(_end);
                var slice = string.slice(start, end).replace(_trim, '');
                if (options.ignore && options.ignore.test(slice)) {
                    continue;
                }

                end = start + slice.length;
                var result = callback(slice, start, end, string);
                string = string.slice(0, start) + result + string.slice(end);
                _start.lastIndex = start + result.length;
            }

            _start.lastIndex = 0;
            return string;
        };

        URI.ensureValidHostname = function(v) {
            // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)
            // they are not part of DNS and therefore ignored by URI.js

            if (v.match(URI.invalid_hostname_characters)) {
                // test punycode
                if (!punycode) {
                    throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-] and Punycode.js is not available');
                }

                if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
                    throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
                }
            }
        };

        // noConflict
        URI.noConflict = function(removeAll) {
            if (removeAll) {
                var unconflicted = {
                    URI: this.noConflict()
                };

                if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
                    unconflicted.URITemplate = root.URITemplate.noConflict();
                }

                if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
                    unconflicted.IPv6 = root.IPv6.noConflict();
                }

                if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
                    unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
                }

                return unconflicted;
            } else if (root.URI === this) {
                root.URI = _URI;
            }

            return this;
        };

        p.build = function(deferBuild) {
            if (deferBuild === true) {
                this._deferred_build = true;
            } else if (deferBuild === undefined || this._deferred_build) {
                this._string = URI.build(this._parts);
                this._deferred_build = false;
            }

            return this;
        };

        p.clone = function() {
            return new URI(this);
        };

        p.valueOf = p.toString = function() {
            return this.build(false)._string;
        };


        function generateSimpleAccessor(_part){
            return function(v, build) {
                if (v === undefined) {
                    return this._parts[_part] || '';
                } else {
                    this._parts[_part] = v || null;
                    this.build(!build);
                    return this;
                }
            };
        }

        function generatePrefixAccessor(_part, _key){
            return function(v, build) {
                if (v === undefined) {
                    return this._parts[_part] || '';
                } else {
                    if (v !== null) {
                        v = v + '';
                        if (v.charAt(0) === _key) {
                            v = v.substring(1);
                        }
                    }

                    this._parts[_part] = v;
                    this.build(!build);
                    return this;
                }
            };
        }

        p.protocol = generateSimpleAccessor('protocol');
        p.username = generateSimpleAccessor('username');
        p.password = generateSimpleAccessor('password');
        p.hostname = generateSimpleAccessor('hostname');
        p.port = generateSimpleAccessor('port');
        p.query = generatePrefixAccessor('query', '?');
        p.fragment = generatePrefixAccessor('fragment', '#');

        p.search = function(v, build) {
            var t = this.query(v, build);
            return typeof t === 'string' && t.length ? ('?' + t) : t;
        };
        p.hash = function(v, build) {
            var t = this.fragment(v, build);
            return typeof t === 'string' && t.length ? ('#' + t) : t;
        };

        p.pathname = function(v, build) {
            if (v === undefined || v === true) {
                var res = this._parts.path || (this._parts.hostname ? '/' : '');
                return v ? URI.decodePath(res) : res;
            } else {
                this._parts.path = v ? URI.recodePath(v) : '/';
                this.build(!build);
                return this;
            }
        };
        p.path = p.pathname;
        p.href = function(href, build) {
            var key;

            if (href === undefined) {
                return this.toString();
            }

            this._string = '';
            this._parts = URI._parts();

            var _URI = href instanceof URI;
            var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
            if (href.nodeName) {
                var attribute = URI.getDomAttribute(href);
                href = href[attribute] || '';
                _object = false;
            }

            // window.location is reported to be an object, but it's not the sort
            // of object we're looking for:
            // * location.protocol ends with a colon
            // * location.query != object.search
            // * location.hash != object.fragment
            // simply serializing the unknown object should do the trick
            // (for location, not for everything...)
            if (!_URI && _object && href.pathname !== undefined) {
                href = href.toString();
            }

            if (typeof href === 'string' || href instanceof String) {
                this._parts = URI.parse(String(href), this._parts);
            } else if (_URI || _object) {
                var src = _URI ? href._parts : href;
                for (key in src) {
                    if (hasOwn.call(this._parts, key)) {
                        this._parts[key] = src[key];
                    }
                }
            } else {
                throw new TypeError('invalid input');
            }

            this.build(!build);
            return this;
        };

        // identification accessors
        p.is = function(what) {
            var ip = false;
            var ip4 = false;
            var ip6 = false;
            var name = false;
            var sld = false;
            var idn = false;
            var punycode = false;
            var relative = !this._parts.urn;

            if (this._parts.hostname) {
                relative = false;
                ip4 = URI.ip4_expression.test(this._parts.hostname);
                ip6 = URI.ip6_expression.test(this._parts.hostname);
                ip = ip4 || ip6;
                name = !ip;
                sld = name && SLD && SLD.has(this._parts.hostname);
                idn = name && URI.idn_expression.test(this._parts.hostname);
                punycode = name && URI.punycode_expression.test(this._parts.hostname);
            }

            switch (what.toLowerCase()) {
                case 'relative':
                    return relative;

                case 'absolute':
                    return !relative;

                // hostname identification
                case 'domain':
                case 'name':
                    return name;

                case 'sld':
                    return sld;

                case 'ip':
                    return ip;

                case 'ip4':
                case 'ipv4':
                case 'inet4':
                    return ip4;

                case 'ip6':
                case 'ipv6':
                case 'inet6':
                    return ip6;

                case 'idn':
                    return idn;

                case 'url':
                    return !this._parts.urn;

                case 'urn':
                    return !!this._parts.urn;

                case 'punycode':
                    return punycode;
            }

            return null;
        };

        // component specific input validation
        var _protocol = p.protocol;
        var _port = p.port;
        var _hostname = p.hostname;

        p.protocol = function(v, build) {
            if (v !== undefined) {
                if (v) {
                    // accept trailing ://
                    v = v.replace(/:(\/\/)?$/, '');

                    if (!v.match(URI.protocol_expression)) {
                        throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
                    }
                }
            }
            return _protocol.call(this, v, build);
        };
        p.scheme = p.protocol;
        p.port = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v !== undefined) {
                if (v === 0) {
                    v = null;
                }

                if (v) {
                    v += '';
                    if (v.charAt(0) === ':') {
                        v = v.substring(1);
                    }

                    if (v.match(/[^0-9]/)) {
                        throw new TypeError('Port "' + v + '" contains characters other than [0-9]');
                    }
                }
            }
            return _port.call(this, v, build);
        };
        p.hostname = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v !== undefined) {
                var x = {};
                URI.parseHost(v, x);
                v = x.hostname;
            }
            return _hostname.call(this, v, build);
        };

        // compound accessors
        p.host = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined) {
                return this._parts.hostname ? URI.buildHost(this._parts) : '';
            } else {
                URI.parseHost(v, this._parts);
                this.build(!build);
                return this;
            }
        };
        p.authority = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined) {
                return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
            } else {
                URI.parseAuthority(v, this._parts);
                this.build(!build);
                return this;
            }
        };
        p.userinfo = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined) {
                if (!this._parts.username) {
                    return '';
                }

                var t = URI.buildUserinfo(this._parts);
                return t.substring(0, t.length -1);
            } else {
                if (v[v.length-1] !== '@') {
                    v += '@';
                }

                URI.parseUserinfo(v, this._parts);
                this.build(!build);
                return this;
            }
        };
        p.resource = function(v, build) {
            var parts;

            if (v === undefined) {
                return this.path() + this.search() + this.hash();
            }

            parts = URI.parse(v);
            this._parts.path = parts.path;
            this._parts.query = parts.query;
            this._parts.fragment = parts.fragment;
            this.build(!build);
            return this;
        };

        // fraction accessors
        p.subdomain = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            // convenience, return "www" from "www.example.org"
            if (v === undefined) {
                if (!this._parts.hostname || this.is('IP')) {
                    return '';
                }

                // grab domain and add another segment
                var end = this._parts.hostname.length - this.domain().length - 1;
                return this._parts.hostname.substring(0, end) || '';
            } else {
                var e = this._parts.hostname.length - this.domain().length;
                var sub = this._parts.hostname.substring(0, e);
                var replace = new RegExp('^' + escapeRegEx(sub));

                if (v && v.charAt(v.length - 1) !== '.') {
                    v += '.';
                }

                if (v) {
                    URI.ensureValidHostname(v);
                }

                this._parts.hostname = this._parts.hostname.replace(replace, v);
                this.build(!build);
                return this;
            }
        };
        p.domain = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (typeof v === 'boolean') {
                build = v;
                v = undefined;
            }

            // convenience, return "example.org" from "www.example.org"
            if (v === undefined) {
                if (!this._parts.hostname || this.is('IP')) {
                    return '';
                }

                // if hostname consists of 1 or 2 segments, it must be the domain
                var t = this._parts.hostname.match(/\./g);
                if (t && t.length < 2) {
                    return this._parts.hostname;
                }

                // grab tld and add another segment
                var end = this._parts.hostname.length - this.tld(build).length - 1;
                end = this._parts.hostname.lastIndexOf('.', end -1) + 1;
                return this._parts.hostname.substring(end) || '';
            } else {
                if (!v) {
                    throw new TypeError('cannot set domain empty');
                }

                URI.ensureValidHostname(v);

                if (!this._parts.hostname || this.is('IP')) {
                    this._parts.hostname = v;
                } else {
                    var replace = new RegExp(escapeRegEx(this.domain()) + '$');
                    this._parts.hostname = this._parts.hostname.replace(replace, v);
                }

                this.build(!build);
                return this;
            }
        };
        p.tld = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (typeof v === 'boolean') {
                build = v;
                v = undefined;
            }

            // return "org" from "www.example.org"
            if (v === undefined) {
                if (!this._parts.hostname || this.is('IP')) {
                    return '';
                }

                var pos = this._parts.hostname.lastIndexOf('.');
                var tld = this._parts.hostname.substring(pos + 1);

                if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
                    return SLD.get(this._parts.hostname) || tld;
                }

                return tld;
            } else {
                var replace;

                if (!v) {
                    throw new TypeError('cannot set TLD empty');
                } else if (v.match(/[^a-zA-Z0-9-]/)) {
                    if (SLD && SLD.is(v)) {
                        replace = new RegExp(escapeRegEx(this.tld()) + '$');
                        this._parts.hostname = this._parts.hostname.replace(replace, v);
                    } else {
                        throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
                    }
                } else if (!this._parts.hostname || this.is('IP')) {
                    throw new ReferenceError('cannot set TLD on non-domain host');
                } else {
                    replace = new RegExp(escapeRegEx(this.tld()) + '$');
                    this._parts.hostname = this._parts.hostname.replace(replace, v);
                }

                this.build(!build);
                return this;
            }
        };
        p.directory = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined || v === true) {
                if (!this._parts.path && !this._parts.hostname) {
                    return '';
                }

                if (this._parts.path === '/') {
                    return '/';
                }

                var end = this._parts.path.length - this.filename().length - 1;
                var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');

                return v ? URI.decodePath(res) : res;

            } else {
                var e = this._parts.path.length - this.filename().length;
                var directory = this._parts.path.substring(0, e);
                var replace = new RegExp('^' + escapeRegEx(directory));

                // fully qualifier directories begin with a slash
                if (!this.is('relative')) {
                    if (!v) {
                        v = '/';
                    }

                    if (v.charAt(0) !== '/') {
                        v = '/' + v;
                    }
                }

                // directories always end with a slash
                if (v && v.charAt(v.length - 1) !== '/') {
                    v += '/';
                }

                v = URI.recodePath(v);
                this._parts.path = this._parts.path.replace(replace, v);
                this.build(!build);
                return this;
            }
        };
        p.filename = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined || v === true) {
                if (!this._parts.path || this._parts.path === '/') {
                    return '';
                }

                var pos = this._parts.path.lastIndexOf('/');
                var res = this._parts.path.substring(pos+1);

                return v ? URI.decodePathSegment(res) : res;
            } else {
                var mutatedDirectory = false;

                if (v.charAt(0) === '/') {
                    v = v.substring(1);
                }

                if (v.match(/\.?\//)) {
                    mutatedDirectory = true;
                }

                var replace = new RegExp(escapeRegEx(this.filename()) + '$');
                v = URI.recodePath(v);
                this._parts.path = this._parts.path.replace(replace, v);

                if (mutatedDirectory) {
                    this.normalizePath(build);
                } else {
                    this.build(!build);
                }

                return this;
            }
        };
        p.suffix = function(v, build) {
            if (this._parts.urn) {
                return v === undefined ? '' : this;
            }

            if (v === undefined || v === true) {
                if (!this._parts.path || this._parts.path === '/') {
                    return '';
                }

                var filename = this.filename();
                var pos = filename.lastIndexOf('.');
                var s, res;

                if (pos === -1) {
                    return '';
                }

                // suffix may only contain alnum characters (yup, I made this up.)
                s = filename.substring(pos+1);
                res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
                return v ? URI.decodePathSegment(res) : res;
            } else {
                if (v.charAt(0) === '.') {
                    v = v.substring(1);
                }

                var suffix = this.suffix();
                var replace;

                if (!suffix) {
                    if (!v) {
                        return this;
                    }

                    this._parts.path += '.' + URI.recodePath(v);
                } else if (!v) {
                    replace = new RegExp(escapeRegEx('.' + suffix) + '$');
                } else {
                    replace = new RegExp(escapeRegEx(suffix) + '$');
                }

                if (replace) {
                    v = URI.recodePath(v);
                    this._parts.path = this._parts.path.replace(replace, v);
                }

                this.build(!build);
                return this;
            }
        };
        p.segment = function(segment, v, build) {
            var separator = this._parts.urn ? ':' : '/';
            var path = this.path();
            var absolute = path.substring(0, 1) === '/';
            var segments = path.split(separator);

            if (segment !== undefined && typeof segment !== 'number') {
                build = v;
                v = segment;
                segment = undefined;
            }

            if (segment !== undefined && typeof segment !== 'number') {
                throw new Error('Bad segment "' + segment + '", must be 0-based integer');
            }

            if (absolute) {
                segments.shift();
            }

            if (segment < 0) {
                // allow negative indexes to address from the end
                segment = Math.max(segments.length + segment, 0);
            }

            if (v === undefined) {
                /*jshint laxbreak: true */
                return segment === undefined
                    ? segments
                    : segments[segment];
                /*jshint laxbreak: false */
            } else if (segment === null || segments[segment] === undefined) {
                if (isArray(v)) {
                    segments = [];
                    // collapse empty elements within array
                    for (var i=0, l=v.length; i < l; i++) {
                        if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {
                            continue;
                        }

                        if (segments.length && !segments[segments.length -1].length) {
                            segments.pop();
                        }

                        segments.push(v[i]);
                    }
                } else if (v || typeof v === 'string') {
                    if (segments[segments.length -1] === '') {
                        // empty trailing elements have to be overwritten
                        // to prevent results such as /foo//bar
                        segments[segments.length -1] = v;
                    } else {
                        segments.push(v);
                    }
                }
            } else {
                if (v) {
                    segments[segment] = v;
                } else {
                    segments.splice(segment, 1);
                }
            }

            if (absolute) {
                segments.unshift('');
            }

            return this.path(segments.join(separator), build);
        };
        p.segmentCoded = function(segment, v, build) {
            var segments, i, l;

            if (typeof segment !== 'number') {
                build = v;
                v = segment;
                segment = undefined;
            }

            if (v === undefined) {
                segments = this.segment(segment, v, build);
                if (!isArray(segments)) {
                    segments = segments !== undefined ? URI.decode(segments) : undefined;
                } else {
                    for (i = 0, l = segments.length; i < l; i++) {
                        segments[i] = URI.decode(segments[i]);
                    }
                }

                return segments;
            }

            if (!isArray(v)) {
                v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
            } else {
                for (i = 0, l = v.length; i < l; i++) {
                    v[i] = URI.decode(v[i]);
                }
            }

            return this.segment(segment, v, build);
        };

        // mutating query string
        var q = p.query;
        p.query = function(v, build) {
            if (v === true) {
                return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            } else if (typeof v === 'function') {
                var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                var result = v.call(this, data);
                this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
                this.build(!build);
                return this;
            } else if (v !== undefined && typeof v !== 'string') {
                this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
                this.build(!build);
                return this;
            } else {
                return q.call(this, v, build);
            }
        };
        p.setQuery = function(name, value, build) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);

            if (typeof name === 'string' || name instanceof String) {
                data[name] = value !== undefined ? value : null;
            } else if (typeof name === 'object') {
                for (var key in name) {
                    if (hasOwn.call(name, key)) {
                        data[key] = name[key];
                    }
                }
            } else {
                throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
            }

            this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            if (typeof name !== 'string') {
                build = value;
            }

            this.build(!build);
            return this;
        };
        p.addQuery = function(name, value, build) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            URI.addQuery(data, name, value === undefined ? null : value);
            this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            if (typeof name !== 'string') {
                build = value;
            }

            this.build(!build);
            return this;
        };
        p.removeQuery = function(name, value, build) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            URI.removeQuery(data, name, value);
            this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            if (typeof name !== 'string') {
                build = value;
            }

            this.build(!build);
            return this;
        };
        p.hasQuery = function(name, value, withinArray) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return URI.hasQuery(data, name, value, withinArray);
        };
        p.setSearch = p.setQuery;
        p.addSearch = p.addQuery;
        p.removeSearch = p.removeQuery;
        p.hasSearch = p.hasQuery;

        // sanitizing URLs
        p.normalize = function() {
            if (this._parts.urn) {
                return this
                    .normalizeProtocol(false)
                    .normalizeQuery(false)
                    .normalizeFragment(false)
                    .build();
            }

            return this
                .normalizeProtocol(false)
                .normalizeHostname(false)
                .normalizePort(false)
                .normalizePath(false)
                .normalizeQuery(false)
                .normalizeFragment(false)
                .build();
        };
        p.normalizeProtocol = function(build) {
            if (typeof this._parts.protocol === 'string') {
                this._parts.protocol = this._parts.protocol.toLowerCase();
                this.build(!build);
            }

            return this;
        };
        p.normalizeHostname = function(build) {
            if (this._parts.hostname) {
                if (this.is('IDN') && punycode) {
                    this._parts.hostname = punycode.toASCII(this._parts.hostname);
                } else if (this.is('IPv6') && IPv6) {
                    this._parts.hostname = IPv6.best(this._parts.hostname);
                }

                this._parts.hostname = this._parts.hostname.toLowerCase();
                this.build(!build);
            }

            return this;
        };
        p.normalizePort = function(build) {
            // remove port of it's the protocol's default
            if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
                this._parts.port = null;
                this.build(!build);
            }

            return this;
        };
        p.normalizePath = function(build) {
            if (this._parts.urn) {
                return this;
            }

            if (!this._parts.path || this._parts.path === '/') {
                return this;
            }

            var _was_relative;
            var _path = this._parts.path;
            var _leadingParents = '';
            var _parent, _pos;

            // handle relative paths
            if (_path.charAt(0) !== '/') {
                _was_relative = true;
                _path = '/' + _path;
            }

            // resolve simples
            _path = _path
                .replace(/(\/(\.\/)+)|(\/\.$)/g, '/')
                .replace(/\/{2,}/g, '/');

            // remember leading parents
            if (_was_relative) {
                _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
                if (_leadingParents) {
                    _leadingParents = _leadingParents[0];
                }
            }

            // resolve parents
            while (true) {
                _parent = _path.indexOf('/..');
                if (_parent === -1) {
                    // no more ../ to resolve
                    break;
                } else if (_parent === 0) {
                    // top level cannot be relative, skip it
                    _path = _path.substring(3);
                    continue;
                }

                _pos = _path.substring(0, _parent).lastIndexOf('/');
                if (_pos === -1) {
                    _pos = _parent;
                }
                _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
            }

            // revert to relative
            if (_was_relative && this.is('relative')) {
                _path = _leadingParents + _path.substring(1);
            }

            _path = URI.recodePath(_path);
            this._parts.path = _path;
            this.build(!build);
            return this;
        };
        p.normalizePathname = p.normalizePath;
        p.normalizeQuery = function(build) {
            if (typeof this._parts.query === 'string') {
                if (!this._parts.query.length) {
                    this._parts.query = null;
                } else {
                    this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
                }

                this.build(!build);
            }

            return this;
        };
        p.normalizeFragment = function(build) {
            if (!this._parts.fragment) {
                this._parts.fragment = null;
                this.build(!build);
            }

            return this;
        };
        p.normalizeSearch = p.normalizeQuery;
        p.normalizeHash = p.normalizeFragment;

        p.iso8859 = function() {
            // expect unicode input, iso8859 output
            var e = URI.encode;
            var d = URI.decode;

            URI.encode = escape;
            URI.decode = decodeURIComponent;
            this.normalize();
            URI.encode = e;
            URI.decode = d;
            return this;
        };

        p.unicode = function() {
            // expect iso8859 input, unicode output
            var e = URI.encode;
            var d = URI.decode;

            URI.encode = strictEncodeURIComponent;
            URI.decode = unescape;
            this.normalize();
            URI.encode = e;
            URI.decode = d;
            return this;
        };

        p.readable = function() {
            var uri = this.clone();
            // removing username, password, because they shouldn't be displayed according to RFC 3986
            uri.username('').password('').normalize();
            var t = '';
            if (uri._parts.protocol) {
                t += uri._parts.protocol + '://';
            }

            if (uri._parts.hostname) {
                if (uri.is('punycode') && punycode) {
                    t += punycode.toUnicode(uri._parts.hostname);
                    if (uri._parts.port) {
                        t += ':' + uri._parts.port;
                    }
                } else {
                    t += uri.host();
                }
            }

            if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
                t += '/';
            }

            t += uri.path(true);
            if (uri._parts.query) {
                var q = '';
                for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {
                    var kv = (qp[i] || '').split('=');
                    q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)
                            .replace(/&/g, '%26');

                    if (kv[1] !== undefined) {
                        q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)
                                .replace(/&/g, '%26');
                    }
                }
                t += '?' + q.substring(1);
            }

            t += URI.decodeQuery(uri.hash(), true);
            return t;
        };

        // resolving relative and absolute URLs
        p.absoluteTo = function(base) {
            var resolved = this.clone();
            var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
            var basedir, i, p;

            if (this._parts.urn) {
                throw new Error('URNs do not have any generally defined hierarchical components');
            }

            if (!(base instanceof URI)) {
                base = new URI(base);
            }

            if (!resolved._parts.protocol) {
                resolved._parts.protocol = base._parts.protocol;
            }

            if (this._parts.hostname) {
                return resolved;
            }

            for (i = 0; (p = properties[i]); i++) {
                resolved._parts[p] = base._parts[p];
            }

            if (!resolved._parts.path) {
                resolved._parts.path = base._parts.path;
                if (!resolved._parts.query) {
                    resolved._parts.query = base._parts.query;
                }
            } else if (resolved._parts.path.substring(-2) === '..') {
                resolved._parts.path += '/';
            }

            if (resolved.path().charAt(0) !== '/') {
                basedir = base.directory();
                resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
                resolved.normalizePath();
            }

            resolved.build();
            return resolved;
        };
        p.relativeTo = function(base) {
            var relative = this.clone().normalize();
            var relativeParts, baseParts, common, relativePath, basePath;

            if (relative._parts.urn) {
                throw new Error('URNs do not have any generally defined hierarchical components');
            }

            base = new URI(base).normalize();
            relativeParts = relative._parts;
            baseParts = base._parts;
            relativePath = relative.path();
            basePath = base.path();

            if (relativePath.charAt(0) !== '/') {
                throw new Error('URI is already relative');
            }

            if (basePath.charAt(0) !== '/') {
                throw new Error('Cannot calculate a URI relative to another relative URI');
            }

            if (relativeParts.protocol === baseParts.protocol) {
                relativeParts.protocol = null;
            }

            if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
                return relative.build();
            }

            if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
                return relative.build();
            }

            if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
                relativeParts.hostname = null;
                relativeParts.port = null;
            } else {
                return relative.build();
            }

            if (relativePath === basePath) {
                relativeParts.path = '';
                return relative.build();
            }

            // determine common sub path
            common = URI.commonPath(relative.path(), base.path());

            // If the paths have nothing in common, return a relative URL with the absolute path.
            if (!common) {
                return relative.build();
            }

            var parents = baseParts.path
                .substring(common.length)
                .replace(/[^\/]*$/, '')
                .replace(/.*?\//g, '../');

            relativeParts.path = parents + relativeParts.path.substring(common.length);

            return relative.build();
        };

        // comparing URIs
        p.equals = function(uri) {
            var one = this.clone();
            var two = new URI(uri);
            var one_map = {};
            var two_map = {};
            var checked = {};
            var one_query, two_query, key;

            one.normalize();
            two.normalize();

            // exact match
            if (one.toString() === two.toString()) {
                return true;
            }

            // extract query string
            one_query = one.query();
            two_query = two.query();
            one.query('');
            two.query('');

            // definitely not equal if not even non-query parts match
            if (one.toString() !== two.toString()) {
                return false;
            }

            // query parameters have the same length, even if they're permuted
            if (one_query.length !== two_query.length) {
                return false;
            }

            one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
            two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);

            for (key in one_map) {
                if (hasOwn.call(one_map, key)) {
                    if (!isArray(one_map[key])) {
                        if (one_map[key] !== two_map[key]) {
                            return false;
                        }
                    } else if (!arraysEqual(one_map[key], two_map[key])) {
                        return false;
                    }

                    checked[key] = true;
                }
            }

            for (key in two_map) {
                if (hasOwn.call(two_map, key)) {
                    if (!checked[key]) {
                        // two contains a parameter not present in one
                        return false;
                    }
                }
            }

            return true;
        };

        // state
        p.duplicateQueryParameters = function(v) {
            this._parts.duplicateQueryParameters = !!v;
            return this;
        };

        p.escapeQuerySpace = function(v) {
            this._parts.escapeQuerySpace = !!v;
            return this;
        };

        return URI;
    }));
/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.AbstractList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.AbstractList == 'undefined') { JIRA.Projects.AbstractList = {}; }
if (typeof JIRA.Projects.AbstractList.Templates == 'undefined') { JIRA.Projects.AbstractList.Templates = {}; }


JIRA.Projects.AbstractList.Templates.pagination = function(opt_data, opt_ignored) {
  var output = '<ol data-total="' + soy.$$escapeHtml(opt_data.totalPages) + '" class="aui-nav aui-nav-pagination' + ((opt_data.cssClass) ? ' ' + soy.$$escapeHtml(opt_data.cssClass) : '') + '">';
  if (opt_data.firstPage < opt_data.lastPage) {
    output += '<li class="aui-nav-previous"><a href="' + soy.$$escapeHtml(opt_data.url) + '&amp;page=' + ((opt_data.currentPage == opt_data.firstPage) ? '0' : soy.$$escapeHtml(opt_data.currentPage - 1)) + '" ' + ((opt_data.currentPage == opt_data.firstPage) ? 'aria-disabled="true"' : 'data-page="' + ((opt_data.currentPage == opt_data.firstPage) ? '0' : soy.$$escapeHtml(opt_data.currentPage - 1)) + '"') + '>' + soy.$$escapeHtml("Previous") + '</a></li>';
    var pageInit36 = opt_data.firstPage;
    var pageLimit36 = opt_data.lastPage + 1;
    for (var page36 = pageInit36; page36 < pageLimit36; page36++) {
      output += (page36 == opt_data.currentPage) ? '<li class="aui-nav-page aui-nav-selected">' + soy.$$escapeHtml(page36) + '</li>' : '<li><a href="' + soy.$$escapeHtml(opt_data.url) + '&amp;page=' + soy.$$escapeHtml(page36) + '" data-page="' + soy.$$escapeHtml(page36) + '">' + soy.$$escapeHtml(page36) + '</a></li>';
    }
    output += '<li class="aui-nav-next"><a href="' + soy.$$escapeHtml(opt_data.url) + '&amp;page=' + ((opt_data.currentPage == opt_data.lastPage) ? soy.$$escapeHtml(opt_data.lastPage) : soy.$$escapeHtml(opt_data.currentPage + 1)) + '"' + ((opt_data.currentPage == opt_data.lastPage) ? 'aria-disabled="true"' : 'data-page="' + ((opt_data.currentPage == opt_data.lastPage) ? soy.$$escapeHtml(opt_data.lastPage) : soy.$$escapeHtml(opt_data.currentPage + 1)) + '"') + '>' + soy.$$escapeHtml("Next") + '</a></li>';
  }
  output += '</ol>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.AbstractList.Templates.pagination.soyTemplateName = 'JIRA.Projects.AbstractList.Templates.pagination';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/queryStringParam.js' */
(function() {
    "use strict";

    /**
     * Get query sting param's value from the url. Optionally hash can be included in the search.
     *
     * @param name {string} The name of the parameter we're retrieving the value for.
     * @param includeHash {boolean} Whether to search for the parameter also in the hash fragment.
     *
     * @returns {string} The value of the parameter (preferring the one in the hash fragment if we're searching there, too).
     * or <tt>undefined</tt> if the parameter is not present.
     */
    function getQueryStringParam(name, includeHash, location) {
        location = location || window.location;
        if (!name) {
            return;
        }
        var params = location.search.substr(1).split('&');
        if (includeHash) {
            params = params.concat(location.hash.substr(1).split('&'));
        }
        for (var i = params.length - 1; i >= 0; i--) {
            var param = params[i].split('=');
            if (param.length != 2) continue;
            if (name === param[0]) {
                return decodeURIComponent(param[1].replace(/\+/g, " "));
            }
        }
    }

    AJS.namespace("JIRA.Projects.AbstractList.NavigationUtils");
    JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam = getQueryStringParam;
})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/NavigationUtils.js' */
(function() {
    "use strict";
    var URI = require('atlassian/libs/uri-1.14.1');

    AJS.namespace("JIRA.Projects.AbstractList.NavigationUtils");
    JIRA.Projects.AbstractList.NavigationUtils.pushStateSupported = !!history.pushState;
    JIRA.Projects.AbstractList.NavigationUtils.getBackboneHistoryRoot = function getRoot() {
        return (JIRA.Projects.AbstractList.NavigationUtils.pushStateSupported)
                ? ""
                : JIRA.Projects.AbstractList.NavigationUtils.getRoot();
    };
    JIRA.Projects.AbstractList.NavigationUtils.getRoot = function getRoot() {
        return document.location.pathname + "?selectedItem=" + JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("selectedItem");
    };
    JIRA.Projects.AbstractList.NavigationUtils.navigate = function navigate(location) {
        if (JIRA.Projects.AbstractList.NavigationUtils.pushStateSupported) {
            location = JIRA.Projects.AbstractList.NavigationUtils.getRoot() + location;
        }
        Backbone.history.navigate(location);
    };
    JIRA.Projects.AbstractList.NavigationUtils.append = function append(name, value) {
        var uri = new URI(location.href);
        uri = uri.addSearch(name, value);

        history.replaceState(null, "", uri.href());
    };
})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/FilterModel.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.AbstractList.FilterModel");
    JIRA.Projects.AbstractList.FilterModel = Backbone.Model.extend({
        filterAttributes: [],
        initialize: function initialize(options) {
            this.pageableCollection = options.pageableCollection;
            delete this.attributes.pageableCollection; // silently get rid of the set model attribute
        },
        filterCollection: function filterCollection() {
            var filtered = this.pageableCollection.originalCollection;
            this.pageableCollection.fullCollection.reset(filtered);
            this.pageableCollection.getPage("first");
        },
        navigate: function navigate() {
            JIRA.Projects.AbstractList.NavigationUtils.navigate(this.getFilterQueryStringParams());
            this.trigger("navigate");
        },
        getFilterQueryStringParams: function getFilterQueryStringParams() {
            var filter = this.filterAttributes
                    .reduce(function (previous, current) {
                        var param = this.get(current);
                        if (param) {
                            return previous + "&" + encodeURIComponent(current) + "=" + encodeURIComponent(param);
                        }
                        return previous;
                    }.bind(this), "");
            if (!JIRA.Projects.AbstractList.NavigationUtils.pushStateSupported) {
                filter = filter.substr(1)
            }
            return filter;
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/ItemModel.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.AbstractList.ItemModel");
    JIRA.Projects.AbstractList.ItemModel = Backbone.Model.extend({});

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/Layout.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.AbstractList.Layout");
    JIRA.Projects.AbstractList.Layout = JIRA.Projects.Libs.Marionette.LayoutView.extend({
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/PageableItemCollection.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.AbstractList.PageableItemCollection");
    JIRA.Projects.AbstractList.PageableItemCollection = Backbone.PageableCollection.extend({
        model: JIRA.Projects.AbstractList.ItemModel,
        initialize: function initialize(items) {
            this.originalCollection = items;
        }
    });
})();

;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/PaginationView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.AbstractList.PaginationView");
    JIRA.Projects.AbstractList.PaginationView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.AbstractList.Templates.pagination,
        ui: {
            page: "li a"
        },
        events: {
            "click @ui.page": "clickPage"
        },
        collectionEvents: {
            reset: "render"
        },
        modelEvents: {
            change: "render"
        },
        onRender: function onRender() {
            this.unwrapTemplate();
        },
        serializeData: function() {
            var url = JIRA.Projects.AbstractList.NavigationUtils.getRoot() + this.model.getFilterQueryStringParams();
            var data =_.extend({
                url: url
            }, this.collection.state);
            data.firstPage = Math.max(data.currentPage - 5, data.firstPage);
            data.totalPages = data.lastPage;
            data.lastPage = Math.min(data.currentPage + 5, data.lastPage);
            return data;
        },
        clickPage: function clickPage(e) {
            e.preventDefault();
            var pageNumber = +AJS.$(e.target).attr("data-page");
            if (pageNumber) {
                JIRA.Projects.AbstractList.NavigationUtils.navigate(this.model.getFilterQueryStringParams() + "&page=" + pageNumber);
                this.collection.getPage(pageNumber);
                this.trigger("navigate", pageNumber);
            }
        }
    });
})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:abstract-list-page', location = '/page/project/abstract-list/Router.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.AbstractList.Router");
    JIRA.Projects.AbstractList.Router = Backbone.Router.extend({
        initialize: function() {
            this.route(/(.*)/, 'any');
        },
        any: function any() {
            // Intentionally left empty, so we have an event to bind to.
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.Release.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.Release == 'undefined') { JIRA.Projects.Release = {}; }
if (typeof JIRA.Projects.Release.Templates == 'undefined') { JIRA.Projects.Release.Templates = {}; }


JIRA.Projects.Release.Templates.page = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + JIRA.Projects.Release.Templates.whatsnew(opt_data) + aui.page.pageHeader({content: '<h1>' + soy.$$escapeHtml(opt_data.releaseTitle) + '</h1>' + ((opt_data.adminLink) ? aui.page.pageHeaderActions({content: '' + aui.buttons.button({text: "Manage Versions", href: soy.$$escapeHtml("/jira") + '/' + soy.$$escapeHtml(opt_data.adminLink)})}) : ''), extraClasses: 'aui-page-header-fixed'}) + '<div id="release-page"><div id="filter-container"></div>' + aui.page.pagePanelContent({content: '<div id="content-container"></div><div id="pagination-container"></div>', extraClasses: 'aui-page-panel-content-no-table'}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.page.soyTemplateName = 'JIRA.Projects.Release.Templates.page';
}


JIRA.Projects.Release.Templates.whatsnew = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + ((opt_data.learnMoreURL) ? '<div class="whats-new-container"><div class="whats-new"><div class="logo"></div><h2>' + soy.$$escapeHtml("Get the status of a version at a glance or go deeper") + '</h2><p>' + soy.$$escapeHtml("These are the versions in your project. Hover over the progress bar for a summary or click a version to see the complete status, including the issues, development data, and potential problems.") + '</p><p><a href="' + soy.$$escapeHtml(opt_data.learnMoreURL) + '" title="' + soy.$$escapeHtml(opt_data.learnMoreTitle) + '">' + soy.$$escapeHtml("Learn more") + '</a></p></div></div>' : '');
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.whatsnew.soyTemplateName = 'JIRA.Projects.Release.Templates.whatsnew';
}


JIRA.Projects.Release.Templates.filter = function(opt_data, opt_ignored) {
  var output = '';
  var isReleasedPressed__soy43 = opt_data.status == 'all' || opt_data.status == 'released';
  var isUnreleasedPressed__soy44 = opt_data.status == 'all' || opt_data.status == 'unreleased';
  output += '<form id="version-filter" class="version-filter aui ajs-dirty-warning-exempt"><div class="version-filter-text-container"><div class="version-filter-search-container ' + ((opt_data.contains) ? 'version-filter-search-opened' : '') + '"><input type="text" id="version-filter-text" class="version-filter-text text" value="' + soy.$$escapeHtml(opt_data.contains) + '" /><span class="aui-icon aui-icon-small aui-iconfont-search-small"></span></div><div class="version-filter-status-text" title="' + soy.$$escapeHtml("Use Quick Filters to view a subset of versions.") + '">' + soy.$$escapeHtml("Quick filters:") + '</div></div><div class="version-filter-status-container">' + JIRA.Projects.Release.Templates.button({buttonName: 'released', isPressed: isReleasedPressed__soy43, text: "Released"}) + JIRA.Projects.Release.Templates.button({buttonName: 'unreleased', isPressed: isUnreleasedPressed__soy44, text: "Unreleased"}) + '</div></form>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.filter.soyTemplateName = 'JIRA.Projects.Release.Templates.filter';
}


JIRA.Projects.Release.Templates.button = function(opt_data, opt_ignored) {
  return '<a class="version-filter-status-' + soy.$$escapeHtml(opt_data.buttonName) + ' version-filter-status-button ' + ((opt_data.isPressed) ? 'version-filter-status-pressed' : '') + '" href="#" data-version-type="' + soy.$$escapeHtml(opt_data.buttonName) + '">' + soy.$$escapeHtml(opt_data.text) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.button.soyTemplateName = 'JIRA.Projects.Release.Templates.button';
}


JIRA.Projects.Release.Templates.table = function(opt_data, opt_ignored) {
  return '' + aui.table({extraClasses: 'versions-table', theadContent: '<tr><th>' + soy.$$escapeHtml("Version") + '</th><th>' + soy.$$escapeHtml("Status") + '</th><th>' + soy.$$escapeHtml("Progress") + '</th><th class="versions-table__date">' + soy.$$escapeHtml("Start date") + '</th><th class="versions-table__date">' + soy.$$escapeHtml("Release date") + '</th><th>' + soy.$$escapeHtml("Description") + '</th></tr>', content: '', cssClass: 'versions-table', id: 'versions-table'});
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.table.soyTemplateName = 'JIRA.Projects.Release.Templates.table';
}


JIRA.Projects.Release.Templates.row = function(opt_data, opt_ignored) {
  return '<tr><td class="versions-table__name">' + ((opt_data.url) ? '<a href="' + soy.$$escapeHtml(opt_data.url) + '">' + soy.$$escapeHtml(opt_data.name) + '</a>' : soy.$$escapeHtml(opt_data.name)) + '</td><td class="versions-table__status">' + ((opt_data.released) ? aui.lozenges.lozenge({text: "Released", type: 'success', isSubtle: true}) : aui.lozenges.lozenge({text: "Unreleased", type: 'current', isSubtle: true})) + '</td><td class="versions-table__progress">' + JIRA.Projects.Release.Templates.status(opt_data.status) + '</td><td class="versions-table__date">' + JIRA.Projects.Release.Templates.date(opt_data.startDate) + '</td><td class="versions-table__date">' + JIRA.Projects.Release.Templates.date(opt_data.releaseDate) + '</td><td class="versions-table__description">' + soy.$$escapeHtml(opt_data.description) + '</td></tr>';
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.row.soyTemplateName = 'JIRA.Projects.Release.Templates.row';
}


JIRA.Projects.Release.Templates.emptyRow = function(opt_data, opt_ignored) {
  return '<tr class="versions-table__row-empty"><td colspan="6"><div class="jira-adbox jira-adbox-medium no-results"><h3>' + soy.$$escapeHtml("No versions were found that match your search") + '</h3><p class="no-results-hint">' + soy.$$escapeHtml("Try modifying your filter criteria.") + '</p></div></td></tr>';
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.emptyRow.soyTemplateName = 'JIRA.Projects.Release.Templates.emptyRow';
}


JIRA.Projects.Release.Templates.status = function(opt_data, opt_ignored) {
  var output = '';
  var totalCount__soy137 = opt_data.unmapped.count + opt_data.toDo.count + opt_data.inProgress.count + opt_data.complete.count;
  output += '<div class="progressbar-container">' + ((totalCount__soy137) ? '<div class="progressbar progressbar_full">' + JIRA.Projects.Release.Templates.progressBarEntry({entry: opt_data.complete, totalCount: totalCount__soy137, type: 'complete', name: "Done"}) + JIRA.Projects.Release.Templates.progressBarEntry({entry: opt_data.inProgress, totalCount: totalCount__soy137, type: 'in-progress', name: "In Progress"}) + JIRA.Projects.Release.Templates.progressBarEntry({entry: opt_data.toDo, totalCount: totalCount__soy137, type: 'to-do', name: "To Do"}) + JIRA.Projects.Release.Templates.progressBarEntry({entry: opt_data.unmapped, totalCount: totalCount__soy137, type: 'undefined', name: "No Category"}) + '</div>' : soy.$$escapeHtml("No issues")) + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.status.soyTemplateName = 'JIRA.Projects.Release.Templates.status';
}


JIRA.Projects.Release.Templates.progressBarEntry = function(opt_data, opt_ignored) {
  var output = '';
  var percentage__soy167 = opt_data.entry.count / opt_data.totalCount * 100;
  output += (percentage__soy167) ? '<div class="progressbar__entry progressbar__entry progressbar__entry progressbar__entry_' + soy.$$escapeHtml(opt_data.type) + '" data-type="' + soy.$$escapeHtml(opt_data.type) + '" data-title="' + soy.$$escapeHtml(opt_data.name) + '" data-count="' + soy.$$escapeHtml(opt_data.entry.count) + '" data-url="' + soy.$$escapeHtml(opt_data.entry.jqlUrl) + '" style="width: ' + soy.$$escapeHtml(percentage__soy167) + '%"></div>' : '';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.progressBarEntry.soyTemplateName = 'JIRA.Projects.Release.Templates.progressBarEntry';
}


JIRA.Projects.Release.Templates.progressBarDialog = function(opt_data, opt_ignored) {
  var output = '<div class="progress-statuses">' + soy.$$escapeHtml("Version") + ': ' + soy.$$escapeHtml(opt_data.name) + '<br />' + soy.$$escapeHtml(AJS.format("{0,choice,0#{0} issues|1#{0} issue|1\x3c{0} issues} in total",opt_data.totalCount)) + '<br /><table class="progress-statuses__table"><tbody>';
  var entryList191 = opt_data.entries;
  var entryListLen191 = entryList191.length;
  for (var entryIndex191 = 0; entryIndex191 < entryListLen191; entryIndex191++) {
    var entryData191 = entryList191[entryIndex191];
    output += '<tr><td>' + soy.$$escapeHtml(entryData191.name) + '</td><td><a href="' + soy.$$escapeHtml(entryData191.url) + '">' + aui.badges.badge({text: entryData191.count, extraClasses: 'progress-statuses__table__badge progress-statuses__table__badge_' + soy.$$escapeHtml(entryData191.type)}) + '</a></td></tr>';
  }
  output += '</tbody><tfoot><td colspan="2"><a href="' + soy.$$escapeHtml(opt_data.url) + '">' + soy.$$escapeHtml("All issues") + '</a></td></tfoot></table></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.progressBarDialog.soyTemplateName = 'JIRA.Projects.Release.Templates.progressBarDialog';
}


JIRA.Projects.Release.Templates.date = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + ((opt_data.formatted) ? '<time class="date" datetime="' + soy.$$escapeHtml(opt_data.iso) + '">' + soy.$$escapeHtml(opt_data.formatted) + '</time>' : '');
};
if (goog.DEBUG) {
  JIRA.Projects.Release.Templates.date.soyTemplateName = 'JIRA.Projects.Release.Templates.date';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/FilterModel.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Release.FilterModel");
    JIRA.Projects.Release.FilterModel = JIRA.Projects.AbstractList.FilterModel.extend({
        filterAttributes: ['status', 'contains'],
        defaults: {
            status: "unreleased",
            contains: ""
        },
        initialize: function initialize(options) {
            JIRA.Projects.AbstractList.FilterModel.prototype.initialize.call(this, options);

            this.on("change:status change:contains", this.filterCollection);
            this.on("change:status change:contains", this.navigate);
        },
        filterCollection: function filterCollection() {
            var status = this.get("status") || "no-filter";
            var filtered = this.pageableCollection.originalCollection;
            if (status !== "all" && status !== "no-filter") {
                filtered = filtered.filter(function filterByStatus(arrayElement) {
                    return ((status === "released" && arrayElement.released) || (status === "unreleased" && !arrayElement.released));
                });
            }

            var contains = (this.get("contains") || "").toLowerCase();
            if (contains !== "") {
                filtered = filtered.filter(function filterText(arrayElement) {
                    return (
                        arrayElement.name.toLowerCase().indexOf(contains) > -1 ||
                        arrayElement.description.toLowerCase().indexOf(contains) > -1 ||
                        arrayElement.startDate.formatted.toLowerCase().indexOf(contains) > -1 ||
                        arrayElement.releaseDate.formatted.toLowerCase().indexOf(contains) > -1
                    );
                });
            }
            this.pageableCollection.fullCollection.reset(filtered);
            this.pageableCollection.getPage("first");
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/FilterView.js' */
define("jira/projects/page/release/view/filter", [
    "jira/projects/libs/marionette",
    "underscore"
], function(
    Marionette,
    _
) {
    "use strict";
    var Templates = JIRA.Projects.Release.Templates;
    var trace = _.bind(JIRA.trace, JIRA);

    var CLASSES = {
        CONTAINS_OPENED: "version-filter-search-opened",
        STATUS_PRESSED: "version-filter-status-pressed"
    };

    return Marionette.ItemView.extend({
        template: Templates.filter,
        ui: {
            "form": "form",
            "unreleased": ".version-filter-status-unreleased",
            "released": ".version-filter-status-released",
            "contains": ".text",
            "quickFilter": ".version-filter-status-text",
            "searchContainer": ".version-filter-search-container"
        },
        events: {
            // Prevent the form from being submitted when user hits enter
            "submit @ui.form": function formSubmit(e) {
                e.preventDefault();
            },
            "input @ui.contains": "inputContains",
            "change @ui.contains": "inputContains",
            "click @ui.released": "clickStatusReleased",
            "click @ui.unreleased": "clickStatusUnreleased",
            "focus @ui.contains": function() {
                this.ui.searchContainer.addClass(CLASSES.CONTAINS_OPENED);
            },
            "blur @ui.contains": function() {
                if (this._isContainsEmpty()) {
                    this.ui.searchContainer.removeClass(CLASSES.CONTAINS_OPENED);
                }
            }
        },
        modelEvents: {
            "change:status": function onStatusChange() {
                var isReleasedPressed = this._getReleased();
                var isUnreleasedPressed = this._getUnreleased();

                var hasReleasedPressedClass = this.ui.released.hasClass(CLASSES.STATUS_PRESSED);
                var hasUnreleasedPressedClass = this.ui.unreleased.hasClass(CLASSES.STATUS_PRESSED);

                if (isReleasedPressed && !hasReleasedPressedClass) {
                    this.ui.released.addClass(CLASSES.STATUS_PRESSED);
                }

                if (!isReleasedPressed && hasReleasedPressedClass) {
                    this.ui.released.removeClass(CLASSES.STATUS_PRESSED);
                }

                if (isUnreleasedPressed && !hasUnreleasedPressedClass) {
                    this.ui.unreleased.addClass(CLASSES.STATUS_PRESSED);
                }

                if (!isUnreleasedPressed && hasUnreleasedPressedClass) {
                    this.ui.unreleased.removeClass(CLASSES.STATUS_PRESSED);
                }

                trace("project.release.status.changed");
            }
        },
        onRender: function() {
            this.ui.quickFilter.tooltip({
                gravity: "w"
            });
        },
        clickStatusReleased: function (e) {
            this._clickStatus(e, !this._getReleased(), this._getUnreleased());
        },
        clickStatusUnreleased: function (e) {
            this._clickStatus(e, this._getReleased(), !this._getUnreleased());
        },
        _clickStatus: function (e, released, unreleased) {
            e.preventDefault();
            this.model.set("status", this._getCurrentStatus(released, unreleased));
        },
        _isContainsEmpty: function() {
            return _.isEmpty(this.ui.contains.val());
        },
        searchContainerResize: function() {
            if (!this._isContainsEmpty()) {
                this.ui.searchContainer.addClass(CLASSES.CONTAINS_OPENED);
            } else {
                if (!this.ui.contains.is(":focus")) {
                    this.ui.searchContainer.removeClass(CLASSES.CONTAINS_OPENED);
                }
            }
        },
        _inputContains: _.debounce(function inputContains(e) {
            var filter = this.ui.contains.val();
            this.model.set("contains", filter);
        }, 100),
        inputContains: function inputContains(e) {
            this.searchContainerResize();
            this._inputContains();
        },
        _getReleased: function() {
            var status = this.model.get("status");
            return status === 'all' || status === 'released';
        },
        _getUnreleased: function() {
            var status = this.model.get("status");
            return status === 'all' || status === 'unreleased';
        },
        _getCurrentStatus: function getCurrentStatus(released, unreleased) {
            if (released && unreleased) {
                return "all";
            } else if (unreleased) {
                return "unreleased";
            } else if (released) {
                return "released";
            } else {
                return "no-filter";
            }
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/EmptyItemView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Release");
    JIRA.Projects.Release.EmptyItemView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Release.Templates.emptyRow,
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/ItemView.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Release.ItemView");
    JIRA.Projects.Release.ItemView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Release.Templates.row,
        ui: {
            progressbar:  ".progressbar"
        },
        onRender: function onRender() {
            this.unwrapTemplate();
            this.initializeProgressDialog();
        },
        initializeProgressDialog: function initializeProgressDialog() {
            var instance = this;
            var versionInlineDialog = AJS.InlineDialog(this.ui.progressbar, "version-progress-" + this.cid,
                    function(content, trigger, showPopup) {
                        var $trigger = AJS.$(trigger);
                        var $row = $trigger.closest("tr");
                        var $versionName = $row.find("td:first-child a");
                        var entries = [];
                        var totalCount = 0;
                        $trigger.find(".progressbar__entry").each(function(i, el){
                            var $el = $(el);
                            var count = +$el.attr("data-count");
                            totalCount += +count;
                            entries.push({
                                name: $el.attr("data-title"),
                                type: $el.attr("data-type"),
                                url: $el.attr("data-url"),
                                count: count
                            });
                        });
                        content.html(JIRA.Projects.Release.Templates.progressBarDialog({
                            name: $versionName.text(),
                            url: $versionName.attr("href"),
                            totalCount: totalCount,
                            entries: entries
                        }));
                        showPopup();
                        versionInlineDialog.refresh();

                        return false;
                    },
                    {
                        gravity: 'w',
                        autoWidth: true,
                        onHover: true,
                        hideDelay: 500
                    }
            );
            versionInlineDialog.on("click", "a", function () {
                instance.trigger("progressDialogClicked");
            });
        }
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/ItemCollectionView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Release.ItemCollectionView");
    JIRA.Projects.Release.ItemCollectionView = JIRA.Projects.Libs.Marionette.CompositeView.extend({
        childView: JIRA.Projects.Release.ItemView,
        childViewContainer: "tbody",
        emptyView: JIRA.Projects.Release.EmptyItemView,
        template: JIRA.Projects.Release.Templates.table
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/ReleasePageApp.js' */
define("jira/projects/page/release/release-page-app", [
    "jira/projects/libs/marionette",
    "jira/api/projects",
    "jira/projects/page/release/view/filter",
    "jira/data/local-storage",
    "wrm/data",
    "backbone"
], function(
    Marionette,
    Projects,
    FilterView,
    localStorage,
    WRMData,
    Backbone
) {
    "use strict";

    var App = new Marionette.Application();

    function isOnProject() {
        return Projects.getCurrentProjectId() !== undefined;
    }

    App.on("start", function(options) {
        if (!isOnProject()) {
            return;
        }
        var projectId = Projects.getCurrentProjectId();
        var storageStatusKey = "jira-projects:release-page-status-" + projectId;

        var $el = options.container;
        var data = WRMData.claim('com.atlassian.jira.projects.page.release:versions');


        function saveStatus(status) {
            try {
                localStorage.setItem(storageStatusKey, status);
            } catch (exc) {
                // local storage may be disabled or full, do not do anything in this case
                console.warn(exc);
            }
        }

        App.pageableItems = new JIRA.Projects.AbstractList.PageableItemCollection(data, {
            mode: "client",
            state: {
                pageSize: (data.length > 50) ? 25 : 50,
                currentPage: 1
            }
        });

        App.filter = new JIRA.Projects.Release.FilterModel({
            pageableCollection: App.pageableItems,
            status: "unreleased",
            contains: ""
        });
        App.filter.filterCollection();
        App.filter.on("change:status", function(child, value) {
            saveStatus(value);
        });

        App.layout = new JIRA.Projects.AbstractList.Layout({
            model: App.filter,
            el: $el,
            regions: {
                filter: "#filter-container",
                main: "#content-container",
                pagination: "#pagination-container"
            }
        });

        App.layout.filter.show(new FilterView({
            model: App.filter
        }));

        App.layout.main.show(new JIRA.Projects.Release.ItemCollectionView({
            collection: App.pageableItems
        }));

        App.layout.pagination.show(new JIRA.Projects.AbstractList.PaginationView({
            collection: App.pageableItems,
            model: App.filter
        }));

        App.router = new JIRA.Projects.AbstractList.Router();
        App.router.on("route:any", function() {
            var status = JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("status", true) || "unreleased";
            var contains = JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("contains", true) || "";
            var page = +JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("page", true) || 1;

            App.filter.set("status", status, {silent: true});
            saveStatus(status);
            App.filter.set("contains", contains, {silent: true});
            App.filter.filterCollection();
            App.pageableItems.getPage(page);
            App.layout.filter.currentView.render();
        });

        function onNavigate() {
            App.trigger("navigate");
        }
        App.layout.pagination.currentView.on("navigate", onNavigate);
        App.filter.on("navigate", onNavigate);
        App.router.on("route:any", onNavigate);
        App.layout.main.currentView.on("childview:progressDialogClicked", function() {
            App.trigger("progressDialogClicked");
        });

        try {
            var storedStatus = localStorage.getItem(storageStatusKey);
            if (!JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("status", true) && isOnProject() && !!storedStatus) {
                App.filter.set("status", storedStatus, {silent: true});
                JIRA.Projects.AbstractList.NavigationUtils.append("status", storedStatus);
            }
        } catch (exc) {
            // local storage may be disabled or full, do not do anything in this case
            console.warn(exc);
        }


        if (Backbone.history && Backbone.History && !Backbone.History.started) {
            Backbone.history.start({
                root: JIRA.Projects.AbstractList.NavigationUtils.getBackboneHistoryRoot(),
                pushState: JIRA.Projects.AbstractList.NavigationUtils.pushStateSupported
            });
        }
    });

    return App;
});

AJS.namespace("JIRA.Projects.Release.App", null, require("jira/projects/page/release/release-page-app"));;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/Analytics.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Release.Analytics");
    JIRA.Projects.Release.Analytics = JIRA.Projects.Libs.Marionette.Controller.extend({
        progressDialogClick: function () {
            AJS.trigger('analyticsEvent', {
                name: "jira.projects.release.progress.dialog.click"
            });
        },
        navigate: function navigate() {
            var status = JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("status", true) || "unreleased";
            var contains = JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("contains", true) || "";
            var page = +JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("page", true) || 1;

            AJS.trigger('analyticsEvent', {
                name: "jira.projects.release.navigate",
                data: {
                    status: status,
                    containsLength: contains.length,
                    page: page
                }
            });
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:release-page-assets', location = '/page/project/release/release-page-init.js' */
require([
    "jquery",
    "jira/projects/page/release/release-page-app"
], function(
    $,
    ReleasePageApp
) {
    "use strict";

    var analytics = new JIRA.Projects.Release.Analytics();
    ReleasePageApp.on("navigate", analytics.navigate);
    ReleasePageApp.on("progressDialogClicked", analytics.progressDialogClick);

    $(function() {
        var $releaseContainer = $("#release-page");
        if ($releaseContainer.length) {
            ReleasePageApp.start({
                container: $releaseContainer
            });
        }
    });

});;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/templates.soy' */
// This file was automatically generated from templates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Projects.Components.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Projects == 'undefined') { JIRA.Projects = {}; }
if (typeof JIRA.Projects.Components == 'undefined') { JIRA.Projects.Components = {}; }
if (typeof JIRA.Projects.Components.Templates == 'undefined') { JIRA.Projects.Components.Templates = {}; }


JIRA.Projects.Components.Templates.page = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return aui.page.pageHeader({content: '<h1>' + soy.$$escapeHtml("Components") + '</h1>' + ((opt_data.adminLink) ? aui.page.pageHeaderActions({content: '' + aui.buttons.button({text: "Manage components", href: soy.$$escapeHtml("/jira") + '/' + soy.$$escapeHtml(opt_data.adminLink), id: 'add_component'})}) : ''), extraClasses: 'aui-page-header-fixed'}) + '<div id="components-page"><div id="filter-container"></div>' + aui.page.pagePanelContent({content: '<div id="content-container"></div><div id="pagination-container"></div>', extraClasses: 'aui-page-panel-content-no-table'}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Projects.Components.Templates.page.soyTemplateName = 'JIRA.Projects.Components.Templates.page';
}


JIRA.Projects.Components.Templates.table = function(opt_data, opt_ignored) {
  return '' + aui.table({extraClasses: 'components-table', theadContent: '<tr><th>' + soy.$$escapeHtml("Component") + '</th><th>' + soy.$$escapeHtml("Issues") + '</th><th>' + soy.$$escapeHtml("Lead") + '</th><th>' + soy.$$escapeHtml("Description") + '</th></tr>', content: '', cssClass: 'components-table', id: 'components-table'});
};
if (goog.DEBUG) {
  JIRA.Projects.Components.Templates.table.soyTemplateName = 'JIRA.Projects.Components.Templates.table';
}


JIRA.Projects.Components.Templates.row = function(opt_data, opt_ignored) {
  return '<tr><td class="components-table__name"><a href="' + soy.$$escapeHtml(opt_data.issuesUrl) + '">' + soy.$$escapeHtml(opt_data.name) + '</a></td><td class="components-table__issues-count"><a href="' + soy.$$escapeHtml(opt_data.issuesUrl) + '">' + soy.$$escapeHtml(AJS.format("{0,choice,0#{0} Issues|1#{0} Issue|1\x3c{0} Issues}",opt_data.issuesCount)) + '</a></td><td class="components-table__lead">' + soy.$$filterNoAutoescape(opt_data.leadUserProfileLinkHtml) + '</td><td class="components-table__description">' + ((opt_data.description) ? soy.$$escapeHtml(opt_data.description) : '') + '</td></tr>';
};
if (goog.DEBUG) {
  JIRA.Projects.Components.Templates.row.soyTemplateName = 'JIRA.Projects.Components.Templates.row';
}


JIRA.Projects.Components.Templates.emptyRow = function(opt_data, opt_ignored) {
  return '<tr class="components-table__row-empty"><td colspan="6"><div class="jira-adbox jira-adbox-medium no-results"><h3>' + soy.$$escapeHtml("No components were found that match your search") + '</h3><p class="no-results-hint">' + soy.$$escapeHtml("Try modifying your filter criteria.") + '</p></div></td></tr>';
};
if (goog.DEBUG) {
  JIRA.Projects.Components.Templates.emptyRow.soyTemplateName = 'JIRA.Projects.Components.Templates.emptyRow';
}


JIRA.Projects.Components.Templates.filter = function(opt_data, opt_ignored) {
  return '<form id="component-filter" class="component-filter aui ajs-dirty-warning-exempt"><div class="component-filter-text-container"><input type="text" id="component-filter-text" placeholder="' + soy.$$escapeHtml("Contains text...") + '" class="component-filter-text text" value="' + soy.$$escapeHtml(opt_data.contains) + '" /><span class="aui-icon aui-icon-small aui-iconfont-search-small"></span></div></form>';
};
if (goog.DEBUG) {
  JIRA.Projects.Components.Templates.filter.soyTemplateName = 'JIRA.Projects.Components.Templates.filter';
}
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/FilterModel.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.FilterModel");
    JIRA.Projects.Components.FilterModel = JIRA.Projects.AbstractList.FilterModel.extend({
        filterAttributes: ['contains'],
        defaults: {
            contains: ""
        },
        initialize: function initialize(options) {
            JIRA.Projects.AbstractList.FilterModel.prototype.initialize.call(this, options);

            this.on("change:contains", this.filterCollection);
            this.on("change:contains", this.navigate);
        },
        filterCollection: function filterCollection() {
            var filtered = this.pageableCollection.originalCollection;
            var contains = (this.get("contains") || "").toLowerCase();
            if (contains !== "") {
                filtered = filtered.filter(function filterText(arrayElement) {
                    return (
                            (arrayElement.name && arrayElement.name.toLowerCase().indexOf(contains) > -1) ||
                            (arrayElement.description && arrayElement.description.toLowerCase().indexOf(contains) > -1) ||
                            (arrayElement.leadUserDisplayName && arrayElement.leadUserDisplayName.toLowerCase().indexOf(contains) > -1)
                    );
                });
            }
            this.pageableCollection.fullCollection.reset(filtered);
            this.pageableCollection.getPage("first");
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/FilterView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.FilterView");
    JIRA.Projects.Components.FilterView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Components.Templates.filter,
        ui: {
            "form": "form",
            "contains": ".text"
        },
        events: {
            "submit @ui.form": "formSubmit",
            "input @ui.contains": "inputContains",
            "change @ui.contains": "inputContains"
        },
        formSubmit: function formSubmit(e) {
            e.preventDefault();
        },
        inputContains: _.debounce(function inputContains(e) {
            var filter = this.ui.contains.val();
            this.model.set("contains", filter);
        }, 300)
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/EmptyItemView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.EmptyItemView");
    JIRA.Projects.Components.EmptyItemView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Components.Templates.emptyRow,
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/ItemView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.ItemView");
    JIRA.Projects.Components.ItemView = JIRA.Projects.Libs.Marionette.ItemView.extend({
        template: JIRA.Projects.Components.Templates.row,
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/ItemCollectionView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.ItemCollectionView");
    JIRA.Projects.Components.ItemCollectionView = JIRA.Projects.Libs.Marionette.CompositeView.extend({
        childView: JIRA.Projects.Components.ItemView,
        childViewContainer: "tbody",
        emptyView: JIRA.Projects.Components.EmptyItemView,
        template: JIRA.Projects.Components.Templates.table
    });

})();;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/ComponentsPageApp.js' */
(function componentsPage() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.App");
    var App = JIRA.Projects.Components.App = new JIRA.Projects.Libs.Marionette.Application();

    App.on("start", function(options) {
        var $el = options.container;
        var data = WRM.data.claim("com.atlassian.jira.projects.page.components:components");

        App.pageableItems = new JIRA.Projects.AbstractList.PageableItemCollection(data, {
            mode: "client",
            state: {
                pageSize: (data.length > 50) ? 25 : 50,
                currentPage: 1
            }
        });

        App.filter = new JIRA.Projects.Components.FilterModel({
            pageableCollection: App.pageableItems,
            contains: ""
        });
        App.filter.filterCollection();

        App.layout = new JIRA.Projects.AbstractList.Layout({
            model: App.filter,
            el: $el,
            regions: {
                filter: "#filter-container",
                main: "#content-container",
                pagination: "#pagination-container"
            }
        });

        App.layout.filter.show(new JIRA.Projects.Components.FilterView({
            model: App.filter
        }));

        App.layout.main.show(new JIRA.Projects.Components.ItemCollectionView({
            collection: App.pageableItems
        }));

        App.layout.pagination.show(new JIRA.Projects.AbstractList.PaginationView({
            collection: App.pageableItems,
            model: App.filter
        }));

        App.router = new JIRA.Projects.AbstractList.Router();
        App.router.on("route:any", function() {
            var contains = JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("contains", true) || "";
            var page = +JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("page", true) || 1;

            App.filter.set("contains", contains, {silent: true});
            App.filter.filterCollection();
            App.pageableItems.getPage(page);
            App.layout.filter.currentView.render();
        });

        function onNavigate() {
            App.trigger("navigate");
        }
        App.layout.pagination.currentView.on("navigate", onNavigate);
        App.filter.on("navigate", onNavigate);
        App.router.on("route:any", onNavigate);

        if (Backbone.history && Backbone.History && !Backbone.History.started) {
            Backbone.history.start({
                root: JIRA.Projects.AbstractList.NavigationUtils.getBackboneHistoryRoot(),
                pushState: JIRA.Projects.AbstractList.NavigationUtils.pushStateSupported
            });
        }
    });

}());;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/Analytics.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Projects.Components.Analytics");
    JIRA.Projects.Components.Analytics = JIRA.Projects.Libs.Marionette.Controller.extend({
        navigate: function navigate() {
            var contains = JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("contains", true) || "";
            var page = +JIRA.Projects.AbstractList.NavigationUtils.getQueryStringParam("page", true) || 1;

            AJS.trigger('analyticsEvent', {
                name: "jira.projects.components.navigate",
                data: {
                    containsLength: contains.length,
                    page: page
                }
            });
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:components-page-assets', location = '/page/project/components/components-page-init.js' */
(function componentsPage($) {
    "use strict";

    var analytics = new JIRA.Projects.Components.Analytics();
    JIRA.Projects.Components.App.on("navigate", analytics.navigate);

    $(function() {
        var $componentsContainer = $("#components-page");
        if ($componentsContainer.length) {
            JIRA.Projects.Components.App.start({
                container: $componentsContainer
            });
        }
    });
}(AJS.$));;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:report-page-assets', location = '/page/project/report/analytics.js' */
(function reportsPageAnalytics($) {
    "use strict";

    AJS.namespace("JIRA.Projects.Report");

    JIRA.Projects.Report.Analytics = function() {

        $('.reports .reports__list__report').on('click', function(e) {
            var $this = $(this);

            AJS.trigger('analyticsEvent', {
                name: "jira.projects.report.clicked",
                data: {
                    report: $this.attr("data-report-key"),
                    category: $this.closest('ul').attr("data-category-key"),
                    listPosition: $this.closest('li').prevAll().length + 1
                }
            });
        });
    };

    $(JIRA.Projects.Report.Analytics);
}(AJS.$));;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:reports-link-storage', location = '/sidebar/reports/reports-link-storage.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Projects.Sidebar.Reports");

    JIRA.Projects.Sidebar.Reports = {
        storeLastViewedReportLink: function(reportUrl) {
            if (JIRA.API.Sidebar.isProjectSidebar()) {
                var key = this._createLastViewedReportKey();
                require("jira/data/local-storage").setItem(key, reportUrl);
                this._setReportsItemLink(reportUrl);
            }
            JIRA.trace("jira.projects.sidebar.reports.link.stored");
        },

        restoreLastViewedReportLink: function() {
            if (JIRA.API.Sidebar.isProjectSidebar()) {
                var key = this._createLastViewedReportKey();
                var reportUrl = require("jira/data/local-storage").getItem(key);
                if (reportUrl) {
                    this._setReportsItemLink(reportUrl);
                }
            }
            JIRA.trace("jira.projects.sidebar.reports.link.restored");
        },

        _createLastViewedReportKey: function() {
            var scopeFilterId = JIRA.API.Sidebar.getSelectedScopeFilterId();
            var projectKey = JIRA.API.Projects.getCurrentProjectKey();

            var key = "last.viewed.report." + projectKey;
            if (scopeFilterId) {
                key += "." + scopeFilterId;
            }
            return key;
        },

        _setReportsItemLink: function(reportUrl) {
            JIRA.API.Sidebar.setReportsItemLink(reportUrl);
        }
    };

}());
;
;
/* module-key = 'com.atlassian.jira.jira-projects-plugin:reports-link-init', location = '/sidebar/reports/reports-link-init.js' */
AJS.$(function() {
    "use strict";

    JIRA.API.getSidebar().done(function() {
        JIRA.Projects.Sidebar.Reports.restoreLastViewedReportLink();
    });
});
;
;
/* module-key = 'jira.webresources:field-templates', location = '/includes/jira/field/templates/singleUserPicker.soy' */
// This file was automatically generated from singleUserPicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Fields.Pickers.User.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Fields == 'undefined') { JIRA.Templates.Fields = {}; }
if (typeof JIRA.Templates.Fields.Pickers == 'undefined') { JIRA.Templates.Fields.Pickers = {}; }
if (typeof JIRA.Templates.Fields.Pickers.User == 'undefined') { JIRA.Templates.Fields.Pickers.User = {}; }


JIRA.Templates.Fields.Pickers.User.single = function(opt_data, opt_ignored) {
  var output = '<select id="' + soy.$$escapeHtml(opt_data.field.id) + '" name="' + soy.$$escapeHtml(opt_data.field.name) + '" class="single-user-picker js-' + ((opt_data.type) ? soy.$$escapeHtml(opt_data.type) : 'default-user-picker') + '"' + ((opt_data.inputText) ? ' data-input-text="' + soy.$$escapeHtml(opt_data.inputText) + '"' : '') + ((opt_data.editValue) ? ' data-edit-value="' + soy.$$escapeHtml(opt_data.editValue) + '"' : '') + ((opt_data.showDropdownButton) ? ' data-show-dropdown-button="true"' : '') + ((opt_data.userType) ? ' data-user-type="' + soy.$$escapeHtml(opt_data.userType) + '"' : '') + ((opt_data.containerClass) ? ' data-container-class="' + soy.$$escapeHtml(opt_data.containerClass) + '"' : '') + '>';
  var optionList38 = opt_data.options;
  var optionListLen38 = optionList38.length;
  for (var optionIndex38 = 0; optionIndex38 < optionListLen38; optionIndex38++) {
    var optionData38 = optionList38[optionIndex38];
    if (optionData38.optionGroup) {
      output += '<optgroup id="' + soy.$$escapeHtml(opt_data.field.id) + '-group-' + soy.$$escapeHtml(optionData38.id) + '" label="' + soy.$$escapeHtml(optionData38.display) + '"' + ((optionData38.footer) ? ' data-footer-text="' + soy.$$escapeHtml(optionData38.footer) + '"' : '') + ((optionData38.weight != -1) ? ' data-weight="' + soy.$$escapeHtml(optionData38.weight) + '"' : '') + '>';
      var groupOptionList59 = optionData38.groupOptions;
      var groupOptionListLen59 = groupOptionList59.length;
      for (var groupOptionIndex59 = 0; groupOptionIndex59 < groupOptionListLen59; groupOptionIndex59++) {
        var groupOptionData59 = groupOptionList59[groupOptionIndex59];
        output += JIRA.Templates.Fields.Pickers.User.option(groupOptionData59);
      }
      output += '</optgroup>';
    } else {
      output += JIRA.Templates.Fields.Pickers.User.option(optionData38);
    }
  }
  output += '</select>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.Pickers.User.single.soyTemplateName = 'JIRA.Templates.Fields.Pickers.User.single';
}


JIRA.Templates.Fields.Pickers.User.option = function(opt_data, opt_ignored) {
  return '<option ' + ((opt_data.loggedInUser) ? 'class="current-user" ' : '') + ((opt_data.selected) ? 'selected="selected" ' : '') + 'value="' + soy.$$escapeHtml(opt_data.optionName) + '" data-field-text="' + soy.$$escapeHtml(opt_data.displayName) + '" data-field-label="' + soy.$$escapeHtml(opt_data.displayName) + ((opt_data.emailAddress) ? ' - ' + soy.$$escapeHtml(opt_data.emailAddress) : '') + ((opt_data.optionName && opt_data.optionName != '-1') ? ' (' + soy.$$escapeHtml(opt_data.optionName) + ')' : '') + '" data-icon="' + soy.$$escapeHtml(opt_data.avatarURL) + '" >' + soy.$$escapeHtml(opt_data.displayName) + '</option>';
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.Pickers.User.option.soyTemplateName = 'JIRA.Templates.Fields.Pickers.User.option';
}
;
;
/* module-key = 'jira.webresources:field-templates', location = '/includes/jira/field/templates/assigneeField.soy' */
// This file was automatically generated from assigneeField.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Fields.Pickers.User.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Fields == 'undefined') { JIRA.Templates.Fields = {}; }
if (typeof JIRA.Templates.Fields.Pickers == 'undefined') { JIRA.Templates.Fields.Pickers = {}; }
if (typeof JIRA.Templates.Fields.Pickers.User == 'undefined') { JIRA.Templates.Fields.Pickers.User = {}; }


JIRA.Templates.Fields.Pickers.User.assignee = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.Fields.Pickers.User.single(soy.$$augmentMap(opt_data, {options: opt_data.assigneeOptions.options, showDropdownButton: true, userType: 'assignee', type: 'assignee-picker', containerClass: 'long-field'})) + ((opt_data.isLoggedInUserAssignable) ? '<a href="#' + soy.$$escapeHtml(opt_data.field.id) + '" id="assign-to-me-trigger">' + soy.$$escapeHtml("Assign to me") + '</a>' : '') + '<fieldset class="hidden parameters"><input type="hidden" title="projectKeys" value="' + soy.$$escapeHtml(opt_data.projectKeys) + '"/>' + ((opt_data.issueKey) ? '<input type="hidden" title="assigneeEditIssueKey" value="' + soy.$$escapeHtml(opt_data.issueKey) + '"/>' : '') + ((opt_data.actionDescriptorId) ? '<input type="hidden" title="actionDescriptorId" value="' + soy.$$escapeHtml(opt_data.actionDescriptorId) + '"/>' : '') + '</fieldset>';
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.Pickers.User.assignee.soyTemplateName = 'JIRA.Templates.Fields.Pickers.User.assignee';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/lib/jquery.dotdotdot-1.5.7.js' */
/*	
 *	jQuery dotdotdot 1.5.7
 *	
 *	Copyright (c) 2013 Fred Heusschen
 *	www.frebsite.nl
 *
 *	Plugin website:
 *	dotdotdot.frebsite.nl
 *
 *	Dual licensed under the MIT and GPL licenses.
 *	http://en.wikipedia.org/wiki/MIT_License
 *	http://en.wikipedia.org/wiki/GNU_General_Public_License
 */

(function( $ )
{
	if ( $.fn.dotdotdot )
	{
		return;
	}

	$.fn.dotdotdot = function( o )
	{
		if ( this.length == 0 )
		{
			if ( !o || o.debug !== false )
			{
				debug( true, 'No element found for "' + this.selector + '".' );				
			}
			return this;
		}
		if ( this.length > 1 )
		{
			return this.each(
				function()
				{
					$(this).dotdotdot( o );
				}
			);
		}


		var $dot = this;

		if ( $dot.data( 'dotdotdot' ) )
		{
			$dot.trigger( 'destroy.dot' );
		}

		$dot.bind_events = function()
		{
			$dot.bind(
				'update.dot',
				function( e, c )
				{
					e.preventDefault();
					e.stopPropagation();

					opts.maxHeight = ( typeof opts.height == 'number' ) 
						? opts.height 
						: getTrueInnerHeight( $dot );

					opts.maxHeight += opts.tolerance;

					if ( typeof c != 'undefined' )
					{
						if ( typeof c == 'string' || c instanceof HTMLElement )
						{
					 		c = $('<div />').append( c ).contents();
						}
						if ( c instanceof $ )
						{
							orgContent = c;
						}
					}

					$inr = $dot.wrapInner( '<div class="dotdotdot" />' ).children();
					$inr.empty()
						.append( orgContent.clone( true ) )
						.css({
							'height'	: 'auto',
							'width'		: 'auto',
							'border'	: 'none',
							'padding'	: 0,
							'margin'	: 0
						});

					var after = false,
						trunc = false;

					if ( conf.afterElement )
					{
						after = conf.afterElement.clone( true );
						conf.afterElement.remove();
					}
					if ( test( $inr, opts ) )
					{
						if ( opts.wrap == 'children' )
						{
							trunc = children( $inr, opts, after );
						}
						else
						{
							trunc = ellipsis( $inr, $dot, $inr, opts, after );
						}
					}
					$inr.replaceWith( $inr.contents() );
					$inr = null;
					
					if ( $.isFunction( opts.callback ) )
					{
						opts.callback.call( $dot[ 0 ], trunc, orgContent );
					}

					conf.isTruncated = trunc;
					return trunc;
				}

			).bind(
				'isTruncated.dot',
				function( e, fn )
				{
					e.preventDefault();
					e.stopPropagation();

					if ( typeof fn == 'function' )
					{
						fn.call( $dot[ 0 ], conf.isTruncated );
					}
					return conf.isTruncated;
				}

			).bind(
				'originalContent.dot',
				function( e, fn )
				{
					e.preventDefault();
					e.stopPropagation();

					if ( typeof fn == 'function' )
					{
						fn.call( $dot[ 0 ], orgContent );
					}
					return orgContent;
				}

			).bind(
				'destroy.dot',
				function( e )
				{
					e.preventDefault();
					e.stopPropagation();

					$dot.unwatch()
						.unbind_events()
						.empty()
						.append( orgContent )
						.data( 'dotdotdot', false );
				}
			);
			return $dot;
		};	//	/bind_events

		$dot.unbind_events = function()
		{
			$dot.unbind('.dot');
			return $dot;
		};	//	/unbind_events

		$dot.watch = function()
		{
			$dot.unwatch();
			if ( opts.watch == 'window' )
			{
				var $window = $(window),
					_wWidth = $window.width(),
					_wHeight = $window.height(); 

				$window.bind(
					'resize.dot' + conf.dotId,
					function()
					{
						if ( _wWidth != $window.width() || _wHeight != $window.height() || !opts.windowResizeFix )
						{
							_wWidth = $window.width();
							_wHeight = $window.height();
	
							if ( watchInt )
							{
								clearInterval( watchInt );
							}
							watchInt = setTimeout(
								function()
								{
									$dot.trigger( 'update.dot' );
								}, 10
							);
						}
					}
				);
			}
			else
			{
				watchOrg = getSizes( $dot );
				watchInt = setInterval(
					function()
					{
						var watchNew = getSizes( $dot );
						if ( watchOrg.width  != watchNew.width ||
							 watchOrg.height != watchNew.height )
						{
							$dot.trigger( 'update.dot' );
							watchOrg = getSizes( $dot );
						}
					}, 100
				);
			}
			return $dot;
		};
		$dot.unwatch = function()
		{
			$(window).unbind( 'resize.dot' + conf.dotId );
			if ( watchInt )
			{
				clearInterval( watchInt );
			}
			return $dot;
		};

		var	orgContent	= $dot.contents(),
			opts 		= $.extend( true, {}, $.fn.dotdotdot.defaults, o ),
			conf		= {},
			watchOrg	= {},
			watchInt	= null,
			$inr		= null;

		conf.afterElement	= getElement( opts.after, $dot );
		conf.isTruncated	= false;
		conf.dotId			= dotId++;


		$dot.data( 'dotdotdot', true )
			.bind_events()
			.trigger( 'update.dot' );

		if ( opts.watch )
		{
			$dot.watch();
		}

		return $dot;
	};


	//	public
	$.fn.dotdotdot.defaults = {
		'ellipsis'	: '... ',
		'wrap'		: 'word',
		'lastCharacter': {
			'remove'		: [ ' ', ',', ';', '.', '!', '?' ],
			'noEllipsis'	: []
		},
		'tolerance'	: 0,
		'callback'	: null,
		'after'		: null,
		'height'	: null,
		'watch'		: false,
		'windowResizeFix': true,
		'debug'		: false
	};
	

	//	private
	var dotId = 1;

	function children( $elem, o, after )
	{
		var $elements 	= $elem.children(),
			isTruncated	= false;

		$elem.empty();

		for ( var a = 0, l = $elements.length; a < l; a++ )
		{
			var $e = $elements.eq( a );
			$elem.append( $e );
			if ( after )
			{
				$elem.append( after );
			}
			if ( test( $elem, o ) )
			{
				$e.remove();
				isTruncated = true;
				break;
			}
			else
			{
				if ( after )
				{
					after.remove();
				}
			}
		}
		return isTruncated;
	}
	function ellipsis( $elem, $d, $i, o, after )
	{
		var $elements 	= $elem.contents(),
			isTruncated	= false;

		$elem.empty();

		var notx = 'table, thead, tbody, tfoot, tr, col, colgroup, object, embed, param, ol, ul, dl, select, optgroup, option, textarea, script, style';
		for ( var a = 0, l = $elements.length; a < l; a++ )
		{

			if ( isTruncated )
			{
				break;
			}

			var e	= $elements[ a ],
				$e	= $(e);

			if ( typeof e == 'undefined' )
			{
				continue;
			}

			$elem.append( $e );
			if ( after )
			{
				$elem[ ( $elem.is( notx ) ) ? 'after' : 'append' ]( after );
			}
			if ( e.nodeType == 3 )
			{
				if ( test( $i, o ) )
				{
					isTruncated = ellipsisElement( $e, $d, $i, o, after );
				}
			}
			else
			{
				isTruncated = ellipsis( $e, $d, $i, o, after );
			}

			if ( !isTruncated )
			{
				if ( after )
				{
					after.remove();
				}
			}
		}
		return isTruncated;
	}
	function ellipsisElement( $e, $d, $i, o, after )
	{
		var isTruncated	= false,
			e = $e[ 0 ];

		if ( typeof e == 'undefined' )
		{
			return false;
		}

		var seporator	= ( o.wrap == 'letter' ) ? '' : ' ',
			textArr		= getTextContent( e ).split( seporator ),
			position 	= -1,
			midPos		= -1,
			startPos	= 0,
			endPos		= textArr.length - 1;

		while ( startPos <= endPos )
		{
			var m = Math.floor( ( startPos + endPos ) / 2 );
			if ( m == midPos ) 
			{
				break;
			}
			midPos = m;

			setTextContent( e, textArr.slice( 0, midPos + 1 ).join( seporator ) + o.ellipsis );

			if ( !test( $i, o ) )
			{
				position = midPos;
				startPos = midPos; 
			}
			else
			{
				endPos = midPos;
			}				
		}	
	
		if ( position != -1 && !( textArr.length == 1 && textArr[ 0 ].length == 0 ) )
		{
			var txt = addEllipsis( textArr.slice( 0, position + 1 ).join( seporator ), o );
			isTruncated = true;
			setTextContent( e, txt );
		}
		else
		{
			var $w = $e.parent();
			$e.remove();

			var afterLength = ( after ) ? after.length : 0 ;

			if ( $w.contents().size() > afterLength )
			{
				var $n = $w.contents().eq( -1 - afterLength );
				isTruncated = ellipsisElement( $n, $d, $i, o, after );
			}
			else
			{
				var e = $w.prev().contents().eq( -1 )[ 0 ];

				if ( typeof e != 'undefined' )
				{
					var txt = addEllipsis( getTextContent( e ), o );
					setTextContent( e, txt );
					$w.remove();
					isTruncated = true;
				}

			}
		}

		return isTruncated;
	}
	function test( $i, o )
	{
		return $i.innerHeight() > o.maxHeight;
	}
	function addEllipsis( txt, o )
	{
		while( $.inArray( txt.slice( -1 ), o.lastCharacter.remove ) > -1 )
		{
			txt = txt.slice( 0, -1 );
		}
		if ( $.inArray( txt.slice( -1 ), o.lastCharacter.noEllipsis ) < 0 )
		{
			txt += o.ellipsis;
		}
		return txt;
	}
	function getSizes( $d )
	{
		return {
			'width'	: $d.innerWidth(),
			'height': $d.innerHeight()
		};
	}
	function setTextContent( e, content )
	{
		if ( e.innerText )
		{
			e.innerText = content;
		}
		else if ( e.nodeValue )
		{
			e.nodeValue = content;
		}
		else if (e.textContent)
		{
			e.textContent = content;
		}

	}
	function getTextContent( e )
	{
		if ( e.innerText )
		{
			return e.innerText;
		}
		else if ( e.nodeValue )
		{
			return e.nodeValue;
		}
		else if ( e.textContent )
		{
			return e.textContent;
		}
		else
		{
			return "";
		}
	}
	function getElement( e, $i )
	{
		if ( typeof e == 'undefined' )
		{
			return false;
		}
		if ( !e )
		{
			return false;
		}
		if ( typeof e == 'string' )
		{
			e = $(e, $i);
			return ( e.length )
				? e 
				: false;
		}
		if ( typeof e == 'object' )
		{
			return ( typeof e.jquery == 'undefined' )
				? false
				: e;
		}
		return false;
	}
	function getTrueInnerHeight( $el )
	{
		var h = $el.innerHeight(),
			a = [ 'paddingTop', 'paddingBottom' ];

		for ( var z = 0, l = a.length; z < l; z++ ) {
			var m = parseInt( $el.css( a[ z ] ), 10 );
			if ( isNaN( m ) )
			{
				m = 0;
			}
			h -= m;
		}
		return h;
	}
	function debug( d, m )
	{
		if ( !d )
		{
			return false;
		}
		if ( typeof m == 'string' )
		{
			m = 'dotdotdot: ' + m;
		}
		else
		{
			m = [ 'dotdotdot:', m ];
		}

		if ( typeof window.console != 'undefined' )
		{
			if ( typeof window.console.log != 'undefined' )
			{
				window.console.log( m );
			}
		}
		return false;
	}
	

	//	override jQuery.html
	var _orgHtml = $.fn.html;
    $.fn.html = function( str ) {
		if ( typeof str != 'undefined' )
		{
			if ( this.data( 'dotdotdot' ) )
			{
				if ( typeof str != 'function' )
				{
					return this.trigger( 'update', [ str ] );
				}
			}
			return _orgHtml.call( this, str );
		}
		return _orgHtml.call( this );
    };


	//	override jQuery.text
	var _orgText = $.fn.text;
    $.fn.text = function( str ) {
		if ( typeof str != 'undefined' )
		{
			if ( this.data( 'dotdotdot' ) )
			{
				var temp = $( '<div />' );
				temp.text( str );
				str = temp.html();
				temp.remove();
				return this.trigger( 'update', [ str ] );
			}
			return _orgText.call( this, str );
		}
        return _orgText.call( this );
    };


})( require('jquery') );
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/soy/ProjectTemplatesList.soy' */
// This file was automatically generated from ProjectTemplatesList.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }


JIRA.Templates.ProjectTemplates.renderProjectTemplates = function(opt_data, opt_ignored) {
  return '' + ((soy.$$getMapKeys(opt_data.projectTemplates).length == 0) ? JIRA.Templates.errorMsg({closeable: false, msg: "No project templates could be found."}) : JIRA.Templates.ProjectTemplates.renderTemplates(opt_data));
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderProjectTemplates.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderProjectTemplates';
}


JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.projectTemplatesByType.length == 0) {
    output += JIRA.Templates.errorMsg({closeable: false, msg: "No project templates could be found."});
  } else {
    var projectTypeTemplatesGroupList18 = opt_data.projectTemplatesByType;
    var projectTypeTemplatesGroupListLen18 = projectTypeTemplatesGroupList18.length;
    for (var projectTypeTemplatesGroupIndex18 = 0; projectTypeTemplatesGroupIndex18 < projectTypeTemplatesGroupListLen18; projectTypeTemplatesGroupIndex18++) {
      var projectTypeTemplatesGroupData18 = projectTypeTemplatesGroupList18[projectTypeTemplatesGroupIndex18];
      output += '<div class="template-group" id="project-template-group-' + soy.$$escapeHtml(projectTypeTemplatesGroupData18.projectTypeBean.projectTypeKey) + '"><div class="template-group-header"><h6><img class="project-type-icon" src="data:image/svg+xml;base64, ' + soy.$$escapeHtml(projectTypeTemplatesGroupData18.projectTypeBean.icon) + ' "/><span>' + soy.$$escapeHtml(projectTypeTemplatesGroupData18.projectTypeBean.projectTypeDisplayKey) + '</span></h6></div>' + JIRA.Templates.ProjectTemplates.renderTemplates({projectTemplates: projectTypeTemplatesGroupData18.projectTemplates}) + '</div>';
    }
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType';
}


JIRA.Templates.ProjectTemplates.renderTemplates = function(opt_data, opt_ignored) {
  return '<div class="pt-templates-list">' + JIRA.Templates.ProjectTemplates.renderItems(opt_data) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderTemplates.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderTemplates';
}


JIRA.Templates.ProjectTemplates.renderItems = function(opt_data, opt_ignored) {
  var output = '<ol class="templates" tabindex="100">';
  var templateList37 = opt_data.projectTemplates;
  var templateListLen37 = templateList37.length;
  for (var templateIndex37 = 0; templateIndex37 < templateListLen37; templateIndex37++) {
    var templateData37 = templateList37[templateIndex37];
    output += '<li class="template"' + ((templateData37.itemModuleCompleteKey) ? 'data-item-module-complete-key="' + soy.$$escapeHtml(templateData37.itemModuleCompleteKey) + '"' : '') + ((templateData37.projectTemplateModuleCompleteKey) ? 'data-project-template-module-complete-key="' + soy.$$escapeHtml(templateData37.projectTemplateModuleCompleteKey) + '"' : '') + ((templateData37.createProject) ? 'data-create-project="' + soy.$$escapeHtml(templateData37.createProject) + '"' : '') + ((templateData37.demoProject) ? 'data-demo-project="' + soy.$$escapeHtml(templateData37.demoProject) + '"' : '') + ((templateData37.backgroundIconUrl) ? 'data-background-icon-url="' + soy.$$escapeHtml(templateData37.backgroundIconUrl) + '"' : '') + ((templateData37.name) ? 'data-name="' + soy.$$escapeHtml(templateData37.name) + '"' : '') + ((templateData37.description) ? 'data-description="' + soy.$$escapeHtml(templateData37.description) + '"' : '') + ((templateData37.longDescriptionContent) ? 'data-long-description-content="' + soy.$$escapeHtml(templateData37.longDescriptionContent) + '"' : '') + ((templateData37.infoSoyPath) ? 'data-info-soy-path="' + soy.$$escapeHtml(templateData37.infoSoyPath) + '"' : '') + '><img class="template-preview" src="' + soy.$$escapeHtml(templateData37.iconUrl) + '" /><div class="template-meta"><div class="template-name" title="' + soy.$$escapeHtml(templateData37.name) + '">' + soy.$$escapeHtml(templateData37.name) + '</div><div class="template-description" title="' + soy.$$escapeHtml(templateData37.description) + '">' + soy.$$escapeHtml(templateData37.description) + '</div></div></li>';
  }
  output += '</ol>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderItems.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderItems';
}


JIRA.Templates.ProjectTemplates.loadingTemplatesList = function(opt_data, opt_ignored) {
  return '<div class="wait-container"><img class="wait-icon" src="' + soy.$$escapeHtml("/jira") + '/images/icons/wait.gif"><span class="wait-text">' + soy.$$escapeHtml("Loading project templates") + '&hellip;</span></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.loadingTemplatesList.soyTemplateName = 'JIRA.Templates.ProjectTemplates.loadingTemplatesList';
}


JIRA.Templates.ProjectTemplates.footerLinks = function(opt_data, opt_ignored) {
  return '<div class="footer-links"><a class="import-project-trigger button-panel-link" href="' + soy.$$escapeHtml("/jira") + '/secure/admin/views/ExternalImport1.jspa">' + soy.$$escapeHtml("Import a project") + '</a>|<a class="create-with-shared-config button-panel-link" href="#"><span class="aui-icon aui-icon-create-shared">' + soy.$$escapeHtml("Create with shared configuration") + '</span> ' + soy.$$escapeHtml("Create with shared configuration") + '</a>' + ((opt_data.showDemoLink) ? '| <a class="add-demo-project-trigger button-panel-link" href="#">' + soy.$$escapeHtml("Create sample data") + '</a>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.footerLinks.soyTemplateName = 'JIRA.Templates.ProjectTemplates.footerLinks';
}


JIRA.Templates.ProjectTemplates.addWorkflowsLink = function(opt_data, opt_ignored) {
  return '<a class="add-workflow-link" href="' + soy.$$escapeHtml(opt_data.baseUrl) + '/plugins/servlet/wfshare-import?src=projecttemplates" tabindex="-1">' + soy.$$escapeHtml("View Marketplace Workflows") + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.addWorkflowsLink.soyTemplateName = 'JIRA.Templates.ProjectTemplates.addWorkflowsLink';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/soy/AddProject.soy' */
// This file was automatically generated from AddProject.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }


JIRA.Templates.ProjectTemplates.addProjectForm = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.errors.errorMessages) {
    var errorList5 = opt_data.errors.errorMessages;
    var errorListLen5 = errorList5.length;
    for (var errorIndex5 = 0; errorIndex5 < errorListLen5; errorIndex5++) {
      var errorData5 = errorList5[errorIndex5];
      output += JIRA.Templates.errorMsg({closeable: false, msg: errorData5});
    }
  }
  output += '<div class="add-project-wrapper"><div class="add-project-form-wrapper">' + aui.form.form({content: '' + aui.form.fieldset({legendContent: '', content: '' + JIRA.Templates.ProjectTemplates.longTextField({id: 'name', name: 'name', isRequired: false, maxLength: opt_data.maxNameLength, labelContent: "Name", descriptionText: AJS.format("Max. {0} characters.",opt_data.maxNameLength), value: opt_data.currentName ? opt_data.currentName : '', errorTexts: opt_data.errors.errors.projectName ? [opt_data.errors.errors.projectName] : []}) + JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon({id: 'key', name: 'key', isRequired: false, maxLength: opt_data.maxKeyLength, labelContent: "Key", descriptionText: AJS.format("Max. {0} characters.",opt_data.maxKeyLength), helpTitle: "What\x27s a project key?", value: opt_data.currentKey ? opt_data.currentKey : '', errorTexts: opt_data.errors.errors.projectKey ? [opt_data.errors.errors.projectKey] : []}) + ((opt_data.shouldShowLead) ? JIRA.Templates.ProjectTemplates.projectLeadField({field: opt_data.projectLeadPickerField, isRequired: false, errorTexts: opt_data.errors.errors.projectLead ? [opt_data.errors.errors.projectLead] : [], options: opt_data.leadOptions}) : '') + ((opt_data.addUserToLicense.displayCheckbox) ? JIRA.Templates.ProjectTemplates.addUserToLicense({fieldId: opt_data.addUserToLicense.fieldId, fieldName: opt_data.addUserToLicense.fieldName, applicationName: opt_data.addUserToLicense.applicationName, usedSeats: opt_data.addUserToLicense.usedSeats, totalSeats: opt_data.addUserToLicense.totalSeats, disableCheckbox: opt_data.addUserToLicense.disableCheckbox, licensingUrl: opt_data.addUserToLicense.licensingUrl}) : '') + '<input type="hidden" name="keyEdited" id="keyEdited" value="false"><input type="hidden" name="projectTemplateWebItemKey" value="' + soy.$$escapeHtml(opt_data.projectTemplateWebItemKey) + '"><input type="hidden" name="projectTemplateModuleKey" value="' + soy.$$escapeHtml(opt_data.projectTemplateModuleKey) + '"><input type="submit" class="pt-hidden-submit offscreen-left">'}), id: 'add-project-form'}) + '</div>' + ((opt_data.projectTemplateDescriptionContent) ? '<div class="add-project-description-wrapper"><div class="project-template-title"><h3>' + soy.$$escapeHtml(opt_data.projectTemplateTitle) + '</h3></div><div class="project-template-description">' + soy.$$filterNoAutoescape(opt_data.projectTemplateDescriptionContent) + '</div></div>' : '') + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.addProjectForm.soyTemplateName = 'JIRA.Templates.ProjectTemplates.addProjectForm';
}


JIRA.Templates.ProjectTemplates.keyHelp = function(opt_data, opt_ignored) {
  return '<div class="project-key-help"><p><b>' + soy.$$escapeHtml("What\x27s a project key?") + '</b></p><ul><li>' + soy.$$escapeHtml("It prefixes each issue in the project") + '</li><li>' + soy.$$escapeHtml("It can be changed, but this is not a trivial task") + '</li></ul></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.keyHelp.soyTemplateName = 'JIRA.Templates.ProjectTemplates.keyHelp';
}


JIRA.Templates.ProjectTemplates.projectLeadField = function(opt_data, opt_ignored) {
  var param77 = '' + aui.form.label({forField: opt_data.field.name + '-field', isRequired: opt_data.isRequired, content: "Project Lead"}) + JIRA.Templates.Fields.Pickers.User.single({field: opt_data.field, options: opt_data.options, editValue: opt_data.value}) + aui.form.fieldDescription({message: "Enter the username of the Project Lead."});
  if (opt_data.errorTexts) {
    var errorList90 = opt_data.errorTexts;
    var errorListLen90 = errorList90.length;
    for (var errorIndex90 = 0; errorIndex90 < errorListLen90; errorIndex90++) {
      var errorData90 = errorList90[errorIndex90];
      param77 += aui.form.fieldError({message: errorData90});
    }
  }
  var output = '' + aui.form.fieldGroup({content: param77});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.projectLeadField.soyTemplateName = 'JIRA.Templates.ProjectTemplates.projectLeadField';
}


JIRA.Templates.ProjectTemplates.addUserToLicense = function(opt_data, opt_ignored) {
  var output = '';
  var labelMessage__soy96 = '' + soy.$$escapeHtml(AJS.format("Give me a {0} license so I can access this project.",opt_data.applicationName)) + ((opt_data.totalSeats > 0) ? '<br/>' + soy.$$escapeHtml(AJS.format("({0} of {1} licenses now used)",opt_data.usedSeats,opt_data.totalSeats)) : '');
  output += aui.form.fieldGroup({content: '' + aui.form.label({forField: opt_data.fieldName, content: 'License'}) + ((opt_data.disableCheckbox) ? aui.form.field({id: opt_data.fieldId, name: opt_data.fieldName, value: 'true', type: 'checkbox', isChecked: false, labelContent: labelMessage__soy96, isDisabled: true, descriptionContent: AJS.format("We can\x27\x27t give you access to {0} automatically. You can {1}manage application access{2} to work on {0} projects.",opt_data.applicationName,'<a href="' + "/jira" + opt_data.licensingUrl + '">','</a>')}) : aui.form.field({id: opt_data.fieldId, name: opt_data.fieldName, value: 'true', type: 'checkbox', isChecked: false, labelContent: labelMessage__soy96, isDisabled: false}))});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.addUserToLicense.soyTemplateName = 'JIRA.Templates.ProjectTemplates.addUserToLicense';
}


JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon = function(opt_data, opt_ignored) {
  var param128 = '' + aui.form.label({forField: opt_data.name, isRequired: opt_data.isRequired, content: opt_data.labelContent}) + aui.form.input({id: opt_data.id, name: opt_data.name, type: 'text', maxLength: opt_data.maxLength, value: opt_data.value}) + '<a class="help-lnk" title="' + soy.$$escapeHtml(opt_data.helpTitle) + '" id="' + soy.$$escapeHtml(opt_data.id) + '-help-icon"><span class="aui-icon aui-icon-help">' + soy.$$escapeHtml(opt_data.helpTitle) + '</span></a>' + ((opt_data.descriptionText) ? aui.form.fieldDescription({message: opt_data.descriptionText}) : '');
  if (opt_data.errorTexts) {
    var errorList152 = opt_data.errorTexts;
    var errorListLen152 = errorList152.length;
    for (var errorIndex152 = 0; errorIndex152 < errorListLen152; errorIndex152++) {
      var errorData152 = errorList152[errorIndex152];
      param128 += aui.form.fieldError({message: errorData152});
    }
  }
  var output = '' + aui.form.fieldGroup({content: param128});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon.soyTemplateName = 'JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon';
}


JIRA.Templates.ProjectTemplates.longTextField = function(opt_data, opt_ignored) {
  var param158 = '' + aui.form.label({forField: opt_data.name, isRequired: opt_data.isRequired, content: opt_data.labelContent}) + aui.form.input({id: opt_data.id, name: opt_data.name, type: 'text', maxLength: opt_data.maxLength, value: opt_data.value, extraClasses: 'long-field'}) + ((opt_data.descriptionText) ? aui.form.fieldDescription({message: opt_data.descriptionText}) : '');
  if (opt_data.errorTexts) {
    var errorList176 = opt_data.errorTexts;
    var errorListLen176 = errorList176.length;
    for (var errorIndex176 = 0; errorIndex176 < errorListLen176; errorIndex176++) {
      var errorData176 = errorList176[errorIndex176];
      param158 += aui.form.fieldError({message: errorData176});
    }
  }
  var output = '' + aui.form.fieldGroup({content: param158});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.longTextField.soyTemplateName = 'JIRA.Templates.ProjectTemplates.longTextField';
}


JIRA.Templates.ProjectTemplates.spinner = function(opt_data, opt_ignored) {
  return '<span id=\'' + soy.$$escapeHtml(opt_data.id) + '\' class=\'icon throbber loading\'/>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.spinner.soyTemplateName = 'JIRA.Templates.ProjectTemplates.spinner';
}


JIRA.Templates.ProjectTemplates.formatAnchor = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.href) + '"' + ((opt_data.title) ? ' title="' + soy.$$escapeHtml(opt_data.title) + '"' : '') + '>' + soy.$$escapeHtml(opt_data.body) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.formatAnchor.soyTemplateName = 'JIRA.Templates.ProjectTemplates.formatAnchor';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/soy/CreateSharedProject.soy' */
// This file was automatically generated from CreateSharedProject.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }


JIRA.Templates.ProjectTemplates.createSharedProjectForm = function(opt_data, opt_ignored) {
  return '<div class="create-shared-project-wrapper"><div class="create-shared-project-form-wrapper">' + aui.form.form({content: '' + aui.form.fieldset({content: '<p>' + soy.$$escapeHtml("Select the existing project that you\x27d like to share configurations with.") + '<a class="help-lnk" title="' + soy.$$escapeHtml("What will be shared?") + '" id="shared-help-icon"><span class="aui-icon aui-icon-help">' + soy.$$escapeHtml("What will be shared?") + '</span></a></p>' + aui.form.fieldGroup({extraClasses: 'project-picker-group', content: '' + aui.form.label({forField: 'project-picker', isRequired: false, content: "Choose a project"}) + aui.form.input({id: 'project-picker', name: 'project', type: 'text'}) + '<div id="project-picker-options" data-suggestions="' + soy.$$escapeHtml(opt_data.projectSuggestions) + '"></div>'}) + '<p class="create-shared-info">' + soy.$$escapeHtml("When a configuration is shared with several projects, it means that any changes made to the configuration will affect all the projects.") + '</p>'}), id: 'create-shared-project-form'}) + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.createSharedProjectForm.soyTemplateName = 'JIRA.Templates.ProjectTemplates.createSharedProjectForm';
}


JIRA.Templates.ProjectTemplates.loading = function(opt_data, opt_ignored) {
  return '<div><div class="dialog-spinner"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.loading.soyTemplateName = 'JIRA.Templates.ProjectTemplates.loading';
}


JIRA.Templates.ProjectTemplates.noProjects = function(opt_data, opt_ignored) {
  return '<p>' + soy.$$escapeHtml("Looks like no other projects exist yet. Please create a brand new project first before trying to share an existing project\x27s configuration.") + '</p>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.noProjects.soyTemplateName = 'JIRA.Templates.ProjectTemplates.noProjects';
}


JIRA.Templates.ProjectTemplates.sharedHelp = function(opt_data, opt_ignored) {
  return '<div class="shared-help"><p><strong>' + soy.$$escapeHtml("What will be shared?") + '</strong></p><p>' + soy.$$escapeHtml("Configuration refers to the set of schemes used by a project") + '</p><ul><li>' + soy.$$escapeHtml("Permission Scheme") + '</li><li>' + soy.$$escapeHtml("Notification Scheme") + '</li><li>' + soy.$$escapeHtml("Issue Security Scheme") + '</li><li>' + soy.$$escapeHtml("Workflow Scheme") + '</li><li>' + soy.$$escapeHtml("Issue Type Scheme") + '</li><li>' + soy.$$escapeHtml("Issue Type Screen Scheme") + '</li><li>' + soy.$$escapeHtml("Field Configuration Scheme") + '</li></ul></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.sharedHelp.soyTemplateName = 'JIRA.Templates.ProjectTemplates.sharedHelp';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/Config.js' */
define('jira/project-templates/config', {
    model: {}
});
AJS.namespace('JPT.ConfigModel', null, require('jira/project-templates/config'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/ProjectKeyGenerator.js' */
define('jira/project-templates/project-key-generator', [
    'jquery',
    'underscore'
], function(
    $,
    _
){
    var ProjectKeyGenerator = {};
    ProjectKeyGenerator.IGNORED_WORDS = ["THE", "A", "AN", "AS", "AND", "OF", "OR"];

    // The (non-ascii) characters used as keys will be replaced with their (ascii) value.
    ProjectKeyGenerator.CHARACTER_MAP = {};
    ProjectKeyGenerator.CHARACTER_MAP[199] = "C"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[231] = "c"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[252] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[251] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[250] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[249] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[233] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[234] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[235] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[232] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[226] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[228] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[224] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[229] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[225] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[239] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[238] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[236] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[237] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[196] = "A"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[197] = "A"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[201] = "E"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[230] = "ae"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[198] = "Ae"; // ®
    ProjectKeyGenerator.CHARACTER_MAP[244] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[246] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[242] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[243] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[220] = "U"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[255] = "Y"; // Ø
    ProjectKeyGenerator.CHARACTER_MAP[214] = "O"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[241] = "n"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[209] = "N"; // ?

    ProjectKeyGenerator.desiredKeyLength = 4;
    ProjectKeyGenerator.maxKeyLength = 10;

    ProjectKeyGenerator.getTotalLength = function getTotalLength(words) {
        return words.join("").length;
    };

    ProjectKeyGenerator.removeIgnoredWords = function removeIgnoredWords(words) {
        return _.reject(words, function(word) {
            return $.inArray(word, ProjectKeyGenerator.IGNORED_WORDS) !== -1;
        });
    };

    ProjectKeyGenerator.createAcronym = function createAcronym(words) {
        var result = "";
        $.each(words, function(i, word) {
            result += word.charAt(0);
        });
        return result;
    };

    ProjectKeyGenerator.getFirstSyllable = function getFirstSyllable(word) {
        // Best guess at getting the first syllable
        // Returns the substring up to and including the first consonant to appear after a vowel
        var pastVowel = false;
        var i;
        for (i = 0; i < word.length; i++) {
            if (ProjectKeyGenerator.isVowelOrY(word[i])) {
                pastVowel = true;
            } else {
                if (pastVowel) {
                    return word.substring(0, i + 1);
                }
            }
        }
        return word;
    };

    ProjectKeyGenerator.isVowelOrY = function isVowelOrY(c) {
        return c && c.length === 1 && c.search("[AEIOUY]") !== -1;
    };

    ProjectKeyGenerator.init = function init(desiredKeyLength, maxKeyLength) {
        ProjectKeyGenerator.desiredKeyLength = desiredKeyLength;
        ProjectKeyGenerator.maxKeyLength = maxKeyLength;
    };

    ProjectKeyGenerator.generate = function generate(name) {
        name = $.trim(name);
        if (!name) {
            return "";
        }

        // Brute-force chunk-by-chunk substitution and filtering.
        var filtered = [];
        for(var i=0, ii=name.length; i<ii; i++) {
            var sub = ProjectKeyGenerator.CHARACTER_MAP[name.charCodeAt(i)];
            filtered.push(sub ? sub : name[i]);
        }
        name = filtered.join('');

        // Split into words
        var words = [];
        $.each(name.split(/\s+/), function(i, word) {
            if (word) {
                // Remove whitespace and punctuation characters (i.e. anything not A-Z)
                word = word.replace(/[^a-zA-Z]/g, "");
                // uppercase the word (NOTE: JavaScript attempts to convert characters like § in to SS)
                word = word.toUpperCase();
                // add the word, should it be worthy.
                word.length && words.push(word);
            }
        });

        // Remove ignored words
        if (ProjectKeyGenerator.desiredKeyLength && ProjectKeyGenerator.getTotalLength(words) > ProjectKeyGenerator.desiredKeyLength) {
            words = ProjectKeyGenerator.removeIgnoredWords(words);
        }

        var key;

        if (words.length == 0) {
            // No words were worthy!
            key = "";
        } else if (words.length == 1) {
            // If we have one word, and it is longer than a desired key, get the first syllable
            var word = words[0];
            if (ProjectKeyGenerator.desiredKeyLength && word.length > ProjectKeyGenerator.desiredKeyLength) {
                key = ProjectKeyGenerator.getFirstSyllable(word);
            } else {
                // The word is short enough to use as a key
                key = word;
            }
        } else {
            // If we have more than one word, just take the first letter from each
            key = ProjectKeyGenerator.createAcronym(words);
        }

        // Limit the length of the key
        if (ProjectKeyGenerator.maxKeyLength && key.length > ProjectKeyGenerator.maxKeyLength) {
            key = key.substr(0, ProjectKeyGenerator.maxKeyLength);
        }

        return key;
    };
    return ProjectKeyGenerator;
});
AJS.namespace('JPT.ProjectKeyGenerator', null, require('jira/project-templates/project-key-generator'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/DialogView.js' */
// Warning!
//This module has a hidden circular dependency -> jira/project-templates/dialog-controller
define('jira/project-templates/dialog-view-impl', [
    'require',
    'backbone',
    'underscore'
], function(
    require,
    Backbone,
    _
){
    var Dialog = AJS.Dialog;
    var Trigger = AJS.trigger;

    return Backbone.View.extend({
        events: {
            "click   .add-project-trigger": "_onClickAddProject",
            "click   .add-demo-project-trigger": "_onClickAddDemoProject",
            "click   .add-workflow-link": "_onClickViewMarketplaceWorkflows",
            "click   #add-project-dialog .add-demo-project-trigger": "_onCreateProjectAddDemoProjectClick",
            "click   #add-project-dialog .import-project-trigger": "_onClickImportProject",
            "click   #add-project-dialog .create-with-shared-config": "_onClickCreateShared",
            "keydown #add-project-dialog .pt-templates-list": "_onKeydownInTemplatesList"
        },

        draw: function() {
            var dialog = new Dialog({
                width: 840,
                height: 400,
                id: "add-project-dialog",
                closeOnOutsideClick: false,
                keypressListener: _.bind(this._onKeyPressed, this)
            });

            var $dialog = dialog.popup.element;

            dialog.addPage("project-templates-page");

            dialog.addHeader("Create project", "add-project-dialog-header");

            dialog.addPanel("ProjectTemplatesListPanel", JIRA.Templates.ProjectTemplates.loadingTemplatesList(), "pt-content");

            this._dialog = dialog;
            this._$dialogElement = $dialog;

            dialog.show();

            return dialog;
        },

        /**
         * Removes this DialogView.
         *
         * @return {*}
         */
        remove: function() {
            this._dialog && this._dialog.remove();
        },

        showErrorMessage: function(message) {
            this._dialog.getPanel(1, 0).html(JIRA.Templates.errorMsg({
                closable: false,
                msg: message
            }));
        },

        get$PTContent: function getPTContent() {
            return this.getDialogController().$dialogElement.find(".pt-content");
        },

        /**
         * Removes this dialog when ESC is pressed. Note that this is called on keydown anywhere within the dialog,
         * including all steps of the wizard, so you want to be careful about what you do in here.
         *
         * @param {jQuery.Event} e the keydown Event
         * @returns {boolean}
         * @private
         */
        _onKeyPressed: function(e) {
            var escapeKey = 27;
            if (this._dialog) {
                if (e.keyCode === escapeKey) {
                    this.getDialogController().hideDialogFromNewUser("dismissed");
                    this._dialog.remove();
                    return false; // preventDefault, don't propagate.
                }
            }

            return true;
        },

        /**
         * Proceeds to the next step of the wizard when the user presses ENTER in the project templates list.
         * Unfortunately in this case we can't rely on browser auto-submit of forms because the focus is not inside a
         * text input/
         *
         * @param {jQuery.Event} e
         * @returns {boolean}
         * @private
         */
        _onKeydownInTemplatesList: function(e) {
            var enterKey = 13;
            if (this._dialog) {
                if (e.keyCode === enterKey) {
                    this._$dialogElement.find(".pt-submit-button:visible").click();
                    return false;
                }
            }

            return true;
        },

        _onClickAddProject: function(event) {
            event.preventDefault();
            this.getDialogController().handleProjectTemplateTriggered();
        },

        _onCreateProjectAddDemoProjectClick: function() {
            Trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.demo.create.project.clicked'});
        },

        _onClickViewMarketplaceWorkflows: function () {
            Trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.viewmarketplaceworkflows.clicked'});
        },

        _onClickAddDemoProject: function(event) {
            event.preventDefault();
            var dialog = this.getDialogController().dialog;
            if (dialog && dialog.popup && dialog.popup.element) {
                dialog.remove();
            }
            this.getDialogController().handleDemoProjectTemplateTriggered();
        },

        _onClickImportProject: function(event) {
            this.getDialogController().hideDialogFromNewUser("importproject");
        },

        _onClickCreateShared: function(event) {
            this.getDialogController().handleCreateShared();
        },

        getDialogController: function() {
            return require('jira/project-templates/dialog-controller');
        }
    });
});

define('jira/project-templates/dialog-view', [
    'jira/project-templates/dialog-view-impl',
    'jquery'
], function(
    DialogViewImpl,
    $
){
    return new DialogViewImpl({ el: $(document) });
});
AJS.namespace('JPT.DialogView', null, require('jira/project-templates/dialog-view'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/DialogController.js' */
// Warning!
// This module has a hidden circular dependencies -> jira/project-templates/select-project-template-controller
//                                                -> jira/project-templates/create-shared-controller
define('jira/project-templates/dialog-controller', [
    'jira/project-templates/dialog-view',
    'jira/project-templates/config',
    'jira/ajs/ajax/smart-ajax',
    'jira/util/data/meta',
    'jira/lib/class',
    'jquery',
    'underscore',
    'wrm/data'
], function(
    DialogView,
    Config,
    SmartAjax,
    Meta,
    Class,
    $,
    _,
    wrmData
){
    var contextPath = AJS.contextPath();
    var isDevMode = AJS.isDevMode;
    var log = AJS.log;

    function triggerAnalytics(name, params) {
        AJS.trigger('analyticsEvent', {name: name, data: params});
    }

    var ptAnalyticsData;
    var getPtAnalyticsData = function () {
        if( !ptAnalyticsData ) {
            ptAnalyticsData = wrmData.claim('com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources.ptAnalyticsData') || {};
        }
        return ptAnalyticsData;
    };

    var DialogController = Class.extend({
        WELCOME_REST_URL: contextPath + "/rest/welcome/1.0/show/welcome",

        initialize: function() {
            _.bindAll(this, 'handleProjectTemplateTriggered', 'hideDialogFromNewUser');

            if (Meta.getBoolean('show-welcome-screen')) {
                this.handleProjectTemplateTriggered();
            }
        },

        handleProjectTemplateTriggered: function() {
            this.demoProject = false;
            triggerAnalytics('jira.project.templates.dialog.create.show');
            this.openWithFirstProjectTemplateOfTypePreSelected();
        },

        handleDemoProjectTemplateTriggered: function() {
            this.demoProject = true;
            var projectTemplatesDeferred = this.getTemplateController().loadDemoProjectTemplatesData();
            this.openWithFirstProjectTemplateOfTypePreSelected(null, projectTemplatesDeferred);
            this._addAnalyticsToCreateDemoShow(projectTemplatesDeferred);
        },

        _addAnalyticsToCreateDemoShow: function (projectTemplatesDeferred) {
            projectTemplatesDeferred.done(function (data) {
                var params = {};

                var getDemoSets = function (data) {
                    return data.projectTemplatesGroupedByType.map(
                        function (ptGroup) {
                            return ptGroup.projectTemplates.map(
                                function (pt) {
                                    return pt.itemModuleCompleteKey
                                }).join();
                        }).join();
                };

                params.demoSets = getDemoSets(data);
                params.instanceCreatedDate = getPtAnalyticsData().instanceCreatedDate;

                triggerAnalytics('jira.project.templates.dialog.create.demo.show', params);
            }.bind(this));
        },

        openWithFirstProjectTemplateOfTypePreSelected: function(projectTypeKey, projectTemplatesDeferred) {
            projectTemplatesDeferred = projectTemplatesDeferred || this.getTemplateController().loadProjectTemplatesData();
            //draw dialog with spinner
            this.dialog  = DialogView.draw();

            projectTemplatesDeferred.fail(_.bind(function (jqXHR) {
                this._handleUnknownErrorOfPTRetrieval();
            }, this));

            projectTemplatesDeferred.done(_.bind(function (data) {
                this.$dialogElement = this.dialog.popup.element;

                // Persist the selected template (e.g. after coming back from a GH installation)
                var selectedTemplate;
                if (!_.isUndefined(Config.model.selectedTemplate)) {
                    selectedTemplate = Config.model.selectedTemplate;
                }
                Config.model = data;
                Config.model.selectedTemplate = selectedTemplate;
                this.getTemplateController().init(data, projectTypeKey);
            }, this));
        },

        handleCreateShared: function() {
            triggerAnalytics('jira.project.templates.dialog.create.shared.clicked');
            this.demoProject = false;
            this.openWithCreateShared();
        },

        openWithCreateShared: function() {
            var CreateSharedController = require('jira/project-templates/create-shared-controller');
            CreateSharedController.initCreateShared();
        },

        callbackWithResize: function(callback) {
            return _.bind(_.wrap(callback, function(originalCallback) {
                originalCallback.call(this);
                this.dialog.updateHeight();
            }), this);
        },

        addPage: function(pageConfig) {
            var page = this.dialog.addPage(pageConfig.name).page[this.dialog.curpage];
            this.dialog.addHeader(pageConfig.title, "add-project-dialog-header");
            this.dialog.addPanel(pageConfig.panelName, "", "pt-content");

            if (pageConfig.backButton) {
                this._addBackButton(page);
            }

            this.dialog.addButton(
                pageConfig.submitButtonText,
                this.callbackWithResize(pageConfig.submitButtonCallback),
                pageConfig.submitButtonClass + " pt-submit-button"
            );
            var $submitButton = this.$dialogElement.find("." + pageConfig.submitButtonClass);
            $submitButton.removeClass("button-panel-button").addClass("aui-button aui-button-primary"); /* button-panel-button class doesn't have disabled styles, using .aui-button instead */
            $submitButton.focus();

            this.dialog.addCancel("Cancel", _.bind(function(event) {
                this.hideDialogFromNewUser("dismissed");

                this.dialog.remove();
            }, this));

            return page;
        },

        _backButtonOnClickCallback: function(page) {
            return _.bind(function() {
                if (this.demoProject) {
                    triggerAnalytics("jira.project.templates.dialog.demo.back");
                } else {
                    triggerAnalytics("jira.project.templates.dialog.create.back");
                }
                var $addProjectWrapper = DialogView.get$PTContent();
                $addProjectWrapper.css('background-image', 'none');

                this.dialog.prevPage();
                page.remove();
                this.dialog.page.pop();
            }, this);
        },

        _addBackButton: function(page) {
            this.dialog.addButton(
                "Back",
                this.callbackWithResize(this._backButtonOnClickCallback(page)),
                "add-project-back-button"
            );
            var $backButton = this.$dialogElement.find(".add-project-back-button");
            $backButton.removeClass("button-panel-button").addClass("aui-button");
        },

        _handleUnknownErrorOfPTRetrieval: function() {
            DialogView.showErrorMessage("An error occurred while trying to contact JIRA");
        },

        hideDialogFromNewUser: function(reason) {
            if (reason === "dismissed") {
                if (this.demoProject) {
                    triggerAnalytics("jira.project.templates.dialog.demo.dismissed");
                } else {
                    triggerAnalytics("jira.project.templates.dialog.create.dismissed");
                }
            } else if (reason === "importproject") {
                triggerAnalytics('jira.project.templates.dialog.import.clicked');
            } else if (reason === "templateselected") {
                if (this.demoProject) {
                    triggerAnalytics("jira.project.templates.dialog.demo.templateselected");
                } else {
                    triggerAnalytics("jira.project.templates.dialog.create.templateselected");
                }
            }

            if (Meta.getBoolean('show-welcome-screen')) {
                $.ajax({
                    url: this.WELCOME_REST_URL + "/" + reason,
                    type: "DELETE",
                    success: function () {
                        if (isDevMode && isDevMode()) {
                            log("don't show project template dialog anymore");
                        }
                    }
                });
            }
        },

        getTemplateController: function() {
            return require('jira/project-templates/select-project-template-controller');
        }
    });

    return new DialogController();
});
AJS.namespace('JPT.DialogController', null, require('jira/project-templates/dialog-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/AddProjectView.js' */
// WARNING
// This module has a hidden circular dependency -> jira/project-templates/add-project-controller
define('jira/project-templates/add-project-view-impl', [
    'jira/project-templates/dialog-controller',
    'jira/project-templates/config',
    'jira/util/events',
    'jira/util/events/types',
    'require',
    'backbone',
    'jquery',
    'underscore'
], function(
    DialogController,
    Config,
    Events,
    EventTypes,
    require,
    Backbone,
    $,
    _
){
    var InlineDialog = AJS.InlineDialog;

    return Backbone.View.extend({
        TIMEOUT_MS: 100,

        postDrawCallbacks: [],

        events: {
            "submit #add-project-form": "onSubmitForm"
        },

        page: undefined,
        isSubmitting: false,

        initialize: function(options) {
            _.bindAll(this, "bindHook");
        },

        addPostDrawCallback: function(callback) {
            this.postDrawCallbacks.push(callback);
        },

        /**
         * Prepare the Dialog to hold the Add Project form; this should only be called once for a selected Project Template.
         * The actual form could be rendered multiple times after unsuccessful validations.
         */
        prepareDialog: function(title) {
            this.page = DialogController.addPage({
                name: "add-project",
                title: title,
                panelName: "add-project",
                backButton: true,
                submitButtonText: "Submit",
                submitButtonCallback: this.onSubmitForm.bind(this),
                submitButtonClass: "add-project-dialog-create-button"
            });
        },

        /**
         * Draw the Add Project form into the passed dialog, as a new screen.
         *
         * This will be triggered on clicking "Next", so should render on the second page.
         */
        draw: function(params) {
            function fixErrorObject(errors) {
                if (!errors.errors) {
                    errors.errors = {}
                }
                return errors;
            }
            this.isSubmitting = false;

            DialogController.dialog.gotoPage(this.page.id);

            var projectTemplateModuleCompleteKey = params.webItemData.projectTemplateModuleCompleteKey;
            var templateGroup = _.find(Config.model.projectTemplatesGroupedByType, function(templateGroup){
                return _.any(templateGroup.projectTemplates, function(template) {
                    return template.itemModuleCompleteKey == projectTemplateModuleCompleteKey
                });
            });
            var applicationName = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.applicationName) || '';
            var usedSeats = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.licenseUsedSeats) || 0;
            var totalSeats = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.licenseTotalSeats) || 0;
            var canUserBeAddedToApplication = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.canUserBeAddedToApplication) || false;
            var canUserUseApplication = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.canUserUseApplication) || false;
            var isOnDemand = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.ondemand) || false;
            var displayCheckbox;
            if (!templateGroup || !templateGroup.applicationInfo) {
                displayCheckbox = false;
            } else {
                displayCheckbox = !canUserUseApplication;
            }

            var soyParameters = {
                maxNameLength: Config.model.maxNameLength,
                maxKeyLength: Config.model.maxKeyLength,
                shouldShowLead: Config.model.shouldShowProjectLead,
                projectTemplateWebItemKey: Config.model.selectedTemplate || params.webItemData.itemModuleCompleteKey,
                projectTemplateModuleKey: projectTemplateModuleCompleteKey,
                projectTemplateTitle: params.webItemData.name,
                projectTemplateDescriptionContent: params.webItemData.longDescriptionContent,
                currentKey: params.currentKey || "",
                currentName: params.currentName || "",
                errors: fixErrorObject(params.errors),
                projectLeadPickerField: {
                    id: 'lead',
                    name: 'lead'
                },
                addUserToLicense: {
                    displayCheckbox: displayCheckbox,
                    disableCheckbox: !canUserBeAddedToApplication,
                    applicationName: applicationName,
                    usedSeats: usedSeats,
                    totalSeats: totalSeats,
                    fieldId: 'licenseUser',
                    fieldName: 'licenseUser',
                    licensingUrl: isOnDemand? '/admin/accessconfig' : '/plugins/servlet/applications/versions-licenses'
                },
                leadOptions: [
                    {
                        selected: true,
                        displayName: params.currentUserDisplayName,
                        optionName: params.currentUserName,
                        avatarURL: params.currentUserAvatarUrl
                    }
                ]
            };
            var addProjectForm = JIRA.Templates.ProjectTemplates.addProjectForm(soyParameters);

            DialogController.dialog.getPanel(this.page.id, 0).html(addProjectForm);

            if (params.webItemData && params.webItemData.backgroundIconUrl) {
                var $addProjectWrapper = DialogController.$dialogElement.find(".pt-content");
                $addProjectWrapper.css('background-image', 'url("' + params.webItemData.backgroundIconUrl + '")');
            }

            var $addProjectForm = $("#add-project-form");
            // fire event to create the Single User Picker
            Events.trigger(EventTypes.NEW_CONTENT_ADDED, [$addProjectForm]);

            this.nameElement = DialogController.$dialogElement.find("#name");
            this.keyElement = DialogController.$dialogElement.find("#key");
            this.keyEditedElement = DialogController.$dialogElement.find("#keyEdited");
            this.leadDisplayElement = DialogController.$dialogElement.find("#lead-field");
            this.leadValueElement = DialogController.$dialogElement.find("#lead");

            var $keyHelpElement = this.keyElement.parent().find(".aui-icon-help");
            if ($keyHelpElement.length) {
                new InlineDialog($keyHelpElement, "project-key-help-popup",
                    function(contents, trigger, show) {
                        contents.html(JIRA.Templates.ProjectTemplates.keyHelp());
                        show();
                    }, {
                        width: 330,
                        offsetX: -30
                    });
            }

            // Input restrictions
            this.keyElement.attr("style", "text-transform: uppercase");

            var AddProjectController = require('jira/project-templates/add-project-controller');

            this.nameElement.focus(_.bind(function(e) {
                this.bindHook(e, AddProjectController.nameTimeout);
            }, this));

            var self = this;
            this.nameElement.change(function (e){
                AddProjectController.validateName();
                self.unbindHook(e);
            });

            this.nameElement.focus();

            this.keyElement.focus(_.bind(function(e) {
                var el = $(e.target);
                el.data("lastValue", el.val());
                this.bindHook(e, AddProjectController.keyTimeout);
            }, this));

            this.keyElement.blur(_.bind(function(e) {
                this.unbindHook(e);
            }, this));

            this.keyElement.change(function() {
                AddProjectController.validateKey();
                AddProjectController.autofillKeyIfNeeded();
            });
            if (!_.isEmpty(this.postDrawCallbacks)) {
                _.each(this.postDrawCallbacks, function(callback) {
                    callback();
                });
            }
            DialogController.dialog.updateHeight();
        },

        /**
         * Submits the "Add Project" form.
         *
         * @param {jQuery.Event} e the submit event
         * @returns {boolean}
         */
        onSubmitForm: function(e) {
            var AddProjectController = require('jira/project-templates/add-project-controller');
            AddProjectController.submit();
            return false;
        },

        get$SubmitButton: function() {
            return DialogController.$dialogElement.find(".add-project-dialog-create-button");
        },

        get$BackButton: function() {
            return DialogController.$dialogElement.find(".add-project-back-button");
        },

        bindHook: function bindHook(e, func) {
            var el = $(e.target), hook;
            hook = _.bind(function() {
                this.unbindHook(e);
                func.apply();
                if (el.is(":visible")) {
                    el.data("checkHook", setTimeout(hook, this.TIMEOUT_MS));
                }
            }, this);
            if (!el.data("checkHook")) {
                el.data("checkHook", setTimeout(hook, 0));
            }
        },

        unbindHook: function(e) {
            var el = $(e.target);
            clearTimeout(el.data("checkHook"));
            el.removeData("checkHook");
        },

        /**
         * Show an error for an input element, in the place of its description.
         *
         * @param $element
         * @param msg
         */
        showInlineError: function($element, msg) {
            if (this.isSubmitting) {
                // while the form is being submitted, don't show any late validation errors
                return;
            }
            var $errorElement = $element.parent().find(".error");
            if (!$errorElement.length) {
                $errorElement = $("<div class='error'></div>");
                $element.parent().append($errorElement);
            }
            $errorElement.text(msg);
            $errorElement.show();
        },

        showInlineErrorForName: function showInlineErrorForName(msg) {
            this.showInlineError(this.nameElement, msg);
        },

        showInlineErrorForKey: function showInlineErrorForKey(msg) {
            this.showInlineError(this.keyElement, msg);
        },

        /**
         * Hide any errors for an input field shown by showInlineError, and its description.
         *
         * @param $element
         */
        hideInlineError: function hideInlineError($element) {
            $element.parent().find(".error").hide();
        },

        hideInlineErrorForName: function hideInlineErrorForName() {
            this.hideInlineError(this.nameElement);
        },

        hideInlineErrorForKey: function hideInlineErrorForKey() {
            this.hideInlineError(this.keyElement);
        },

        setName: function setName(value) {
            this.nameElement.val(value);
        },

        getName: function getName() {
            return this.nameElement.val();
        },

        setKey: function setKey(value) {
            this.keyElement.val(value);
        },

        getKey: function getKey() {
            return this.keyElement.val().toUpperCase();
        },

        getLeadDisplayName: function getLeadDisplayName() {
            return this.leadDisplayElement.val();
        },

        getLeadUserName: function getLeadUserName() {
            return this.leadValueElement.val();
        },

        getAvatarUrlOfSelectedLead: function getAvatarUrlOfSelectedLead() {
            var userAvatarBackGroundProperty = DialogController.$dialogElement.find("#lead-single-select .aui-ss-entity-icon").css('background-image');
            if (!_.isUndefined(userAvatarBackGroundProperty)) {
                var userAvatarUrl = userAvatarBackGroundProperty.match(/^url\((.+)\)$/);
                return (userAvatarUrl && userAvatarUrl[1]) ? userAvatarUrl[1] : "";
            } else {
                return "";
            }
        },

        setKeyEdited: function setKeyEdited(value) {
            this.keyEditedElement.val(value);
        },

        getKeyEdited: function getKeyEdited() {
            return this.keyEditedElement.val();
        },

        setKeyEdited: function setKeyEdited() {
            var key = this.getKey();
            // If the key is manually edited, do not suggest automatically generated keys anymore
            // If the key field is cleared, resume suggesting automatically generated keys
            if (this.keyElement.data("lastValue") !== key) {
                this.keyEditedElement.val((key) ? "true" : "false");
            }
            this.keyElement.data("lastValue", key);
        },

        hasNameErrors: function hasNameErrors() {
            return this.nameElement.parent().find(".error").size() > 0;
        },

        getAddProjectForm: function getAddProjectForm() {
            return $("#add-project-form");
        },

        get$FormFields: function getFormFields() {
            return DialogController.$dialogElement.find(":input");
        },

        enterLoadingState: function showLoadingState() {
            $submitButton = this.get$SubmitButton();
            if (!$submitButton.attr("disabled")) {
                $backButton = this.get$BackButton();
                $submitButton.attr("disabled", "disabled");
                $backButton.attr("disabled", "disabled");
                $backButton.before(
                    JIRA.Templates.ProjectTemplates.spinner({
                        id: "addproject-loading"
                    }));
                this.get$FormFields().attr('disabled', 'disabled');

                this.isSubmitting = true;

                return true;
            } else {
                return false;
            }
        },

        hideLoadingState: function hideLoadingState() {
            DialogController.$dialogElement.find("#addproject-loading").remove();
            this.get$SubmitButton().removeAttr('disabled');
            this.get$BackButton().removeAttr('disabled');
            this.get$FormFields().removeAttr('disabled');
        },

        avoidDirtyFormWarning: function avoidDirtyFormWarning() {
            if ($.fn.removeDirtyWarning) {
                this.getAddProjectForm().removeDirtyWarning();
            }
        },

        hasInlineErrors: function hasInlineErrors() {
            return DialogController.$dialogElement.find(".field-group .error:visible").length != 0;
        }

    });
});
define('jira/project-templates/add-project-view', [
    'jira/project-templates/add-project-view-impl',
    'jira/project-templates/dialog-view',
    'jquery'
], function(
    AddProjectViewImpl,
    DialogView,
    $
) {
    return new AddProjectViewImpl({
        el: $(document),
        dialogView: DialogView
    });
});

AJS.namespace('JPT.AddProjectView', null, require('jira/project-templates/add-project-view'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/AddProjectController.js' */
define('jira/project-templates/add-project-controller-impl', [
    'jira/project-templates/add-project-view',
    'jira/project-templates/project-key-generator',
    'jira/project-templates/dialog-controller',
    'jira/project-templates/config',
    'jira/lib/class',
    'jquery',
    'underscore'
], function (
    AddProjectView,
    ProjectKeyGenerator,
    DialogController,
    Config,    
    Class,
    $,
    _
){
    var contextPath = AJS.contextPath();
    var trigger = AJS.trigger;

    return Class.extend({
        postProjectCreationCallbacks: [],
        projectKeyValidationCallbacks: [],
        projectNamesUpperCased: [],

        init: function (options) {
            this._window = options.window || window; // used for mocking 'window' in QUnit
            _.bindAll(this, "projectCreatedHandler", "projectValidationFailedHandler", "nameTimeout", "keyTimeout", "submit");
        },

        initCreateShared: function (existingProjectData) {
            this.existingProjectData = existingProjectData;
            this._initAddProject("Create with shared configuration");
        },

        initProjectTemplate: function (webItemData) {
            this.existingProjectData = undefined;
            this.webItemData = webItemData;
            this._initAddProject(webItemData.name);
        },

        _initAddProject: function (title) {
            this.desiredKeyLength = 4;
            this.lastKeyValidated = "";

            this._getExistingProjects();
            ProjectKeyGenerator.init(this.desiredKeyLength, Config.model.maxKeyLength);

            AddProjectView.prepareDialog(title);
            AddProjectView.draw({
                webItemData: this.webItemData || {},
                maxKeyLength: Config.model.maxKeyLength,
                maxNameLength: Config.model.maxNameLength,
                currentUserName: Config.model.currentUserName,
                currentUserDisplayName: Config.model.currentUserDisplayName,
                currentUserAvatarUrl: Config.model.currentUserAvatarUrl,
                errors: {}
            });
        },

        _resetProjectLeadValues: function () {
            Config.model.currentUserDisplayName = "";
            Config.model.currentUserName = "";
            Config.model.currentUserAvatarUrl = "";
        },

        _hasFullyConfiguredProjectLead: function () {
            return AddProjectView.getLeadDisplayName() && AddProjectView.getAvatarUrlOfSelectedLead() != "";
        },

        submit: function (event) {
            // This data is retrieved before the input fields are disabled (in enterLoadingState()) to avoid null-pointer exceptions when the fields are empty.
            var formData;
            if (this.existingProjectData) {
                formData = {
                    "key": AddProjectView.getKey(),
                    "name": AddProjectView.getName(),
                    "lead": AddProjectView.getLeadUserName() && AddProjectView.getLeadUserName()[0]
                };
            } else {
                formData = jQuery.param(AddProjectView.getAddProjectForm().serializeArray().map(function(param) {
                    // upper case is "visually" enforced by text-transform: uppercase
                    if (param.name === "key") {
                        param.value = param.value.toUpperCase();
                    }
                    return param
                }));
            }

            if (AddProjectView.hasInlineErrors()) {
                return;
            }

            if (AddProjectView.enterLoadingState()) {
                // store lead so we can repopulate the user picker for when the submit fails
                if (this._hasFullyConfiguredProjectLead()) {
                    Config.model.currentUserDisplayName = AddProjectView.getLeadDisplayName();
                    Config.model.currentUserName = Config.model.currentUserDisplayName ? AddProjectView.getLeadUserName() : "";
                    Config.model.currentUserAvatarUrl = AddProjectView.getAvatarUrlOfSelectedLead();
                } else {
                    this._resetProjectLeadValues();
                }

                if (this.existingProjectData) {
                    $.ajax({
                        url: contextPath + "/rest/project-templates/1.0/createshared/" + this.existingProjectData.existingProjectId,
                        type: "POST",
                        contentType: "application/json",
                        data: JSON.stringify(formData)
                    }).then(this.projectCreatedHandler, this.projectValidationFailedHandler);
                } else {
                    $.ajax({
                        url: contextPath +
                            (this.webItemData.demoProject ?
                                "/rest/jira-importers-plugin/1.0/demo/create" :
                                "/rest/project-templates/1.0/templates"),
                        type: "POST",
                        data: formData,
                        headers: {
                            "X-Atlassian-Token": "nocheck"
                        }
                    }).then(this.projectCreatedHandler, this.projectValidationFailedHandler);
                }
            }
        },

        registerPostProjectCreationCallback: function (callback) {
            this.postProjectCreationCallbacks.push(callback);
        },

        registerProjectKeyValidationCallback: function (callback) {
            this.projectKeyValidationCallbacks.push(callback);
        },

        localStoragePrefix: "jira.projecttemplates.",

        projectCreatedHandler: function (data) {
            if (this.existingProjectData) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.shared.project.create.success'});
            } else if (this.webItemData.demoProject) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.demo.success'});
            } else {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.project.success'});
            }
            AddProjectView.avoidDirtyFormWarning();

            // Put the created projects into local storage
            var localStoragePrefix = this.localStoragePrefix;
            var remoteProjectTypes = ["confluenceProject", "fisheyeProject", "crucibleProject", "bambooProject"];
            _.map(remoteProjectTypes, function (remoteProject) {
                if (data.remoteProjectLinks && data.remoteProjectLinks[remoteProject]) {
                    localStorage.setItem(localStoragePrefix + remoteProject, data.remoteProjectLinks[remoteProject]);
                }
            });


            // If there are any post Project Created callbacks registered, call these. Otherwise redirect to the desired return URL.
            if (!_.isEmpty(this.postProjectCreationCallbacks)) {
                DialogController.dialog.addPage("post-project-created-page");
                _.each(this.postProjectCreationCallbacks, function (callback) {
                    callback(DialogController.dialog, data.returnUrl, data.projectId, data.projectKey, data.projectName);
                });
            } else {
                this._window.location = contextPath + data.returnUrl;
            }
        },

        projectValidationFailedHandler: function (jqXhr, textStatus) {
            if (this.existingProjectData) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.shared.project.create.failure'});
            } else if (this.webItemData.demoProject) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.demo.failure'});
            } else {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.project.failure'});
            }

            var errors = {};
            if (this.isBadRequest(jqXhr)) {
                errors = JSON.parse(jqXhr.responseText);
            } else if (this.isUnDefinedServerSideError(jqXhr)) {
                errors = {"errorMessages": ["Hmm... we couldn\'t create your project due to an unknown error. Try refreshing the page to start again."]}
            } else if (this.isDefinedServerSideError(jqXhr)) {
                var errorResponse = JSON.parse(jqXhr.responseText);
                // Project template configuration threw an exception: Project has been created but the template hasn't been configured
                JIRA.Messages.showReloadErrorMsg(errorResponse.message);
                AddProjectView.avoidDirtyFormWarning();
                this._window.location = contextPath + errorResponse.returnUrl;
                // Remain in loading state while refreshing.
                return;
            } else if (this.isTimeoutError(textStatus)) {
                errors = {"errorMessages": ["Request timeout when creating project"]}
            } else {
                // Different kind of error. Let's generate an errors object with a general error that contains the right information
                errors = {"errorMessages": [AJS.format("Error creating project, {0}", jqXhr.responseText)]}
            }

            AddProjectView.draw({
                webItemData: this.webItemData || {},
                errors: errors,
                currentName: AddProjectView.getName(),
                currentKey: AddProjectView.getKey(),
                currentUserDisplayName: Config.model.currentUserDisplayName,
                currentUserName: Config.model.currentUserName,
                currentUserAvatarUrl: Config.model.currentUserAvatarUrl
            });

            AddProjectView.hideLoadingState();
        },

        isBadRequest: function(jqXhr) {
            return (jqXhr.status === 400) ;
        },

        isUnDefinedServerSideError: function(jqXhr){
            if (jqXhr.status === 500) {
                try {
                    JSON.parse(jqXhr.responseText);
                } catch(e) {
                    return true;
                }
            }
            return false;
        },

        isDefinedServerSideError: function(jqXhr) {
            return jqXhr.status === 500 && !_.isUndefined(JSON.parse(jqXhr.responseText).message) ;
        },

        isTimeoutError: function(textStatus) {
            return textStatus === "timeout" ;
        },

        _updateAndValidateKey: function updateKey(key) {
            AddProjectView.setKey(key);
            this.validateKey();
        },

        _shouldUpdateKey: function _shouldUpdateKey() {
            return (AddProjectView.getKeyEdited() != "true");
        },

        autofillKeyIfNeeded: function autofillKeyIfNeeded() {
            if (this._shouldUpdateKey()) {
                var key = ProjectKeyGenerator.generate(AddProjectView.getName());
                // JRADEV-10797 - Rather than validate the key,
                // we'll pretend that a key is always invalid if it's less than 1 character long.
                if (key.length > 1) {
                    this._updateAndValidateKey(key);
                } else {
                    // Blank the key without validation.
                    AddProjectView.setKey("");
                }
            }
        },

        _doesProjectNameExists: function (name) {
            var x;
            for (x in this.projectNamesUpperCased) {
                if (name.toUpperCase() == this.projectNamesUpperCased[x]) {
                    return true;
                }
            }

            return false;
        },

        validateName: function () {
            var name = $.trim(AddProjectView.getName());

            if (!name) {
                return;
            }

            if (name.length < Config.model.minNameLength) {
                AddProjectView.showInlineErrorForName(AJS.format("The project name should be at least {0} characters in length.", Config.model.minNameLength));
                return;
            }

            if (name.length > Config.model.maxNameLength) {
                AddProjectView.showInlineErrorForName(AJS.format("The project name must not exceed {0} characters in length.", Config.model.maxNameLength));
                return;
            }

            if (this._doesProjectNameExists(name)) {
                AddProjectView.showInlineErrorForName("A project with that name already exists.");
                return;
            }

            AddProjectView.hideInlineErrorForName();
        },

        _performKeyValidationChecks: function (key) {
            var validationChecksDeferred = $.ajax({
                url: contextPath + "/rest/api/latest/projectvalidate/key?key=" + key.toUpperCase()
            });

            validationChecksDeferred.done(_.bind(function (errors) {
                if (errors.errors && errors.errors["projectKey"]) {
                    AddProjectView.showInlineErrorForKey(errors.errors["projectKey"]);
                } else {
                    var foundError = false;
                    _.each(this.projectKeyValidationCallbacks, function (callback) {
                        var errors = callback(key.toUpperCase());
                        if (errors.errors && errors.errors["projectKey"]) {
                            foundError = true;
                            AddProjectView.showInlineErrorForKey(errors.errors["projectKey"]);
                        }
                    });
                    if (!foundError) {
                        AddProjectView.hideInlineErrorForKey();
                    }
                }
            }, this));
        },

        validateKey: function validateKey() {
            var key = AddProjectView.getKey();

            // Only validate the key if it has changed since the last time we validated it
            if (this.lastKeyValidated === key) {
                return;
            }

            if (key) {
                this.lastKeyValidated = key;
                this._performKeyValidationChecks(key);
            } else {
                AddProjectView.hideInlineErrorForKey();
            }
        },

        nameTimeout: function nameTimeout() {
            this.autofillKeyIfNeeded();
        },

        keyTimeout: function keyTimeout() {
            AddProjectView.setKeyEdited();
        },

        _getExistingProjects: function () {
            // Avoid retrieving the list twice (e.g. after hitting the 'Back' button and selecting new template)
            if (this.projectNamesUpperCased.length > 0) {
                return this.projectNamesUpperCased;
            }

            var existingProjectsDeferred = $.ajax({
                url: contextPath + "/rest/api/latest/project"
            });

            existingProjectsDeferred.done(_.bind(function (projects) {
                this.projectNamesUpperCased = _.map(projects, function (project) {
                    return project.name.toUpperCase();
                });
            }, this));
        }
    });
});
define('jira/project-templates/add-project-controller', [
    'jira/project-templates/add-project-controller-impl',
    'jquery'
], function(
    AddProjectControllerImpl,
    $
){
    return new AddProjectControllerImpl({el: $(document)});
});
AJS.namespace('JPT.AddProjectController', null, require('jira/project-templates/add-project-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/TemplateInfoView.js' */
// Warning!
// This module has a hidden circular dependency -> jira/project-templates/template-info-controller
define('jira/project-templates/template-info-view', [
    'jira/project-templates/dialog-controller',
    'require',
    'backbone',
    'jquery',
    'underscore'
], function(
    DialogController,
    require,
    Backbone,
    $,
    _
){
    var trigger = AJS.trigger;

    return Backbone.View.extend({

        initialize: function(options) {
            _.bindAll(this, "draw", "onNext")
        },

        draw: function(templatePath, name) {
            var page = DialogController.addPage({
                name: "template-info",
                title: name,
                panelName: "template-info",
                backButton: true,
                submitButtonText: "Select",
                submitButtonCallback: this.onNext,
                submitButtonClass: "template-info-dialog-create-button"
            });

            var templateInfoPanel = this._nameToObj(templatePath)();
            DialogController.dialog.getPanel(page.id, 0).html(templateInfoPanel);

            DialogController.dialog.gotoPage(page.id);
        },

        _nameToObj: function(name) {
            return _.reduce(name.split('.'), function(obj, name) { if (obj) return obj[name]; }, window);
        },

        onNext: function(e) {
            trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.templateinfo.next'});
            // This is a workaround to resolve circular dependencies between these two modules.
            var TemplateInfoController = require('jira/project-templates/template-info-controller');
            TemplateInfoController.next();
            return false;
        }
    });
});
AJS.namespace('JPT.TemplateInfoView', null, require('jira/project-templates/template-info-view'));
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/TemplateInfoController.js' */

define('jira/project-templates/template-info-controller', [
    'jira/project-templates/template-info-view',
    'jira/lib/class',
    'require',
    'underscore'
], function(
    TemplateInfoView,
    Class,
    require,
    _
){
    var TemplateInfoController = Class.extend({

        init: function(options) {
            _.bindAll(this, "initTemplateInfo", "next");
        },

        initTemplateInfo: function(projectTemplateData) {
            this.projectTemplateData = projectTemplateData;

            var infoView = new TemplateInfoView();
            infoView.draw(projectTemplateData.infoSoyPath, projectTemplateData.name);
        },

        next: function() {
            var SelectProjectTemplateController = require('jira/project-templates/select-project-template-controller');
            SelectProjectTemplateController.openAddProjectPage(this.projectTemplateData);
        }
    });
    return new TemplateInfoController();
});
AJS.namespace('JPT.TemplateInfoControllerImpl', null, require('jira/project-templates/template-info-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/SelectProjectTemplateView.js' */
// Warning!
// This module has a hidden circular dependency -> jira/project-templates/select-project-template-controller
define('jira/project-templates/select-project-template-view', [
    'jira/project-templates/dialog-controller',
    'jira/project-templates/config',
    'jira/featureflags/feature-manager',
    'require',
    'backbone',
    'jquery',
    'underscore'
], function(
    DialogController,
    Config,
    featureManager,
    require,
    Backbone,
    $,
    _
){
    var contextPath = AJS.contextPath();
    var preventDefault = AJS.preventDefault;

    return {
        ROW_LENGTH: 2,
        DIALOG_BODY_CLASS: "select-project-templates-page",
        DIALOG_WIDTH: 800,

        draw: function(data, projectType) {
            var SelectProjectTemplateController = require('jira/project-templates/select-project-template-controller');
            this.page = DialogController.addPage({
                name: this.DIALOG_BODY_CLASS,
                title: data.demoProjects ? "Create project with sample data" : "Create project",
                panelName: "ProjectTemplatesListPanel",
                backButton: false,
                submitButtonText: "Next",
                submitButtonCallback: SelectProjectTemplateController.dialogSubmitted,
                submitButtonClass: "create-project-dialog-create-button"
            });

            function getHtml() {
                if (SelectProjectTemplateController.isProjectTypesEnabled(data)) {
                    return JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType({
                        projectTemplatesByType: data.projectTemplatesGroupedByType
                    });
                }
                return JIRA.Templates.ProjectTemplates.renderProjectTemplates({
                    projectTemplates: data.projectTemplates
                });
            }

            DialogController.dialog.getPanel(this.page.id, 0).html(getHtml());

            if (Config.model.projectCount >= 2 && !data.demoProjects) {
                $(JIRA.Templates.ProjectTemplates.addWorkflowsLink({
                    baseUrl : contextPath
                })).appendTo(DialogController.$dialogElement.find(".dialog-title"));
            }

            var $nextButton = DialogController.$dialogElement.find(".create-project-dialog-create-button");
            var self = this;
            this.getTemplateItems().click(function() {
                var $this = $(this);
                $this.addClass("selected");
                self.getTemplateItems().not(this).removeClass("selected");
            }).dblclick(function() {
                $nextButton.click();
            }).focus(function () {
                $(this).click();
            });

            var $templatesContainer = this.get$TemplatesContainer();

            if (!data.demoProjects) {
                $(JIRA.Templates.ProjectTemplates.footerLinks({
                    showDemoLink: featureManager.isFeatureEnabled("jira.onboarding.cyoa")
                }))
                        .prependTo(DialogController.$dialogElement.find(".dialog-button-panel"));
            }

            this.bindKeyboardEvents($templatesContainer);

            if(SelectProjectTemplateController.isProjectTypesEnabled(data)) {
                if((data.projectTemplatesGroupedByType).length == 0) $nextButton.attr("disabled", "disabled");
            } else {
                if((data.projectTemplates).length == 0) $nextButton.attr("disabled", "disabled");
            }

            this.focusOnFirstTemplate($templatesContainer, projectType);

            DialogController.dialog.updateHeight();
            this.truncateTemplateDescriptions();
            this.resizeTemplateWidths();
        },

        get$TemplatesContainer: function() {
            return DialogController.$dialogElement.find('.templates');
        },

        focusOnFirstTemplate: function($templatesContainer, projectType) {
            if (projectType) {
                this.getFirstTemplateItemOfProjectType(projectType).click();
            } else {
                this.getFirstTemplateItem().click();
            }
            // Make sure me don't loose the focus because of any other interactions
            setTimeout(function (){
                $templatesContainer.focus();
            }, 0);
        },

        getSelectedTemplateData: function() {
            var $selectedTemplate = DialogController.$dialogElement.find(".template.selected");

            return $selectedTemplate.data();
        },

        /**
         * Converts arrow directions into sibling movement amounts in a grid.
         * @param which - the code of the key pressed
         * @return {Number} the amount to move, or 0 if no move should occur for this key code
         */
        getMoveDeltaForKey: function (which) {
            switch (which) {
                case 37: return -1; // left
                case 39: return +1; // right
                case 38: return -this.ROW_LENGTH; // up
                case 40: return +this.ROW_LENGTH; // down
            }
            return 0;
        },

        /**
         * Key-bindings on arrow-keys to change the selected template in the template container.
         */
        bindKeyboardEvents: function ($container) {
            $container.bind("keydown", _.bind(function (e) {
                var delta = this.getMoveDeltaForKey(e.which);
                if (delta) {
                    this.moveSelection($container, delta);
                    return preventDefault(e);
                }
            }, this));
        },

        /**
         * Move the selection in the template container forward or backward by a specified number of templates
         * @param container the template container jQuery object
         * @param delta - positive to move forward, negative to move backward
         */
        moveSelection: function (container, delta) {
            var $results = container.find('.template');
            var $selected = $results.filter('.selected');
            var index = $results.index($selected) + delta;
            if (index < $results.length && index >= 0) {
                var $next = $results.eq(index);
                $next.click().focus();

                this.scrollToSelectedElement($next);
            }
        },

        scrollToSelectedElement: function($selected) {
            var $itemContainer = $(".dialog-panel-body.pt-content");
            var itemContainerTopPosition = $itemContainer.offset().top;
            var nextTopPosition = $selected.offset().top;
            var nextBottomPosition = nextTopPosition + $selected.height();
            var itemContainerBottomPosition = itemContainerTopPosition + $itemContainer.height();

            if (nextTopPosition < itemContainerTopPosition) {
                $itemContainer.scrollTop($itemContainer.scrollTop() - (itemContainerTopPosition - nextTopPosition));
            } else if(nextBottomPosition > (itemContainerTopPosition + $itemContainer.height())) {
                $itemContainer.scrollTop($itemContainer.scrollTop() + nextBottomPosition - itemContainerBottomPosition);
            }
        },

        get$NextButton: function() {
            return DialogController.$dialogElement.find(".create-project-dialog-create-button");
        },

        disableNextButton: function() {
            this.get$NextButton().attr('disabled','disabled');
        },

        truncateTemplateDescriptions: function() {
            var locale = AJS.Meta.get("user-locale");
            var wrap = "word";
            if (locale === "ja_JP") {
                wrap = "letter";
            }
            DialogController.$dialogElement.find(".template-description").each(function() {
                $(this).dotdotdot({
                    'wrap': wrap,
                    'lastCharacter': {
                        'remove'		: [ ' ', ',', ';', '.', '!', '?', '。' ],
                        'noEllipsis'	: []
                    }
                });
            });
        },

        getTemplatesDialogContainer: function() {
            return DialogController.$dialogElement
                    .find("." + this.DIALOG_BODY_CLASS)
                    .find(".dialog-panel-body.pt-content")
                    .get(0);
        },

        getFirstTemplateItem: function() {
            return this.getTemplateItems().first();
        },

        getFirstTemplateItemOfProjectType: function(projectType) {
            return this.getTemplateItems().filter("#project-template-group-" + projectType + " *").first();
        },

        getTemplateItems: function() {
            return DialogController.$dialogElement.find(".template");
        },

        widthOfScrollbarForElement: function(el) {
            var visibleWidth = el.offsetWidth;
            var visibleWidthWithoutBorders = el.clientWidth;

            return visibleWidth - visibleWidthWithoutBorders;
        },

        widthOfDialogAvailableForTemplateList: function() {
            var dialogScrollbarWidth = this.widthOfScrollbarForElement(this.getTemplatesDialogContainer());

            return this.DIALOG_WIDTH - dialogScrollbarWidth;
        },

        widthOfTemplateItem: function() {
            var maxWidthForEachItem = this.widthOfDialogAvailableForTemplateList() / this.ROW_LENGTH;

            return maxWidthForEachItem - this.borderWidthOfTemplateItem();
        },

        borderWidthOfTemplateItem: function() {
            var templateItemBorderWidthString = this.getFirstTemplateItem().css("border-top-width");

            return parseInt(templateItemBorderWidthString, 10);
        },

        resizeTemplateWidths: function() {
            this.getTemplateItems().each(_.bind(function(index, el) {
                $(el).css("width", this.widthOfTemplateItem());
            }, this));
        }
    };
});
AJS.namespace('JPT.SelectProjectTemplateView', null, require('jira/project-templates/select-project-template-view'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/SelectProjectTemplateController.js' */
define('jira/project-templates/select-project-template-controller', [
    'jira/project-templates/select-project-template-view',
    'jira/project-templates/template-info-controller',
    'jira/project-templates/add-project-controller',
    'jira/project-templates/dialog-controller',
    'jira/project-templates/dialog-view',
    'jira/project-templates/config',
    'wrm/context-path',
    'jquery',
    'underscore'
], function(
    SelectProjectTemplateView,
    TemplateInfoController,
    AddProjectController,
    DialogController,
    DialogView,
    Config,
    ContextPath,
    $,
    _
){
    var contextPath = ContextPath();
    var SelectProjectTemplateController = {
        init: function init(data, projectTypeKey) {
            SelectProjectTemplateView.draw(data, projectTypeKey);
        },

        /**
         * Returns true if project types have been enabled on the server.
         * @param data the model returned by the server
         * @returns {boolean} true if project types have been enabled on the server.
         */
        isProjectTypesEnabled: function isProjectTypesEnabled(data) {
            return data.projectTemplatesGroupedByType != null;
        },

        /**
         * Return a Promise that others can hook into that returns the data required.
         */
        loadProjectTemplatesData: function loadProjectTemplatesData() {
            // Perform AJAX request for web items in the dialog and return them.
            return $.ajax({
                url: contextPath + "/rest/project-templates/1.0/templates",
                type: "GET"
            });
        },

        loadDemoProjectTemplatesData: function loadProjectTemplatesData() {
            // Perform AJAX request for web items in the dialog and return them.
            return $.ajax({
                url: contextPath + "/rest/project-templates/1.0/templates/demo-projects",
                type: "GET"
            }).then(function(result) {
                result.demoProjects = true;
                return result;
            });
        },

        dialogSubmitted: function dialogSubmitted() {
            var projectTemplateData = SelectProjectTemplateView.getSelectedTemplateData();

            DialogController.hideDialogFromNewUser("templateselected");

            SelectProjectTemplateController.raiseAtlassianEvent(projectTemplateData.itemModuleCompleteKey);

            if (!_.isUndefined(projectTemplateData.infoSoyPath)) {
                TemplateInfoController.initTemplateInfo(projectTemplateData);
            } else {
                SelectProjectTemplateController.openAddProjectPage(projectTemplateData);
            }
        },

        openAddProjectPage: function openAddProjectPage(projectTemplateData) {
            if (!projectTemplateData) {
                // Null data? How did you get here? It should be impossible to have no selected item.
                DialogView.showErrorMessage("An error occurred while trying to contact JIRA");
                return;
            }

            // Should the template key be missing, go to the project configuration step
            if (projectTemplateData.createProject) {
                AddProjectController.initProjectTemplate(projectTemplateData);
                // Otherwise, no template key provided: fire an event passing the dialog, so the plugin can choose what to do next
            } else {
                DialogController.dialog.addPage("blank-template-page");
                $("body").trigger(projectTemplateData.itemModuleCompleteKey, DialogController.dialog);
            }
        },

        raiseAtlassianEvent: function raiseAtlassianEvent(projectTemplateModuleKey) {
            Config.model.selectedTemplate = projectTemplateModuleKey;
            if (AJS.EventQueue) {
                AJS.EventQueue.push({
                    name: "projecttemplates.templateselected",
                    properties: {
                        selectedTemplate: projectTemplateModuleKey
                    }
                });
            }
        }
    };
    return SelectProjectTemplateController;
});
AJS.namespace('JPT.SelectProjectTemplateController', null, require('jira/project-templates/select-project-template-controller'));
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/CreateSharedView.js' */
// Warning!
// This module has a hidden circular dependency -> jira/project-templates/create-shared-controller
define('jira/project-templates/create-shared-view', [
    'jira/project-templates/dialog-controller',
    'jira/project-templates/dialog-view',
    'jira/ajs/select/scrollable-single-select',
    'jira/ajs/select/suggestion-collection-model',
    'require',
    'backbone',
    'jquery'
], function(
    DialogController,
    DialogView,
    ScrollableSingleSelect,
    SuggestionCollectionModel,
    require,
    Backbone,
    $
){
    "use strict";

    var InlineDialog = AJS.InlineDialog;
    var trigger = AJS.trigger;

    var CreateSharedView = Backbone.View.extend({
        events: {
            "submit #create-shared-project-form": "onSubmitForm"
        },

        page: undefined,

        /**
         * Prepare the Dialog to hold the Create Shared Project form; this should only be called once.
         */
        prepareDialog: function(title) {
            var CreateSharedController = require('jira/project-templates/create-shared-controller');
            this.page = DialogController.addPage({
                name: "create-shared-project",
                title: title,
                panelName: "create-shared-project",
                backButton: true,
                submitButtonText: "Next",
                submitButtonCallback: CreateSharedController.dialogSubmitted,
                submitButtonClass: "create-shared-dialog-button"
            });
        },

        /**
         * Draw the Add Project form into the passed dialog, as a new screen.
         *
         * This will be triggered on clicking "Next", so should render on the second page.
         */
        draw: function(params) {
            DialogController.dialog.gotoPage(this.page.id);

            var createSharedForm = JIRA.Templates.ProjectTemplates.createSharedProjectForm({
                "projectSuggestions": JSON.stringify(params.projectSuggestions)
            });

            DialogController.dialog.getPanel(this.page.id, 0).html(createSharedForm);

            this._createProjectPicker();

            var $sharedHelpElement = DialogController.$dialogElement.find("#shared-help-icon");
            if ($sharedHelpElement.length) {
                new InlineDialog($sharedHelpElement, "shared-project-help-popup",
                        function(contents, trigger, show) {
                            contents.html(JIRA.Templates.ProjectTemplates.sharedHelp());
                            show();
                        }, {
                            width: 330,
                            offsetX: -30
                        });
            }

            DialogController.$dialogElement.find(".dialog-button-panel button").removeAttr("disabled");
        },

        showProjectMissingError: function () {
            this._clearFormErrors();

            this._getProjectPickerInput().after(aui.form.fieldError({
                extraClasses: 'project-picker-missing-error',
                message: "Please select an existing project first."
            }));
        },

        drawEmptyInfo: function() {
            var noProjects = JIRA.Templates.ProjectTemplates.noProjects();
            DialogController.dialog.getPanel(this.page.id, 0).html(noProjects);

            DialogController.$dialogElement.find(".dialog-button-panel button").hide();
        },

        drawError: function(message) {
            DialogController.dialog.getPanel(this.page.id, 0).html(JIRA.Templates.errorMsg({
                closable: false,
                msg: message
            }));
        },

        drawLoading: function() {
            DialogController.dialog.gotoPage(this.page.id);

            var addProjectForm = JIRA.Templates.ProjectTemplates.loading();

            DialogController.dialog.getPanel(this.page.id, 0).html(addProjectForm);

            DialogController.$dialogElement.find(".dialog-spinner").spin();
            DialogController.$dialogElement.find(".dialog-button-panel button").attr("disabled", "disabled");
        },

        _clearFormErrors: function() {
            DialogController.$dialogElement.find(".project-picker-missing-error").remove();
        },

        _getProjectPickerInput: function() {
            return DialogController.$dialogElement.find("#project-picker");
        },

        onSubmitForm: function(e) {
            this._clearFormErrors();
            var CreateSharedController = require('jira/project-templates/create-shared-controller');
            CreateSharedController.dialogSubmitted();
            return false;
        },

        _getExtraInfoMessage: function() {
            return DialogController.$dialogElement.find(".create-shared-info");
        },

        _createProjectPicker: function() {
            this._getExtraInfoMessage().hide();
            this.projectSelect = new ScrollableSingleSelect({
                element: this._getProjectPickerInput(),
                revertOnInvalid: true,
                pageSize: 50,
                pagingThreshold: 100,
                model: SuggestionCollectionModel
            });

            this.projectSelect.$field.focus();

            var self = this;
            this._getProjectPickerInput().on("selected", function(e, selected) {
                if(selected.value()) {
                    trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.shared.project.selected'});
                    self._getExtraInfoMessage().show();
                }
            });
        },

        getSelectedProject: function() {
            return this.projectSelect.getSelectedDescriptor() && this.projectSelect.getSelectedDescriptor().value();
        }
    });

    return new CreateSharedView({
        el: $(document),
        dialogView: DialogView
    });
});
AJS.namespace('JPT.CreateSharedView', null, require('jira/project-templates/create-shared-view'));
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/CreateSharedController.js' */
define('jira/project-templates/create-shared-controller-impl', [
    'jira/project-templates/add-project-controller',
    'jira/project-templates/create-shared-view',
    'jira/lib/class',
    'jquery',
    'underscore'
], function(
    AddProjectController,
    CreateSharedView,
    Class,
    $,
    _
) {
    "use strict";

    var contextPath = AJS.contextPath();

    return Class.extend({

        init: function (options) {
            this._window = options.window || window; // used for mocking 'window' in QUnit
            _.bindAll(this, "dialogSubmitted");
        },

        initCreateShared: function () {
            CreateSharedView.prepareDialog("Create with shared configuration");

            var self = this;
            this._getProjectSuggestions().done(function (resp) {
                if (self._hasSuggestions(resp)) {
                    CreateSharedView.draw({projectSuggestions: resp});
                } else {
                    CreateSharedView.drawEmptyInfo();
                }
            }).fail(function () {
                CreateSharedView.drawError("An error occurred while trying to contact JIRA");
            });

            CreateSharedView.drawLoading();
        },

        _hasSuggestions: function (projectSuggestions) {
            var hasSuggestions = false;
            $.each(projectSuggestions, function (i, group) {
                if (group && group.items && group.items.length > 0) {
                    hasSuggestions = true;
                }
            });
            return hasSuggestions;
        },

        _getProjectSuggestions: function () {
            return $.ajax({
                url: contextPath + "/rest/project-templates/1.0/createshared"
            });
        },

        dialogSubmitted: function () {
            var selectedProject = CreateSharedView.getSelectedProject();
            if (selectedProject) {
                AddProjectController.initCreateShared({existingProjectId: selectedProject});
            } else {
                CreateSharedView.showProjectMissingError();
            }
        }
    });
});
define('jira/project-templates/create-shared-controller', [
    'jira/project-templates/create-shared-controller-impl',
    'jquery'
], function(
    CreateSharedControllerImpl,
    $
){
    return new CreateSharedControllerImpl({el: $(document)});
});
AJS.namespace('JPT.CreateSharedController', null, require('jira/project-templates/create-shared-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/RemoteProjectsCreatedMessage.js' */
var $ = require('jquery');
$(function () {

    var format = AJS.format;
    var AddProjectController = require('jira/project-templates/add-project-controller');

    var confluenceProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "confluenceProject");
    var fishEyeProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "fisheyeProject");
    var crucibleProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "crucibleProject");
    var bambooProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "bambooProject");

    localStorage.removeItem(AddProjectController.localStoragePrefix + "confluenceProject");
    localStorage.removeItem(AddProjectController.localStoragePrefix + "fisheyeProject");
    localStorage.removeItem(AddProjectController.localStoragePrefix + "crucibleProject");
    localStorage.removeItem(AddProjectController.localStoragePrefix + "bambooProject");

    var message;
    function formatAnchor(link, label) {
        return JIRA.Templates.ProjectTemplates.formatAnchor({
            href: link,
            body: label,
            title: label
        });
    }
    function createProjectLinks(confluenceProjectLink, fecruProjectLink, crucibleProjectLink, bambooProjectLink) {
        var links = [];
        links.push("a JIRA project");
        if (confluenceProjectLink) {
            links.push(formatAnchor(confluenceProjectLink, "a Confluence space"));
        }
        if (fecruProjectLink) {
            links.push(formatAnchor(fecruProjectLink, "a FishEye repository"));
        }
        if (crucibleProjectLink) {
            links.push(formatAnchor(crucibleProjectLink, "a Crucible project"));
        }
        if (bambooProjectLink) {
            links.push(formatAnchor(bambooProjectLink, "a Bamboo project"));
        }
        return links;
    }
    function createMessage(confluenceProjectLink, fecruProjectLink, crucibleProjectLink, bambooProjectLink) {
        var title = "The following entities were created: {0} and {1}.";
        var projectLinks = createProjectLinks(confluenceProjectLink, fecruProjectLink, crucibleProjectLink, bambooProjectLink);
        var lastLink = projectLinks.pop();
        return (projectLinks.length > 0) ? format(title, projectLinks.join(", "), lastLink) : null;
    }
    function scrollTo(selector) {
        var settingsOffset = $(selector).offset();
        if (settingsOffset) {
            window.scrollTo(settingsOffset.left, settingsOffset.top);
        }
    }

    if (confluenceProjectLink || fishEyeProjectLink || crucibleProjectLink || bambooProjectLink) {
        message = createMessage(confluenceProjectLink, fishEyeProjectLink, crucibleProjectLink, bambooProjectLink);
        if (message) {
            JIRA.Messages.showSuccessMsg(message, {
                closeable:true
            });
        }
        scrollTo("#project-config-webpanel-summary-settings");
    }
});;
;
/* module-key = 'com.atlassian.plugins.jira-project-creation:project-creation-resources', location = '/js/lib/ajaxHooks/xdr.js' */
/**
 Copyright 2012 Julian Aubourg <j@ubourg.net>

 https://github.com/jaubourg/ajaxHooks

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
if ( window.XDomainRequest ) {
    jQuery.ajaxTransport(function( s ) {
        if ( s.crossDomain && s.async ) {
            if ( s.timeout ) {
                s.xdrTimeout = s.timeout;
                delete s.timeout;
            }
            var xdr;
            return {
                send: function( _, complete ) {
                    function callback( status, statusText, responses, responseHeaders ) {
                        xdr.onload = xdr.onerror = xdr.ontimeout = jQuery.noop;
                        xdr = undefined;
                        complete( status, statusText, responses, responseHeaders );
                    }
                    xdr = new XDomainRequest();
                    xdr.onload = function() {
                        callback( 200, "OK", { text: xdr.responseText }, "Content-Type: " + xdr.contentType );
                    };
                    xdr.onerror = function() {
                        callback( 404, "Not Found" );
                    };
                    xdr.onprogress = jQuery.noop;
                    xdr.ontimeout = function() {
                        callback( 0, "timeout" );
                    };
                    xdr.timeout = s.xdrTimeout || Number.MAX_VALUE;
                    xdr.open( s.type, s.url );
                    xdr.send( ( s.hasContent && s.data ) || null );
                },
                abort: function() {
                    if ( xdr ) {
                        xdr.onerror = jQuery.noop;
                        xdr.abort();
                    }
                }
            };
        }
    });
};
;
/* module-key = 'com.atlassian.plugins.jira-project-creation:project-creation-resources', location = '/js/project-creation.js' */
ATLAS_PROJECT_CREATE = {};

(function ($) {

    AJS.EventQueue = AJS.EventQueue || [];

    var JIRA_PROJECT_CAPABILITY_KEY = 'jira.project';

    //This will most likely be added to the SPI in future versions
    var CAPABILITY_WEIGHT = {
        "confluence.space" : 30,
        "bamboo.project" : 20,
        "ondemand.svn-repository" : 10
    };

    ATLAS_PROJECT_CREATE.getFilteredRootTypes = function getFilteredRootTypes(response) {
        var types = {};
        for (var key in response.types) {
            if (key !== JIRA_PROJECT_CAPABILITY_KEY) {
                types[key] = response.types[key];
            }
        }
        return types;
    };

    ATLAS_PROJECT_CREATE.loadRemoteRoots = function loadRemoteRoots(capabilities) {
        var deferred = jQuery.Deferred(),
            innerPromises = [],
            rootTypes = [];

        // map each capability to the promise of an ajax call, when they're all done innerpromises will contain an array of promises, one for each
        // inner ajax call made. Once this outer mega-promise is resolved, we can create a new mega-promise out of the contents of innerPromises.
        // Once that mega-promise is resolved we can resolve the outside visible promise (projectCreationPromise), passing in the gathered root types.
        mapToPromise(capabilities,function (capability) {
            var baseUrl = capability.capabilitiesUrl;
            return AJS.$.ajax(baseUrl + '/aggregate-root', {
                success: function (response) {
                    var types = ATLAS_PROJECT_CREATE.getFilteredRootTypes(response);
                    innerPromises = innerPromises.concat(_.map(types, function (type, key) {
                        return AJS.$.ajax(type.href, {
                            xhrFields: {
                                withCredentials: true
                            },
                            success: function (rootType) {
                                rootTypes.push(ATLAS_PROJECT_CREATE.constructFullRootType(rootType, type.label, key, baseUrl, capability.id));
                            },
                            error: function (xhr, status, errorThrown) {
                                AJS.log('Got ' + errorThrown + ' from aggregate root type ' + type.href);
                            }
                        }).promise();
                    }));
                }, error: function (xhr, status, errorThrown) {
                    // TODO ROTP-1146 ROTP-1147: handle 401, 403 better
                    AJS.log('Got ' + errorThrown + ' from aggregate roots capapbility for ' + baseUrl);
                }
            }).promise();
        }).done(function () {
                promiseFromPromiseList(innerPromises).done(function () {
                    deferred.resolve(rootTypes);
                });
            });
        return deferred.promise();
    };

    ATLAS_PROJECT_CREATE.constructFullRootType = function constructFullRootType(rootType, label, capabilityKey, baseUrl, instanceId) {
        return {
            keys: rootType.keys,
            url: rootType.links.self,
            label: label,
            capabilityKey: capabilityKey,
            baseUrl: baseUrl,
            instanceId: instanceId
        };
    };

    ATLAS_PROJECT_CREATE.createLink = function createLink(linkDetails, complete) {
        console.log("creating link from " + linkDetails.entityType + " to " + linkDetails.remoteEntityType);
        var linkRequest = JSON.stringify({
            "local": linkDetails.baseUrl + "/aggregate-root/" + linkDetails.entityType + "/" + linkDetails.entityKey,
            "target": linkDetails.remoteInstanceBaseUrl + "/aggregate-root/" + linkDetails.remoteEntityType + "/" + linkDetails.remoteEntityKey
        });
        AJS.$.ajax(linkDetails.baseUrl + "/aggregate-root-link", {
            type: "POST",
            contentType: "application/json",
            data: linkRequest,
            timeout: 8000,
            complete: complete
        });
    };


    ATLAS_PROJECT_CREATE.linkAllTheThings = function linkAllTheThings(dialog, createdThings, projectKey, projectCreationPage, acknowledgeButton) {

        var linksToCreate = [];
        $.each(createdThings, function createLinks(idx, entity) {
            linksToCreate.push({
                baseUrl: entity.type.baseUrl,
                entityType: entity.type.capabilityKey,
                entityKey: entity.data.key,
                remoteInstanceBaseUrl: getAppBaseUrl() + "/rest/capabilities",
                remoteEntityType: JIRA_PROJECT_CAPABILITY_KEY,
                remoteEntityKey: projectKey
            });

            linksToCreate.push({
                baseUrl: getAppBaseUrl() + "/rest/capabilities",
                entityType: JIRA_PROJECT_CAPABILITY_KEY,
                entityKey: projectKey,
                remoteInstanceBaseUrl: entity.type.baseUrl,
                remoteEntityType: entity.type.capabilityKey,
                remoteEntityKey: entity.data.key
            });

            AJS.$.each(createdThings, function createLinkBetweenRemoteEntities(targetIdx, targetEntity) {
                //first check we are not trying to link something to itself or something else in the same instance
                if (targetEntity !== entity) {
                    linksToCreate.push({
                        baseUrl: entity.type.baseUrl,
                        entityType: entity.type.capabilityKey,
                        entityKey: entity.data.key,
                        remoteInstanceBaseUrl: targetEntity.type.baseUrl,
                        remoteEntityType: targetEntity.type.capabilityKey,
                        remoteEntityKey: targetEntity.data.key
                    });
                }
            });
        });

        //TODO ROTP-992 : Doesn't need to be serialized once applinks fixes up race condition
        var numErrors = 0;

        function createNext(xhr, status) {
            if (status !== "success") {
                numErrors++;
                // render the error message
                var errorMessage = xhr.statusText;
                try {
                    var data = JSON.parse(xhr.responseText);
                    if (data && data.message) {
                        errorMessage = data.message;
                    }
                } catch (err) {

                }
                AJS.messages.error(".li-linking-status", {
                    title: "Could not create links between created projects",
                    body: errorMessage
                });
                dialog.updateHeight();
            }
            if (linksToCreate.length > 0) {
                ATLAS_PROJECT_CREATE.createLink(linksToCreate.pop(), createNext);
            } else {
                if (numErrors > 0) {
                    projectCreationPage.find(".linking-status").html('<span class="aui-icon aui-icon-small aui-iconfont-error">' + "Error" + '</span>');
                } else {
                    projectCreationPage.find(".linking-status").html('<span class="aui-icon aui-icon-small aui-iconfont-success">' + "Success" + '</span>');
                }
                acknowledgeButton.prop("disabled", false);
                acknowledgeButton.attr('aria-disabled', 'false');
            }
        }

        createNext(null, "success");
    };

    var remoteRootsPromise;

    function bindRemoteRootsPromise(promise, getDialog, onCheckboxChange) {
        var dialog = getDialog();
        $.when(promise).then(
            // success handler
            function (types) {
                dialog.getCurPanel().body.find('.field-group.loading').remove();

                types.sort(sortCapabilities);
                if (types.length !== 0) {
                    var projectCreateForm = dialog.getCurPanel().body.find('form');
                    projectCreateForm.append(project.creation.remoteRootsCheckboxes({rootTypes: types}));
                    if (onCheckboxChange) {
                        projectCreateForm.find('input[type="checkbox"]').filter('.remote-root').change(onCheckboxChange);
                    }

                    dialog.updateHeight();
                }

                enableSubmitBtn(dialog, true);
            },
            // fail handler
            function () {
                dialog.getCurPanel().body.find('.field-group.loading').remove();
                enableSubmitBtn(dialog, true);
                dialog.updateHeight();
                // the provided promise only ever resolves. This shouldn't happen, but if something explodes it should
                // be enough to just revert back to default JIRA behaviour.
            }
        );
    }

    var panel;

    function setupProjectCreationIntegration(getDialog, onCheckboxChange) {
        var dialog = getDialog();
        //Store a ref to the panel for use in some promises
        panel = dialog.getCurPanel();
        // Attach some info and a spinner below Project Create name & key entry
        panel.body.find('form').append(project.creation.remoteRootsLoading({}));

        enableSubmitBtn(dialog, false);
        dialog.updateHeight();

        //Make sure the height is good again when the user hits back
        panel.page.element.find(".add-project-back-button").click(function() {
            dialog.updateHeight();
        });


        initRemoteRoots(bindRemoteRootsPromise, getDialog, onCheckboxChange);
    }

    function getSelectedTypes(types) {
        var selectedCheckboxes = _.filter(panel.body.find("input.remote-root.checkbox"), function (checkbox) {
            return checkbox.checked === true;
        });
        var selectedTypeIds = _.map(selectedCheckboxes,
            function (input) {
                return input.id;
            });
        return _.filter(types, function (type) {
            return _.contains(selectedTypeIds, 'capability_' + type.capabilityKey);
        });
    }

    var userMetaTag = AJS.$('meta[name="ajs-remote-user"]');
    // if we neither got a user tag, or it had no content then bail out.
    if (!userMetaTag || !userMetaTag[0] || !userMetaTag[0].content) {
        console.log("Project create didn't get a user META tag, or it had no content.  Bailing out");
        return;
    }

    // if the dark feature is disabled, return here.
    if (!AJS.DarkFeatures.isEnabled("rotp.project.create")) {
        return;
    }

    var postProjectCreationCallback = function postProjectCreationCallback(dialog, redirectFn, projectId, projectKey, projectName) {
        var callRedirectFn = function callRedirectFn(redirectFn, acknowledgeButton) {
            acknowledgeButton.prop("disabled", true);
            acknowledgeButton.attr('aria-disabled', 'true');
            acknowledgeButton.before('<span class="aui-icon aui-icon-wait project-creation-acknowledge-spinner">' + "Loading, please wait" + '</span>');
            redirectFn();
        };

        $.when(remoteRootsPromise).then(
            function (types) {
                var selectedTypes = getSelectedTypes(types);
                sendAnalytics(selectedTypes);

                if (selectedTypes.length === 0) {
                    //Make sure we don't show empty next page which is the default of project templates
                    dialog.prevPage();
                    redirectFn();
                    return;
                }

                createProjectCreationResultPanel(dialog, callRedirectFn, redirectFn);

                var templateData = [];
                var createdThings = [];
                mapToPromise(selectedTypes, function (type) {
                    var statusId = "creation_status_" + type.capabilityKey.replace(".", "_") + "_" + type.instanceId;
                    templateData.push({
                        statusId: statusId,
                        label: type.label
                    });

                    return AJS.$.ajax(type.url + "/" + projectKey, {
                        type: "PUT",
                        data: JSON.stringify({
                            label: projectName
                        }),
                        xhrFields: {
                            withCredentials: true
                        },
                        success: function (data) {
                            createdThings = createdThings.concat(processCreatedRoots(data, type));
                            renderCreatedRoots(data, statusId);
                        },
                        error: function (xhr, textStatus, errorThrown) {
                            renderErrorDuringRootCreation(statusId, type, xhr, errorThrown);
                        },
                        contentType: "application/json",
                        dataType: "json"
                    }).promise();
                }).always(function () {
                    renderErrorHeaderInCaseOfErrors(dialog);
                    console.log("about to begin linking created objects");
                    ATLAS_PROJECT_CREATE.linkAllTheThings(dialog,
                                                            createdThings,
                                                            projectKey,
                                                            AJS.$(".post-project-created-page-content"),
                                                            AJS.$(".project-create-acknowledge-button"));
                });

                AJS.$(".post-project-created-page-content").append(project.creation.remoteRootsSuccess({rootTypes: templateData}));
            }
        );
    };


    var checkIfKeyExists = function checkIfKeyExists(projectKey) {
        var duplicateFound;
        $.when(remoteRootsPromise).then(
            function (types) {
                var selectedTypes = getSelectedTypes(types);
                _.each(selectedTypes, function (type) {
                    if (type.keys) {
                        for (var key in type.keys) {
                            if (type.keys.hasOwnProperty(key)) {
                                if (projectKey.toUpperCase() === key.toUpperCase()) {
                                    duplicateFound = type;
                                }
                            }
                        }
                    }
                });
            });
        var response = {errors: {}};
        if (duplicateFound) {
            response.errors.projectKey = AJS.format("{0} with that key already exists in the remote instance", duplicateFound.label);
        }
        return response;
    };


    function getOrigin() {
        return window.location.origin ? window.location.origin : (window.location.protocol + '//' + window.location.host);
    }

    function getAppBaseUrl() {
        var baseUrl = getOrigin();
        return baseUrl + AJS.contextPath();
    }

    /**
     * Parse and return some components of a URL.
     * @param {string} url A URL, e.g. "http://google.com:80/a/b/c"
     * @returns {{host: string, protocol: string, port: string}}
     */
    function parseUrl(url) {
        var a = document.createElement('a');
        a.href = url;
        return {
            host: a.hostname,
            port: a.port,
            protocol: a.protocol.replace(':', '')
        };
    }

    /**
     * Determine if making a request from one URL to another would represent a security downgrade, and
     * as such be blocked by the browser.
     *
     * @param {string} origin The URL from which a request to *destination* is to be made.
     * @param {string} destination The destination URL.
     * @returns {boolean} true if origin uses https: and destination uses http:
     */
    function isSecurityDowngrade(origin, destination) {
        var aParts = parseUrl(origin);
        var bParts = parseUrl(destination);
        return aParts.protocol === "https" && bParts.protocol === "http";
    }

    function initRemoteRoots(fn, getDialog, onCheckboxChange) {
        AJS.$.ajax(getAppBaseUrl() + '/rest/capabilities/awareness', {
            type: "GET",

            /**
             * @param {{applications: object, links: {selfInstanceId: string} }} data
             */
            success: function parseAwarenessResponse(data) {
                // We need to be careful with what requests we make. Making a request from a HTTPS page to a HTTP
                // page will be blocked by the browser and will only fail after the timeout period has elapsed.
                var willTimeout = _.partial(isSecurityDowngrade, getOrigin());
                var capabilities = _
                    .chain(data.applications)
                    .map(function (details, url) {
                        return _.extend(details, {capabilitiesUrl: url});
                    })
                    .filter(function (details) {
                        return willTimeout(details.capabilitiesUrl) === false;
                    })
                    .value();

                //push an object in to gather any local capabilities
                capabilities.push({
                    id: data.links.selfInstanceId,
                    capabilitiesUrl: data.links.collection
                });

                remoteRootsPromise = ATLAS_PROJECT_CREATE.loadRemoteRoots(capabilities);
                selfInstanceId = data.links.selfInstanceId;
                if (typeof fn === 'function') {
                    fn(remoteRootsPromise, getDialog, onCheckboxChange);
                }
            },
            error: function (xhr, status, errorThrown) {
                // log & revert to vanilla JIRA behaviour.
                console.log("Project create error - error gathering roots from awareness capability");
                if (getDialog) {
                    $(getDialog().getCurPanel().page.element).find(".pt-submit-button").attr('aria-disabled', 'false');
                }
            }
        });
    }


    var selfInstanceId;
    var odFecruAwareness = null;

    // given a list<X> and a function fn : X -> promise returns a promise composed
    // of all the promises returned by applying fn to members of list
    function mapToPromise(list, fn) {
        var promises = _.map(list, fn);
        return promiseFromPromiseList(promises);
    }

    // given a list of promises, construct a new promise which fires done when all proivded promises have either been resolved or rejected.
    // NOTE: can not just be return $.when.apply(promises).promise() because that would reject when the first internal promise is rejected,
    // whereas we want the promise to fire after all are completed.
    // Again, NOTE: resolution of the returned promise will be empty. This should only be used when you want flow control,
    // data access should be by other means (or wrapped around one of these).
    function promiseFromPromiseList(promises) {
        var deferred = $.Deferred();
        var resolutionCount = 0;
        if (promises.length === 0) {
            deferred.resolve();
        } else {
            _.each(promises, function (promise) {
                promise.always(function () {
                    resolutionCount++;
                    if (resolutionCount === promises.length) {
                        deferred.resolve();
                    }
                });
            });
        }
        return deferred.promise();
    }

    function createProjectCreationResultPanel(dialog, callRedirectFn, redirectFn) {
        dialog.addPanel("title", "", "post-project-created-page-content");
        dialog.addHeader("Creating and linking companions for your JIRA project");
        dialog.addButton("All done!", function () {
            callRedirectFn(redirectFn, AJS.$(this));
        }, "project-create-acknowledge-button");

        AJS.$(".project-create-acknowledge-button").removeClass("button-panel-button")
            .addClass("aui-button aui-button-primary")
            .attr('aria-disabled', 'true')
            .prop('disabled', true);
    }

    function processCreatedRoots(data, type) {
        var createdThings = [];
        if (type.capabilityKey === "ondemand.svn-repository") {
            // TODO: Remove this special case when FeCru is removed from OnDemand
            // this is a hack to handle the fact that SVN repositories
            // are being created in JIRA.
            console.log("got back created SVN repository");
            createdThings.push({
                type: {
                    capabilityKey: "fecru.repository",
                    instanceId: odFecruAwareness.id,
                    baseUrl: odFecruAwareness.capabilitiesUrl
                },
                data: {
                    key: data.key
                }
            });
            createdThings.push({
                type: {
                    capabilityKey: "fecru.project",
                    instanceId: odFecruAwareness.id,
                    baseUrl: odFecruAwareness.capabilitiesUrl
                },
                data: {
                    key: "CR-" + data.key
                }
            });
        } else {
            console.log("got back created thing " + type.capabilityKey);
            var createdThing = {
                type: type,
                data: data
            };
            createdThings.push(createdThing);
        }

        return createdThings;
    }

    function renderCreatedRoots(data, statusId) {
        var statusBlock = AJS.$("." + statusId);
        statusBlock.empty(); //remove spinner
        statusBlock.append('<span class="aui-icon aui-icon-small aui-iconfont-success">' + "Success" + '</span>');
        if (data.links.resource) {
            var link = AJS.$("<a target='_blank'></a>");
            link.text(data.label);
            link.attr("href",data.links.resource);
            link.attr("title",data.label);
            statusBlock.closest('li').append(link);
        }
    }

    function renderErrorDuringRootCreation(statusId, type, xhr, errorThrown) {
        var statusBlock = AJS.$("." + statusId);
        statusBlock.empty(); //remove spinner
        statusBlock.append('<span class="aui-icon aui-icon-small aui-iconfont-error">' + "Error" + '</span>');
        var errorMessage = errorThrown;
        if (xhr && xhr.responseText) {
            try {
                var data = JSON.parse(xhr.responseText);
                if (data && data.message) {
                    errorMessage = data.message;
                }
            } catch (err) {
                // swallow syntax error if response is not valid JSON and display the response text as error
                errorMessage = xhr.responseText;
            }
        }

        AJS.messages.error(".li-" + statusId, {
            title: AJS.format("Could not create {0}", type.label),
            body: errorMessage
        });
    }

    function renderErrorHeaderInCaseOfErrors(dialog) {
        // if we have any errors, add a helpful message
        var currentPanel = dialog.getCurrentPanel();
        if (currentPanel.body.find('.aui-message.error').size() !== 0) {
            AJS.messages.warning('.project-creation-success', {
                title: "We were unable to create everything you requested",
                body: '<p>' + "However, you can create them yourself and manually set up links." + '</p>'
            });

            dialog.updateHeight();
        }
    }

    function sendAnalytics(selectedTypes) {
        var capabilityKeys = _.map(selectedTypes, function (type) { return type.capabilityKey;});
        var analyticsValue = (capabilityKeys.length == 0) ? "none" : capabilityKeys.sort().join('_');

        AJS.EventQueue.push({name: 'project.create.aggregateroots.selected', properties: {capabilitykeys: analyticsValue}});
    }

    function enableSubmitBtn(dialog, enabled) {
        $(dialog.getCurPanel().page.element).find(".pt-submit-button").attr('aria-disabled', !enabled);
    }

    function sortCapabilities(capabilityA, capabilityB) {
        return getCapabilityWeight(capabilityB.capabilityKey) - getCapabilityWeight(capabilityA.capabilityKey);
    }

    function getCapabilityWeight(capabilityKey) {
        return _.has(CAPABILITY_WEIGHT, capabilityKey) ? CAPABILITY_WEIGHT[capabilityKey] : 0;
    }



    JPT.AddProjectController.registerProjectKeyValidationCallback(checkIfKeyExists);

    var getJptDialog = function getJptDialog() {
        return JPT.DialogView.dialog || JPT.DialogView._dialog;
    };
    var onJptCheckboxChange = function onJptCheckboxChange() {
        if (JPT.AddProjectView.getKey().length >= 2) {
            JPT.AddProjectController._performKeyValidationChecks(JPT.AddProjectView.getKey());
        }
    };

    JPT.AddProjectView.addPostDrawCallback(function () {
        setupProjectCreationIntegration(getJptDialog, onJptCheckboxChange);
    });

    JPT.AddProjectController.registerPostProjectCreationCallback(function (dialog, returnUrl, projectId, projectKey, projectName) {
        var redirectFn = function() {
            window.location = AJS.contextPath() + returnUrl;
        };
        postProjectCreationCallback(dialog, redirectFn, projectId, projectKey, projectName);
    });

    // Embed project create in Greenhopper project create flow
    // (But only in flow creating a JIRA project at the same time)
    var registerGhCallbacks = function registerGhCallbacks() {
        var GH_PROJECT_CREATION_STEP = "projectCreation";
        GH.StartWizardView.registerWizardStepPreRenderCallback(function ghProjectCreateSetup(stepName) {
            if (stepName == GH_PROJECT_CREATION_STEP) {
                initRemoteRoots();

                GH.StartWizardView.registerWizardStepOnCreateCallbacks(function ghProjectCreageCallback(dialog, executeNextCallback, model) {
                    console.log("creating external entities");
                    dialog.addPage("post-project-created-page");
                    postProjectCreationCallback(dialog, executeNextCallback, null, model.project.key, model.project.name);
                });
            }
        });
        GH.StartWizardView.registerWizardStepPostRenderCallback(function renderGhProjectCheckboxes(stepName, dialog) {
            if (stepName == GH_PROJECT_CREATION_STEP) {
                setupProjectCreationIntegration(function getGhDialog() {
                    return dialog;
                });
                dialog.updateHeight();
            }
        });
        GH.StartWizardView.registerWizardStepOnValidateCallback(function validateProjectKey(stepName, dialog) {
            if (stepName == GH_PROJECT_CREATION_STEP) {
                var $keyInput = dialog.getCurPanel().body.find("#ghx-wizard-project-projectkey");
                var keyExistsResponse = checkIfKeyExists($keyInput.val());
                if (keyExistsResponse.errors.projectKey) {
                    var $errorElement = AJS.$("<div class='error project-creation-error'></div>");
                    var parent = $keyInput.parent();
                    parent.find(".project-creation-error").remove();
                    parent.append($errorElement);
                    $errorElement.text(keyExistsResponse.errors.projectKey);
                    $errorElement.show();
                    return false;
                }
            }
            return true;
        });
    };

    $(function() {

        // Embed project create in JIRA project templates dialog
        // on clicking the project create link, we want to start gathering our capabilities
        AJS.$('.add-project-trigger').live('click', initRemoteRoots);

        // check if Greenhopper is available and that it is a version which has support for the required
        // callbacks.  If so, register greenhopper callbacks
        if (typeof GH !== 'undefined') {
            if (GH.StartWizardView && GH.StartWizardView.registerWizardStepPreRenderCallback) {
                // GH has support for the required callbacks....
                registerGhCallbacks();
            }
        }
    });

    // Embed project create in JIRA project templates dialog
    // on clicking the project create link, we want to start gathering our capabilities
    $(function () {
        AJS.$('.add-project-trigger').live('click', initRemoteRoots);
    });


})(jQuery);
;
;
/* module-key = 'com.atlassian.plugins.jira-project-creation:project-creation-resources', location = '/templates/project-creation.soy' */
// This file was automatically generated from project-creation.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace project.creation.
 */

if (typeof project == 'undefined') { var project = {}; }
if (typeof project.creation == 'undefined') { project.creation = {}; }


project.creation.remoteRootsLoading = function(opt_data, opt_ignored) {
  return '<div class="field-group loading"><span class="aui-icon aui-icon-wait"/>' + soy.$$escapeHtml("Retrieving additional project types you might want to create") + '</div>';
};
if (goog.DEBUG) {
  project.creation.remoteRootsLoading.soyTemplateName = 'project.creation.remoteRootsLoading';
}


project.creation.remoteRootsCheckboxes = function(opt_data, opt_ignored) {
  var output = '<fieldset class="group remote-root-checkboxes"><h4>' + soy.$$escapeHtml("Create a linked:") + '</h4><div class=\'field-group\'>';
  var rootTypeList10 = opt_data.rootTypes;
  var rootTypeListLen10 = rootTypeList10.length;
  for (var rootTypeIndex10 = 0; rootTypeIndex10 < rootTypeListLen10; rootTypeIndex10++) {
    var rootTypeData10 = rootTypeList10[rootTypeIndex10];
    output += '<div class="checkbox"><input class="checkbox remote-root" type="checkbox" id="capability_' + soy.$$escapeHtml(rootTypeData10.capabilityKey) + '" checked="true" data-url="' + soy.$$escapeHtml(rootTypeData10.url) + '"></input><label for="capability_' + soy.$$escapeHtml(rootTypeData10.capabilityKey) + '">' + soy.$$escapeHtml(rootTypeData10.label) + '</label></div>';
  }
  output += '</div></fieldset>';
  return output;
};
if (goog.DEBUG) {
  project.creation.remoteRootsCheckboxes.soyTemplateName = 'project.creation.remoteRootsCheckboxes';
}


project.creation.remoteRootsSuccess = function(opt_data, opt_ignored) {
  var output = '<div class="project-creation-success"><ul>';
  var rootTypeList24 = opt_data.rootTypes;
  var rootTypeListLen24 = rootTypeList24.length;
  for (var rootTypeIndex24 = 0; rootTypeIndex24 < rootTypeListLen24; rootTypeIndex24++) {
    var rootTypeData24 = rootTypeList24[rootTypeIndex24];
    output += '<li class="li-' + soy.$$escapeHtml(rootTypeData24.statusId) + '"><div class="' + soy.$$escapeHtml(rootTypeData24.statusId) + ' created-entity-status"><span class="aui-icon aui-icon-wait">' + soy.$$escapeHtml("Loading, please wait") + '</span></div><div class="created-entity-status">' + soy.$$escapeHtml(rootTypeData24.label) + '</div></li>';
  }
  output += '<li class="li-linking-status"><div class="linking-status created-entity-status"><span class="aui-icon aui-icon-wait">' + soy.$$escapeHtml("Loading, please wait") + '</span></div><div class="created-entity-status">' + soy.$$escapeHtml("Creating links") + '</div></li></ul></div>';
  return output;
};
if (goog.DEBUG) {
  project.creation.remoteRootsSuccess.soyTemplateName = 'project.creation.remoteRootsSuccess';
}
;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/store-1.3.1.js' */
/* Copyright (c) 2010-2012 Marcus Westin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function(){
	var store = {},
		win = window,
		doc = win.document,
		localStorageName = 'localStorage',
		globalStorageName = 'globalStorage',
		namespace = '__storejs__',
		storage;

	store.disabled = false;
	store.set = function(key, value) {};
	store.get = function(key) {};
	store.remove = function(key) {};
	store.clear = function() {};
	store.transact = function(key, transactionFn) {
		var val = store.get(key);
		if (typeof val == 'undefined') { val = {} }
		transactionFn(val);
		store.set(key, val);
	};

	store.serialize = function(value) {
		return JSON.stringify(value);
	};
	store.deserialize = function(value) {
		if (typeof value != 'string') { return undefined }
		return JSON.parse(value);
	};

	// Functions to encapsulate questionable FireFox 3.6.13 behavior 
	// when about.config::dom.storage.enabled === false
	// See https://github.com/marcuswestin/store.js/issues#issue/13
	function isLocalStorageNameSupported() {
		try { return (localStorageName in win && win[localStorageName]); }
		catch(err) { return false; }
	}
	
	function isGlobalStorageNameSupported() {
		try { return (globalStorageName in win && win[globalStorageName] && win[globalStorageName][win.location.hostname]); }
		catch(err) { return false; }
	}	

	if (isLocalStorageNameSupported()) {
		storage = win[localStorageName];
		store.set = function(key, val) {
			if (val === undefined) { return store.remove(key); }
			storage.setItem(key, store.serialize(val));
		};
		store.get = function(key) { return store.deserialize(storage.getItem(key)); };
		store.remove = function(key) { storage.removeItem(key); };
		store.clear = function() { storage.clear(); };

	} else if (isGlobalStorageNameSupported()) {
		storage = win[globalStorageName][win.location.hostname];
		store.set = function(key, val) {
			if (val === undefined) { return store.remove(key); }
			storage[key] = store.serialize(val);
		};
		store.get = function(key) { return store.deserialize(storage[key] && storage[key].value); };
		store.remove = function(key) { delete storage[key]; };
		store.clear = function() { for (var key in storage ) { delete storage[key]; } };

	} else if (doc.documentElement.addBehavior) {
		var storageOwner,
			storageContainer;
		// Since #userData storage applies only to specific paths, we need to
		// somehow link our data to a specific path.  We choose /favicon.ico
		// as a pretty safe option, since all browsers already make a request to
		// this URL anyway and being a 404 will not hurt us here.  We wrap an
		// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
		// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
		// since the iframe access rules appear to allow direct access and
		// manipulation of the document element, even for a 404 page.  This
		// document can be used instead of the current document (which would
		// have been limited to the current path) to perform #userData storage.
		try {
			storageContainer = new ActiveXObject('htmlfile');
			storageContainer.open();
			storageContainer.write('<s' + 'cript>document.w=window</s' + 'cript><iframe src="/favicon.ico"></frame>');
			storageContainer.close();
			storageOwner = storageContainer.w.frames[0].document;
			storage = storageOwner.createElement('div');
		} catch(e) {
			// somehow ActiveXObject instantiation failed (perhaps some special
			// security settings or otherwse), fall back to per-path storage
			storage = doc.createElement('div');
			storageOwner = doc.body;
		}
		function withIEStorage(storeFunction) {
			return function() {
				var args = Array.prototype.slice.call(arguments, 0);
				args.unshift(storage);
				// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
				// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
				storageOwner.appendChild(storage);
				storage.addBehavior('#default#userData');
				storage.load(localStorageName);
				var result = storeFunction.apply(store, args);
				storageOwner.removeChild(storage);
				return result;
			}
		}
		store.set = withIEStorage(function(storage, key, val) {
			if (val === undefined) { return store.remove(key) }
			storage.setAttribute(key, store.serialize(val));
			storage.save(localStorageName);
		});
		store.get = withIEStorage(function(storage, key) {
			return store.deserialize(storage.getAttribute(key));
		});
		store.remove = withIEStorage(function(storage, key) {
			storage.removeAttribute(key);
			storage.save(localStorageName);
		});
		store.clear = withIEStorage(function(storage) {
			var attributes = storage.XMLDocument.documentElement.attributes;
			storage.load(localStorageName);
			for (var i=0, attr; attr = attributes[i]; i++) {
				storage.removeAttribute(attr.name);
			}
			storage.save(localStorageName);
		});
	}
	
	try {
		store.set(namespace, namespace);
		if (store.get(namespace) != namespace) { store.disabled = true; }
		store.remove(namespace);
	} catch(e) {
		store.disabled = true;
	}
	
	if (typeof module != 'undefined') { module.exports = store; }
	else if (typeof define === 'function' && define.amd) { define(store); }
	else { this.store = store; }
})();;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/page-visibility.js' */
define('atlassian/analytics/page-visibility', function () {
    var hasBrowserSupport = (document.hidden !== undefined);

    /**
     * A partial wrapper for the Page Visibility API
     * @exports atlassian/analytics/page-visibility
     */
    var wrapper = {

        /** Is the API supported by the browser? */
        supported: hasBrowserSupport,

        /**
         * A proxy for `document.hidden`.
         * Defaults to false if the API is not supported by the browser
         * @returns {boolean}
         */
        isHidden: function () {
            return hasBrowserSupport ? document.hidden : false;
        }
    };

    return wrapper;
});;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/user-activity-xhr-header.js' */
/**
 * Provides overrides that add a custom HTTP header to XHR and fetch requests
 * to make MAU User Activity event tracking easier by identifying requests
 * from inactive tabs/windows
 *
 * @module atlassian/analytics/user-activity-xhr-header
 *
 * @see module:atlassian/analytics/page-visibility
 */
define('atlassian/analytics/user-activity-xhr-header', ['atlassian/analytics/page-visibility'], function (pageVisibility) {

    var ACTIVITY_IGNORE_HEADER = 'x-atlassian-mau-ignore';

    // Store native xhr and fetch methods
    var oldSend = XMLHttpRequest.prototype.send;
    var oldFetch = window.fetch;

    var _installed = false;

    return /** @alias module:atlassian/analytics/user-activity-xhr-header */ {
        /**
         * Install global overrides to XHR send and fetch methods to add a
         * custom HTTP header that makes MAU User Activity event tracking
         * easier by identifying requests from inactive tabs/windows
         */
        install: function () {
            // Only install if the override is not already installed
            // and if the browser supports the Page Visibility API
            if (!_installed && pageVisibility.supported) {

                // Override the native send()
                XMLHttpRequest.prototype.send = function () {
                    if (pageVisibility.isHidden()) {
                        this.setRequestHeader(ACTIVITY_IGNORE_HEADER, pageVisibility.isHidden());
                    }
                    oldSend.apply(this, arguments);
                };

                // Override the native fetch() if it exists
                if (oldFetch) {
                    window.fetch = function (input, init) {
                        var augmentedInit = init || {};
                        var headers = augmentedInit.headers;

                        if (pageVisibility.isHidden()) {
                            augmentedInit.headers = (headers) ? new Headers(headers) : new Headers();
                            augmentedInit.headers.append(ACTIVITY_IGNORE_HEADER, pageVisibility.isHidden());
                        }

                        return oldFetch.call(this, input, augmentedInit);
                    };
                }

                _installed = true;
            }
        },

        /**
         * Restore native XHR send and fetch methods
         */
        uninstall: function () {
            if (_installed) {
                XMLHttpRequest.prototype.send = oldSend;
                if (oldFetch) {
                    window.fetch = oldFetch;
                }
            }
            _installed = false;
        }
    };

});

require('atlassian/analytics/user-activity-xhr-header').install();;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/atlassian-analytics.js' */
(function ($) {
    // Make sure we are getting the jQuery.ajax method, even if it has been overridden elsewhere.
    // This will only work if this code is executed before any code which overrides the ajax method.
    var $ajax = AJS.$.ajax;
    var baseStorageKey = 'atlassian-analytics';
    var contextPath =
        typeof AJS.contextPath == "function" ? AJS.contextPath() :
        typeof AJS.Confluence != "undefined" ? AJS.Confluence.getContextPath() :
        window.contextPath != null ? window.contextPath : "";

    var publish = null;
    var storageKey = null;
    var lockKey = null;

    // A unique identifier for this browser tab
    // Source: http://stackoverflow.com/a/2117523
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
    });

    var determineStorageKey = function(){
        // We need to give each product it's own key for events because in ondemand multiple product live
        // at the same url.
        var product = 'unknown';
        if (document.body.id == 'jira'){
            product = 'jira';
        }
        else if (document.body.id == 'com-atlassian-confluence'){
            product = 'confluence';
        }
        storageKey = baseStorageKey + '.' + product;
        lockKey = storageKey + '.lock';
    };

    var getLock = function() {
        if (store.get(lockKey)) {
            return false;
        }

        store.set(lockKey, uuid);

        // Reduce chance of race condition - read back lock to make sure we still have it
        return (store.get(lockKey) === uuid);
    };

    var releaseLock = function() {
        store.set(lockKey, null);
    };

    /**
     * Persists the events that have been generated until such time that they can be sent.
     */
    var saveForLater = function() {
        var events = [],
            event,
            e, i, ii;
        if (AJS.EventQueue.length == 0)
            return;
        // Prime our events array with anything that's already saved.
        events = store.get(storageKey) || events;
        // Suck the events out of the event queue and in to our events array.
        for (i = 0, ii = AJS.EventQueue.length; i < ii; ++i) {
            e = AJS.EventQueue[i];
            if (e.name) {
                // the queue could contain anything - shear unusable properties
                event = { name: e.name, properties: e.properties, time: e.time || 0};
                events.push(event);
            }
        }
        // Empty the event queue
        AJS.EventQueue.length = 0;
        // Save our events for later
        store.set(storageKey, events);
    };

    // Variable to track the number of retries to publish
    var bulkPublishRetryCount = 0;

    /**
     * Gets the amount of time that should be waited until the next publish attempt.
     * @param retryCount How many requests failed since the last successful publish.
     * @returns {number} how many ms that should be waited.
     */
    var getBulkPublishBackoff = function (retryCount) {
        return Math.min(5000 * Math.pow(2, retryCount), 5*60*1000);
    };

    /**
     * Publishes every event that's ready for publishing.
     */
    var bulkPublish = function() {
        var events;

        function reschedule() {
            setTimeout(bulkPublish, getBulkPublishBackoff(bulkPublishRetryCount = 0));
        }

        function rescheduleFailed() {
            setTimeout(bulkPublish, getBulkPublishBackoff(++bulkPublishRetryCount));
        }

        // Avoid multiple browser tabs hitting this all at once
        if (!getLock()) {
            return reschedule();
        }

        // Make sure every event we might have is stored.
        saveForLater();
        // Pull the stored events out and get 'em ready for transmission.
        events = store.get(storageKey);

        if (!events || !events.length) {
            releaseLock();
            return reschedule();
        }

        // Wipe the stored events.
        store.remove(storageKey);

        releaseLock();

        // Validate events and remove any dodgy ones
        if (!validateEvents(events)) {
            return reschedule();
        }

        // try to present a rough timing of events that the server can interpret relative to it's own time.
        var currentTime = new Date().getTime();
        for (var i = 0; i < events.length; i++){
            if (events[i].time > 0){
                events[i].timeDelta = events[i].time - currentTime;
            }
            else{
                // just fake it. This corresponds to a millisecond for each place behind last in the array.
                // This should be rare. Basically, events added to EventQueue before this script was loaded.
                events[i].timeDelta = i - events.length;
            }
            delete events[i].time;
        }

        // AJS.safe.post appears to corrupt a JSON data object, so we send it as a context param instead.
        // Failing to JSON encode the data results in jQuery not attempting to send, and silently swallowing our attempt
        publish = $ajax({
            type: "POST",
            url: contextPath + "/rest/analytics/1.0/publish/bulk",
            data: JSON.stringify(events),
            contentType: "application/json",
            dataType: "json"
        });
        // In case the transmission fails, let's keep the events we just attempted to send.
        publish.fail(function() {
            // This actually drops events, but the alternative is to use something like:
            //   $.merge(AJS.EventQueue, events);
            // Unfortunately using that will cause some fairly nasty issues where duplicate events continually
            // get sent - see https://jira.atlassian.com/browse/AA-179 for more details.
            // TODO: investigate why the above happens and fix this functionality for good
            AJS.EventQueue.concat(events);

            saveForLater();
            rescheduleFailed();
        });
        publish.done(function () {
            reschedule();
        });
    };

    /**
     * Check for any invalid events and remove/sanitise them.
     * @param events - the list of events to be published
     * @returns the number of valid events remaining
     */
    var validateEvents = function(events) {
        for (var i = events.length - 1; i >= 0; i--) {
            var validMsg = "";
            var event = events[i];
            var properties = event.properties;
            if (typeof event.name === "undefined") {
                validMsg = "you must provide a name for the event.";
            } else if (typeof properties !== "undefined" && properties !== null) {
                if (properties.constructor !== Object) {
                    validMsg = "properties must be an object with key value pairs.";
                } else {
                    sanitiseProperties(properties);
                }
            }
            if (validMsg !== "") {
                AJS.log("WARN: Invalid analytics event detected and ignored, " + validMsg + "\nEvent: "+JSON.stringify(event));
                events.splice(i, 1);
            }
        }
        return events.length;
    };

    var sanitiseProperties = function(properties) {
        for (var propertyName in properties) {
            if (properties.hasOwnProperty(propertyName)) {
                var propertyValue = properties[propertyName];
                if (typeof propertyValue !== "undefined" && propertyValue !== null && propertyValue.toString) {
                    // Sanitise the property value by invoking its "toString"
                    properties[propertyName] = propertyValue.toString();
                } else {
                    // If it's an undefined, null or invalid value - blank it out
                    properties[propertyName] = "";
                }
            }
        }
    };

    var cancelPublish = function() {
        if (publish && !(publish.state() === "resolved" || publish.state() === "rejected")) {
            publish.abort(); // This will cancel the request to the server, and cause the events to be saved for later.
        }
    };

    /**
     * Provides a way to publish events asynchronously, without requiring AJS.Events to have loaded.
     * Users of this property must conditionally initialise it to an empty array. Objects pushed
     * must have a name property, and optionally a properties property of other data to send.
     * @example
     * AJS.EventQueue = AJS.EventQueue || [];
     * AJS.EventQueue.push({name: 'eventName', properties: {some: 'data', more: true, hits: 20}});
     */
    AJS.EventQueue = AJS.EventQueue || [];

    var arrayPush = Array.prototype.push;
    AJS.EventQueue.push = function(obj) {
    	obj.time = new Date().getTime();
    	arrayPush.call(AJS.EventQueue, obj);
    };

    AJS.toInit(function() {
    	determineStorageKey();
        setTimeout(bulkPublish, 500);
        removeOldAnalytics();
    });
    $(window).unload(function() {
        cancelPublish();
        saveForLater();
    });

    /**
     * @deprecated since v3.39, please trigger as normal and use whitelisting to denote privacy policy safe events
     */
    AJS.Analytics = {
        triggerPrivacyPolicySafeEvent: function(name, properties) {
            AJS.log("WARN: 'triggerPrivacyPolicySafeEvent' has been deprecated");
            AJS.EventQueue.push({name: name, properties: properties});
        }
    };

    /**
     * Binds to an event that developers can trigger without having to do any feature check.
     * If this code is available then the event will get published and if it's not the event
     * will go unnoticed.
     * @example
     * AJS.trigger('analytics', {name: 'pageSaved', data: {pageName: page.name, space: page.spaceKey}});
     */
    AJS.bind('analytics', function(event, data) {
    	AJS.EventQueue.push({name: data.name, properties: data.data});
    });

    // legacy binding until Confluence page layout JS is updated
    AJS.bind('analyticsEvent', function(event, data) {
    	AJS.EventQueue.push({name: data.name, properties: data.data});
    });

    /**
     * As part of bundling this plugin in BTF now, we need to remove the existing JIRA analytics setting if we see it.
     */
    var removeOldAnalytics = function () {
        if (window.location.pathname.indexOf("/secure/admin/ViewApplicationProperties") > -1) {
            AJS.$("[data-property-id='analytics-enabled']").remove();
        } else if (window.location.pathname.indexOf("/secure/admin/EditApplicationProperties") > -1) {
            var $analytics = AJS.$(":contains(Enable Atlassian analytics)");
            if ($analytics.size() > 0) {
                var parentElement = $analytics[$analytics.size() - 2];
                if (parentElement) {
                    parentElement.remove();
                }
            }
        }
    }

}(AJS.$));
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:application-header-administration-cog-resource', location = 'header/cog.js' */
var NavLinks = (function (NavLinks) {

    NavLinks.ApplicationHeader = function (ApplicationHeader) {

        ApplicationHeader.Cog = (function () {

            var _get = function () {

                var jiraSection = AJS.$("#system-admin-menu-content");
                if (jiraSection.length > 0) {
                    return jiraSection;
                }

                var confluenceSection = AJS.$("#admin-menu-link-content");
                if (confluenceSection.length > 0) {
                    return confluenceSection;
                }

                // Bamboo
                return AJS.$("#bamboo\\.global\\.header-admin\\.menu");
            };

            return {
                getDropdown: _get
            };
        }());
        return ApplicationHeader;
    }(NavLinks.ApplicationHeader || {});

    return NavLinks;
}(NavLinks || {}));;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:administration-shortcuts-resources', location = 'adminshortcuts/adminshortcuts.soy' */
// This file was automatically generated from adminshortcuts.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.adminshortcuts.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.adminshortcuts == 'undefined') { navlinks.templates.adminshortcuts = {}; }


navlinks.templates.adminshortcuts.section = function(opt_data, opt_ignored) {
  var param5 = '<ul class="aui-list-truncate">';
  var linkList7 = opt_data.links;
  var linkListLen7 = linkList7.length;
  for (var linkIndex7 = 0; linkIndex7 < linkListLen7; linkIndex7++) {
    var linkData7 = linkList7[linkIndex7];
    param5 += '<li><a href="' + soy.$$escapeHtml(linkData7.link) + '">' + soy.$$escapeHtml(linkData7.label) + '</a></li>';
  }
  param5 += '</ul>';
  var output = '' + aui.dropdown2.section({id: 'nl-remote-admin-section', label: "Other applications", content: param5});
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.adminshortcuts.section.soyTemplateName = 'navlinks.templates.adminshortcuts.section';
}
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:administration-shortcuts-resources', location = 'adminshortcuts/adminnavlinks.js' */
var NavLinks = (function (NavLinks) {

    NavLinks.AdminShortcuts = (function () {

        var _requestLinks = function () {
            return AJS.$.ajax({
                url:AJS.contextPath() + '/rest/menu/latest/admin',
                cache:false,
                dataType:'json'
            });
        };

        var trackAnalytics = function () {
            AJS.$("#nl-remote-admin-section").on('click', 'a', function () {
                NL.trackEvent('remoteAdminItemSelected', NL.getCurrentApplication(), $(this).attr('href'));
            });
        };

        return {
            render: function () {

                _requestLinks().done(function (linkData) {

                    // filter links to exclude the local admin link
                    linkData = _.reject(linkData,  function (link) {
                        return link['local'] === true;
                    });

                    if (linkData.length) {
                        // if we have remote admin links, render them in a new dropdown section
                        var renderedTemplate = navlinks.templates.adminshortcuts.section({links: linkData});
                        NavLinks.ApplicationHeader.Cog.getDropdown().append(renderedTemplate);

                        trackAnalytics();
                    }
                })
            }
        };
    }());

    return NavLinks;
}(NavLinks || {}));;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:administration-shortcuts', location = 'adminshortcuts/adminshortcuts-cdn.js' */
AJS.toInit(function () {
    if (AJS.DarkFeatures && AJS.DarkFeatures.isEnabled('rotp.admin.shortcuts')) {
        NavLinks.AdminShortcuts.render();
    }
});;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-projectshortcuts', location = 'projectshortcuts/projectshortcuts.soy' */
// This file was automatically generated from projectshortcuts.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.projectshortcuts.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.projectshortcuts == 'undefined') { navlinks.templates.projectshortcuts = {}; }


navlinks.templates.projectshortcuts.dialogContent = function(opt_data, opt_ignored) {
  return '' + ((opt_data.localShortcuts && opt_data.localShortcuts.length > 0) ? navlinks.templates.projectshortcuts.dialogContentShortcuts({shortcuts: opt_data.localShortcuts, listClass: 'projectshortcut-links'}) : '') + ((opt_data.remoteShortcuts != null) ? (opt_data.remoteShortcuts.length > 0) ? '<h2 class="projectshortcuts-heading">Related Links</h2>' + navlinks.templates.projectshortcuts.dialogContentShortcuts(soy.$$augmentMap(opt_data.remoteShortcuts, {shortcuts: opt_data.remoteShortcuts, listClass: 'projectshortcut-links'})) : '' : navlinks.templates.projectshortcuts.dialogLoading(null));
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogContent.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogContent';
}


navlinks.templates.projectshortcuts.headingWrapper = function(opt_data, opt_ignored) {
  return '<div class="project-dialog-header-wrapper"><div class="project-header"><img class="project-img" src="' + soy.$$escapeHtml(opt_data.logoUrl) + '"><h2 class="dialog-title">' + soy.$$escapeHtml(opt_data.title) + '</h2></div><div class="project-content-wrapper">' + soy.$$filterNoAutoescape(opt_data.contentHtml) + '</div></div>';
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.headingWrapper.soyTemplateName = 'navlinks.templates.projectshortcuts.headingWrapper';
}


navlinks.templates.projectshortcuts.dialogContentShortcuts = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  var output = '<ul' + ((opt_data.listClass) ? ' class="' + soy.$$escapeHtml(opt_data.listClass) + '"' : '') + '>';
  var shortcutList35 = opt_data.shortcuts;
  var shortcutListLen35 = shortcutList35.length;
  for (var shortcutIndex35 = 0; shortcutIndex35 < shortcutListLen35; shortcutIndex35++) {
    var shortcutData35 = shortcutList35[shortcutIndex35];
    output += '<li' + ((shortcutIndex35 == shortcutListLen35 - 1) ? ' class="last"' : '') + '>' + navlinks.templates.projectshortcuts.dialogContentShortcut(shortcutData35) + '</li>';
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogContentShortcuts.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogContentShortcuts';
}


navlinks.templates.projectshortcuts.dialogContentShortcut = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.link) + '"' + ((opt_data.tooltip) ? ' title="' + soy.$$escapeHtml(opt_data.tooltip) + '"' : '') + '>' + soy.$$escapeHtml(opt_data.label) + '</a>';
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogContentShortcut.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogContentShortcut';
}


navlinks.templates.projectshortcuts.dialogLoading = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div class="projectshortcuts-loading">' + ((opt_data.text) ? soy.$$escapeHtml(opt_data.text) : '') + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogLoading.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogLoading';
}
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-projectshortcuts', location = 'projectshortcuts/projectshortcuts.js' */
(function ($, NL) {
    var dialog,
        dialogDataCache = {},
        triggerDataEntityKey = 'key',
        triggerDataEntityName = 'name',
        triggerDataEntityType = 'entity-type';

    function showShortcutsDialog(e) {
        var $trigger = $(this),
            projectKey = $trigger.data(triggerDataEntityKey),
            projectName = $trigger.data(triggerDataEntityName),
            projectEntityType = $trigger.data(triggerDataEntityType);

        if (typeof projectKey === 'undefined') {
            return;
        }

        e.preventDefault();

        dialog = new AJS.Dialog({
            width: 600,
            keypressListener: function (e) {
                if (e.which == jQuery.ui.keyCode.ESCAPE) {
                    dialog.remove();
                }
            },
            id: "project-shortcuts-dialog"
        })
            .addCancel('Close', function () {
                dialog.remove();
            })
            .addPanel('',
                    navlinks.templates.projectshortcuts.headingWrapper({
                            title: projectName,
                            logoUrl: getLogoUrl(),
                            contentHtml : navlinks.templates.projectshortcuts.dialogLoading({ text: 'Retrieving links…' })
                        }))
            .show();

        updateDialogHeight(dialog);

        if (!dialogDataCache[projectKey]) {
            dialogDataCache[projectKey] = {
                entity: {
                    title: projectName
                },
                localShortcuts: null,
                remoteShortcuts: null
            };
            getData(AJS.contextPath() + '/rest/project-shortcuts/1.0/local/' + projectKey, { entityType: projectEntityType }).done(updateLocal);
            getData(AJS.contextPath() + '/rest/project-shortcuts/1.0/remote/' + projectKey, { entityType: projectEntityType }).done(updateRemote).fail(function () {
                var $wrapper = dialog.getCurrentPanel().body.find('.project-content-wrapper');
                $wrapper.find('.projectshortcuts-loading').remove();
                AJS.messages.error($wrapper, {
                    body: "Could not retrieve remote project shortcuts",
                    closeable: false
                });
                updateDialogHeight(dialog);
            });
        } else {
            updateShortcutsDialog(dialogDataCache[projectKey]);
        }

        function updateLocal(data) {
            dialogDataCache[projectKey].localShortcuts = data.shortcuts;
            updateShortcutsDialog(dialogDataCache[projectKey]);
        }
        function updateRemote(data) {
            dialogDataCache[projectKey].remoteShortcuts = data.shortcuts;
            updateShortcutsDialog(dialogDataCache[projectKey]);
        }
    }

    function getLogoUrl() { 
        return $(".project-shortcut-dialog-trigger img").attr("src");
    }

    function updateShortcutsDialog(data) {
        if (data.localShortcuts) { // Don't update the dialog until we have entity data and local links (stops the dialog from displaying remote links only if remote links has returned first)
            dialog.getCurrentPanel().html(
                    navlinks.templates.projectshortcuts.headingWrapper({
                        title: data.entity.title,
                        logoUrl: getLogoUrl(),
                        contentHtml: navlinks.templates.projectshortcuts.dialogContent(data)
                    }));

            updateDialogHeight(dialog);
        }
    }
    
    function truncateDesc(desc) {

        var trunc = 210;
        if(!desc || desc.length <= trunc)
            return desc;

        var i = trunc;
        while(i > 0 && desc.charAt(i) != " ") {
            i--;
        }
        if(i == 0) {
            i = trunc;
        }

        desc = desc.substring(0, i);
        if(desc.length >= i)
            desc = desc + "...";
        return desc;
    }

    /**
     * Since AJS.Dialog's height updating is completely broken we need to do it custom for our dialog
     * @param dialog
     */
    function updateDialogHeight(dialog) {
        var $dialog = dialog.popup.element,
            $body = $dialog.find('.dialog-panel-body'),
            $components = $dialog.find('.dialog-components');

        $body.height('auto');
        $dialog.height($components.outerHeight() - 1);
        $('.aui-shadow').remove();
    }

    function getData(url, data) {
        return $.ajax({
            url: url,
            cache: false,
            data: data,
            dataType: 'json'
        });
    }

    $(document).on('click', '.project-shortcut-dialog-trigger', showShortcutsDialog);
}(jQuery, window.NL = (window.NL || {})));
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:atlassian-ui-popup-display-controller', location = 'popups/DisplayController.js' */
AJS.Popups = AJS.Popups || {};

/**
 * Coordinate the display of popup dialogs requested from other functions in the application.
 *
 * Its responsibility is to organise the display of these popups so that that they do not come into conflict with
 * each other.
 */
AJS.Popups.DisplayController = function () {

    var _popupDialogRegistry = [];
    var _renderPerformed = false;
    var _dialogShown = false;

    AJS.toInit(function () {
        setTimeout(function () {
            AJS.Popups.DisplayController.render();
        }, 0);
    });

    return {

        /**
         * Request the display of a popup dialog to this controller.
         *
         * @param popupDialog An {Object} containing a request to display a popup dialog.
         */
        request:function (popupDialog) {
            _popupDialogRegistry.push(popupDialog);
            if (_renderPerformed && _dialogShown === false) {
                this.render();
            }
        },

        /**
         * Renders a popup dialog on screen.
         *
         * If more than one popup has been requested, it will render the one that has the lowest "weight",
         * if no popups have been requested, no dialog will be displayed.
         *
         */
        render:function () {
            _popupDialogRegistry.sort(function (first, second) {
                return first.weight - second.weight;
            });

            _renderPerformed = true;

            if (_popupDialogRegistry.length !== 0) {
                _dialogShown = true;
                _popupDialogRegistry[0].show();
            }
        }
    };
}();;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-web-plugin:issue-link-web-link', location = 'js/issuelink-weblink.js' */
(function () {
    var $hiddenImg = AJS.$("<img>"),
        $iconUrlInput,
        $urlInput,
        faviconUrl,
        throbberTimeoutId;

    $hiddenImg.load(function() {
        $iconUrlInput.val(faviconUrl);
        $urlInput.css("background-image", 'url("' + faviconUrl + '")');

        clearTimeout(throbberTimeoutId);
        $urlInput.removeClass("loading");
    });
    $hiddenImg.error(function() {
        clearTimeout(throbberTimeoutId);
        $urlInput.removeClass("loading");
    });

    function init(context) {
        $iconUrlInput = AJS.$("#web-link-icon-url", context);
        $urlInput = AJS.$("#web-link-url", context).bind("change", fetchFavicon);

        if ($iconUrlInput.val()) {
            $urlInput.css("background-image", "url(" + $iconUrlInput.val() + ")");
        }
    }

    function fetchFavicon() {
        // Initialise state
        $hiddenImg.attr("src", '');
        $iconUrlInput.val('');
        $urlInput.css("background-image", '');
        faviconUrl = parseFaviconUrl($urlInput.val());

        if (!faviconUrl) {
            return;
        }

        /**
         * IE specific hack: For some reason I cannot change the class inside event handler for the event source.
         */
        setTimeout(function() { $urlInput.addClass("loading"); }, 0);
        throbberTimeoutId = setTimeout(function() { $urlInput.removeClass("loading"); }, 3000);

        $hiddenImg.attr("src", faviconUrl);
    }

    function parseFaviconUrl(url) {
        var hostUrl = url.match(/^([^/]*\/\/[^/]+)/)[1];

        if (!hostUrl) {
            return;
        }

        return hostUrl + "/favicon.ico";
    }

    JIRA.bind(JIRA.Events.NEW_PAGE_ADDED, function (e, context) {
        init(context);
    });
})();;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/path.js' */
define("dndattachment/ctrlv/path", [
    "exports"
], function (
  exports
) {
    "use strict";

    /**
     * Get the basename of a URI (i.e. the last path component).
     * @param {String} uri
     * @returns {String}
     */
    var basename = function basename(uri) {
        return uri.split(/\//).pop();
    };

    exports.basename = basename;

    /**
     * Get everything *except* the basename of a URI.
     * @param {String} uri
     * @returns {String}
     */
    exports.dirname = function (uri) {
        var basenameResult = basename(uri);
        return uri.substring(0, uri.length - basenameResult.length);
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/ie_version.js' */
define("dndattachment/ctrlv/version", [
    "jquery",
    "underscore",
    "jira/util/navigator",
    "exports"
  ],
  function(
    $,
    _,
    Navigator,
    exports
  ){
    "use strict";


    // It's a sad state of affairs that we need this browser detection, but unfortunately there's no reliable feature
    // detection for image pasting from clipboard support, so we're left with browser detection.
    //
    // JIRA politely puts classes on <html> to identify the browser for us, so let's treat that as our browser detection
    // API. We only care about IE for special casing clipboard behaviour, for all other browsers we'll assume they
    // support the HTML5 clipboard API,
    var classes = document.documentElement.className.split(/\s+/);
    var isIE = Navigator.isIE();
    var gt7 = $.inArray("msie-gt-7", classes) > -1;
    var gt8 = $.inArray("msie-gt-8", classes) > -1;
    var gt9 = $.inArray("msie-gt-9", classes) > -1;
    var gt10 = $.inArray("msie-gt-10", classes) > -1;

    var isIE8  = isIE && gt7 && !gt8;
    var isIE9  = isIE && gt8 && !gt9;
    var isIE10 = isIE && gt9 && !gt10;

    exports.isIE8 = _.once(function(){
      return isIE8;
    });

    exports.isIE9 = _.once(function(){
      return isIE9;
    });

    exports.isIE10 = _.once(function(){
      return isIE10;
    });

});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/resource-uris.js' */
define("dndattachment/ctrlv/resource-uris", [
    "jquery",
    "exports"
], function (
  $,
  exports
) {
    "use strict";

    var dataKey = "com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources.resource-uris";
    var data = WRM.data.claim(dataKey) || {};

    exports.get = function(name) {
        return data[name];
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'templates/soy/attach-screenshot-form.soy' */
// This file was automatically generated from attach-screenshot-form.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Html5Screenshot.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Html5Screenshot == 'undefined') { JIRA.Templates.Html5Screenshot = {}; }


JIRA.Templates.Html5Screenshot.attachScreenshotForm = function(opt_data, opt_ignored) {
  return '<h2 class="dialog-title">' + soy.$$escapeHtml("Attach Screenshot") + '</h2><form action="ShowAttachScreenshotFormAction.jspa" class="aui" method="post" id="attach-screenshot-form" data-attach-secure-token="' + soy.$$escapeHtml(opt_data.attachUserToken) + '" data-submit-secure-token="' + soy.$$escapeHtml(opt_data.submitUserToken) + '"><input type="hidden" name="id" value="' + soy.$$escapeHtml(opt_data.id) + '"/><input type="hidden" name="atl_token" value="' + soy.$$escapeHtml(opt_data.atlToken) + '"><input type="hidden" name="formToken" value="' + soy.$$escapeHtml(opt_data.formToken) + '"><input type="hidden" name="filetoconvert" value=""><div class="attach-screenshot-padding"><div class="attach-screenshot-container"><div id="attach-screenshot-inner-container"><div class="mod-content"><ul class="item-details"><li><dl><dt>' + soy.$$escapeHtml("Take a screenshot:") + '</dt>' + ((opt_data.userPlatform == 'pc') ? '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3ePrtScn\x3c/kbd\x3e") + '</dd>' : '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3e\x26#8963; Ctrl\x3c/kbd\x3e + \x3ckbd\x3e\x26#8984; Cmd\x3c/kbd\x3e + \x3ckbd\x3e\x26#8679; Shift\x3c/kbd\x3e + \x3ckbd\x3e3\x3c/kbd\x3e") + '</dd>') + '</dl></li><li><dl><dt>' + soy.$$escapeHtml("Paste the image:") + '</dt>' + ((opt_data.userPlatform == 'pc') ? '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3eCtrl\x3c/kbd\x3e + \x3ckbd\x3ev\x3c/kbd\x3e") + '</dd>' : '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3e\x26#8984; Cmd\x3c/kbd\x3e + \x3ckbd\x3ev\x3c/kbd\x3e") + '</dd>') + '</dl></li></ul></div><input type="text" id="attach-screenshot-fake-input"><div class="attach-screenshot-padding attach-screenshot-padding-inner"><div id="attach-screenshot-image-container" class="attach-screenshot-image-container"><div class="attach-screenshot-placeholder"><div class="mod-content"><ul class="item-details"><li><dl><dt id="attach-screenshot-placeholder-message">' + soy.$$escapeHtml("Your image will be pasted here") + '</dt></dl></li></ul></div></div></div></div><div id=\'attach-max-size\' class="hidden">' + soy.$$escapeHtml(opt_data.maxSize) + '</div></div></div></div><fieldset><div><legend><span>' + soy.$$escapeHtml("Attach Screenshot") + '</span></legend><div id="attach-screenshot-filename-group" class="field-group"><div id="attach-screenshot-progress-container"></div><label for="attachscreenshotname">' + soy.$$escapeHtml("File name") + ' <span class="aui-icon icon-required">' + soy.$$escapeHtml("Required") + '</span></label><input class="text" type="text" id="attachscreenshotname" name="attachscreenshotname" title="File Name" value="' + soy.$$escapeHtml(opt_data.nextScreenshotName) + '"><div class="description">' + soy.$$escapeHtml("A file name to be used as attached image name") + '</div></div></div></fieldset><div class="buttons-container form-footer"><div class="buttons"><button class="aui-button aui-button-primary" id="attach-screenshot-html5-upload">' + soy.$$escapeHtml("Upload") + '</button><a href="#" class="cancel">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form>';
};
if (goog.DEBUG) {
  JIRA.Templates.Html5Screenshot.attachScreenshotForm.soyTemplateName = 'JIRA.Templates.Html5Screenshot.attachScreenshotForm';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/requireDeployJava.js' */
define("dndattachment/ctrlv/requireDeployJava", [
    "jquery",
    "dndattachment/ctrlv/resource-uris",
    "exports"
], function (
  $,
  resourceUris,
  exports
) {
    "use strict";

    var deployJavaPromise = null;

    /**
     * AMD-ish pattern akin to require('deployJava').
     *
     * Oracle provides a JavaScript function -- deployJava -- that makes it easy to install Java in the browser.
     * @returns a jQuery promise that's resolved with two arguments:
     *     - {Function} `deployJava`
     *     - {WindowProxy} the contentWindow where `deployJava` exists.
     */
    exports.requireDeployJava = function () {
        var deferred;

        if (deployJavaPromise !== null) {
            return deployJavaPromise;
        }

        deferred = $.Deferred();
        deployJavaPromise = deferred.promise();

        $('<iframe style="display: none !important; visibility: hidden !important; opacity: 0"/>')
            .attr('src', resourceUris.get("deployJava.html"))
            .one('load', function () {
                deferred.resolve(this.contentWindow.deployJava, this.contentWindow);
            })
            .one('error', deferred.reject.bind(deferred))
            .appendTo('body');

        return deployJavaPromise;
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/polyfill.js' */
define("dndattachment/ctrlv/polyfill", [
    "jquery",
    "underscore",
    "dndattachment/ctrlv/utility",
    "dndattachment/ctrlv/requireDeployJava",
    "dndattachment/ctrlv/resource-uris",
    "dndattachment/ctrlv/path",
    "dndattachment/ctrlv/version",
    "jira/ajs/ajax/smart-ajax",
    "exports"
], function (
  $,
  _,
  utility,
  requireDeployJava,
  resourceUris,
  path,
  version,
  SmartAjax,
  exports
) {
    "use strict";

    var appletNode;

    var pasteImageWidth = 510;
    var pasteImageHeight = 280;
    var dataURILimit = version.isIE8() ? 32000 : Number.MAX_VALUE;

    exports.pasteImageWidth = pasteImageWidth;
    exports.pasteImageHeight = pasteImageHeight;
    exports.dataURILimit = dataURILimit;

    /**
     * Create a rejected jQuery deferred. All arguments are passed to .reject().
     * @returns a jQuery deferred.
     */
    function fail() {
        var deferred = $.Deferred();
        return deferred.reject.apply(deferred, arguments);
    }

    var $node;

    // paste polyfill
    var handleKeydown = function (event) {
        if (utility.isKeyPasteEvent(event)) {
            appletNode.reload();
            var imageUri = appletNode.getClipboardData();
            if (imageUri) {
                var previewImageUri = appletNode.getClipboardData(pasteImageWidth, pasteImageHeight);
                if (previewImageUri.length > dataURILimit) {
                    var f = dataURILimit / previewImageUri.length;
                    previewImageUri = appletNode.getClipboardData(pasteImageWidth * f, pasteImageHeight * f);
                }
                $node.trigger('polyPaste', [imageUri, previewImageUri]);
            }
        }
    };

    /**
     * Use the Java applet to make a HTTP request.
     * @param data
     * @param requestUrl
     * @returns a jQuery deferred that pretends to be a jqXHR. The only addition is a '.abort()' method to try to
     *   conform closer to jqXHR API.
     */
    function executeAjaxUpload(data, requestUrl) {
        var cookies = document.cookies,
          deferred = $.Deferred();

        var xhr = {
            getResponseHeader: function (name) {
                return responseHeaders[name];
            }
        };

        var requestDeferred = new $.Deferred()
          .progress(_.bind(deferred.notify, deferred))
          .done(_.bind(deferred.resolve, deferred))
          .fail(function(error, responseJson) {
              var errorMessage = responseJson || JSON.stringify({ errorMessage: errorMessage });
              deferred.reject(null, null, null, new SmartAjax.SmartAjaxResult(xhr, 0, "error", errorMessage, true));
          });

        appletNode.doMultipartRequest(requestUrl, "UTF-8", window.navigator.userAgent, requestDeferred);
        // Java applets use the browser's cookie storage for URLConnection for non-http-only cookies. This means
        // xsrftoken and other cookies can pollute the browser's.
        deferred.always(function () {
            document.cookies = cookies;
        });
        return deferred;
    }

    /**
     * Install the polyfill to provide clipboard access to non-HTML5 browsers.
     *
     * @param {Element} node Where the 'keydown' event handler should be added.
     * @returns a jQuery promise that's resolved with [deployJava, contentWindow], or rejected
     *   with a [reason, message].
     *
     * Reasons include:
     * - "java-absent" -- Java isn't installed.
     * - "java-version" -- The version Java is not supported.
     * - "java-security" -- Java security settings are blocking the applet. Typically this can be overcome by
     *   lowering the 'Security Level' in Java's 'Control Panel' (e.g. from High to Medium).
     * - "unknown" -- Every other case.
     */
    exports.install = _.once(function (node) {
        $node = $(node);

        return requireDeployJava.requireDeployJava()
            .pipe(function (deployJava, contentWindow) {
                // Unfortunately using deployJava.versionCheck() isn't guaranteed to be accurate. Depending on the
                // platform and JRE. For example Java 1.7.0_06 on IE9 only reports the JRE as 1.7.0 (i.e. no update
                // information).
                // Given that the specific rules/cases/etc are ambiguous, we'll opt for doing a 'best effort' here
                // rather than hard coding a bunch of special case rules that aren't guaranteed to be reliable.
                var attributes,
                    parameters,
                    requiresLegacyApplet,
                    minimumVersion = '1.7.0_06',
                    uri;

                if (deployJava.getJREs().length === 0) {
                    return fail("java-absent");
                } else if (!deployJava.versionCheck(minimumVersion + '+')) {
                    return fail("java-version");
                }

                // Java 1.7.0_45 changed the manifest attributes that are required to allow JavaScript to invoke
                // applet methods. Java 1.7.0_40 and earlier requires the 'Trusted-Library' attribute, but later
                // versions require the 'Caller-Allowable-Codebase' attribute.
                //
                // See https://blogs.oracle.com/java-platform-group/entry/7u45_caller_allowable_codebase_and for more
                // details.
                requiresLegacyApplet = !deployJava.versionCheck('1.7.0_45+');
                uri = resourceUris.get(requiresLegacyApplet ? "clipboard-legacy.jar" : "clipboard.jar");

                attributes = {
                    id: 'JIRA HTML5 Images Applet',
                    codebase: path.dirname(uri),
                    code: "com.atlassian.plugins.jira.screenshot.applet.ScreenshotApplet.class",
                    archive: path.basename(uri),
                    width: 0,
                    height: 0
                };
                parameters = {
                    permissions: "all-permissions"
                };

                deployJava.runApplet(attributes, parameters, minimumVersion);
                appletNode = contentWindow.document.getElementById(attributes.id);

                try {
                    // We need a try/catch here because...
                    // A 'appletNode.isSecurity' doesn't work, because it's falsey on IE. We can use .hasOwnProperty
                    // but it doesn't tell us if it's a function, and 'typeof appletNode.isSecurity' returns
                    // "unknown".
                    if (!appletNode || !appletNode.isSecurityOk()) {
                        return fail("java-security");
                    }
                } catch (e) {
                    return fail("java-security");
                }

                if(! utility.isUnifiedAttachmentsEnabled()){
                    $node.on('keydown', handleKeydown);
                }
                return executeAjaxUpload;
            }, function () {
                return fail("unknown");
            })
            // Add a message to the error.
            .pipe(null, function (reason) {
                var messages;
                if(utility.isUnifiedAttachmentsEnabled()){
                    messages = {
                        "unknown": "A problem occurred while attempting to attach screenshot via Ctrl+V.",
                        "java-version": AJS.format("You need to {0}upgrade Java{1} to be able to attach screenshots via Ctrl+V.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-absent": AJS.format("You need to install {0}Java{1} to be able to attach screenshots via Ctrl+V.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-security": AJS.format("Your Java security settings are blocking the ability to attach screenshots via Ctrl+V. Please upgrade to the latest {0}Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>")
                    }
                } else {
                    messages = {
                        "unknown": "A problem occurred while running Java.",
                        "java-version": AJS.format("You need to {0}upgrade Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-absent": AJS.format("You need to install {0}Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-security": AJS.format("Your Java security settings are blocking this feature. Please upgrade to the latest {0}Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>")
                    }
                }

                return fail(reason, messages[reason]);
            });
    });

    exports.getClipboardData = function(){
        var deferred = new $.Deferred();
        exports.install(document).done(function(){
            try {
                appletNode.reload();
                deferred.resolve(appletNode.getClipboardData());
            } catch(e){
                deferred.reject("A problem occurred while attempting to attach screenshot via Ctrl+V.");
            }
        }).fail(function(reason, message){
            deferred.reject(message);
        });
        return deferred;
    };

    exports.isRequired = function () {
        // Enable the Java applet for IE 8/9/10, assume all other browsers are compatible, since we
        // support latest IE, Chrome, Firefox, and all of these support HTML5 clipboard.
        return version.isIE8() || version.isIE9() || version.isIE10();
    };

    exports.isRequiredForBinaryAjax = function () {
        // The applet has security restrictions on Windows 8 + IE10, so we can't use it there. Luckily IE10 supports
        // AJAX requests with binary data anyway, so we can use that. IE8 and IE9 don't support binary data.
        return version.isIE8() || version.isIE9();
    };

    // proxy ajax request, because session with temporary attachments is in applet
    exports.proxyAjaxRequest = function (fn, userTokenFn) {
        return function () {
            var _smartAjaxMakeRequest = SmartAjax.makeRequest;

            SmartAjax.makeRequest = function (requestOptions) {
                var requestParams = _.reduce(_.keys(requestOptions.data), function (r, name) {
                    r.push(name, requestOptions.data[name]);
                    return r;
                }, []);

                requestParams.push("secureToken", userTokenFn());

                var requestResult = appletNode.doAjaxRequest(requestOptions.url, "UTF-8", window.navigator.userAgent, $.Deferred(), requestParams);
                requestResult.abort = $.noop;
                requestResult.then(function (data) {
                    var responseHeaders = _.filter(arguments, function (el, idx) {
                        return idx > 0;
                    });
                    responseHeaders[0] = "Status";
                    responseHeaders = _.reduce(_.reduce(responseHeaders, function (r, el, idx) {
                        var pdx = (idx / 2) << 0;
                        (r[pdx] || (r[pdx] = [])).push(el);
                        return r;
                    }, []), function (r, el) {
                        r[el[0]] = el[1];
                        return r;
                    }, {});

                    var xhr = {
                        getResponseHeader: function (name) {
                            return responseHeaders[name];
                        }
                    };
                    var textStatus = 'success';
                    var smartAjaxResult = new SmartAjax.SmartAjaxResult(xhr, 0, "success", data, true);
                    requestOptions.complete(xhr, textStatus, smartAjaxResult);
                });

                return requestResult;
            };

            fn.apply(this, arguments);

            SmartAjax.makeRequest = _smartAjaxMakeRequest;
        };
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/html5.js' */
define("dndattachment/ctrlv/html5", [
    "jquery",
    "underscore",
    "dndattachment/ctrlv/polyfill",
    "dndattachment/ctrlv/base64decode",
    "dndattachment/ctrlv/utility",
    "jira/dialog/dialog",
    "jira/dialog/dialog-register",
    "jira/ajs/ajax/smart-ajax",
    "jira/attachment/inline-attach",
    "exports"
], function (
  $,
  _,
  polyfill,
  base64decode,
  utility,
  Dialog,
  DialogRegister,
  SmartAjax,
  InlineAttach,
  exports
) {
    "use strict";

    /**
     * Try to get File Blob from event object, function is asynchronous since on some browsers we may want to
     * implement an workaround for clipboardData.items/files absence
     *
     * @param event JQuery Event object
     * @returns {$.Deferred}
     */
    exports.getFileFromEvent = function (event) {
        var deferred = new $.Deferred();

        if (utility.isImagePasteEvent(event)) {
            // look for image content in items and files, check mimetype and return the first one
            deferred.resolve(
                _(event.clipboardData.items)
                    .filter(function (item) {
                        return item.type.indexOf("image") !== -1;
                    }).map(function (item) {
                        return item.getAsFile();
                    })[0] ||
                    // according to bugzilla in future Mozilla will support this via files:
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=891247
                _(event.clipboardData.files)
                    .filter(function (item) {
                        return item.type.indexOf("image") !== -1;
                    })[0]);
        } else {
            deferred.reject();
        }

        return deferred.promise();
    };

    //exports.screenshotPasteHandler = {
    exports.REQUEST_TIMEOUT_MILLIS = 5 * 60 * 1000;

    exports.screenshotFileUpload = {};
    exports.screenshotFileUploadUri = null;

    exports.$document = undefined;
    exports.$window = undefined;
    exports.$container = undefined;
    exports.$fakeInput = undefined;

    exports.uploadError = false;
    exports.uploadErrorMsg = "";

    exports.progressView = {
        hidden: false,
        progress: 0,
        old: 0,
        progressBarContainer: undefined,
        progressEl: undefined,
        container: undefined,
        options: undefined,
        staticProgress: undefined,

        initProgress: function () {
            this.container = this.buildContainer();
            this.progressEl = this.buildProgress();
            this.container.append(this.progressEl);

            this.options = {showPercentage: false, height: "5px"};

            this.progressBarContainer = $("#attach-screenshot-progress-container");
            this.progressBarContainer.empty();
            this.progressBarContainer.append(this.container);

            this.staticProgress = this.container;
            this.hidden = true;
        },

        finish: function () {
            this.value(100);
        },

        progressHandler: function (event) {
            var percentage = Math.round(event.loaded * 100 / event.total);
            this.value(percentage);
        },

        value: function (value) {
            if (value > 100) {
                value = 100;
            } else if (value < 0) {
                value = 0;
            }

            if (this.hidden) {
                this.progressEl.show();
                this.hidden = false;
            }

            if (this.old !== value) {
                this.progressEl.progressBar(value, this.options);
                if (value >= 100) {
                    this.progressEl.fadeOut();
                }
                this.old = value;
            }
        },

        buildContainer: function () {
            return $("<div>").addClass("file-progress");
        },

        buildProgress: function () {
            return $("<div>").attr("id", "attach-screenshot-upload-progress");
        }
    };

    exports.dialogView = {
        pasteCatcher: {},
        presenter: undefined,

        getMaxSize: function () {
            return $("#attach-max-size").text();
        },

        getFileSize: function () {
            if ($.isPlainObject(this.presenter.screenshotFileUpload) && _.isEmpty(this.presenter.screenshotFileUpload)) {
                return 0;
            }
            return this.presenter.screenshotFileUpload.size || this.presenter.screenshotFileUpload.byteLength || this.presenter.screenshotFileUpload.length;
        },

        cleanGeneralErrors: function () {
            $("#error-attach-screenshot-image").closest(".field-group").remove();
        },

        cleanFileErrors: function () {
            $("#error-attach-screenshot-filename").remove();
        },

        displayErrors: function (errors) {
            if(utility.isUnifiedAttachmentsEnabled()){
                if ("compatibility" in errors) {
                    utility.showErrorMsg("", errors["compatibility"]);
                }
                if ("fileName" in errors) {
                    utility.showErrorMsg("", errors["fileName"]);
                }
                if ("fileUpload" in errors) {
                    utility.showErrorMsg("", errors["fileUpload"]);
                }
            }
            else{
                // cleanup old error messages
                exports.dialogView.cleanFileErrors();
                exports.dialogView.cleanGeneralErrors();

                if ("compatibility" in errors) {
                    $("#attach-screenshot-inner-container").before(aui.message.error({
                        content: errors["compatibility"]
                    }));
                }
                if ("fileName" in errors) {
                    $("#attach-screenshot-filename-group").append("<div class=\"error\" id=\"error-attach-screenshot-filename\" data-field=\"attachscreenshotname\"></div>").find('.error').text(errors["fileName"]);
                }
                if ("fileUpload" in errors) {
                    $("#attach-screenshot-inner-container").append("<div class=\"field-group attach-screenshot-image-error\"><div class=\"error\" id=\"error-attach-screenshot-image\"></div></div>").find('.error').text(errors["fileUpload"]);
                }
            }
        },

        appendBlobImage: function (blob) {
            // and use a URL or webkitURL (whichever is available to the browser)
            // to create a temporary URL to the object
            var URLObj = window.URL || window.webkitURL;
            var source = URLObj.createObjectURL(blob);
            this.presenter.screenshotFileUpload = blob;
            this.createImage(source);
        },

        /**
         * Creates and shows image
         * Supports:
         *  Chrome binary data from Webkit
         *  base64 encoded data from FireFox
         * @param uri image data
         */
        createImage: function (uri) {
            var pastedImage = new Image();
            pastedImage.onload = function () {
                // You now have the image!
            };
            pastedImage.src = uri;

            this.presenter.screenshotToUpload = pastedImage;

            // Appending image to document
            var jqueryImage = $(pastedImage);
            jqueryImage.addClass("attach-screenshot-pasted-image");
            var screenshotContainer = $("#attach-screenshot-image-container");
            screenshotContainer.empty();
            screenshotContainer.append(jqueryImage);

            this.presenter.$fakeInput.focus();

            // handle async upload
            // IE11 quirk: if this is called within onPaste handler, browser will throw "Access denied" on any XHR
            _.defer(function () {
                exports.imageCreatedHandler();
            });

        },

        /**
         * Parse the input in the paste catcher element
         */
        checkInput: function () {
            var image,
              node = exports.dialogView.pasteCatcher.childNodes[0];

            if (node) {
                // If the user pastes an image, the src attribute
                // will represent the image as a base64 encoded string.
                if ("IMG" === node.tagName) {
                    // does not start with data, try to get contents via canvas
                    if (node.src.indexOf("data:") === 0) {
                        image = node.src;
                    } else {
                        // we could use canvas and toDataURL here, but it is not allowed by browser:
                        // https://html.spec.whatwg.org/multipage/scripting.html#dom-canvas-todataurl
                    }
                }

                // Clear the inner html to make sure we're always getting the latest inserted content.
                exports.dialogView.pasteCatcher.innerHTML = "";
            }

            if (!image) {
                exports.$fakeInput.focus();
            }

            return image;
        },

        /**
         * onPaste handler, Either uses webkits clipboardData object on the paste event, or interprets
         * the data uri that has been embedded in the page by firefox.
         */
        onPaste: function (event) {
            exports.dialogView.cleanFileErrors();
            exports.dialogView.cleanGeneralErrors();

            // TODO: ensure target is not text fields - this prevents pasting text in text fields

            // We need to check if event contains image content we can use
            if (utility.isImagePasteEvent(event)) {
                // Get the items from the clipboard
                exports.getFileFromEvent(event).then(function (file) {
                    this.appendBlobImage(file);
                }.bind(this));
                // If we can't handle clipboard data directly (Firefox),
                // we need to read what was pasted from the contenteditable element
            } else {
                setTimeout(function () {
                    var image = this.checkInput();

                    if (image) {
                        // Firefox image is base64 encoded - decoding while setting up the data
                        exports.screenshotFileUpload = base64decode.decodeBase64DataUri(image);
                        exports.dialogView.createImage(image);
                    }

                }.bind(this), 0);
            }
        },

        getFakeInput: function () {
            return $("#attach-screenshot-fake-input");
        },

        getContainer: function () {
            return $("#attach-screenshot-image-container");
        },

        getIssueKey: function () {
            return $("input[name='id']").val();
        },

        getDocument: function () {
            return $(document);
        },

        getWindow: function () {
            return $(window);
        },

        getFileNameInput: function () {
            return $("#attachscreenshotname");
        },

        hasPngExtension: function (str) {
            var pattern = /\.png$/i; // REGEX: Ends with ".png". Case insensitive
            return pattern.test(str);
        },

        setFileToConvert: function (value) {
            $("input[name='filetoconvert']").val(value);
        },

        /**
         * Pasting into a content-editable element is the most cross-browser HTML5 approach.
         */
        buildPasteCatcher: function () {
            if (!document.getElementById("attach-screenshot-form")) return;
            var catcher = document.createElement("div");
            catcher.setAttribute("contenteditable", "true");
            catcher.style.width = 0;
            catcher.style.height = 0;
            /* make sure the catcher is rendered outside the browser view to prevent vertical scrollbars */
            catcher.style.position = 'absolute';
            catcher.style.top = '-5000px';
            document.getElementById("attach-screenshot-form").appendChild(catcher);
            return catcher;
        },

        _getFormSubmits: function () {
            return $("#attach-screenshot-form").find("button.aui-button");
        },

        disable: function () {
            this._getFormSubmits().attr("disabled", "disabled");
            return this;
        },
        enable: function () {
            this._getFormSubmits().removeAttr("disabled");
            return this;
        },
        isEnabled: function () {
            return this.isVisible() && !this._getFormSubmits().attr("disabled");
        },

        isVisible: function () {
            return $("#attach-screenshot-form").length > 0;
        },

        initDialog: function (presenter) {
            this.pasteCatcher = {};
            this.presenter = presenter;

            if (!polyfill.isRequired()) {
                this.pasteCatcher = this.buildPasteCatcher();
            }
        }
    };

    exports.initScreenshotPasteHandler = function () {
        var dialogView = exports.dialogView;

        exports.screenshotFileUpload = {};
        exports.resetUploadErrors();

        exports.dialogView.initDialog(exports);

        // Caching elements needed to fix tabbing
        exports.$document = dialogView.getDocument();
        exports.$window = dialogView.getWindow();
        exports.$container = dialogView.getContainer();
        exports.$fakeInput = dialogView.getFakeInput();

        // Event Handlers
        exports.bindOnce(exports.$container, "click", exports.setFocusOnClickHandler);
        exports.bindOnce(exports.$fakeInput, "focus", exports.showFocusOnFieldHandler);
        exports.bindOnce(exports.$fakeInput, "blur", exports.hideFocusOnFieldHandler);
        exports.bindOnce(exports.$fakeInput, "keydown", exports.keyDownHandler);

        if (!utility.browserIsSupported()) {
            dialogView.displayErrors({"compatibility": AJS.format("Your browser is not supported. Consider using an alternative supported browser such as {0}Google Chrome{1} or {2}Firefox{3}.", "<a href=\"//www.google.com/chrome/browser/\">", "</a>", "<a href=\"//www.mozilla.org/firefox/\">", "</a>")});
        } else if (polyfill.isRequired()) {
            polyfill.install(document)
              .done(function (executeAjaxUploadFromApplet) {
                  exports.bindOnce(exports.$document, "polyPaste", exports.polyPasteHandler);
                  if (polyfill.isRequiredForBinaryAjax()) {
                      exports.executeAjaxUpload = executeAjaxUploadFromApplet;
                  }
              })
              .fail(function (reason, message) {
                  dialogView.displayErrors({"compatibility": message});
              });
        } else {
            exports.bindOnce(exports.$window, "paste", exports.pasteHandler);
        }
    };

    exports.resetUploadErrors = function () {
        exports.uploadError = false;
        exports.uploadErrorMsg = undefined;
    };

    exports.setUploadError = function (errorMsg) {
        exports.uploadError = true;
        exports.uploadErrorMsg = errorMsg;
    };

    /**
     * Ensures only one event is bound to the element
     * @param jqueryEl
     * @param eventName
     * @param handler
     */
    exports.bindOnce = function (jqueryEl, eventName, handler) {
        jqueryEl.unbind(eventName, handler);
        jqueryEl.bind(eventName, handler);
    };

    exports.showFocusOnFieldHandler = function () {
        exports.$container.addClass("focus");
    };

    exports.hideFocusOnFieldHandler = function () {
        exports.$container.addClass("focus");
    };

    exports.setFocusOnClickHandler = function () {
        exports.$fakeInput.focus();
    };

    exports.pasteHandler = function (event) {
        if (!exports.dialogView.isEnabled()) {
            return;
        }
        event = utility.normalizePasteEvent(event);

        exports.dialogView.onPaste(event);
    };

    exports.polyPasteHandler = function (event, imageUri, imagePreviewUri) {
        if (!exports.dialogView.isEnabled()) {
            return;
        }

        exports.screenshotFileUpload = {length: -1};
        exports.screenshotFileUploadUri = imageUri;
        exports.dialogView.createImage(imagePreviewUri);
    };

    exports.keyDownHandler = function (event) {
        if (utility.isKeyPasteEvent(event)) {
            if (exports.dialogView.pasteCatcher.focus) {
                exports.dialogView.pasteCatcher.focus();
            }
        }
    };

    exports.imageCreatedHandler = function () {
        exports.doAjaxUpload(this.dialogView.getIssueKey(), this.dialogView.getFileNameInput().val());
    };

    exports.getMimeType = function () {
        if (polyfill.isRequired()) {
            return "image/jpeg";
        }
        return "image/png";
    };

    exports.createData = function () {
        if (polyfill.isRequired() && !polyfill.isRequiredForBinaryAjax() && !utility.isUnifiedAttachmentsEnabled()) {
            return base64decode.decodeBase64DataUri(exports.screenshotFileUploadUri);
        }
        return exports.screenshotFileUpload;
    };

    // TODO function is not called delete?
    exports.clipboardDataIsEmpty = function (event) {
        // Internet Explorer will fire paste event for anything but image content, therefore we can assume that such event is not empty
        if (window.clipboardData != null) {
            return false;
        }

        return !(event && event.clipboardData && event.clipboardData.types && event.clipboardData.types.length > 0);
    };

    exports.validateFileSize = function (errors, fileSize, maxSize) {
        var fileSize = fileSize || exports.dialogView.getFileSize();
        var maxSize = maxSize || exports.dialogView.getMaxSize();
        if (fileSize > maxSize) {
            //TODO: hack, using IninleAttach module, check if this a blessed way to go
            var sizes = InlineAttach.Text.fileSize(maxSize, fileSize);
            errors["fileUpload"] = AJS.format("Screenshot is too large to attach. Attachment is {0} but the largest allowed attachment is {1}.", sizes[1], sizes[0]);
        }
    };

    exports.validateFormData = function (fileUpload, fileName) {
        var errors = {};

        if ($.isPlainObject(fileUpload) && _.isEmpty(fileUpload)) {
            errors["fileUpload"] = "Please paste the image you wish to upload";
        }
        exports.validateFileSize(errors);
        if (exports.uploadError) {
            errors["fileUpload"] = "The error occurred during image upload - you will need to try the pasting image again. Sorry for the inconvenience.";
        }

        if ("" == fileName) {
            errors["fileName"] = "You must specify a filename of the image.";
        }

        if (!utility.isValidFileName(fileName)) {
            errors["fileName"] = "Filename must not contain the characters \'\\\', \'/\', \'\"\', \':\', \'?\', \'*\', \'\u003c\', \'|\', \'\u003e\', \'!\'";
        }
        return errors;
    };

    exports.doAjaxUpload = function (issueKey, fileName) {
        exports.dialogView.disable();

        var errors = {};
        exports.validateFileSize(errors);
        if (!_.isEmpty(errors)) {
            exports.dialogView.displayErrors(errors);
            exports.dialogView.enable();

            // Prevent form from uploading
            return;
        }

        var data = exports.createData(),
          mimeType = exports.getMimeType(),
          secureToken = $("#attach-screenshot-form").data("attach-secure-token"),
          formToken = $("#attach-screenshot-form").find("input[name='formToken']").attr('value');

        var requestUrl = AJS.contextPath() + "/rest/internal/1.0/AttachTemporaryFile" +
          (polyfill.isRequired() ? "/secure?" : "?") +
          "size=" + exports.dialogView.getFileSize() + "&" +
          "filename=" + encodeURIComponent(fileName) + "&" +
          "atl_token=" + encodeURIComponent(atl_token()) + "&" +
          "issueId=" + encodeURIComponent(this.dialogView.getIssueKey()) +
          (secureToken ? ("&secureToken=" + encodeURIComponent(secureToken)) : "") +
          (formToken ? ("&formToken=" + encodeURIComponent(formToken)) : "");

        exports.resetUploadErrors();
        exports.executeAjaxUpload(data, requestUrl, mimeType).progress(function (val) {
            if (val == 'init') {
                exports.progressView.initProgress();
            }
        }).done(function (val) {
            if (typeof val == "string") {
                val = JSON.parse(val);
            }

            exports.dialogView.setFileToConvert(val.id);
        }).fail(function (jqXHR, textStatus, msg, smartAjaxResult) {
            var errMsg;
            if (smartAjaxResult.statusText == "abort") {
                errMsg = "The call to the JIRA server did not complete within the timeout period.  We are unsure of the result of this operation.";
            } else if (smartAjaxResult.hasData) {
                var data = JSON.parse(smartAjaxResult.data);

                if (data.errorMessage) {
                    errMsg = data.errorMessage;
                } else {
                    errMsg = SmartAjax.buildSimpleErrorContent(smartAjaxResult, {alert: false});
                }
            }
            exports.setUploadError(errMsg);
            exports.dialogView.displayErrors({"fileUpload": errMsg});
        }).always(function () {
            var deferred = $.Deferred();

            // polyfill is required so we need a new secureToken
            if (polyfill.isRequired()) {
                exports.reloadSecureToken(deferred);
            } else {
                deferred.resolve();
            }

            deferred.then(function () {
                exports.dialogView.enable();
                // Progress Listener cleanup
                exports.progressView.finish();
            });
        }).progress(function (val) {
            if (val != 'init') {
                exports.progressView.progressHandler(val);
            }
        });
    };

    exports.executeAjaxUpload = function (data, requestUrl, mimeType) {
        var deferred = $.Deferred();

        var xhr = SmartAjax.makeRequest({
            type: 'POST',
            url: requestUrl,
            contentType: mimeType,
            processData: false,
            data: data,
            timeout: exports.REQUEST_TIMEOUT_MILLIS,
            success: deferred.resolve.bind(deferred),
            error: deferred.reject.bind(deferred),
            xhr: function () {
                var xhr = $.ajaxSettings.xhr();

                deferred.notify('init');
                xhr.upload.addEventListener("progress", deferred.notify.bind(deferred));
                return xhr;
            }
        });

        deferred.always(function () {
            $.ajaxSettings.xhr().removeEventListener("progress", exports.progressView.progressHandler);
            $(DialogRegister.attachScreenshotDialog).off("Dialog.hide", xhr.abort);
        });

        // cancel upload on dialog hide
        $(DialogRegister.attachScreenshotDialog).one("Dialog.hide", xhr.abort);

        return deferred.promise();
    };

    exports.reloadSecureToken = function (deferred) {
        var formUrl = AJS.contextPath() + "/secure/ShowAttachScreenshotFormAction!default.jspa?" +
          "id=" + encodeURIComponent(this.dialogView.getIssueKey()) +
          "&inline=true&decorator=dialog&_=" + (new Date().getTime());

        $.get(formUrl).then(function (response) {
            var newToken = $(response).find("#attach-screenshot-form").data("attach-secure-token");
            if (newToken) {
                $("#attach-screenshot-form").data("attach-secure-token", newToken);
                deferred.resolve(newToken);
            } else {
                deferred.reject();
            }
        }, _.bind(deferred.reject, deferred));
    };

    /**
     * Trigger Attach Screenshot dialog and resolve deferred once it is open
     *
     * @returns {$.Deferred}
     */
    exports.show = function () {
        var deferred = new $.Deferred();
        var $dialogTrigger = $(".issueaction-attach-screenshot-html5.aui-list-item-link");

        // Such situation is not supported yet
        // TODO remove once we add support for textfields in create issue dialog (temporary attachments problem)
        if (Dialog.current != null) {
            return deferred.reject().promise();
        }

        // trigger is not available
        // TODO refactor when we start supporting create issue dialog
        if ($dialogTrigger.length == 0) {
            return deferred.reject().promise();
        }

        // IE11 quirk: if this is called within onPaste handler, browser will throw "Access denied" on any XHR
        _.defer(function () {
            $dialogTrigger.trigger("click");
        });

        $(document).on("dialogContentReady", function (event, dialog) {
            if (dialog === DialogRegister.attachScreenshotDialog &&
              exports.dialogView.isEnabled()) {
                deferred.resolve(dialog);
            } else {
                deferred.reject();
            }
        });

        // each impression of dialog causes ajax request, reject deferred if there was request for dialog content, but after some brief time deferred was still not resolved
        $(document).on("ajaxComplete.jira.screenshot.dialog", function (event, jqXhr, options) {
            if (options.url.indexOf($dialogTrigger.attr("href")) > -1) {
                setTimeout(function () {
                    if (!deferred.isResolved()) {
                        deferred.reject();
                    }
                }, 1000);
            }
        });

        // unbind from ajaxComplete
        deferred.always(function () {
            $(document).off("ajaxComplete.jira.screenshot.dialog");
        });

        return deferred.promise();
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/issue-paste.js' */
define("dndattachment/ctrlv/issue-paste", [
    "jquery",
    "dndattachment/ctrlv/trace",
    "dndattachment/ctrlv/tracking",
    "dndattachment/ctrlv/utility",
    "dndattachment/ctrlv/html5",
    "dndattachment/ctrlv/polyfill",
    "dndattachment/ctrlv/base64decode",
    "jira/dialog/dialog",
    "jira/util/events",
    'dndattachment/util/events/types',
    "exports"
], function (
  $,
  trace,
  tracker,
  utility,
  html5,
  polyfill,
  base64decode,
  Dialog,
  Events,
  EventTypes,
  exports
) {
    "use strict";

    /** Ze State Machine **/

    // Event types
    var EVENT_WINDOW_KEYDOWN = 0;
    var EVENT_WINDOW_PASTE = 1;

    var EVENT_FILE_LOADED = 2;
    var EVENT_FILE_LOAD_ERROR = 3;

    var EVENT_IMAGE_LOADED = 4;
    var EVENT_IMAGE_LOAD_ERROR = 5;

    var EVENT_DIALOG_LOADED = 6;
    var EVENT_DIALOG_CLOSED = 7;
    var EVENT_DIALOG_CANCELED = 8;

    var EVENT_TIMEOUT = 9;
    /**
     * Stub function, does nothing, in future may wrap states in some default behavior
     * @param {Function} state
     * @returns {State}
     * @constructor
     */
    function State(stateName, state) {
        state.stateName = stateName;
        var result = function() {
            var handler = state.apply(null, arguments);
            handler.stateName = stateName;
            return handler;
        };
        result.stateName = stateName;

        return result;
    }

    /**
     * Wraps given state, so that it will receive EVENT_TIMEOUT event after given timeout
     * @param {Function} state
     * @param {Number} timeout in milliseconds
     * @returns {WeakState}
     * @constructor
     */
    function WeakState(stateName, state, timeoutDelay) {
        return State(stateName, function() {
            var timeout = setTimeout(function() {
                triggerEvent(EVENT_TIMEOUT);
            }, timeoutDelay);

            var handler = state.apply(null, arguments);
            var result = function(eventType, eventObject) {
                var result = handler(eventType, eventObject);
                // we will change state, so clear timeout
                if(result) {
                    clearTimeout(timeout);
                    return result;
                }
            };
            result.stateName = stateName;

            return result;
        });
    }

    /**
     * Idle state, initial
     */
    var StateIdle = State("idle", function() {

        function isValidTarget(event) {
            // - don't play with catching paste events on any input elements other than wiki-textfield
            // - ignore content editable, because it will rather handle paste on its own
            // - summary field is an exception, because it is focused by default in create issue dialog
            if($(event.target).is(':input:not(.wiki-textfield, #summary)') || utility.isContentEditable(event.target)) {
                return;
            }

            return true;
        }


        return function(eventType, eventObject) {
            // We have this just in case something goes wrong after OD deployment
            if(utility.isIssuePasteDisabledEnabled()) {
                trace("jira/attach-images-plugin/issuePasteDisabled");
                return;
            }

            if(eventType == EVENT_WINDOW_KEYDOWN && utility.isKeyPasteEvent(eventObject)) {
                // in chrome we rely 100% on onPaste event, in Safari we don't want to make any attempts on catching clipboard data
                if (utility.browserIsNativePaste() || !isValidTarget(eventObject) || !utility.browserIsSupported()) {
                    return;
                }

                tracker.trigger("attach.screenshot.html5.catchClipboard");

                return new StateCatchClipboard(eventObject);
            }

            if(eventType == EVENT_WINDOW_PASTE) {
                if(utility.isImagePasteEvent(eventObject)) {
                    tracker.trigger("attach.screenshot.html5.handlePaste");

                    if(!isValidTarget(eventObject)) {
                        trace("jira/attach-images-plugin/pasteIgnored");
                        return;
                    }

                    /** Prevent paste now so after pressing cancel in dialog selected fragment in textarea won't be removed */
                    if($(eventObject.target).is(':input.wiki-textfield')) {
                        eventObject.preventDefault();
                    }

                    return new StateFileLoading(eventObject);
                } else {
                    trace("jira/attach-images-plugin/pasteIgnoredNotImage");
                }
            }
        }
    });

    /**
     * Catch clipboard contents after CTRL+V
     * @param {Event} keyPasteEvent
     */
    var StateCatchClipboard = WeakState("catchClipboard", function(keyPasteEvent) {
        // we will switch focus from currently active element, but we want to restore it once we are done with this state
        var activeElement = document.activeElement;

        // preserve initial selection information for later use
        keyPasteEvent.selectionStart = keyPasteEvent.target.selectionStart;
        keyPasteEvent.selectionEnd = keyPasteEvent.target.selectionEnd;

        var $contentEditable = $('<div contenteditable="true" class="attach-screenshot-paste-catcher"></div>').appendTo('body');

        // focus on content editable, so the paste event will go into this element and we will get content from it (possible an image)
        $contentEditable.focus();

        // we rely on :focusable or :aui-focusable selector from AUI, we don't want to refocus on non focusable elements, because
        // it may cause unnecessary scroll
        // also focus only on input input elements
        if($(activeElement).is(':focusable:input,:aui-focusable:input')) {
            // this quirk is required for FF, otherwise it will bug cursor
            setTimeout(function() {
                activeElement.focus();
            });
        }

        // TODO refactor this, so we won't need to call this each time we want to leave this state
        function cleanUp() {
            $contentEditable.remove();
        }

        return function(eventType, eventObject) {
            if(eventType == EVENT_WINDOW_PASTE) {
                if(utility.isImagePasteEvent(eventObject)) {
                    cleanUp();

                    eventObject.target = activeElement;
                    return new StateFileLoading(eventObject);
                }

                if(utility.isHtmlImagePasteEvent(eventObject)) {
                    cleanUp();

                    eventObject.target = activeElement;
                    return new StateImageLoading(eventObject);
                }

                if(utility.isTextPasteEvent(eventObject)) {
                    cleanUp();

                    var text1 = utility.getTextPasteContent(eventObject);
                    utility.insertToInput(text1, keyPasteEvent.target, keyPasteEvent.selectionStart, keyPasteEvent.selectionEnd);

                    // This is required for consistent behavior, IE requires preventDefault, while others don't
                    eventObject.preventDefault();

                    return new StateIdle();
                }
            }

            if(eventType == EVENT_TIMEOUT) {
                cleanUp();

                var $img = $contentEditable.find('>img');
                if($img.is(':only-child')) {
                    var imgSrc = $img.attr("src");
                    if (imgSrc.toLowerCase().indexOf("http") === 0) {
                        // we could use canvas and toDataURL here, but it is not allowed by browser:
                        // https://html.spec.whatwg.org/multipage/scripting.html#dom-canvas-todataurl
                        return StateIdle();
                    }
                    else {
                        var array = base64decode.decodeBase64DataUri(imgSrc);
                        var blob = new Blob([array], {type: "image/png"});

                        return new StateAttachImage(blob, keyPasteEvent);
                    }
                } else {
                    // special handling for IE10
                    if(polyfill.isRequired() && !$contentEditable.text()){
                        // if we are here, we know:
                        // - user pressed Ctrl+v while not in a text field
                        // - the clipboard does not contain text (if it did it would have been handled elsewhere)
                        // this is a good place to attempt to load the java applet.
                        // We are not certain the user is trying to paste an image,
                        // but if not they can just choose not to load the applet.
                        return new StateAppletLoading(keyPasteEvent);
                    }
                    else {
                        // there was no image paste, so we need to reinsert pasted text into text input
                        var text2 = utility.getTextContent($contentEditable[0]);
                        utility.insertToInput(text2, keyPasteEvent.target, keyPasteEvent.selectionStart, keyPasteEvent.selectionEnd);

                        return StateIdle();
                    }
                }
            }
        }
    });

    var StateAppletLoading = State("appletLoading", function(keyPasteEvent) {
        polyfill.getClipboardData().done(function(imgUri){
            var array = base64decode.decodeBase64DataUri(imgUri);
            var blob = new Blob([array], {type: "image/jpeg"});
            triggerEvent(EVENT_IMAGE_LOADED, blob);
        }).fail(function(message){
            utility.showErrorMsg("", message);
            triggerEvent(EVENT_IMAGE_LOAD_ERROR);
        });

        return function(eventType, blob){
            if(eventType == EVENT_IMAGE_LOADED){
                return new StateAttachImage(blob, keyPasteEvent);
            }
            if(eventType == EVENT_IMAGE_LOAD_ERROR) {
                return new StateIdle();
            }
        }
    });

    /**
     * Load File from image, this state is not weak, because we expect file loading to take some time
     * @param {Event} pasteEvent that contains text/html in clipboardData
     */
    var StateImageLoading = State("imageLoading", function(pasteEvent) {
        var imageSrc = utility.getHtmlImagePaste(pasteEvent);
        if(!imageSrc) {
            triggerEvent(EVENT_IMAGE_LOAD_ERROR);
        } else {
            utility.loadImage(imageSrc).then(function(image) {
                triggerEvent(EVENT_IMAGE_LOADED, image);
            }, triggerEvent.bind(null, EVENT_IMAGE_LOAD_ERROR));
        }

        return function(eventType, eventObject) {
            if(eventType == EVENT_IMAGE_LOADED) {
                var file = utility.convertImageToBlob(eventObject);

                if(file) {
                    return new StateAttachImage(file, pasteEvent);
                } else {
                    return new StateIdle();
                }
            }

            if(eventType == EVENT_TIMEOUT || eventType == EVENT_IMAGE_LOAD_ERROR) {
                return new StateIdle();
            }
        }
    });

    /**
     * Handle paste event, get file open attach screenshot dialog
     * @param {Event} pasteEvent
     */
    var StateFileLoading = WeakState("fileLoading", function(pasteEvent) {
        html5.getFileFromEvent(pasteEvent).done(function (file) {
            triggerEvent(EVENT_FILE_LOADED, file);
        }).fail(function () {
            triggerEvent(EVENT_FILE_LOAD_ERROR);
        });

        return function(eventType, eventObject) {
            if (eventType == EVENT_FILE_LOADED) {
                return new StateAttachImage(eventObject, pasteEvent);
            } else if (eventType == EVENT_FILE_LOAD_ERROR || eventType == EVENT_TIMEOUT) {
                return new StateIdle();
            }
        }
    }, 1000);

    var StateAttachImage = State("attachImage", function(file, pasteEvent) {
        var pasteTarget =  pasteEvent.target;
        var screenshotName = utility.generateFileName() + (polyfill.isRequired() ? ".jpg" : ".png");

        var pastedImage = utility.convertBlobToImage(file, screenshotName);

        Events.trigger(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, {
            files: [pastedImage],
            // We want the attachment executor to know if a wiki textfield is in focus
            // so that the executor can then decide whether it wants to perform its action.
            isWikiTextfieldFocused: utility.isWikiTextfield($(pasteTarget)),
            wikiTextfield: pasteTarget,
            // Tell the dropzone whether the files came from a paste or from an actual drag and drop
            isPaste: true,
            successCallback: function() {
                triggerEvent(EVENT_DIALOG_LOADED)
            }
        });

        return function(eventType, eventObject) {
            return new StateIdle();
        };
    });

    /**
     * Current state, which will receive next event, initilized with {StateIdle}
     * @type {State}
     */
    var currentState = new StateIdle();

    /**
     * Trigger current state with given parameters
     * @param {Number} eventType
     * @param {Object} eventObject
     */
    function triggerEvent(eventType, eventObject) {
        // some states may call this function during initialization, therefore there is a need to queue such events
        // in order to avoid nested executions
        if(triggerEvent.eventQueue) {
            triggerEvent.eventQueue.push({ type: eventType, object: eventObject });
            return;
        }

        triggerEvent.eventQueue = [{ type: eventType, object: eventObject }];

        while(triggerEvent.eventQueue.length > 0) {
            var event = triggerEvent.eventQueue.splice(0, 1)[0];
            var newState = currentState(event.type, event.object);
            if(newState) {
                currentState = newState;
            }
        }

        delete triggerEvent.eventQueue;
    }

    /**
     * Required for tests
     */
    exports._getStateMap = function() {
        return {
            events: {
                EVENT_WINDOW_KEYDOWN: EVENT_WINDOW_KEYDOWN,
                EVENT_WINDOW_PASTE: EVENT_WINDOW_PASTE,

                EVENT_FILE_LOADED: EVENT_FILE_LOADED,
                EVENT_FILE_LOAD_ERROR: EVENT_FILE_LOAD_ERROR,

                EVENT_IMAGE_LOADED: EVENT_IMAGE_LOADED,
                EVENT_IMAGE_LOAD_ERROR: EVENT_IMAGE_LOAD_ERROR,

                EVENT_DIALOG_LOADED: EVENT_DIALOG_LOADED,
                EVENT_DIALOG_CLOSED: EVENT_DIALOG_CLOSED,
                EVENT_DIALOG_CANCELED: EVENT_DIALOG_CANCELED,

                EVENT_TIMEOUT: EVENT_TIMEOUT
            },
            states: {
                StateIdle: StateIdle,
                StateCatchClipboard: StateCatchClipboard,
                StateAppletLoading: StateAppletLoading,
                StateImageLoading: StateImageLoading,
                StateFileLoading: StateFileLoading,
                StateAttachImage: StateAttachImage
            }
        }
    };

    exports.initIssuePaste = function () {
        // handle CTRL+V on wiki textfields
        $(window).on('keydown', function (event) {
            triggerEvent(EVENT_WINDOW_KEYDOWN, event);
        });
        $(window).on("paste", function (event) {
            triggerEvent(EVENT_WINDOW_PASTE, utility.normalizePasteEvent(event));
        });
        Events.bind("Dialog.hide", function (event, $popup, reason) {
            if (reason) {
                triggerEvent(EVENT_DIALOG_CANCELED, $popup);
            } else {
                triggerEvent(EVENT_DIALOG_CLOSED, $popup);
            }
        });
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/trace.js' */
define("dndattachment/ctrlv/trace", [], function () {
  "use strict";
  // tests often redefine JIRA.trace this avoid grabbing a stale version
  return function amdJiraTrace() {
    return JIRA.trace.apply(undefined, arguments);
  };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/tracking.js' */
define("dndattachment/ctrlv/tracking", [
  "exports"
], function (
  exports
) {
  "use strict";
  exports.trigger = function (analyticKey, payload) {
    AJS.trigger("analytics", {name: analyticKey, data: payload || {}});
  };
});

;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/executor.js' */
define("dndattachment/ctrlv/executor", [
    "jquery",
    "jira/util/events",
    "dndattachment/ctrlv/html5",
    "dndattachment/upload/handler",
    "exports"
], function (
    $,
    Events,
    html5,
    DnDUploadHandler,
    exports
) {

    exports.register = function () {
        /*
         * This executor spawns the attach screenshot dialog and is only valid if user pastes an attachment via ctrlv.
         */
        var ctrlvExecutor = {
            name: 'JIRA Ctrl+V attachment executor',
            // This weight is higher than the default executor (weight 0) and lower than the ServiceDesk executor (weight 50)
            weight: 5,
            isValid: function (event, args) {
                return !!args.isPaste;
            },
            processFiles: function (files, attachmentDropZone) {
                var deferred = $.Deferred();
                html5.show().done(function (dialog) {
                    var $el = $("#attach-screenshot-placeholder-message");
                    var evt = $.Event("paste");
                    evt.clipboardData = {files: files};
                    $el.focus();
                    setTimeout(function() {
                        $el.trigger(evt)
                    });

                    Events.bind("Dialog.hide", function (event, $popup, reason) {
                        if (reason) {
                            deferred.reject();
                        }
                        else {
                            // If there is no reason, then we know the file was uploaded successfully.
                            deferred.resolve([$popup.find('#attachscreenshotname').val() + '.png']);
                        }
                    });
                });

                return deferred;
            }
        };

        DnDUploadHandler.registerExecutor(ctrlvExecutor);
    }

});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/initialize.js' */
define("dndattachment/ctrlv/initialize", [
  "jquery",
  "underscore",
  "dndattachment/ctrlv/polyfill",
  "dndattachment/ctrlv/utility",
  "dndattachment/ctrlv/html5",
  "dndattachment/ctrlv/issue-paste",
  "dndattachment/ctrlv/tracking",
  "dndattachment/ctrlv/executor",
  "jira/dialog/dialog-register",
  "jira/dialog/form-dialog",
  "exports"
], function (
  $,
  _,
  polyfill,
  utility,
  html5,
  issue_paste,
  tracker,
  executor,
  DialogRegister,
  FormDialog,
  exports
) {
  "use strict";

  // Initialization of HTML5 paste handler
  exports.init = function() {
    var AttachImageDialog = FormDialog.extend({
      options: {}
    });

    /**
     * SW-306 js errors are present when this reference isn't available in global scope
     * @deprecated
     */
    JIRA.ScreenshotDialog = AttachImageDialog;

    issue_paste.initIssuePaste();

    // Upload and Cancel Button Handlers
    $(document).ready(function () {
      "use strict";

      var delayShowUntil = $.Deferred();

      if (!utility.browserIsSupported() || !polyfill.isRequired()) {
        delayShowUntil.resolve();
      }

      // Shows the Attach Screenshot in a Popup
      DialogRegister.attachScreenshotDialog = new AttachImageDialog({
        id: "attach-screenshot-dialog",
        trigger: "a.issueaction-attach-screenshot-html5",
        isIssueDialog: true,
        onContentRefresh: function attachScreenshotContentRefresh() {

          this.$form.bind("before-submit", function attachScreenshotContentRefreshBeforeSubmit(e) {
            var errors = html5.validateFormData(html5.screenshotFileUpload, $.trim(html5.dialogView.getFileNameInput().val()));
            if (html5.dialogView.getFileSize() == 0) {
              e.preventDefault();
              return false;
            } else if (!_.isEmpty(errors)) {
              html5.dialogView.displayErrors(errors);
              e.preventDefault();
              return false;
            }
            return true;
          });

        },
        delayShowUntil: function () {
          if (polyfill.isRequired()) {
            polyfill.install(document)
              .done(function () {
                AttachImageDialog.prototype._submitForm = polyfill.proxyAjaxRequest(AttachImageDialog.prototype._submitForm, function () {
                  return $("#attach-screenshot-form").data("submit-secure-token");
                });
              })
              .always(function () {
                delayShowUntil.resolve();
              });
          }
          return delayShowUntil;
        }
      });

      $(document).bind("dialogContentReady", function (event, dialog) {
        // Ensure that the dialog is *ours*, and that it's showing the Attach screen shot form. It's possible that
        // it's populated with an error from the server, in which case we wouldn't want to "init" it.
        if (dialog === DialogRegister.attachScreenshotDialog && document.getElementById("attach-screenshot-form") !== null) {
          tracker.trigger("attach.screenshot.html5.contentReady");
          html5.initScreenshotPasteHandler();
        }
      });

      $(document).ready(function () {
        // Atlassian Analytics - Capture click events
        $(document).on("click", "#attach-screenshot-html5", function () {
          tracker.trigger("attach.screenshot.html5.display");
        });
      });
    });

    executor.register();
  };
});

require([
  "dndattachment/ctrlv/initialize",
  "jquery"
], function(
  jhtml5,
  $
) {
  "use strict";
  $(function() { jhtml5.init(); });
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'applet/deployJava.js' */
/*
 * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * deployJava.js
 *
 * This file is part of the Deployment Toolkit.  It provides functions for web
 * pages to detect the presence of a JRE, install the latest JRE, and easily run
 * applets or Web Start programs.  More Information on usage of the
 * Deployment Toolkit can be found in the Deployment Guide at:
 * http://docs.oracle.com/javase/6/docs/technotes/guides/jweb/index.html
 *
 * The "live" copy of this file may be found at :
 * http://java.com/js/deployJava.js.
 * For web pages provisioned using https, you may want to access the copy at:
 * https://java.com/js/deployJava.js.
 *
 * You are encouraged to link directly to the live copies.
 * The above files are stripped of comments and whitespace for performance,
 * You can access this file w/o the whitespace and comments removed at:
 * http://java.com/js/deployJava.txt.
 *
 */

var deployJava = function() {
    /** HTML attribute filter implementation */
    var hattrs = {
        core: [ 'id', 'class', 'title', 'style' ],
        i18n: [ 'lang', 'dir' ],
        events: [ 'onclick', 'ondblclick', 'onmousedown', 'onmouseup',
            'onmouseover', 'onmousemove', 'onmouseout', 'onkeypress',
            'onkeydown', 'onkeyup' ],
        applet: [ 'codebase', 'code', 'name', 'archive', 'object',
            'width', 'height', 'alt', 'align', 'hspace', 'vspace' ],
        object: [ 'classid', 'codebase', 'codetype', 'data', 'type',
            'archive', 'declare', 'standby', 'height', 'width', 'usemap',
            'name', 'tabindex', 'align', 'border', 'hspace', 'vspace' ]
    };

    var object_valid_attrs = hattrs.object.concat(hattrs.core, hattrs.i18n,
        hattrs.events);
    var applet_valid_attrs = hattrs.applet.concat(hattrs.core);

    // generic log function, use console.log unless it isn't available
    // then revert to alert()
    function log(message) {
        if ( ! rv.debug ) {return};

        if (console.log) {
            console.log(message);
        } else {
            alert(message);
        }
    }

    //checks where given version string matches query
    //
    //NB: assume format is correct. Can add format check later if needed
    // from dtjava.js
    function versionCheckEx(query, version) {
        if (query == null || query.length == 0) return true;

        var c = query.charAt(query.length - 1);

        //if it is not explicit pattern but does not have update version then need to append *
        if (c != '+' && c != '*' && (query.indexOf('_') != -1 && c != '_')) {
            query = query + "*";
            c = '*';
        }

        query = query.substring(0, query.length - 1);
        //if query ends with ".", "_" then we want to strip it to allow match of "1.6.*" to shorter form such as "1.6"
        //TODO: add support for match of "1.7.0*" to "1.7"?
        if (query.length > 0) {
            var z = query.charAt(query.length - 1);
            if (z == '.' || z == '_') {
                query = query.substring(0, query.length - 1);
            }
        }
        if (c == '*') {
            //it is match if version starts from it
            return (version.indexOf(query) == 0);
        } else if (c == '+') {
            //match if query string is lexicographically smaller
            return query <= version;
        }
        return false;
    }

    function getWebStartLaunchIconURL() {
        var imageUrl = '//java.com/js/webstart.png';
        try {
            // for http/https; use protocol less url; use http for all other protocol
            return document.location.protocol.indexOf('http') != -1 ?
                imageUrl : 'http:' + imageUrl;
        } catch (err) {
            return 'http:' + imageUrl;
        }
    }

    // GetJava page
    function constructGetJavaURL(query) {

        var getJavaURL = 'http://java.com/dt-redirect';

        if (query == null || query.length == 0) return getJavaURL;
        if(query.charAt(0) == '&')
        {
            query = query.substring(1, query.length);
        }
        return getJavaURL + '?'+  query;
    }

    function arHas(ar, attr) {
        var len = ar.length;
        for (var i = 0; i < len; i++) {
            if (ar[i] === attr) return true;
        }
        return false;
    }

    function isValidAppletAttr(attr) {
        return arHas(applet_valid_attrs, attr.toLowerCase());
    }

    function isValidObjectAttr(attr) {
        return arHas(object_valid_attrs, attr.toLowerCase());
    }

    /**
     * returns true if we can enable DT plugin auto-install without chance of
     * deadlock on cert mismatch dialog
     *
     * requestedJREVersion param is optional - if null, it will be
     * treated as installing any JRE version
     *
     * DT plugin for 6uX only knows about JRE installer signed by SUN cert.
     * If it encounter Oracle signed JRE installer, it will have chance of
     * deadlock when running with IE.  This function is to guard against this.
     */
    function enableWithoutCertMisMatchWorkaround(requestedJREVersion) {

        // Non-IE browser are okay
        if ('MSIE' != deployJava.browserName) return true;

        // if DT plugin is 10.0.0 or above, return true
        // This is because they are aware of both SUN and Oracle signature and
        // will not show cert mismatch dialog that might cause deadlock
        if (deployJava.compareVersionToPattern(deployJava.getPlugin().version,
            ["10", "0", "0"], false, true)) {
            return true;
        }

        // If we got there, DT plugin is 6uX

        if (requestedJREVersion  == null) {
            // if requestedJREVersion is not defined - it means ANY.
            // can not guarantee it is safe to install ANY version because 6uX
            // DT does not know about Oracle certificates and may deadlock
            return false;
        }

        // 6u32 or earlier JRE installer used Sun certificate
        // 6u33+ uses Oracle's certificate
        // DT in JRE6 does not know about Oracle certificate => can only
        // install 6u32 or earlier without risk of deadlock
        return !versionCheckEx("1.6.0_33+", requestedJREVersion);
    }

    /* HTML attribute filters */

    var rv = {

        debug: null,

        /* version of deployJava.js */
        version: "20120801",

        firefoxJavaVersion: null,

        myInterval: null,
        preInstallJREList: null,
        returnPage: null,
        brand: null,
        locale: null,
        installType: null,

        EAInstallEnabled: false,
        EarlyAccessURL: null,


        // mime-type of the DeployToolkit plugin object
        oldMimeType: 'application/npruntime-scriptable-plugin;DeploymentToolkit',
        mimeType: 'application/java-deployment-toolkit',

        /* location of the Java Web Start launch button graphic is right next to
         * deployJava.js at:
         *    http://java.com/js/webstart.png
         *
         * Use protocol less url here for http/https support
         */
        launchButtonPNG: getWebStartLaunchIconURL(),

        browserName: null,
        browserName2: null,

        /**
         * Returns an array of currently-installed JRE version strings.
         * Version strings are of the form #.#[.#[_#]], with the function returning
         * as much version information as it can determine, from just family
         * versions ("1.4.2", "1.5") through the full version ("1.5.0_06").
         *
         * Detection is done on a best-effort basis.  Under some circumstances
         * only the highest installed JRE version will be detected, and
         * JREs older than 1.4.2 will not always be detected.
         */
        getJREs: function() {
            var list = new Array();
            if (this.isPluginInstalled()) {
                var plugin =  this.getPlugin();
                var VMs = plugin.jvms;
                for (var i = 0; i < VMs.getLength(); i++) {
                    list[i] = VMs.get(i).version;
                }
            } else {
                var browser = this.getBrowser();

                if (browser == 'MSIE') {
                    if (this.testUsingActiveX('1.7.0')) {
                        list[0] = '1.7.0';
                    } else if (this.testUsingActiveX('1.6.0')) {
                        list[0] = '1.6.0';
                    } else if (this.testUsingActiveX('1.5.0')) {
                        list[0] = '1.5.0';
                    } else if (this.testUsingActiveX('1.4.2')) {
                        list[0] = '1.4.2';
                    } else if (this.testForMSVM()) {
                        list[0] = '1.1';
                    }
                } else if (browser == 'Netscape Family') {
                    this.getJPIVersionUsingMimeType();
                    if (this.firefoxJavaVersion != null) {
                        list[0] = this.firefoxJavaVersion;
                    } else if (this.testUsingMimeTypes('1.7')) {
                        list[0] = '1.7.0';
                    } else if (this.testUsingMimeTypes('1.6')) {
                        list[0] = '1.6.0';
                    } else if (this.testUsingMimeTypes('1.5')) {
                        list[0] = '1.5.0';
                    } else if (this.testUsingMimeTypes('1.4.2')) {
                        list[0] = '1.4.2';
                    } else if (this.browserName2 == 'Safari') {
                        if (this.testUsingPluginsArray('1.7.0')) {
                            list[0] = '1.7.0';
                        } else if (this.testUsingPluginsArray('1.6')) {
                            list[0] = '1.6.0';
                        } else if (this.testUsingPluginsArray('1.5')) {
                            list[0] = '1.5.0';
                        } else if (this.testUsingPluginsArray('1.4.2')) {
                            list[0] = '1.4.2';
                        }
                    }
                }
            }

            if (this.debug) {
                for (var i = 0; i < list.length; ++i) {
                    log('[getJREs()] We claim to have detected Java SE ' + list[i]);
                }
            }

            return list;
        },

        /**
         * Triggers a JRE installation.  The exact effect of triggering an
         * installation varies based on platform, browser, and if the
         * Deployment Toolkit plugin is installed.
         *
         * The requestVersion string is of the form #[.#[.#[_#]]][+|*],
         * which includes strings such as "1.4", "1.5.0*", and "1.6.0_02+".
         * A star (*) means "any version starting within this family" and
         * a plus (+) means "any version greater or equal to this".
         * "1.5.0*" * matches 1.5.0_06 but not 1.6.0_01, whereas
         * "1.5.0+" matches both.
         *
         * installCallback is an optional argument which holds a reference
         * to a javascript callback function for reporting install status.
         *
         * If the Deployment Toolkit plugin is not present, this will just call
         * this.installLatestJRE().
         */
        installJRE: function(requestVersion, installCallback) {
            var ret = false;
            if (this.isPluginInstalled() &&
                this.isAutoInstallEnabled(requestVersion)) {
                var installSucceeded = false;
                if (this.isCallbackSupported()) {
                    installSucceeded =
                        this.getPlugin().installJRE(requestVersion, installCallback);
                } else {
                    installSucceeded = this.getPlugin().installJRE(requestVersion);
                }

                if (installSucceeded) {
                    this.refresh();
                    if (this.returnPage != null) {
                        document.location = this.returnPage;
                    }
                }
                return installSucceeded;
            } else {
                return this.installLatestJRE();
            }
        },

        /**
         * returns true if jre auto install for the requestedJREVersion is enabled
         * for the local system; false otherwise
         *
         * requestedJREVersion param is optional - if not specified, it will be
         * treated as installing any JRE version
         *
         * DT plugin for 6uX only knows about JRE installer signed by SUN cert.
         * If it encounter Oracle signed JRE installer, it will have chance of
         * deadlock when running with IE.  This function is to guard against this.
         */
        isAutoInstallEnabled: function(requestedJREVersion) {
            // if no DT plugin, return false
            if (!this.isPluginInstalled()) return false;

            if (typeof requestedJREVersion  == 'undefined') {
                requestedJREVersion = null;
            }

            return enableWithoutCertMisMatchWorkaround(requestedJREVersion);

        },

        /**
         * returns true if jre install callback is supported
         * callback support is added since dt plugin version 10.2.0 or above
         */
        isCallbackSupported: function() {
            return this.isPluginInstalled() &&
                this.compareVersionToPattern(this.getPlugin().version,
                    ["10", "2", "0"], false, true);
        },

        /**
         * Triggers a JRE installation.  The exact effect of triggering an
         * installation varies based on platform, browser, and if the
         * Deployment Toolkit plugin is installed.
         *
         * In the simplest case, the browser window will be redirected to the
         * java.com JRE installation page, and (if possible) a redirect back to
         * the current URL upon successful installation.  The return redirect is
         * not always possible, as the JRE installation may require the browser to
         * be restarted.
         *
         * installCallback is an optional argument which holds a reference
         * to a javascript callback function for reporting install status.
         *
         * In the best case (when the Deployment Toolkit plugin is present), this
         * function will immediately cause a progress dialog to be displayed
         * as the JRE is downloaded and installed.
         */
        installLatestJRE: function(installCallback) {
            if (this.isPluginInstalled() && this.isAutoInstallEnabled()) {
                var installSucceeded = false;
                if (this.isCallbackSupported()) {
                    installSucceeded = this.getPlugin().installLatestJRE(installCallback);
                } else {
                    installSucceeded = this.getPlugin().installLatestJRE();
                }
                if (installSucceeded) {
                    this.refresh();
                    if (this.returnPage != null) {
                        document.location = this.returnPage;
                    }
                }
                return installSucceeded;
            } else {
                var browser = this.getBrowser();
                var platform = navigator.platform.toLowerCase();
                if ((this.EAInstallEnabled == 'true') &&
                    (platform.indexOf('win') != -1) &&
                    (this.EarlyAccessURL != null)) {

                    this.preInstallJREList = this.getJREs();
                    if (this.returnPage != null) {
                        this.myInterval =
                            setInterval("deployJava.poll()", 3000);
                    }

                    location.href = this.EarlyAccessURL;

                    // we have to return false although there may be an install
                    // in progress now, when complete it may go to return page
                    return false;
                } else {
                    if (browser == 'MSIE') {
                        return this.IEInstall();
                    } else if ((browser == 'Netscape Family') &&
                        (platform.indexOf('win32') != -1)) {
                        return this.FFInstall();
                    } else {
                        location.href = constructGetJavaURL(
                            ((this.returnPage != null) ?
                                ('&returnPage=' + this.returnPage) : '') +
                                ((this.locale != null) ?
                                    ('&locale=' + this.locale) : '') +
                                ((this.brand != null) ?
                                    ('&brand=' + this.brand) : ''));
                    }
                    // we have to return false although there may be an install
                    // in progress now, when complete it may go to return page
                    return false;
                }
            }
        },


        /**
         * Ensures that an appropriate JRE is installed and then runs an applet.
         * minimumVersion is of the form #[.#[.#[_#]]], and is the minimum
         * JRE version necessary to run this applet.  minimumVersion is optional,
         * defaulting to the value "1.1" (which matches any JRE).
         * If an equal or greater JRE is detected, runApplet() will call
         * writeAppletTag(attributes, parameters) to output the applet tag,
         * otherwise it will call installJRE(minimumVersion + '+').
         *
         * After installJRE() is called, the script will attempt to detect that the
         * JRE installation has completed and begin running the applet, but there
         * are circumstances (such as when the JRE installation requires a browser
         * restart) when this cannot be fulfilled.
         *
         * As with writeAppletTag(), this function should only be called prior to
         * the web page being completely rendered.  Note that version wildcards
         * (star (*) and plus (+)) are not supported, and including them in the
         * minimumVersion will result in an error message.
         */
        runApplet: function(attributes, parameters, minimumVersion) {
            if (minimumVersion == 'undefined' || minimumVersion == null) {
                minimumVersion = '1.1';
            }

            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";

            var matchData = minimumVersion.match(regex);

            if (this.returnPage == null) {
                // if there is an install, come back here and run the applet
                this.returnPage = document.location;
            }

            if (matchData != null) {
                var browser = this.getBrowser();
                if (browser != '?') {
                    if (this.versionCheck(minimumVersion + '+')) {
                        this.writeAppletTag(attributes, parameters);
                    } else if (this.installJRE(minimumVersion + '+')) {
                        // after successful install we need to refresh page to pick
                        // pick up new plugin
                        this.refresh();
                        location.href = document.location;
                        this.writeAppletTag(attributes, parameters);
                    }
                } else {
                    // for unknown or Safari - just try to show applet
                    this.writeAppletTag(attributes, parameters);
                }
            } else {
                log('[runApplet()] Invalid minimumVersion argument to runApplet():' +
                    minimumVersion);
            }
        },


        /**
         * Outputs an applet tag with the specified attributes and parameters, where
         * both attributes and parameters are associative arrays.  Each key/value
         * pair in attributes becomes an attribute of the applet tag itself, while
         * key/value pairs in parameters become <PARAM> tags.  No version checking
         * or other special behaviors are performed; the tag is simply written to
         * the page using document.writeln().
         *
         * As document.writeln() is generally only safe to use while the page is
         * being rendered, you should never call this function after the page
         * has been completed.
         */
        writeAppletTag: function(attributes, parameters) {
            var startApplet = '<' + 'applet ';
            var params = '';
            var endApplet = '<' + '/' + 'applet' + '>';
            var addCodeAttribute = true;

            if (null == parameters || typeof parameters != 'object') {
                parameters = new Object();
            }

            for (var attribute in attributes) {
                if (! isValidAppletAttr(attribute)) {
                    parameters[attribute] = attributes[attribute];
                } else {
                    startApplet += (' ' +attribute+ '="' +attributes[attribute] + '"');
                    if (attribute == 'code') {
                        addCodeAttribute = false;
                    }
                }
            }

            var codebaseParam = false;
            for (var parameter in parameters) {
                if (parameter == 'codebase_lookup') {
                    codebaseParam = true;
                }
                // Originally, parameter 'object' was used for serialized
                // applets, later, to avoid confusion with object tag in IE
                // the 'java_object' was added.  Plugin supports both.
                if (parameter == 'object' || parameter == 'java_object' ||
                    parameter == 'java_code' ) {
                    addCodeAttribute = false;
                }
                params += '<param name="' + parameter + '" value="' +
                    parameters[parameter] + '"/>';
            }
            if (!codebaseParam) {
                params += '<param name="codebase_lookup" value="false"/>';
            }

            if (addCodeAttribute) {
                startApplet += (' code="dummy"');
            }
            startApplet += '>';

            document.write(startApplet + '\n' + params + '\n' + endApplet);
        },


        /**
         * Returns true if there is a matching JRE version currently installed
         * (among those detected by getJREs()).  The versionPattern string is
         * of the form #[.#[.#[_#]]][+|*], which includes strings such as "1.4",
         * "1.5.0*", and "1.6.0_02+".
         * A star (*) means "any version within this family" and a plus (+) means
         * "any version greater or equal to the specified version".  "1.5.0*"
         * matches 1.5.0_06 but not 1.6.0_01, whereas "1.5.0+" matches both.
         *
         * If the versionPattern does not include all four version components
         * but does not end with a star or plus, it will be treated as if it
         * ended with a star.  "1.5" is exactly equivalent to "1.5*", and will
         * match any version number beginning with "1.5".
         *
         * If getJREs() is unable to detect the precise version number, a match
         * could be ambiguous.  For example if getJREs() detects "1.5", there is
         * no way to know whether the JRE matches "1.5.0_06+".  versionCheck()
         * compares only as much of the version information as could be detected,
         * so versionCheck("1.5.0_06+") would return true in in this case.
         *
         * Invalid versionPattern will result in a JavaScript error alert.
         * versionPatterns which are valid but do not match any existing JRE
         * release (e.g. "32.65+") will always return false.
         */
        versionCheck: function(versionPattern)
        {
            var index = 0;
            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?(\\*|\\+)?$";

            var matchData = versionPattern.match(regex);

            if (matchData != null) {
                // default is exact version match
                // examples:
                //    local machine has 1.7.0_04 only installed
                //    exact match request is "1.7.0_05":  return false
                //    family match request is "1.7.0*":   return true
                //    minimum match request is "1.6+":    return true
                var familyMatch = false;
                var minMatch = false;

                var patternArray = new Array();

                for (var i = 1; i < matchData.length; ++i) {
                    // browser dependency here.
                    // Fx sets 'undefined', IE sets '' string for unmatched groups
                    if ((typeof matchData[i] == 'string') && (matchData[i] != '')) {
                        patternArray[index] = matchData[i];
                        index++;
                    }
                }

                if (patternArray[patternArray.length-1] == '+') {
                    // + specified in request - doing a minimum match
                    minMatch = true;
                    familyMatch = false;
                    patternArray.length--;
                } else if (patternArray[patternArray.length-1] == '*') {
                    // * specified in request - doing a family match
                    minMatch = false;
                    familyMatch = true;
                    patternArray.length--;
                } else if (patternArray.length < 4) {
                    // versionPattern does not include all four version components
                    // and does not end with a star or plus, it will be treated as
                    // if it ended with a star. (family match)
                    minMatch = false;
                    familyMatch = true;
                }

                var list = this.getJREs();
                for (var i = 0; i < list.length; ++i) {
                    if (this.compareVersionToPattern(list[i], patternArray,
                        familyMatch, minMatch)) {
                        return true;
                    }
                }

                return false;
            } else {
                var msg = 'Invalid versionPattern passed to versionCheck: ' +
                    versionPattern;
                log('[versionCheck()] ' + msg);
                alert(msg);
                return false;
            }
        },


        /**
         * Returns true if an installation of Java Web Start of the specified
         * minimumVersion can be detected.  minimumVersion is optional, and
         * if not specified, '1.4.2' will be used.
         * (Versions earlier than 1.4.2 may not be detected.)
         */
        isWebStartInstalled: function(minimumVersion) {

            var browser = this.getBrowser();
            if (browser == '?') {
                // we really don't know - better to try to use it than reinstall
                return true;
            }

            if (minimumVersion == 'undefined' || minimumVersion == null) {
                minimumVersion = '1.4.2';
            }

            var retval = false;
            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";
            var matchData = minimumVersion.match(regex);

            if (matchData != null) {
                retval = this.versionCheck(minimumVersion + '+');
            } else {
                log('[isWebStartInstaller()] Invalid minimumVersion argument to isWebStartInstalled(): ' + minimumVersion);
                retval = this.versionCheck('1.4.2+');
            }
            return retval;
        },

        // obtain JPI version using navigator.mimeTypes array
        // if found, set the version to this.firefoxJavaVersion
        getJPIVersionUsingMimeType: function() {
            // Walk through the full list of mime types.
            for (var i = 0; i < navigator.mimeTypes.length; ++i) {
                var s = navigator.mimeTypes[i].type;
                // The jpi-version is the plug-in version.  This is the best
                // version to use.
                var m = s.match(/^application\/x-java-applet;jpi-version=(.*)$/);
                if (m != null) {
                    this.firefoxJavaVersion = m[1];
                    // Opera puts the latest sun JRE last not first
                    if ('Opera' != this.browserName2) {
                        break;
                    }
                }
            }
        },

        // launch the specified JNLP application using the passed in jnlp file
        // the jnlp file does not need to have a codebase
        // this requires JRE 7 or above to work
        // if machine has no JRE 7 or above, we will try to auto-install and then launch
        // (function will return false if JRE auto-install failed)
        launchWebStartApplication: function(jnlp) {
            var uaString = navigator.userAgent.toLowerCase();

            this.getJPIVersionUsingMimeType();

            // make sure we are JRE 7 or above
            if (this.isWebStartInstalled('1.7.0') == false) {

                // perform latest JRE auto-install
                if ((this.installJRE('1.7.0+') == false) ||
                    ((this.isWebStartInstalled('1.7.0') == false))) {
                    return false;
                }
            }

            var jnlpDocbase = null;

            // use document.documentURI for docbase
            if (document.documentURI) {
                jnlpDocbase = document.documentURI;
            }

            // fallback to document.URL if documentURI not available
            if (jnlpDocbase == null) {
                jnlpDocbase = document.URL;
            }

            var browser = this.getBrowser();

            var launchTag;

            if (browser == 'MSIE') {

                launchTag = '<' +
                    'object classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93" ' +
                    'width="0" height="0">' +
                    '<' + 'PARAM name="launchjnlp" value="' + jnlp + '"' + '>' +
                    '<' + 'PARAM name="docbase" value="' + jnlpDocbase + '"' + '>' +
                    '<' + '/' + 'object' + '>';
            } else if (browser == 'Netscape Family') {

                launchTag = '<' +
                    'embed type="application/x-java-applet;jpi-version=' +
                    this.firefoxJavaVersion + '" ' +
                    'width="0" height="0" ' +
                    'launchjnlp="' +  jnlp + '"' +
                    'docbase="' +  jnlpDocbase + '"' +
                    ' />';
            }

            if (document.body == 'undefined' || document.body == null) {
                document.write(launchTag);
                // go back to original page, otherwise current page becomes blank
                document.location = jnlpDocbase;
            } else {
                var divTag = document.createElement("div");
                divTag.id = "div1";
                divTag.style.position = "relative";
                divTag.style.left = "-10000px";
                divTag.style.margin = "0px auto";
                divTag.className ="dynamicDiv";
                divTag.innerHTML = launchTag;
                document.body.appendChild(divTag);
            }
        },

        createWebStartLaunchButtonEx: function(jnlp, minimumVersion) {

            if (this.returnPage == null) {
                // if there is an install, come back and run the jnlp file
                this.returnPage = jnlp;
            }

            var url = 'javascript:deployJava.launchWebStartApplication(\'' + jnlp +
                '\');';

            document.write('<' + 'a href="' + url +
                '" onMouseOver="window.status=\'\'; ' +
                'return true;"><' + 'img ' +
                'src="' + this.launchButtonPNG + '" ' +
                'border="0" /><' + '/' + 'a' + '>');
        },


        /**
         * Outputs a launch button for the specified JNLP URL.  When clicked, the
         * button will ensure that an appropriate JRE is installed and then launch
         * the JNLP application.  minimumVersion is of the form #[.#[.#[_#]]], and
         * is the minimum JRE version necessary to run this JNLP application.
         * minimumVersion is optional, and if it is not specified, '1.4.2'
         * will be used.
         * If an appropriate JRE or Web Start installation is detected,
         * the JNLP application will be launched, otherwise installLatestJRE()
         * will be called.
         *
         * After installLatestJRE() is called, the script will attempt to detect
         * that the JRE installation has completed and launch the JNLP application,
         * but there are circumstances (such as when the JRE installation
         * requires a browser restart) when this cannot be fulfilled.
         */
        createWebStartLaunchButton: function(jnlp, minimumVersion) {

            if (this.returnPage == null) {
                // if there is an install, come back and run the jnlp file
                this.returnPage = jnlp;
            }

            var url = 'javascript:' +
                'if (!deployJava.isWebStartInstalled(&quot;' +
                minimumVersion + '&quot;)) {' +
                'if (deployJava.installLatestJRE()) {' +
                'if (deployJava.launch(&quot;' + jnlp + '&quot;)) {}' +
                '}' +
                '} else {' +
                'if (deployJava.launch(&quot;' + jnlp + '&quot;)) {}' +
                '}';

            document.write('<' + 'a href="' + url +
                '" onMouseOver="window.status=\'\'; ' +
                'return true;"><' + 'img ' +
                'src="' + this.launchButtonPNG + '" ' +
                'border="0" /><' + '/' + 'a' + '>');
        },


        /**
         * Launch a JNLP application, (using the plugin if available)
         */
        launch: function(jnlp) {
            /*
             * Using the plugin to launch Java Web Start is disabled for the time being
             */
            document.location=jnlp;
            return true;
        },


        /*
         * returns true if the ActiveX or XPI plugin is installed
         */
        isPluginInstalled: function() {
            var plugin = this.getPlugin();
            if (plugin && plugin.jvms) {
                return true;
            } else {
                return false;
            }
        },

        /*
         * returns true if the plugin is installed and AutoUpdate is enabled
         */
        isAutoUpdateEnabled: function() {
            if (this.isPluginInstalled()) {
                return this.getPlugin().isAutoUpdateEnabled();
            }
            return false;
        },

        /*
         * sets AutoUpdate on if plugin is installed
         */
        setAutoUpdateEnabled: function() {
            if (this.isPluginInstalled()) {
                return this.getPlugin().setAutoUpdateEnabled();
            }
            return false;
        },

        /*
         * sets the preferred install type : null, online, kernel
         */
        setInstallerType: function(type) {
            this.installType = type;
            if (this.isPluginInstalled()) {
                return this.getPlugin().setInstallerType(type);
            }
            return false;
        },

        /*
         * sets additional package list - to be used by kernel installer
         */
        setAdditionalPackages: function(packageList) {
            if (this.isPluginInstalled()) {
                return this.getPlugin().setAdditionalPackages(
                    packageList);
            }
            return false;
        },

        /*
         * sets preference to install Early Access versions if available
         */
        setEarlyAccess: function(enabled) {
            this.EAInstallEnabled = enabled;
        },

        /*
         * Determines if the next generation plugin (Plugin II) is default
         */
        isPlugin2: function() {
            if (this.isPluginInstalled()) {
                if (this.versionCheck('1.6.0_10+')) {
                    try {
                        return this.getPlugin().isPlugin2();
                    } catch (err) {
                        // older plugin w/o isPlugin2() function -
                    }
                }
            }
            return false;
        },

        //support native DT plugin?
        allowPlugin: function() {
            this.getBrowser();

            // Safari and Opera browsers find the plugin but it
            // doesn't work, so until we can get it to work - don't use it.
            var ret = ('Safari' != this.browserName2 &&
                'Opera' != this.browserName2);

            return ret;
        },

        getPlugin: function() {
            this.refresh();

            var ret = null;
            if (this.allowPlugin()) {
                ret = document.getElementById('deployJavaPlugin');
            }
            return ret;
        },

        compareVersionToPattern: function(version, patternArray,
                                          familyMatch, minMatch) {
            if (version == undefined || patternArray == undefined) {
                return false;
            }
            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";
            var matchData = version.match(regex);

            if (matchData != null) {
                var index = 0;
                var result = new Array();

                for (var i = 1; i < matchData.length; ++i) {
                    if ((typeof matchData[i] == 'string') && (matchData[i] != ''))
                    {
                        result[index] = matchData[i];
                        index++;
                    }
                }

                var l = Math.min(result.length, patternArray.length);

                // result contains what is installed in local machine
                // patternArray is what is being requested by application
                if (minMatch) {
                    // minimum version match, return true if what we have (installed)
                    // is greater or equal to what is requested.  false otherwise.
                    for (var i = 0; i < l; ++i) {
                        if (result[i] < patternArray[i]) {
                            return false;
                        } else if (result[i] > patternArray[i]) {
                            return true;
                        }
                    }
                    return true;
                } else {
                    for (var i = 0; i < l; ++i) {
                        if (result[i] != patternArray[i]) return false;
                    }
                    if (familyMatch) {
                        // family match - return true as long as what we have
                        // (installed) matches up to the request pattern
                        return true;
                    } else {
                        // exact match
                        // result and patternArray needs to have exact same content
                        return (result.length == patternArray.length);
                    }
                }
            } else {
                return false;
            }
        },

        getBrowser: function() {

            if (this.browserName == null) {
                var browser = navigator.userAgent.toLowerCase();

                log('[getBrowser()] navigator.userAgent.toLowerCase() -> ' + browser);


                // order is important here.  Safari userAgent contains mozilla,
                // IE 11 userAgent contains mozilla and netscape,
                // and Chrome userAgent contains both mozilla and safari.
                if ((browser.indexOf('msie') != -1) && (browser.indexOf('opera') == -1)) {
                    this.browserName = 'MSIE';
                    this.browserName2 = 'MSIE';
                } else if (browser.indexOf('trident') != -1 || browser.indexOf('Trident') != -1) {
                    this.browserName = 'MSIE';
                    this.browserName2 = 'MSIE';
                } else if (browser.indexOf('iphone') != -1) {
                    // this included both iPhone and iPad
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'iPhone';
                } else if ((browser.indexOf('firefox') != -1) && (browser.indexOf('opera') == -1)) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Firefox';
                } else if (browser.indexOf('chrome') != -1) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Chrome';
                } else if (browser.indexOf('safari') != -1) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Safari';
                } else if ((browser.indexOf('mozilla') != -1) && (browser.indexOf('opera') == -1)) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Other';
                } else if (browser.indexOf('opera') != -1) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Opera';
                } else {
                    this.browserName = '?';
                    this.browserName2 = 'unknown';
                }

                log('[getBrowser()] Detected browser name:'+ this.browserName +
                    ', ' + this.browserName2);
            }
            return this.browserName;
        },


        testUsingActiveX: function(version) {
            var objectName = 'JavaWebStart.isInstalled.' + version + '.0';

            // we need the typeof check here for this to run on FF/Chrome
            // the check needs to be in place here - cannot even pass ActiveXObject
            // as arg to another function
            if (typeof ActiveXObject == 'undefined' || !ActiveXObject) {
                log('[testUsingActiveX()] Browser claims to be IE, but no ActiveXObject object?');
                return false;
            }

            try {
                return (new ActiveXObject(objectName) != null);
            } catch (exception) {
                return false;
            }
        },


        testForMSVM: function() {
            var clsid = '{08B0E5C0-4FCB-11CF-AAA5-00401C608500}';

            if (typeof oClientCaps != 'undefined') {
                var v = oClientCaps.getComponentVersion(clsid, "ComponentID");
                if ((v == '') || (v == '5,0,5000,0')) {
                    return false;
                } else {
                    return true;
                }
            } else {
                return false;
            }
        },


        testUsingMimeTypes: function(version) {
            if (!navigator.mimeTypes) {
                log ('[testUsingMimeTypes()] Browser claims to be Netscape family, but no mimeTypes[] array?');
                return false;
            }

            for (var i = 0; i < navigator.mimeTypes.length; ++i) {
                s = navigator.mimeTypes[i].type;
                var m = s.match(/^application\/x-java-applet\x3Bversion=(1\.8|1\.7|1\.6|1\.5|1\.4\.2)$/);
                if (m != null) {
                    if (this.compareVersions(m[1], version)) {
                        return true;
                    }
                }
            }
            return false;
        },

        testUsingPluginsArray: function(version) {
            if ((!navigator.plugins) || (!navigator.plugins.length)) {
                return false;
            }
            var platform = navigator.platform.toLowerCase();

            for (var i = 0; i < navigator.plugins.length; ++i) {
                s = navigator.plugins[i].description;
                if (s.search(/^Java Switchable Plug-in (Cocoa)/) != -1) {
                    // Safari on MAC
                    if (this.compareVersions("1.5.0", version)) {
                        return true;
                    }
                } else if (s.search(/^Java/) != -1) {
                    if (platform.indexOf('win') != -1) {
                        // still can't tell - opera, safari on windows
                        // return true for 1.5.0 and 1.6.0
                        if (this.compareVersions("1.5.0", version) ||
                            this.compareVersions("1.6.0", version)) {
                            return true;
                        }
                    }
                }
            }
            // if above dosn't work on Apple or Windows, just allow 1.5.0
            if (this.compareVersions("1.5.0", version)) {
                return true;
            }
            return false;



        },

        IEInstall: function() {

            location.href = constructGetJavaURL(
                ((this.returnPage != null) ?
                    ('&returnPage=' + this.returnPage) : '') +
                    ((this.locale != null) ?
                        ('&locale=' + this.locale) : '') +
                    ((this.brand != null) ? ('&brand=' + this.brand) : ''));

            // should not actually get here
            return false;
        },

        done: function (name, result) {
        },

        FFInstall: function() {

            location.href = constructGetJavaURL(
                ((this.returnPage != null) ?
                    ('&returnPage=' + this.returnPage) : '') +
                    ((this.locale != null) ?
                        ('&locale=' + this.locale) : '') +
                    ((this.brand != null) ? ('&brand=' + this.brand) : '') +
                    ((this.installType != null) ?
                        ('&type=' + this.installType) : ''));

            // should not actually get here
            return false;
        },

        // return true if 'installed' (considered as a JRE version string) is
        // greater than or equal to 'required' (again, a JRE version string).
        compareVersions: function(installed, required) {

            var a = installed.split('.');
            var b = required.split('.');

            for (var i = 0; i < a.length; ++i) {
                a[i] = Number(a[i]);
            }
            for (var i = 0; i < b.length; ++i) {
                b[i] = Number(b[i]);
            }
            if (a.length == 2) {
                a[2] = 0;
            }

            if (a[0] > b[0]) return true;
            if (a[0] < b[0]) return false;

            if (a[1] > b[1]) return true;
            if (a[1] < b[1]) return false;

            if (a[2] > b[2]) return true;
            if (a[2] < b[2]) return false;

            return true;
        },

        enableAlerts: function() {
            // reset this so we can show the browser detection
            this.browserName = null;
            this.debug = true;
        },

        poll: function() {

            this.refresh();
            var postInstallJREList = this.getJREs();

            if ((this.preInstallJREList.length == 0) &&
                (postInstallJREList.length != 0)) {
                clearInterval(this.myInterval);
                if (this.returnPage != null) {
                    location.href = this.returnPage;
                };
            }

            if ((this.preInstallJREList.length != 0) &&
                (postInstallJREList.length != 0) &&
                (this.preInstallJREList[0] != postInstallJREList[0])) {
                clearInterval(this.myInterval);
                if (this.returnPage != null) {
                    location.href = this.returnPage;
                }
            }

        },

        writePluginTag: function() {
            var browser = this.getBrowser();

            if (browser == 'MSIE') {
                // width=0 and height=0 don't seem to be enough to hide the object element on all IE versions
                // so position: absolute + top were added to ensure the expected behaviour
                document.write('<' +
                    'object classid="clsid:CAFEEFAC-DEC7-0000-0001-ABCDEFFEDCBA" ' +
                    'id="deployJavaPlugin" width="0" height="0" style="position: absolute; top: -5000px;">' +
                    '<' + '/' + 'object' + '>');
            } else if (browser == 'Netscape Family' && this.allowPlugin()) {
                this.writeEmbedTag();
            }
        },

        refresh: function() {
            navigator.plugins.refresh(false);

            var browser = this.getBrowser();
            if (browser == 'Netscape Family' && this.allowPlugin()) {
                var plugin = document.getElementById('deployJavaPlugin');
                // only do this again if no plugin
                if (plugin == null) {
                    this.writeEmbedTag();
                }
            }
        },

        writeEmbedTag: function() {
            var written = false;
            if (navigator.mimeTypes != null) {
                for (var i=0; i < navigator.mimeTypes.length; i++) {
                    if (navigator.mimeTypes[i].type == this.mimeType) {
                        if (navigator.mimeTypes[i].enabledPlugin) {
                            document.write('<' +
                                'embed id="deployJavaPlugin" type="' +
                                this.mimeType + '" hidden="true" />');
                            written = true;
                        }
                    }
                }
                // if we ddn't find new mimeType, look for old mimeType
                if (!written) for (var i=0; i < navigator.mimeTypes.length; i++) {
                    if (navigator.mimeTypes[i].type == this.oldMimeType) {
                        if (navigator.mimeTypes[i].enabledPlugin) {
                            document.write('<' +
                                'embed id="deployJavaPlugin" type="' +
                                this.oldMimeType + '" hidden="true" />');
                        }
                    }
                }
            }
        }
    }; // deployJava object

    rv.writePluginTag();
    if (rv.locale == null) {
        var loc = null;

        if (loc == null) try {
            loc = navigator.userLanguage;
        } catch (err) { }

        if (loc == null) try {
            loc = navigator.systemLanguage;
        } catch (err) { }

        if (loc == null) try {
            loc = navigator.language;
        } catch (err) { }

        if (loc != null) {
            loc.replace("-","_")
            rv.locale = loc;
        }
    }

    return rv;
}();;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:attachment-menu-link-init', location = 'js/menu/initAttachmentMenuLink.js' */
require([
        'jquery',
        'dndattachment/aui',
        'jira/util/events',
        'dndattachment/util/events/types'
    ], function ($,
                 AJS,
                 Events,
                 EventTypes) {

        var ISSUEACTION_ATTACH_FILES_CLASS = "issueaction-attach-file";

        var addDialogClassAndInvoke = function($el) {
            $el.addClass(ISSUEACTION_ATTACH_FILES_CLASS);
            $el.click();
        };

        var openFilePickerForPage = function() {
            var $tempFileInput = $("<input type=\"file\" multiple />");
            $tempFileInput.change(function (event) {
                Events.trigger(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, {
                    files: $tempFileInput[0].files
                });
            });
            $tempFileInput.click();
        };

        var isSubtaskLink = function($link) {
            return !! $link.data("issuekey");
        };

        // This should use skate once skate is a thing in jira-core
        var initialiseMenuAttachmentLink = function () {
            $(document).on('click', '.unified-attach-file', function (e) {
                AJS.trigger('analytics', { name : 'issue.dnd.attachment.opsbar.attachFiles.linkClick', data : {}});

                var $target = $(e.target);

                // If we have the old issueaction class, then do nothing
                if($target.hasClass(ISSUEACTION_ATTACH_FILES_CLASS)) {
                    return;
                }

                e.preventDefault();

                // Check if we have a Drop Zone present
                var isDropZonePresent = $(".issue-drop-zone").length;
                if(isDropZonePresent && !isSubtaskLink($target)) {
                    // If we have a drop zone available then we  create a dummy file input and open it
                    openFilePickerForPage();
                } else {
                    // If we do not, then add the class to make it behave the old way then click the target again to open the dialog
                    // This is mainly for JIRA Agile, who won't have a drop zone available to listen accept the files.
                    addDialogClassAndInvoke($target);
                }
            });
        };

        var onReady = function () {
            initialiseMenuAttachmentLink();
        };

        if ($.isReady) {
            onReady();
        } else {
            AJS.$(onReady);
        }
    }
);;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-public', location = 'js/applinks.public.js' */
/**
 * Support code to provide appropriate behavior for HTML elements created by
 * ApplicationLinkUIService; also, public functions that can be used from JS code
 * in other plugins to create the same kinds of HTML elements, in case it's not
 * convenient to do so on the back end.
 */
var ApplinksUtils = ApplinksUtils || (function($) {

    var pendingRequests = {},
        pendingConfirmations = {};
    
    // Provide a well-defined name for the authentication window/tab we create with
    // window.open() - may be useful in debugging, and is used by integration tests.
    // Note, IE8 does not allow this name to contain hyphens or periods.
    var authWindowName = "com_atlassian_applinks_authentication";

    /**
     * This function is basically duplicated from messages.js in AJS, because some products
     * only provide a stub version of messages.js within gadgets.
     */
    function makeCloseable(message) {
        var $icon = $('<span class="aui-icon icon-close"></span>').click(function () {
            message.trigger("messageClose", [this]).remove();
        });
        message.append($icon);
    }

    /**
     * Helper function to get the DOM object of the current iframe.
     * @return {Object} a DOM object, or null if we are not in an iframe
     */
    function getCurrentIframe() {
        if (window === parent.window) {
            return null;
        }
        var ret = null,
            myFrameWindow = window;
        $('iframe', parent.document.body).each(function(index) {
            if (this.contentWindow.window === myFrameWindow) {
                ret = this;
            }
        });
        return ret;
    }

    /**
     * Event handler that is called by the applinks authorization completion servlet.  It triggers
     * the completion function for any pending authorization request that matches the given applink
     * ID, and also redispatches the event to any other iframes in the current window.
     * @param {Object} eventObject  JQuery event object
     * @param {string} applinkId  application link ID
     * @param {boolean} success  true if the request was approved
     * @param {string} authAdminUri  URI of the "OAuth Access Tokens" page (will be displayed in the
     *   confirmation message)
     * @param {boolean} wasRedispatched  true if the event has been retriggered from another frame
     * @param {Object} [messages]
     *      'userError': an error message relevant to a non-admin user,
     *      'adminError': an error message relevant to an admin user,
     *      'adminErrorDetails': a list of details related to the admin message if there is one 
     */
    function onAuthCompletion(eventObject, applinkId, success, authAdminUri, wasRedispatched, messages) {
        if (applinkId in pendingRequests) {
            var request = pendingRequests[applinkId];
            if (success) {
                request.authAdminUri = authAdminUri;
                delete pendingRequests[applinkId];
            }
            completeAuthRequest(request, success, messages);
        }
        if (!wasRedispatched && parent && (parent !== window)) {
            var myWindow = window;
            $('iframe', parent.document.body).each(function(index, frame) {
                var scope = frame.contentWindow;
                if (scope !== myWindow) {
                    if (scope.AJS && scope.AJS.$) {
                        scope.AJS.$(scope.document).trigger('applinks.auth.completion',
                            [applinkId, success, authAdminUri, true, messages]);
                    }
                }
            });
        }
    }
      
    /**
     * Fires the appropriate event when the authorization flow has completed.  On approval, reloads
     * the window/frame unless an event handler calls {@code preventDefault()} on the event.
     * @param {Object} applinkProperties  has the same properties passed to {@link createAuthRequestBanner}
     * @param {boolean} approved  true if the request was approved
     * @param {Object} [messages]
     *      'userError': an error message relevant to a non-admin user,
     *      'adminError': an error message relevant to an admin user,
     *      'adminErrorDetails': a list of details related to the admin message if there is one
     */
    function completeAuthRequest(applinkProperties, approved, messages) {
        var $scope = $(document);
        if (approved) {
            // Temporarily bind an event handler so our handler runs after any other handlers that
            // may exist.
            var defaultApprovalHandler = function (eventObject) {
                if (eventObject.isDefaultPrevented()) {
                    // Don't reload, just show the confirmation message
                    showAuthConfirmationBanner(applinkProperties);
                } else {
                    // Reload, but first save a reminder to make us show a confirmation message
                    // after we've reloaded.
                    registerPendingConfirmation(applinkProperties);
                    document.location.reload(true);
                }
            };
            $scope.bind('applinks.auth.approved', defaultApprovalHandler);
            $scope.trigger('applinks.auth.approved', applinkProperties);
            $scope.unbind('applinks.auth.approved', defaultApprovalHandler);
        } else {
            // There's no default behavior for a request that was denied, but fire an event in case
            // anyone is interested.
            $scope.trigger('applinks.auth.denied', [applinkProperties, messages]);
        }
    }

    /**
     * Used internally to make the applink support code aware of a "please authenticate" message
     * element that has been displayed, by wiring the appropriate event handlers and adding the
     * applink's properties to an internal list of authentication requests.
     * @param $element {Object}  a JQuery object
     * @param applinkProperties {Object}  has the same properties passed to {@link createAuthRequestBanner}
     */
    function initAuthRequest($element, applinkProperties) {
        var $authLink = $element.find("a.applink-authenticate");
        
        if ($element.hasClass('aui-message')) {
            // Workaround for incomplete AJS availability in some products
            makeCloseable($element);
        }
        
        $authLink.click(function(e) {
            window.open(applinkProperties.authUri, authWindowName);
            e.preventDefault();
        });
        
        pendingRequests[applinkProperties.id] = applinkProperties;
        
        return $element;
    }
    
    /**
     * Used internally to ensure that {@link initAuthRequest} is called for every
     * authorisation request element that was generated as HTML from the back end,
     * rather than by calling {@link createAuthRequestBanner} or
     * {@link createAuthRequestInline}.  The parameters of the request are passed
     * from the back end in hidden input elements.
     */
    function initAuthRequestElements() {
        $('.applinks-auth-request').each(function(index) {
            var $e = $(this),
                applinkId = $e.find(".applinkId").val(),
                appName = $e.find(".appName").val(),
                appUri = $e.find(".appUri").val(),
                authUri = $e.find(".authUri").val();
            // Ignore request banners that have already been created (by {@link createAuthRequestBanner} or
            // {@link createAuthRequestInline})
            if (applinkId && authUri) {
                initAuthRequest($e, {
                    id: applinkId,
                    appName: appName,
                    appUri: appUri,
                    authUri: authUri});
            }
        });
    }

    /**
     * Builds a "please authenticate" banner (in a standard AUI message box) containing a link that
     * that will start authorization for an application link that needs credentials.
     * <p>
     * On completion of the authorization flow, a JQuery event will be triggered on the document,
     * with the event type "applinks.auth.approved" or "applinks.auth.denied", and an additional
     * parameter equal to the {@code applinkProperties} parameter that was passed here.
     * <p>
     * If authorization is granted (event "applinks.auth.approved"), the default behavior is for the
     * window or frame to be reloaded; also, a confirmation banner will be displayed either within
     * a &lt;div&gt; element of class "applinks-auth-confirmation-container" if one exists, or at the top of
     * the document otherwise.  Reloading of the window/frame can be disabled by having an event
     * handler call {@code preventDefault()} on the event.
     *
     * @param {Object} applinkProperties contains the following application link properties:
     *   {@code id}: the application link identifier;
     *   {@code appName}: the name of the remote application;
     *   {@code appUri}: the base URI of the remote application;
     *   {@code authUri}: the URI for starting the authorization flow
     * @return {Object} a JQuery object referring to a {@code <div>} element, which has not yet
     *   been inserted anywhere on the page; its class is "applinks-auth-request"
     */
    function createAuthRequestBanner(applinkProperties) {
        var $banner = $('<div class="aui-message warning closeable applinks-auth-request"><p><span class="aui-icon icon-applinks-key"></span></p></div>');
        // Note that we can't just use the AJS.messages.warning() function, because it will put a
        // standard warning icon in the message box and we want a custom icon.
        $banner.append(AJS.format("Additional information may be available, please \u003ca class=\"applink-authenticate\" href=\"{0}\"\u003eauthenticate\u003c/a\u003e with \u003ca href=\"{1}\"\u003e{2}\u003c/a\u003e.",
                                        AJS.escapeHtml(applinkProperties.authUri),
                                        AJS.escapeHtml(applinkProperties.appUri),
                                        AJS.escapeHtml(applinkProperties.appName)));
        initAuthRequest($banner, applinkProperties);
        return $banner;
    }

    /**
     * Builds a "please authenticate" message suitable for displaying inline (in a span
     * with the class "applinks-auth-request"), containing a link that will start authorization.
     * This behaves identically to {@link createAuthRequestBanner}, except it creates a {@code <span>}
     * element instead of a {@code div} and also allows additional text to be displayed.
     * 
     * @param {string} content  optional HTML content to be displayed within the inline
     *   element (e.g. a description of the entity for which authorization is required);
     *   will not be escaped; may be null
     * @param {Object} applinkProperties  see {@link createAuthRequestBanner}
     * @return {Object} a JQuery object referring to a {@code <span>} element, which has not yet
     *   been inserted anywhere on the page; its class is "applinks-auth-request"
     */
    function createAuthRequestInline(content, applinkProperties) {
        var $lozenge = $('<span class="applinks-auth-request"></span>'),
            $contentSpan = $('<span class="applinks-request-description"></span>'),
            message = AJS.format("\u003ca class=\"applink-authenticate\" href=\"{0}\"\u003eAuthenticate\u003c/a\u003e to see additional information.", AJS.escapeHtml(applinkProperties.authUri));
        if (content) {
            $contentSpan.append(content);
            $contentSpan.append(" - ");
        }
        $contentSpan.append(message);
        $lozenge.append($contentSpan);
        initAuthRequest($lozenge, applinkProperties);
        return $lozenge;
    }

    /**
     * Used internally to remember the fact that we have just completed authorizing an
     * applink and are about to refresh the iframe associated with it, so that we can
     * display a confirmation message after the iframe is refreshed.
     */
    function registerPendingConfirmation(applinkProperties) {
        var frame = getCurrentIframe();
        if ((!frame) || (!frame.id)) {
            return;
        }
        if (! parent.ApplinksUtils.pendingConfirmations) {
            parent.ApplinksUtils.pendingConfirmations = { };
        }
        if (!(frame.id in parent.ApplinksUtils.pendingConfirmations)) {
            parent.ApplinksUtils.pendingConfirmations[frame.id] = [];
        }
        parent.ApplinksUtils.pendingConfirmations[frame.id].push(applinkProperties);
        return;
    }

    /**
     * Called after a page load, to see if we've been refreshed due to a successful authorization.
     * If we're in an iframe, a variable will have been set on the parent window to tell us that
     * this happened.  If so, insert a confirmation banner at the top of the iframe.
     */
    function checkForPendingConfirmations() {
        if (parent && parent.ApplinksUtils && parent.ApplinksUtils.pendingConfirmations) {
            var myFrame = getCurrentIframe();
            if (myFrame) {
                if (myFrame.id in parent.ApplinksUtils.pendingConfirmations) {
                    var pendingConfirmations = parent.ApplinksUtils.pendingConfirmations[myFrame.id];
                    delete parent.ApplinksUtils.pendingConfirmations[myFrame.id];
                    for (var i = 0, n = pendingConfirmations.length; i < n; i++) {
                        showAuthConfirmationBanner(pendingConfirmations[i]);
                    }
                }
            }
        }
    }

    /**
     * Displays a confirmation banner.  If an element exists with the class
     * "applinks-auth-confirmation-contianer", it is inserted there, otherwise at the top of the
     * document.
     */
    function showAuthConfirmationBanner(applinkProperties) {
        var scope = $(document),
            banner = $('<div class="aui-message success closeable applinks-auth-confirmation"><p><span class="aui-icon icon-applinks-key-success"></span></p></div>'),
            container = scope.find('div.applinks-auth-confirmation-container');
        if (!container.length) {
            container = scope.find('body');
        }
        banner.append(AJS.format("This application is now using \u003ca href=\"{0}\"\u003e{1}\u003c/a\u003e\'\'s credentials. Revoke access at any time by going to \u003ca href=\"{2}\"\u003eOAuth access tokens\u003c/a\u003e.",
                                        AJS.escapeHtml(applinkProperties.appUri),
                                        AJS.escapeHtml(applinkProperties.appName),
                                        AJS.escapeHtml(applinkProperties.authAdminUri)));
        makeCloseable(banner);
        container.prepend(banner);
        setTimeout(function() {
            banner.fadeOut(1000, function() {
                $(this).remove();
            });
        }, 5000);
    }
    
    /**
     * Initialization function to be called once at document ready time.
     */
    function setup() {
        // If we're in an iframe, set up an object in the parent window that we can use to
        // keep track of state even if the iframe is refreshed.
        if (parent && !(parent === window)) {
            if (! parent.ApplinksUtils) {
                parent.ApplinksUtils = { };
            }
        }
        
        $(document).bind('applinks.auth.completion', onAuthCompletion);

        initAuthRequestElements();
        checkForPendingConfirmations();
    }

    $(document).ready(setup);
    
    return {      
        createAuthRequestBanner: createAuthRequestBanner,
        createAuthRequestInline: createAuthRequestInline
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.plugin.jslibs:underscore-1.5.2', location = 'libs/underscore/1.5.2/underscore-1.5.2.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
  define('atlassian/libs/underscore-1.5.2', function() {
    var env = {};
    factory.call(env);
    return env._.noConflict();
  });
})(function(){
/////// End of Atlassian modification ///////

  //     Underscore.js 1.5.2
  //     http://underscorejs.org
  //     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  //     Underscore may be freely distributed under the MIT license.

  (function() {

    // Baseline setup
    // --------------

    // Establish the root object, `window` in the browser, or `exports` on the server.
    var root = this;

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Establish the object that gets returned to break out of a loop iteration.
    var breaker = {};

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var
      push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var
      nativeForEach      = ArrayProto.forEach,
      nativeMap          = ArrayProto.map,
      nativeReduce       = ArrayProto.reduce,
      nativeReduceRight  = ArrayProto.reduceRight,
      nativeFilter       = ArrayProto.filter,
      nativeEvery        = ArrayProto.every,
      nativeSome         = ArrayProto.some,
      nativeIndexOf      = ArrayProto.indexOf,
      nativeLastIndexOf  = ArrayProto.lastIndexOf,
      nativeIsArray      = Array.isArray,
      nativeKeys         = Object.keys,
      nativeBind         = FuncProto.bind;

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) {
      if (obj instanceof _) return obj;
      if (!(this instanceof _)) return new _(obj);
      this._wrapped = obj;
    };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `_` as a global object via a string identifier,
    // for Closure Compiler "advanced" mode.
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = _;
      }
      exports._ = _;
    } else {
      root._ = _;
    }

    // Current version.
    _.VERSION = '1.5.2';

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles objects with the built-in `forEach`, arrays, and raw objects.
    // Delegates to **ECMAScript 5**'s native `forEach` if available.
    var each = _.each = _.forEach = function(obj, iterator, context) {
      if (obj == null) return;
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, length = obj.length; i < length; i++) {
          if (iterator.call(context, obj[i], i, obj) === breaker) return;
        }
      } else {
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
        }
      }
    };

    // Return the results of applying the iterator to each element.
    // Delegates to **ECMAScript 5**'s native `map` if available.
    _.map = _.collect = function(obj, iterator, context) {
      var results = [];
      if (obj == null) return results;
      if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
      each(obj, function(value, index, list) {
        results.push(iterator.call(context, value, index, list));
      });
      return results;
    };

    var reduceError = 'Reduce of empty array with no initial value';

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
    _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
      var initial = arguments.length > 2;
      if (obj == null) obj = [];
      if (nativeReduce && obj.reduce === nativeReduce) {
        if (context) iterator = _.bind(iterator, context);
        return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
      }
      each(obj, function(value, index, list) {
        if (!initial) {
          memo = value;
          initial = true;
        } else {
          memo = iterator.call(context, memo, value, index, list);
        }
      });
      if (!initial) throw new TypeError(reduceError);
      return memo;
    };

    // The right-associative version of reduce, also known as `foldr`.
    // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
    _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
      var initial = arguments.length > 2;
      if (obj == null) obj = [];
      if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
        if (context) iterator = _.bind(iterator, context);
        return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
      }
      var length = obj.length;
      if (length !== +length) {
        var keys = _.keys(obj);
        length = keys.length;
      }
      each(obj, function(value, index, list) {
        index = keys ? keys[--length] : --length;
        if (!initial) {
          memo = obj[index];
          initial = true;
        } else {
          memo = iterator.call(context, memo, obj[index], index, list);
        }
      });
      if (!initial) throw new TypeError(reduceError);
      return memo;
    };

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = function(obj, iterator, context) {
      var result;
      any(obj, function(value, index, list) {
        if (iterator.call(context, value, index, list)) {
          result = value;
          return true;
        }
      });
      return result;
    };

    // Return all the elements that pass a truth test.
    // Delegates to **ECMAScript 5**'s native `filter` if available.
    // Aliased as `select`.
    _.filter = _.select = function(obj, iterator, context) {
      var results = [];
      if (obj == null) return results;
      if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
      each(obj, function(value, index, list) {
        if (iterator.call(context, value, index, list)) results.push(value);
      });
      return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = function(obj, iterator, context) {
      return _.filter(obj, function(value, index, list) {
        return !iterator.call(context, value, index, list);
      }, context);
    };

    // Determine whether all of the elements match a truth test.
    // Delegates to **ECMAScript 5**'s native `every` if available.
    // Aliased as `all`.
    _.every = _.all = function(obj, iterator, context) {
      iterator || (iterator = _.identity);
      var result = true;
      if (obj == null) return result;
      if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
      each(obj, function(value, index, list) {
        if (!(result = result && iterator.call(context, value, index, list))) return breaker;
      });
      return !!result;
    };

    // Determine if at least one element in the object matches a truth test.
    // Delegates to **ECMAScript 5**'s native `some` if available.
    // Aliased as `any`.
    var any = _.some = _.any = function(obj, iterator, context) {
      iterator || (iterator = _.identity);
      var result = false;
      if (obj == null) return result;
      if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
      each(obj, function(value, index, list) {
        if (result || (result = iterator.call(context, value, index, list))) return breaker;
      });
      return !!result;
    };

    // Determine if the array or object contains a given value (using `===`).
    // Aliased as `include`.
    _.contains = _.include = function(obj, target) {
      if (obj == null) return false;
      if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
      return any(obj, function(value) {
        return value === target;
      });
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = function(obj, method) {
      var args = slice.call(arguments, 2);
      var isFunc = _.isFunction(method);
      return _.map(obj, function(value) {
        return (isFunc ? method : value[method]).apply(value, args);
      });
    };

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = function(obj, key) {
      return _.map(obj, function(value){ return value[key]; });
    };

    // Convenience version of a common use case of `filter`: selecting only objects
    // containing specific `key:value` pairs.
    _.where = function(obj, attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return _[first ? 'find' : 'filter'](obj, function(value) {
        for (var key in attrs) {
          if (attrs[key] !== value[key]) return false;
        }
        return true;
      });
    };

    // Convenience version of a common use case of `find`: getting the first object
    // containing specific `key:value` pairs.
    _.findWhere = function(obj, attrs) {
      return _.where(obj, attrs, true);
    };

    // Return the maximum element or (element-based computation).
    // Can't optimize arrays of integers longer than 65,535 elements.
    // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
    _.max = function(obj, iterator, context) {
      if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
        return Math.max.apply(Math, obj);
      }
      if (!iterator && _.isEmpty(obj)) return -Infinity;
      var result = {computed : -Infinity, value: -Infinity};
      each(obj, function(value, index, list) {
        var computed = iterator ? iterator.call(context, value, index, list) : value;
        computed > result.computed && (result = {value : value, computed : computed});
      });
      return result.value;
    };

    // Return the minimum element (or element-based computation).
    _.min = function(obj, iterator, context) {
      if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
        return Math.min.apply(Math, obj);
      }
      if (!iterator && _.isEmpty(obj)) return Infinity;
      var result = {computed : Infinity, value: Infinity};
      each(obj, function(value, index, list) {
        var computed = iterator ? iterator.call(context, value, index, list) : value;
        computed < result.computed && (result = {value : value, computed : computed});
      });
      return result.value;
    };

    // Shuffle an array, using the modern version of the
    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
    _.shuffle = function(obj) {
      var rand;
      var index = 0;
      var shuffled = [];
      each(obj, function(value) {
        rand = _.random(index++);
        shuffled[index - 1] = shuffled[rand];
        shuffled[rand] = value;
      });
      return shuffled;
    };

    // Sample **n** random values from an array.
    // If **n** is not specified, returns a single random element from the array.
    // The internal `guard` argument allows it to work with `map`.
    _.sample = function(obj, n, guard) {
      if (arguments.length < 2 || guard) {
        return obj[_.random(obj.length - 1)];
      }
      return _.shuffle(obj).slice(0, Math.max(0, n));
    };

    // An internal function to generate lookup iterators.
    var lookupIterator = function(value) {
      return _.isFunction(value) ? value : function(obj){ return obj[value]; };
    };

    // Sort the object's values by a criterion produced by an iterator.
    _.sortBy = function(obj, value, context) {
      var iterator = lookupIterator(value);
      return _.pluck(_.map(obj, function(value, index, list) {
        return {
          value: value,
          index: index,
          criteria: iterator.call(context, value, index, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
      }), 'value');
    };

    // An internal function used for aggregate "group by" operations.
    var group = function(behavior) {
      return function(obj, value, context) {
        var result = {};
        var iterator = value == null ? _.identity : lookupIterator(value);
        each(obj, function(value, index) {
          var key = iterator.call(context, value, index, obj);
          behavior(result, key, value);
        });
        return result;
      };
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = group(function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });

    // Indexes the object's values by a criterion, similar to `groupBy`, but for
    // when you know that your index values will be unique.
    _.indexBy = group(function(result, key, value) {
      result[key] = value;
    });

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    _.countBy = group(function(result, key) {
      _.has(result, key) ? result[key]++ : result[key] = 1;
    });

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = function(array, obj, iterator, context) {
      iterator = iterator == null ? _.identity : lookupIterator(iterator);
      var value = iterator.call(context, obj);
      var low = 0, high = array.length;
      while (low < high) {
        var mid = (low + high) >>> 1;
        iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
      }
      return low;
    };

    // Safely create a real, live array from anything iterable.
    _.toArray = function(obj) {
      if (!obj) return [];
      if (_.isArray(obj)) return slice.call(obj);
      if (obj.length === +obj.length) return _.map(obj, _.identity);
      return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = function(obj) {
      if (obj == null) return 0;
      return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
    };

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = function(array, n, guard) {
      if (array == null) return void 0;
      return (n == null) || guard ? array[0] : slice.call(array, 0, n);
    };

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N. The **guard** check allows it to work with
    // `_.map`.
    _.initial = function(array, n, guard) {
      return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
    };

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array. The **guard** check allows it to work with `_.map`.
    _.last = function(array, n, guard) {
      if (array == null) return void 0;
      if ((n == null) || guard) {
        return array[array.length - 1];
      } else {
        return slice.call(array, Math.max(array.length - n, 0));
      }
    };

    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
    // Especially useful on the arguments object. Passing an **n** will return
    // the rest N values in the array. The **guard**
    // check allows it to work with `_.map`.
    _.rest = _.tail = _.drop = function(array, n, guard) {
      return slice.call(array, (n == null) || guard ? 1 : n);
    };

    // Trim out all falsy values from an array.
    _.compact = function(array) {
      return _.filter(array, _.identity);
    };

    // Internal implementation of a recursive `flatten` function.
    var flatten = function(input, shallow, output) {
      if (shallow && _.every(input, _.isArray)) {
        return concat.apply(output, input);
      }
      each(input, function(value) {
        if (_.isArray(value) || _.isArguments(value)) {
          shallow ? push.apply(output, value) : flatten(value, shallow, output);
        } else {
          output.push(value);
        }
      });
      return output;
    };

    // Flatten out an array, either recursively (by default), or just one level.
    _.flatten = function(array, shallow) {
      return flatten(array, shallow, []);
    };

    // Return a version of the array that does not contain the specified value(s).
    _.without = function(array) {
      return _.difference(array, slice.call(arguments, 1));
    };

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = function(array, isSorted, iterator, context) {
      if (_.isFunction(isSorted)) {
        context = iterator;
        iterator = isSorted;
        isSorted = false;
      }
      var initial = iterator ? _.map(array, iterator, context) : array;
      var results = [];
      var seen = [];
      each(initial, function(value, index) {
        if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
          seen.push(value);
          results.push(array[index]);
        }
      });
      return results;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = function() {
      return _.uniq(_.flatten(arguments, true));
    };

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    _.intersection = function(array) {
      var rest = slice.call(arguments, 1);
      return _.filter(_.uniq(array), function(item) {
        return _.every(rest, function(other) {
          return _.indexOf(other, item) >= 0;
        });
      });
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = function(array) {
      var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
      return _.filter(array, function(value){ return !_.contains(rest, value); });
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = function() {
      var length = _.max(_.pluck(arguments, "length").concat(0));
      var results = new Array(length);
      for (var i = 0; i < length; i++) {
        results[i] = _.pluck(arguments, '' + i);
      }
      return results;
    };

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values.
    _.object = function(list, values) {
      if (list == null) return {};
      var result = {};
      for (var i = 0, length = list.length; i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    };

    // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
    // we need this function. Return the position of the first occurrence of an
    // item in an array, or -1 if the item is not included in the array.
    // Delegates to **ECMAScript 5**'s native `indexOf` if available.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = function(array, item, isSorted) {
      if (array == null) return -1;
      var i = 0, length = array.length;
      if (isSorted) {
        if (typeof isSorted == 'number') {
          i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
        } else {
          i = _.sortedIndex(array, item);
          return array[i] === item ? i : -1;
        }
      }
      if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
      for (; i < length; i++) if (array[i] === item) return i;
      return -1;
    };

    // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
    _.lastIndexOf = function(array, item, from) {
      if (array == null) return -1;
      var hasIndex = from != null;
      if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
        return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
      }
      var i = (hasIndex ? from : array.length);
      while (i--) if (array[i] === item) return i;
      return -1;
    };

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function(start, stop, step) {
      if (arguments.length <= 1) {
        stop = start || 0;
        start = 0;
      }
      step = arguments[2] || 1;

      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var idx = 0;
      var range = new Array(length);

      while(idx < length) {
        range[idx++] = start;
        start += step;
      }

      return range;
    };

    // Function (ahem) Functions
    // ------------------

    // Reusable constructor function for prototype setting.
    var ctor = function(){};

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
    // available.
    _.bind = function(func, context) {
      var args, bound;
      if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
      if (!_.isFunction(func)) throw new TypeError;
      args = slice.call(arguments, 2);
      return bound = function() {
        if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
        ctor.prototype = func.prototype;
        var self = new ctor;
        ctor.prototype = null;
        var result = func.apply(self, args.concat(slice.call(arguments)));
        if (Object(result) === result) return result;
        return self;
      };
    };

    // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context.
    _.partial = function(func) {
      var args = slice.call(arguments, 1);
      return function() {
        return func.apply(this, args.concat(slice.call(arguments)));
      };
    };

    // Bind all of an object's methods to that object. Useful for ensuring that
    // all callbacks defined on an object belong to it.
    _.bindAll = function(obj) {
      var funcs = slice.call(arguments, 1);
      if (funcs.length === 0) throw new Error("bindAll must be passed function names");
      each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
      return obj;
    };

    // Memoize an expensive function by storing its results.
    _.memoize = function(func, hasher) {
      var memo = {};
      hasher || (hasher = _.identity);
      return function() {
        var key = hasher.apply(this, arguments);
        return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
      };
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = function(func, wait) {
      var args = slice.call(arguments, 2);
      return setTimeout(function(){ return func.apply(null, args); }, wait);
    };

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = function(func) {
      return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
    };

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    _.throttle = function(func, wait, options) {
      var context, args, result;
      var timeout = null;
      var previous = 0;
      options || (options = {});
      var later = function() {
        previous = options.leading === false ? 0 : new Date;
        timeout = null;
        result = func.apply(context, args);
      };
      return function() {
        var now = new Date;
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0) {
          clearTimeout(timeout);
          timeout = null;
          previous = now;
          result = func.apply(context, args);
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = function(func, wait, immediate) {
      var timeout, args, context, timestamp, result;
      return function() {
        context = this;
        args = arguments;
        timestamp = new Date();
        var later = function() {
          var last = (new Date()) - timestamp;
          if (last < wait) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) result = func.apply(context, args);
          }
        };
        var callNow = immediate && !timeout;
        if (!timeout) {
          timeout = setTimeout(later, wait);
        }
        if (callNow) result = func.apply(context, args);
        return result;
      };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = function(func) {
      var ran = false, memo;
      return function() {
        if (ran) return memo;
        ran = true;
        memo = func.apply(this, arguments);
        func = null;
        return memo;
      };
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = function(func, wrapper) {
      return function() {
        var args = [func];
        push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function() {
      var funcs = arguments;
      return function() {
        var args = arguments;
        for (var i = funcs.length - 1; i >= 0; i--) {
          args = [funcs[i].apply(this, args)];
        }
        return args[0];
      };
    };

    // Returns a function that will only be executed after being called N times.
    _.after = function(times, func) {
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    };

    // Object Functions
    // ----------------

    // Retrieve the names of an object's properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`
    _.keys = nativeKeys || function(obj) {
      if (obj !== Object(obj)) throw new TypeError('Invalid object');
      var keys = [];
      for (var key in obj) if (_.has(obj, key)) keys.push(key);
      return keys;
    };

    // Retrieve the values of an object's properties.
    _.values = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var values = new Array(length);
      for (var i = 0; i < length; i++) {
        values[i] = obj[keys[i]];
      }
      return values;
    };

    // Convert an object into a list of `[key, value]` pairs.
    _.pairs = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var pairs = new Array(length);
      for (var i = 0; i < length; i++) {
        pairs[i] = [keys[i], obj[keys[i]]];
      }
      return pairs;
    };

    // Invert the keys and values of an object. The values must be serializable.
    _.invert = function(obj) {
      var result = {};
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        result[obj[keys[i]]] = keys[i];
      }
      return result;
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`
    _.functions = _.methods = function(obj) {
      var names = [];
      for (var key in obj) {
        if (_.isFunction(obj[key])) names.push(key);
      }
      return names.sort();
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = function(obj) {
      each(slice.call(arguments, 1), function(source) {
        if (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      });
      return obj;
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = function(obj) {
      var copy = {};
      var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
      each(keys, function(key) {
        if (key in obj) copy[key] = obj[key];
      });
      return copy;
    };

     // Return a copy of the object without the blacklisted properties.
    _.omit = function(obj) {
      var copy = {};
      var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
      for (var key in obj) {
        if (!_.contains(keys, key)) copy[key] = obj[key];
      }
      return copy;
    };

    // Fill in a given object with default properties.
    _.defaults = function(obj) {
      each(slice.call(arguments, 1), function(source) {
        if (source) {
          for (var prop in source) {
            if (obj[prop] === void 0) obj[prop] = source[prop];
          }
        }
      });
      return obj;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = function(obj) {
      if (!_.isObject(obj)) return obj;
      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = function(obj, interceptor) {
      interceptor(obj);
      return obj;
    };

    // Internal recursive comparison function for `isEqual`.
    var eq = function(a, b, aStack, bStack) {
      // Identical objects are equal. `0 === -0`, but they aren't identical.
      // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
      if (a === b) return a !== 0 || 1 / a == 1 / b;
      // A strict comparison is necessary because `null == undefined`.
      if (a == null || b == null) return a === b;
      // Unwrap any wrapped objects.
      if (a instanceof _) a = a._wrapped;
      if (b instanceof _) b = b._wrapped;
      // Compare `[[Class]]` names.
      var className = toString.call(a);
      if (className != toString.call(b)) return false;
      switch (className) {
        // Strings, numbers, dates, and booleans are compared by value.
        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return a == String(b);
        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
          // other numeric values.
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') return false;
      // Assume equality for cyclic structures. The algorithm for detecting cyclic
      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
      var length = aStack.length;
      while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] == a) return bStack[length] == b;
      }
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Add the first object to the stack of traversed objects.
      aStack.push(a);
      bStack.push(b);
      var size = 0, result = true;
      // Recursively compare objects and arrays.
      if (className == '[object Array]') {
        // Compare array lengths to determine if a deep comparison is necessary.
        size = a.length;
        result = size == b.length;
        if (result) {
          // Deep compare the contents, ignoring non-numeric properties.
          while (size--) {
            if (!(result = eq(a[size], b[size], aStack, bStack))) break;
          }
        }
      } else {
        // Deep compare objects.
        for (var key in a) {
          if (_.has(a, key)) {
            // Count the expected number of properties.
            size++;
            // Deep compare each member.
            if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
          }
        }
        // Ensure that both objects contain the same number of properties.
        if (result) {
          for (key in b) {
            if (_.has(b, key) && !(size--)) break;
          }
          result = !size;
        }
      }
      // Remove the first object from the stack of traversed objects.
      aStack.pop();
      bStack.pop();
      return result;
    };

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = function(a, b) {
      return eq(a, b, [], []);
    };

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = function(obj) {
      if (obj == null) return true;
      if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
      for (var key in obj) if (_.has(obj, key)) return false;
      return true;
    };

    // Is a given value a DOM element?
    _.isElement = function(obj) {
      return !!(obj && obj.nodeType === 1);
    };

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || function(obj) {
      return toString.call(obj) == '[object Array]';
    };

    // Is a given variable an object?
    _.isObject = function(obj) {
      return obj === Object(obj);
    };

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
    each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
      _['is' + name] = function(obj) {
        return toString.call(obj) == '[object ' + name + ']';
      };
    });

    // Define a fallback version of the method in browsers (ahem, IE), where
    // there isn't any inspectable "Arguments" type.
    if (!_.isArguments(arguments)) {
      _.isArguments = function(obj) {
        return !!(obj && _.has(obj, 'callee'));
      };
    }

    // Optimize `isFunction` if appropriate.
    if (typeof (/./) !== 'function') {
      _.isFunction = function(obj) {
        return typeof obj === 'function';
      };
    }

    // Is a given object a finite number?
    _.isFinite = function(obj) {
      return isFinite(obj) && !isNaN(parseFloat(obj));
    };

    // Is the given value `NaN`? (NaN is the only number which does not equal itself).
    _.isNaN = function(obj) {
      return _.isNumber(obj) && obj != +obj;
    };

    // Is a given value a boolean?
    _.isBoolean = function(obj) {
      return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
    };

    // Is a given value equal to null?
    _.isNull = function(obj) {
      return obj === null;
    };

    // Is a given variable undefined?
    _.isUndefined = function(obj) {
      return obj === void 0;
    };

    // Shortcut function for checking if an object has a given property directly
    // on itself (in other words, not on a prototype).
    _.has = function(obj, key) {
      return hasOwnProperty.call(obj, key);
    };

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function() {
      root._ = previousUnderscore;
      return this;
    };

    // Keep the identity function around for default iterators.
    _.identity = function(value) {
      return value;
    };

    // Run a function **n** times.
    _.times = function(n, iterator, context) {
      var accum = Array(Math.max(0, n));
      for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
      return accum;
    };

    // Return a random integer between min and max (inclusive).
    _.random = function(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    };

    // List of HTML entities for escaping.
    var entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      }
    };
    entityMap.unescape = _.invert(entityMap.escape);

    // Regexes containing the keys and values listed immediately above.
    var entityRegexes = {
      escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
      unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
    };

    // Functions for escaping and unescaping strings to/from HTML interpolation.
    _.each(['escape', 'unescape'], function(method) {
      _[method] = function(string) {
        if (string == null) return '';
        return ('' + string).replace(entityRegexes[method], function(match) {
          return entityMap[method][match];
        });
      };
    });

    // If the value of the named `property` is a function then invoke it with the
    // `object` as context; otherwise, return it.
    _.result = function(object, property) {
      if (object == null) return void 0;
      var value = object[property];
      return _.isFunction(value) ? value.call(object) : value;
    };

    // Add your own custom functions to the Underscore object.
    _.mixin = function(obj) {
      each(_.functions(obj), function(name) {
        var func = _[name] = obj[name];
        _.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return result.call(this, func.apply(_, args));
        };
      });
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = function(prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
      evaluate    : /<%([\s\S]+?)%>/g,
      interpolate : /<%=([\s\S]+?)%>/g,
      escape      : /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'":      "'",
      '\\':     '\\',
      '\r':     'r',
      '\n':     'n',
      '\t':     't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    _.template = function(text, data, settings) {
      var render;
      settings = _.defaults({}, settings, _.templateSettings);

      // Combine delimiters into one regular expression via alternation.
      var matcher = new RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');

      // Compile the template source, escaping string literals appropriately.
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset)
          .replace(escaper, function(match) { return '\\' + escapes[match]; });

        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        }
        if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        }
        if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }
        index = offset + match.length;
        return match;
      });
      source += "';\n";

      // If a variable is not specified, place data values in local scope.
      if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

      source = "var __t,__p='',__j=Array.prototype.join," +
        "print=function(){__p+=__j.call(arguments,'');};\n" +
        source + "return __p;\n";

      try {
        render = new Function(settings.variable || 'obj', '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }

      if (data) return render(data, _);
      var template = function(data) {
        return render.call(this, data, _);
      };

      // Provide the compiled function source as a convenience for precompilation.
      template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

      return template;
    };

    // Add a "chain" function, which will delegate to the wrapper.
    _.chain = function(obj) {
      return _(obj).chain();
    };

    // OOP
    // ---------------
    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.

    // Helper function to continue chaining intermediate results.
    var result = function(obj) {
      return this._chain ? _(obj).chain() : obj;
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        method.apply(obj, arguments);
        if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
        return result.call(this, obj);
      };
    });

    // Add all accessor Array functions to the wrapper.
    each(['concat', 'join', 'slice'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        return result.call(this, method.apply(this._wrapped, arguments));
      };
    });

    _.extend(_.prototype, {

      // Start chaining a wrapped Underscore object.
      chain: function() {
        this._chain = true;
        return this;
      },

      // Extracts the result from a wrapped and chained object.
      value: function() {
        return this._wrapped;
      }

    });

  }).call(this);

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:lodash-amd', location = 'applinks/internal/lib/lodash-jslibs.js' */
define('applinks/lib/lodash', ['atlassian/libs/underscore-1.5.2'], function(lodash) {
        return lodash;
    });;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/console-amd.js' */
define('applinks/lib/console', function() {
    return window.console;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/jquery-amd.js' */
define('applinks/lib/jquery', function() {
   return window.jQuery;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/aui-amd.js' */
define('applinks/lib/aui', function() {
   var aui = window.AJS;
   if (!aui) {
      throw "window.AJS not defined, cannot load AUI";
   }
   var auiVersion = aui.version.split(".");
   aui.versionDetails = {
      major: parseInt(auiVersion[0]),
      minor: parseInt(auiVersion[1]),
      bugfix: parseInt(auiVersion[2])
   };
   return aui;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/wrm-amd.js' */
/**
 * Define Web resource manager as an AMD dependency. This should also be present in apps using Atlassian Plugins Web
 * Resources framework.
 */
define('applinks/lib/wrm', function() {
   return window.WRM;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/skate-amd.js' */
define('applinks/lib/skate', function() {
   return window.skate;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/window-amd.js' */
/**
 * Define window as AMD module to facilitate unit testing of some modules
 */
define('applinks/lib/window', function() {
    return window;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/preconditions.js' */
define('applinks/common/preconditions', [
    'applinks/lib/lodash'
], function(
    _
) {
    function nonEmptyString(value, varName, customMessage) {
        _checkArgument(
            _.isString(value) && !_.isEmpty(value),
            customMessage,
            _withVarName(varName, ': expected a non-empty string')
        );
    }

    function isFunction(value, varName, customMessage) {
        _checkArgument(
            _.isFunction(value),
            customMessage,
            _withVarName(varName, ': expected a function, was: ' + value)
        );
    }

    function hasValue(value, varName, customMessage) {
        _checkArgument(
            value,
            customMessage,
            _withVarName(varName, ': expected a value')
        );
    }

    function _checkArgument(value, message, defaultMessage) {
        var actualMessage = message ? message : defaultMessage;
        if (!value) {
            throw new Error(actualMessage)
        }
    }

    function _withVarName(varName, msg) {
        return (varName || '[unspecified]') + msg;
    }

    return {
        checkArgument: _.partial(_checkArgument, _, _, ''),
        nonEmptyString: nonEmptyString,
        isFunction: isFunction,
        hasValue: hasValue
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/context.js' */
define('applinks/common/context', [
    'applinks/lib/console',
    'applinks/lib/window',
    'applinks/lib/wrm',
    'applinks/common/modules'
], function(
    console,
    window,
    WRM,
    ApplinksModules
) {
    var context = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-context'));

    return {
        currentUser: function() {
            return context.currentUser
        },

        /**
         * @returns {object} host application containing `id` and `type` properties
         */
        hostApplication: function() {
            return context.hostApplication
        },

        validateCurrentUser: function() {
            if (!this.currentUser()) {
                console.log('No user context, reloading the page to trigger redirect to the login screen');
                window.location.reload();
            }
        }
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/help-paths.js' */
define('applinks/common/help-paths', [
    'applinks/lib/console',
    'applinks/lib/wrm',
    'applinks/lib/lodash',
    'applinks/common/modules',
    'applinks/common/preconditions'
], function(
    console,
    WRM,
    _,
    ApplinksModules,
    Preconditions
) {
    // lazy-load help paths, facilitates unit-testing
    var allHelpPaths = _.memoize(function() {
        var helpPaths = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-help-paths'));
        if (!helpPaths.entries) {
            console.warn('Help paths not found, all help links are likely to be broken.');
        }
        return helpPaths.entries || {};
    });

    var getPath = function(key, sectionKey) {
        Preconditions.nonEmptyString(key, 'key');
        var path = allHelpPaths()[key] || key;
        if (sectionKey) {
            Preconditions.nonEmptyString(sectionKey, 'sectionKey');
            var prefix = path.replace(/\+/g, ''); // "g" flag to remove _all_ '+' signs
            path += '#' +prefix + '-' + sectionKey;
        }
        return path;
    };

    function endsWith(string, suffix) {
        return string.indexOf(suffix, string.length - suffix.length) !== -1;
    }

    function addSuffixIfRequired(string, suffix) {
        return endsWith(string, suffix) ? string : string + suffix;
    }

    return {
        /**
         * @param key {string} key to get the path for
         * @returns {string} relative help path that can be appended to any relevant docs base URL
         */
        getPath: getPath,

        /**
         * @param key {string} key to get the path for
         * @param sectionKey {string} optional key of the anchor on the target page
         * @returns {string} full help path including the base URL
         */
        getFullPath: function(key, sectionKey) {
            var baseUrl = this.baseUrl();
            return addSuffixIfRequired(baseUrl, '/') + this.getPath(key, sectionKey);
        },

        /**
         * @returns {string} configured base URL for the help paths
         */
        baseUrl: _.partial(getPath, 'applinks.docs.root')
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/events.js' */
define('applinks/common/events', function() {

    var PREFIX = 'applinks.event.';

    return {
        PREREADY: PREFIX + 'preready',
        READY: PREFIX + 'ready',

        /**
         * Raised when applinks list is first loaded
         */
        APPLINKS_LOADED: PREFIX + 'loaded',
        /**
         * Raised when applinks list is updated
         */
        APPLINKS_UPDATED: PREFIX + 'updated',

        /**
         * This event is only raised when linking to Atlassian applications
         * Can be consumed by other plugins
         */
        NEW_APPLINK_CREATED: PREFIX + 'created',

        // legacy events
        Legacy: {
            MESSAGE_BOX_DISPLAYED: PREFIX + 'message-box-displayed'
        }
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/initializer.js' */
define('applinks/common/initializer', [
    'applinks/lib/jquery',
    'applinks/lib/lodash'
], function(
    $,
    _
) {
    function _callInitCallback(module) {
        if (module && _.isFunction(module.init)) {
            module.init();
        }
        if (module && _.isFunction(module.initialize)) {
            module.initialize();
        }
    }

    return {

        /**
         * Init `module`. If the module contains an `init` or `initialize` function, it will be called immediately
         * If both functions are present, both will be called.
         *
         * @param module {object} module to initialize
         */
        init: function(module) {
            _callInitCallback(module);
        },

        /**
         * Init `module` on DOM ready. If the module contains an `init` or `initialize` function, it will be called
         * on DOM ready event. Those functions should contain code that performs UI initialization dependent on the
         * state of the DOM. If both functions are present, both will be called.
         *
         * @param module {object} module to initialize
         */
        initOnDomReady: function(module) {
            $(document).ready(function() {
                _callInitCallback(module);
            });
        }
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/modules.js' */
/**
 * Applinks plugin modules core constants and definitions.
 */
define('applinks/common/modules', function() {
    return {
        /**
         * Applinks plugin key
         */
        PLUGIN_KEY: 'com.atlassian.applinks.applinks-plugin',

        /**
         * Fully qualifies a module name using the plugin key.
         *
         * @param {string} moduleName module name to qualify
         * @returns {string} fully qualified name
         */
        fqn: function(moduleName) {
            return this.PLUGIN_KEY + ':' + moduleName;
        },

        /**
         * Fully qualifies web-resource data using module name and data key.
         *
         * @param {string} moduleName module name
         * @param {string} dataKey key of the data element
         * @returns {string} fully qualified name
         */
        dataFqn: function(moduleName, dataKey) {
            return this.fqn(moduleName) + '.' + dataKey;
        }
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/features.js' */
define('applinks/common/features', [
    'applinks/lib/wrm',
    'applinks/lib/lodash',
    'applinks/common/modules',
    'applinks/common/context',
    'applinks/common/rest'
], function(
    WRM,
    _,
    ApplinksModules,
    ApplinksContext,
    ApplinksRest
) {
    var enabledFeatures, discoveredFeatures;

    function _getEnabledFeatures() {
        if (_.isUndefined(enabledFeatures)) {
            enabledFeatures = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-features'));
        }
        return enabledFeatures;
    }

    function _getDiscoveredFeatures() {
        if (_.isUndefined(discoveredFeatures)) {
            discoveredFeatures = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-discovered-features'));
        }
        return discoveredFeatures;
    }

    function isDiscovered(featureKey) {
        return _.contains(_getDiscoveredFeatures(), featureKey.toLowerCase());
    }

    function addEnabledFeatures(features) {
        _.extend(_getEnabledFeatures(), features);
    }

    function addDiscoveredFeatures(featureKeys) {
        featureKeys.forEach(function(featureKey){
            if (!isDiscovered(featureKey)) {
                _getDiscoveredFeatures().push(featureKey.toLowerCase());
            }
        });
    }

    /**
     * Allows to query for, enable and discover Applinks features.
     */
    return {

        BITBUCKET_REBRAND: 'BITBUCKET_REBRAND',
        V3_UI_OPT_IN: 'V3_UI_OPT_IN',
        V3_UI: 'V3_UI',

        /**
         * @returns {Object.<string, Object>} all enabled features mapped by key
         */
        getEnabledFeatures: function() {
            return _getEnabledFeatures();
        },

        isEnabled: function(featureName) {
            return this.getEnabledFeatures()[featureName];
        },

        /**
         * Disable `featureName`, requires user context and admin permissions.
         *
         * @param featureName {string} feature name to enable
         * @return the request promise to hook callbacks to
         */
        disable: function(featureName) {
            ApplinksContext.validateCurrentUser();
            return ApplinksRest.V3.features(featureName).del()
                .done(function() {
                    _getEnabledFeatures()[featureName] = false;
                });
        },

        /**
         * Enable `featureName`, requires user context and admin permissions.
         *
         * @param featureName {string} feature name to enable
         * @return the request promise to hook callbacks to
         */
        enable: function(featureName) {
            ApplinksContext.validateCurrentUser();
            return ApplinksRest.V3.features(featureName).put()
                .done(function(feature) {
                    addEnabledFeatures(feature);
                });
        },

        /**
         * @returns {string[]} an array of discovered feature keys
         */
        getDiscoveredFeatures: function() {
            return _getDiscoveredFeatures();
        },

        isDiscovered: isDiscovered,

        /**
         * Discover `featureKey`, requires user context.
         *
         * @param featureKey {string} key to discover
         */
        discover: function(featureKey) {
            ApplinksContext.validateCurrentUser();
            ApplinksRest.V3.featureDiscovery(featureKey).put()
                .fail(function(req) {
                    throw 'Feature discovery request failed: ' + req.status + ': ' + req.responseText;
                }).done(function(featureKey) {
                    addDiscoveredFeatures(featureKey);
                });
        }
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/products.js' */
define('applinks/common/products', [
    'applinks/lib/window'
], function(Window) {

    function getTypeName(typeId) {
        // Note: window.appLinksI18n.entries is injected into the page by common_header.vm
        return Window.appLinksI18n.entries['applinks.application.type.'+typeId];
    }

    /**
     * Map of Atlassian product keys to application type IDs
     */
    return {
        BAMBOO: 'bamboo',
        BITBUCKET: 'stash', // special case, see java class com.atlassian.applinks.application.bitbucket.BitbucketApplicationTypeImpl.TYPE_ID
        CONFLUENCE: 'confluence',
        FECRU: 'fecru',
        JIRA: 'jira',
        REFAPP: 'refapp',
        STASH: 'stash',
        getTypeName: getTypeName
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/response-status.js' */
define('applinks/common/response-status', [
    'applinks/lib/lodash'
], function(
    _
) {

    function StatusFamily(familyCode) {
        this.familyCode = familyCode;
    }

    StatusFamily.prototype.matches = function(code) {
        return Math.floor(_getStatusCode(code) / 100) == this.familyCode;
    };

    var StatusFamilies = {
        INFORMATIONAL: new StatusFamily(1),
        SUCCESSFUL: new StatusFamily(2),
        REDIRECTION: new StatusFamily(3),
        CLIENT_ERROR: new StatusFamily(4),
        SERVER_ERROR: new StatusFamily(5),

        forCode: function(code) {
            return _.find(StatusFamilies.all(), function(family) {
                return family.matches(code);
            });
        },

        all: function() {
            return [
                StatusFamilies.INFORMATIONAL,
                StatusFamilies.SUCCESSFUL,
                StatusFamilies.REDIRECTION,
                StatusFamilies.CLIENT_ERROR,
                StatusFamilies.SERVER_ERROR
            ];
        }
    };

    function ResponseStatus(code) {
        this.code = code;
        this.family = StatusFamilies.forCode(code);
    }

    ResponseStatus.prototype.matches = function(code) {
        return _getStatusCode(code) == this.code;
    };

    function _getStatusCode(object) {
        if (object && object.status && _.isNumber(object.status)) {
            return object.status;
        } else if (_.isNumber(object)) {
            return object;
        } else {
            return 0;
        }
    }

    return {
        OK: new ResponseStatus(200),
        CREATED: new ResponseStatus(201),

        BAD_REQUEST: new ResponseStatus(400),
        UNAUTHORIZED: new ResponseStatus(401),
        FORBIDDEN: new ResponseStatus(403),
        NOT_FOUND: new ResponseStatus(404),
        CONFLICT: new ResponseStatus(409),

        Family: StatusFamilies
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/rest-request.js' */
define('applinks/common/rest-request', [
    'applinks/lib/console',
    'applinks/lib/window',
    'applinks/lib/jquery',
    'applinks/lib/lodash',
    'applinks/common/preconditions',
    'applinks/common/response-status'
], function(
    console,
    window,
    $,
    _,
    Preconditions,
    ResponseStatus
) {
    var defaultRequestSettings = {
        dataType: 'json',
        contentType: 'application/json'
    };

    // construct the target URL by adding query params
    function _toUrl(url, queryParams) {
        if (_.isEmpty(queryParams)) {
            return url;
        }
        var separator = url.indexOf('?') > -1 ? '&' : '?';
        return url + separator + $.param(queryParams);
    }

    // create default success and error handlers to ensure we got an expected status
    function _defaultSuccessHandler(statuses) {
        return function(data, textStatus, request) {
            if (!_.some(statuses, function(status) { return status.matches(request) })) {
                console.error('Unexpected response status: ' + request.status + ': ' + request.responseText);
            }
        }
    }

    function _defaultErrorHandler(statuses) {
        return function(request, textStatus, error) {
            if (!_.some(statuses, function(status) { return status.matches(request) })) {
                console.error('Unexpected response status: ' + request.status + ': ' + request.responseText);
                // force re-login if UNAUTHORIZED
                if (ResponseStatus.UNAUTHORIZED.matches(request)) {
                    window.location.reload();
                }
            }
        }
    }

    /**
     * Creates a new instance of `ApplinksRestRequest`.
     *
     * @param url URL to request to. NOTE: URLs with fragments (`#`) are not supported
     * @param params query parameters to add to the request URL
     * @constructor
     */
    function ApplinksRestRequest(url, params) {
        Preconditions.nonEmptyString(url, 'url');
        Preconditions.checkArgument(url.indexOf('#') == -1, 'url: "#" fragments not supported');
        this._url = url;
        this._queryParams = _.extend({}, params);
        this._expectedStatus = [ResponseStatus.Family.SUCCESSFUL];
    }

    ApplinksRestRequest.GET = 'GET';
    ApplinksRestRequest.PUT = 'PUT';
    ApplinksRestRequest.POST = 'POST';
    ApplinksRestRequest.DELETE = 'DELETE';

    ApplinksRestRequest.prototype.get = function() {
        return this._execute(this._requestSettings(ApplinksRestRequest.GET));
    };

    ApplinksRestRequest.prototype.del = function() {
        return this._execute(this._requestSettings(ApplinksRestRequest.DELETE));
    };

    ApplinksRestRequest.prototype.put = function(data) {
        var settings = this._requestSettings(ApplinksRestRequest.PUT);
        if (data) {
            settings.data = data;
        }
        return this._execute(settings);
    };

    ApplinksRestRequest.prototype.post = function(data) {
        var settings = this._requestSettings(ApplinksRestRequest.POST);
        if (data) {
            settings.data = data;
        }
        return this._execute(settings);
    };

    /**
     * Add query param to this request.
     *
     * @param {string} name param name
     * @param {string} value param value
     * @return {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.queryParam = function(name, value) {
        this._queryParams[name] = value;
        return this;
    };

    /**
     * Add query params to this request.
     *
     * @param {Object} params params map to add
     * @returns {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.queryParams = function(params) {
        this._queryParams = _.extend(this._queryParams, params);
        return this;
    };

    /**
     * Add `authorisationCallback` query parameter to this request, this is useful for resources that are expected to
     * respond with `authorisationUri`
     *
     * @param {string} callback URI to call back once authorisation is done
     * @return {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.authorisationCallback = function(callback) {
        this.queryParam('authorisationCallback', callback);
        return this;
    };

    /**
     * Expect a specific status (or status family). Use a specific number or one of the members defined in
     * `applinks/common/response-status`. By default a successful 20x response is expected. If the response does not
     * meet this expectation, a default error handler will be invoked.
     *
     * Invoke this method with any number of of statuses expressed as an object that contains `matches` method (using
     * the ones in `applinks/lib/response-status` is highly recommended).
     * @returns {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.expectStatus = function() {
        this._expectedStatus = _.isArray(arguments[0]) ? arguments[0] : _.toArray(arguments);
        return this;
    };

    ApplinksRestRequest.prototype._requestSettings = function(requestType) {
        var that = this;
        return _.defaults({
            url: _toUrl(that._url, that._queryParams),
            type: requestType
        }, defaultRequestSettings);
    };

    ApplinksRestRequest.prototype._execute = function(settings) {
        return $.ajax(settings)
            .done(_defaultSuccessHandler(this._expectedStatus))
            .fail(_defaultErrorHandler(this._expectedStatus));
    };

    return ApplinksRestRequest;
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/rest.js' */
define('applinks/common/rest', [
    'applinks/lib/aui',
    'applinks/common/preconditions',
    'applinks/common/rest-request',
    'applinks/common/rest-oauth'
], function(
    AJS,
    Preconditions,
    ApplinksRestRequest,
    ApplinksOAuthRest
) {
    function ApplinksRestModule(version) {
        Preconditions.hasValue(version, 'version');
        this._version = version;
    }

    ApplinksRestModule.prototype.baseUrl = function() {
        return AJS.contextPath() + '/rest/applinks/' + this._version;
    };

    ApplinksRestModule.prototype.withPath = function(path) {
        return this.baseUrl() + '/' + path;
    };

    function ApplinksV1RestModule() {
        this.module = new ApplinksRestModule('1.0');
    }

    function ApplinksV2RestModule() {
        this.module = new ApplinksRestModule('2.0');
    }

    function ApplinksV3RestModule() {
        this.module = new ApplinksRestModule('3.0');
    }

    ApplinksV3RestModule.prototype.featureDiscovery = function(featureKey) {
        if (!featureKey) {
            throw 'feature key not defined';
        }
        return new ApplinksRestRequest(this.module.withPath('feature-discovery/' + featureKey));
    };

    ApplinksV3RestModule.prototype.features = function(featureName) {
        if (!featureName) {
            throw 'feature name not defined';
        }
        return new ApplinksRestRequest(this.module.withPath('features/' + featureName));
    };

    ApplinksV3RestModule.prototype.status = function(applinkId) {
        if (!applinkId) {
            throw 'applinkId not defined';
        }
        return new ApplinksRestRequest(this.module.withPath('status/' + applinkId));
    };

    return {
        V1: new ApplinksV1RestModule(),
        V2: new ApplinksV2RestModule(),
        V3: new ApplinksV3RestModule(),
        OAuth: ApplinksOAuthRest
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/rest-oauth.js' */
define('applinks/common/rest-oauth', [
    'applinks/lib/aui',
    'applinks/common/rest-request',
    'applinks/common/preconditions'
], function(
    AJS,
    ApplinksRestRequest,
    Preconditions
) {
    function ApplinksOAuthRestModule(version) {
        Preconditions.hasValue(version, 'version');
        this.baseUrl =  AJS.contextPath() + '/rest/applinks-oauth/' + version + '/';
    }

    ApplinksOAuthRestModule.prototype._withPath = function(path) {
        return this.baseUrl + path;
    };

    function ApplinksOAuthV1RestModule() {
        this.module = new ApplinksOAuthRestModule('1.0');
    }

    ApplinksOAuthV1RestModule.prototype.consumerToken = function(applinkId) {
        Preconditions.hasValue(applinkId, 'applinkId');
        return new ApplinksRestRequest(this.module._withPath('consumer-token/' + applinkId));
    };

    return {
        V1: new ApplinksOAuthV1RestModule()
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/i18n.js' */
define('applinks/common/i18n', [
    'applinks/lib/jquery',
    'applinks/lib/aui'
], function(
    $,
    AJS
) {
    function init() {
        // set up I18n for dynamical calls on client side, remember to use " for AJS.I18n.getText
        // Please make sure that AbstractApplinksServlet.java has put the appLinksI18n.entries correctly on the page
        AJS.I18n.keys = AJS.I18n.keys || {};
        $.extend(AJS.I18n.keys, appLinksI18n.entries);
    }

    return {
        init: init
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'js/fecru-compatibility.js' */
if (jQuery != undefined && AJS != undefined) jQuery = AJS.$; // make sure we're extending the correct jQuery;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/common/rest-service.js' */
/**
 * The triggering of AppLinks initialisation can be customised by setting a function on
 * AJS.AppLinksInitialisationBinder. The binder function should take a single argument which is a zero-arg function to
 * run and should execute this function when appropriate.
 */
AppLinks = AJS.$.extend(window.AppLinks || {}, {
    Event: {
        NAMESPACE: "applinks"
    }
});
var ApplinksEvents = require('applinks/common/events');
AppLinks.Event = AJS.$.extend(window.AppLinks.Event, ApplinksEvents);

// Is there an overridden initialisation binder?
if (AJS.AppLinksInitialisationBinder) {
    AppLinks.initialisationBinder = AJS.AppLinksInitialisationBinder;
} else {
    // The default bind if no specific binder is specified
    AppLinks.initialisationBinder = function(f) {
        AJS.toInit(f);
    }
}

AppLinks.initialisationBinder(function() {
    //$ is passed in by AJS.toInit but initilizationBinder can be over loaded by products so that $ is unsafe.
    var $ = AJS.$;
    AppLinks = $.extend(window.AppLinks || {}, {
        failure: function(data) {
            if (data.status == 401) {
                window.location.reload();
            } else {
                var message = AppLinks.parseError(data);
                var errorDivs = $('.page-error');

                if (errorDivs.length > 0) {
                    errorDivs.html(message).fadeIn('slow');
                }
                else {
                    alert("REST request failed: " + message);
                }
            }
        },
        jsonRequest: function(url, type, data, success, error) {
            if (data) {
                data = JSON.stringify(data);
            }
            $(".page-error").fadeOut('fast');
            if (!error) error = AppLinks.failure;
            return jQuery.ajax({
                url: url,
                type: type,
                data: data,
                dataType: 'json',
                contentType: "application/json; charset=utf-8",
                cache: false,
                success: success,
                error: error
            });
        },
        xmlRequest: function(url, type, data, success, error) {
            if (data) {
                data = JSON.stringify(data);
            }
            $(".page-error").fadeOut('fast');
            if (!error) error = AppLinks.failure;
            return jQuery.ajax({
                url: url,
                type: type,
                data: data,
                dataType: 'xml',
                contentType: "application/xml; charset=utf-8",
                cache: false,
                success: success,
                error: error
            });
        },
        parseError: function(errorData) {
            var error;
            try {
                error = JSON.parse(errorData.responseText);
            } catch (e) {
                if (errorData.statusText) {
                    return error = errorData.statusText;
                } else {
                    return errorData;
                }
            }
            if (error.message) {
                if ($.isArray(error.message)) {
                    return error.message.join(' ');
                }
                return error.message;
            }
            else {
                return errorData.statusText;
            }
        },
        put: function(url, data, success, error) {
            return AppLinks.jsonRequest(url, 'PUT', data, success, error);
        },
        post: function(url, data, success, error) {
            return AppLinks.jsonRequest(url, 'POST', data, success, error);
        },
        update: function(data, success, error) {
            AppLinks.put(AppLinks.self_link(data), data, success, error);
        },
        get: function(url, success, error) {
            return AppLinks.jsonRequest(url, 'GET', null, success, error);
        },
        getXml: function(url, success, error) {
            return AppLinks.xmlRequest(url, 'GET', null, success, error);
        },
        self_link: function(item) {
            for (var i = 0, _i = item.link.length; i < _i; i++) {
                var link = item.link[i];
                if (link.rel == "self") return link.href;
            }

            throw "No self-link found";
        },
        del: function(urlOrObject, success, error) {
            var url;
            if (typeof(urlOrObject) == 'string') url = urlOrObject;
            else url = AppLinks.self_link(urlOrObject);
            return AppLinks.jsonRequest(url, 'DELETE', null, success, error);
        },
        SPI: $.extend({}, {
            API_VERSION: "1.0",
            REST_RESOURCE_URL: AJS.contextPath() + "/rest/applinks/",
            BASE_URL: AJS.contextPath() + "/rest/applinks/1.0",
            OAUTH_REST_RESOURCE_URL: AJS.contextPath() + "/rest/applinks-oauth/",
            OAUTH_BASE_URL: AJS.contextPath() + "/rest/applinks-oauth/1.0",

            /**
             * Update the API version and associated urls.
             * @param version
             */
            setApiVersion: function(version){
                AppLinks.SPI.API_VERSION = version;
                AppLinks.SPI.setBaseUrl(AppLinks.SPI.REST_RESOURCE_URL + AppLinks.SPI.API_VERSION);
            },
            setBaseUrl: function(url){
                AppLinks.SPI.BASE_URL = url;
            },
            setOAuthBaseUrl: function(url){
                AppLinks.SPI.OAUTH_BASE_URL = url;
            },
            /**
             * Build a base URL for rest calls using the specified baseUrl.
             * @param baseUrl
             * @returns {string}
             */
            getRemoteRestBaseUrl: function(baseUrl) {
                return baseUrl + "/rest/applinks/" + AppLinks.SPI.API_VERSION;
            },
            /**
             * Build a base URL for plugin servlet calls using the specified baseUrl.
             * @param baseUrl
             * @returns {string}
             */
            getRemotePluginServletBaseUrl: function(baseUrl) {
                return baseUrl + "/plugins/servlet";
            },
            getAllLinks: function(success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink";
                return AppLinks.get(url, success, failure);
            },
            getAllLinksWithAuthInfo: function(success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/listApplicationlinks";
                return AppLinks.get(url, success, failure);
            },
            getApplicationLinkState: function(id, success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/listApplicationlinkstates/id/" + id;
                return AppLinks.get(url, success, failure);
            },
            getLinksOfType: function(typeId, success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink/type/" + typeId;
                return AppLinks.get(url, success, failure);
            },
            tryToFetchManifest: function(url, success, failure) {
                var restUrl = AppLinks.SPI.BASE_URL + '/applicationlinkForm/manifest.json?url=' + encodeURIComponent(url);
                return AppLinks.get(restUrl, success, failure);
            },
            getManifestFor: function(id, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/manifest/' + id + ".json";
                return AppLinks.get(url, success, failure);
            },
            getLocalManifest: function(success, failure){
                var url = AppLinks.SPI.BASE_URL + '/manifest.json';
                return AppLinks.get(url, success, failure);
            },
            /**
             * Attempt to get the Manifest of the remote application, via a direct REST call.
             * Requires CORS enabled on the REST resource.
             * @param url
             * @param success
             * @param failure
             * @returns {*}
             */
            getRemoteManifest: function(remoteBaseUrl, success, failure){
                var remoteManifestUrl = AppLinks.SPI.getRemoteRestBaseUrl(remoteBaseUrl) + '/manifest.json';
                return AppLinks.get(remoteManifestUrl, success, failure);
            },
            /**
             * Attempt to get the OAuth Consumer Info of the remote application, via a direct call.
             * Requires CORS enabled on the REST resource.
             * @param url
             * @param success
             * @param failure
             * @returns {*}
             */
            getRemoteOAuthConsumerInfo: function(remoteBaseUrl, success, failure){
                var remoteManifestUrl = AppLinks.SPI.getRemotePluginServletBaseUrl(remoteBaseUrl) + '/oauth/consumer-info';
                return AppLinks.getXml(remoteManifestUrl, success, failure);
            },
            getApplinkStatus: function (applinkId, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/status/' + applinkId;
                return AppLinks.get(url, success, failure);
            },
            createStaticUrlAppLink: function(applicationType, success, failure) {
                var restUrl = AppLinks.SPI.BASE_URL + '/applicationlinkForm/createStaticUrlAppLink?typeId=' + applicationType;
                return AppLinks.post(restUrl, null, success, failure);
            },
            createLink: function(applicationLink, username, password, createTwoWayLink, customRpcUrl, rpcUrl, configFormValues, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlinkForm/createAppLink';
                var data = {
                    applicationLink: applicationLink,
                    username: username,
                    password: password,
                    createTwoWayLink: createTwoWayLink,
                    customRpcURL: customRpcUrl,
                    rpcUrl: rpcUrl,
                    configFormValues: configFormValues
                };
                return AppLinks.post(url, data, success, failure);
            },
            createLinkWithOrphanedTrust : function(applicationLink, username, password, createTwoWayLink, customRpcUrl, rpcUrl, configFormValues, orphanedTrust, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlinkForm/createAppLink';
                var data = {
                    applicationLink: applicationLink,
                    username: username,
                    password: password,
                    createTwoWayLink: createTwoWayLink,
                    customRpcURL: customRpcUrl,
                    rpcUrl: rpcUrl,
                    configFormValues: configFormValues,
                    orphanedTrust: orphanedTrust
                };
                return AppLinks.post(url, data, success, failure);
            },
            verifyTwoWayLinkDetails : function (remoteUrl, rpcUrl, username, password, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlinkForm/details';
                var data = {
                    username: username,
                    password: password,
                    remoteUrl: remoteUrl,
                    rpcUrl: rpcUrl
                };
                return AppLinks.post(url, data, success, failure);
            },
            getApplicationLinkInfo: function (appId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlinkInfo/id/" + appId;
                return AppLinks.get(url, success, error);
            },
            deleteLink: function(applicationLink, reciprocate, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink/" + applicationLink.id;
                if (reciprocate) url += "?reciprocate=true";
                return AppLinks.del(url, success, error);
            },
            makePrimary: function(applicationLink, success) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink/primary/" + applicationLink.id;
                return AppLinks.post(url, null, success);
            },
            relocate: function(applicationLink, newUrl, suppressWarnings, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/relocateApplicationlink/" + applicationLink.id + "?newUrl=" + encodeURIComponent(newUrl) +
                        "&nowarning=" + (suppressWarnings ? "true" : "false");
                return AppLinks.post(url, null, success, error);
            },
            legacyUpgrade: function(applicationLink, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/upgrade/legacy/" + applicationLink.id;
                return AppLinks.post(url, null, success, error);
            },
            ualUpgrade: function(applicationLink, body, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/upgrade/ual/" + applicationLink.id;
                return AppLinks.post(url, body, success, error);
            },
            getEntityTypesForApplicationType: function(applicationType, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/type/entity/" + applicationType;
                return AppLinks.get(url, success, error);
            },
            getLocalEntitiesWithLinksToApplication: function(applicationLinkId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/localEntitiesWithLinksTo/" + applicationLinkId + ".json";
                return AppLinks.get(url, success, error);
            },
            getEntityLinksForApplication: function(applicationLinkId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entities/" + applicationLinkId + ".json";
                AppLinks.get(url, success, error);
            },
            getEntityLinksForApplicationUsingAnonymousAccess: function(applicationLinkId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entities/anonymous/" + applicationLinkId + ".json";
                return AppLinks.get(url, success, error);
            },
            createNonUalEntityLink: function(localType, localKey, applicationId, remoteTypeId, remoteKey, name, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/" + localType + "/" + localKey + "?reciprocate=false";
                var data = {
                    applicationId: applicationId,
                    typeId: remoteTypeId,
                    key: remoteKey,
                    name: name,
                    isPrimary: false
                };
                return AppLinks.put(url, data, success, error);
            },
            createEntityLink: function(localType, localKey, entity, reciprocate, success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/" + localType + "/" + localKey + "?reciprocate=";
                url += (reciprocate ? "true" : "false");
                return AppLinks.put(url, entity, success, failure);
            },
            getConfiguredEntityLinks: function(localType, localKey, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/primaryLinks/" + localType + "/" + localKey + ".json";
                return AppLinks.get(url, success, error);
            },
            deleteEntityLink: function(localTypeId, localKey, entity, reciprocate, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/" + localTypeId + "/" + localKey + "?typeId=" + entity.typeId + "&key=" + entity.key + "&applicationId=" + entity.applicationId + "&reciprocate=" + reciprocate;
                return AppLinks.del(url, success, error);
            },
            makePrimaryEntityLink: function(localTypeID, localKey, entity, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/primary/" + localTypeID + "/" + localKey + "?typeId=" + entity.typeId + "&key=" + entity.key + "&applicationId=" + entity.applicationId;
                return AppLinks.post(url, null, success, error);
            },
            canDeleteAppLink: function(applicationId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/permission/reciprocate-application-delete/" + applicationId;
                return AppLinks.get(url, success, error);
            },
            canDeleteEntityLink: function(localTypeId, localKey, entity, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/permission/reciprocate-entity-delete/" + entity.applicationId + "/" + localTypeId + "/" + localKey + "/" + entity.typeId + "/" + entity.key;
                return AppLinks.get(url, success, error);
            },
            canCreateReciprocateEntityLink: function(applicationId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/permission/reciprocate-entity-create/" + applicationId;
                return AppLinks.get(url, success, error);
            },
            processPermissionCode: function(settings) {
                var config = {
                    noPermission: function() {},
                    missing: function() {},
                    credentialsRequired: function(authUrl) {},
                    authenticationFailed: function(authUrl) {},
                    noAuthentication: function(authUrl) {},
                    noAuthenticationConfigured: function() {},
                    noConnection: function() {},
                    allowed: function() {},
                    unrecognisedCode: function(code) {},
                    updateView: function(message, icon, button) {}
                };

                if (!settings) settings = {};

                settings = $.extend(config, settings);

                return function(data) {
                    var code = data.code;
                    if (code == "NO_PERMISSION") {
                        settings.noPermission();
                    } else if (code == "MISSING") {
                        settings.missing();
                    } else if (code == "CREDENTIALS_REQUIRED") {
                        settings.credentialsRequired(data.url);
                    } else if (code == "AUTHENTICATION_FAILED") {
                        settings.authenticationFailed(data.url);
                    } else if (code == "NO_AUTHENTICATION") {
                        settings.noAuthentication(data.url);
                    } else if (code == "NO_AUTHENTICATION_CONFIGURED") {
                        settings.noAuthenticationConfigured();
                    } else if (code == "NO_CONNECTION") {
                        settings.noConnection();
                    } else if (code == "ALLOWED") {
                        settings.allowed();
                    } else {
                        settings.unrecognisedCode(data.code);
                    }
                };
            },
            addAuthenticationTrigger: function(target, authUrl, callbacks) {
                if (!callbacks) {
                    callbacks = {};
                }

                if (typeof callbacks.onSuccess == "undefined") {
                    callbacks.onSuccess = function() {
                        location.reload();
                    }
                }

                if (typeof callbacks.onFailure == "undefined") {
                    callbacks.onFailure = function() {
                        return true;
                    }
                }
                //Unbind previous click listener, otherwise we might end up opening multiple windows.
                $(target).unbind('click');
                $(target).click(function() {
                    if (callbacks.before) {
                        callbacks.before();
                    }
                    AppLinks.authenticateRemoteCredentials(authUrl, callbacks.onSuccess, callbacks.onFailure);
                });
            },
            deleteOrphanedTrust: function(id, type, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/orphaned-trust/" + type + "/" + id;
                return AppLinks.del(url, success, error);
            },
            getOrphanedTrust: function(success, error) {
                var url = AppLinks.SPI.BASE_URL + "/orphaned-trust/";
                return AppLinks.get(url, success, error);
            },
            showCreateEntityLinkSuggestion: function() {
                return true;
            },
            getApplicationLink: function(id, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlink/' + id;
                return AppLinks.get(url, success, failure);
            },
            createApplicationLink: function(id, name, rpcUrl, displayUrl, typeId, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlink';
                var data = {
                    id: id,
                    name: name,
                    rpcUrl: rpcUrl,
                    displayUrl: displayUrl,
                    typeId: typeId
                };
                return AppLinks.put(url, data, success, failure);
            },
// TODO APLDEV-3 extract OAuth creation code into OAuth specific js files in the Oauth plugin.
            createConsumer: function(id, key, name, description, sharedSecret, publicKey, twoLOAllowed, executingTwoLOUser, twoLOImpersonationAllowed, outgoing, success, failure) {
                var url = AppLinks.SPI.OAUTH_BASE_URL + '/applicationlink/' + id + '/authentication/consumer';
                var data = {
                    key: key,
                    name: name,
                    description: description,
                    sharedSecret: sharedSecret,
                    publicKey: publicKey,
                    outgoing: outgoing,
                    twoLOAllowed: twoLOAllowed,
                    executingTwoLOUser: executingTwoLOUser,
                    twoLOImpersonationAllowed: twoLOImpersonationAllowed
                };
                return AppLinks.put(url, data, success, failure);
            },
            createConsumerAutoConfigure: function(id, twoLOAllowed, executingTwoLOUser, twoLOImpersonationAllowed, success, failure) {
                var url = AppLinks.SPI.OAUTH_BASE_URL + '/applicationlink/' + id + '/authentication/consumer?autoConfigure=true';
                var data = {
                    twoLOAllowed: twoLOAllowed,
                    executingTwoLOUser: executingTwoLOUser,
                    twoLOImpersonationAllowed: twoLOImpersonationAllowed
                };
                return AppLinks.put(url, data, success, failure);
            },
            registerProvider: function(id, provider, config, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlink/' + id + '/authentication/provider';
                var data = {
                    config : config,
                    provider : provider
                };
                return AppLinks.put(url, data, success, failure);
            },
            enableFeature: function(featureName, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/features/' + featureName;
                return AppLinks.put(url, {}, success, failure);
            },
            disableFeature: function(featureName, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/features/' + featureName;
                return AppLinks.del(url, success, failure);
            }
        }, (window.AppLinks && window.AppLinks.SPI) || {})
    });

    var i18nRootKey = 'applinks';

    AppLinks.UI = {
        showInfoBox: function(message) {
            $('.aui-message.success').remove();
            AppLinks.UI.createMessage('success', message, 'page-info');
        },
        hideInfoBox: function() {
            $('.aui-message.success').remove();
        },
        showErrorBox: function(message) {
            AppLinks.UI.createMessage('error', message, 'page-error');
        },
        hideErrorBox: function() {
            $('.aui-message.error').remove();
        },
        showWarningBox: function(messages) {
            if ($.isArray(messages) && messages.length > 0) {
                var ulEl = $("<ul></ul>");
                $(messages).each(function(index) {
                    ulEl.append($("<li/>", {
                        text: messages[index]
                    }));
                });
                var messageEl = $('<div class="page-warning"></div>').append(ulEl);
                AppLinks.UI.createMessage('warning', messageEl.html(), 'page-warning');
            } else {
                AppLinks.UI.createMessage('warning', messages, 'page-warning');
            }
        },
        hideWarningBox: function() {
            $('.aui-message.warning').remove();
        },
        shortenString: function(message, maxLength) {
            if (message.length  > maxLength) {
               message = message.substring(0, maxLength) + "...";
            }
            return message;
        },
        createMessage: function(type, message, cssClass) {
            var messageEl = $('<div class="' + cssClass + '">');
            messageEl.html(message);
            AJS.messages[type](".applinks-message-bar", {
                title: "",
                body: messageEl.wrap('<div></div>').parent().html(),
                closeable: true
            });
            $(document).trigger(AppLinks.Event.Legacy.MESSAGE_BOX_DISPLAYED);
        },
        displayValidationErrorMessages: function (errorClass, rootEl, messages) {
            if ($.isArray(messages)) {
                $(messages).each(function(i,v) {
                   var d = $('<div class="error applinks-error">');
                   d.text(v);
                   $(rootEl).find("." + errorClass).append(d);
                });
            } else if(typeof messages != 'undefined'){
                var d = $('<div class="error applinks-error">');
                d.text(messages.toString());
                $(rootEl).find("." + errorClass).append(d);
            }
        },
        displayValidationError: function(errorClass, rootEl, errorFn) {
            return function(xhr) {
                if (xhr.status == 401) {
                    window.location.reload();
                    return;
                }

                $('.applinks-error').remove();
                $('.loading').remove();
                var respJSON = xhr.responseText;
                var respObj = $.parseJSON(respJSON);
                var messages = respObj.message;
                if (typeof respObj.fields == "undefined") {
                    AppLinks.UI.displayValidationErrorMessages(errorClass, rootEl, messages);
                } else {
                    var fields = respObj.fields;
                    $(fields).each(function(index) {
                        var d = $('<div class="error applinks-error" id="' + fields[index] + '-error">');
                        d.text(messages[index]);
                        if ($(rootEl).find('.' + fields[index]).length > 0) {
                          d.insertAfter($(rootEl).find('.' + fields[index]));
                        } else {
                          d.insertAfter($(rootEl).find('.' + errorClass).append(d));
                        }
                    });
                }
                $(rootEl).find('.' + errorClass).addClass("fully-populated-errors");
                if (errorFn) {
                 errorFn();
                }
            }
        },
        addProtocolToURL : function(url) {
            var newUrl = $.trim(url);
            var tempURL = newUrl.toLowerCase();
            var hasProtocol = false;
            if (tempURL.length >= 7) {
                if (tempURL.substring(0,7).indexOf('http') != -1) {
                    hasProtocol = true;
                }
            }
            //default protocol is http
            if (!hasProtocol) {
                newUrl = 'http://' + newUrl;
            }
            return newUrl;
        },
        /**
         * Similar to the standard Javascript join() method, but nicer in that
         * it uses a different delimiter for the last node (by default "and"),
         * so that:
         * {code}
         * "1, 2 and 3" == prettyJoin(['1', '2', '3'], function(value) {return value;});
         * {code}
         *
         * @param inputArray
         * @param resolveFn
         * @param finalDelimiter
         */
        prettyJoin : function(inputArray, resolveFn, finalDelimiter) {
            if (!finalDelimiter) {
                finalDelimiter = AppLinks.I18n.getText('applinks.and');
            }
            var maxLength = inputArray.length;
            var message = "";
            $.each(inputArray, function(index, value) {
                if (index == (maxLength - 1) && maxLength > 1) {
                  message += " " + finalDelimiter + "  " + resolveFn(value);
                } else {
                  message += resolveFn(value);
                  if (index + 2 < maxLength) {
                      message += ", ";
                  }
                }
            });
            return message;
        },
        showLoadingIcon: function(element) {
            $('<span class="loading">&nbsp;</span>').insertAfter(element);
        },
        hideLoadingIcon: function(element) {
            $(element).next('.loading').remove();
        },
        findUrl: function(text) {
            var url = undefined;
            var lcText = text.toLowerCase();
            var startOfUrl = lcText.indexOf('http:');
            if (startOfUrl == -1) {
                startOfUrl = lcText.indexOf('https:');
            }
            if (startOfUrl > -1) {
                var endOfUrl = lcText.indexOf(' ', startOfUrl);
                if (endOfUrl == -1) {
                    endOfUrl = lcText.length;
                }
                url = text.substring(startOfUrl, endOfUrl); // use _case-sensitive_ version to retrieve the actual URL
            }
            return url;
        },
        findApplicationType : function(id) {
            id = id.toLowerCase();
            if (id.indexOf("jira") != -1) {
                return "jira";
            } else if (id.indexOf("fisheye") != -1) {
                return "fecru";
            } else if (id.indexOf("confluence") != -1) {
                return "confluence";
            } else if (id.indexOf("refapp") != -1) {
                return "refapp";
            } else {
                return undefined;
            }
        },
        escapeSelector: function(selector) {
            // based on http://samuelsjoberg.com/archive/2009/09/escape-jquery-selectors
            return selector.replace(/([#;&,\.\+\*\~':"\!\^$\[\]\(\)=>\|])/g, "\\$1");
        },
        sanitiseHTML: function(input) {
            var replacements = {
                "<": "&lt;",
                '"': "&quot;",
                "&": "&amp;"
            };
            return input.replace(/[<"&]/g, function(match) {
                return replacements[match];
            });
        },
        refreshOrphanedTrust: function() {
            // post dialog -- check whether we need to remove any orphaned-trust entries
            var updateOrphanedTrust = function(data) {
                $("tr.orphaned-trust-row").each(function() {
                    var $this = $(this);
                    var id = $this.attr("data-id");
                    var type = $this.attr("data-type");
                    var stillExists = false;
                    for (var i = 0; i < data.orphanedTrust.length; i++) {
                        var ot = data.orphanedTrust[i];
                        if (id == ot.id && type == ot.type) {
                            stillExists = true;
                            break;
                        }
                    }
                    if (!stillExists) {
                        $this.remove();
                        if (data.orphanedTrust.length == 0) {
                            // we just removed the last orphaned trust cert, hide warning!
                            $(".orphaned-trust-warning").hide();
                        }
                    }
                });
            };

            AppLinks.SPI.getOrphanedTrust(updateOrphanedTrust);
        },
        removeCssClass: function(element, prefix) {
            $(element).removeClass( function(index, className) {
                   var classes = className.split(' ');
                   var classToRemove = "";
                   $.each(classes, function(index, value) {
                       if (value.indexOf(prefix) != -1) {
                           classToRemove = value;
                       }
                   });
                   return classToRemove;
            } );
        }
    };

    /**
     * Add jQuery event system to AppLinks.UI namespace.
     */
    (function(){
        var eventBus = $({});
        $.each(['bind', 'unbind', 'trigger'], function(i, current){
            AppLinks.UI[current] = function(){
                return eventBus[current].apply(eventBus, arguments);
            }
        });
    })();

    AppLinks.I18n = {
        // very simple i18n param interpolation, doesn't attempt to respect escaping
        //Deferrs to AJS.format for for legacy reason the array conversion needs to stick around.
        interpolate: function(text, params) {
            if (params) {
                if (!$.isArray(params)) {
                    // single arg
                    params = [new String(params)];
                }
                params.unshift(text);
                text = AJS.format.apply(AJS, params);
            }
            return text;
        },
        getTextWithPrefix: function(key, params) {
            return AppLinks.I18n.interpolate(appLinksI18n.entries[i18nRootKey + "." + key], params);
        },
        getText: function(key, params) {
            return AppLinks.I18n.interpolate(AppLinks.I18n.resolveValue(key), params);
        },
        getApplicationTypeName: function(typeId) {
            return appLinksI18n.entries["applinks.application.type." + typeId];
        },
        getEntityTypeName: function(typeId) {
            return appLinksI18n.entries["applinks.entity.type." + typeId];
        },
        getPluralizedEntityTypeName: function(typeId) {
            return appLinksI18n.entries["applinks.entity.type.plural." + typeId];
        },
        getAuthenticationTypeName: function(type) {
            return appLinksI18n.entries["applinks.auth.provider." + type];
        },
        resolveValue: function(key) {
            var value = appLinksI18n.entries[key];
            return typeof value == "undefined" ? key : value;
        }
    };

    var ApplinksHelpPaths = require('applinks/common/help-paths');
    AppLinks.Docs = {

        /**
         * NOTE: this is a dynamically generated version of the link build in _help_link.vm, any update here should be
         * applied there.
         * @method createDocLink
         * @param pageKey a key that maps to a page in ual-help-paths.properties
         * @param sectionKey (Optional) a key that maps to an anchor section id in ual-help-paths.properties
         * @return an html &lt;a&gt; element targeting the specified page & section
         * @deprecated use
         */
        createDocLink: function(pageKey, sectionKey, css) {
            if (!css) {
                css = "";
            } else {
                css = " " + css;
            }
            return $("<a/>", {
                "class": "ual-help-link help-link" + css,
                href: AppLinks.Docs.getDocHref(pageKey, sectionKey),
                target: "_blank",
                "data-help-link-key": pageKey,
                text: AppLinks.I18n.getText("applinks.help"),
                title: AppLinks.I18n.getText("applinks.help")
            });
        },
        /**
         * @method getDocHref
         * @param pageKey a key that maps to a page in ual-help-paths.properties
         * @param sectionKey (Optional) a key that maps to an anchor section id in ual-help-paths.properties
         * @return the url of the given page and section (if specified)
         */
        getDocHref: function(pageKey, sectionKey) {
            var link = ApplinksHelpPaths.getFullPath(pageKey);
            if (sectionKey) {
                link += '#' + ApplinksHelpPaths.getPath(pageKey);
            }
            return link;
        }
    };

    $(document).trigger(AppLinks.Event.PREREADY);
    $(document).trigger(AppLinks.Event.READY);
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/component/autocomplete.js' */
AJS.$(document).bind(AppLinks.Event.READY, function() {
/**
 * TODO: THIS CODE IS COPIED FROM CONFLUENCE and should be part of AUI/AJS.
 * IF AUI comes with the InputDrivenDropDown when can remove this file.
 * https://studio.atlassian.com/browse/AJS-471
 *
 * A simple cache manager that supports a
 * FIFO cache invalidation strategy.
 *
 * @class cacheManager
 * @namespace AJS.Confluence
 * @constructor
 * @param cacheSize the size of the cache before keys are invalidated
 */
AppLinks.autoComplete = {
        cacheManager : function (cacheSize) {
    var cache = {},
        cacheStack = [],
        cacheSize = cacheSize || 30;

    return {
        /**
         * Return the value stored in the cache for the given key
         * @method get
         * @param key {String}
         */
        get: function(key) {
            return cache[key];
        },
        /**
         * Put the given key, value in the cache
         * @method put
         * @param key {String}
         * @param value {Object}
         */
        put: function(key, value) {
            cache[key] = value;
            cacheStack.push(key);
            if (cacheStack.length > cacheSize) {
                delete cache[cacheStack.shift()];
            }
        },
        /**
         * Clear the cache.
         */
        clear : function() {
            cache = {};
            cacheStack = [];
        }
    };
}};


(function($){
    /**
     * Check that all items in the drop down can be displayed - show ellipses at the end of any that
     * are too long. Also remove any unused properties that the dropDown may have stored for each
     * item in the list.
     *
     * @method truncateText
     * @private
     */
    var truncateText = function (dd) {
        AJS.log("InputDrivenDropDown: truncating text");
        var width = dd.$.closest(".aui-dropdown").width(),
            rightPadding = 20; // add some padding so the ellipsis doesn't run over the edge of the box

        $("a span:not(.icon)", dd.$).each(function () {
            var $a = $(this),
                elpss = AJS("var", "&#8230;"),
                elwidth = elpss.width(),
                isLong = false;

            $a.wrapInner($("<em>"));
            $("em", $a).each(function () {
                var $label = $(this);

                $label.show();
                if (this.offsetLeft + this.offsetWidth > width) {
                    var childNodes = this.childNodes,
                        success = false;

                    for (var j = childNodes.length - 1; j >= 0; j--) {
                        var childNode = childNodes[j],
                            truncatedChars = 1,
                            valueAttr = (childNode.nodeType == 3) ? "nodeValue" : "innerHTML",
                            nodeText = childNode[valueAttr];

                        do {
                            if (truncatedChars <= nodeText.length) {
                                childNode[valueAttr] = nodeText.substr(0, nodeText.length - truncatedChars++);
                            } else { // if we cannot fit even one character of the next word, then try truncating the node just previous to this
                                break;
                            }
                        } while (this.offsetLeft + this.offsetWidth + elwidth > width - rightPadding);

                        if (truncatedChars <= nodeText.length) {
                            // we've managed truncate part of the word and fit it in
                            success = true;
                            break;
                        }
                    }

                    if (success) {
                        isLong = true;
                    } else {
                        $label.hide();
                    }
                }
            });
            if (isLong) {
                $a.append(elpss);
                this.elpss = elpss;
            }
        });
    };

    var highlightTokens = function(dd, tokens) {
        if (!tokens.length || !tokens[0]) return;

        AJS.log("InputDrivenDropDown: highlighting tokens");

        // escape regex chars .*+?|()[]{}\ first
        for (var i = 0, ii = tokens.length; i < ii; i++) {
            var token = tokens[i];
            tokens[i] = token ? token.replace(/[\.\*\+\?\|\(\)\[\]{}\\]/g, "\\$") : "";
        }

        var regex = new RegExp("(" + tokens.join("|") + ")", "gi");

        $("li a:not(.dropdown-prevent-highlight) span", dd.$).each(function() {
            var span = $(this),
                html = span.html().replace(regex, "<strong>$1</strong>");
            span.html(html);
        });
    };

    /**
     * Builds and shows the dropdown.
     *
     * @param idd the InputDrivenDropdown
     * @param dropdownData in the form { matrix, query, queryTokens }
     * @private
     */
    var makeDropdown = function (idd, dropdownData) {
        var options = idd.options,
            old_dd = idd.dd;

        if (old_dd) {
            old_dd.hide();
            old_dd.$.remove();
        }

        options.ajsDropDownOptions = options.ajsDropDownOptions || {};
        if (options.ajsDropDownOptions && !options.ajsDropDownOptions.alignment) { // default to left alignment
            options.ajsDropDownOptions.alignment = "left";
        }
        //this needs to be moved into aui
        options.ajsDropDownOptions.selectionHandler = options.ajsDropDownOptions.selectionHandler || function(e, element) {
            if(e.type != "click") {
                e.preventDefault();
                $("a",element).click();
                document.location = $("a",element).attr("href");
            }
        };

        /* Fixing an AUI bug in here:  AJS.dropdown puts the raw 'matrix[i].name' as html, without escaping it !
           The solution is to override their displayHandler
         */
        /**
         * Escape obj.name and return it
         */
        options.ajsDropDownOptions.displayHandler = function (obj) {
            return AJS.escapeHtml(obj.name);
        }

        var dd = idd.dd = new AJS.dropDown(dropdownData.matrix, options.ajsDropDownOptions)[0];

        // could move into dropdown.js in AUI
        if (options.ajsDropDownOptions && options.ajsDropDownOptions.className) {
            dd.$.addClass(options.ajsDropDownOptions.className);
        }

        // place the created drop down using the configured dropdownPlacement function
        // if there is none then use a default behaviour
        if (options.dropdownPlacement) {
            options.dropdownPlacement(dd.$);
        } else {
            AJS.log("No dropdownPlacement function specified. Appending dropdown to the body.");
            $("body").append(dd.$);
        }

        highlightTokens(dd, dropdownData.queryTokens || [dropdownData.query]);
        truncateText(dd);

        if (options.dropdownPostprocess) {
            options.dropdownPostprocess(dd.$);
        }
        dd.show(idd._effect);

        if (typeof options.onShow == "function") {
            options.onShow.call(dd, dd.$);
        }

        return dd;
    };

    /**
     * Provides a controller-agnostic object that listens for controller changes and populates a dropdown
     * via a callback. Most aspects can be customized via the options object parameter.
     * <br>
     * Options are:
     * <li>
     *   getDataAndRunCallback - (required) callback method used to provide data for the dropdown. It must take
     *                          two parameters, user input value and the callback function to execute.
     * </li>
     * <li>
     *   onShow - function to call when the drop-down is displayed
     * </li>
     * <li>
     *   dropdownPlacement - a function that will be called with the drop down and which should place it in the
     *                          correct place on the page. The supplied arguments are 1) the input that issued the
     *                          search, 2) the dropDown to be placed.
     * </li>
     * <li>
     *   ajsDropDownOptions - any options the underlying dropDown component can handle expects
     * </li>
     * <li>
     *   onDeath - callback to run when dropdown dies
     * </li>
     * @class InputDrivenDropDown
     * @namespace AJS
     */
    function InputDrivenDropDown(id, options) {
        this._effect = "appear";
        this._timer = null;

        this.id = id;
        this.options = options;
        this.inactive = false;
        this.busy = false;
        this.cacheManager = AppLinks.autoComplete.cacheManager();
    }

    /**
     * Clears the cache.
     */
    InputDrivenDropDown.prototype.clearCache = function () {
        this.cacheManager.clear();
    };

    /**
     * This method should be called when the user input for this dropdown has changed.
     * It will check the cache before fetching data (via options.getDataAndRunCallback)
     * and displaying the dropdown.
     *
     * @param value {String} the new value of the user input
     * @param force {Boolean} force a change to occur regardless of user input
     */
    InputDrivenDropDown.prototype.change = function (value, force) {
        var t = this;
        if (value != t._value || force) {
            t._value = value;
            t.busy = false;

            clearTimeout(t._timer);

            if (force || (/\S{0,}/).test(value)) {
                var cachedVal = t.cacheManager.get(value);
                if (cachedVal) {
                    makeDropdown(t, cachedVal);
                } else {
                    t.busy = true;
                    t._timer = setTimeout(function () { // delay sending a request to give the user a chance to finish typing their search term(s)
                        t.options.getDataAndRunCallback.call(t, value, t.show);
                    }, 200);
                }
            } else {
                t.dd && t.dd.hide();
            }
        }
    };

    /**
     * Gets the number of visible options in the dropdown.
     */
    InputDrivenDropDown.prototype.dropDownLength = function () {
        return this.dd.links ? this.dd.links.length : 0;
    };
    
    /**
     * Gets the specified menu item from the dropdown list.
     * 
     * @param index {Integer} the 0-based index of the dropdown option list
     */
    InputDrivenDropDown.prototype.dropDownItem = function (index) {
        return this.dropDownLength() > index ? this.dd.links[index] : null;
    };
    
    /**
     * Hides the drop down
     */
    InputDrivenDropDown.prototype.hide = function () {
        this.dd && this.dd.hide();
    };

    /**
     * Hides and removes the drop down from the DOM.
     */
    InputDrivenDropDown.prototype.remove = function () {
        var dd = this.dd;
        if (dd) {
            this.hide();
            dd.$.remove();
        }
        this.inactive = true;
        this.options.onDeath && this.options.onDeath();
    };

    /**
     * Shows the drop down with the given matrix data and query.
     * <br>
     * Matrix property should be an array of arrays, where the sub-arrays represent the different
     * search categories.
     *
     * Expected properties of category sub-array objects are:
     *  - href
     *  - name
     *  - className
     *  - html (optional, replaces href and name)
     *  - icon (optional)
     *
     *
     * @param matrix {Array} matrix to populate the drop down from
     * @param query {String} the user input string that triggered this show
     * @param queryTokens {Array} an array of strings of the query tokens. Use for highlighting search terms.
     */
    InputDrivenDropDown.prototype.show = function (matrix, query, queryTokens) {
        if (this.inactive) {
            AJS.log("Quick search abandoned before server response received, ignoring. " + this);
            return;
        }

        var dropdownData = {
            matrix: matrix,
            query: query,
            queryTokens: queryTokens
        };
        this.cacheManager.put(query, dropdownData);

        makeDropdown(this, dropdownData);
        this.busy = false;
    };

    /**
     * Returns an InputDrivenDropDown. See InputDrivenDropDown for more documentation.
     * @param options {Object} options for the InputDrivenDropDown
     * @constructor
     */
    AppLinks.inputDrivenDropdown = function (options) {
        return new InputDrivenDropDown("inputdriven-dropdown", options);
    };

})(jQuery);
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/component/wizard.js' */
AJS.$(document).bind(AppLinks.Event.PREREADY, function() {

    (function($) {

        $.fn.wizard = function(settings) {
            var config = {
                width: 500,
                height: 350,
                onshow: function(popup, configuration) {
                    return true;
                },
                aftershow: function() {
                    return true;
                },
                oncancel: function() {
                    return true;
                },
                onsubmit: function() {
                    return true;
                },
                aftersubmit: function() {
                    return true;
                },
                onnext: function() {
                    return true;
                },
                onprevious: function() {
                    return true;
                },
                cancelLabel: AppLinks.I18n.getText("applinks.cancel"),
                submitLabel: AppLinks.I18n.getText("applinks.create"),
                nextLabel: AppLinks.I18n.getText("applinks.next"),
                previousLabel: AppLinks.I18n.getText("applinks.previous"),
                id: ""
            };

            if (!settings) settings = {};

            settings = $.extend(config, settings);

            var result = this;

            this.each(function() {
                var obj = $(this);
                var popup = new AJS.Dialog(settings.width, settings.height, settings.id);
                var showFn = show(popup, settings.onshow, settings.aftershow);
                var cancelFn = cancel(popup, settings.oncancel);
                var submitFn = submit(popup, settings.onsubmit, settings.aftersubmit);
                var previousFn = previous(popup, settings.onprevious)
                var nextFn = next(popup, settings.onnext);

                var disableNextFn = disableNext(popup);
                var enableNextFn  = enableNext(popup);

                var disableSubmitFn = disableSubmit(popup);
                var enableSubmitFn  = enableSubmit(popup);

                var disablePreviousFn = disablePrevious(popup);
                var enablePreviousFn  = enablePrevious(popup);

                if (settings.showButtonId) {
                    $('#' + settings.showButtonId).click(showFn);
                }

                var pages = findPages(obj);


                for (var pageIndex = 0; pageIndex < pages.length; pageIndex++) {
                    var page = pages[pageIndex];
                    createPage(popup, page);
                    if (page.className) {
                        popup.addHeader(page.title, page.className + "-header");
                    } else {
                        popup.addHeader(page.title);
                    }

                    if (pageIndex != 0 && $(page.div).attr("previous") != "false") {
                        popup.addButton(settings.previousLabel, previousFn, "applinks-previous-button");
                    }

                    if (pageIndex < pages.length - 1 && $(page.div).attr("submit") != "true" && $(page.div).attr("next") != "false") {
                        popup.addButton(settings.nextLabel, nextFn, "applinks-next-button");
                    }

                    if ($(page.div).attr("submit") == "true") {
                        popup.addButton(settings.submitLabel, submitFn, "wizard-submit");
                    }

                    if (!popup.getPage(pageIndex).buttonpanel) {
                        //THIS IS A DUMMY BUTTON, which gets remove afterwards
                        //THE DUMMY BUTTON will cause the cancel text link to appear on the correct position.
                        //IT IS A WORKAROUND so I don't have to change the dialog.js code
                        popup.addButton("", null);
                        $(popup.getPage(pageIndex).buttonpanel).empty();
                        var cancelLink = $('<button class="aui-button aui-button-link button-panel-button applinks-cancel-link">' + settings.cancelLabel + '</button>');
                        popup.getPage(pageIndex).buttonpanel.append(cancelLink);
                        cancelLink.click(cancelFn);
                    } else {
                        var cancelLink = $('<button class="aui-button aui-button-link button-panel-link button-panel-cancel-link applinks-cancel-link">' + settings.cancelLabel + '</button>');
                        $(popup.getPage(pageIndex).buttonpanel).append(cancelLink);
                        cancelLink.click(cancelFn);
                    }

                    if (pageIndex < pages.length - 1) {
                        popup.addPage();
                    }
                }

                result = {
                    dialog: popup,
                    nextPage: nextFn,
                    prevPage: previousFn,
                    submit: submitFn,
                    cancel: cancelFn,
                    show: showFn,
                    disableNextBtn     : disableNextFn,
                    enableNextBtn      : enableNextFn,
                    disableSubmitBtn   : disableSubmitFn,
                    enableSubmitBtn    : enableSubmitFn,
                    disablePreviousBtn : disablePreviousFn,
                    enablePreviousBtn  : enablePreviousFn
                };
                popup.gotoPage(0);
                popup.gotoPanel(0);
            });

            return result;
        };

        function disablePrevious(popup) {
            return function() {
                disable(getButton(popup, 'applinks-previous-button'));
            }
        }

        function enablePrevious(popup) {
            return function() {
                enable(getButton(popup, 'applinks-previous-button'));
            }
        }

        function disableNext(popup) {
            return function() {
                disable(getButton(popup, 'applinks-next-button'));
            }
        }

        function enableNext(popup) {
            return function() {
                enable(getButton(popup, 'applinks-next-button'));
            }
        }

        function disableSubmit(popup) {
            return function(showLoading) {
                var buttonEl = getButton(popup, 'wizard-submit');
                disable(buttonEl);
                if (typeof(showLoading) == 'undefined' || showLoading) {
                    $('<span class="loading">&nbsp;</span>').insertBefore(buttonEl);
                } else {
                    buttonEl.parent().find('.loading').remove();
                }
            }
        }

        function enableSubmit(popup) {
            return function() {
                var buttonEl = getButton(popup, 'wizard-submit');
                enable(buttonEl);
                buttonEl.parent().find('.loading').remove();
            }
        }

        function getButton(popup, cssClass) {
            return $(popup.getPage(popup.curpage).buttonpanel).find('.' + cssClass);
        }

        function resetForms(popup) {
             $(popup.popup.element).find('form').each( function() {
                  this.reset();
             });
        }

        function enable(element) {
            element.attr('disabled', false);
        }

        function disable(element) {
            element.attr('disabled', true);
        }
		
        function show(popup, onshow, aftershow) {
            return function(configuration) {
				if (onshow(popup, configuration) !== false) {
                    popup.gotoPage(0);
                    popup.gotoPanel(0);
                    $(document).unbind('keydown.ual.dialog');
                    $(document).bind('keydown.ual.dialog', attachKeypressListener(popup));
					popup.show();
                    aftershow();
                }
            }
        }

        function cancel(popup, oncancel) {
            return function() {
                if (oncancel(popup) !== false) {
                    popup.hide();
                    resetForms(popup);
                }
            }
        }

        function previous(popup, onprevious) {
            return function() {
                if (onprevious(popup) !== false) {
                    popup.prevPage();
                }
            }
        }

        function next(popup, onnext) {
            return function() {
                if (onnext(popup) !== false) {
                    popup.nextPage();
                }
            }
        }

        function attachKeypressListener(popup) {
            return function(e) {
                if (e.keyCode === 27) {
                    resetForms(popup);
                    $(document).unbind('keydown.ual.dialog');
                }
            }
        }

        function submit(popup, onSubmit, afterSubmit) {
            return function() {
                if (onSubmit(popup) !== false) {
                    afterSubmit(popup);
                    resetForms(popup);
                }
            }
        }

        function createPage(popup, page) {
            var panelDivs = $("> div[panel]", page.div);
            if (panelDivs.length > 0) {
                panelDivs.each(function(index, panelDiv) {
                    var popupPage = popup.addPanel(panelDiv.title, null, panelDiv.className, 'menu-' + panelDiv.id);
                    popupPage.getCurrentPanel().body.append(panelDivs[index]);
                });
            }
            else {
                var popupPage = popup.addPanel(page.title);
                popupPage.getCurrentPanel().body.append(page.div);
            }
        }


        function findPages(containerDiv) {
            var pagesDivs = $(" > div", containerDiv);
            var pages = [];
            pagesDivs.each(function(index) {
                var pageDiv = $(this);
                pages[index] = {
                    title: pageDiv.attr('title') || null,
                    className: pageDiv.attr('class'),
                    div: pageDiv
                };
            });
            return pages;
        }
    })(jQuery)
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/feature/applinks-wizard/applinkwizard.js' */
(function($) {
    AppLinks.Wizard = {
        getWizard: function(){
            return $("#create-application-link-container").data('wizard');
        },
        initAuthenticationUI: function(element) {
            var root = $(element);
            var createTwoWayLinkCheckbox = root.find('.create-reciprocal-link');
            var ualArrow = root.find('.ual-arrow');
            var linkDetails = root.find('.two-way-link-details');
            var linkDescription = root.find('.reciprocal-link-description');
            var noLinkDescription = root.find('.no-reciprocal-link-description');
            createTwoWayLinkCheckbox.click(function() {
                if (createTwoWayLinkCheckbox.is(':checked')) {
                    ualArrow.removeClass('no-background');
                    linkDetails.show();
                    linkDescription.show();
                    noLinkDescription.hide();
                } else {
                    ualArrow.addClass('no-background');
                    linkDetails.hide();
                    linkDescription.hide();
                    noLinkDescription.show();
                }
            });
            var sameUserBtn = root.find('.same-user-radio-btn');
            var differentUserBtn = root.find('.different-user-radio-btn');
            var differentUserBaseImage = root.find('.different-userbase-image');
            var sameUserBaseImage = root.find('.same-userbase-image');

            sameUserBtn.click(function() {
                differentUserBaseImage.addClass('different-userbase-image-grey');
                sameUserBaseImage.removeClass('same-userbase-image-grey');
            });

            differentUserBtn.click(function() {
                sameUserBaseImage.addClass('same-userbase-image-grey');
                differentUserBaseImage.removeClass('different-userbase-image-grey');
            });
        },

        initNonUALUI : function(element) {
            var root = $(element);
            var applicationTypesEl = root.find('.application-types');
            for (var i = 0; i < nonAppLinksApplicationTypes.length; i++) {
                $('<option value=\"' + nonAppLinksApplicationTypes[i].typeId + '\">' + nonAppLinksApplicationTypes[i].label + '</option>').appendTo(applicationTypesEl);
            }
        },
        fetchManifest : function(wizard, dialogRootEl, ualAppCallbackFn, nonUALAppCallbackFn) {
            var applicationURLEl = dialogRootEl.find('#application-url');
            if (applicationURLEl.val() == '') {
                var applicationTypeEl = dialogRootEl.find('#application-types');
                if (applicationTypeEl.val() == '') {
                    $('<div class="error applinks-error">' + AppLinks.I18n.getText('applinks.error.url.field.empty') + '</div>').insertAfter(applicationURLEl);
                    return false;
                }
                var success = function(data) {
                    wizard.enableSubmitBtn();
                    wizard.enablePreviousBtn();
                    wizard.cancel();
                    AppLinks.UI.listApplicationLinks(data.applicationLink.id, 'new', data);
                };
                AppLinks.SPI.createStaticUrlAppLink(applicationTypeEl.val(), success, null);
                return true;
            }
            var appUrl = AppLinks.UI.addProtocolToURL(applicationURLEl.val());

            AppLinks.UI.showLoadingIcon(applicationURLEl);
            var success = function(data) {
                var manifest = data;
                wizard.enableNextBtn();
                dialogRootEl.find('.loading').remove();
                dialogRootEl.find('.reciprocal-rpc-url').val($('#baseUrl').val());
                if (typeof data.typeId != "undefined") {
                    AppLinks.Wizard.handleUALManifest(manifest, dialogRootEl);
                    wizard.dialog.gotoPage(2);
                    dialogRootEl.find('.reciprocal-link-username').focus();
                    if (ualAppCallbackFn) {
                      ualAppCallbackFn(manifest);
                    }
                }
                else {
                    if (data.code == 'applinks.warning.redirected.host' && !applicationURLEl.data('hasWarnedAboutRedirection')) {
                        // The host requires a redirection. Stay on the same page, ask for a confirmation.
                        AppLinks.UI.displayValidationErrorMessages('manifest-validation-errors', dialogRootEl, data.warning);
                        applicationURLEl.data('hasWarnedAboutRedirection', 'true');
                        var unsetRedirectionWarning = function () {
                            $(applicationURLEl).removeData('hasWarnedAboutRedirection');
                            $(applicationURLEl).unbind('change', unsetRedirectionWarning);
                        };
                        applicationURLEl.bind('change', unsetRedirectionWarning);
                    }
                	else if (data.code == 'applinks.warning.unknown.host' && !applicationURLEl.data('forceWhenHostIsOffline')) {
                	    // The host doesn't ping. Stay on the same page, ask for a confirmation.
                	    AppLinks.UI.displayValidationErrorMessages('manifest-validation-errors', dialogRootEl, data.warning);
                	    applicationURLEl.data('forceWhenHostIsOffline', 'true');
                	    var unsetForceWhenHostIsOffline = function () {
                	        $(applicationURLEl).removeData('forceWhenHostIsOffline');
                	        $(applicationURLEl).unbind('change', unsetForceWhenHostIsOffline);
                	    };
                	    applicationURLEl.bind('change', unsetForceWhenHostIsOffline);
            		}
                	else {
                        if (manifest.code == 'applinks.warning.unknown.host' || manifest.code == "applinks.warning.redirected.host") {
                	        // The user has already been notified of this warning.
                	        delete manifest.warning;
                	        delete manifest.code;
                	    }
                	    AppLinks.Wizard.handleNonUALManifest(manifest, appUrl, dialogRootEl);
                        wizard.dialog.gotoPage(1);
                        dialogRootEl.find('.application-name').focus();
                        if (nonUALAppCallbackFn) {
                          nonUALAppCallbackFn(manifest);
                        }
                	}
                }
            };
            wizard.disableNextBtn();
            AppLinks.SPI.tryToFetchManifest(appUrl, success, AppLinks.UI.displayValidationError('manifest-validation-errors', dialogRootEl, function() {
                wizard.enableNextBtn();
            }));
            return appUrl;
        },
        handleUALManifest : function(manifest, element) {
            var root = $(element);
            root.find('.remote-app-image').removeClass( function(index, className) {
            var classes = className.split(' ');
            var classToRemove = "";
                $.each(classes, function(index, value) {
                    if (value.indexOf('application-type-image-') != -1) {
                        classToRemove = value;
                    }
                });
                return classToRemove;
            });
            root.find('.remote-app-image').addClass('application-type-image-' + manifest.typeId);
            root.find('.link-to-app-type').html(AppLinks.I18n.getText('applinks.create.title.link.to', AppLinks.I18n.getApplicationTypeName(manifest.typeId)));
            root.find('.remote-app-name').text(AppLinks.UI.shortenString(manifest.name, 20));
            root.find('.create-reciprocal-link').attr('checked', true);
            root.find('#reciprocal-link-back-to-server').html(AppLinks.I18n.getText('applinks.create.link.back.to.server', AJS.escapeHtml(manifest.name)));
            // For the two way link text, we need to specify different roles for the credentials depending on the remote app
            // For JIRA and Confluence version < 3.10, it is system administrator
            // For everything else, it is administrator
            var twoWayLinkParams = ["administrator", AJS.escapeHtml(manifest.name),
                             '<a target="_blank" href="' + AppLinks.Docs.getDocHref("applinks.docs.adding.application.link") + '">', '</a>'];
            if(manifest.applinksVersion != undefined) {
                var remoteVersion = manifest.applinksVersion.split(".");
                var majorVersion = parseInt(remoteVersion[0]);
                var minorVersion = parseInt(remoteVersion[1]);
                // we don't have to check for versions < 3 since those won't have the manifest.
                if ((manifest.typeId == "jira" || manifest.typeId == "confluence") && (majorVersion == 3 && minorVersion < 10)) {
                    twoWayLinkParams[0] = "system administrator";
                }
            }
            root.find('.reciprocal-link-description').html(AppLinks.I18n.getText('applinks.create.two.way.link', twoWayLinkParams));
            root.find('.no-reciprocal-link-description').hide();
            root.find('.no-reciprocal-link-description').html(AppLinks.I18n.getText('applinks.create.two.way.no.link', AJS.escapeHtml(manifest.name)));
            root.find('.reciprocal-link-username').val('');
            root.find('.reciprocal-link-password').val('');
            root.find('.ual-arrow').removeClass('no-background');
            root.find('.two-way-link-details').show();
            root.find('.reciprocal-link-description').show();
            root.find('.no-reciprocal-link-description').hide();
        },
        handleNonUALManifest : function(data, appUrl, element) {
            var root = $(element);
            root.find('.application-name').val('');
            root.find(".application-types option:first-child").attr("selected", "selected");
            root.find('.non-ual-application-url').text(appUrl);
            if (data.warning) {
                root.find('.create-non-ual-warning').show();
                root.find('.create-non-ual-warning').html(data.warning);
            } else {
                root.find('.create-non-ual-warning').hide();
            }
        },
        checkReciprocalLinkFormThreeStepMode : function(element, handleOneWayLinkFn, handleTwoWayLinkDetailsSuccess, appUrl, errorFn) {
            var root = $(element);
            if (root.find('.create-reciprocal-link').is(':checked')) {
                var reciprocalRPCURL = $.trim(root.find('.reciprocal-rpc-url').val());
                if (reciprocalRPCURL == '') {
                    $("<div class='error applinks-error'>" + AppLinks.I18n.getText('applinks.error.url.field.empty') + "</div>").insertAfter(root.find('.reciprocal-rpc-url'))
                    if (errorFn) {
                        errorFn();
                    }
                    return;
                }
                var reciprocalLinkUsername = root.find('.reciprocal-link-username');
                var reciprocalLinkPwd = root.find('.reciprocal-link-password');
                if (reciprocalLinkUsername.val() == '') {
                    $('<div class="error applinks-error">'+ AppLinks.I18n.getText('applinks.error.username.empty') +'</div>').insertAfter(reciprocalLinkUsername);
                    if (errorFn) {
                        errorFn();
                    }
                    return false;
                }

                //verify user has admin rights.
                var successFn = function(data) {
                    root.find('.same-user-description').find('input').attr('checked', true);
                    root.find(".trust-radio-btn").attr('checked', true);
                    root.find('.same-user-radio-btn').click();
                    handleTwoWayLinkDetailsSuccess(data);
                };
                reciprocalRPCURL = AppLinks.UI.addProtocolToURL(reciprocalRPCURL);
                AppLinks.SPI.verifyTwoWayLinkDetails(appUrl, reciprocalRPCURL, reciprocalLinkUsername.val(), reciprocalLinkPwd.val(), successFn, AppLinks.UI.displayValidationError('two-way-link-errors', element, errorFn));
                return false;
            } else {
                handleOneWayLinkFn();
                return false;
            }
        },
        checkReciprocalLinkFormTwoStepMode : function(element, appUrl, successFn, errorFn) {
            var root = $(element);
            var reciprocalRPCURL = $.trim(root.find('.reciprocal-rpc-url').val());
            if (reciprocalRPCURL == '') {
                $("<div class='error applinks-error'>" + AppLinks.I18n.getText('applinks.error.url.field.empty') + "</div>").insertAfter(root.find('.reciprocal-rpc-url'))
                if (errorFn) {
                    errorFn();
                }
                return;
            }
            var reciprocalLinkUsername = root.find('.reciprocal-link-username');
            var reciprocalLinkPwd = root.find('.reciprocal-link-password');
            if (reciprocalLinkUsername.val() == '') {
                $('<div class="error applinks-error">'+ AppLinks.I18n.getText('applinks.error.username.empty') +'</div>').insertAfter(reciprocalLinkUsername);
                if (errorFn) {
                    errorFn();
                }
                return false;
            }

            reciprocalRPCURL = AppLinks.UI.addProtocolToURL(reciprocalRPCURL);
            AppLinks.SPI.verifyTwoWayLinkDetails(appUrl, reciprocalRPCURL, reciprocalLinkUsername.val(), reciprocalLinkPwd.val(), successFn, AppLinks.UI.displayValidationError('two-way-link-errors', element, errorFn));
            return false;
        }
    }
})(AJS.$);
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/common/urls.js' */
define('applinks/common/urls', [
    'applinks/lib/aui',
    'applinks/lib/lodash',
    'applinks/common/products'
], function(
    AJS,
    _,
    Products
) {
    /**
     * Utility functions for generating URLs in JS, including a link to applinks admin screen.
     */
    var ApplinksUrls = {

        /**
         * Generate a URL from the base and parameters.
         * @param baseUrl the baseUrl
         * @param parametersMap a map of parameters to add, in the form of { parameterName :  parameterValue }
         * @return {String}
         */
        generateUrl: function(baseUrl, parametersMap) {
            var redirectUrl = baseUrl;

            if(_.isUndefined(parametersMap)) {
                return redirectUrl;
            } else {
                _.each(parametersMap, function(value, key) {
                    if(redirectUrl.indexOf('?') < 0) {
                        redirectUrl = redirectUrl + '?';
                    } else {
                        redirectUrl = redirectUrl + '&';
                    }
                    redirectUrl = redirectUrl + key + "=" + encodeURIComponent(JSON.stringify(value))
                });

                return redirectUrl;
            }
        }
    };

    ApplinksUrls.Local = {

        admin: function(params) {
            var url = AJS.contextPath() + "/plugins/servlet/applinks/listApplicationLinks";
            return ApplinksUrls.generateUrl(url, params);
        }
    };

    ApplinksUrls.Remote = {

        /**
         * Generate a URL to remote Applinks Admin screen. For compatibility it needs to accept `applicationTypeId`.
         *
         * @param remoteBaseUrl
         * @param applicationTypeId
         * @param params extra URL params
         * @returns {String}
         */
        admin: function(remoteBaseUrl, applicationTypeId, params) {
            var suffix = applicationTypeId === Products.CONFLUENCE ?
                '/admin/listapplicationlinks.action' :
                '/plugins/servlet/applinks/listApplicationLinks';
            var url = remoteBaseUrl + suffix;

            return ApplinksUrls.generateUrl(url, params);
        }
    };

    return ApplinksUrls;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'js/help-link-analytics.js' */
(function ($) {
    $(function () {
        AJS.$('body').on('click', '.help-link', function () {
            AJS.trigger('analyticsEvent', {
                name: 'applinks.view.documentation',
                data: {linkKey: $(this).attr('data-help-link-key')}
            });
        });
    })
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-applinks-common-plugin:issue-link-applinks', location = 'js/issuelink-applinks.js' */
/**
 * Initialises anything requiring OAuth authentication. Requires the following elements:
 * <div class="issue-link-applinks-authentication-message"></div>
 */
var IssueLinkAppLinks = IssueLinkAppLinks || (function($) {
    function createHelper(servers, context, settings) {
        var helper = {};
        var selectedServer = null;

        function selectServer(appId) {
            selectedServer = getServer(servers, appId);

            var authenticationRequired = selectedServer && selectedServer.requireCredentials;
            doAuthenticationRequired(authenticationRequired, context);

            return {"authenticationRequired": authenticationRequired};
        }

        function setAuthenticationRequired(appId, authenticationRequired) {
            var server = getServer(servers, appId);
            if (server) {
                server.requireCredentials = authenticationRequired;

                // Refresh the authenication message if we have updated the selected server
                if (selectedServer && selectedServer.id === appId) {
                    doAuthenticationRequired(authenticationRequired, context);
                }
            }
        }

        function doAuthenticationRequired(required, context) {
            $(".issue-link-applinks-authentication-message", context).empty();
            if (required) {
                createAuthRequiredBanner($(".issue-link-applinks-authentication-message", context), context);
                $(".issue-link-oauth-toggle").hide();
                $(".buttons-container input[type=submit]", context).attr("disabled", "disabled");
            } else {
                $(".issue-link-oauth-toggle").show();
                $(".buttons-container input[type=submit]", context).removeAttr("disabled");
            }
        }

        function createAuthRequiredBanner($container, context) {
            var oauthCallbacks = {
                onSuccess: function () {
                    selectedServer.requireCredentials = false;
                    doAuthenticationRequired(false, context);
                    if (settings.onAuthenticationSuccessCallback) {
                        settings.onAuthenticationSuccessCallback(context, selectedServer.id, helper);
                    }
                },
                onFailure: function () {
                    if (settings.onAuthenticationFailedCallback) {
                        settings.onAuthenticationFailedCallback(context, selectedServer.id, helper);
                    }
                }
            };

            var encodedServerName = AJS.escapeHtml(selectedServer.name);
            if (selectedServer.authUrl) {
                var $banner = $('<div class="aui-message warning closeable shadowed applinks-auth-request"><p><span class="aui-icon icon-applinks-key"></span></p></div>');
                $banner.append(AJS.format("Authorization required to create issue link. Please \u003ca href=\"{0}\" class=\"applink-authenticate\"\u003eauthenticate\u003c/a\u003e with \u003ca href=\"{1}\"\u003e{2}\u003c/a\u003e.", selectedServer.authUrl, selectedServer.url, encodedServerName));
                $("a", $banner).addClass("applink-authenticate");
                $('.applink-authenticate', $banner).click(function (e) {
                    authenticateRemoteCredentials(selectedServer.authUrl, oauthCallbacks.onSuccess, oauthCallbacks.onFailure);
                    e.preventDefault();
                });
                $container.append($banner);
            } else {
                var warningMessage = AJS.format("Unable to create a link to \u003ca href=\"{0}\"\u003e{1}\u003c/a\u003e as the application does not have any authentication configured.", selectedServer.url, encodedServerName);
                AJS.messages.warning($container, {body: warningMessage});
            }
        }

        function createOAuthCallback() {
            if (!AppLinks.OAuthCallback && typeof(oauthCallback) === "undefined") {
                AppLinks.OAuthCallback = function() {

                };

                AppLinks.OAuthCallback.prototype.success = function() {
                    this.aouthWindow.close();
                    this.onSuccess();
                    delete oauthCallback;
                    delete AppLinks.OAuthCallback;
                };

                AppLinks.OAuthCallback.prototype.failure = function() {
                    this.aouthWindow.close();
                    this.onFailure();
                    delete oauthCallback;
                    delete AppLinks.OAuthCallback;
                };

                AppLinks.OAuthCallback.prototype.show = function(url, onSuccess, onFailure) {
                    this.onSuccess = onSuccess;
                    this.onFailure = onFailure;
                    this.aouthWindow = window.open(url, "com_atlassian_applinks_authentication");
                };
                // set the global oAuthCallback variable required by AppLinks
                oauthCallback = new AppLinks.OAuthCallback();
            }
        }

        function authenticateRemoteCredentials(url, onSuccess, onFailure) {
            createOAuthCallback();

            $('.applinks-error').remove();
            oauthCallback.show(url, onSuccess, onFailure);
        }

        return $.extend(helper, {
            selectServer: selectServer,
            setAuthenticationRequired: setAuthenticationRequired
        });
    }

    function getServer(servers, appId) {
        var i;
        if (servers.length) {
            for (i = 0; i < servers.length; i++) {
                if (servers[i].id === appId) {
                    return servers[i];
                }
            }
        }
        return null;
    }

    /**
     * Called only once during the initialisation to retrieve the list of servers.
     *
     * @param context the context to perform the initialisation. This is either the inline dialog or the entire document
     *                body.
     */
    function initApplinkServers(settings, context, deferred) {
        var currentAppId = settings.getCurrentAppId(context);
        var applicationType = $(".issue-link-applinks-application-type", context).val();
        var issueId = settings.getIssueId(context);
        $.get(AJS.contextPath() + '/rest/issueLinkAppLink/1/appLink/info', { type: applicationType, issueIdOrKey: issueId }, function (servers) {
            var helper = createHelper(servers, context, settings);
            var currentRequiresCredentials;
            if (servers && servers.length) {
                var currentServer = getServer(servers, currentAppId);
                if (currentServer) {
                    currentRequiresCredentials = $(".issue-link-applinks-authentication-message", context).hasClass("required");
                    if (currentRequiresCredentials) {
                        currentServer.requireCredentials = true;
                    }
                    helper.selectServer(currentAppId);
                }
                deferred.resolve(context, helper);
            } else {
                deferred.reject(context);
            }
        });
    }

    /**
     * @return jQuery.Promise<String>
     */
    function init(settings, context) {
        var deferred = $.Deferred();

        var isIssueLinkAppLinkContent = $(".issue-link-applinks-authentication-message", context).length !== 0;
        if (isIssueLinkAppLinkContent && settings.shouldExecute(context)) {
            initApplinkServers(settings, context, deferred);
        }

        return deferred.promise();
    }

    return {
        init: init
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-remote-jira-js', location = 'js/issuelink-jira.js' */
/**
 * Initialises OAuth authentication for JIRA Application Links. Requires the following elements:
 * <div class="issue-link-applinks-authentication-message"></div>
 */
(function ($) {

    var settings = {
        getCurrentAppId: function (context) {
            return $("#jira-app-link", context).val();
        },
        shouldExecute: function (context) {
            return $("#jira-app-link", context).length !== 0;
        },
        getIssueId: function (context) {
            return $("input[name=id]", context).val();
        }
    };

    var updateIssuePicker = function($select, appId) {
        if ($select.length) {
            // Update the appId param
            $select.attr("data-ajax-options.data.app-id", appId);
            if (appId && appId !== "") {
                // Set the url for remote JIRA queries
                $select.attr("data-ajax-options.url", contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/picker");
            }
            else {
                // Set the url for local JIRA queries
                $select.attr("data-ajax-options.url", contextPath + "/rest/api/2/issue/picker");
            }

            $select.trigger("updateOptions");

            // Now that we have changed server, our current issue selection is no longer relevant
            $select.trigger("clearSelection");
        }
    };

    var updateCreateReciprocalCheckbox = function(appId, context) {
        var $reciprocalCheckbox = $("#create-reciprocal", context);
        if ($reciprocalCheckbox.length) {
            if (appId && appId !== "") {
                // Get default choice for creating a remote reciprocal link
                var defaultChoice = ($("#create-reciprocal-default", context).val() == "true");
                if (defaultChoice) {
                    $reciprocalCheckbox.attr("checked", "checked");
                } else {
                    $reciprocalCheckbox.removeAttr("checked");
                }
                $reciprocalCheckbox.removeAttr("disabled");
                $("#create-reciprocal-fieldset", context).removeClass("disabled");
            } else {
                // Set to checked for local links, as they always create a reciprocal link
                $reciprocalCheckbox.attr("checked", "checked");
                $reciprocalCheckbox.attr("disabled", "disabled");
                $("#create-reciprocal-fieldset", context).addClass("disabled");
            }
        }
    };

    JIRA.bind(JIRA.Events.NEW_PAGE_ADDED, function (e, context) {

        var $select = $("#jira-issue-keys", context);
        if ($select.length) {
            var appId = $("#jira-app-link", context).val();
            updateIssuePicker($select, appId);
            updateCreateReciprocalCheckbox(appId, context);
        }

        IssueLinkAppLinks.init(settings, context).done(function (context, helper) {
            $("#jira-app-link", context).change(function () {
                var appId = $(this).val();
                helper.selectServer(appId);
                updateIssuePicker($select, appId);
                updateCreateReciprocalCheckbox(appId, context);
            });
        });
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-jira-search-js', location = 'js/issuelink-jira-jqlautocomplete.js' */
/**
 * Instantiates jql autocomplete functionality on request instead of on page load.
 */
var IssueLinkJQLAutoComplete = IssueLinkJQLAutoComplete || (function($) {

    /**
     * Initializes an auto complete field
     */
    function initialize(options) {

        var fieldID = options.fieldID;
        var errorID = options.errorID;
        var autoCompleteUrl = options.autoCompleteUrl;
        var autoCompleteData = options.autoCompleteData;
        var formSubmitFunction = options.formSubmitFunction;

        var $field = $('#'+fieldID);
        var hasFocus = $field.length > 0 && $field[0] == document.activeElement;

        var jqlFieldNames = autoCompleteData.visibleFieldNames || [];
        var jqlFunctionNames = autoCompleteData.visibleFunctionNames || [];
        var jqlReservedWords = autoCompleteData.jqlReservedWords || [];

        var jqlAutoComplete = JIRA.JQLAutoComplete({
            fieldID: fieldID,
            parser: JIRA.JQLAutoComplete.MyParser(jqlReservedWords),
            queryDelay: .65,
            jqlFieldNames: jqlFieldNames,
            jqlFunctionNames: jqlFunctionNames,
            minQueryLength: 0,
            allowArrowCarousel: true,
            autoSelectFirst: false,
            errorID: errorID,
            autoCompleteUrl: autoCompleteUrl
        });

        $field.unbind("keypress", submitOnEnter);

        if (formSubmitFunction) {
            $field.keypress(function (e) {
                if (jqlAutoComplete.dropdownController === null || !jqlAutoComplete.dropdownController.displayed || jqlAutoComplete.selectedIndex < 0) {
                    if (e.keyCode === 13 && !e.ctrlKey && ! e.shiftKey)
                    {
                        formSubmitFunction();
                        return false;
                    }
                    else
                    {
                        return true;
                    }
                }
            });
        }

        jqlAutoComplete.buildResponseContainer();
        jqlAutoComplete.parse($field.text());
        jqlAutoComplete.updateColumnLineCount();

        $field.click(function(){
            jqlAutoComplete.dropdownController.hideDropdown();
        });

        if (hasFocus) {
            $field.select();
        }
    }

    return {
        initialize: initialize
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-jira-search-js', location = 'js/issuelink-jira-search.js' */
AJS.$(function ($) {
    var remoteJiraSearchDialog =  new JIRA.FormDialog({
        id: "remote-jira-search-dialog",
        trigger: "#link-jira-issue .remote-jira-search-trigger",
        widthClass: "large",
        content: function (render) {
            render(JIRA.Templates.RemoteJiraIssueSearch.dialog());
            initSearchDialog(this.$popup);
        },
        submitHandler: function(e, callback){
            e.preventDefault();
            $("#simple-search-panel-button").removeAttr("disabled");
            $("#advanced-search-panel-button").removeAttr("disabled");
            if($(e.target).attr("id") === "remote-jira-simple-search-form"){
                $("#simple-search-panel-button").click();
            } else {
                $("#advanced-search-panel-button").click();
            }
            callback();
        }
    });

    function initSearchDialog($dialog) {
        // Gather the JQL auto complete data
        var appId = $("#jira-app-link").val();
        var autoCompletePromise = getJqlAutoCompleteData(appId);

        // Bind the simple search button
        $("#simple-search-panel-button", $dialog).click(function () {
            $("#search-results-table", $dialog).empty();
            var searchText = $("#link-search-text", $dialog).val();
            searchText = $.trim(searchText);
            if (searchText) {
                doSimpleSearch(searchText, $dialog);
            } else {
                AJS.messages.info("#search-results-table", {
                    body: "Please enter search value.",
                    closeable: false
                });
            }

            return false;
        });

        // Bind the advanced search button
        $("#advanced-search-panel-button", $dialog).click(function() {
            advancedSearchButtonClick($dialog);
            return false;
        });

        $("#simple-search-toggle", $dialog).click(function() {
            $("#remote-jira-simple-search-form", $dialog).show();
            $("#remote-jira-advanced-search-form", $dialog).hide();
            return false;
        });

        $("#linkjiraissue-add-selected", $dialog).click(function(){
            //select selected checkboxes of only *visible* rows
            //filtering to visible is necessary due to tabbed layout
            $("table tbody tr:visible  td.selection input:checked", $dialog).each(function(){
                var issueKey = $(this).parent().data("key");
                $("#jira-issue-keys").trigger("selectOption", [{
                    value: issueKey
                }]);
            });


            // Clear all error messages on the parent dialog, as we now have a newly selected issue
            $("#link-issue-dialog .error").hide();

            remoteJiraSearchDialog.hide();

            $("#link-issue-dialog")
                    .show()
                    .trigger("multiSelectRevealed");

            $("#jira-issue-keys-textarea").focus().select();
        });


        $("#advanced-search-toggle", $dialog).click(function() {
            $("#remote-jira-advanced-search-form", $dialog).show();
            $("#remote-jira-simple-search-form", $dialog).hide();

            // Initialise the JQL auto complete once we have the data
            // Ensure that we only initialise it once only
            var $jqlSearchText = $("#jql-search-text");
            if (!$jqlSearchText.attr("jql-initialized")) {
                setAutoCompleteLoadingIconVisible(true, $dialog);
                WRM.require("wr!jira.webresources:jqlautocomplete", function(){
                    autoCompletePromise.done(function (smartAjaxResult) {
                        if (smartAjaxResult.successful) {
                            // Enable JQL AutoComplete
                            IssueLinkJQLAutoComplete.initialize({
                                fieldID: "jql-search-text",
                                errorID: "jql-search-error",
                                autoCompleteUrl: getAutoCompleteUrl(appId),
                                autoCompleteData: smartAjaxResult.data,
                                formSubmitFunction: function() {
                                    advancedSearchButtonClick($dialog);
                                }
                            });
                        }
                        else {
                            setJQLErrorVisible(false, $dialog);
                            setAutoCompleteFailedIconVisible(true, $dialog);
                        }
                        setAutoCompleteLoadingIconVisible(false, $dialog);
                        $jqlSearchText.attr("jql-initialized", 1);
                    });
                });

            }
            $jqlSearchText.focus();

            return false;
        });

        $("#simple-search-toggle", $dialog).trigger("click");
    }

    function getAutoCompleteUrl(appId) {
        if (appId && appId !== "") {
            // Remote JIRA instance
            return contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/autocomplete?appId=" + appId;
        }
        // Local JIRA instance - will use the default URL in JQLAutoComplete
        return "";
    }

    function advancedSearchButtonClick($dialog) {
        $("#search-results-table", $dialog).empty();
        var searchText = $("#jql-search-text", $dialog).val();
        searchText = $.trim(searchText);
        if (searchText) {
            doAdvancedSearch(searchText, $dialog);
        } else {
            AJS.messages.info("#search-results-table", {
                body: "Please enter search value.",
                closeable: false
            });
        }
    }

    function setLoadingIconVisible(visible, $context) {
        $("#link-search-loading", $context).toggleClass("hidden", !visible);
    }

    function setAutoCompleteLoadingIconVisible(visible, $context) {
        $("#autocomplete-loading", $context).toggleClass("hidden", !visible);
    }

    function setAutoCompleteFailedIconVisible(visible, $context) {
        $("#autocomplete-failed", $context).toggleClass("hidden", !visible);
    }

    function setJQLErrorVisible(visible, $context) {
        $("#jql-search-error", $context).toggleClass("hidden", !visible);
    }

    function doSimpleSearch(searchText, $context) {
        setLoadingIconVisible(true, $context);
        var appId = $("#jira-app-link").val();
        var issueKeyJql = 'key = "' + searchText + '"';
        var projectJql = 'project = "' + searchText + '"';
        var plainTextJql = 'summary ~ "' + searchText + '" OR description ~ "' + searchText + '" OR comment ~ "' + searchText + '"';

        // First, check if search text is an issue key
        // We need to do this because the search will fail if it is not an issue key,
        // even if it is OR'd with a condition that returns results!
        jqlSearch(issueKeyJql, appId).done(function (smartAjaxResult) {
            if (smartAjaxResult.successful && smartAjaxResult.data.issues.length > 0) {
                setLoadingIconVisible(false, $context);
                showResults(smartAjaxResult, $context);
            } else {

                // Then check if search text is a project
                jqlSearch(projectJql, appId).done(function (smartAjaxResult) {
                    if (smartAjaxResult.successful && smartAjaxResult.data.issues.length > 0) {
                        // The search text is a project name or key
                        setLoadingIconVisible(false, $context);
                        showResults(smartAjaxResult, $context);
                    } else {

                        // Finally, a plain text search
                        jqlSearch(plainTextJql, appId).done(function (smartAjaxResult) {
                            setLoadingIconVisible(false, $context);
                            if (smartAjaxResult.successful) {
                                showResults(smartAjaxResult, $context);
                            } else {
                                showResultsError(smartAjaxResult);
                            }
                        });
                    }
                });
            }
        });
    }

    function doAdvancedSearch(jql, $context) {
        setLoadingIconVisible(true, $context);
        var appId = $("#jira-app-link").val();
        jqlSearch(jql, appId).done(function (smartAjaxResult) {
            setLoadingIconVisible(false, $context);
            if (smartAjaxResult.successful) {
                showResults(smartAjaxResult, $context);
            } else {
                if (smartAjaxResult.status === 400) {
                    AJS.messages.warning("#search-results-table", {
                        body: "Invalid JQL query.",
                        closeable: false
                    });
                } else {
                    showResultsError(smartAjaxResult);
                }
            }
        });
    }

    function jqlSearch(jql, appId) {
        var deferred = $.Deferred();
        var url;
        if (appId && appId !== "") {
            // Remote JIRA instance
            url = contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/search?jql=" + jql + "&appId=" + appId + "&maxResults=10";
        } else {
            // Local JIRA instance
            // Filter out current issue from results
            var currentIssueKey = $("#current-issue-key").val();
            jql = "(" + jql + ") and key != " + currentIssueKey;
            url = contextPath + "/rest/api/2/search?jql=" + jql + "&maxResults=10";
        }
        JIRA.SmartAjax.makeRequest({
            url: url,
            complete: function (xhr, textStatus, smartAjaxResult) {
                deferred.resolve(smartAjaxResult);
            }
        });
        return deferred.promise();
    }

    function getJqlAutoCompleteData(appId) {
        var deferred = $.Deferred();
        var remote;
        var url;
        if (appId && appId !== "") {
            // Remote JIRA instance
            url = contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/autocompletedata?appId=" + appId;
            remote = true;
        } else {
            // Local JIRA instance
            url = contextPath + "/rest/api/2/jql/autocompletedata";
            remote = false;
        }
        JIRA.SmartAjax.makeRequest({
            url: url,
            complete: function (xhr, textStatus, smartAjaxResult) {
                if (!smartAjaxResult.successful && remote) {
                    // If a remote JIRA request fails, it probably doesn't have the autocompletedata REST endpoint (added in JIRA v5.1)
                    // Get the auto complete data by parsing the issue navigator page
                    JIRA.SmartAjax.makeRequest({
                        url: contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/autocompletedata/legacy?appId=" + appId,
                        complete: function (xhr, textStatus, smartAjaxResult) {
                            deferred.resolve(smartAjaxResult);
                        }
                    });
                } else {
                    deferred.resolve(smartAjaxResult);
                }
            }
        });
        return deferred.promise();
    }

    function showResults(smartAjaxResult, $context) {
        var resultHtml = JIRA.Templates.RemoteJiraIssueSearch.resultsTable({result: smartAjaxResult.data});
        $("#search-results-table", $context).html(resultHtml);

        $("#linkjiraissue-select-all", $context).click(function(){
            var $masterStatus = $(this).prop("checked");
            $("tbody tr td.selection input", $context).prop("checked", $masterStatus);
        });

        $("tbody tr", $context).click(function (e) {

            //if we click on checkbox directly we don't want to change its value
            if($(e.target).is(":checkbox")){
                return;
            }
            var checkbox = $(this).find("td.selection input");
            checkbox.prop("checked", !checkbox.prop("checked"));


        });
    }

    function showResultsError(smartAjaxResult) {
        AJS.messages.error("#search-results-table", {
            body: JIRA.SmartAjax.buildSimpleErrorContent(smartAjaxResult),
            closeable: false
        });
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-jira-search-js', location = 'templates/dialog/linkjiraissue-search.soy' */
// This file was automatically generated from linkjiraissue-search.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.RemoteJiraIssueSearch.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.RemoteJiraIssueSearch == 'undefined') { JIRA.Templates.RemoteJiraIssueSearch = {}; }


JIRA.Templates.RemoteJiraIssueSearch.dialog = function(opt_data, opt_ignored) {
  return '<h2>' + soy.$$escapeHtml("Find JIRA issues") + '</h2><form class="aui search-form" id="remote-jira-simple-search-form" action="#" method="post"><div class="field-group"><label for="link-search-text">' + soy.$$escapeHtml("Search") + ':</label><input id="link-search-text" type="text" tabindex="0" class="text" size="50"> <input type="submit" tabindex="0" class="button" id="simple-search-panel-button" value="' + soy.$$escapeHtml("Search") + '"> <a id="advanced-search-toggle" href="#" title="' + soy.$$escapeHtml("Perform a JQL search") + '">' + soy.$$escapeHtml("Advanced Search") + '</a><span id="link-search-loading" class="icon loading throbber hidden"/></div></form><form class="aui search-form" id="remote-jira-advanced-search-form" action="#" method="post"><div class="field-group"><label for="jql-search-text">' + soy.$$escapeHtml("JQL Search") + '<span id="autocomplete-loading" class="hidden"><span class="icon loading throbber"/>' + soy.$$escapeHtml("Loading auto-complete") + '</span><span id="autocomplete-failed" class="hidden">' + soy.$$escapeHtml("(auto-complete unavailable)") + '</span></label><div id="jql-search-container"><span id="jql-search-error" class="icon jqlgood" /><div class="atlassian-autocomplete"><textarea id="jql-search-text" class="text full-width-field" tabindex="0" /></div></div><button class="aui-button aui-button-subtle search-button" id="advanced-search-panel-button" type="submit"><span class="aui-icon aui-icon-small aui-iconfont-search" title="' + soy.$$escapeHtml("Search") + '"></span></button> <a id="simple-search-toggle" href="#" title="' + soy.$$escapeHtml("Perform a plain text search") + '">' + soy.$$escapeHtml("Simple Search") + '</a><span id="link-search-loading" class="icon loading throbber hidden"/></div></form><div class="message-panel hidden"></div><div id="search-results-table" class="data-table"></div><div class="buttons-container form-footer"><div class="buttons"><button type="button" class="aui-button" id="linkjiraissue-add-selected">' + soy.$$escapeHtml("Add") + '</button><button class="aui-button aui-button-link cancel" href="#" id="remote-jira-link-cancel" title="' + soy.$$escapeHtml("Press Esc to close") + '">' + soy.$$escapeHtml("Close") + '</button></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.dialog.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.dialog';
}


JIRA.Templates.RemoteJiraIssueSearch.resultsTable = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.result.issues.length > 0) {
    output += '<table id="remote-jira-searchresult" class="aui"><thead><tr><th class="selection" ><input id="linkjiraissue-select-all" type="checkbox"/></th><th class="type">' + soy.$$escapeHtml("Type") + '</th><th class="key">' + soy.$$escapeHtml("Key") + '</th><th class="summary">' + soy.$$escapeHtml("Summary") + '</th><th class="status">' + soy.$$escapeHtml("Status") + '</th></tr></thead><tbody>';
    var issueList44 = opt_data.result.issues;
    var issueListLen44 = issueList44.length;
    for (var issueIndex44 = 0; issueIndex44 < issueListLen44; issueIndex44++) {
      var issueData44 = issueList44[issueIndex44];
      output += '<tr title="' + soy.$$escapeHtml(issueData44.key) + '"><td class="selection" data-key="' + soy.$$escapeHtml(issueData44.key) + '"><input type="checkbox"/></td><td class="type">' + JIRA.Templates.RemoteJiraIssueSearch.issueType({issueType: issueData44.fields.issuetype}) + '</td><td class="key" title="' + soy.$$escapeHtml(issueData44.key) + '">' + soy.$$escapeHtml(issueData44.key) + '</td><td class="summary" title="' + soy.$$escapeHtml(issueData44.fields.summary) + '">' + soy.$$escapeHtml(issueData44.fields.summary) + '</td><td class="status">' + JIRA.Templates.RemoteJiraIssueSearch.status({status: issueData44.fields.status}) + '</td></tr>';
    }
    output += '</tbody></table>';
  } else {
    output += '<div class="aui-message info"><span class="aui-icon icon-info"></span><p>' + soy.$$escapeHtml("Search returned no results.") + '</p></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.resultsTable.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.resultsTable';
}


JIRA.Templates.RemoteJiraIssueSearch.issueType = function(opt_data, opt_ignored) {
  return '<img src="' + soy.$$escapeHtml(opt_data.issueType.iconUrl) + '" alt="' + soy.$$escapeHtml(opt_data.issueType.name) + '" title="' + soy.$$escapeHtml(opt_data.issueType.name) + ' - ' + soy.$$escapeHtml(opt_data.issueType.description) + '"/>';
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.issueType.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.issueType';
}


JIRA.Templates.RemoteJiraIssueSearch.status = function(opt_data, opt_ignored) {
  return '' + JIRA.Template.Util.Issue.Status.issueStatusResolver({issueStatus: opt_data.status});
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.status.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.status';
}
;
;
/* module-key = 'jira.webresources:jira-analytics', location = '/includes/jira/analytics/analytics.js' */
/**
 * Capture analytics events in the JIRA general context.
 */
AJS.toInit(function($) {
    /**
     * Returns the currently selected tab on the Browse Project page
     */
    function getBrowseProjectTab() {
        return $("li.active a.browse-tab").attr("id");
    }

    // Need to defer for debugging support (see analytics-debug.js).
    _.defer(function() {
        if (AJS.EventQueue) {
            // Capture clicks on 'Administer Project' button on Browse Project page
            $(document).delegate("#project-admin-link", "click", function() {
                var selectedTab = getBrowseProjectTab();
                AJS.EventQueue.push({
                    name: "browseproject.administerproject",
                    properties: {
                        selectedtab: selectedTab
                    }
                });
            });

            // Capture clicks on 'Create New Project' button on Browse Projects page
            $(document).delegate("#browse-projects-create-project", "click", function() {
                AJS.EventQueue.push({
                    name: "browseprojects.createproject",
                    properties: {}
                });
            });

            // Capture clicks on the 'create an issue' link on the Issues tab when no issues exist in the project
            $(document).delegate("#no-issues-create-issue", "click", function() {
                AJS.EventQueue.push({
                    name: "browseproject.issuesblankslate.createissue",
                    properties: {}
                });
            });

            // Capture clicks on the issue filter links on the Issues tab
            $(document).delegate("a.issue-filter-link", "click", function() {
                var $el = $(this);
                var id = $el.attr("id").replace("filter_", "");
                var type = $el.attr("data-type");
                AJS.EventQueue.push({
                    name: "browse" + type + ".issuefilter." + id,
                    properties: {}
                });
            });

            $(document).on("click", "#project_import_link_lnk", function() {
                AJS.EventQueue.push({
                    name: "topnav.jim",
                    properties: {}
                });
            });

            $(document).on("click", ".issueaction-viewworkflow", function() {
                var classes = $(this).attr("class");
                var isNew = classes.indexOf("new-workflow-designer") > -1 || classes.indexOf("jira-workflow-designer-link") > -1;
                var version = isNew ? "new" : "old";

                var newEnabled = AJS.DarkFeatures.isEnabled("casper.VIEW_ISSUE");

                AJS.EventQueue.push({
                    name: "issue.viewworkflow",
                    properties: {
                        version: version,
                        newEnabled: newEnabled
                    }
                });
            });
        } // if (AJS.EventQueue)
    });
});
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/jquery/plugins/avataror/avataror.js' */

jQuery.fn.avataror = function (options) {
    var $ = jQuery,
        $document = $(document);
    this.each(function () {
        var $this = $(this);

        var imgsrc = $this.find("img").attr("src");
        $this.css({"-moz-border-radius": "10px", "-webkit-border-radius": "10px"});
        $this.html("<p>Loading?</p>");
        var avataror = {previewSize: 48};
        avataror.preview = $("<div/>").addClass("avataror-preview").css({border: "solid 1px #000", "float": "left", height: avataror.previewSize +"px", overflow: "hidden", width: avataror.previewSize +"px", position: "relative", top: "-9999em", left: "-9999em"});
        avataror.preview.prependTo(options.previewElement);
        avataror.img = $('<img src="' + imgsrc + '" alt="Avatar Source"/>');
        avataror.img.load(function () {
            avataror.image = $("<div/>").css({background: "url('" + imgsrc + "') no-repeat", clear: "left", position: "relative"});
            avataror.marker = $("<div/>").css({cursor: "move", position: "relative" });
            avataror.dash = $("<div/>");
            avataror.shadow = $("<div/>");
            avataror.dash.add(avataror.shadow).css({cursor: "move", opacity: .5, left: 0, top: 0, position: "absolute"});
            avataror.image.append(avataror.shadow).append(avataror.dash).append(avataror.marker);
            $this.append(avataror.image);
            avataror.marker.html('<div></div><div></div><div></div><div></div>');
            $("div", avataror.marker).each(function (i) {
                var $this = $(this);
                $this.css({background: "#000", border: "solid 1px #fff", width: "10px", height: "10px", position: "absolute", "font-size": "1px"});
                $this.css(["left", "right", "right", "left"][i], "-6px");
                $this.css(["top", "top", "bottom", "bottom"][i], "-6px");
                $this.css("cursor", ["nw-resize", "ne-resize", "se-resize", "sw-resize"][i]);
                $this.mousedown(function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    avataror.dragging = {x: e.pageX, y: e.pageY, ax: avataror.x, ay: avataror.y, w: avataror.width, h: avataror.height, i: i + 1};
                    avataror.shadow.hide();
                });
            });
            avataror.marker.add(avataror.image).mousedown(function (e) {
                e.preventDefault();
                avataror.dragging = {
                    x: e.pageX,
                    y: e.pageY,
                    ax: avataror.x,
                    ay: avataror.y,
                    w: avataror.width,
                    h: avataror.height};
                avataror.shadow.hide();
            });

            $document.mouseup(function (e) {
                avataror.handleMouseUp(e);
            });
            $document.mousemove(function (e) {
                if (avataror.dragging) {
                    avataror.handleMouseMove(e.pageX, e.pageY);
                    e.preventDefault();
                }
            });


            avataror.imgwidth = avataror.img.width();
            avataror.imgheight = avataror.img.height();
            avataror.x = parseInt($("#avatar-offsetX").val());
            avataror.y = parseInt($("#avatar-offsetY").val());
            avataror.width = parseInt($("#avatar-width").val());
            avataror.height = avataror.width;
            avataror.image.css({width: avataror.imgwidth + "px", height: avataror.imgheight + "px"});
            avataror.setMarker();

            $this.css({width: avataror.imgwidth + "px"});
            avataror.preview.css({position: "static"});
            $("p", $this).remove();
            $this.trigger("AvatarImageLoaded");
        });
        avataror.preview.append(avataror.img);

        avataror.setMarker = function () {
            avataror.marker.css("border", "dashed 1px #fff");
            avataror.dash.css("border", "solid 1px #000");
            avataror.shadow.css("border", "solid 1px #000");
            avataror.marker.add(this.dash).css("left", this.x - 1 + "px");
            avataror.marker.add(avataror.dash).css("top", avataror.y - 1 + "px");
            avataror.shadow.css("border-left-width", avataror.x + "px");
            avataror.shadow.css("border-right-width", avataror.imgwidth - avataror.x - avataror.width + "px");
            avataror.shadow.css("border-top-width", avataror.y + "px");
            avataror.shadow.css("border-bottom-width", avataror.imgheight - avataror.y - avataror.height + "px");
            avataror.shadow.css("width", avataror.width + "px");
            avataror.shadow.css("height", avataror.height + "px");
            avataror.marker.add(avataror.dash).css("width", avataror.width + "px");
            avataror.marker.add(avataror.dash).css("height", avataror.height + "px");
        };

        avataror.adjustPreview = function() {
            avataror.img.attr("width", avataror.imgwidth * avataror.previewSize / avataror.width);
            avataror.img.attr("height", avataror.imgheight * avataror.previewSize / avataror.height);
            avataror.img.css("margin-left", "-" + avataror.x * avataror.previewSize / avataror.width + "px");
            avataror.img.css("margin-top", "-" + avataror.y * avataror.previewSize / avataror.height + "px");
            avataror.preview.select();
        };

        avataror.handleMouseMove = function(newX, newY) {
            avataror.dragging.nextExec = avataror.dragging.nextExec || 0;
            if (avataror.dragging.nextExec == 0) {
                avataror.dragging.nextExec = 3;
            } else {
                avataror.dragging.nextExec--;
                return;
            }
            var dx = newX - avataror.dragging.x;
            var dy = newY - avataror.dragging.y;
            if (this.dragging.i) {
                var handler = avataror.resizeHandlers[this.dragging.i-1];
                handler(dx,dy);
            } else {
                avataror.x = avataror.dragging.ax + dx;
                avataror.y = avataror.dragging.ay + dy;
                if (avataror.x + avataror.width > avataror.imgwidth) {
                    avataror.x = avataror.imgwidth - avataror.width;
                }
                if (avataror.y + avataror.height > avataror.imgheight) {
                    avataror.y = avataror.imgheight - avataror.height;
                }
                if (avataror.x < 0) {
                    avataror.x = 0;
                }
                if (avataror.y < 0) {
                    avataror.y = 0;
                }
            }
            avataror.setMarker();
            avataror.adjustPreview();
        };

        avataror.handleMouseUp = function(e) {
//            avataror.adjustPreview();
            $("#avatar-offsetX").val(avataror.x);
            $("#avatar-offsetY").val(avataror.y);
            $("#avatar-width").val(avataror.width);
            avataror.dragging = null;
            avataror.shadow.show();
        };

        avataror.originX = function() {
            return avataror.dragging.ax;
        };
        avataror.originY = function() {
            return avataror.dragging.ay;
        };
        avataror.originBottomX = function() {
            return avataror.dragging.ax + avataror.dragging.w;
        };
        avataror.originBottomY = function() {
            return avataror.dragging.ay + avataror.dragging.h;
        };

        avataror.originNw = function() {
            return {x: avataror.originX(), y: avataror.originY()};
        };
        avataror.originNe = function() {
            return {x: avataror.originBottomX(), y: avataror.originY()};
        };
        avataror.originSe = function() {
            return {x: avataror.originBottomX(), y: avataror.originBottomY()};
        };
        avataror.originSw = function() {
            return {x: avataror.originX(), y: avataror.originBottomY()};
        };

        avataror.nwHandler = function(dx, dy) {
            var anchor = avataror.originSe();
            var tmpBase = {x: avataror.originX() + dx, y: avataror.originY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);
            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x - newSize < 0) {
                newSize = anchor.x;
            }
            if (anchor.y - newSize < 0) {
                newSize = anchor.y;
            }
            avataror.x = anchor.x - newSize;
            avataror.y = anchor.y - newSize;
            avataror.width = avataror.height = newSize;
        };

        avataror.neHandler = function(dx, dy) {
            var anchor = avataror.originSw();
            var tmpBase = {x: avataror.originBottomX() + dx, y: avataror.originY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);

            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x + newSize > avataror.imgwidth) {
                newSize = avataror.imgwidth - anchor.x;
            }
            if (anchor.y - newSize < 0) {
                newSize = anchor.y;
            }

            avataror.y = anchor.y - newSize;
            avataror.width = avataror.height = newSize;
        };

        avataror.seHandler = function(dx, dy) {
            var anchor = avataror.originNw();
            var tmpBase = {x: avataror.originBottomX() + dx, y: avataror.originBottomY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);

            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x + newSize > avataror.imgwidth) {
                newSize = avataror.imgwidth - anchor.x;
            }
            if (anchor.y + newSize > avataror.imgheight) {
                newSize = avataror.imgheight - anchor.y;
            }
            avataror.width = avataror.height = newSize;
        };

        avataror.swHandler = function(dx, dy) {
            var anchor = avataror.originNe();
            var tmpBase = {x: avataror.originX() + dx, y: avataror.originBottomY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);

            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x - newSize < 0) {
                newSize = anchor.x;
            }
            if (anchor.y + newSize > avataror.imgheight) {
                newSize = avataror.imgheight - anchor.y;
            }
            avataror.x = anchor.x - newSize;
            avataror.width = avataror.height = newSize;
        };

        avataror.resizeHandlers = [avataror.nwHandler, avataror.neHandler, avataror.seHandler, avataror.swHandler];

        // implementation
    });
};
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/Avatar.js' */
/**
 * Represents an icon for a project or some other entity in JIRA.
 *
 * @Class JIRA.Avatar
 *
 */
JIRA.Avatar = Class.extend({

    /**
     * @constructor
     * @param {object} options
     * @param {Number} options.id
     * @param {Boolean} options.isSystemAvatar
     * @param {object} [options.urls] an optional hash of avatar URLs
     */
    init: function (options) {
        this._id = options.id;
        this._isSystemAvatar = options.isSystemAvatar;
        this._isSelected = options.isSelected;
        this._urls = options.urls;
    },

    /**
     * Sets as unselected
     */
    setUnSelected: function () {
        this._isSelected = false;
    },

    /**
     * Sets as selected
     */
    setSelected: function () {
        this._isSelected = true;
    },

    /**
     * Gets selected state
     */
    isSelected: function () {
        return !!this._isSelected;
    },

    /**
     * Indicates whether the Avatar is a system-provided one or if users have defined it.
     *
     * @return {Boolean} true only if the Avatar is a system-provided one.
     */
    isSystemAvatar: function () {
        return this._isSystemAvatar;
    },

    /**
     * The database identifier for the Avatar, may be null if it hasn't yet been stored.
     *
     * @return the database id or null.
     */
    getId: function () {
        return this._id;
    },

    /**
     * Returns the URL of this avatar in the given size.
     *
     * @param {string} size an avatar size
     * @return {string} the avatar URL
     */
    getUrl: function(size) {
        return this._urls[size];
    },

    /**
     * Serilaizes the object into a JSON object
     *
     * @return {Object}
     */
    toJSON: function () {
        return {
            id: this._id,
            isSystemAvatar: this._isSystemAvatar,
            isSelected: this._isSelected,
            urls: this._urls
        };
    }
});


// Factories

/**
 * Creates custom avatar
 *
 * @param descriptor
 * ... {String} id
 */
JIRA.Avatar.createCustomAvatar = function (descriptor) {
    descriptor.isSystemAvatar = false;
    return new JIRA.Avatar(descriptor);
};

/**
 * Creates system avatar
 *
 * @param descriptor
 * ... {String} id
 */
JIRA.Avatar.createSystemAvatar = function (descriptor) {
    descriptor.isSystemAvatar = true;
    return new JIRA.Avatar(descriptor);
};

/**
 * Converts avatar size name to size object. If passed parameters is object is
 * returned unmodified.
 * @param name
 * @returns {JIRA.Avatar}
 */
JIRA.Avatar.getSizeObjectFromName = function (name) {
    if ( "object" === typeof name ) {
        return name;
    }
    var nameTrimmed = "string" === typeof name ? jQuery.trim(name) : "";
    if ( JIRA.Avatar.LARGE.param===name ) {
        return JIRA.Avatar.LARGE;
    } else if ( JIRA.Avatar.MEDIUM.param===name ) {
        return JIRA.Avatar.MEDIUM;
    } else if ( JIRA.Avatar.SMALL.param===name ) {
        return JIRA.Avatar.SMALL;
    } else if ( "xsmall"===name ) { // Java uses xmall name!#@$
        return JIRA.Avatar.SMALL;
    } else {
        return JIRA.Avatar.LARGE;
    }
};


// Sizes

/**
 * Large avatar settings
 */
JIRA.Avatar.LARGE = {
    param: "large",
    height: 48,
    width: 48
};

/**
 * Medium avatar settings
 */
JIRA.Avatar.MEDIUM = {
    param: "medium",
    width: 32,
    height: 32
};

/**
 * Small avatar settings
 */
JIRA.Avatar.SMALL = {
    param: "small",
    width: 16,
    height: 16
};

;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarManager.js' */
/**
 * Manager interface for JIRA.Avatar objects.
 *
 * You should use this for creating, manipulating and deleteing of avatars. Helper methods such as getting avatar
 * urls are also contained within this class.
 *
 * Please use the factory methods for construction
 *
 * @Class JIRA.AvatarManager
 */
JIRA.AvatarManager = Class.extend({

    /**
     * @param options
     * @param {JIRA.AvatarStore} options.store
     * @param {Number|String} options.defaultAvatarId - This is the avatar that is currently in use if no other have been selected
     * @param {Number|String} options.anonymousAvatarId - In the case of user avatar, this is the one used for logged out/or annonymous users
     * @param {String} options.avatarSrcBaseUrl - The base url used to load the avatar image
     */
    init: function (options) {
        this.store = options.store;
        this.ownerId = options.ownerId;
        this.username = options.username;
        this.anonymousAvatarId = options.anonymousAvatarId;
        this.avatarSrcBaseUrl = options.avatarSrcBaseUrl;
    },

    /**
     * Selects avatar, this will become the displayed avatar for the given type (ie project)
     *
     * @param avatar
     * @param options
     */
    selectAvatar: function (avatar, options) {
        return this.store.selectAvatar(avatar, options);
    },

    /**
     * Retrieve the avatar with the given id.
     *
     * @param avatarId must not be null.
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    getById: function (id) {
        return this.store.getById(id);
    },

    /**
     * Delete the avatar
     *
     * @param {String} avatar must not be null.
     */
    destroy: function (avatar, options) {
        this.store.destroy(avatar, options);
    },

    /**
     * Saves the avatar as an updated version of the avatar with the same id that is already in the store.
     *
     * @param {JIRA.Avatar} avatar must not be null.
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    update: function (avatar, options) {
        this.store.update(avatar, options);
    },

    /**
     * Creates a database record for the given avatar. Use the return value as the persistent avatar, not the one you
     * passed in.
     *
     * @param {JIRA.Avatar} avatar must not be null, must have a null id.
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    add: function (avatar, options) {
        this.store._add(avatar, options);
    },

    /**
     * Provides a list of all system avatars.
     *
     * Note: You will need to call refreshStore first
     *
     * @return {Array<JIRA.Avatar>} the system avatars.
     */
    getAllSystemAvatars: function () {
        return this.store.getAllSystemAvatars();
    },

    /**
     * Provides an array of all system avatars.
     *
     * Note: You will need to call refreshStore first
     *
     * @return {Array<JIRA.Avatar>} the custom avatars.
     */
    getAllCustomAvatars: function () {
        return this.store.getAllCustomAvatars();
    },

    /**
     * Gets selected avatar
     *
     * @return JIRA.Avatar
     */
    getSelectedAvatar: function () {
        return this.store.getSelectedAvatar();
    },

    /**
     *
     * Gets all avatars
     *
     * Note: You will need to call refreshStore first
     *
     * @return {Object}
     * ... {Array<JIRA.Avatar>} system
     * ... {Array<JIRA.Avatar>} custom
     */
    getAllAvatars: function () {
        return this.store.getAllAvatars();
    },

    /**
     * Gets a JSON blob, that contains the img src of each avatar based on the supplied size
     *
     * @param {JIRA.Avatar.LARGE | JIRA.Avatar.MEDIUM | JIRA.Avatar.SMALL} size
     * @return {Object}
     * ... {Array[{id, src, isSystemAvatar}]} system
     * ... {Array[{id, src, isSystemAvatar}] custom
     */
    getAllAvatarsRenderData: function (size) {

        var i,
                instance = this,
                avatars = this.getAllAvatars(),
                renderData = {
                    system: [],
                    custom: []
                };

        for (i = 0; i < avatars.system.length; i++) {
            renderData.system.push(instance.getAvatarRenderData(avatars.system[i], size));
        }

        for (i = 0; i < avatars.custom.length; i++) {
            renderData.custom.push(instance.getAvatarRenderData(avatars.custom[i], size));
        }

        return renderData;
    },

    /**
     * Gets json descriptor of given avatar that contains the img src based on the supplied size
     * @param avatar
     * @param size
     */
    getAvatarRenderData: function (avatar, size) {
        var data = avatar.toJSON();

        data.src = this.getAvatarSrc(avatar, size);
        data.width = size.width;
        data.height = size.height;


        return data;
    },

    /**
     * Refreshes avatar store
     *
     * @param options
     * ... {function} success
     * ... {function} error
     */
    refreshStore: function (options) {
        this.store.refresh(options);
    },

    /**
     *
     * @param {JIRA.Avatar} avatar
     * @param {JIRA.Avatar.LARGE | JIRA.Avatar.MEDIUM | JIRA.Avatar.SMALL} size
     * @return String
     */
    getAvatarSrc: function(avatar, size) {

        if (this.store.isTempAvatar(avatar)) {
            // if the user chooses a new temporary avatar we need to keep making this url unique so that the image is kept fresh
            return contextPath + "/secure/temporaryavatar?" + jQuery.param({
                cropped: true,
                magic: new Date().getTime(),
                size: size.param
            });
        }

        return avatar.getUrl(AJS.format('{0}x{1}', size.height, size.width));
    },

    /**
     * Creates temporary avatar from the value in the supplied file input field
     *
     * @param {HTMLElement} field
     * @param {Object} options
     * ... {function} success
     * ... {function} error
     */
    createTemporaryAvatar: function (field, options) {
        this.store.createTemporaryAvatar(field, options);
    },

    /**
     * Creates an avatar with the properties of the given avatar.
     *
     * @param {Object} instructions
     * ... {Number} cropperOffsetX
     * ... {Number} cropperOffsetY
     * ... {Number} cropperWidth
     *
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    createAvatarFromTemporary: function (instructions, options) {
        this.store.createAvatarFromTemporary(instructions, options);
    },

    /**
     * Gets the avatar id to use to represent an unknown or anonymous user
     * @return {Number} the avatar id for an anonymous user
     */
    getAnonymousAvatarId: function () {
        return this.anonymousAvatarId;
    }

});


// Factories


/**
 *
 * Creates a project avatar manager
 *
 * @param options
 * ... {String} projectKey
 * ... {String} projectId
 * ... {String} defaultAvatarId
 */
JIRA.AvatarManager.createUniversalAvatarManager = function (options) {

    // Cater for the projectKey being empty
    var restQueryUrl,
            restUpdateUrl = "",
            restCreateTempUrl = "",
            restUpdateTempUrl = "",
            restSingleAvatarUrl = "";

    if (options.projectId) {
        var urlAvatarOwnerPrefix = contextPath + "/rest/api/latest/universal_avatar/type/"+options.avatarType+"/owner/" + options.projectId;

        restQueryUrl = urlAvatarOwnerPrefix;

        var avatarCreateUrl = urlAvatarOwnerPrefix + "/avatar";

        restUpdateUrl = null;
        restCreateTempUrl = urlAvatarOwnerPrefix + "/temp";
        restUpdateTempUrl = avatarCreateUrl;
        restSingleAvatarUrl = avatarCreateUrl;
    } else {
        restQueryUrl = contextPath + "/rest/api/latest/avatar/project/system";
        restCreateTempUrl = contextPath + "/rest/api/latest/avatar/project/temporary";
        restUpdateTempUrl = contextPath + "/rest/api/latest/avatar/project/temporaryCrop";
    }

    var store = new JIRA.AvatarStore({
        restQueryUrl: restQueryUrl,
        restUpdateUrl: restUpdateUrl,
        restCreateTempUrl: restCreateTempUrl,
        restUpdateTempUrl: restUpdateTempUrl,
        restSingleAvatarUrl: restSingleAvatarUrl,
        defaultAvatarId: options.defaultAvatarId
    });

    return new JIRA.AvatarManager({
        store: store,
        ownerId: options.projectId,
        avatarSrcBaseUrl: contextPath + "/secure/projectavatar"
    });
};

/**
 *
 * Creates a project avatar manager
 *
 * @param options
 * ... {String} projectKey
 * ... {String} projectId
 * ... {String} defaultAvatarId
 */
JIRA.AvatarManager.createProjectAvatarManager = function (options) {
    options.avatarType = "project";

    return JIRA.AvatarManager.createUniversalAvatarManager(options);
};

/**
 * Creates a user avatar manager
 *
 * @param options
 * ... {String} username
 * ... {String} defaultAvatarId
 */
JIRA.AvatarManager.createUserAvatarManager = function (options) {

    var userRestUrl = contextPath + "/rest/api/latest/user";
    var store = new JIRA.AvatarStore({
        restQueryUrl: userRestUrl + "/avatars",
        restUpdateUrl: userRestUrl + "/avatar",
        restCreateTempUrl: userRestUrl + "/avatar/temporary",
        restUpdateTempUrl: userRestUrl + "/avatar",
        restSingleAvatarUrl: userRestUrl + "/avatar",
        restParams: { 'username': options.username },
        defaultAvatarId: options.defaultAvatarId
    });

    return new JIRA.AvatarManager({
        store: store,
        username: options.username,
        avatarSrcBaseUrl: contextPath + "/secure/useravatar"
    });
};
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarStore.js' */
/**
 * Persistent storage mechanism for JIRA.Avatar
 *
 * This default store uses a CRUD rest interface. There are several parameters to provide. Any optional rest URL
 * parameters are simply not invoked.
 *
 * @param restQueryUrl
 *      Mandatory. Retrieves the list of available avatars to pick from.
 *      Type: GET
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatars
 *      Response: {"system":[{"id":10001,"isSystemAvatar":true,"selected":false}], "custom": [{"id":10002,"isSystemAvatar":false,"selected":false}]}
 *
 * @param restUpdateUrl
 *      Optional. Sets the avatar as the selection for the owner.
 *      Type: PUT
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar
 *      Request: {"id":10001,"isSystemAvatar":true,"selected":false}
 *
 * @param restCreateTempUrl
 *      Mandatory. Uploads a file and stores it as the session's temporary avatar
 *      Type: Wildcard
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar/temporary
 *      Request: io stream (for supporting browsers) or multipart
 *
 * @param restUpdateTempUrl
 *      Mandatory. Crops the temporary avatar. This may also be a good time to convert it into a real avatar, but that
 *      will not always be the case, e.g. when an owner (project, user, etc) is still in the process of being created.
 *      Type: POST
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar
 *      Request: {"cropperOffsetX":"90","cropperOffsetY":"57","cropperWidth":"143"}
 *
 * @param restSingleAvatarUrl
 *      Optional. Deletes avatar.
 *      Type: DELETE
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar
 *      Request: {"id":10001,"isSystemAvatar":true,"selected":false}
 *
 * @param restParams
 *      Optional. e.g. {username: "admin"}
 *
 * @param defaultAvatarId
 *      Mandatory. Used if the currently selected avatar is deleted.
 *
 * Note: If you want to use a different storage mechanism, you can implement the same interface as here and pass it to the
 * constructor of your JIRA.AvatarManager
 */
JIRA.AvatarStore = Class.extend({

    TEMP_ID: "TEMP",

    /**
     * @constructor
     * @param options
     * ... {String} restQueryUrl - Retrieves the list of available avatars to pick from (see class description)
     * ... {String} restUpdateUrl - Sets the avatar as the selection for the owner (see class description)
     * ... {String} restCreateTempUrl - Uploads a file and stores it as the session's temporary avatar (see class description)
     * ... {String} restUpdateTempUrl - Crops the temporary avatar (see class description)
     * ... {String} restSingleAvatarUrl - Deletes avatar (see class description)
     * ... {String} restParams - The optional query parameters to append to the base URL for rest requests (see class description)
     * ... {Number} defaultAvatarId - The id of default avatar. The selected avatar if user has not selected one yet.
     */
    init: function (options) {

        if (!options.restQueryUrl) {
            throw new Error("JIRA.AvatarStore.init: You must specify [restQueryUrl], The rest url for querying avatars (see class description)");
        }

        if (!options.restCreateTempUrl) {
            throw new Error("JIRA.AvatarStore.init: You must specify [restCreateTempUrl], The rest url for creating a temporary avatar (see class description)");
        }

        if (!options.restUpdateTempUrl) {
            throw new Error("JIRA.AvatarStore.init: You must specify [restUpdateTempUrl], The rest url for updating a temporary avatar (see class description)");
        }

        if (!options.defaultAvatarId) {
            throw new Error("JIRA.AvatarStore.init: You must specify [defaultAvatarId] to the contructor so the store " +
                "knows what to select if you delete the selected one");
        }

        this.restQueryUrl = options.restQueryUrl;
        this.restUpdateUrl = options.restUpdateUrl;
        this.restCreateTempUrl = options.restCreateTempUrl;
        this.restUpdateTempUrl = options.restUpdateTempUrl;
        this.restSingleAvatarUrl = options.restSingleAvatarUrl;
        this.restParams = options.restParams || {};
        this.restParams.atl_token = atl_token();
        this.defaultAvatarId = options.defaultAvatarId;
        this.avatars = {system: [], custom: []};
    },

    /**
     * Builds the REST URL using the given url and optional restParams options.
     */
    _buildCompleteUrl: function (url) {
        var completeUrl = url;

        if (this.restParams) {
            var queryParams = '';
            for (var name in this.restParams) {
                queryParams += AJS.format('&{0}={1}', encodeURIComponent(name), encodeURIComponent(this.restParams[name]));
            }

            completeUrl += ('?' + queryParams.substr(1));
        }

        return completeUrl;
    },

    /**
     * Retrieves the Avatar by id.
     *
     * @param avatarId the avatar's id, must not be null.
     * @return the avatar with the given id or null if it doesn't exist.
     */
    getById: function (avatarId) {

        var match;

        jQuery.each(this.avatars.system, function (i, avatar) {
            if (this.getId() === avatarId) {
                match = avatar;
                return false;
            }
        });

        if (!match) {
            jQuery.each(this.avatars.custom, function (i, avatar) {
                if (this.getId() === avatarId) {
                    match = avatar;
                    return false;
                }
            });
        }

        return match;
    },

    /**
     * Checks if the given avatar is the temporarty avatar.
     *
     * @param avatar
     * @return true if it is the temporary avatar, false if otherwise.
     */
    isTempAvatar: function(avatar) {
        return (avatar.getId() === this.TEMP_ID);
    },

    /**
     * Update client side storage
     *
     * @param avatar
     */
    _selectAvatar: function (avatar) {

        var selected = this.getSelectedAvatar();

        if (selected) {
            selected.setUnSelected();
        }
        avatar.setSelected();
    },

    /**
     * Selects avatar, this will become the displayed avatar for the given type (ie project)
     *
     * @param {JIRA.Avatar} avatar
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    selectAvatar: function (avatar, options) {

        var instance = this;

        if (!avatar) {
            throw new Error("JIRA.AvatarStore.selectAvatar: Cannot select Avatar that does not exist");
        }

        if (this.restUpdateUrl) {
            JIRA.SmartAjax.makeRequest({
                type: "PUT",
                contentType: "application/json",
                dataType: "json",
                url: this._buildCompleteUrl(this.restUpdateUrl),
                data: JSON.stringify(avatar.toJSON()),
                success: function () {
                    instance._selectAvatar(avatar);
                    if (options.success) {
                        options.success.call(this, avatar);
                    }
                },
                error: options.error
            });
        } else {
            instance._selectAvatar(avatar);
            if (options.success) {
                options.success.call(this, avatar);
            }
        }
    },

    /**
     * Removes avatar in client side store
     *
     * @param {JIRA.Avatar} avatar
     */
    _destory: function (avatar) {

        var index = jQuery.inArray(avatar, this.avatars.custom);

        if (index !== -1) {
            this.avatars.custom.splice(index, 1);
        } else {
            throw new Error("JIRA.AvatarStore._destroy: Cannot remove avatar [" + avatar.getId() + "], "
                    + "it might be a system avatar (readonly) or does not exist.");
        }
    },

    /**
     * Permanently removes the avatar from the system.
     *
     * @param {JIRA.Avatar} avatar - must not be null.
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    destroy: function (avatar, options) {

        var instance = this;

        options = options || {};

        if (!avatar) {
            throw new Error("JIRA.AvatarStore.destroy: Cannot delete Avatar that does not exist");
        }

        JIRA.SmartAjax.makeRequest({
            type: "DELETE",
            url: this.getRestUrlForAvatar(avatar),
            success: function () {
                instance._destory(avatar);
                if (avatar.isSelected()) {
                    instance.selectAvatar(instance.getById(instance.defaultAvatarId), options);
                } else if (options.success) {
                    options.success.apply(this, arguments);
                }
            },
            error: options.error
        });
    },

    /**
     * Gets selected avatar, the displayed avatar for the given type (ie project)
     *
     * @return {JIRA.Avatar}
     */
    getSelectedAvatar: function () {

        for (var i = 0; i < this.avatars.custom.length; i++) {
            if (this.avatars.custom[i].isSelected()) {
                return this.avatars.custom[i];
            }
        }

        for (i = 0; i < this.avatars.system.length; i++) {
            if (this.avatars.system[i].isSelected()) {
                return this.avatars.system[i];
            }
        }
    },

    /**
     * Updates avatar in our client side store
     *
     * @param {JIRA.Avatar} avatar
     */
    _update: function (avatar) {

        var instance = this;

        if (this.getById(avatar.getId())) {
            jQuery.each(this.avatars.custom, function (i) {
                if (this.getId() === avatar.getId()) {
                    instance.avatars.custom[i] = avatar;
                }
            });
        }
        else {
            throw new Error("JIRA.AvatarStore._update: Cannot update avatar [" + avatar.getId() + "], "
                    + "it might be a system avatar (readonly) or does not exist.");
        }
    },

    /**
     * Updates an avatar's properties to match those in the given avatar. The avatar
     * to change is identified by the id of the given avatar.
     *
     * @param {JIRA.Avatar} avatar - the avatar to update, must not be null.
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    update: function (avatar, options) {

        var instance = this;

        options = options || {};

        JIRA.SmartAjax.makeRequest({
                    type: "PUT",
                    url: this.getRestUrlForAvatar(avatar),
                    error: options.error,
                    success: function () {
                        instance._update(avatar);
                        if (options.success) {
                            options.success.apply(this, arguments);
                        }
                    }
                });
    },

    /**
     * Adds avatar to our client side store
     *
     * @param avatar
     */
    _add: function (avatar) {
        if (avatar.isSystemAvatar()) {
            this.avatars.system.push(avatar);
        }
        else {
            this.avatars.custom.push(avatar);
        }
    },

    /**
     * Creates an avatar with the properties of the given avatar.
     *
     * @param {Object} instructions
     * ... {Number} cropperOffsetX
     * ... {Number} cropperOffsetY
     * ... {Number} cropperWidth
     *
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    createAvatarFromTemporary: function (instructions, options) {

        var instance = this;

        options = options || {};

        if (this.restUpdateTempUrl) {
            JIRA.SmartAjax.makeRequest({
                type: "POST",
                url: this._buildCompleteUrl(this.restUpdateTempUrl),
                data: JSON.stringify(instructions),
                contentType: "application/json",
                dataType: "json",
                success: function (data) {

                    // If no data is returned, no real avatar was created and the temporary avatar has just been updated with the cropping instructions
                    if (!data) {
                        data = {
                            id: instance.TEMP_ID,
                            isSelected: true
                        };
                    }
                    var avatar = JIRA.Avatar.createCustomAvatar(data);
                    instance._add(avatar);

                    if (options.success) {
                        options.success.call(this, data);
                    }
                },
                error: options.error
            });
        }
    },

    /**
     *
     * Creates temporary avatar on server
     *
     * @param {HTMLElement} fileInput
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    createTemporaryAvatar: function (fileInput, options) {
        // add the restParams as option
        options = AJS.$.extend(true, {}, options, { params: this.restParams });

        JIRA.AvatarUtil.uploadTemporaryAvatar(this.restCreateTempUrl, fileInput, options);
    },

    /**
     * Resets store with the Avatars created from the supplied JSON
     *
     * @param JSON avatar descriptors
     */
    _refresh: function (avatars) {

        var instance = this;

        instance.avatars.system = [];
        instance.avatars.custom = [];

        if (avatars.system) {
            jQuery.each(avatars.system, function (i, descriptor) {
                instance.avatars.system.push(JIRA.Avatar.createSystemAvatar(descriptor));
            });
        }

        if (avatars.custom) {
            jQuery.each(avatars.custom, function (i, descriptor) {
                instance.avatars.custom.push(JIRA.Avatar.createCustomAvatar(descriptor));
            });
        }
    },

    /**
     * Goes back to the server and retrievs all avatars
     *
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    refresh: function (options) {

        var instance = this;

        // Remember the temporary avatar if we have one
        var tempAvatar = this.getById(instance.TEMP_ID);

        options = options || {};

        JIRA.SmartAjax.makeRequest({
            url: this._buildCompleteUrl(this.restQueryUrl),
            error: options.error,
            success: function (avatars) {
                instance._refresh(avatars);
                if (tempAvatar) {
                    instance._add(tempAvatar);
                }
                if (options.success) {
                    options.success.apply(this, arguments);
                }
            }
        });
    },

    /**
     * Gets all avatars, custom and system
     *
     * @return {Object}
     * ... {Array<JIRA.Avatar>} system
     * ... {Array<JIRA.Avatar>} custom
     */
    getAllAvatars: function () {
        return this.avatars;
    },

    /**
     * Provides an array of all system avatars.
     *
     * @return the system avatars, never null.
     */
    getAllSystemAvatars: function () {
        return this.avatars.system;
    },

    /**
     * Provides an array of all system avatars.
     *
     * @return the custom avatars.
     */
    getAllCustomAvatars: function () {
        return this.avatars.custom;
    },

    /**
     * Gets rest url to update a single avatar
     *
     * @param avatar
     */
    getRestUrlForAvatar: function (avatar) {
        return this._buildCompleteUrl(this.restSingleAvatarUrl + "/" + avatar.getId());
    }
});
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarUtil.js' */
JIRA.AvatarUtil = {

    uploadUsingIframeRemoting: function (url, field, options) {
        options = options || {};

        var fileName = field.val(),
            form = new AJS.InlineAttach.Form(new AJS.InlineAttach.FileInput(field, false)),
            progress = form.addStaticProgress(fileName);

        //Add a new "File Input" to the form. We use the old input as part of a hidden form that we can submit to the
        //server in the background.
        var $oldInput = form.cloneFileInput();

        form.fileSelector.clear();

        //We only show progress after we are sure the upload will take longer than AJS.InlineAttach.DISPLAY_WAIT.
        var timer = new AJS.InlineAttach.Timer(function() {
            !this.cancelled && progress.show();
        }, this);

        var upload = new AJS.InlineAttach.FormUpload({
            $input: $oldInput,
            url: url,
            params: AJS.$.extend({}, options.params, {
                filename: fileName,
                atl_token: atl_token()
            }),
            scope: this,
            before: function() {
                !this.cancelled && progress.start();
            },
            success: function(val, status) {
                if (val.errorMessages && val.errorMessages.length) {
                    form.addErrorWithFileName(val.errorMessages[0], fileName, JIRA.AvatarUtil.getErrorTarget(form));
                } else if (options.success) {
                    options.success(val, status);
                }
            },
            error: function(text) {

                console.log(text);

                if (this.cancelled) {
                    return;
                }

                if (text.indexOf("SecurityTokenMissing") >= 0) {
                    form.addError(AJS.InlineAttach.Text.tr("upload.xsrf.timeout", fileName), JIRA.AvatarUtil.getErrorTarget(form));
                } else {
                    form.addError(AJS.InlineAttach.Text.tr("upload.error.unknown", fileName), JIRA.AvatarUtil.getErrorTarget(form));
                }
            },
            after: function() {

                timer.cancel();
                progress.remove();

                if (!this.cancelled) {
                    form.enable();
                }
            }
        });

        progress.onCancel(function() {
            upload.abort();
        });

        upload.upload();
    },

    uploadUsingFileApi: function (url, field, options) {

        var timer,
            upload,
            cancelled,
            file = field[0].files[0],
            form = new AJS.InlineAttach.Form(new AJS.InlineAttach.FileInput(field, false)),
            progress = form.addProgress(file);

        options = options || {};

        //We only show progress after we are sure the upload will take longer than AJS.InlineAttach.DISPLAY_WAIT.
        timer = new AJS.InlineAttach.Timer(function() {
            if (!cancelled) {
                progress.show();
            }
        });

        upload = new AJS.InlineAttach.AjaxUpload({
            file: file,
            params: AJS.$.extend({}, options.params, {
                filename: file.name,
                size: file.size,
                atl_token: atl_token()
            }),
            scope: this,
            url: url,
            before: function() {
                field.hide();
                !cancelled && progress.start();
            },
            progress: function(val) {
                progress.progress.$progress.parent().parent().show();
                !cancelled && progress.update(val);
            },
            success: function(val, status) {

                if (cancelled) {
                    return;
                }

                if (val.errorMessages && val.errorMessages.length) {
                    form.addErrorWithFileName(val.errorMessages[0], file.name, JIRA.AvatarUtil.getErrorTarget(form));
                } else if (status === 201) {
                    options.success(val, status);
                }
            },
            error: function(text, status) {


                if (status < 0) {
                    //This is a client error so just render it.
                    form.addError(text, JIRA.AvatarUtil.getErrorTarget(form));
                } else {
                    form.addError(AJS.InlineAttach.Text.tr("upload.error.unknown", file.name), JIRA.AvatarUtil.getErrorTarget(form));
                }

                if (options.error) {
                    options.error(text, status);
                }
            },
            after: function() {
                timer.cancel();
                progress.finish().remove();
                field.val("").show();
            }
        });

        upload.upload();

        progress.onCancel(function () {
            upload.abort();
        });
    },

    getErrorTarget: function (form) {
        return {
            $element: form.$form.find(".error")
        };
    },

    /**
     * Uploads temporary avatar using progress bars (if file API supported)
     *
     * @param {String} url - url to upload to, must accept any type, multipart etc
     * @param {HTMLElement} field - file input field containing file path
     * @param options
     * ... {Function} success
     * ... {Function} error
     * ... {Object} params additional query params to use in the upload request
     */
    uploadTemporaryAvatar: function (url, field, options) {
        if (AJS.InlineAttach.AjaxPresenter.isSupported(field)) {
            this.uploadUsingFileApi(url, field, options);
        } else {
            this.uploadUsingIframeRemoting(url, field, options);
        }
    }
};
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarPicker.js' */
;(function($) {

    /**
     * Creates/Renders avatar picker
     *
     * @class JIRA.AvatarPicker
     */
    JIRA.AvatarPicker = AJS.Control.extend({

        /**
         * @constructor
         * @param {Object} options
         * ... {JIRA.AvatarManager or something that implements same interface} avatarManager
         * ... {JIRA.AvatarPicker.Avatar or something that implements same interface} avatarRenderer
         * ... {JIRA.Avatar.LARGE | JIRA.Avatar.MEDIUM | JIRA.Avatar.SMALL} size
         */
        init: function (options) {
            this.avatarManager = options.avatarManager;
            this.avatarRenderer = options.avatarRenderer;
            this.imageEditor = options.imageEditor;
            this.size = options.size;
            this.selectCallback = options.select;
            this.cropperDialog = null;
            this.initialSelection = options.initialSelection;
        },

        /**
         * Renders avatar picker
         *
         * @param {Function} ready - a callback function that will be called when rendering is complete, the first
         * argument of this function will be the contents of the avatar picker. You can then append this element to wherever you
         * want the picker displayed
         */
        render: function (ready) {

            var instance = this;

            // we need to go to the server and get all the avatars first
            this.avatarManager.refreshStore({

                success: function () {
                    if (instance.cropperDialog instanceof JIRA.Dialog) {
                        instance.cropperDialog.hide();
                        delete instance.cropperDialog;
                    }
                    instance.element = $('<div id="jira-avatar-picker" />');

                    instance.element.html(JIRA.Templates.AvatarPicker.picker({
                        avatars: instance.avatarManager.getAllAvatarsRenderData(instance.size)
                    }));

                    instance._assignEvents("selectAvatar", instance.element.find(".jira-avatar button"));
                    instance._assignEvents("deleteAvatar", instance.element.find(".jira-delete-avatar"));
                    instance._assignEvents("uploader", instance.element.find("#jira-avatar-uploader"));

                    if (undefined !== instance.initialSelection) {
                        instance.getAvatarElById(instance.initialSelection).addClass("jira-selected-avatar");
                    }

                    // we are finished, call with picker contents
                    ready(instance.element);
                },
                error: function (xhr, error, textStatus, smartAjaxResult) {
                    instance.appendErrorContent(instance.element, smartAjaxResult);
                    ready(instance.element);
                }
            });
        },

        /**
         *
         * Gets the most useful error response from a smartAjaxResponse and appends it to the picker
         *
         * @param el
         * @param smartAjaxResult
         */
        appendErrorContent: function (el, smartAjaxResult) {
            try {
                var errors = JSON.parse(smartAjaxResult.data);

                if (errors && errors.errorMessages) {
                    $.each(errors.errorMessages, function (i, message) {
                        AJS.messages.error(el, {
                            body: AJS.escapeHTML(message),
                            closeable: false,
                            shadowed: false
                        });
                    });
                } else {
                    el.append(JIRA.SmartAjax.buildDialogErrorContent(smartAjaxResult, true));
                }
            } catch (e) {
                el.append(JIRA.SmartAjax.buildDialogErrorContent(smartAjaxResult, true));
            }
        },

        /**
         * Saves temporary avatar and invokes cropper
         *
         * @param {HTMLElement} field
         */
        uploadTempAvatar: function (field) {

            var instance = this;

            this.avatarManager.createTemporaryAvatar(field, {

                success: function (data) {

                    if (data.id) {
                        // We have an avatar and don't need to crop
                        instance.render(function () {
                            instance.selectAvatar(data.id);
                        });
                    } else {
                        field.val("");

                        instance.cropperDialog = new JIRA.Dialog({
                            id: "project-avatar-cropper",
                            width: 560,
                            content: function(ready) {
                                var $el = instance.imageEditor.render(data);
                                function disableSubmitButton() {
                                    var $button = $el.find("input[type=submit]");
                                    var $loader = $("<span class='icon throbber loading'></span>");
                                    $button.attr("aria-disabled", "true").attr("disabled", "");
                                    $button.before($loader);
                                    return function() {
                                        $loader.remove();
                                        $button.removeAttr("aria-disabled").removeAttr("disabled");
                                    };
                                }

                                instance.imageEditor.edit({
                                    confirm: function (instructions) {
                                        var reEnableSubmit = disableSubmitButton();
                                        instance.avatarManager.createAvatarFromTemporary(instructions, {
                                            success: function (data) {
                                                instance.render(function () {
                                                    instance.selectAvatar(data.id);
                                                });
                                            },
                                            error: reEnableSubmit
                                        });
                                    }
                                });
                                $el.find(".cancel").click(function() {
                                    instance.cropperDialog.hide();
                                });
                                ready($el);
                            }
                        });
                        instance.cropperDialog.bind("dialogContentReady", function() {
                            $(instance).trigger(JIRA.AvatarPicker.ImageEditor.LOADED);
                        });
                        instance.cropperDialog.bind("Dialog.hide", function() {
                            $(instance).trigger(JIRA.AvatarPicker.ImageEditor.DISMISSED);
                        });

                        instance.cropperDialog.show();
                    }
                },
                error: function () {
                    console.log(arguments);
                }
            });
        },

        /**
         * Gets avatar HTML element based on it's database id
         *
         * @param {String} id
         * @return {$}
         */
        getAvatarElById: function (id) {
            return this.element.find(".jira-avatar[data-id='" + id + "']");
        },

        /**
         * Selects avatar
         *
         * @param {String} id - avatar id
         */
        selectAvatar: function (id) {
            var avatar = this.avatarManager.getById(id);
            var instance = this;

            this.avatarManager.selectAvatar(this.avatarManager.getById(id), {
                error: function () {
                },
                success: function () {

                    instance.getAvatarElById(id).remove();

                    if (instance.selectCallback) {
                        instance.selectCallback.call(instance, avatar,
                                instance.avatarManager.getAvatarSrc(avatar, instance.size));
                    }
                }
            });
        },

        /**
         * Deletes avatar, shows confirmation before hand
         *
         * @param {String} id - avatar id
         */
        deleteAvatar: function (id) {

            var instance = this;

            if (confirm("Are you sure you want to delete avatar?")) {
                this.avatarManager.destroy(this.avatarManager.getById(id), {
                    error: function () {

                    },
                    success: function () {

                        var selectedAvatar = instance.avatarManager.getSelectedAvatar(),
                            $avatar = instance.getAvatarElById(id);

                        $avatar.fadeOut(function () {
                            $avatar.remove();
                        });

                        // if the avatar we have deleted is the selected avatar, then we want to set the selected avatar to be
                        // the default. This is done automagically in AvatarStore.
                        if (selectedAvatar.getId() !== id) {

                            instance.getAvatarElById(selectedAvatar.getId()).addClass("jira-selected-avatar");

                            instance.selectCallback.call(instance, selectedAvatar,
                                    instance.avatarManager.getAvatarSrc(selectedAvatar, instance.size), true);
                        }
                    }
                });
            }
        },

        _events: {
            uploader: {
                change: function (e, el) {
                    this.uploadTempAvatar(el);
                }
            },
            deleteAvatar: {
                click: function (e, el) {
                    this.deleteAvatar(el.attr("data-id"));
                }
            },
            selectAvatar: {
                click: function (e, el) {
                    // Don't select avatar if we click an overlay, such as delete icon
                    if (el[0].id === "select-avatar-button") {
                        this.selectAvatar(el.attr("data-id"));
                    }
                }
            }
        }
    });

    /**
     * Handles cropping of avatar
     *
     * @class JIRA.AvatarPicker.ImageEditor
     *
     */
    JIRA.AvatarPicker.ImageEditor = AJS.Control.extend({
        /**
         * Renders cropper
         *
         * @param {Object} data
         * ... {Number} cropperOffsetX
         * ... {Number} cropperOffsetY
         * ... {Number} cropperWidth
         */
        render: function (data) {
            this.element = $('<div id="avatar-picker-image-editor"/>').html(JIRA.Templates.AvatarPicker.imageEditor(data));
            return this.element;
        },

        /**
         * Initializes cropper
         *
         * @param {Object} options
         * ... {Function} confirm
         * ... {Function} cancel
         * ... {Function} ready
         */
        edit: function (options) {

            var instance = this,
                    avator = this.element.find(".avataror");

            options = options || {};

            avator.unbind();
            avator.bind("AvatarImageLoaded", function () {
                if (options.ready) {
                    options.ready();
                }
            });

            avator.find("img").load(function () {
                avator.avataror({
                    previewElement: instance.element.find(".jira-avatar-cropper-header"),
                    parent: instance.element
                });
            });

            this.element.find("#avataror").submit(function (e) {

                e.preventDefault();

                if (options.confirm) {
                    options.confirm({
                        cropperOffsetX: $("#avatar-offsetX").val(),
                        cropperOffsetY: $("#avatar-offsetY").val(),
                        cropperWidth: $("#avatar-width").val()
                    });
                }
            })
            .find(".cancel").click(function (e) {
                e.preventDefault();
                if (options.cancel) {
                    options.cancel();
                }
            });
        }

    });

    /**
     * Name of event fired when the image editor dialog is loaded and ready.
     */
    JIRA.AvatarPicker.ImageEditor.LOADED = "imageEditorLoaded";

    /**
     * Name of event fired when the image editor dialog is dismissed/actioned and unloaded.
     */
    JIRA.AvatarPicker.ImageEditor.DISMISSED = "imageEditorDismissed";


    /**
     * Creates project avatar picker
     *
     * @param options
     * ... {String} projectKey
     *
     * @return JIRA.AvatarPicker
     */
    JIRA.AvatarPicker.createUniversalAvatarPicker = function (options) {
        return new JIRA.AvatarPicker({
            avatarManager: JIRA.AvatarManager.createUniversalAvatarManager({
                projectKey: options.projectKey,
                projectId: options.projectId,
                defaultAvatarId: options.defaultAvatarId,
                avatarType: options.avatarType
            }),
            initialSelection: options.initialSelection,
            imageEditor: new JIRA.AvatarPicker.ImageEditor(),
            size: options.hasOwnProperty('avatarSize') ? options.avatarSize : JIRA.Avatar.LARGE,
            select: options.select
        });
    };

    /**
     * Creates project avatar picker
     *
     * @param options
     * ... {String} projectKey
     *
     * @return JIRA.AvatarPicker
     */
    JIRA.AvatarPicker.createProjectAvatarPicker = function (options) {
        return new JIRA.AvatarPicker({
            avatarManager: JIRA.AvatarManager.createProjectAvatarManager({
                projectKey: options.projectKey,
                projectId: options.projectId,
                defaultAvatarId: options.defaultAvatarId
            }),
            imageEditor: new JIRA.AvatarPicker.ImageEditor(),
            size: JIRA.Avatar.LARGE,
            select: options.select
        });
    };

    /**
     * Creates user avatar picker
     *
     * @param {Object} options
     * @param {String} options.username
     *
     * @return JIRA.AvatarPicker
     */
    JIRA.AvatarPicker.createUserAvatarPicker = function (options) {
        return new JIRA.AvatarPicker({
            avatarManager: JIRA.AvatarManager.createUserAvatarManager({
                username: options.username,
                defaultAvatarId: options.defaultAvatarId
            }),
            imageEditor: new JIRA.AvatarPicker.ImageEditor(),
            size: JIRA.Avatar.LARGE,
            select: options.select
        });
    };

    /**
     * Creates a project avatar picker dialog
     *
     * @param {Object} options
     * @param {HTMLElement | String} options.trigger - element that when clicked will bring up dialog
     * @param {String} options.projectKey
     * @param {String} options.projectId
     */
    JIRA.createUniversalAvatarPickerDialog = function (options) {
        var lastSelection = options.initialSelection || options.defaultAvatarId;

        var projectAvatarDialog = new JIRA.FormDialog({
            trigger: options.trigger,
            id: "project-avatar-picker",
            width: 600,
            stacked: true,
            content: function (ready) {

                var avatarPicker,
                        $dialogWrapper;

                $dialogWrapper = $('<div id="projectavatar-content-wrapper"/>');

                $("<h2 />").text( options.title || "Select a Project Avatar")
                        .appendTo($dialogWrapper);


                avatarPicker = JIRA.AvatarPicker.createUniversalAvatarPicker({
                    projectKey: options.projectKey,
                    projectId: options.projectId,
                    defaultAvatarId: options.defaultAvatarId,
                    initialSelection: lastSelection,
                    avatarType: options.avatarType,
                    avatarSize: options.avatarSize,
                    select: function (avatar, src, implicit) {
                        lastSelection = String(avatar.getId());

                        if (options.select) {
                            options.select.apply(this, arguments);
                        }
                        if (!implicit) {
                            projectAvatarDialog.hide();
                        }
                    }
                });

                avatarPicker.render(function (content) {
                    $dialogWrapper.append(content);
                    ready($dialogWrapper);
                });
            }
        });

        projectAvatarDialog._focusFirstField = function () {};
    };

    /**
     * Creates a project avatar picker dialog
     *
     * @param {Object} options
     * @param {HTMLElement | String} options.trigger - element that when clicked will bring up dialog
     * @param {String} options.projectKey
     * @param {String} options.projectId
     */
    JIRA.createProjectAvatarPickerDialog = function (options) {
        var projectAvatarDialog = new JIRA.FormDialog({
            trigger: options.trigger,
            id: "project-avatar-picker",
            width: 600,
            stacked: true,
            content: function (ready) {

                var avatarPicker,
                    $dialogWrapper;

                $dialogWrapper = $('<div id="projectavatar-content-wrapper"/>');

                $("<h2 />").text("Select a Project Avatar")
                        .appendTo($dialogWrapper);


                avatarPicker = JIRA.AvatarPicker.createProjectAvatarPicker({
                    projectKey: options.projectKey,
                    projectId: options.projectId,
                    defaultAvatarId: options.defaultAvatarId,
                    select: function (avatar, src, implicit) {
                        if (options.select) {
                            options.select.apply(this, arguments);
                        }
                        if (!implicit) {
                            projectAvatarDialog.hide();
                        }
                    }
                });

                avatarPicker.render(function (content) {
                    $dialogWrapper.append(content);
                    ready($dialogWrapper);
                });
            }
        });

        projectAvatarDialog._focusFirstField = function () {};
    };

    var avatarPickerData = WRM.data.claim("jira.webresources:avatar-picker.data");

    /**
     * Creates a project avatar picker dialog
     *
     * @param {Object} options
     * @param {HTMLElement | String} options.trigger - element that when clicked will bring up dialog
     * @param {String} options.projectKey
     * @param {String} options.projectId
     */
    JIRA.createUserAvatarPickerDialog = function (options) {

        if (avatarPickerData && avatarPickerData.isEnabled) {
            // SW-1977 - Defer and redirect to the Atlassian ID version.
            $(options.trigger).click(function(e) {
                var href = AJS.contextPath() + avatarPickerData.url;
                var separator = href.indexOf("?") > -1 ? "&" : "?";
                href += separator + "continue=" + encodeURIComponent(window.location.href);
                e.preventDefault();
                e.stopPropagation();
                AJS.reloadViaWindowLocation(href);
            });
            return;
        }

        var userAvatarDialog = new JIRA.FormDialog({
            trigger: options.trigger,
            id: "user-avatar-picker",
            width: 600,
            stacked: true,
            content: function (ready) {

                var avatarPicker,
                    $dialogWrapper;

                $dialogWrapper = $('<div id="useravatar-content-wrapper"/>');

                $("<h2 />").text("Select a User Avatar")
                        .appendTo($dialogWrapper);


                avatarPicker = JIRA.AvatarPicker.createUserAvatarPicker({
                    username: options.username,
                    defaultAvatarId: options.defaultAvatarId,
                    select: function (avatar, src, implicit) {

                        if (options.select) {
                            options.select.apply(this, arguments);
                        }

                        $(".avatar-image").attr("src", src);

                        if (!implicit) {
                            userAvatarDialog.hide();
                        }
                    }
                });

                avatarPicker.render(function (content) {
                    $dialogWrapper.append(content);
                    ready($dialogWrapper);
                });
            }
        });
    };

    // initialize user picker dialog
    $(function () {
        JIRA.createUserAvatarPickerDialog({
            trigger: "#user_avatar_image",
            username: $("#avatar-owner-id").text(),
            defaultAvatarId: $("#default-avatar-id").text()
        });
    });

})(window.jQuery);
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/GravatarUtil.js' */
/**
 * Helper methods for showing Gravatar-related help text.
 */
;(function() {
    AJS.namespace('JIRA.GravatarUtil');
    JIRA.GravatarUtil.showGravatarHelp = function(data) {
        // response is in the form of  { entry: [] }
        if (typeof(data) !== 'undefined' && typeof(data.entry) !== 'undefined') {
            // hide the "sign up" text and show the "log in" text
            AJS.$('.gravatar-signup-text').addClass('hidden');
            AJS.$('.gravatar-login-text').removeClass('hidden');
        }
    };

    var displayGravatarHelp = function() {
        var gravatarJsonUrl = AJS.$('#gravatar_json_url');
        if (gravatarJsonUrl.length) {
            // use JSONP to determine whether the user has a Gravatar
            AJS.$.ajax(gravatarJsonUrl.val(), {
                dataType: 'jsonp',
                success: JIRA.GravatarUtil.showGravatarHelp
            });
        }
    };

    AJS.$(document).ready(function() {
        if (AJS.$('#gravatar_help_params')) {
            displayGravatarHelp();
        }
    });
}());
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarPicker.soy' */
// This file was automatically generated from AvatarPicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.AvatarPicker.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.AvatarPicker == 'undefined') { JIRA.Templates.AvatarPicker = {}; }


JIRA.Templates.AvatarPicker.picker = function(opt_data, opt_ignored) {
  var output = '<form class="jira-avatar-upload-form aui top-label" action="#"><input name="id" value="10000" type="hidden" ><input name="pid" value="10000" type="hidden" ><div class="field-group"><label for="jira-avatar-uploader">' + soy.$$escapeHtml("Upload a new avatar") + '</label><input type="file" class="ignore-inline-attach" name="avatar" id="jira-avatar-uploader"/><div class="error"></div></div></form><div class="form-body"><ul class="jira-avatars">';
  var avatarList6 = opt_data.avatars.system;
  var avatarListLen6 = avatarList6.length;
  for (var avatarIndex6 = 0; avatarIndex6 < avatarListLen6; avatarIndex6++) {
    var avatarData6 = avatarList6[avatarIndex6];
    output += '<li class="jira-avatar jira-system-avatar ' + ((avatarData6.isSelected) ? 'jira-selected-avatar' : '') + '" title="Select this Avatar" data-id="' + soy.$$escapeHtml(avatarData6.id) + '"><button id="select-avatar-button" data-id="' + soy.$$escapeHtml(avatarData6.id) + '" class="jira-icon-button" title="' + soy.$$escapeHtml("Select this Avatar") + '"><img id="avatar-' + soy.$$escapeHtml(avatarData6.id) + '" src="' + soy.$$escapeHtml(avatarData6.src) + '" width="' + soy.$$escapeHtml(avatarData6.width) + '" height="' + soy.$$escapeHtml(avatarData6.height) + '" alt="' + soy.$$escapeHtml("Select this Avatar") + '"/></button></li>';
  }
  var avatarList29 = opt_data.avatars.custom;
  var avatarListLen29 = avatarList29.length;
  for (var avatarIndex29 = 0; avatarIndex29 < avatarListLen29; avatarIndex29++) {
    var avatarData29 = avatarList29[avatarIndex29];
    output += '<li class="jira-avatar jira-custom-avatar ' + ((avatarData29.isSelected) ? 'jira-selected-avatar' : '') + '" title="Select this avatar" data-id="' + soy.$$escapeHtml(avatarData29.id) + '"><button id="select-avatar-button" data-id="' + soy.$$escapeHtml(avatarData29.id) + '" class="jira-icon-button" title="' + soy.$$escapeHtml("Select this Avatar") + '"><img id="avatar-' + soy.$$escapeHtml(avatarData29.id) + '" src="' + soy.$$escapeHtml(avatarData29.src) + '" width="' + soy.$$escapeHtml(avatarData29.width) + '" height="' + soy.$$escapeHtml(avatarData29.height) + '" alt="' + soy.$$escapeHtml("Select this Avatar") + '" /></span><button class="jira-delete-avatar jira-icon-button" data-id="' + soy.$$escapeHtml(avatarData29.id) + '" title="' + soy.$$escapeHtml("Delete this Avatar") + '">' + soy.$$escapeHtml("Delete this Avatar") + '</button></li>';
  }
  output += '</ul></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.AvatarPicker.picker.soyTemplateName = 'JIRA.Templates.AvatarPicker.picker';
}


JIRA.Templates.AvatarPicker.imageEditor = function(opt_data, opt_ignored) {
  return '<form id="avataror" class="jira-avatar-cropper-form aui" action="/jira/secure/project/AvatarPicker.jspa"><input type="hidden" name="cropperOffsetX" id="avatar-offsetX" value="' + soy.$$escapeHtml(opt_data.cropperOffsetX) + '"><input type="hidden" name="cropperOffsetY" id="avatar-offsetY" value="' + soy.$$escapeHtml(opt_data.cropperOffsetY) + '"><input type="hidden" name="cropperWidth" id="avatar-width"  value="' + soy.$$escapeHtml(opt_data.cropperWidth) + '"><div class="jira-avatar-cropper-header"><p>' + soy.$$escapeHtml("Please select which part of the uploaded image you wish to use as the avatar.") + '</p></div><div class="form-body"><div class="avataror"><img src="' + soy.$$escapeHtml(opt_data.url) + '" height="300" /></div></div><div class="form-footer buttons-container"><div class="buttons"><input type="submit" class="aui-button aui-button-primary" value="' + soy.$$escapeHtml("Confirm") + '"><a class="aui-button aui-button-link cancel" href="#">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form>';
};
if (goog.DEBUG) {
  JIRA.Templates.AvatarPicker.imageEditor.soyTemplateName = 'JIRA.Templates.AvatarPicker.imageEditor';
}
;
;
/* module-key = 'jira.webresources:avatar-picker-trigger', location = '/includes/jira/admin/initAvatarPickerTrigger.js' */
(function () {


    var AvatarPickerContentRetriever = AJS.ContentRetriever.extend({

        init: function (avatarPicker) {
            this.avatarPicker = avatarPicker;
        },

        content: function (finished) {
            this.avatarPicker.render(function (el) {
                finished(jQuery("<div />").html(el));
            });
        },
        cache: function () {
            return false;
        },
        isLocked: function () {},
        startingRequest: function () {},
        finishedRequest: function () {}

    });


    var InlineAvatarPicker = AJS.InlineLayer.extend({

        init: function (options) {
            var instance = this;
            this.avatarPicker = JIRA.AvatarPicker.createProjectAvatarPicker({
                projectId: options.projectId,
                projectKey: options.projectKey,
                defaultAvatarId: options.defaultAvatarId,
                select: function (avatar, src, implicit) {
                    if (options.select) {
                        options.select.apply(this, arguments);
                    }
                    if (!implicit) {
                        instance.hide();
                    }

                    instance.offsetTarget().attr("src", src);
                    instance.offsetTarget().trigger("AvatarSelected");
                }
            });

            options.contentRetriever = new AvatarPickerContentRetriever(this.avatarPicker);

            jQuery(this.avatarPicker.imageEditor).bind(JIRA.AvatarPicker.ImageEditor.LOADED, function () {
                // todo: need to use prop() instead of attr() in master
                instance.setWidth(instance.layer().attr("scrollWidth"));
            });

            this._super(options);

            // Wrap the image in a little box to manage its appearance.
            var $triggerImg = this.offsetTarget();
            var $triggerContainer = jQuery("<span class='jira-avatar-picker-trigger'></span>");
            $triggerContainer.insertBefore($triggerImg).append($triggerImg);

            this._assignEvents("offsetTarget", $triggerContainer);

        },
        _events: {
            offsetTarget: {
                click: function (e) {
                    this.show();
                }
            }
        }
    });


    function initProjectAvatarPicker(ctx) {
        var trigger = jQuery(".jira-avatar-picker-trigger");
        var triggerImg = jQuery(".jira-avatar-picker-trigger img, img.jira-avatar-picker-trigger", ctx);
        var avatarIdField = jQuery(ctx).find("#avatar-picker-avatar-id");
        var avatarIconurlField = jQuery(ctx).find("#avatar-picker-iconurl");
        var avatarTypeElement = jQuery(ctx).find("#avatar-type");
        if ("" === avatarTypeElement.text()) return;
        JIRA.createUniversalAvatarPickerDialog({
            trigger: trigger,
            title: jQuery(ctx).find("#avatar-dialog-title").text(),
            projectId: jQuery(ctx).find("#avatar-owner-id").text(),
            projectKey: jQuery(ctx).find("#avatar-owner-key").text(),
            defaultAvatarId: jQuery(ctx).find("#default-avatar-id").text(),
            initialSelection: avatarIdField.val(),
            avatarSize: JIRA.Avatar.getSizeObjectFromName(jQuery(ctx).find("#avatar-size").text()),
            avatarType: avatarTypeElement.text(),
            select: function (avatar, src) {
                triggerImg.attr("src", src);
                avatarIconurlField.val(src);
                avatarIdField.val(avatar.getId());
            }
        });
    }

    function initProjectInlineAvatarPicker(ctx) {
        var $triggerImg = jQuery(".jira-inline-avatar-picker-trigger", ctx);

        if ($triggerImg.length) {
            new InlineAvatarPicker({
                offsetTarget: $triggerImg,
                projectId: jQuery(ctx).find("#avatar-owner-id").text(),
                projectKey: jQuery(ctx).find("#avatar-owner-key").text(),
                defaultAvatarId: jQuery(ctx).find("#default-avatar-id").text(),
                alignment: AJS.LEFT,
                width: 420, // Fits 7 avatars + the OSX choose file dialog min width.
                allowDownsize: true
            });
        }

    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initProjectAvatarPicker(context);
            initProjectInlineAvatarPicker(context);
        }
    });

})();;
;
/* module-key = 'jira.webresources:croneditor', location = '/includes/js/cron/croneditor.js' */
/*
Renders an element visible to the user
*/
function hideCronEdit(elementid)
{
    document.getElementById(elementid).style.display = 'none';
}

/*
Renders an element invisible to the user
*/
function showCronEdit(elementid)
{
    document.getElementById(elementid).style.display = '';
}

function toggleFrequencyControl(paramPrefix, setOriginal)
{
    var select = document.getElementById(paramPrefix + "interval");
    if(select.value == 0)
    {
        switchToOnce(paramPrefix, setOriginal);
    }
    else
    {
        switchToMany(paramPrefix, setOriginal);
    }
}

/*
Toggles the frequency controls to match 'once per day' mode
*/
function switchToOnce(paramPrefix, setOriginal)
{
    //make sure the frequency select is set correctly
    //set state
    hideCronEdit(paramPrefix + "runMany");
    showCronEdit(paramPrefix + "runOnce");
    if (setOriginal)
    {
        timesOnce[paramPrefix] = true;
    }
}

/*
Toggles the frequency controls to match 'many per day' mode
*/
function switchToMany(paramPrefix, setOriginal)
{
    //set state
    hideCronEdit(paramPrefix + "runOnce");
    showCronEdit(paramPrefix + "runMany");
    if (setOriginal)
    {
        timesOnce[paramPrefix] = false;
    }
}

function switchToDaysOfMonth(paramPrefix)
{
    hideCronEdit(paramPrefix + 'daysOfWeek');
    showCronEdit(paramPrefix + 'daysOfMonth');
    showCronEdit(paramPrefix + 'freqDiv');
    hideCronEdit(paramPrefix + 'innerFreqDiv');
    hideCronEdit(paramPrefix + 'advanced');
    switchToOnce(paramPrefix, false);
}

function switchToDaysOfWeek(paramPrefix)
{
    showCronEdit(paramPrefix + 'daysOfWeek');
    hideCronEdit(paramPrefix + 'daysOfMonth');
    showCronEdit(paramPrefix + 'freqDiv');
    showCronEdit(paramPrefix + 'innerFreqDiv');
    hideCronEdit(paramPrefix + 'advanced');
    switchToOriginal(paramPrefix);
}

function switchToDaily(paramPrefix)
{
    hideCronEdit(paramPrefix + 'daysOfWeek');
    hideCronEdit(paramPrefix + 'daysOfMonth');
    showCronEdit(paramPrefix + 'freqDiv');
    showCronEdit(paramPrefix + 'innerFreqDiv');
    hideCronEdit(paramPrefix + 'advanced');
    switchToOriginal(paramPrefix);
}

function switchToAdvanced(paramPrefix)
{
    hideCronEdit(paramPrefix + 'daysOfWeek');
    hideCronEdit(paramPrefix + 'daysOfMonth');
    hideCronEdit(paramPrefix + "runOnce");
    hideCronEdit(paramPrefix + "runMany");
    hideCronEdit(paramPrefix + 'freqDiv');
    showCronEdit(paramPrefix + 'advanced');

}

function switchToOriginal(paramPrefix)
{
    if (timesOnce[paramPrefix])
    {
        switchToOnce(paramPrefix, false);
    }
    else
    {
        switchToMany(paramPrefix, false);
    }
}
;
;
/* module-key = 'com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue-bootstrap', location = 'js/init/create-bootstrap-wrm.js' */
require([
    'jquery',
    'underscore',
    'wrm/require',
    'quick-edit/util/loading-indicator',
    'jira/ajs/keyboardshortcut/keyboard-shortcut-toggle'
], function (
    jQuery,
    _,
    wrmRequire,
    LoadingIndicator,
    KeyboardShortcutToggle
) {
    var showLoadingIndicator = function () {
        KeyboardShortcutToggle.disable();
        LoadingIndicator.showLoadingIndicator();
    };
    var hideLoadingIndicator = function () {
        LoadingIndicator.hideLoadingIndicator(true);
        KeyboardShortcutToggle.enable();
    };

    var subtaskTrigger;

    var createIssueDialogLoading = false;
    jQuery(document).on("simpleClick", ".create-issue, .create-issue-type", function(e) {
        e.preventDefault();
        if( !createIssueDialogLoading ) {
            createIssueDialogLoading = true;
            showLoadingIndicator();
            var resourceKey = 'wr!com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue';
            var wrmRequireDeferred = wrmRequire([resourceKey]);
            wrmRequireDeferred.then(onDone.bind(undefined, e), function onFail() {
                hideLoadingIndicator();
                createIssueDialogLoading = false;
            });
        }
    });
    var onDone = function (e) {
        var InitCreateDialogs = require('quick-edit/init/create');
        InitCreateDialogs.initIssueDialog(e);

        KeyboardShortcutToggle.enable();
        createIssueDialogLoading = false;
    };

jQuery(function () {
    subtaskTrigger = document.getElementById("stqc_show");

    // remove old subtask form
    if (subtaskTrigger) {
        subtaskTrigger.onclick = null;
    }
});

    var createSubtaskDialogLoading = false;
    jQuery(document).on("simpleClick", ".issueaction-create-subtask", function(e) {
        e.preventDefault();
        if (!createSubtaskDialogLoading) {
            createSubtaskDialogLoading = true;
            showLoadingIndicator();
            var resourceKey = 'wr!com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue';
            var wrmRequireDeferred = wrmRequire([resourceKey]);
            wrmRequireDeferred.then(onDoneSubtask, function onFail() {
                hideLoadingIndicator();
                createSubtaskDialogLoading = false;
            });
        }
    });
    var onDoneSubtask = function (e) {
        var InitCreateDialogs = require('quick-edit/init/create');
        InitCreateDialogs.initSubtaskDialog(e);

        KeyboardShortcutToggle.enable();
        createSubtaskDialogLoading = false;
    }
});
;
;
/* module-key = 'jira.webresources:jira-page-atl-prefetch', location = '/includes/jira/page/prefetch.js' */
define('jira/page/atl/prefetch', [
    'jira/util/data/meta',
    'jira/data/local-storage',
    'jira/ajs/dark-features',
    'jquery'
], function definePrefetchResource(meta,
    storage,
    darkFeatures,
    jQuery
) {
    /**
     * A module for pre-fetching resources for given page before it is really visited.
     * <link rel="prefetch" /> is used to instruct browser which resources to pre download.
     * Currently used to prefetch view issue resources.
     * @exports jira/issue/resources-prefetch
     */
    'use strict';

    var SESSION_KEY = 'jira.issue.prefetch.last.superbatch';
    var stateToken = _getStateToken();

    //
    // Private functions
    //
    function _getStateToken() {
        //lets use last super batch url as token with date as browser most probably removed entries from cache
        var now = new Date();
        var dateStr = now.getFullYear().toString() + now.getMonth().toString() + now.getDate().toString();
        var superbatch = jQuery('head > script').filter(function findSuperbatch(a, b) {return b.src.indexOf('/_super') > 0;});
        return (superbatch.length > 0 ? superbatch[0].src : 'empty') + dateStr;

    }

    function _addPrefetchTag(url) {
        jQuery('<link />', {
            rel: 'prefetch',
            href: url
        }).appendTo('head');
    }

    /**
     * @param {Object} issueMenuData - data for view issue menu.
     * @param {Object} [issueMenuData.sections] - optional section in view issue menu.
     */
    function _getLastIssueFromMenu(issueMenuData) {
        var sections = issueMenuData.sections;
        if (!sections) {
            return;
        }
        var recentIssues = sections.filter(function filterMenu(menuItem) {return menuItem.id === 'issues_history_main';});
        if (recentIssues.length && recentIssues[0].items.length !== 0) {
            var lastIssue = recentIssues[0].items[0];
            return lastIssue.url;
        }
    }

    function _addPrefetchForRegex(response, regex) {
        var matchResult;
        while (matchResult = regex.exec(response)) {
            var url = matchResult[1].replace(/&amp;/g, '&');
            _addPrefetchTag(url);
        }
    }

    function _rememberFetchState() {
        storage.setItem(SESSION_KEY, stateToken);

    }

    function _parsePageAndInsertLinks(data) {
        _addPrefetchForRegex(data, /<script.+?src="(.+?)".+?<\/script>/g);
        _addPrefetchForRegex(data, /<link.+?rel="stylesheet".+?href="(.+?)".+?>/g);
        _rememberFetchState();
    }

    function _shouldFetchResources() {
        if (!darkFeatures.isEnabled('jira.issue.prefetch')) {
            //don't fetch if dark feature is not enabled
            return false;
        }
        if (jQuery('#isNavigator').length === 1) {
            //don't fetch on navigator as this has the same resources as issue
            _rememberFetchState();
            return false;
        }
        else if (meta.get('issue-key')) {
            //don't fetch on issue page
            _rememberFetchState();
            return false;
        }
        else {
            //fetch if current state token is different for stored in local storage
            return stateToken !== storage.getItem(SESSION_KEY);
        }
    }
    function _prefetchResourcesForLastIssue(data) {
        var issueUrl = _getLastIssueFromMenu(data);
        if (issueUrl) {
            prefetchResourcesForUrl(issueUrl);
        }
    }
    //
    // Public API functions
    //

    function prefetchResourcesForUrl(url) {
        jQuery.get(url, _parsePageAndInsertLinks);
    }


    function prefetchViewIssueResources() {
        if (_shouldFetchResources()) {
            //only execute if we are on view issue context and
            jQuery.ajax(
                {
                    url: AJS.contextPath() + '/rest/api/1.0/menus/find_link?inAdminMode=false',
                    dataType: 'json'
                }).done(_prefetchResourcesForLastIssue);
        }
    }

    return {
        /**
         * Adds prefetch tags for resources included by page at given URL
         * @param {String} url
         */
        prefetchResourcesForUrl: prefetchResourcesForUrl,
        /**
         * Adds prefetch tags for view issue resources.
         * It will work only if user has visited any issue in the past so it is accessible from latest issues menu.
         */
        prefetchViewIssueResources: prefetchViewIssueResources
    };
});
;
;
/* module-key = 'jira.webresources:init-jira-page-atl-prefetch', location = '/includes/jira/page/initPrefetch.js' */
require(['jira/page/atl/prefetch', 'jquery'], function executePrefetch(resourcePrefetch, $) {
    $(window).on('load', resourcePrefetch.prefetchViewIssueResources.bind(resourcePrefetch));
});
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:update-plugin-banner-resources', location = 'js/banner/update-hipchat-link-banner.js' */
(function ($) {
    AJS.toInit(function () {

        var HIPCHAT_ADMIN_BANNER_COOKIE_KEY = "HIPCHAT_ADMIN_BANNER_DISMISS_2";
        var warningMsg;

        if (!isHipChatConfigurationPage() && AJS.Meta.get("is-admin") && !isAlreadyDismissed()) {

            $.ajax({
                url: AJS.contextPath() + '/rest/hipchat/integrations/1.0/configuration/status',
                dataType: 'json',
                cache: false
            }).done(function (data) {

                if (data.requiresManualInstallation || data.v1) {
                    warningMsg = showWarningMsg(data);
                }
            });

        }

        function showWarningMsg(data) {
            var html = JIRA.Templates.HipChat.Banner.updateHipChatLink({removeV1link: !data.v2 && data.v1});
            var warningMsg = JIRA.Messages.showWarningMsg(html);
            $(document).on("click", "#remove-hipchat-v1-link", removeHipChatLink);
            $(document).on("aui-flag-close", ".aui-flag", dismissPopUp);
            return warningMsg;
        }

        function isHipChatConfigurationPage() {
            return window.location.toString().indexOf("/plugins/servlet/hipchat/configure") > 0;
        }

        function dismissPopUp(e) {

            // The aui flag sends all the close events, that is why we need to filter
            // to the flag that has my container
            if ($(e.target).find(".hipchat-update-banner").length > 0) {
                AJS.Cookie.save(HIPCHAT_ADMIN_BANNER_COOKIE_KEY, true);
            }
        }

        function isAlreadyDismissed() {
            return AJS.Cookie.read(HIPCHAT_ADMIN_BANNER_COOKIE_KEY) == "true";
        }


        function removeHipChatLink(e) {
            e.preventDefault();

            $.ajax({
                url: AJS.contextPath() + '/rest/hipchat/integrations/1.0/configuration/v1',
                cache: false,
                type: "DELETE"
            }).error(function (error) {

                if(warningMsg){
                    warningMsg.hide();
                }

                JIRA.Messages.showErrorMsg(AJS.format("We couldn\'\'t find your integration. If the problem persists, contact Atlassian Support.\u003cbr/\u003e Error Status [{0}]", error.status));

            }).done(function (data) {

                if(warningMsg){
                    warningMsg.hide();
                }

                JIRA.Messages.showSuccessMsg("Integration has been removed successfully");
            });
        }
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:update-plugin-banner-resources', location = 'soy/banner/update-hipchat-link-banner.soy' */
// This file was automatically generated from update-hipchat-link-banner.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.Banner.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.Banner == 'undefined') { JIRA.Templates.HipChat.Banner = {}; }


JIRA.Templates.HipChat.Banner.updateHipChatLink = function(opt_data, opt_ignored) {
  return '<div class="hipchat-update-banner"><b>' + soy.$$escapeHtml("HipChat Integration is out of date") + '</b><p>' + soy.$$escapeHtml("Update to take full advantage of the latest features.") + '</p><p/><a href="' + soy.$$escapeHtml("/jira" + '/plugins/servlet/hipchat/configure') + '">' + soy.$$escapeHtml("Update Now!") + '</a>' + ((opt_data.removeV1link) ? '<a id="remove-hipchat-v1-link">' + soy.$$escapeHtml("Remove Integration") + '</a>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Banner.updateHipChatLink.soyTemplateName = 'JIRA.Templates.HipChat.Banner.updateHipChatLink';
}
;
;
/* module-key = 'com.atlassian.labs.plugins.quickreload.reloader:qr-batched-mode-twizzler', location = 'batchedmode/quickreload-batchedmode-switcher.js' */
;(function($, AJS) {
    if(!$) {
        console.warn("Could not find jQuery, QuickReload batch mode switcher not enabled");
        return;
    }
    if(!AJS) {
        console.warn("Could not find AJS, QuickReload batch mode switcher not enabled");
        return;
    }
    if(!$.isFunction(AJS.whenIType)) {
        console.warn("Could not find AJS.whenIType, QuickReload batch mode switcher not enabled");
        return;
    }

    //From underscore
    var debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;

        var later = function() {
            var last = Date.now() - timestamp;

            if (last < wait && last >= 0) {
                timeout = setTimeout(later, wait - last);
            } else {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                    if (!timeout) context = args = null;
                }
            }
        };

        return function() {
            context = this;
            args = arguments;
            timestamp = Date.now();
            var callNow = immediate && !timeout;
            if (!timeout) timeout = setTimeout(later, wait);
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }

            return result;
        };
    };

    var searchForContextPath = function() {
        if($.isFunction(AJS.contextPath)) {
            return AJS.contextPath();
        } else if (AJS.Meta && $.isFunction(AJS.Meta.get)) {
            try {
                return AJS.Meta.get("context-path");
            } catch(ignored) {}
        }

        return null;
    };

    var getCurrentBatchModeStateUrl = function(contextPath) {
        return contextPath + "/rest/qr/1.0/batching";
    };

    var getUpdateBatchModeUrl = function(contextPath, enableBatching) {
        return contextPath + "/rest/qr/1.0/batching/setState?enabled=" + !!enableBatching;
    };

    var tryGrabAuiFlag = function() {
        try {
            if($.isFunction(require)) {
                return require("aui/flag");
            }
        } catch(notFoundException) {}

        return null;
    };

    var getToastSuccessTitle = function(newBatchedModeState) {
        if(!!newBatchedModeState) {
            return "Production mode";
        } else {
            return "Dev mode";
        }
    };

    var getToastSuccessMessageHtml = function(newBatchedModeState) {
        if(!!newBatchedModeState) {
            return "Web resource batching and caching enabled";
        } else {
            return "Disabled web resource batching and caching";
        }
    };

    var toastSuccess = function(title, messageHtml) {
        toastMessage(title, messageHtml, true);
    };

    var toastError = function(title, messageHtml) {
        toastMessage(title, messageHtml, false);
    };

    var messageId = "quickreload-flag";
    var toastMessage = function(title, messageHtml, isSuccess) {
        var auiFlag = tryGrabAuiFlag();
        if(auiFlag) {
            auiFlag({
                type: !!isSuccess ? "success" : "error",
                title: title,
                body: messageHtml,
                persistent: false,
                close: "auto"
            });
        } else if(AJS.messages && $.isFunction(AJS.messages.success)) {
            var messageFunc;
            if(!!isSuccess) {
                messageFunc = AJS.messages.success;
            } else {
                messageFunc = AJS.messages.error;
            }

            var $message = $(messageFunc.call(AJS.messages, {
                title: title,
                body: messageHtml,
                id: messageId,
                fadeout: true,
                delay: 3000
            }));

            $("#" + messageId).remove();
            $("body").append($message);
        } else {
            alert(title);
        }
    };

    $(function() {
        var contextPath = searchForContextPath();
        if(!contextPath) {
            console.warn("Failed to determine context path, QuickReload batch mode switcher not enabled");
            return;
        }

        var batchingEnabledState = false;
        //Fetch initial state
        $.get(getCurrentBatchModeStateUrl(contextPath)).done(function(data) {
            batchingEnabledState = data.batchingEnabled;
        });

        var debouncedToggleBatchingCallback = debounce(function() {
            $.get(getUpdateBatchModeUrl(contextPath, !batchingEnabledState))
                .done(function(data) {
                    batchingEnabledState = data.batchingEnabled;
                    var successTitle = getToastSuccessTitle(batchingEnabledState);
                    var successMessageHtml = getToastSuccessMessageHtml(batchingEnabledState);
                    toastSuccess(successTitle, successMessageHtml);
                })
                .fail(function(xhr, textStatus) {
                    if(textStatus !== "abort") {
                        var batchingStateStr = batchingEnabledState ? "enabled" : "disabled";
                        toastError("Failed to update batch mode state (current state: " + batchingStateStr + ")");
                    }

                });
        }, 2000, true);

        AJS.whenIType("b").execute(debouncedToggleBatchingCallback);
    });
})((AJS && AJS.$) || $, AJS);;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:newsletter-signup-tip', location = 'static/components/newsletter/NewsletterSignup.soy' */
// This file was automatically generated from NewsletterSignup.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }


JIRA.Templates.newsletterSignupTip = function(opt_data, opt_ignored) {
  return '<div><p>' + soy.$$escapeHtml(opt_data.description) + '</p>' + aui.form.form({action: '#', isTopLabels: true, extraClasses: 'insiders-signup-form', content: '' + aui.form.textField({id: 'jira-newsletter-user-email', placeholderText: '' + soy.$$escapeHtml("Email address"), value: opt_data.userEmail}) + aui.form.buttons({content: '' + aui.form.submit({type: 'primary', text: '' + soy.$$filterNoAutoescape("Sign me up")}) + aui.form.linkButton({text: '' + soy.$$escapeHtml("No thanks")})})}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.newsletterSignupTip.soyTemplateName = 'JIRA.Templates.newsletterSignupTip';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:newsletter-signup-tip', location = 'static/components/newsletter/NewsletterSignup.js' */
define('jira/newsletter/signuptip', [
    'jquery'
], function(
    $
) {

    // taken from setup-mac-util.js
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address without &
    var emailRegex = /^[a-zA-Z0-9.!#$%'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

    function validateEmail(email) {
        if (email.length > 255) {
            return false;
        }
        return emailRegex.test(email);
    }

    return {
        render : function (newsletterFormDetails, helpTipOptions) {
            var defaults = {
                anchor: "#user-options",
                isSequence: false,
                showCloseButton: false
            };

            if (newsletterFormDetails.isBusinessOnly) {
                defaults.id = "business-newsletter-signup-tip";
                defaults.title = "Atlassian for Business Teams";
                defaults.bodyHtml = JIRA.Templates.newsletterSignupTip({
                    userEmail: newsletterFormDetails.userEmail,
                    description: "Atlassian gets down to business. Get our view on productivity for business teams. You\'ll get business-related content, best practices and product announcements to unleash the potential in your marketing, HR, finance, legal and sales teams."
                });
            } else {
                defaults.id = "newsletter-signup-tip";
                defaults.title = "JIRA Insiders";
                defaults.bodyHtml = JIRA.Templates.newsletterSignupTip({
                    userEmail: newsletterFormDetails.userEmail,
                    description: "Stay up-to-date with the latest JIRA tips, tricks, and exclusive inside jokes. All this and more in JIRA Insiders, delivered every month from our inbox to yours."
                });
            }
            var tip = new AJS.HelpTip($.extend(defaults, helpTipOptions));
            if(tip.isDismissed()) {
                return;
            }

            tip.show();

            AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.shown" });

            var $body = $("body");
            $body.on("submit", "form.aui.insiders-signup-form", function (e) {
                e.preventDefault();

                var $form = $(this);
                $form.find(".error").remove();

                var $emailInput = $form.find("#jira-newsletter-user-email");
                var email = $emailInput.val();
                if (validateEmail(email)) {
                    $.ajax({
                        type: 'POST',
                        url: AJS.format(newsletterFormDetails.formUrl, encodeURI(email)),
                        dataType: 'json'
                    }).success(function() {
                        AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.submitted" });
                    }).error(function(xhr) {
                        AJS.trigger('analyticsEvent', {
                            name: "jira.newsletter.signuptip.error",
                            data: {
                                statusCode: xhr.status
                            }
                        });
                    });

                    if(newsletterFormDetails.userEmail !== email) {
                        AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.email.changed" });
                    }

                    tip.dismiss("newslettersubscribed");
                }
                else {
                    AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.email.validationerror" });
                    $emailInput.after(aui.form.fieldError({message: "Please enter a valid e-mail address."}));
                }
            });

            $body.on("click", "form.aui.insiders-signup-form a.cancel", function (e) {
                e.preventDefault();
                AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.dismissed" });
                tip.dismiss("newslettercancelled");
            });
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:newsletter-signup-tip', location = 'static/components/newsletter/initNewsletterSignup.js' */
define('jira/newsletter/init-signup', [
    'jira/newsletter/signuptip'
], function (NewsletterSignup) {
    return function () {
        var newsletterSignupData = WRM.data.claim("com.atlassian.jira.jira-header-plugin:newsletter-signup-tip.newsletterSignup");

        if (newsletterSignupData && newsletterSignupData.showNewsletterTip) {
            NewsletterSignup.render({
                userEmail: newsletterSignupData.userEmail,
                formUrl: newsletterSignupData.formUrl,
                isBusinessOnly: newsletterSignupData.isBusinessOnly
            });
        }
    };
});

require([
    'jquery',
    'jira/newsletter/init-signup'
], function ($,
    InitNewsletterSignup) {
    $(InitNewsletterSignup);
});

;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/dialog.js' */
define('jira/admin-helper/dialog', [
    'jquery',
    'jira/dialog/dialog',
    'jira/focus/set-focus'
], function (
    $,
    Dialog,
    setFocus
) {

    return Dialog.extend({

        _getDefaultOptions: function () {
            return $.extend(this._super(), {
                cached: false,
                widthClass: "large",
                stacked: true
            });
        },

        defineResources: function() {
            this._super();
            this.requireResource("com.atlassian.jira.plugins.jira-admin-helper-plugin:whereismycf-resources");
        },

        decorateContent: function () {

            var instance = this;

            // init the close link
            this.get$popupContent().find(".cancel").click(function (e) {
                instance.hide();
                e.preventDefault();
            });
        },

        _onShowContent: function () {
            this._super();
            if (Dialog.current === this) {
                var triggerConfig = new setFocus.FocusConfiguration();
                triggerConfig.context = this.get$popup()[0];
                triggerConfig.parentElementSelectors = ['.form-body'];
                setFocus.pushConfiguration(triggerConfig);
                setFocus.triggerFocus();
            }
        },

        hide: function (undim) {

            if (this._super(undim) === false) {
                return false;
            }
            setFocus.popConfiguration();
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/notification-helper-init.js' */
require([
    'jquery',
    'jira/admin-helper/dialog',
    'jira/util/data/meta'
], function (
    $,
    Dialog,
    Meta
) {
    if (Meta.get("is-admin")) {

        $(document).delegate(".notificationhelper-trigger", "click", function (event) {
            event.preventDefault();
            new Dialog({
                id: "notification-helper-dialog",
                content: function content(callback) {
                    var dialog = this;
                    require(['jira/admin-helper/notification-helper/content-loader'],
                        function (ContentLoader) {
                            ContentLoader.loadContent(dialog, callback);
                        });
                }
            }).show();
        });
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/permission-helper-init.js' */
require([
    'jquery',
    'jira/admin-helper/dialog',
    'jira/util/data/meta'
], function (
    $,
    Dialog,
    Meta
) {
    if (Meta.get("is-admin")) {

        $(document).delegate(".permissionhelper-trigger", "click", function (event) {
            event.preventDefault();

            new Dialog({
                id: "permission-helper-dialog",
                content: function content(callback) {
                    var dialog = this;
                    require(['jira/admin-helper/permission-helper/content-loader'],
                        function (ContentLoader) {
                            ContentLoader.loadContent(dialog, callback);
                        });
                }
            }).show();
        });
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/whereismycf-init.js' */
require([
    'jquery',
    'jira/admin-helper/dialog',
    'jira/util/data/meta',
    'jira/dialog/dialog'
], function (
    $,
    Dialog,
    Meta,
    JiraDialog
) {
    if (Meta.get("is-admin")) {
        var LABEL = "Where is my field?";

        $(document).delegate(".whereismycf-trigger", "click", function (event) {
            event.preventDefault();
            new Dialog({
                id: "whereismycf-dialog",
                content: function content(callback) {
                    var dialog = this;
                    require(['jira/admin-helper/whereismycf/content-loader'],
                        function (ContentLoader) {
                            ContentLoader.loadContentForView(dialog, callback);
                        });
                }
            }).show();

        });
        // hook into the quick-edit
        $(document).bind("showLayer", function (event, control, hash) {
            if (control == "inlineDialog" && hash.popup.attr("id") == "inline-dialog-field_picker_popup") {
                if (hash.popup.find(".whereismycf-qfpicker-link").length == 0) {
                    var thelink = $("<a href='#' class='whereismycf-qfpicker-link'>" + LABEL + "</a>").appendTo(hash.popup.find(".qf-picker-header dl"));
                    thelink.click(function (event) {
                        event.preventDefault();
                        hash.hide();
                        eventsAndDecouplingInJavaScriptAreSoooAwesome();
                        var currentDialog = JiraDialog.current;
                        new Dialog({
                            id: "whereismycf-dialog",
                            content: function content(callback) {
                                var dialog = this;
                                require(['jira/admin-helper/whereismycf/content-loader'],
                                    function (ContentLoader) {
                                        ContentLoader.loadContentForEditAndCreate(dialog, currentDialog, callback);
                                    });
                            }
                        }).show();

                    });
                }
            }
        });

        function eventsAndDecouplingInJavaScriptAreSoooAwesome() {
            // we're doing this because LayerManager wants to outsmart the world by deciding what to hide and what not...
            // and InlineDialog (and everything else in AUI) wants to outsmart the world by applying stupid timeouts to everything...
            // but ultimately you can outsmart every smartass in the JS land just by setting global variables to null! BUAHAHAHAHAHAHA
            AJS.InlineDialog.current = null;
        }
    }
});;
;
/* module-key = 'com.atlassian.jira-core-project-templates:jira-core-project-templates-resources', location = '/soy/CoreProjectTemplates.soy' */
// This file was automatically generated from CoreProjectTemplates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.CoreTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }
if (typeof JIRA.Templates.ProjectTemplates.CoreTemplates == 'undefined') { JIRA.Templates.ProjectTemplates.CoreTemplates = {}; }


JIRA.Templates.ProjectTemplates.CoreTemplates.taskManagementInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Create simple tasks, organize them and get them done. You can use this project to manage your tasks or assign them to someone else.", projectTemplate: 'taskManagement'});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.taskManagementInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.taskManagementInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.projectManagementInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Create your tasks, organize and track their progress, and deliver your work on time. Estimations and time tracking allow you to report on where your project is at any stage.", projectTemplate: 'projectManagement'});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.projectManagementInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.projectManagementInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.processManagementInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Create your tasks and track them at every step, from start to finish. You can use this project to review documentation, approve expenses, or other processes.", projectTemplate: 'processManagement'});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.processManagementInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.processManagementInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.boardBetaInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Visualize work across your team with a board.", projectTemplate: 'projectManagement', issueTypesHtml: '' + JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType(null)});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.boardBetaInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.boardBetaInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog = function(opt_data, opt_ignored) {
  return '<div><div class="top-panel"><p>' + soy.$$escapeHtml(opt_data.description) + '</p></div><div class="left-panel"><h6>' + soy.$$escapeHtml("Issue Types") + '</h6><ul class="project-template-issuetype-list">' + ((opt_data.issueTypesHtml != null) ? soy.$$filterNoAutoescape(opt_data.issueTypesHtml) : JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType(null) + JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType(null)) + '</ul></div><div class="right-panel"><h6>' + soy.$$escapeHtml("Workflow") + '</h6><div class="workflow ' + soy.$$escapeHtml(opt_data.projectTemplate) + '"></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.issueType = function(opt_data, opt_ignored) {
  return '<li><span class="issuetype-list-label"><span class="issuetype-icon ' + soy.$$escapeHtml(opt_data.iconKey) + '"></span><span class="issuetype-name">' + soy.$$escapeHtml(opt_data.label) + '</span></span></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.issueType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.issueType';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.issueType({iconKey: 'task', label: "Task"});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.issueType({iconKey: 'subtask', label: "Sub-task"});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-confluence-plugin:issue-link-confluence-js', location = 'js/issuelink-confluence.js' */
/**
 * Initialises OAuth authentication for Confluence Application Links. Requires the following elements:
 * <div class="issue-link-applinks-authentication-message"></div>
 */
(function ($) {

    var settings = {
        getCurrentAppId: function (context) {
            return $("#issue-link-confluence-app-id", context).val();
        },
        shouldExecute: function (context) {
            return $("#confluence-page-link", context).length !== 0;
        },
        getIssueId: function (context) {
            return $("input[name=id]", context).val();
        }
    };

    JIRA.bind(JIRA.Events.NEW_PAGE_ADDED, function (e, context) {
        IssueLinkAppLinks.init(settings, context);
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-confluence-plugin:confluence-page-resource', location = 'js/ConfluencePageSearch.js' */
AJS.$(function ($) {
    var confluenceSearchDialog =  new JIRA.FormDialog({
        id: "confluence-page-search-dialog",
        trigger: "#confluence-page-link .confluence-search-trigger",
        widthClass: "large",
        height: "565px",
        content: function (render) {
            var dialog = this;
            JIRA.SmartAjax.makeRequest({
                url: contextPath + "/rest/confluenceIssueLink/1/confluence/applink",
                complete: function (xhr, textStatus, smartAjaxResult) {
                    if (smartAjaxResult.successful) {
                        var appLinks = smartAjaxResult.data.applicationLinks;
                        render(JIRA.Templates.ConfluencePageSearch.result({appLinks: appLinks}));

                        initAppLinks(dialog).done(function (context, helper) {
                            initSearchDialog(context, helper);
                            $("#link-search-text", context).focus();
                        });
                    } else {
                        AJS.messages.error("#search-results-table", {
                            body: "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.",
                            closeable: false
                        });
                        render();
                    }
                }
            });
        },
        submitHandler: function(e, callback){
            e.preventDefault();
            $("#search-panel-button").click().removeAttr("disabled");
            callback();
        }
    });

    function initSearchDialog($dialog, helper) {
        // Bind the select drop-down
        $("#confluence-app-link", $dialog).change(function () {
            var authenticationRequired = helper.selectServer($(this).val()).authenticationRequired;
            if (!authenticationRequired) {
                populateSpaces($dialog, $(this).val(), helper);
            }
            $("#search-results-table", $dialog).empty();

            // Any previous errors are not relevant to our new selection
            setSearchControlsEnabled(true, $dialog);
        });

        // Bind the search button
        $("#search-panel-button", $dialog).click(function () {
            $("#search-results-table", $dialog).empty();
            var searchText = $("#link-search-text", $dialog).val();
            searchText = $.trim(searchText);
            if (searchText) {
                doSearch(searchText, $dialog);
            } else {
                AJS.messages.info("#search-results-table", {
                    body: "Please enter search value.",
                    closeable: false
                });
            }

            return false;
        });
    }

    var spaceAjaxId = 0;
    function populateSpaces($context, appId, helper) {
        $("select#search-panel-space", $context).html(JIRA.Templates.ConfluencePageSearch.allSpacesOption());
        var myAjaxId = ++spaceAjaxId;
        JIRA.SmartAjax.makeRequest({
            url: contextPath + "/rest/confluenceIssueLink/1/confluence/space?appId=" + appId,
            complete: function (xhr, textStatus, smartAjaxResult) {
                if (myAjaxId !== spaceAjaxId) {
                    return;
                }
                if (smartAjaxResult.successful) {
                    var spaces = smartAjaxResult.data.spaces;
                    $("select#search-panel-space", $context).html(JIRA.Templates.ConfluencePageSearch.spaceOptions({spaces: spaces}));
                } else {
                    if (smartAjaxResult.status === 401) {
                        helper.setAuthenticationRequired(appId, true);
                    } else {
                        // Since we have an error, prevent the user from submitting a search
                        setSearchControlsEnabled(false, $context);

                        var msg;
                        if (smartAjaxResult.status === 403) {
                            msg = "Content on the Confluence site could not be accessed because the Confluence server\'s \'Remote API\' feature is disabled. The Confluence system administrator must enable this \'Remote API\' feature for JIRA to successfully access this content.";
                        } else {
                            msg = "Unable to gather information from the selected Confluence instance.";
                        }
                        AJS.messages.error("#search-results-table", {
                            body: msg,
                            closeable: false
                        });
                    }
                }
            }
        });
    }

    function setSearchControlsEnabled(enabled, $context) {
        if (enabled) {
            $("#link-search-text", $context).removeAttr("disabled");
            $("#search-panel-space", $context).removeAttr("disabled");
            $("#search-panel-button", $context).removeAttr("disabled");
        } else {
            $("#link-search-text", $context).attr("disabled", "disabled");
            $("#search-panel-space", $context).attr("disabled", "disabled");
            $("#search-panel-button", $context).attr("disabled", "disabled");
        }
    }

    function setLoadingIconVisible(visible, $context) {
        $("#link-search-loading", $context).toggleClass("hidden", !visible);
    }

    function doSearch(searchText, $context) {
        setLoadingIconVisible(true, $context);
        var appLinkId = $("#confluence-app-link", $context).val();
        var spaceKey = $("#search-panel-space option:selected", $context).val();
        JIRA.SmartAjax.makeRequest({
            url: contextPath + "/rest/confluenceIssueLink/1/confluence/search?query=" + searchText + "&appId=" + appLinkId + "&spaceKey=" + spaceKey + "&maxResults=10",
            complete: function (xhr, textStatus, smartAjaxResult) {
                setLoadingIconVisible(false, $context);
                if (smartAjaxResult.successful) {
                    var results = smartAjaxResult.data.result;
                    var resultHtml = JIRA.Templates.ConfluencePageSearch.resultsTable({results: results});
                    $("#search-results-table", $context).html(resultHtml);
                } else {
                    // This replicates the JIRA.SmartAjax.buildSimpleErrorContent method, but we can't use that because
                    // it mentions a JIRA instance.
                    var msg;
                    if (smartAjaxResult.hasData) {
                        msg = "The JIRA server was contacted but has returned an error response. We are unsure of the result of this operation.";
                    } else {
                        msg = "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.";
                    }
                    AJS.messages.error("#search-results-table", {
                        body: msg,
                        closeable: false
                    });
                }

                $("#confluence-searchresult tbody tr", $context).click(function () {
                    var linkUrl = $(this).children().first().data("url");
                    $("#confluence-page-url").val(linkUrl);

        ////        If we want to display the title in the 'description' area on the main dialog
        ////        var linkTitle = $(this).children().first().text();
        ////        $("#confluence-page-url").siblings(".description").text(linkTitle);

                    // Clear all error messages on the parent dialog, as we now have a newly selected URL
                    $("#link-issue-dialog .error").hide();

                    confluenceSearchDialog.hide();
                    $("#link-issue-dialog").show();
                    $("#confluence-page-url").focus().select();
                });
            }
        });
    }

    function initAppLinks(dialog) {
        var settings = {
            getCurrentAppId: function (context) {
                return $("#confluence-app-link", context).val();
            },
            shouldExecute: function (context) {
                return $("#confluence-app-link", context).length !== 0;
            },
            onAuthenticationSuccessCallback: function (context, currentAppId, helper) {
                populateSpaces(context, currentAppId, helper);
            },
            getIssueId: function (context) {
                return $("#confluence-page-link input[name=id]").val();
            }
        };

        return IssueLinkAppLinks.init(settings, dialog.$popup).done(function (context, helper) {
            populateSpaces(context, settings.getCurrentAppId(context), helper);
        });
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-confluence-plugin:confluence-page-resource', location = 'templates/dialog/searchresult.soy' */
// This file was automatically generated from searchresult.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ConfluencePageSearch.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ConfluencePageSearch == 'undefined') { JIRA.Templates.ConfluencePageSearch = {}; }


JIRA.Templates.ConfluencePageSearch.result = function(opt_data, opt_ignored) {
  var output = '<h2>' + soy.$$escapeHtml("Find a Confluence page") + '</h2><form class="aui search-form" id="confluence-page-search-form" action="#" method="post"><div class="field-group"><label for="confluence-app-link">' + soy.$$escapeHtml("Server") + ':</label>';
  if (opt_data.appLinks.length == 1) {
    output += '<span class="field-value">' + soy.$$escapeHtml(opt_data.appLinks[0].name) + '</span><input id="confluence-app-link" class="hidden" type="hidden" name="appId" value="' + soy.$$escapeHtml(opt_data.appLinks[0].id) + '"/>';
  } else {
    output += '<select id="confluence-app-link" class="select medium-field" name="appId">';
    var appLinkList17 = opt_data.appLinks;
    var appLinkListLen17 = appLinkList17.length;
    for (var appLinkIndex17 = 0; appLinkIndex17 < appLinkListLen17; appLinkIndex17++) {
      var appLinkData17 = appLinkList17[appLinkIndex17];
      output += '<option value="' + soy.$$escapeHtml(appLinkData17.id) + '">' + soy.$$escapeHtml(appLinkData17.name) + '</option>';
    }
    output += '</select>';
  }
  output += '</div><div class="issue-link-applinks-authentication-message applinks-message-bar"></div><div class="hidden"><input class="issue-link-applinks-application-type" type="hidden" value="com.atlassian.applinks.api.application.confluence.ConfluenceApplicationType"/></div><div class="issue-link-oauth-toggle field-group"><label for="link-search-text" id="linkSearch-label">' + soy.$$escapeHtml("Search") + ':</label><input id="link-search-text" type="text" tabindex="0" class="text" name="linkSearch" size="50" /> <select tabindex="0" class="search-space select" id="search-panel-space"><option value="">' + soy.$$escapeHtml("All Spaces") + '</option></select> <input type="submit" tabindex="0" class="aui-button" id="search-panel-button" value="' + soy.$$escapeHtml("Search") + '"/><span id="link-search-loading" class="icon loading throbber hidden"/></div><div class="message-panel hidden"></div><div id="search-results-table" class="data-table"></div><div class="buttons-container form-footer"><div class="buttons"><button class="aui-button aui-button-link cancel" id="confluence-link-cancel" title="' + soy.$$escapeHtml("Press Esc to close") + '">' + soy.$$escapeHtml("Close") + '</button></div></div></form>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.result.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.result';
}


JIRA.Templates.ConfluencePageSearch.resultsTable = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.results.length > 0) {
    output += '<table id="confluence-searchresult" class="aui"><thead><tr><th width="180px">' + soy.$$escapeHtml("Title") + '</th><th width="550px">' + soy.$$escapeHtml("Excerpt") + '</th></tr></thead><tbody>';
    var resultList44 = opt_data.results;
    var resultListLen44 = resultList44.length;
    for (var resultIndex44 = 0; resultIndex44 < resultListLen44; resultIndex44++) {
      var resultData44 = resultList44[resultIndex44];
      output += '<tr title="' + soy.$$escapeHtml(resultData44.title) + '"><td class="title" data-url="' + soy.$$escapeHtml(resultData44.url) + '">' + soy.$$escapeHtml(resultData44.title) + '</td><td class="excerpt">' + soy.$$escapeHtml(resultData44.excerpt) + '</td></tr>';
    }
    output += '</tbody></table>';
  } else {
    output += '<div class="aui-message info"><span class="aui-icon icon-info"></span><p>' + soy.$$escapeHtml("Search returned no results.") + '</p></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.resultsTable.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.resultsTable';
}


JIRA.Templates.ConfluencePageSearch.spaceOptions = function(opt_data, opt_ignored) {
  var output = '<option value="">' + soy.$$escapeHtml("All Spaces") + '</option>';
  var spaceList64 = opt_data.spaces;
  var spaceListLen64 = spaceList64.length;
  for (var spaceIndex64 = 0; spaceIndex64 < spaceListLen64; spaceIndex64++) {
    var spaceData64 = spaceList64[spaceIndex64];
    output += '<option value="' + soy.$$escapeHtml(spaceData64.key) + '">' + soy.$$escapeHtml(spaceData64.name) + '</option>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.spaceOptions.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.spaceOptions';
}


JIRA.Templates.ConfluencePageSearch.allSpacesOption = function(opt_data, opt_ignored) {
  return '<option value="">' + soy.$$escapeHtml("All Spaces") + '</option><option value="" disabled="disabled">' + soy.$$escapeHtml("Loading...") + '</option>';
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.allSpacesOption.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.allSpacesOption';
}
;
;
/* module-key = 'com.atlassian.administration.atlassian-admin-quicksearch-jira:admin-quicksearch-webresources', location = 'com/atlassian/administration/quicksearch/jira/js/adminQuickNav.js' */
/**
 * Shifter group for admin search
 */
require([
    'jquery',
    'underscore',
    'jira/ajs/ajax/smart-ajax',
    'jira/shifter',
    'wrm/context-path'
], function (jQuery,
             _,
             SmartAjax,
             Shifter,
             contextPath) {
    Shifter.register(function () {
        var suggestionsDeferred = jQuery.Deferred();

        function formatItem(item) {
            return {
                label: item.label,
                value: item.linkUrl,
                keywords: item.aliases
            };
        }

        function getItemsInSection(section) {
            return _.map(section.items, formatItem).concat(_.map(section.sections, getItemsInSection));
        }

        function formatResponse(data) {
            return _.flatten(getItemsInSection(data));
        }

        SmartAjax.makeRequest({
            dataType: 'json',
            url: contextPath() + '/rest/adminquicksearch/latest/links/default'
        })
            .pipe(formatResponse)
            .done(function (suggestions) {
                suggestionsDeferred.resolve(suggestions);
            })
            .fail(function () {
                suggestionsDeferred.reject();
            });

        return {
            id: 'admin',
            name: "Administration",
            weight: 500,
            getSuggestions: function () {
                return suggestionsDeferred;
            },
            onSelection: function (value) {
                window.location = value;
                return jQuery.Deferred();
            }
        };
    });
});
;
;
/* module-key = 'com.atlassian.plugins.browser.metrics.browser-metrics-plugin:api', location = 'probe.js' */
;(function() {
var util_window, is_supported, event_stream, api_addReporter, api_delegateTo, api_end, util_table, util_document, util_element_hound, util_element_wolf, api_start_is_ready_supported, util_is_dom_content_loaded_done, api_start, api_subscribe, index;
util_window = function () {
  return window;
}();
is_supported = function (window) {
  /**
   * Feature detection for whether mandatory browser features are supported.
   */
  // required for .start() and .end() timing
  // http://caniuse.com/#search=performance.now
  return !!(window.performance && window.performance.now);
}(util_window);
event_stream = [];
api_addReporter = function (eventStream) {
  /**
   * Add a custom reporter to contribute to transition reports.
   *
   * @param {Reporter} reporter
   * @example
   *     api.addReporter(function dateReporter(transition) {
   *         return {
   *             date: Date.now()
   *         };
   *     });
   */
  return function addReporter(reporter) {
    // "addReporter" API has highest priority, so we use .unshift() rather than .push()
    eventStream.unshift({ addReporter: reporter });
  };
}(event_stream);
api_delegateTo = function (eventStream) {
  /**
   * Yield control to another object, giving it all events captured thus far, and all events in the future.
   * @param {function} subscriber
   */
  return function delegateTo(subscriber) {
    while (eventStream.length) {
      subscriber(eventStream.splice(0, 1)[0]);
    }
    eventStream.unshift = subscriber;
    eventStream.push = subscriber;
  };
}(event_stream);
api_end = function (eventStream, window) {
  /**
   * Finish timing and report the results.
   *
   * @param {String} options.key A key that identifies the page that has now finished loading. It must match the
   *     key provided to `start`.
   * @returns {undefined}
   * @example
   *     api.end({key: "jira.issue.view"});
   */
  return function end(options) {
    eventStream.push({
      end: {
        key: options.key,
        timestamp: window.performance.now()
      }
    });
  };
}(event_stream, util_window);
util_table = function () {
  /**
   * A multi-dimensional map that supports multiple values per key.
   * @constructor
   */
  function Table() {
    this._ = {};
  }
  /**
   * Recursive iteration over all keys and values. Function argument explanation:
   * {function} args[0] callback Called with arguments: values, key, higherKey, moreHigherKey,...
   * {Object} args[1] items to iterate
   * {string} args[2..n] keys from bottom to top
   *
   * @param {Array} args
   * @returns {undefined}
   */
  var _forEachRecursive = function (args) {
    var callback = args[0];
    var items = args[1];
    // at 1st level it's -> this;
    if (items instanceof Table) {
      if (args.length >= 3) {
        Object.keys(items._).forEach(function (key) {
          _forEachRecursive([
            callback,
            items._[key],
            key
          ].concat(args.slice(2)));
        });
      } else {
        Object.keys(items._).forEach(function (key) {
          _forEachRecursive([
            callback,
            items._[key],
            key
          ]);
        });
      }
    } else if (Array.isArray(items)) {
      callback.apply(null, [items].concat(args.slice(2)));
    }
  };
  /**
   * Iterate over all keys and values.
   * @param {function} callback Called with two arguments: values, key
   * @returns {undefined}
   */
  Table.prototype.forEach = function (callback) {
    _forEachRecursive([
      callback,
      this
    ]);
  };
  /**
   * Adds an object to a multi-dimension table. Head arguments are keys in order of deepness,
   * 1st goes highest key (e.g.: row key) and the one before last is the deepest level key (e.g.: column key).
   * Last argument considered as a value.
   *
   * @param arguments array of keys from top to bottom, ending with value (e.g.: [0] > rowKey, [1] > columnKey, [2] > value)
   */
  Table.prototype.add = function () {
    // selector, hasNone, callback
    var obj = this;
    // current level row
    var prev = null;
    // previous argument/key
    var cur = null;
    // current func argument/key/value
    for (var i = 0; i < arguments.length; i++) {
      cur = arguments[i];
      // then "obj" is an Array and "cur" is a value
      if (i === arguments.length - 1 && Array.isArray(obj)) {
        obj.push(cur);
        break;  // creating new level of table
      } else if (i < arguments.length - 2 && !obj._.hasOwnProperty(cur)) {
        obj._[cur] = new Table();  // {_: {}, length: 0}
                                   // considered as last level, we need to create an Array for values if not exists
      } else if (i === arguments.length - 2 && !obj._.hasOwnProperty(cur)) {
        obj._[cur] = [];
      }
      obj = obj._[cur];
      // this is an Array if i === arguments.length - 2
      prev = cur;
    }
  };
  /**
   *
   * @param visited an Array of tupples of "table key" > "object under that key" (root key is always null)
   * @param keyToRemove a key on the table structure which needs to be removed
   */
  var _cleanUpRecursive = function (visited, keyToRemove) {
    if (visited.length === 0) {
      return;
    }
    var tuple = visited.pop();
    var key = tuple[0];
    var obj = tuple[1];
    if (key === keyToRemove) {
      _cleanUpRecursive(visited, key);
    } else if (obj._.hasOwnProperty(keyToRemove)) {
      delete obj._[keyToRemove];
    }
    if (Object.keys(obj).length === 0) {
      _cleanUpRecursive(visited, key);
    }
  };
  /**
   * Remove an object under a key.
   * @param arguments array of keys from top to bottom, ending with value (e.g.: [0] > rowKey, [1] > columnKey, [2] > value)
   * @returns {boolean} true if an item was removed
   */
  Table.prototype.remove = function () {
    // e.g.: rowKey, columnKey, value
    var index;
    // index of the Array element that is about to be removed
    var mutated = false;
    // true if Table was changed, i.e. element was removed
    var key = null;
    // current level key
    var obj = this;
    // current level row
    // Visited elements - Array of tuples, root key is always null (e.g.: [aKey1, {_: { aKey2 : Table/Array }, length: 1}]
    var visited = [[
        key,
        obj
      ]];
    var cur = null;
    // current func argument
    for (var i = 0; i < arguments.length; i++) {
      cur = arguments[i];
      // then "obj" is Array and "cur" is an entry in this Array.
      if (Array.isArray(obj)) {
        index = obj.indexOf(cur);
        if (index > -1) {
          obj.splice(index, 1);
          if (obj.length === 0 && visited.length > 1) {
            _cleanUpRecursive(visited, key);  // cleaning all upper levels if they are empty as well
          }
          mutated = true;
        }
      } else if (obj._.hasOwnProperty(cur)) {
        // When only some key is specified, _all_ values under that key are removed.
        if (i === arguments.length - 1) {
          delete obj._[cur];
          // if we want correct reduce, we need to count all inner keys being removed
          if (Object.keys(obj).length === 0 && visited.length > 1) {
            _cleanUpRecursive(visited, key);  // cleaning all upper levels if they are empty either
          }
          mutated = true;
        }
        key = cur;
        obj = obj._[cur];
        visited.push([
          key,
          obj
        ]);  // at the previous to last index step obj is an Array
      } else {
        break;
      }
    }
    return mutated;
  };
  /**
   * Get objects under a key.
   * @returns {Array}
   * @param key under which sought-for element stored
   */
  Table.prototype.get = function (key) {
    if (this._.hasOwnProperty(key)) {
      return this._[key];
    }
    return [];
  };
  return Table;
}();
util_document = function (window) {
  return window.document;
}(util_window);
util_element_hound = function (Table, window, document) {
  var MutationObserver = window.MutationObserver;
  var observer;
  var observing = false;
  var Promise = window.Promise;
  var targets;
  // MutationObserver -- Required for determining whether selectors are satisfied in the DOM;
  // Promise -- Required for combining multiple conditions together.
  if (!(MutationObserver && Promise)) {
    return;
  }
  // A table of selector -> [hasNone -> [callbacks, ...], ... ] of things to find.
  targets = new Table();
  function isNothing(obj) {
    return !obj || obj == null || obj === 'null' || obj === 'undefined';
  }
  /**
   * Add a target to watch for, ensuring the MutationObserver is enabled.
   * @param {string} selector
   * @param {string} hasNone
   * @param {function} callback
   */
  function addTarget(selector, hasNone, callback) {
    if (!observing) {
      observer.observe(document, {
        attributes: true,
        childList: true,
        subtree: true
      });
      observing = true;
    }
    targets.add(selector, hasNone, callback);
  }
  /**
   * Find candidate elements that satisfy the "selector predicate".
   * @param selector
   * @param hasNone
   * @returns {boolean}
   */
  function satisfies(selector, hasNone) {
    var candidates = document.querySelectorAll(selector);
    return candidates.length && (isNothing(hasNone) || Array.prototype.every.call(candidates, function (element) {
      return !element.querySelector(hasNone);
    }));
  }
  // A MutationObserver so we know when the DOM changes.
  observer = new MutationObserver(function (mutations) {
    // 1. Gather list of elements that satisfy the "selector" predicate
    // 2. For each of those "candidate" elements, check if it satisfies the "hasNone" predicate.
    targets.forEach(function (callbacks, hasNone, selector) {
      if (satisfies(selector, hasNone)) {
        callbacks.forEach(function (callback) {
          callback();
        });
        targets.remove(selector, hasNone);
      }
    });
  });
  /**
   * @typedef {Promise} ElementHound
   * @property {function} dismiss When called, dismissed the hound.
   */
  /**
   * Find some elements!
   *
   * @param {string|string[]} selectors One ore more CSS selectors that must all match elements of interest.
   * @param {string|string[]} hasNones If not null, selectors only match elements that do not have descendants matching
   *     this selector.
   * @returns {ElementHound}
   * @constructor
   */
  function ElementHound(selectors, hasNones) {
    var dismiss;
    // Normalise selectors to an array.
    if (!selectors.forEach) {
      selectors = [selectors];
    }
    // Join all "hasNones" into one big comma separated selector
    if (!isNothing(hasNones) && Array.isArray(hasNones)) {
      hasNones = hasNones.join(',');
    }
    /**
     * @type {ElementHound}
     */
    var result = new Promise(function (resolve, reject) {
      var requirementPromises = [];
      var requirementCleanups = [];
      selectors.forEach(function (selector) {
        var promise;
        var cleanup;
        if (!satisfies(selector, hasNones)) {
          promise = new Promise(function (resolve) {
            addTarget(selector, hasNones, resolve);
            cleanup = function () {
              targets.remove(selector, hasNones, resolve);
            };
            requirementCleanups.push(cleanup);
          });
          requirementPromises.push(promise);
        }
      });
      // Clean-up after ourselves, to reduce the work done by the mutation observer.
      function cleanup() {
        requirementCleanups.forEach(function (requirementCleanup) {
          requirementCleanup();
        });
      }
      Promise.all(requirementPromises).then(cleanup).then(resolve, reject);
      dismiss = function () {
        cleanup();
        reject();
      };
    });
    // Allow the caller to explicitly dismiss the hound. This allows the caller to say
    // they don't care about the result any more, and allows us to stop looking for it.
    result.dismiss = dismiss;
    return result;
  }
  return ElementHound;
}(util_table, util_window, util_document);
util_element_wolf = function (Table, window, document) {
  var MutationObserver = window.MutationObserver;
  var observer;
  var observing = false;
  var Promise = window.Promise;
  var targets;
  // MutationObserver -- Required for determining whether selectors are satisfied in the DOM;
  // Promise -- Required for combining multiple conditions together.
  if (!(MutationObserver && Promise)) {
    return;
  }
  // A map of selector->[callback] of things to find.
  targets = new Table();
  /**
   * Add a target to watch for, ensuring the MutationObserver is enabled.
   * @param {string} selector
   * @param {function} callback
   */
  function addTarget(selector, callback) {
    if (!observing) {
      observer.observe(document, {
        attributes: true,
        childList: true,
        subtree: true
      });
      observing = true;
    }
    targets.add(selector, callback);
  }
  // A MutationObserver so we know when the DOM changes.
  observer = new MutationObserver(function (mutations) {
    targets.forEach(function (callbacks, selector) {
      if (!document.querySelector(selector)) {
        callbacks.forEach(function (callback) {
          callback();
        });
        targets.remove(selector);
      }
    });
  });
  /**
   * @typedef {Promise} ElementWolf
   * @property {function} dismiss When called, dismisses the wolf.
   */
  /**
   * Find some elements!
   *
   * @param {string|string[]} selectors One ore more CSS selectors that must all match elements of interest.
   * @returns {ElementWolf}
   * @constructor
   */
  function ElementWolf(selectors) {
    var dismiss;
    // Normalise selectors to an array.
    if (!selectors.forEach) {
      selectors = [selectors];
    }
    /**
     * @type {ElementWolf}
     */
    var result = new Promise(function (resolve, reject) {
      var requirementPromises = [];
      var requirementCleanups = [];
      selectors.forEach(function (selector) {
        var promise;
        var cleanup;
        if (document.querySelector(selector)) {
          promise = new Promise(function (resolve) {
            addTarget(selector, resolve);
            cleanup = function () {
              targets.remove(selector, resolve);
            };
          });
          requirementPromises.push(promise);
          requirementCleanups.push(cleanup);
        }
      });
      // Clean-up after ourselves, to reduce the work done by the mutation observer.
      function cleanup() {
        requirementCleanups.forEach(function (requirementCleanup) {
          requirementCleanup();
        });
      }
      Promise.all(requirementPromises).then(cleanup).then(resolve, reject);
      dismiss = function () {
        cleanup();
        reject();
      };
    });
    // Allow the caller to explicitly dismiss the hound. This allows the caller to say
    // they don't care about the result any more, and allows us to stop looking for it.
    result.dismiss = dismiss;
    return result;
  }
  return ElementWolf;
}(util_table, util_window, util_document);
api_start_is_ready_supported = function (ElementHound, ElementWolf) {
  /**
   * Feature detection for whether the .api({ready: …}) API option is supported.
   */
  return !!(ElementHound && ElementWolf);
}(util_element_hound, util_element_wolf);
util_is_dom_content_loaded_done = function (document, window) {
  var done = false;
  document.addEventListener('DOMContentLoaded', function () {
    // setTimeout matters here because the purpose of this module is to let know when all the DOMContentLoaded
    // event handlers have run. In order to know that, it would have to run after all the other handlers have run.
    // Hence we're using setTimeout to wait until the next tick. We know for certain that on the next tick all
    // the handlers have been executed due to JavaScript being single threaded.
    window.setTimeout(function () {
      done = true;
    });
  });
  /**
   * Return true if the DOMContentLoaded event handlers have been called.
   * @returns {boolean}
   */
  function isDOMContentLoadedDone() {
    return done;
  }
  return isDOMContentLoadedDone;
}(util_document, util_window);
api_start = function (end, isReadySupported, eventStream, ElementHound, ElementWolf, isDOMContentLoadedDone, window) {
  var Promise = window.Promise;
  var executeOnceOnStart = [];
  /**
   * In the .start() API, there are multiple short-hand versions of the 'ready' value that can be used. In the
   * interest of sanity, this function normalises them all to the most complex form.
   *
   * @param {string|string[]|{selector: string, requireUpdate: boolean, hasNone?: string|null}} conditions
   * @param {boolean} defaultRequireUpdate When a ready condition is a string (i.e. selector only), use this value for
   *     requireUpdate.
   * @returns {Array<{selector: string, requireUpdate: boolean, hasNone?: string|null}>}
   */
  function normalisedReady(conditions, defaultRequireUpdate) {
    if (!Array.isArray(conditions)) {
      conditions = [conditions];
    }
    return conditions.map(function (c) {
      return typeof c === 'string' ? {
        selector: c,
        requireUpdate: defaultRequireUpdate,
        hasNone: null
      } : c;
    });
  }
  /**
   * Combine all the ready conditions into a single promise.
   *
   * @param {{selector: string, requireUpdate: boolean, hasNone?: string|null}[]} conditions
   * @returns {Promise} a promise that is resolved when all conditions are satisfied
   */
  function combinedReady(conditions) {
    var combined;
    combined = conditions.map(function (condition) {
      var precondition;
      if (condition.requireUpdate) {
        precondition = new ElementWolf(condition.selector);
        // In case another transition happens _before_ we can finish.
        executeOnceOnStart.push(function () {
          precondition.dismiss();
        });
      } else {
        precondition = Promise.resolve();
      }
      return precondition.then(function () {
        var hound = new ElementHound(condition.selector, condition.hasNone);
        // In case another transition happens _before_ we can finish.
        executeOnceOnStart.push(function () {
          hound.dismiss();
        });
        return hound;
      });
    });
    return Promise.all(combined);
  }
  /**
   * Start measuring the duration of a transition.
   *
   * @param {String} options.key A key that identifies the page where the user is headed.
   * @param {boolean} [options.isInitial] If specified, indicates whether the transition should be treated as a
   *     "full page load" (initial). If not specified, this will be determined automatically based on whether or not
   *     DOMContentLoaded has fired.
   * @param {number} [options.threshold=1000] Declares the target (in milliseconds) duration for the navigation. The
   *     performance of the navigation is considered *good* if it completes within this threshold.
   * @param {String|String[]|{selector: string, requireUpdate: boolean}[]} [options.ready] A CSS selector that matches
   *     one or more DOM elements. When the selector matches something in the DOM, the page is considered "ready" for
   *     the user.
   *
   *     For non-initial page loads, if the selector _immediately_ matches one or more elements in the DOM, it will
   *     first wait a matching element to be removed, and then wait for a DOM mutation to expose a matching element.
   *     This behaviour can be turned off (i.e. don't require an element to be removed first) via the
   *     `requireUpdate=false` option.
   * @returns {undefined}
   * @example
   *     api.start({key: "jira.issue.view"});
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         threshold: 1000
   *     });
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         ready: ".issue-main-content",
   *         threshold: 1000
   *     });
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         ready: [
   *             ".issue-main-content",
   *             {selector: ".issue-main-content", hasNone: ".loading"},
   *             ".another-required-thing"
   *         ],
   *         threshold: 1000
   *     });
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         ready: [
   *             {selector: ".issue-main-content", requireUpdate: false, hasNone: ".aui-loading, .loading"},
   *             ".another-required-thing"
   *         ],
   *         threshold: 1000
   *     });
   */
  return function start(options) {
    var conditions;
    var isInitial = 'isInitial' in options ? options.isInitial : isDOMContentLoadedDone() === false;
    var threshold = 'threshold' in options ? options.threshold : 1000;
    eventStream.push({
      start: {
        key: options.key,
        isInitial: isInitial,
        threshold: threshold,
        timestamp: isInitial ? 0 : window.performance.now()
      }
    });
    executeOnceOnStart.forEach(function (callback) {
      callback();
    });
    // Empty the array of callbacks now that we've called them.
    executeOnceOnStart.splice(0, executeOnceOnStart.length);
    if (options.ready && isReadySupported) {
      conditions = normalisedReady(options.ready, /*defaultRequireUpdate=*/
      !isInitial);
      combinedReady(conditions).then(function () {
        end({ key: options.key });
      });
    }
  };
}(api_end, api_start_is_ready_supported, event_stream, util_element_hound, util_element_wolf, util_is_dom_content_loaded_done, util_window);
api_subscribe = function (eventStream) {
  /**
   * Add a subscriber that's interested in reports.
   */
  return function subscribe(subscriber) {
    eventStream.push({ subscribe: subscriber });
  };
}(event_stream);
index = function (isSupported, addReporter, delegateTo, end, start, subscribe) {
  var noop = function () {
  };
  return {
    start: isSupported ? start : noop,
    end: isSupported ? end : noop,
    addReporter: isSupported ? addReporter : noop,
    delegateTo: isSupported ? delegateTo : noop,
    subscribe: isSupported ? subscribe : noop
  };
}(is_supported, api_addReporter, api_delegateTo, api_end, api_start, api_subscribe);
window['browser-metrics'] = index;
if (window.define) {
  window.define('internal/browser-metrics', function () {
    return index;
  });
}
}());;
;
/* module-key = 'com.atlassian.plugins.browser.metrics.browser-metrics-plugin:api', location = 'internal/browser-metrics-aa-beacon.js' */
define("internal/browser-metrics-aa-beacon",function(){var n={};return n=function(n){function e(n,e){Object.keys(e).forEach(function(r){n[r]=e[r]})}var r=[],t=[];return n.addUrlCleaner=function(n){t.push(n)},n.cleanUrl=function(n){return t.reduce(function(e,r){var t=r(n);return t.length>e.length?t:e},"")},n.addReportMarshaller=function(n){r.push(n)},n.beacon=function(n){var t={};r.forEach(function(r){var a=r(n);"object"==typeof a&&e(t,a)});var a={name:"browser.metrics.navigation",properties:t};AJS.EventQueue.push(a)},n}(n)});;
;
/* module-key = 'com.atlassian.plugins.browser.metrics.browser-metrics-plugin:api', location = 'loader.js' */
;(function() {
var lib_window = {}, lib_wrm = {}, loader = {};
lib_window = function (exports) {
  var w = window;
  return w;
}(lib_window);
lib_wrm = function (exports, window) {
  var wrm = window.WRM;
  return wrm;
}(lib_wrm, lib_window);
loader = function (exports, window, WRM) {
  var contribInstallers = 0;
  var contribInstalls = 0;
  var collectorInstaller = null;
  function tryInstallCollector() {
    if (contribInstallers === contribInstalls && collectorInstaller) {
      collectorInstaller();
      collectorInstaller = null;
    }
  }
  var api = {
    install: function (installer) {
      contribInstallers += 1;
      installer(function () {
        contribInstalls += 1;
        tryInstallCollector();
      });
    }
  };
  window['browser-metrics-plugin'] = api;
  WRM.require(['wrc!browser-metrics-plugin.contrib'], function () {
    window.require(['internal/browser-metrics-plugin/collector'], function (collector) {
      collectorInstaller = function () {
        collector.install();
      };
      tryInstallCollector();
    });
  });
  return exports;
}(loader, lib_window, lib_wrm);
}());;
;
/* module-key = 'com.atlassian.jira.plugins.jira-browser-metrics:sensors', location = 'sensors.js' */
require(["internal/browser-metrics", "jira/util/events"], function (internal_browser_metrics, jira_util_events) {
var sensors_application_menus = {}, sensors_util_safe_dialog_id = {}, sensors_dialogs = {}, sensors = {};
sensors_application_menus = function (exports, Events, metrics) {
  function init() {
    var KEYS = {
      'bonfire_top_menu_dropdown-content': 'jira.header.menu.capture',
      'browse_link-content': 'jira.header.menu.projects',
      'find_link-content': 'jira.header.menu.issues',
      'greenhopper_menu-content': 'jira.header.menu.agile',
      'home_link-content': 'jira.header.menu.dashboards',
      'plugins-jira-webitem-main-content': 'jira.header.menu.portfolio',
      'servicedesk-section-content': 'jira.header.menu.service-desk',
      'system-admin-menu-content': 'jira.header.menu.admin',
      'system-help-menu-content': 'jira.header.menu.help',
      'user-options-content': 'jira.header.menu.profile'
    };
    function getKey(dropdownId) {
      return KEYS.hasOwnProperty(dropdownId) ? KEYS[dropdownId] : null;
    }
    Events.bind('aui-dropdown2-show-before', function (event) {
      var target = event.target;
      var key = getKey(target && target.id);
      if (key) {
        metrics.start({
          key: key,
          isInitial: false,
          threshold: 250
        });
      }
    });
    Events.bind('aui-dropdown2-show-after', function (event) {
      var target = event.target;
      var key = getKey(target && target.id);
      if (key) {
        metrics.end({ key: key });
      }
    });
  }
  exports.init = init;
  return exports;
}(sensors_application_menus, jira_util_events, internal_browser_metrics);
sensors_util_safe_dialog_id = function (exports) {
  var SAFE_DIALOG_IDS = [
    'about-dialog',
    'add-basicuser-dialog',
    'add-developer-dialog',
    'add-field-configuration-dialog',
    'add-field-configuration-scheme-dialog',
    'add-field-dialog',
    'add-field-screen-dialog',
    'add-field-screen-scheme-dialog',
    'add-incoming-mail-handler-dialog',
    'add-issue-type-dialog',
    'add-issue-type-field-configuration-association-dialog',
    'add-issue-type-screen-scheme-configuration-association-dialog',
    'add-issue-type-screen-scheme-dialog',
    'add-new-issue-type-to-scheme-dialog',
    'add-screen-scheme-item-dialog',
    'add-subtask-type-dialog',
    'add-workflow-dialog',
    'add_workflowscheme-dialog',
    'assign-dialog',
    'assign-issue-types-dialog',
    'assign-to-me-link-handler',
    'attach-file-dialog',
    'attach-screenshot-dialog',
    'auditing-settings-dialog',
    'clone-issue-dialog',
    'comment-add-dialog',
    'configure_wallboard_dialog',
    'confluence-page-search-dialog',
    'copy_classic default workflow-dialog',
    'copy-filter-dialog',
    'copy_jira-dialog',
    'create-issue-dialog',
    'create-issue-dialog.issueType',
    'create-issue-dialog.projectId',
    'create-request-dialog',
    'create-service-desk-dialog',
    'create-status-dialog',
    'create-story-dialog',
    'create-story-dialog.issueType',
    'create-story-dialog.projectId',
    'create-subtask-dialog',
    'create-subtask-dialog.issueType',
    'create-team-dialog',
    'create_user-dialog',
    'credits-dialog',
    'delete-attachment-dialog',
    'delete-comment-dialog',
    'delete-dshboard',
    'delete-filter-dialog',
    'delete-issue-dialog',
    'delete-issue-link-dialog',
    'delete-log-work-dialog',
    'delete-metric',
    'delete-queue',
    'delete-status-dialog',
    'deleteuser_link-dialog',
    'devstatus-branch-detail-dialog',
    'devstatus-build-detail-dialog',
    'devstatus-commit-detail-dialog',
    'devstatus-cta-dialog',
    'devstatus-deployment-detail-dialog',
    'devstatus-pullrequest-detail-dialog',
    'devstatus-review-detail-dialog',
    'discard-draft-dialog',
    'discard_draft_workflow-dialog',
    'edit-attachments-dialog',
    'edit-comment',
    'editgroups_admin-dialog',
    'editgroups_link-dialog',
    'editgroups_sysadmin-dialog',
    'edit-issue-dialog',
    'edit-labels-dialog',
    'edit-log-work-dialog',
    'edit-status-dialog',
    'edituser_link_admin-dialog',
    'edit-workflow-dialog',
    'gh-rapidboard-dialog',
    'inline-issue-create-dialog',
    'invite_user-dialog',
    'issue-actions-dialog',
    'issue-tab-error-dialog',
    'jim-create-project-dialog',
    'keyboard-shortcuts-dialog',
    'link-issue-dialog',
    'log-work-dialog',
    'manage-attachment-dialog',
    'metric-pre-save-dialog',
    'modal-field-view',
    'permission-helper-dialog',
    'project-avatar-cropper',
    'project-avatar-picker',
    'project-config-details-project-category-dialog',
    'project-config-project-edit-dialog',
    'project-config-project-edit-lead-and-default-assignee-dialog',
    'project-email-dialog',
    'publish_draft_workflow-dialog',
    'queue-dirty-edits',
    'QuickCreateIssue.error',
    'QuickCreateIssue.success',
    'QuickCreateSubtask.error',
    'QuickCreateSubtask.success',
    'QuickEdit.error',
    'QuickEdit.success',
    'remote-jira-search-dialog',
    'rename-filter-dialog',
    'report-dirty-edits',
    'save-filter-dialog',
    'sd-add-default-value',
    'sd-add-remove-agent-dialog',
    'sd-remove-field-dialog',
    'server-error-dialog',
    'report-delete-confirm',
    'tempo-add-hours-issue-dialog',
    'tempo-add-internal-activity-form',
    'tempo-core-medium-form',
    'tempo-delete-form-dialog',
    'tempo-grace-form',
    'tempo-large-form',
    'tempo-medium-form',
    'tempo-move-form-dialog',
    'tempo-pdf-form',
    'tempo-small-form',
    'tempo-split-form-dialog',
    'tempo-user-settings-dialog',
    'user-avatar-picker',
    'user-defaults-edit-dialog',
    'versionsMergeDialog',
    'view-workflow-dialog',
    'view-workflow-dialog-project-admin',
    'view-workflow-dialog-workflow-schemes',
    'wait-migrate-dialog',
    'whereismycf-dialog',
    'workflow-text-view'
  ].reduce(function (previousValue, currentValue) {
    previousValue[currentValue] = true;
    return previousValue;
  }, {});
  var DIALOG_ID_NORMALISATIONS = [
    {
      dialogId: 'component-delete-dialog',
      pattern: /^component-\d+-delete-dialog$/i
    },
    {
      dialogId: 'version-delete-dialog',
      pattern: /^version-\d+-delete-dialog$/i
    },
    {
      dialogId: 'workflow-transition-dialog',
      pattern: /^workflow-transition-\d+-dialog$/i
    }
  ];
  function safeDialogId(dialogId) {
    var i;
    if (SAFE_DIALOG_IDS.hasOwnProperty(dialogId)) {
      return dialogId;
    }
    for (i = 0; i < DIALOG_ID_NORMALISATIONS.length; i++) {
      if (dialogId.match(DIALOG_ID_NORMALISATIONS[i].pattern)) {
        return DIALOG_ID_NORMALISATIONS[i].dialogId;
      }
    }
    return null;
  }
  return safeDialogId;
}(sensors_util_safe_dialog_id);
sensors_dialogs = function (exports, Events, metrics, safeDialogId) {
  function init() {
    Events.bind('beforeShow', function (event, dialogId) {
      if (typeof dialogId !== 'string') {
        return;
      }
      var key = safeDialogId(dialogId);
      if (key) {
        metrics.start({
          key: 'jira.dialog.open.' + key,
          isInitial: false,
          threshold: 1000
        });
      }
    });
    Events.bind('dialogContentReady', function (event, dialog) {
      if (typeof dialog.options.id !== 'string') {
        return;
      }
      var key = safeDialogId(dialog.options.id);
      if (key) {
        metrics.end({ key: 'jira.dialog.open.' + key });
      }
    });
  }
  exports.init = init;
  return exports;
}(sensors_dialogs, jira_util_events, internal_browser_metrics, sensors_util_safe_dialog_id);
sensors = function (exports, applicationMenusSensor, dialogsSensor) {
  applicationMenusSensor.init();
  dialogsSensor.init();
  return exports;
}(sensors, sensors_application_menus, sensors_dialogs);});
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher.soy' */
// This file was automatically generated from appswitcher.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.appswitcher.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.appswitcher == 'undefined') { navlinks.templates.appswitcher = {}; }


navlinks.templates.appswitcher.linkSection = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.list.length > 0) {
    output += '<div class="aui-nav-heading sidebar-section-header">' + soy.$$escapeHtml(opt_data.title) + '</div><ul class="aui-nav nav-links">';
    var linkList8 = opt_data.list;
    var linkListLen8 = linkList8.length;
    for (var linkIndex8 = 0; linkIndex8 < linkListLen8; linkIndex8++) {
      var linkData8 = linkList8[linkIndex8];
      output += navlinks.templates.appswitcher.applicationsItem(linkData8);
    }
    output += '</ul>';
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.linkSection.soyTemplateName = 'navlinks.templates.appswitcher.linkSection';
}


navlinks.templates.appswitcher.applicationsItem = function(opt_data, opt_ignored) {
  return '<li class="nav-link"><a href="' + soy.$$escapeHtml(opt_data.link) + '" ' + ((opt_data.self) ? 'class="checked"' : '') + ' title="' + soy.$$escapeHtml(opt_data.link) + '"><span class="nav-link-label">' + soy.$$escapeHtml(opt_data.label) + '</span></a></li>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.applicationsItem.soyTemplateName = 'navlinks.templates.appswitcher.applicationsItem';
}


navlinks.templates.appswitcher.shortcutsItem = function(opt_data, opt_ignored) {
  return '<li class="nav-link"><a href="' + soy.$$escapeHtml(opt_data.link) + '" ' + ((opt_data.self) ? 'class="checked"' : '') + ' title="' + soy.$$escapeHtml(opt_data.link) + '"><span class="nav-link-label">' + soy.$$escapeHtml(opt_data.label) + '</span>' + ((opt_data.showDescription && opt_data.description) ? '<span class="nav-link-description">' + soy.$$escapeHtml(opt_data.description) + '</span>' : '') + '</a></li>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.shortcutsItem.soyTemplateName = 'navlinks.templates.appswitcher.shortcutsItem';
}


navlinks.templates.appswitcher.error = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-error">' + soy.$$filterNoAutoescape("Something went wrong, please \x3cspan class\x3d\x22app-switcher-retry\x22\x3etry again\x3c/span\x3e.") + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.error.soyTemplateName = 'navlinks.templates.appswitcher.error';
}


navlinks.templates.appswitcher.sidebarContents = function(opt_data, opt_ignored) {
  return '<div class="aui-page-panel-nav"><nav class="aui-navgroup aui-navgroup-vertical"><div class="app-switcher-section app-switcher-applications"><div class="aui-nav-heading">' + soy.$$escapeHtml("Application Links") + '</div><div class="app-switcher-loading">' + soy.$$filterNoAutoescape("Loading\x26hellip;") + '</div></div><div class="app-switcher-section app-switcher-shortcuts"><div class="aui-nav-heading">' + soy.$$escapeHtml("Shortcuts") + '</div><div class="app-switcher-loading">' + soy.$$filterNoAutoescape("Loading\x26hellip;") + '</div></div></nav></div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.sidebarContents.soyTemplateName = 'navlinks.templates.appswitcher.sidebarContents';
}


navlinks.templates.appswitcher.trigger = function(opt_data, opt_ignored) {
  return '<span class="aui-icon aui-icon-small aui-iconfont-appswitcher">' + soy.$$escapeHtml("Linked Applications") + '</span>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.trigger.soyTemplateName = 'navlinks.templates.appswitcher.trigger';
}


navlinks.templates.appswitcher.projectHeaderSection = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-title">' + aui.avatar.avatar({size: 'large', avatarImageUrl: opt_data.avatarUrl, isProject: true, title: opt_data.name}) + '<div class="sidebar-project-name">' + soy.$$escapeHtml(opt_data.name) + '</div></div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.projectHeaderSection.soyTemplateName = 'navlinks.templates.appswitcher.projectHeaderSection';
}


navlinks.templates.appswitcher.cogDropdown = function(opt_data, opt_ignored) {
  var output = '';
  var dropdownList__soy74 = '' + navlinks.templates.appswitcher.dropdownList({list: opt_data.links});
  output += aui.dropdown2.dropdown2({menu: {id: opt_data.id, content: dropdownList__soy74, extraClasses: 'aui-style-default sidebar-customize-section'}, trigger: {showIcon: false, content: '<span class="aui-icon aui-icon-small aui-iconfont-configure"></span>', container: '#app-switcher'}});
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.cogDropdown.soyTemplateName = 'navlinks.templates.appswitcher.cogDropdown';
}


navlinks.templates.appswitcher.dropdownList = function(opt_data, opt_ignored) {
  var output = '<ul class="sidebar-admin-links">';
  var linkList82 = opt_data.list;
  var linkListLen82 = linkList82.length;
  for (var linkIndex82 = 0; linkIndex82 < linkListLen82; linkIndex82++) {
    var linkData82 = linkList82[linkIndex82];
    output += '<li class="nav-link"><a href="' + soy.$$escapeHtml(linkData82.href) + '" title="' + soy.$$escapeHtml(linkData82.title) + '"><span class="nav-link-label">' + soy.$$escapeHtml(linkData82.label) + '</span></a></li>';
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.dropdownList.soyTemplateName = 'navlinks.templates.appswitcher.dropdownList';
}


navlinks.templates.appswitcher.switcher = function(opt_data, opt_ignored) {
  var output = '';
  if (true) {
    if (AJS.DarkFeatures.isEnabled('rotp.sidebar')) {
      var sidebarContents__soy97 = '' + navlinks.templates.appswitcher.sidebarContents(null);
      var triggerContent__soy99 = '' + navlinks.templates.appswitcher.trigger(null);
      output += navlinks.templates.appswitcher.sidebar({sidebar: {id: 'app-switcher', content: sidebarContents__soy97}, trigger: {showIcon: false, content: triggerContent__soy99}}) + '<script>\n                (function (NL) {\n                    var initialise = function () {\n                        new NL.SideBar({\n                            sidebarContents: \'#app-switcher\'\n                        });\n                    };\n                    if (NL.SideBar) {\n                        initialise();\n                    } else {\n                        NL.onInit = initialise;\n                    }\n                }(window.NL = (window.NL || {})));\n                window.NL.isUserAdmin = ' + soy.$$escapeHtml(false) + '<\/script>';
    } else {
      output += navlinks.templates.appswitcher_old.switcher(null);
    }
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.switcher.soyTemplateName = 'navlinks.templates.appswitcher.switcher';
}


navlinks.templates.appswitcher.sidebar = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.sidebar.id) + '" class="sidebar-trigger app-switcher-trigger" aria-owns="' + soy.$$escapeHtml(opt_data.sidebar.id) + '" aria-haspopup="true">' + soy.$$filterNoAutoescape(opt_data.trigger.content) + '</a><div id=' + soy.$$escapeHtml(opt_data.sidebar.id) + ' class="app-switcher-sidebar aui-style-default sidebar-offscreen">' + soy.$$filterNoAutoescape(opt_data.sidebar.content) + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.sidebar.soyTemplateName = 'navlinks.templates.appswitcher.sidebar';
}
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher.js' */
(function ($, NL) {
    NL.SideBar = function (options) {
        var that = this;
        this.$sidebar = null;

        options = $.extend({
            sidebarContents: null
        }, options);

        this.getLinks = function () {
            return $.ajax({
                url: AJS.contextPath() + '/rest/menu/latest/appswitcher',
                cache: false,
                dataType: 'json'
            }).done(this.updateAppLinks).fail(this.showAppSwitcherError);
        };

        this.populateProjectHeader = function(name, avatarUrl) {
            that.getSidebar().find('.app-switcher-shortcuts .aui-nav-heading').after(navlinks.templates.appswitcher.projectHeaderSection({
                avatarUrl: avatarUrl,
                name: name
            }));
        };

        this.getProjectData = function(){
            var $projectData = $('.project-shortcut-dialog-trigger'),
                projectKey = $projectData.data('key'),
                projectEntityType = $projectData.data('entity-type');
            // if we have no project data, we are not in a project context, so delete the shortcuts section and return.
            if ($projectData.size() == 0 || !projectKey || !projectEntityType)
            {
                $('.app-switcher-shortcuts').remove();
                return;
            }

            var remote, local;

            local = $.ajax({
                url: AJS.contextPath() + '/rest/project-shortcuts/1.0/local/' + projectKey,
                cache: false,
                data: { entityType: projectEntityType },
                dataType: 'json'
            });

            remote = $.ajax({
                url: AJS.contextPath() + '/rest/project-shortcuts/1.0/remote/' + projectKey,
                cache: false,
                data: { entityType: projectEntityType },
                dataType: 'json'
            });

            // wrap a closure around updateProjectShortcuts so we can bind projectKey
            $.when(local, remote).then(function(localData, remoteData){
                that.updateProjectShortcuts(localData, remoteData, {
                    key: projectKey,
                    entityType: projectEntityType,
                    name: $projectData.data('name'),
                    avatarUrl: $projectData.find('img').prop('src')
                });
            }, that.showProjectShortcutsError);
        }

        this.getSidebar = function () {
            if (!this.$sidebar) {
                this.$sidebar = $(options.sidebarContents);
            }
            return this.$sidebar;
        };

        this.addApplicationsCog = function ()
        {
            $('.app-switcher-applications .aui-nav-heading').before(navlinks.templates.appswitcher.cogDropdown({
                id: 'sidebar-applications-admin-dropdown',
                links: [{
                    href: AJS.contextPath() + '/plugins/servlet/customize-application-navigator',
                    label: "Customize navigator",
                    title: "Add new entries, hide existing or restrict who sees what"
                }, {
                    href: AJS.contextPath() + '/plugins/servlet/applinks/listApplicationLinks',
                    label: "Manage application links",
                    title: "Link to more Atlassian applications"
                }]
            }));
        };

        this.addProjectShortcutsCog = function (projectKey, entityType)
        {
            var links = [{
                href: AJS.contextPath() + '/plugins/servlet/custom-content-links-admin?entityKey=' + projectKey,
                label: "Customize shortcuts",
                title: ""
            }];

            if (that.entityMappings[entityType]) {
                links.push({
                    href: that.generateEntityLinksUrl(projectKey, that.entityMappings[entityType]),
                    label: "Manage product links",
                    title: ""
                });
            }

            that.getSidebar().find('.app-switcher-shortcuts .aui-nav-heading').before(navlinks.templates.appswitcher.cogDropdown({
                id: 'sidebar-project-shortcuts-admin-dropdown',
                links: links
            }));
        };

        this.updateAppLinks = function (data) {
            $(function () {
                that.getSidebar().find('.app-switcher-applications').html(navlinks.templates.appswitcher.linkSection({
                    title: "Application Links",
                    list: data
                }));

                if(NL.isUserAdmin)
                {
                    that.addApplicationsCog();
                }

                that.bindAnalyticsHandlers(that.getSidebar(), data);
            });
        };

        this.updateProjectShortcuts = function (localData, remoteData, projectData) {
            var localLinks = localData[0].shortcuts,
                remoteLinks = remoteData[0].shortcuts

            that.getSidebar().find('.app-switcher-shortcuts').html(navlinks.templates.appswitcher.linkSection({
                title: "Shortcuts",
                list: localLinks.concat(remoteLinks)
            }));

            // if we're an admin, put some project admin links in too
            if(NL.isUserAdmin)
            {
                that.addProjectShortcutsCog(projectData.key, projectData.entityType);
            }

            that.populateProjectHeader(projectData.name, projectData.avatarUrl);

            that.bindAnalyticsHandlers(that.getSidebar(), data);
        };

        // Warning: ick.
        this.entityMappings = {
            'confluence.space': 'com.atlassian.applinks.api.application.confluence.ConfluenceSpaceEntityType',
            'jira.project': 'com.atlassian.applinks.api.application.jira.JiraProjectEntityType',
            'bamboo.project': 'com.atlassian.applinks.api.application.bamboo.BambooProjectEntityType',
            'stash.project': 'com.atlassian.applinks.api.application.stash.StashProjectEntityType'
        }
        this.generateEntityLinksUrl = function(projectKey, entityType) {
            // special case for confluence which has a much nicer entity links page
            if (entityType === that.entityMappings['confluence.space']) {
                return AJS.contextPath() + '/spaces/listentitylinks.action?typeId=' + entityType + '&key=' + projectKey;
            } else {
                return AJS.contextPath() + '/plugins/servlet/applinks/listEntityLinks/' + entityType + '/' + projectKey;
            }
        }

        this.showAppSwitcherError = function () {
            $(function () {
                var $sidebar = that.getSidebar();
                $sidebar.find('.app-switcher-applications .app-switcher-loading')
                        .replaceWith(navlinks.templates.appswitcher.error())
                $sidebar.off('.appswitcher')
                        .on('click.appswitcher', '.app-switcher-retry', $.proxy(that.retryLoading, that));
            });
        };

        this.showProjectShortcutsError = function () {
            $(function () {
                var $sidebar = that.getSidebar();
                $sidebar.find('.app-switcher-shortcuts .app-switcher-loading')
                    .replaceWith(navlinks.templates.appswitcher.error());
                $sidebar.off('.appswitcher')
                    .on('click.appswitcher', '.app-switcher-retry', $.proxy(that.retryLoading, that));
            });
        };

        this.retryLoading = function (e) {
            this.getSidebar().html(navlinks.templates.appswitcher.sidebarContents());
            this.getLinks();
            this.getProjectData();
            e && e.stopPropagation();
        };

        this.bindAnalyticsHandlers = function ($sidebar, apps) {
            // TODO: reconsider what we want to capture
        };

        this.getLinks();
        $(this.getProjectData);

        this.toggleSidebar = function(event){
            var sidebar = that.getSidebar(),
                body = $('body'), document = $(window.document);

            if (!body.hasClass('app-switcher-open')) {
                var header = $('#header');

                //append the sidebar to the body if this is the first toggle call.
                sidebar.css('left', -sidebar.width());
                sidebar.parent('body').length || sidebar.appendTo('body');
                sidebarStalk({data: sidebar});
                //Animation can be kicked off now that things are in position
                sidebar.animate({'left': 0}, 300);

                function closeSidebar(closeEvent){
                    var target = closeEvent.target && $(closeEvent.target),
                        keyCode = closeEvent.keyCode;

                    //shortcut out if this is the same even which bound the event to begin with
                    if( closeEvent.originalEvent === event.originalEvent ) {
                        return;
                    }

                    if (target && !keyCode && !(target.closest(sidebar).length || target.closest(header).length)
                            && event.which == 1 && !(closeEvent.shiftKey || closeEvent.ctrlKey || closeEvent.metaKey)){
                        //event is a click outside of the toolbar or header
                        that.toggleSidebar();
                    } else if (keyCode === 27) {
                        //event is the escape key
                        that.toggleSidebar();
                    }
                }
                document.on('click.appSwitcher', closeSidebar);
                document.on('keydown.appSwitcher', closeSidebar);
                document.on('scroll.appSwitcher', sidebar, sidebarStalk);
            } else {
                document.off('.appSwitcher');
            }
            body.toggleClass('app-switcher-open');
        }

        $('#header').on('click', '.app-switcher-trigger', this.toggleSidebar);
    };

    function sidebarStalk(event){
        var scrollPosition = $(document).scrollTop(),
            header = $('#header'),
            topOffset = (header.height() + header.offset().top) - scrollPosition;

        if ( topOffset >= 0 ) {
            event.data.css({top: topOffset, position: 'fixed'});
        } else {
            event.data.css({top: 0, left: 0, position: 'fixed'});
        }
    }

    if (NL.onInit) {
        NL.onInit();
    }
}(jQuery, window.NL = (window.NL || {})));
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher_old.js' */
var APPSWITCHER_TRIGGER_CLICK = "appswitcher.trigger.click";
var APPSWITCHER_DROPDOWN_SHOW = "appswitcher.dropdown.show";
var APPSWITCHER_DROPDOWN_DISPLAY_ERROR = "appswitcher.dropdown.display.error";
var APPSWITCHER_APP_LINK_CLICK = "appswitcher.app.link.click";
var APPSWITCHER_CONFIGURE_LINK_CLICK = "appswitcher.configure.link.click";

(function ($, NL) {
    NL.AppSwitcher = function (options) {
        var ADMIN_EDIT_PATH = AJS.contextPath() + "/plugins/servlet/customize-application-navigator";
        var GLOBAL_BILLING_SYSTEM_DARK_FEATURE_KEY = "unified.usermanagement";
        var that = this;
        this.$dropdown = null;

        options = $.extend({
            dropdownContents: null
        }, options);

        this.getLinks = function () {
            return $.ajax({
                url: AJS.contextPath() + '/rest/menu/latest/appswitcher',
                cache: false,
                dataType: 'json'
            }).done(this.updateDropdown).fail(this.showError);
        };

        this.getDropdown = function () {
            if (!this.$dropdown) {
                this.$dropdown = $(options.dropdownContents);
            }
            return this.$dropdown;
        };

        this.updateDropdown = function (data) {
            $(function () {
                that.getDropdown().html(navlinks.templates.appswitcher_old.applications({
                    apps: data,
                    showAdminLink: NL.environment.isUserAdmin,
                    adminLink: ADMIN_EDIT_PATH
                }));

                that.bindAnalyticsHandlers();
                if (NL.environment.isAppSuggestionAvailable === true) {
                    that.handleSuggestionApps(data);
                }
            });
        };

        this.bindAnalyticsHandlers = function () {
            $(".app-switcher-trigger").on("click", function() {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_TRIGGER_CLICK});
            });

            $("#app-switcher").on("aui-dropdown2-show", function() {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_DROPDOWN_SHOW});
            });

            $('#app-switcher .nav-link').on('click', function() {
                var product = "custom";
                var productLink = $(this).find("a");
                var url = productLink.attr("href");
                var hostname = window.location.hostname;

                if (url.indexOf(hostname + "/wiki") > -1) {
                    product = "confluence";
                } else if (url.indexOf(hostname + "/build") > -1) {
                    product = "bamboo";
                } else if (url.indexOf(hostname) > -1) {
                    product = "jira";
                }

                AJS.trigger("analyticsEvent", {
                    name: APPSWITCHER_APP_LINK_CLICK,
                    data: { product: product }
                });
            });

            $('.nav-link-edit-wrapper').on('click', function() {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_CONFIGURE_LINK_CLICK});
            })
        };

        this.isBillingSystemEnabled = function() {
            return (NL.environment.isSiteAdminUser === true) && AJS.DarkFeatures.isEnabled(GLOBAL_BILLING_SYSTEM_DARK_FEATURE_KEY);
        };

        this.handleSuggestionApps = function(data) {

            var installedApps = _.map(data, function (app) {
                return app.applicationType.toLowerCase();
            });

            var $suggestionApps = $("<div id='app-switcher-suggestion-apps' class='aui-dropdown2-section'/>");
            $suggestionApps.html(navlinks.templates.appswitcher_old.suggestionApps);

            var apps = $suggestionApps.find('.suggestion-apps');
            var hasSuggestionApps = false;
            _.each(suggestions, function(value) {
                if (!_.contains(installedApps, value.appName)) {
                    hasSuggestionApps = true;
                    apps.append(navlinks.templates.appswitcher_old.suggestionApp({
                        suggestionApp: value,
                        isBillingSystemEnabled:  that.isBillingSystemEnabled()
                    }));
                }
            });

            if (!hasSuggestionApps) return;

            $("#app-switcher").append($suggestionApps);

            $('.app-discovery-suggestion-app').click(function () {
                var $suggestionAppLink = $(this).find("a");
                var eventName;
                if (NL.environment.isSiteAdminUser) {
                    eventName = 'appswitcher.discovery.siteadmin.select.inproduct.';
                } else {
                    eventName = 'appswitcher.discovery.user.select.';
                }
                eventName = eventName + $suggestionAppLink.attr("id").toLowerCase();
                AJS.trigger("analytics", {name: eventName});
            });

            $('.app-discovery-suggestion-app').hover(function () {
                $(this).find("a").removeClass("active").removeClass("aui-dropdown2-active");
            });

            $('.app-discovery-cancel-button').click(function () {
                AJS.trigger("analytics", {name: "appswitcher.discovery.nothanks.button.click"});
                storeUserStorageData(KEY_NO_THANKS, "true");
                $suggestionApps.remove();
            });
        };

        this.showError = function () {
            $(function () {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_DROPDOWN_DISPLAY_ERROR});
                that.getDropdown()
                    .html(navlinks.templates.appswitcher_old.error())
                    .off('.appswitcher')
                    .on('click.appswitcher', '.app-switcher-retry', $.proxy(that.retryLoading, that));
            });
        };

        this.retryLoading = function (e) {
            this.getDropdown().html(navlinks.templates.appswitcher_old.loading());
            this.getLinks();
            e && e.stopPropagation();
        };

        this.getLinks();
    };

    var KEY_NO_THANKS = "key-no-thanks";
    var suggestions = [
        {
            appName: "jira",
            appDesc: "Issue & Project Tracking Software",
            discoveryUrl: 'https://www.atlassian.com/software/jira',
            billingSystemDiscoveryUrl: '/admin/billing/addapplication'
        },
        {
            appName: "confluence",
            appDesc: "Collaboration and content sharing",
            discoveryUrl: 'https://www.atlassian.com/software/confluence',
            billingSystemDiscoveryUrl: '/admin/billing/addapplication?product=confluence.ondemand'
        },
        {
            appName: "bamboo",
            appDesc: "Continuous integration",
            discoveryUrl: 'https://www.atlassian.com/software/bamboo',
            billingSystemDiscoveryUrl: '/admin/billing/addapplication?product=bamboo.ondemand'
        }];

    var storeUserStorageData = function (key, value) {
        $.ajax({
            url: AJS.contextPath() + '/rest/menu/latest/userdata/',
            type: "PUT",
            contentType: "application/json",
            data: JSON.stringify({
                key: key,
                value:value
            })
        });
    };

    if (NL.onInit) {
        NL.onInit();
    }


}(jQuery, window.NL = (window.NL || {})));;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher_old.soy' */
// This file was automatically generated from appswitcher_old.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.appswitcher_old.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.appswitcher_old == 'undefined') { navlinks.templates.appswitcher_old = {}; }


navlinks.templates.appswitcher_old.applications = function(opt_data, opt_ignored) {
  return '' + navlinks.templates.appswitcher_old.applicationsSection({list: opt_data.apps, listClass: 'nav-links', showDescription: opt_data.showDescription}) + ((opt_data.custom) ? navlinks.templates.appswitcher_old.applicationsSection({list: opt_data.custom, showDescription: opt_data.showDescription}) : '') + ((opt_data.showAdminLink) ? navlinks.templates.appswitcher_old.adminSection(opt_data) : '');
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.applications.soyTemplateName = 'navlinks.templates.appswitcher_old.applications';
}


navlinks.templates.appswitcher_old.applicationsSection = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.list.length > 0) {
    var param19 = '<ul' + ((opt_data.listClass) ? ' class="' + soy.$$escapeHtml(opt_data.listClass) + '"' : '') + '>';
    var linkList27 = opt_data.list;
    var linkListLen27 = linkList27.length;
    for (var linkIndex27 = 0; linkIndex27 < linkListLen27; linkIndex27++) {
      var linkData27 = linkList27[linkIndex27];
      param19 += navlinks.templates.appswitcher_old.applicationsItem(soy.$$augmentMap(linkData27, {showDescription: opt_data.showDescription}));
    }
    param19 += '</ul>';
    output += aui.dropdown2.section({content: param19});
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.applicationsSection.soyTemplateName = 'navlinks.templates.appswitcher_old.applicationsSection';
}


navlinks.templates.appswitcher_old.applicationsItem = function(opt_data, opt_ignored) {
  return '<li class="nav-link' + ((opt_data.self) ? ' nav-link-local' : '') + '"><a href="' + soy.$$escapeHtml(opt_data.link) + '" class="aui-dropdown2-radio ' + ((opt_data.self) ? 'aui-dropdown2-checked' : '') + '" title="' + soy.$$escapeHtml(opt_data.link) + '"><span class="nav-link-label">' + soy.$$escapeHtml(opt_data.label) + '</span>' + ((opt_data.showDescription && opt_data.description) ? '<span class="nav-link-description">' + soy.$$escapeHtml(opt_data.description) + '</span>' : '') + '</a></li>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.applicationsItem.soyTemplateName = 'navlinks.templates.appswitcher_old.applicationsItem';
}


navlinks.templates.appswitcher_old.adminSection = function(opt_data, opt_ignored) {
  return '' + aui.dropdown2.section({content: '<ul class="nav-links"><li><a class="nav-link-edit-wrapper" href="' + soy.$$escapeHtml(opt_data.adminLink) + '"><span class="nav-link-edit">' + soy.$$filterNoAutoescape("Configure\x26hellip;") + '</span></a></li></ul>'});
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.adminSection.soyTemplateName = 'navlinks.templates.appswitcher_old.adminSection';
}


navlinks.templates.appswitcher_old.error = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-error">' + soy.$$filterNoAutoescape("Something went wrong, please \x3cspan class\x3d\x22app-switcher-retry\x22\x3etry again\x3c/span\x3e.") + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.error.soyTemplateName = 'navlinks.templates.appswitcher_old.error';
}


navlinks.templates.appswitcher_old.loading = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-loading">' + soy.$$filterNoAutoescape("Loading\x26hellip;") + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.loading.soyTemplateName = 'navlinks.templates.appswitcher_old.loading';
}


navlinks.templates.appswitcher_old.trigger = function(opt_data, opt_ignored) {
  return '<span class="aui-icon aui-icon-small aui-iconfont-appswitcher">' + soy.$$escapeHtml("Linked Applications") + '</span>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.trigger.soyTemplateName = 'navlinks.templates.appswitcher_old.trigger';
}


navlinks.templates.appswitcher_old.switcher = function(opt_data, opt_ignored) {
  var output = '';
  if (true) {
    var loadingContent__soy81 = '' + navlinks.templates.appswitcher_old.loading(null);
    var triggerContent__soy83 = '' + navlinks.templates.appswitcher_old.trigger(null);
    output += aui.dropdown2.dropdown2({menu: {id: 'app-switcher', content: loadingContent__soy81, extraClasses: 'aui-style-default'}, trigger: {showIcon: false, content: triggerContent__soy83, extraClasses: 'app-switcher-trigger', extraAttributes: {href: '#app-switcher'}}}) + '<script>\n            (function (NL) {\n                var initialise = function () {\n                    // For some milestones of AUI, the atlassian soy namespace was renamed to aui. Handle that here by ensuring that window.atlassian is defined.\n                    window.atlassian = window.atlassian || window.aui;\n                    new NL.AppSwitcher({\n                        dropdownContents: \'#app-switcher\'\n                    });\n                };\n                if (NL.AppSwitcher) {\n                    initialise();\n                } else {\n                    NL.onInit = initialise;\n                }\n            }(window.NL = (window.NL || {})));\n            window.NL.environment = ' + soy.$$escapeHtml({}) + ';<\/script>';
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.switcher.soyTemplateName = 'navlinks.templates.appswitcher_old.switcher';
}


navlinks.templates.appswitcher_old.suggestionApp = function(opt_data, opt_ignored) {
  var output = '';
  var href__soy92 = opt_data.isBillingSystemEnabled == true ? opt_data.suggestionApp.billingSystemDiscoveryUrl : opt_data.suggestionApp.discoveryUrl;
  output += '<li class="app-discovery-suggestion-app"><a id="' + soy.$$escapeHtml(opt_data.suggestionApp.appName) + '" href="' + soy.$$escapeHtml(href__soy92) + '" class="app-discovery-link aui-icon-container app-discovery-' + soy.$$escapeHtml(opt_data.suggestionApp.appName) + '-product-icon" title="' + soy.$$escapeHtml(href__soy92) + '" target="_blank"/><div class="app-discovery-small">' + soy.$$escapeHtml(opt_data.suggestionApp.appDesc) + '</div></li>';
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.suggestionApp.soyTemplateName = 'navlinks.templates.appswitcher_old.suggestionApp';
}


navlinks.templates.appswitcher_old.suggestionApps = function(opt_data, opt_ignored) {
  return '<ul class=\'nav-links suggestion-apps\'><li><span class=\'app-discovery-suggest-title nav-link-label\'><h6>' + soy.$$escapeHtml("Try other Atlassian apps") + '</h6></span></li></ul><div class=\'buttons-container app-discovery-suggest-apps-buttons\'><div class=\'buttons\'><button class=\'aui-button aui-button-link app-discovery-cancel-button\' name=\'cancel\' accesskey=\'c\' href=\'#\'>' + soy.$$escapeHtml("Don\x27t show this again") + '</button></div></div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.suggestionApps.soyTemplateName = 'navlinks.templates.appswitcher_old.suggestionApps';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:jira-header', location = 'soy/headerDropdown.soy' */
// This file was automatically generated from headerDropdown.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Menu.Dropdowns.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Menu == 'undefined') { JIRA.Templates.Menu = {}; }
if (typeof JIRA.Templates.Menu.Dropdowns == 'undefined') { JIRA.Templates.Menu.Dropdowns = {}; }


JIRA.Templates.Menu.Dropdowns.dropdown2Fragment = function(opt_data, opt_ignored) {
  var output = '';
  var sectionList3 = opt_data.sections;
  var sectionListLen3 = sectionList3.length;
  for (var sectionIndex3 = 0; sectionIndex3 < sectionListLen3; sectionIndex3++) {
    var sectionData3 = sectionList3[sectionIndex3];
    var hasItems__soy4 = sectionData3.items && sectionData3.items.length > 0;
    output += '<div class="aui-dropdown2-section">' + ((hasItems__soy4 && sectionData3.label) ? '<strong>' + soy.$$escapeHtml(sectionData3.label) + '</strong>' : '') + '<ul class=\'aui-list-truncate\'' + ((sectionData3.id) ? ' id="' + soy.$$escapeHtml(sectionData3.id) + '"' : '') + ((sectionData3.style) ? ' class="' + soy.$$escapeHtml(sectionData3.style) + '"' : '') + '>';
    if (hasItems__soy4) {
      var itemList25 = sectionData3.items;
      var itemListLen25 = itemList25.length;
      for (var itemIndex25 = 0; itemIndex25 < itemListLen25; itemIndex25++) {
        var itemData25 = itemList25[itemIndex25];
        output += JIRA.Templates.Menu.Dropdowns.dropdown2Item(itemData25);
      }
    }
    output += '</ul></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Menu.Dropdowns.dropdown2Fragment.soyTemplateName = 'JIRA.Templates.Menu.Dropdowns.dropdown2Fragment';
}


JIRA.Templates.Menu.Dropdowns.dropdown2Item = function(opt_data, opt_ignored) {
  var output = '<li' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ((opt_data.style) ? ' class="' + soy.$$escapeHtml(opt_data.style) + '"' : '') + '><a href="' + soy.$$escapeHtml(opt_data.url) + '"' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '_lnk"' : '') + ((opt_data.title) ? ' title="' + soy.$$escapeHtml(opt_data.title) + '"' : '') + ' class="' + ((opt_data.iconUrl) ? 'aui-icon-container' : '') + ((opt_data.parameters && opt_data.parameters['class']) ? ' ' + soy.$$escapeHtml(opt_data.parameters['class']) : '') + '"';
  if (opt_data.parameters) {
    var keyList66 = soy.$$getMapKeys(opt_data.parameters);
    var keyListLen66 = keyList66.length;
    for (var keyIndex66 = 0; keyIndex66 < keyListLen66; keyIndex66++) {
      var keyData66 = keyList66[keyIndex66];
      output += (keyData66 != 'class') ? ' ' + soy.$$escapeHtml(keyData66) + '="' + soy.$$escapeHtml(opt_data.parameters[keyData66]) + '"' : '';
    }
  }
  output += '>' + ((opt_data.iconUrl) ? '<img class="icon" src="' + soy.$$escapeHtml(opt_data.iconUrl) + '" />' : '') + soy.$$escapeHtml(opt_data.label) + '</a></li>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Menu.Dropdowns.dropdown2Item.soyTemplateName = 'JIRA.Templates.Menu.Dropdowns.dropdown2Item';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:jira-header', location = 'js/init-dropdown2.js' */
/**
 * JIRA's implementation of AUI Dropdown2 remote API (https://extranet.atlassian.com/display/AUI/Dropdown2+remote+API).
 *
 * This predates AUI Dropdown2, and allows the application header menus to be dynamic and populated via AJAX. This is
 * required for menus that are dynamic (e.g. Issues or Projects).
 *
 * In addition to the normal `aui-dropdown2-show` event that is triggered on the dropdown, two extra events are
 * triggered to expose the asynchronous nature of the menus:
 *
 * - `aui-dropdown2-show-before` is triggered _before_ a dropdown is shown (due to implementation details, this is
 *    unfortunately triggered after `aui-dropdown2-show`).
 * - `aui-dropdown2-show-after` is triggered when the dropdown is populated and visible to the user. It is triggered for
 *    both remote dropdowns and normal dropdowns.
 *
 * The class `aui-dropdown2-loading` is added to the dropdown between `aui-dropdown2-show-before` and
 * `aui-dropdown2-show-after`.
 */
require(['jira/ajs/ajax/smart-ajax', 'jquery'], function (SmartAjax, $) {
    $(function () {
        $("nav.aui-header a.aui-dropdown2-trigger").each(function() {
            var $trigger = $(this);
            var $dropdown = $("#" + $trigger.attr("aria-owns"));
            var ajaxKey = $dropdown.data("aui-dropdown2-ajax-key");

            $dropdown.bind("aui-dropdown2-show", function (event, options) {
                $dropdown.trigger('aui-dropdown2-show-before');

                if (ajaxKey) {
                    // JIRA's own implementation of Dropdown2 remote API. This predates Dropdown2 remote, and should be
                    // removed when Dropdown2 remote API lands in AUI.
                    $dropdown.empty();
                    $dropdown.addClass("aui-dropdown2-loading");
                    SmartAjax.makeRequest({
                        url: AJS.contextPath() + "/rest/api/1.0/menus/" + ajaxKey,
                        data: {
                            inAdminMode: AJS.Meta.getBoolean("in-admin-mode")
                        },
                        dataType: "json",
                        cache: false,
                        success: function (data) {
                            $dropdown.removeClass("aui-dropdown2-loading");
                            $dropdown.html(JIRA.Templates.Menu.Dropdowns.dropdown2Fragment(data));

                            if (options && options.selectFirst) {
                                $dropdown.find("a:not(.disabled)").filter(":first").addClass("active");
                            }
                            $dropdown.trigger('aui-dropdown2-show-after');
                        }
                    });
                } else {
                    $dropdown.trigger('aui-dropdown2-show-after');
                }
            });
        });
    });
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/keymaster.js' */
//     keymaster.js
//     (c) 2011-2013 Thomas Fuchs
//     keymaster.js may be freely distributed under the MIT license.

;(function(global){
    var k,
            _handlers = {},
            _mods = { 16: false, 18: false, 17: false, 91: false },
            _scope = 'all',
    // modifier keys
            _MODIFIERS = {
                '⇧': 16, shift: 16,
                '⌥': 18, alt: 18, option: 18,
                '⌃': 17, ctrl: 17, control: 17,
                '⌘': 91, command: 91
            },
    // special keys
            _MAP = {
                backspace: 8, tab: 9, clear: 12,
                enter: 13, 'return': 13,
                esc: 27, escape: 27, space: 32,
                left: 37, up: 38,
                right: 39, down: 40,
                del: 46, 'delete': 46,
                home: 36, end: 35,
                pageup: 33, pagedown: 34,
                ',': 188, '.': 190, '/': 191,
                '`': 192, '-': 189, '=': 187,
                ';': 186, '\'': 222,
                '[': 219, ']': 221, '\\': 220
            },
            code = function(x){
                return _MAP[x] || x.toUpperCase().charCodeAt(0);
            },
            _downKeys = [];

    for(k=1;k<20;k++) _MAP['f'+k] = 111+k;

    // IE doesn't support Array#indexOf, so have a simple replacement
    function index(array, item){
        var i = array.length;
        while(i--) if(array[i]===item) return i;
        return -1;
    }

    // for comparing mods before unassignment
    function compareArray(a1, a2) {
        if (a1.length != a2.length) return false;
        for (var i = 0; i < a1.length; i++) {
            if (a1[i] !== a2[i]) return false;
        }
        return true;
    }

    var modifierMap = {
        16:'shiftKey',
        18:'altKey',
        17:'ctrlKey',
        91:'metaKey'
    };
    function updateModifierKey(event) {
        for(k in _mods) _mods[k] = event[modifierMap[k]];
    };

    // handle keydown event
    function dispatch(event) {
        var key, handler, k, i, modifiersMatch, scope;
        key = event.keyCode;

        if (index(_downKeys, key) == -1) {
            _downKeys.push(key);
        }

        // if a modifier key, set the key.<modifierkeyname> property to true and return
        if(key == 93 || key == 224) key = 91; // right command on webkit, command on Gecko
        if(key in _mods) {
            _mods[key] = true;
            // 'assignKey' from inside this closure is exported to window.key
            for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = true;
            return;
        }
        updateModifierKey(event);

        // see if we need to ignore the keypress (filter() can can be overridden)
        // by default ignore key presses if a select, textarea, or input is focused
        if(!assignKey.filter.call(this, event)) return;

        // abort if no potentially matching shortcuts found
        if (!(key in _handlers)) return;

        scope = getScope();

        // for each potential shortcut
        for (i = 0; i < _handlers[key].length; i++) {
            handler = _handlers[key][i];

            // see if it's in the current scope
            if(handler.scope == scope || handler.scope == 'all'){
                // check if modifiers match if any
                modifiersMatch = handler.mods.length > 0;
                for(k in _mods)
                    if((!_mods[k] && index(handler.mods, +k) > -1) ||
                            (_mods[k] && index(handler.mods, +k) == -1)) modifiersMatch = false;
                // call the handler and stop the event if neccessary
                if((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch){
                    if(handler.method(event, handler)===false){
                        if(event.preventDefault) event.preventDefault();
                        else event.returnValue = false;
                        if(event.stopPropagation) event.stopPropagation();
                        if(event.cancelBubble) event.cancelBubble = true;
                    }
                }
            }
        }
    };

    // unset modifier keys on keyup
    function clearModifier(event){
        var key = event.keyCode, k,
                i = index(_downKeys, key);

        // remove key from _downKeys
        if (i >= 0) {
            _downKeys.splice(i, 1);
        }

        if(key == 93 || key == 224) key = 91;
        if(key in _mods) {
            _mods[key] = false;
            for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = false;
        }
    };

    function resetModifiers() {
        for(k in _mods) _mods[k] = false;
        for(k in _MODIFIERS) assignKey[k] = false;
    };

    // parse and assign shortcut
    function assignKey(key, scope, method){
        var keys, mods;
        keys = getKeys(key);
        if (method === undefined) {
            method = scope;
            scope = 'all';
        }

        // for each shortcut
        for (var i = 0; i < keys.length; i++) {
            // set modifier keys if any
            mods = [];
            key = keys[i].split('+');
            if (key.length > 1){
                mods = getMods(key);
                key = [key[key.length-1]];
            }
            // convert to keycode and...
            key = key[0]
            key = code(key);
            // ...store handler
            if (!(key in _handlers)) _handlers[key] = [];
            _handlers[key].push({ shortcut: keys[i], scope: scope, method: method, key: keys[i], mods: mods });
        }
    };

    // unbind all handlers for given key in current scope
    function unbindKey(key, scope) {
        var multipleKeys, keys,
                mods = [],
                i, j, obj;

        multipleKeys = getKeys(key);

        for (j = 0; j < multipleKeys.length; j++) {
            keys = multipleKeys[j].split('+');

            if (keys.length > 1) {
                mods = getMods(keys);
                key = keys[keys.length - 1];
            }

            key = code(key);

            if (scope === undefined) {
                scope = getScope();
            }
            if (!_handlers[key]) {
                return;
            }
            for (i in _handlers[key]) {
                obj = _handlers[key][i];
                // only clear handlers if correct scope and mods match
                if (obj.scope === scope && compareArray(obj.mods, mods)) {
                    _handlers[key][i] = {};
                }
            }
        }
    };

    // Returns true if the key with code 'keyCode' is currently down
    // Converts strings into key codes.
    function isPressed(keyCode) {
        if (typeof(keyCode)=='string') {
            keyCode = code(keyCode);
        }
        return index(_downKeys, keyCode) != -1;
    }

    function getPressedKeyCodes() {
        return _downKeys.slice(0);
    }

    function filter(event){
        var tagName = (event.target || event.srcElement).tagName;
        // ignore keypressed in any elements that support keyboard data input
        return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');
    }

    // initialize key.<modifier> to false
    for(k in _MODIFIERS) assignKey[k] = false;

    // set current scope (default 'all')
    function setScope(scope){ _scope = scope || 'all' };
    function getScope(){ return _scope || 'all' };

    // delete all handlers for a given scope
    function deleteScope(scope){
        var key, handlers, i;

        for (key in _handlers) {
            handlers = _handlers[key];
            for (i = 0; i < handlers.length; ) {
                if (handlers[i].scope === scope) handlers.splice(i, 1);
                else i++;
            }
        }
    };

    // abstract key logic for assign and unassign
    function getKeys(key) {
        var keys;
        key = key.replace(/\s/g, '');
        keys = key.split(',');
        if ((keys[keys.length - 1]) == '') {
            keys[keys.length - 2] += ',';
        }
        return keys;
    }

    // abstract mods logic for assign and unassign
    function getMods(key) {
        var mods = key.slice(0, key.length - 1);
        for (var mi = 0; mi < mods.length; mi++)
            mods[mi] = _MODIFIERS[mods[mi]];
        return mods;
    }

    // cross-browser events
    function addEvent(object, event, method) {
        if (object.addEventListener)
            object.addEventListener(event, method, false);
        else if(object.attachEvent)
            object.attachEvent('on'+event, function(){ method(window.event) });
    };

    // set the handlers globally on document
    addEvent(document, 'keydown', function(event) { dispatch(event) }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48
    addEvent(document, 'keyup', clearModifier);

    // reset modifiers to false whenever the window is (re)focused.
    addEvent(window, 'focus', resetModifiers);

    // store previously defined key
    var previousKey = global.key;

    // restore previously defined key and return reference to our key object
    function noConflict() {
        var k = global.key;
        global.key = previousKey;
        return k;
    }

    // set window.key and window.key.set/get/deleteScope, and the default filter
    global.key = assignKey;
    global.key.setScope = setScope;
    global.key.getScope = getScope;
    global.key.deleteScope = deleteScope;
    global.key.filter = filter;
    global.key.isPressed = isPressed;
    global.key.getPressedKeyCodes = getPressedKeyCodes;
    global.key.noConflict = noConflict;
    global.key.unbind = unbindKey;

    if(typeof module !== 'undefined') module.exports = key;

})(this);;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/amd-wrappers.js' */
/* AMD wrappers for commonly used objects */

define('wiki-edit/aui', function() { return AJS; });
define('wiki-edit/JIRA', function() { return JIRA; });
define('wiki-edit/keymaster', ["wiki-edit/aui"], function(AJS) {
    if (AJS.Meta.get("keyboard-shortcuts-enabled") === false) {
        return function keyMasterNoop() {};
    }
    return key.noConflict();
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/templates/wiki-editor.soy' */
// This file was automatically generated from wiki-editor.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Plugins.WikiEditor.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Plugins == 'undefined') { JIRA.Templates.Plugins = {}; }
if (typeof JIRA.Templates.Plugins.WikiEditor == 'undefined') { JIRA.Templates.Plugins.WikiEditor = {}; }


JIRA.Templates.Plugins.WikiEditor.renderEditor = function(opt_data, opt_ignored) {
  var output = '<div id="wiki-edit-dropdown2-text-style-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="paragraph" title="' + soy.$$escapeHtml("Paragraph") + '">' + soy.$$escapeHtml("Paragraph") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h1" data-operation="h1" title="' + soy.$$escapeHtml("Heading 1") + '">' + soy.$$escapeHtml("Heading 1") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h2" data-operation="h2" title="' + soy.$$escapeHtml("Heading 2") + '">' + soy.$$escapeHtml("Heading 2") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h3" data-operation="h3" title="' + soy.$$escapeHtml("Heading 3") + '">' + soy.$$escapeHtml("Heading 3") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h4" data-operation="h4" title="' + soy.$$escapeHtml("Heading 4") + '">' + soy.$$escapeHtml("Heading 4") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h5" data-operation="h5" title="' + soy.$$escapeHtml("Heading 5") + '">' + soy.$$escapeHtml("Heading 5") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h6" data-operation="h6" title="' + soy.$$escapeHtml("Heading 6") + '">' + soy.$$escapeHtml("Heading 6") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-monospace" data-operation="monospace" title="' + soy.$$escapeHtml("Preformatted") + '">' + soy.$$escapeHtml("Preformatted") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="paragraph-quote" title="' + soy.$$escapeHtml("Paragraph quote") + '">' + soy.$$escapeHtml("Paragraph quote") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="block-quote" title="' + soy.$$escapeHtml("Block quote") + '">' + soy.$$escapeHtml("Block quote") + '</a></li></ul></div></div><div id="wiki-edit-dropdown2-more-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="delete" data-shortcut="ctrl+shift+s, command+shift+s" title="' + soy.$$escapeHtml("Strikethrough") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+Shift+S)">' + soy.$$escapeHtml("Strikethrough") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="superscript">' + soy.$$escapeHtml("Superscript") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="subscript">' + soy.$$escapeHtml("Subscript") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="cite">' + soy.$$escapeHtml("Citation") + '</a></li></ul></div></div><div id="wiki-edit-dropdown2-link-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown wiki-edit-dropdown-link"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="link" data-shortcut="ctrl+k, command+k" title="' + soy.$$escapeHtml("External link") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+K)">' + soy.$$escapeHtml("External link") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="link-mail">' + soy.$$escapeHtml("Mail link") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="link-anchor">' + soy.$$escapeHtml("Anchor link") + '</a></li>' + ((! opt_data.attachmentM2FeatureFlag) ? '<li><a href="#" class="wiki-edit-operation" data-operation="link-attachment">' + soy.$$escapeHtml("Attachment link") + '</a></li>' : '') + '</ul></div>' + ((! opt_data.attachmentM2FeatureFlag) ? '<div class="aui-dropdown2-section wiki-edit-insert-link"><strong>' + soy.$$escapeHtml("Attachment link") + '</strong><ul class="aui-list-truncate"><li><a href="#"></a></li></ul></div>' : '') + '</div>' + ((! opt_data.attachmentM2FeatureFlag) ? '<div id="wiki-edit-dropdown2-image-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown wiki-edit-dropdown-image"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="image" title="' + soy.$$escapeHtml("External image") + '">' + soy.$$escapeHtml("External image") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="image-attachment">' + soy.$$escapeHtml("Attached image") + '</a></li></ul></div><div class="aui-dropdown2-section wiki-edit-insert-image"><strong>' + soy.$$escapeHtml("Attached image") + '</strong><ul class="aui-list-truncate"><li><a href="#"></a></li></ul></div></div>' : '<div id="wiki-edit-dropdown2-attachment-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown wiki-edit-dropdown-attachment"><div class="aui-dropdown2-section wiki-edit-insert-attachment"><ul class="aui-list-truncate"><li><a href="#"></a></li></ul></div><div class="aui-dropdown2-section wiki-edit-browse-image"><ul class="aui-list-truncate"><li><a href="#" class="wiki-attachment-browse"><span class="aui-icon aui-icon-small aui-iconfont-add"></span>&nbsp;&nbsp;' + soy.$$escapeHtml("Browse") + '</a></li></ul></div></div>') + '<div id="wiki-edit-color-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-picker wiki-edit-color-picker" data-container="wiki-edit-color-picker-buttons-' + soy.$$escapeHtml(opt_data.editorId) + '">';
  var colors__soy108 = ['333333', '707070', 'cccccc', '205081', '59afe1', '14892c', '8eb021', 'd04437', 'f79232', 'f6c342', '654982', 'f691b2'];
  output += '<div class="aui-dropdown2-section"><ul>';
  var colorList110 = colors__soy108;
  var colorListLen110 = colorList110.length;
  for (var colorIndex110 = 0; colorIndex110 < colorListLen110; colorIndex110++) {
    var colorData110 = colorList110[colorIndex110];
    output += '<li><a href="#" style="background-color: #' + soy.$$escapeHtml(colorData110) + '" data-operation="color" data-color="#' + soy.$$escapeHtml(colorData110) + '">&nbsp;</a></li>';
  }
  output += '</ul></div></div><div id="wiki-edit-dropdown2-icon-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-picker wiki-edit-icon-picker" data-container="wiki-edit-icon-picker-buttons-' + soy.$$escapeHtml(opt_data.editorId) + '"><div class="aui-dropdown2-section"><ul><li><a href="#" class="wiki-edit-operation" title=":)" data-operation=":)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/smile.gif" alt="' + soy.$$escapeHtml("smile") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=":(" data-operation=":("><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/sad.gif" alt="' + soy.$$escapeHtml("sad") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=":P" data-operation=":P"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/tongue.gif" alt="' + soy.$$escapeHtml("tongue") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=":D" data-operation=":D"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/biggrin.gif" alt="' + soy.$$escapeHtml("biggrin") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=";)" data-operation=";)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/wink.gif" alt="' + soy.$$escapeHtml("wink") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(y)" data-operation="(y)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/thumbs_up.gif" alt="' + soy.$$escapeHtml("thumbs up") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(n)" data-operation="(n)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/thumbs_down.gif" alt="' + soy.$$escapeHtml("thumbs down") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(i)" data-operation="(i)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/information.gif" alt="' + soy.$$escapeHtml("information") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(/)" data-operation="(/)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/check.gif" alt="' + soy.$$escapeHtml("check") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(x)" data-operation="(x)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/error.gif" alt="' + soy.$$escapeHtml("error") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(!)" data-operation="(!)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/warning.gif" alt="' + soy.$$escapeHtml("warning") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(+)" data-operation="(+)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/add.gif" alt="' + soy.$$escapeHtml("add") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(-)" data-operation="(-)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/forbidden.gif" alt="' + soy.$$escapeHtml("forbidden") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(?)" data-operation="(?)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/help_16.gif" alt="' + soy.$$escapeHtml("help") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(on)" data-operation="(on)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/lightbulb_on.gif" alt="' + soy.$$escapeHtml("lightbulb on") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(off)" data-operation="(off)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/lightbulb.gif" alt="' + soy.$$escapeHtml("lightbulb") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*)" data-operation="(*)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_yellow.gif" alt="' + soy.$$escapeHtml("star yellow") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*r)" data-operation="(*r)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_red.gif" alt="' + soy.$$escapeHtml("star red") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*g)" data-operation="(*g)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_green.gif" alt="' + soy.$$escapeHtml("star green") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*b)" data-operation="(*b)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_blue.gif" alt="' + soy.$$escapeHtml("star blue") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*y)" data-operation="(*y)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_yellow.gif" alt="' + soy.$$escapeHtml("star yellow") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(flag)" data-operation="(flag)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/flag.gif" alt="' + soy.$$escapeHtml("flag") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(flagoff)" data-operation="(flagoff)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/flag_grey.gif" alt="' + soy.$$escapeHtml("flag off") + '" /></a></li></ul></div></div><div id="wiki-edit-dropdown2-other-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="mention">' + soy.$$escapeHtml("User mention") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="table">' + soy.$$escapeHtml("Table") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="code">' + soy.$$escapeHtml("Code") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="noformat">' + soy.$$escapeHtml("Preformatted") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="panel">' + soy.$$escapeHtml("Panel") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="hr">' + soy.$$escapeHtml("Horizontal ruler") + '</a></li><li class="wiki-edit-speech-item hidden"><a href="#" class="wiki-edit-operation" data-operation="speech">' + soy.$$escapeHtml("Speech recognition") + '</a></li></ul></div></div><div class="wiki-edit-toolbar" id="wiki-edit-' + soy.$$escapeHtml(opt_data.editorId) + '"><div class="aui-toolbar2"><div class="aui-toolbar2-inner"><div class="aui-toolbar2-primary"><div class="aui-buttons"><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-style-picker-trigger" aria-owns="wiki-edit-dropdown2-text-style-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-text-style-' + soy.$$escapeHtml(opt_data.editorId) + '">' + soy.$$escapeHtml("Style") + '</a></div><div class="aui-buttons wiki-edit-toolbar-section"><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="bold" data-shortcut="ctrl+b, command+b" title="' + soy.$$escapeHtml("Bold") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+B)"><span class="aui-icon aui-icon-small aui-iconfont-editor-bold">' + soy.$$escapeHtml("Bold") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="italic" data-shortcut="ctrl+i, command+i" title="' + soy.$$escapeHtml("Italic") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+I)"><span class="aui-icon aui-icon-small aui-iconfont-editor-italic">' + soy.$$escapeHtml("Italic") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="underline" data-shortcut="ctrl+u, command+u" title="' + soy.$$escapeHtml("Underline") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+U)"><span class="aui-icon aui-icon-small aui-iconfont-editor-underline">' + soy.$$escapeHtml("Underline") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation wiki-edit-operation-color" data-operation="color" data-color="red" title="' + soy.$$escapeHtml("Text color") + '"><span class="aui-icon aui-icon-small aui-iconfont-editor-color">' + soy.$$escapeHtml("Text color") + '</span><span class="wiki-edit-color-indicator"></span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-color-picker-trigger" data-operation="color-parameter" aria-owns="wiki-edit-color-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" title="' + soy.$$escapeHtml("More colors") + '"><span>' + soy.$$escapeHtml("More colors") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-more-picker-trigger" aria-owns="wiki-edit-dropdown2-more-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-more-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("More") + '"><span class="aui-icon aui-icon-small aui-iconfont-editor-styles">' + soy.$$escapeHtml("More") + '</span></a></div><div class="aui-buttons"><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-link-picker-trigger" aria-owns="wiki-edit-dropdown2-link-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-link-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Link") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+K)"><span class="aui-icon aui-icon-small aui-iconfont-link">' + soy.$$escapeHtml("Link") + '</span></a>' + ((! opt_data.attachmentM2FeatureFlag) ? '<a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-image-picker-trigger" aria-owns="wiki-edit-dropdown2-image-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-image-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Image") + '"><span class="aui-icon aui-icon-small aui-iconfont-image">' + soy.$$escapeHtml("Image") + '</span></a>' : '<a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-attachment-picker-trigger" aria-owns="wiki-edit-dropdown2-attachment-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-attachment-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Attachment") + '"><span class="aui-icon aui-icon-small aui-iconfont-file-generic">' + soy.$$escapeHtml("Attachment") + '</span></a>') + '</div><div class="aui-buttons wiki-edit-toolbar-section"><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="bullet-list" data-shortcut="ctrl+shift+b, command+shift+b" title="' + soy.$$escapeHtml("Bullet list") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+Shift+B)"><span class="aui-icon aui-icon-small aui-iconfont-editor-list-bullet">' + soy.$$escapeHtml("Bullet list") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="numbered-list" data-shortcut="ctrl+shift+n, command+shift+n" title="' + soy.$$escapeHtml("Numbered list") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+Shift+N)"><span class="aui-icon aui-icon-small aui-iconfont-editor-list-number">' + soy.$$escapeHtml("Numbered list") + '</span></a></div><div class="aui-buttons"><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-icon-picker-trigger wiki-edit-tooltip" aria-owns="wiki-edit-dropdown2-icon-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-icon-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Icons") + '"><span class="aui-icon aui-icon-small aui-iconfont-editor-emoticon">' + soy.$$escapeHtml("Icons") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-other-picker-trigger wiki-edit-tooltip" aria-owns="wiki-edit-dropdown2-other-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-other-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Other") + '"><span class="aui-icon aui-icon-small aui-iconfont-add">' + soy.$$escapeHtml("Other") + '</span></a></div><div class="aui-buttons wiki-edit-toolbar-last"><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-visible-toggle wiki-edit-tooltip" title="' + soy.$$escapeHtml("Toggle visibility") + '"><span class="aui-icon icon-toolbartoggle">Lock / Unlock</span></a></div></div></div><!-- .aui-toolbar-inner --></div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Plugins.WikiEditor.renderEditor.soyTemplateName = 'JIRA.Templates.Plugins.WikiEditor.renderEditor';
}


JIRA.Templates.Plugins.WikiEditor.renderListItem = function(opt_data, opt_ignored) {
  return '<li><a href="#" ' + soy.$$escapeHtml(opt_data.attachmentType ? 'data-attachment-type=' + opt_data.attachmentType : '') + '>' + ((opt_data.attachmentM2FeatureFlagEnabled) ? '<span class="wiki-edit-attachment-type-icon aui-icon aui-icon-small ' + soy.$$escapeHtml(((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.cssClass) != null ? ((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.cssClass) : 'aui-iconfont-file-txt') + '" title="' + soy.$$escapeHtml(((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.title) != null ? ((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.title) : 'File') + '"></span>&nbsp;&nbsp;' : '') + '<span class="wiki-edit-attachment-name">' + soy.$$escapeHtml(opt_data.text) + '</span></a></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.Plugins.WikiEditor.renderListItem.soyTemplateName = 'JIRA.Templates.Plugins.WikiEditor.renderListItem';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/Analytics.js' */
define('wiki-edit/analytics',[
    'wiki-edit/aui'
], function(AJS) {

    var triggerEvent = (AJS.Analytics && AJS.Analytics.triggerPrivacyPolicySafeEvent) ?
        (function triggerEvent(name, props) {
            AJS.Analytics.triggerPrivacyPolicySafeEvent('jira.wikieditor.' + name, props || {});
        }) :
        (function triggerEvent(name, props) {
            AJS.trigger("analytics", { name: 'jira.wikieditor.'+name, data: props || {} });
        });

    function hashCode (string) {
        var charCode;
        var hash = 0;
        if (!string) {
            return "";
        }

        for (var i = 0; i < string.length; i += 1) {
            charCode = string.charCodeAt(i);
            hash = ((hash * 32) - hash) + charCode;
            hash |= 0; // force 32-bit representation
        }

        return hash;
    }

    return {
        trigger: triggerEvent,
        hashCode: hashCode
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/KeyTester.js' */
define('wiki-edit/KeyTester', function() {

    return {
        getActionType: function(keyCode) {
            if (this.isNavigation(keyCode)) {
                return "navigating";
            } else if (this.isDeleting(keyCode)) {
                return "deleting";
            } else if (this.isReturn(keyCode)) {
                return "newline";
            } else if (this.isEscape(keyCode)) {
                return "escape";
            } else if (this.isTyping(keyCode)) {
                return "typing";
            }
        },
        isNavigation: function(keyCode) {
            // 33 - 40: page up/dn and arrow keys
            // 63232 - 63235: page up/dn and arrow keys on safari
            return (keyCode >= 33 && keyCode <= 40) || (keyCode >= 63232 && keyCode <= 63235);
        },
        isDeleting: function(keyCode) {
            // 8 - backspace
            // 46 - delete
            // 127 - delete
            return (keyCode == 8 || keyCode == 46 || keyCode == 127);
        },
        isReturn: function(keyCode) {
            return (keyCode == 13);
        },
        isEscape: function(keyCode) {
            return (keyCode == 27);
        },
// not needed at this stage but left for possible later use
//        isSpacebar: function(keyCode) {
//            return keyCode == 32; // spacebar
//        },
        isTyping: function(keyCode) {
            return (keyCode > 47 && keyCode < 58)   || // numbers
                   (keyCode > 95 && keyCode < 112)  || // numpad
                   (keyCode > 64 && keyCode < 91)   || // letters
                   (keyCode > 185 && keyCode < 193) || // ;=,-./`
                   (keyCode > 218 && keyCode < 223) || // [\]'
                    keyCode == 32                   || // spacebar
                    keyCode == 13;                     // return

        }
    };

});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/UndoManager.js' */
define('wiki-edit/UndoManager', function() {

    /**
     * Simple undo/redo manager.
     * Basically the structure is like [---undoList---][CURRENT][---redoList---].
     * All operations move the current element on that "concatenated" list.
     */
    var UndoManager =  function() {
        this._undoStack = [];
        this._redoStack = [];
        this._current = undefined;
    };

    UndoManager.prototype.MAX_STACK = 1000;
    /**
     * Sets the current state of the manager
     * @param {Anything} current - state
     * @param {Boolean} preserveRedo - if set to true existing redo entries will be preserved
     */
    UndoManager.prototype.updateCurrent = function(current, preserveRedo) {
        if (current != this._current) {
            this._current = current;
            if(!preserveRedo) {
                this._redoStack.length = 0; // reset the redo stack
            }
        }
    };

    /**
     * Add val to the undo stack and make it undoable
     * @param {Anything} val - state to be made undoable
     */
    UndoManager.prototype.push = function(val) {
        this._redoStack.length = 0; // reset the redo stack
        if (!this._undoStack.length || !_.isEqual(val, this._undoStack[this._undoStack.length - 1])) {
            this._undoStack.push(val);
            this._current = val;
        }
        if (this._undoStack.length > this.MAX_STACK) {
            this._undoStack.splice(0, this._undoStack.length - this.MAX_STACK)
        }
    };

    /**
     * Undo a value. Set it to be the current element and push the current element to the redo stack
     * @return {Anything} current value after the undo operation
     */
    UndoManager.prototype.undo = function() {
        if (!this.canUndo()) { return; }
        var val;
        do {
            val = this._undoStack.pop();
        } while (_.isEqual(val, this._current) && this.canUndo());
        this._redoStack.push(this._current);
        this._current = val;
        return val;
    };

    /**
     * Redo a value. Set it to be the current element and push the current element to the undo stack
     * @return {Anything} current value after the redo operation
     */
    UndoManager.prototype.redo = function() {
        if (!this.canRedo()) { return; }
    
        var val = this._redoStack.pop();
        this._undoStack.push(this._current);
        this._current = val;
        return val;
    };

    /**
     * Check if it is possible to undo
     * @return {Boolean}
     */
    UndoManager.prototype.canUndo = function() {
        return !!this._undoStack.length;
    };

    /**
     * Check if it is possible to redo
     * @return {Boolean}
     */
    UndoManager.prototype.canRedo = function() {
        return !!this._redoStack.length;
    };

    return UndoManager;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/UndoableTextarea.js' */
define('wiki-edit/UndoableTextarea', [
        'wiki-edit/UndoManager',
        'wiki-edit/KeyTester',
        'jquery'
], function(
    UndoManager,
    KeyTester,
    $
) {

    var CUT_PASTE_MODE = "cut-paste";
    var _lastEditMode = "";

    function _setEditMode(context, newMode) {
        if (newMode === CUT_PASTE_MODE || _lastEditMode != newMode) {
            if (_lastEditMode != "newline") {
                context.recordHistoryItem();
            }
            _lastEditMode = newMode;
        }
    }

    function _manipulateHistory(context, stateName) {
        if (context.undoManager["can" + stateName[0].toUpperCase() + stateName.substring(1)]()) {
            var state = context.undoManager[stateName]();
            context.element.value = state.value;
            context.element.selectionStart = state.selectionStart;
            context.element.selectionEnd = state.selectionEnd;
        }
    }

    var UndoableTextarea = function UndoableTextarea(element) {
        this.element = element;
        this.$el = $(element);
        this.undoManager = new UndoManager();
        this.undoManager.updateCurrent(this.getValue());
        this.undoManager.push(this.getValue());

        var handleKeyboardInput = (function handleChange(e) {
            var keyCode = e.keyCode;
            var keyCodeChar = String.fromCharCode(keyCode);

            if (keyCode) {
                if (!e.ctrlKey && !e.metaKey) {
                    this.undoManager.updateCurrent(this.getValue());
                    _setEditMode(this, KeyTester.getActionType(keyCode));
                } else if ((e.ctrlKey || e.metaKey) && !e.altKey) {
                    switch (keyCodeChar.toLowerCase()) {
                        case "y":
                            this.undoManager.updateCurrent(this.getValue(), true);
                            this.redo();
                            e.preventDefault();
                            break;

                        case "z":
                            this.undoManager.updateCurrent(this.getValue(), true);
                            if (!e.shiftKey) {
                                this.undo();
                            } else {
                                this.redo();
                            }
                            e.preventDefault();
                            break;
                    }
                }
            } else {
                this.undoManager.updateCurrent(this.getValue());
                _setEditMode(this, "other");
            }
        }).bind(this);

        this.$el.on("keydown", handleKeyboardInput);

        this.$el.on("paste cut", function handleCutAndPaste() {
            this.undoManager.updateCurrent(this.getValue());
            _setEditMode(this, CUT_PASTE_MODE);
        }.bind(this));
    };

    UndoableTextarea.prototype.getValue = function() {
        return {
            value: this.element.value,
            selectionStart: this.element.selectionStart,
            selectionEnd: this.element.selectionEnd
        };
    };

    UndoableTextarea.prototype.updateCurrent = function() {
        this.undoManager.updateCurrent(this.getValue());
    };

    UndoableTextarea.prototype.recordHistoryItem = function() {
        this.undoManager.push(this.getValue());
    };

    UndoableTextarea.prototype.undo = function() {
        _setEditMode(this, "undo");
        _manipulateHistory(this, "undo");
        this.element.scrollTop = this.element.scrollHeight;
    };

    UndoableTextarea.prototype.redo = function() {
        _manipulateHistory(this, "redo");
        this.element.scrollTop = this.element.scrollHeight;
    };

    return UndoableTextarea;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/TextareaManipulator.js' */
define('wiki-edit/TextareaManipulator', function() {

    var TextareaManipulator = function(element) {
        this.el = element;
    };
    
    TextareaManipulator.prototype.NEW_LINE_TOKEN = "\n";
    
    /**
     * Gets object containing selection info
     * @returns {{position: number, start: number, end: number, length: number, text: string}}
     */
    TextareaManipulator.prototype.getSelection = function() {
        return {
            start: this.el.selectionStart,
            end: this.el.selectionEnd,
            length: this.el.selectionEnd - this.el.selectionStart,
            text: this.el.value.substring(this.el.selectionStart, this.el.selectionEnd)
        };
    };
    
    /**
     * Sets selection
     * @param start {number} index in the string, start of the selection
     * @param end {number} index in the string, end of the selection
     */
    TextareaManipulator.prototype.setSelection = function(start, end) {
        if (arguments.length === 1) {
            end = start;
        }
        this.el.selectionStart = start;
        this.el.selectionEnd = end;
    };
    
    /**
     * Replaces selected text with a parameter, if no text is selected
     * it's inserted where the cursor is
     * @param text {string} text to replace selection with
     * @param selectReplaced {Boolean} indicates if inserted text should be selected
     */
    TextareaManipulator.prototype.replaceSelectionWith = function(text, selectReplaced) {
        var start = this.el.selectionStart;
        var val = this.el.value;
        this.el.value = val.substring(0, this.el.selectionStart) + text + val.substring(this.el.selectionEnd, val.length);
    
        this.el.selectionEnd = start + text.length;
        this.el.selectionStart = (selectReplaced) ? start : this.el.selectionEnd;
    };
    
    /**
     * Wraps selection with a prefix and a suffix but only if it isn't already wrapped
     * @param prefix {string}
     * @param suffix {string}
     * @param placeholder {string} text to put between prefix and suffix if no selection was made
     */
    TextareaManipulator.prototype.wrapSelectionWith = function(prefix, suffix, placeholder) {
        if (arguments.length < 3) {
            placeholder = "";
        }
        if (arguments.length === 1) {
            suffix = prefix;
        }
        var selection = this.getSelection();
        var val = this.el.value;
    
        if (val.substring(selection.start - prefix.length, selection.start) === prefix &&
            val.substring(selection.end, selection.end + suffix.length) === suffix) {
            return;
        }
    
        var middle = val.substring(selection.start, selection.end);
        if (middle.length == 0) {
            middle = placeholder;
        }
        this.el.value = val.substring(0, selection.start) + prefix + middle + suffix + val.substring(selection.end, val.length);
        var newSelectionStart = selection.start + prefix.length;
        this.setSelection(newSelectionStart, newSelectionStart + middle.length);
    };
    
    /**
     * Finds selected lines within the textarea and returns an object containing full contents of the object
     * as an array of lines and start and end indexes of the selected lines
     * @returns {{lines: Array, start: number, end: number}}
     * @private
     */
    TextareaManipulator.prototype._getSelectedLines = function() {
        var val = this.el.value;
        var selection = this.getSelection();
        var startLine = val.substring(0, selection.start).split(this.NEW_LINE_TOKEN).length - 1; // 0-based index
        var endLine = startLine + val.substring(selection.start, selection.end).split(this.NEW_LINE_TOKEN).length - 1; // 0-based index
        var lines = val.split(this.NEW_LINE_TOKEN);
        return {
            lines: lines,
            start: startLine,
            end: endLine
        }
    };
    
    /**
     * Returns line at which cursor is (or end of the selection)
     * @returns {string}
     */
    TextareaManipulator.prototype.getLineAtCursor = function() {
        var linesSelection = this._getSelectedLines();
        return linesSelection.lines[linesSelection.end];
    };

    /**
     * Return regexp match of the fist line in the selection
     * @param pattern {regexp} prefix to check against
     * @returns {string} matched string or {undefined}
     */
    TextareaManipulator.prototype.getFirstLineMatch = function(pattern) {
        var linesSelection = this._getSelectedLines();
        var match = linesSelection.lines[linesSelection.start].match(pattern);
        if (match) {
            return match[0];
        }
    };
    
    /**
     * Checks if any of the selected lines is prefixed with a given string
     * @param prefix {string} prefix to check against
     * @returns {boolean}
     */
    TextareaManipulator.prototype.areSelectedLinesPrefixed = function(prefix) {
        var linesSelection = this._getSelectedLines();
        var currentLine;
    
        for (currentLine = linesSelection.start; currentLine <= linesSelection.end; currentLine++) {
            if (linesSelection.lines[currentLine].indexOf(prefix) == 0) {
                return true;
            }
        }
        return false;
    };
    
    /**
     * Prefixes selected lines with a given parameter. Lines already containing the prefix remain unchanged
     * @param prefix {string}
     */
    TextareaManipulator.prototype.prefixSelectedLines = function(prefix) {
        var selection = this.getSelection();
        var linesSelection = this._getSelectedLines();
        var currentLine;
        var prefixedLines = 0;
        var firstLinePrefixed = true;
        for (currentLine = linesSelection.start; currentLine <= linesSelection.end; currentLine++) {
            if (linesSelection.lines[currentLine].indexOf(prefix) == 0) {
                if (currentLine == linesSelection.start) {
                    firstLinePrefixed = false;
                }
                continue; //don't prefix lines which already have ie
            }
            prefixedLines += 1;
            linesSelection.lines[currentLine] = prefix + linesSelection.lines[currentLine];
        }
        this.el.value = linesSelection.lines.join(this.NEW_LINE_TOKEN);
    
        var prefixesLength = prefix.length * prefixedLines;
        this.setSelection(selection.start + ((firstLinePrefixed) ? prefix.length : 0), selection.end + prefixesLength);
    };
    
    /**
     * Removes prefix from selected lines
     * @param prefix {string}
     */
    TextareaManipulator.prototype.unprefixSelectedLines = function(prefix) {
        var selection = this.getSelection();
        var linesSelection = this._getSelectedLines();
        var currentLine;
        var firstLinePrefix = false;
        var prefixedLines = 0;
    
        for (currentLine = linesSelection.start; currentLine <= linesSelection.end; currentLine++) {
            if (linesSelection.lines[currentLine].indexOf(prefix) == 0) {
                prefixedLines += 1;
                linesSelection.lines[currentLine] = linesSelection.lines[currentLine].substring(prefix.length);
                if (currentLine == linesSelection.start) {
                    firstLinePrefix = true;
                }
            }
        }
        this.el.value = linesSelection.lines.join(this.NEW_LINE_TOKEN);

        var prefixesLength = prefix.length * prefixedLines;
        this.setSelection(selection.start - ((firstLinePrefix) ? prefix.length : 0), selection.end - prefixesLength);
    };

    return TextareaManipulator;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/keymaster-setup.js' */
define('wiki-edit/keymaster-setup', [
    'jquery',
    'wiki-edit/keymaster'
], function($, key) {
    return {
        init: function () {
            // Set-up library handling key bindings to correctly set scopes for wiki editor
            key.filter = function(event) {
                var element = event.target || event.srcElement || false;
                var editor;
                if (element && (' ' + element.className + ' ').indexOf(' wiki-textfield ') > -1) {
                    editor = $(element).data("wikiEditor");
                    if (editor) {
                        key.setScope(editor.id);
                        return true;
                    }
                }
                return false;
            };
        }
    }
});


;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/WikiEnabledTextarea.js' */
define('wiki-edit/WikiEnabledTextarea', [
        'wiki-edit/TextareaManipulator',
        'wiki-edit/UndoableTextarea',
        'wiki-edit/keymaster',
        'wiki-edit/keymaster-setup',
        'featureflags/feature-manager',
        'wiki-edit/SpeechRecognition',
        'jquery'
], function(TextareaManipulator, UndoableTextarea, onKey, keymasterSetup, FeatureManager, speechRecognition, $) {
    keymasterSetup.init();

    var editorCount = 0;
    // matches any combination of "*" and "#" followed by space which is any list, no matter how deeply nested
    var autocontinuingPrefixMarkupRegexp = /^[#\*]+ /;

    var WikiEnabledTextarea = function(element) {
        this.el = element;
        this.$el = $(element);
        if (this.$el.data("wikiEditor")) {
            // this will be very rare so defensive caching of this value doesn't seem to make much sense
            return this.$el.data("wikiEditor");
        }

        this.id = "wikiEdit" + editorCount;
        editorCount += 1;
        this.manipulationEngine = new TextareaManipulator(this.el);
        this.undoRedoEl = new UndoableTextarea(element);

        var wikiEditor = this;
        // on enter, continue list if possible or discontinue it if current list item is empty
        onKey("enter", wikiEditor.id, function onEnterKey(e) {
            var selection = wikiEditor.manipulationEngine.getSelection();
            var prefix = wikiEditor.manipulationEngine.getFirstLineMatch(autocontinuingPrefixMarkupRegexp);
            if (prefix) {
                if (selection.length == 0 && wikiEditor.manipulationEngine.getLineAtCursor() === prefix) {
                    wikiEditor.manipulationEngine.unprefixSelectedLines(prefix);
                } else {
                    wikiEditor.manipulationEngine.replaceSelectionWith("\n" + prefix);
                }
                e.preventDefault();
            }
        });

        this.$el.data("wikiEditor", this);
    };

    /**
     * Standard wiki markup in the form of <prefix>text<suffix> like *bold*, _italic_ or [mailto:someone@example.com].
     * Every time such markup is inserted:
     *     - if user didn't select any text, the placeholder text will be inserted and selected,
     *     - if user selected some text, this text will be wrapped with prefix and suffix.
     *
     * Each of this properties gets a function on the prototype with the same name
     * that changes value of textarea to apply the markup.
     */
    var wrapperMarkup = {
        'bold': ["*", "*", "strong text"],
        'italic': ["_", "_", "emphasized text"],
        'underline': ["+", "+", "underlined text"],
        'delete': ["-", "-", "deleted text"],
        'superscript': ["^", "^", "superscript text"],
        'subscript': ["~", "~", "subscript text"],
        'monospace': ["{{", "}}", "monospaced text"],
        'cite': ["??", "??", "citation"],
        'block-quote': ["{quote}", "{quote}", "quoted text"],
        'color': ["{color:$1}", "{color}", "colored text", "red"], // 4th parameter is a default value to replace $
        'link': ["[", "]", "link title"+"|http://example.com"],
        'link-anchor': ["[#", "]", "anchor"],
        'link-mail': ["[mailto:", "]", "mail@example.com"],
        'image': ["!", "!", "http://example.com/image.png"],
        'mention': ["@", "", "Mention someone by typing their name..."],
        'code': ["\n{code:java}\n","\n{code}\n", "// Some comments here\npublic String getFoo()\n{\n    return foo;\n}"],
        'noformat': ["\n{noformat}\n", "\n{noformat}\n", "*no* further _formatting_ is done here"],
        'panel': ["\n{panel:title="+"My title"+"}\n", "\n{panel}\n", "Some text with a title"],
        'table': ["\n||"+"Heading"+" 1||"+"Heading"+" 2||\n|", "|"+"Col"+" A2|\n", "Col"+" A1"]
    };

    for(var key in wrapperMarkup) {
        WikiEnabledTextarea.prototype[key] = (function(args, operationKey) {
            var paramsNumber = 0;
            if (args.length > 3) {
                paramsNumber = args.length - 3;
            }
            return function() {

                var prefix = args[0];
                var suffix = args[1];
                var placeholder = args[2];

                var i;
                for (i = 1; i <= paramsNumber; i++) {
                    prefix = prefix.replace("$"+i, arguments[i-1] || args[2 + i]);
                    suffix = suffix.replace("$"+i, arguments[i-1] || args[2 + i]);
                }

                var value = this.el.value;
                var selection = this.manipulationEngine.getSelection();

                this.undoRedoEl.recordHistoryItem();

                // unwrap selection if needed
                if (value.substring(selection.start - prefix.length, selection.start) === prefix &&
                    value.substring(selection.end, selection.end + suffix.length) === suffix) {

                    this.el.value = value.substring(0,selection.start - prefix.length) +
                    value.substring(selection.start, selection.end) +
                    value.substring(selection.end + suffix.length, value.length);

                    this.manipulationEngine.setSelection(selection.start - prefix.length, selection.end - prefix.length);

                    // wrap selection with markup
                } else {
                    this.manipulationEngine.wrapSelectionWith.call(this.manipulationEngine, prefix, suffix, placeholder);
                }
                this.undoRedoEl.recordHistoryItem();
                this.$el.trigger("input");
            };
        })(wrapperMarkup[key], key);
    }

    /**
     * Markup that is always a prefix for entire line, like h1. or bullet lists "* ".
     * Those prefixes are mutually exclusive, which means each line can be only prefixed with one of them
     * and applying one of them will remove any other.
     *
     * Each of this properties gets a function on the prototype with the same name
     * that changes value of textarea to apply the markup.
     */
    var excludingLinePrefixMarkup = {
        'paragraph': "",
        'bullet-list': "* ",
        'numbered-list': "# ",
        'h1': 'h1. ',
        'h2': 'h2. ',
        'h3': 'h3. ',
        'h4': 'h4. ',
        'h5': 'h5. ',
        'h6': 'h6. ',
        'paragraph-quote': 'bq. '
    };

    for(var key in excludingLinePrefixMarkup) {
        WikiEnabledTextarea.prototype[key] = (function(prefix) {
            return function() {
                this.undoRedoEl.recordHistoryItem();
                // check if line is already prefixed with one of the prefixes there
                for(var prefixToRemove in excludingLinePrefixMarkup) {
                    if (this.manipulationEngine.areSelectedLinesPrefixed(excludingLinePrefixMarkup[prefixToRemove])) {
                        this.manipulationEngine.unprefixSelectedLines(excludingLinePrefixMarkup[prefixToRemove]);
                    }
                }

                this.manipulationEngine.prefixSelectedLines.call(this.manipulationEngine, prefix);
                this.undoRedoEl.recordHistoryItem();
                this.$el.trigger("input");
            };
        })(excludingLinePrefixMarkup[key]);
    }

    /**
     * Markup that is just inserted in place of cursor or selection. The cursor is then placed at the end of inserted text.
     *
     * Each of this properties gets a function on the prototype with the same name
     * that changes value of textarea to apply the markup.
     */
    var insertMarkupWithoutSelecting = {
        'hr': "\n----\n",
        ':)': ':)',
        ':(': ':(',
        ':P': ':P',
        ':D': ':D',
        ';)': ';)',
        '(y)': '(y)',
        '(n)': '(n)',
        '(i)': '(i)',
        '(/)': '(/)',
        '(x)': '(x)',
        '(!)': '(!)',
        '(+)': '(+)',
        '(-)': '(-)',
        '(?)': '(?)',
        '(on)': '(on)',
        '(off)': '(off)',
        '(*)': '(*)',
        '(*r)': '(*r)',
        '(*g)': '(*g)',
        '(*b)': '(*b)',
        '(*y)': '(*y)',
        '(flag)': '(flag)',
        '(flagoff)': '(flagoff)',
        'image-attachment': [" !$1|thumbnail! ", "attachment-name.jpg"],
        'image-attachment-full': [" !$1! ", "attachment-name.gif"],
        'link-attachment': [" [^$1] ", "attachment-name.zip"]
    };

    for(var key in insertMarkupWithoutSelecting) {
        WikiEnabledTextarea.prototype[key] = (function(toInsert) {
            var paramsNumber = 0;
            var defaultValues;
            if (_.isArray(toInsert)) {
                paramsNumber = toInsert.length - 1;
                defaultValues = toInsert.slice(1);
                toInsert = toInsert[0];
            }
            return function() {
                var i;
                var result = toInsert;
                for (i = 1; i <= paramsNumber; i++) {
                    result = toInsert.replace("$"+i, arguments[i-1] || defaultValues[i-1]);
                }
                this.undoRedoEl.recordHistoryItem();
                this.manipulationEngine.replaceSelectionWith.call(this.manipulationEngine, result, false);
                this.undoRedoEl.recordHistoryItem();
                this.$el.trigger("input");
            };
        })(insertMarkupWithoutSelecting[key]);
    }

    WikiEnabledTextarea.prototype.speech = function()
    {
        speechRecognition.start(this);
    };

    return WikiEnabledTextarea;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/WikiEditor.js' */
define('wiki-edit/WikiEditor', [
    'wiki-edit/WikiEnabledTextarea',
    'jquery',
    'underscore',
    'wiki-edit/JIRA',
    'wiki-edit/keymaster',
    'wiki-edit/analytics',
    'wiki-edit/WikiEditorUtil',
    'jira/util/events',
    'featureflags/feature-manager'
], function (
    WikiEnabledTextarea,
    $,
    _,
    JIRA,
    key,
    analytics,
    WikiEditorUtil,
    JIRAEvents,
    FeatureManager
) {

    var controlKey = 'Ctrl';
    if (navigator.platform.indexOf('Mac') != -1) {
        controlKey = '⌘';
    }

    // Check jira.unified.attachments.m2 dark feature toggle
    var unifiedAttachmentsM2IsEnabled = function() {
        return FeatureManager.isFeatureEnabled("jira.unified.attachments.m2");
    };

    var determineFileType = function (fileName) {
        return fileName.match(/\.(bmp|gif|jpg|jpeg|png|tiff|webp)$/i) ? 'image' : 'file';
    };

    var insertMarkup = function (wikiEditor, fileName, fileType) {
        // Gif attachments are rendered without thumbnail (eg: !lolcat.gif!) so they can animate properly
        if (unifiedAttachmentsM2IsEnabled()) {
            if (fileType == "image") {
                if (fileName.match(/\.gif$/i)) {
                    wikiEditor["image-attachment-full"](fileName);
                } else {
                    wikiEditor["image-attachment"](fileName);
                }

                analytics.trigger("operation.attachment.image");
            } else {
                wikiEditor["link-attachment"](fileName);
                analytics.trigger("operation.attachment.link");
            }
        } else {
            wikiEditor["image-attachment"](fileName);
            analytics.trigger("operation.attachment.image");
        }
    };

    return {
        create: function (element) {
            // disable plugin in IE <=8
            if (typeof element.selectionStart == "undefined") {
                return;
            }

            var $editorElement = $(element);

            if ($editorElement.data("wikiEditor")) {
                return;
            }

            // todo editor should initialize all html and events by itself
            var wikiEditor = new WikiEnabledTextarea(element);
            this.wikiEditor = wikiEditor;

            var $editorHtml = $(JIRA.Templates.Plugins.WikiEditor.renderEditor({
                editorId: wikiEditor.id,
                controlKey: controlKey,
                attachmentM2FeatureFlag: unifiedAttachmentsM2IsEnabled()
            }));
            var $editorToolbar = $editorHtml.filter(".wiki-edit-toolbar");

            // speech-capable browser?
            if ("webkitSpeechRecognition" in window) {
                $editorHtml.find(".wiki-edit-speech-item").removeClass("hidden");
            }

            $editorElement.parent().before($editorHtml);

            // detect if we are dealing with dialog
            var isDialog = $editorElement.closest(".jira-dialog").length > 0 || $editorElement.closest("form#issue-create").length > 0;
            var isCreateDialog = $editorElement.closest("#create-issue-dialog").length > 0;
            // detect if we are on view issue page
            var isViewIssue = $("#issue-content").length > 0;
            var isComment = $editorElement.closest("#addcomment").length > 0;

            var elementsWithTooltips = $editorHtml.find(".wiki-edit-operation[title], .aui-dropdown2-trigger, .wiki-edit-tooltip");
            var onWikiEditorHideEventName;
            if (isDialog) {
                onWikiEditorHideEventName = 'Dialog.beforeHide';
            } else {
                onWikiEditorHideEventName = JIRA.Events.BEFORE_INLINE_EDIT_CANCEL;
            }
            elementsWithTooltips.each(function () {
                var $this = $(this);
                var config = {
                    aria: true,
                    hideOnClick: true,
                    hoverable: false
                };
                if ($this.parent().is('li')) {
                    config.gravity = 'w';
                }
                $this.tooltip(config);
            });
            var hideAllTooltips = function (){
                elementsWithTooltips.each(function(){
                    $(this).tooltip('hide');
                });
            };
            JIRA.bind(onWikiEditorHideEventName, hideAllTooltips);

            var isDropdownEnabled = false;
            var $wikiDropdown = $editorHtml.filter(".aui-dropdown2");
            $wikiDropdown.on({
                'aui-dropdown2-show': function () {
                    isDropdownEnabled = true;

                    // focus on editorElement when dropdown opens so
                    // it can handle keyboard event (especially in dialogs)
                    $editorElement.focus();
                },
                'aui-dropdown2-hide': function () {
                    isDropdownEnabled = false;

                    hideAllTooltips();
                }
            });
            $editorElement.on('keydown', function checkEscapePressWhenDropdownIsEnabled(e) {
                if (isDropdownEnabled && e.keyCode === AJS.keyCode.ESCAPE) {
                    if (isDialog) {
                        JIRA.one("Dialog.beforeHide", function (e) {
                            e.preventDefault();
                        });
                    } else if (isViewIssue && !isComment) {
                        JIRA.one(JIRA.Events.BEFORE_INLINE_EDIT_CANCEL, function preventInlineEditCloseIfAnyDropdownIsEnabled(e) {
                            e.preventDefault();
                        });
                    }
                }
            });


            var $attachmentDropdown = $editorHtml.filter(
                ".wiki-edit-dropdown-image, " +
                ".wiki-edit-dropdown-attachment"
            );

            var $attachmentListContainer = $attachmentDropdown.find(
                ".wiki-edit-insert-image, " +
                ".wiki-edit-insert-attachment"
            );

            var $attachmentList = $attachmentDropdown.find(
                ".wiki-edit-insert-image ul, " +
                ".wiki-edit-insert-attachment ul"
            );

            // Attachment dropdown link click handler
            $attachmentList.on("click", "a", function (e) {
                e.preventDefault();

                var fileType = $(this).attr("data-attachment-type");
                if (typeof fileType === "undefined") {
                    fileType = "file";
                }

                var fileName = $(this).find('.wiki-edit-attachment-name').text();

                insertMarkup(wikiEditor, fileName, fileType);
            });

            // Build attachment links when attachment button is pressed
            $attachmentDropdown.on("aui-dropdown2-show", function () {
                var genericAttachments = [];

                // Add temporary attachments (those added before dialog is saved such as in create/edit dialog)
                if (isDialog) {
                    $(".upload-progress-bar:not(.upload-progress-bar__upload-error) span.upload-progress-bar__file-name").each(function(i,v){
                        genericAttachments.push(v);
                    });
                }

                // Add permanent attachments
                if (!isCreateDialog && isViewIssue) {
                    $("#attachment_thumbnails li.attachment-content, " +
                      "#file_attachments li.attachment-content").each(function(i,v){
                        genericAttachments.push(v);
                    });
                }

                $attachmentList.empty();
                $attachmentListContainer.addClass("hidden");

                if ((isDialog || isViewIssue) && genericAttachments.length) {
                    $attachmentListContainer.removeClass("hidden");

                    /**
                     * Contents of $genericAttachments (ie: "this") could be:
                     * - A thumbnails (gallery) view item
                     * - A list view item
                     * - Create / edit dialog entry
                     */
                    $(genericAttachments).each(function () {
                        // Handle various form of DOM structure a file name can appear in (create issue dialog,
                        // edit issue - list view, edit issue - thumbnail view
                        var fileName = $(this).is('span.upload-progress-bar__file-name') ?
                            $(this).text() :
                            $(this).find('a.attachment-title, .attachment-title a').first().text();

                        // Determine file type by 'data-attachment-type' attribute, or fall back by checking
                        // popular image file extension
                        var fileType = $(this).attr('data-attachment-type');
                        if (fileType === undefined) {
                            fileType = determineFileType(fileName);
                        }

                        // Try to figure out the attachment type icon using mime type. On thumbnail / list view mime-type
                        // can be looked up using data-downloadurl attribute. If mime-type not available let's fall back
                        // using file extension. And if that still doesn't work use aui-iconfont-file-txt.
                        var typeIcon = WikiEditorUtil.defaultAttachmentTypeIcon;
                        var dataDownloadUrl = $(this).attr('data-downloadurl');
                        if (dataDownloadUrl === undefined) {
                            dataDownloadUrl = $(this).find('[data-downloadurl]').attr('data-downloadurl');
                        }
                        if (dataDownloadUrl !== undefined && typeof dataDownloadUrl === 'string') {
                            var attrs = dataDownloadUrl.split(':');
                            if (attrs.length > 0) {
                                var mimeType = attrs[0];
                                typeIcon = WikiEditorUtil.translateMimeTypeToAttachmentTypeIcon(mimeType);
                            }
                        } else if (fileName !== undefined && typeof fileName === 'string') {
                            var matches = fileName.match(/\.(\w{1,5})$/i); // regex match exts such as .gz,.jpg,.docx,.3gp and discard the dot prefix
                            if (matches && matches.length > 1) {
                                var fileExtension = matches[1];
                                typeIcon = WikiEditorUtil.translateFileExtensionToAttachmentTypeIcon(fileExtension);
                            }
                        }

                        // If feature is disabled do not list non-image attachments
                        if (!unifiedAttachmentsM2IsEnabled() && fileType !== "image") {
                            return;
                        }

                        $attachmentList.append(
                            $(JIRA.Templates.Plugins.WikiEditor.renderListItem({
                                text: fileName,
                                attachmentType: fileType,
                                attachmentTypeIcon: typeIcon,
                                attachmentM2FeatureFlagEnabled: unifiedAttachmentsM2IsEnabled()
                            }))
                        );
                    });
                }
            });

            // dropdown2 fix so when item is selected using keyboard the container div scrolls
            // properly. This bug was fixed on AUI 5.8+ so only do this for older AUI versions
            if (WikiEditorUtil.compareVersion(AJS.version, '5.8.0') < 0) {
                $attachmentDropdown.on('aui-dropdown2-item-selected', function scrollContainerDivIfActiveItemIsOutOfView() {
                    var $active = $(this).find('.aui-dropdown2-active');
                    if (typeof $active !== 'object') {
                        return;
                    }
                    var $container = $active.closest('div');
                    if (typeof $container !== 'object') {
                        return;
                    }

                    // top/bottom limits are extreme points above/below which element will not / only be partially visible
                    var containerTopLimit = $container.offset().top;
                    var containerBottomLimit = containerTopLimit + $container.height();

                    var elementTop = $active.offset().top;
                    var elementBottom = elementTop + $active.height();

                    // Active element is (partially) above the container viewport, scroll up
                    if (elementTop < containerTopLimit) {
                        $container.scrollTop($container.scrollTop() - (containerTopLimit - elementTop));
                    }

                    // Active element is (partially) below the container viewport, scroll down
                    if (elementBottom > containerBottomLimit) {
                        $container.scrollTop($container.scrollTop() + (elementBottom - containerBottomLimit));
                    }
                });
            }

            // SUCCESS-198: Prevent attachments from being listed on links drop down
            if (!unifiedAttachmentsM2IsEnabled()) {
                var $linkDropdown = $editorHtml.filter(".wiki-edit-dropdown-link");
                var $linksList = $linkDropdown.find(".wiki-edit-insert-link");
                var $linkLinkDefault = $linkDropdown.find(".wiki-edit-operation[data-operation=link-attachment]");
                var $linkLinks = $linkDropdown.find(".wiki-edit-insert-link ul");
                $linkLinks.on("click", "a", function (e) {
                    e.preventDefault();
                    wikiEditor["link-attachment"]($(this).text());
                    analytics.trigger("operation.attachment.link");
                });

                $linkDropdown.on("aui-dropdown2-show", function () {
                    var $linkAttachments = $();
                    if (!isCreateDialog && isViewIssue) {
                        $linkAttachments = $linkAttachments.add("#attachment_thumbnails .attachment-title, #file_attachments .attachment-title a");
                    }
                    if (isDialog) {
                        $linkAttachments = $linkAttachments.add(".upload-progress-bar:not(.upload-progress-bar__upload-error) .upload-progress-bar__thumbnail + .upload-progress-bar__file-name");
                    }

                    var attachments = _.uniq($linkAttachments, false, function getValue(item) {
                        return $(item).text().trim();
                    });

                    $linkLinks.empty();
                    $linksList.addClass("hidden");
                    $linkLinkDefault.removeClass("hidden");

                    if ((isDialog || isViewIssue) && attachments.length) {
                        $linksList.removeClass("hidden");
                        $linkLinkDefault.addClass("hidden");
                        attachments.forEach(function (element) {
                            $linkLinks.append(
                                $(JIRA.Templates.Plugins.WikiEditor.renderListItem({
                                    text: $(element).text().trim(),
                                    attachmentM2FeatureFlagEnabled: unifiedAttachmentsM2IsEnabled()
                                }))
                            );
                        });
                    }
                });
            }

            $editorHtml.filter(".wiki-edit-dropdown, .wiki-edit-picker").on("mousedown", function (e) {
                e.preventDefault(); // prevent blurring textarea, needed for inline mode
            });

            // attach keyboard shortcuts
            $editorHtml.find(".wiki-edit-operation:not(.wiki-edit-operation-color)").each(function () {
                var $this = $(this);
                var handler = function (e) {
                    if (!e) {
                        return;
                    }
                    e.preventDefault && e.preventDefault();
                    $editorElement.focus();
                    wikiEditor[$this.data("operation")]();
                    analytics.trigger("operation", {
                        name: $this.data("operation"),
                        nameHash: analytics.hashCode($this.data("operation")),
                        trigger: e.type
                    });
                    analytics.trigger("operation." + $this.data("operation"), {trigger: e.type});
                };

                // todo event delegation, fool!
                $this.click(handler);
                if ($this.data("shortcut")) {
                    // todo shortcuts should be binded once, globally
                    key($this.data("shortcut"), wikiEditor.id, handler);
                }
            });

            // text color
            $editorHtml.find(".wiki-edit-operation-color").each(function () {
                var $this = $(this);
                var handler = function (e) {
                    if (!e) {
                        return;
                    }
                    e.preventDefault && e.preventDefault();
                    $editorElement.focus();
                    wikiEditor[$this.data("operation")]($this.data("color"));
                    analytics.trigger("operation", {
                        name: $this.data("operation"),
                        nameHash: analytics.hashCode($this.data("operation")),
                        trigger: e.type
                    });
                    analytics.trigger("operation." + $this.data("operation"), {trigger: e.type});
                };

                // todo event delegation, fool!
                $this.click(handler);
                if ($this.data("shortcut")) {
                    // todo shortcuts should be binded once, globally
                    key($this.data("shortcut"), wikiEditor.id, handler);
                }

            });

            var defaultColor = (window.localStorage.getItem("jira.wikieditor.last.color")) ? window.localStorage.getItem("jira.wikieditor.last.color") : "red";
            var $colorOperation = $editorHtml.find(".wiki-edit-operation-color");
            $colorOperation.data("color", defaultColor);
            var $colorIndicator = $editorToolbar.find(".wiki-edit-color-indicator");
            $colorIndicator.css("background-color", defaultColor);

            $editorHtml.filter(".wiki-edit-color-picker").on("click", "a", function (e) {
                e.preventDefault();
                $editorElement.focus();
                var color = $(this).data("color");
                wikiEditor.color(color);
                analytics.trigger("operation", {name: "color"});
                analytics.trigger("operation.color.picked", {color: color});
                $colorOperation.data("color", color);
                $colorIndicator.css("background-color", color);
                window.localStorage.setItem("jira.wikieditor.last.color", color);
            });

            var $visibilityToggle = $editorHtml.find('.wiki-edit-visible-toggle');
            var hideToolbar = (localStorage.getItem("jira.wikieditor.visibility" + element.name + '.' + element.id) === "true") ? true : false;
            if (hideToolbar) {
                $visibilityToggle.addClass("active");
                $editorToolbar.addClass("wiki-edit-toolbar-compact");
            }

            function toggleEditor(e) {
                e.preventDefault();
                e.stopPropagation();
                hideToolbar = !hideToolbar;
                $visibilityToggle.toggleClass("active", hideToolbar);
                $editorToolbar.toggleClass("wiki-edit-toolbar-compact", hideToolbar);
                localStorage.setItem("jira.wikieditor.visibility" + element.name + '.' + element.id, (hideToolbar) ? "true" : "false");
                analytics.trigger((hideToolbar) ? "hide" : "show")
            }

            $visibilityToggle.on("click", toggleEditor);
            $editorToolbar.parent().on("click", ".wiki-edit-toolbar-compact", toggleEditor);

            $(document).on("showWikiPreview", function (e, el) {
                if ($(el).find(element).length) {
                    $editorToolbar.addClass("hidden");
                }
            });
            $(document).on("showWikiInput", function (e, el) {
                if ($(el).find(element).length) {
                    $editorToolbar.removeClass("hidden");
                }
            });
        },

        initBrowseLink: function (element) {
            var wikiEditor = this.wikiEditor;

            if (unifiedAttachmentsM2IsEnabled()) {
                var $editorElement = $(element);

                var $browseButton = $editorElement.parent().siblings().find(".wiki-attachment-browse");
                var canAttach = $("#dnd-metadata-webpanel").data("can-attach");

                var isDialog = $editorElement.closest(".jira-dialog").length > 0 || $editorElement.closest("form#issue-create").length > 0;

                if (isDialog) {
                    // These are the dialogs we want to show the browse link in.
                    // The dialogs have an attachment dropzone that we can use to simulate a drop.
                    var supportedDialogSelectors = ['#create-issue-dialog:visible', '#create-subtask-dialog:visible', '#edit-issue-dialog:visible', '#create-linked-issue-dialog:visible'];
                    var supportedDialog = $(supportedDialogSelectors.join(","));
                    var isSupportedDialog = supportedDialog.length > 0;
                    canAttach = $(".jira-dialog fieldset span:contains('Attachment')").length > 0;

                    // If we did not find a dialog that we know can receive files, we search
                    // for other dialogs that explicitly state that they can receive files.
                    if (!isSupportedDialog) {
                        supportedDialog = $editorElement.closest(".dialog-can-receive-files:visible");
                        isSupportedDialog = supportedDialog.length > 0;
                        // If we do find such a dialog, we consume its can-attach (boolean) data attribute.
                        // If the dialog does not have that attribute, canAttach will be undefined and the
                        // browse link will not be shown.
                        canAttach = supportedDialog.data("can-attach");
                    }
                    var insertMarkupInDialog = supportedDialog.data("insert-markup-on-browse");
                }

                var $attachmentsDropdown = $editorElement.parent().siblings().find(".wiki-edit-attachment-picker-trigger");

                if (canAttach && (isDialog ? isSupportedDialog : true)) {
                    $browseButton.closest("div").removeClass("hidden");
                    $attachmentsDropdown.removeClass("hidden");
                    if (!$browseButton.data("initialised")) {
                        $browseButton.on('click', function (e) {
                            e.preventDefault();

                            var $tempFileInput = $("<input type=\"file\" multiple />");
                            $tempFileInput.change(function (event) {
                                var files = $tempFileInput[0].files;
                                if (isDialog) {
                                    var dropEvent = $.Event("drop");
                                    dropEvent.dataTransfer = {files: files};
                                    supportedDialog.find('.issue-drop-zone__target').trigger(dropEvent);
                                }
                                else {
                                    // This event comes from the JIRA Drag and Drop Plugin.
                                    JIRAEvents.trigger("attachmentForPageReceived", {
                                        files: files,
                                        isWikiTextfieldFocused: true
                                    });
                                }
                                if (isDialog ? insertMarkupInDialog : true) {
                                    for (var i = 0; i < files.length; i++) {
                                        var fileName = files[i].name;
                                        insertMarkup(wikiEditor, fileName, determineFileType(fileName));
                                    }
                                }
                            });
                            $tempFileInput.click();

                            analytics.trigger("attachment.dropdown.button.clicked.browse");
                        });
                        $browseButton.data("initialised", true);
                    }
                }
                else {
                    $browseButton.closest("div").addClass("hidden");

                    // Here we know the browse button will be hidden. If we will
                    // not show an attachments list, the attachment dropdown will be empty
                    // so we want to hide the attachment dropdown altogether.
                    var $genericAttachments = $("#attachment_thumbnails li.attachment-content, #file_attachments li.attachment-content");
                    var currentIssueHasAttachments = $genericAttachments.length > 0;

                    // Create issue/Create subtask dialogs are special because even if the current issue has attachments,
                    // we are not supposed to show these attachments in those two dialogs (because attachments are per issue).
                    var isCreateIssueOrSubtaskDialog = isDialog && isSupportedDialog &&
                        (supportedDialog.attr("id") === "create-issue-dialog" || supportedDialog.attr("id") === "create-subtask-dialog");

                    var willShowAttachmentsList = currentIssueHasAttachments &&  !isCreateIssueOrSubtaskDialog;

                    if (!willShowAttachmentsList) {
                        $attachmentsDropdown.addClass("hidden");
                    }
                }
            }
        }
    }
});

;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/WikiEditorUtil.js' */
define('wiki-edit/WikiEditorUtil', [
    'jquery',
    'underscore'
], function (
    $,
    _
) {

    var _defaultAttachmentTypeIcon = {
        cssClass : 'aui-iconfont-devtools-file',
        title : ''
    };

    var _fileExtToAttachmentTypeIconCssClass = {
        'pdf'   : 'aui-iconfont-file-pdf',

        'gif'   : 'aui-iconfont-image',
        'png'   : 'aui-iconfont-image',
        'jpeg'  : 'aui-iconfont-image',
        'jpg'   : 'aui-iconfont-image',

        'xml'   : 'aui-iconfont-file-code',
        'html'  : 'aui-iconfont-file-code',
        'htm'   : 'aui-iconfont-file-code',
        'txt'   : 'aui-iconfont-file-txt',

        'zip'   : 'aui-iconfont-file-zip',
        'gz'    : 'aui-iconfont-file-zip',
        'tar'   : 'aui-iconfont-file-zip',
        'rar'   : 'aui-iconfont-file-zip',
        '7z'    : 'aui-iconfont-file-zip',

        'doc'   : 'aui-iconfont-file-doc',
        'docx'  : 'aui-iconfont-file-doc',
        'xls'   : 'aui-iconfont-file-xls',
        'xlsx'  : 'aui-iconfont-file-xls',
        'xlsm'  : 'aui-iconfont-file-xls',
        'ppt'   : 'aui-iconfont-file-ppt',
        'pptx'  : 'aui-iconfont-file-ppt',

        'java'  : 'aui-iconfont-file-code',
        'c'     : 'aui-iconfont-file-code',
        'h'     : 'aui-iconfont-file-code',
        'cpp'   : 'aui-iconfont-file-code',
        'hpp'   : 'aui-iconfont-file-code',
        'scala' : 'aui-iconfont-file-code',
        'php'   : 'aui-iconfont-file-code',
        'css'   : 'aui-iconfont-file-code',
        'less'  : 'aui-iconfont-file-code',
        'soy'   : 'aui-iconfont-file-code',
        'js'    : 'aui-iconfont-file-code',
        'jar'   : 'aui-iconfont-file-zip',
        'war'   : 'aui-iconfont-file-zip',
        'obr'   : 'aui-iconfont-file-zip'
    };

    var _fileExtToAttachmentTypeIconTitle = {
        'pdf'   : "PDF File",

        'gif'   : "GIF File",
        'png'   : "PNG File",
        'jpeg'  : "JPEG File",
        'jpg'   : "JPEG File",

        'xml'   : "XML File",
        'html'  : "HTML File",
        'htm'   : "HTML File",
        'txt'   : "Text File",

        'zip'   : "Zip Archive",
        'gz'    : "GZip Archive",

        'doc'   : "Microsoft Word",
        'docx'  : "Microsoft Word",
        'xls'   : "Microsoft Excel",
        'xlsx'  : "Microsoft Excel",
        'xlsm'  : "Microsoft Excel",
        'ppt'   : "Microsoft PowerPoint",
        'pptx'  : "Microsoft PowerPoint",

        'java'  : "Java Source File",
        'jar'   : "Java Archive File",
        'war'   : "Java Archive File"
    };

    return {

        /**
         * Default attachment type icon, used as a fallback if type couldn't be determined
         */
        defaultAttachmentTypeIcon : _defaultAttachmentTypeIcon,

        /**
         * Used by attachments dropdown to determine what icon to put to the left of attachment name
         * Icon is decided by attachment mime type
         *
         * @param {string} mimeType attachment mime type (eg: image/jpg)
         *
         * @returns Object with cssClass and title attributes.
         *  If translation fails cssClass is aui-iconfont-devtools-file and title is empty string.
         */
        translateMimeTypeToAttachmentTypeIcon : function (mimeType) {
            return {
              cssClass : JIRA.Templates.ViewIssue.matchFileClass( { mimetype : mimeType } ),
              title : JIRA.Templates.ViewIssue.matchFileIconAlt( { mimetype : mimeType } )
            };
        },

        /**
         * Used by attachments dropdown to determine what icon to put to the left of attachment name
         * Icon is decided by file extension
         *
         * @param extension extension name, with or without dot prefix (eg: .pdf, doc)
         *
         * @returns Object with cssClass and title attributes.
         *  If translation fails cssClass is aui-iconfont-devtools-file and title is empty string.
         */
        translateFileExtensionToAttachmentTypeIcon : function (extension) {
            var result = _.clone(_defaultAttachmentTypeIcon);

            if (typeof extension !== 'string') {
                return result;
            }

            extension = extension.toLowerCase();
            extension = extension.replace(/^\.+/, '');

            var cssClass = _fileExtToAttachmentTypeIconCssClass[extension];
            if (typeof cssClass === 'string') {
                result.cssClass = cssClass;
            }

            var title = _fileExtToAttachmentTypeIconTitle[extension];
            if (typeof title === 'string') {
                result.title = title;
            }

            return result;
        },

        /**
         * Perform version number comparison. Returns a number less than 0 if version A is lower than B, greater than 0
         * if A is higher than B, 0 if both equals.
         *
         * Example:
         * - compareVersion('5.7.10', '5.8.0') // returns -1
         * - compareVersion('5.8.0', '5.8.0') // returns 0
         * - compareVersion('5.8.1', '5.8.0') // returns 1
         * - compareVersion('5.10.0', '5.8.0') // returns 1
         * - compareVersion('5.8', '5.8.0') // returns -1
         * - compareVersion('5.8', '5.8.0') // returns -1
         * - compareVersion('5.0a', '5.0') // returns NaN
         *
         * @param verA (string) version number (eg: 5.7.10)
         * @param verB (string) version number (eg: 5.7.10)
         *
         * @return (number) A number less than 0 if version A is lower than B, greater than 0 if A is higher than B,
         * 0 if both equals, NaN if version comparison can't be performed
         */
        compareVersion : function (verA, verB) {
            var partsA = verA.split('.');
            var partsB = verB.split('.');
            var result = NaN;

            $(partsA).each(function (i, e) {
                if (i >= partsB.length) {
                    return false;
                }
                var partA = Number(e);
                var partB = Number(partsB[i]);
                if (isNaN(partA) || isNaN(partB)) {
                    //noinspection JSUnusedAssignment
                    result = NaN;
                    return false;
                }
                if (partA < partB) {
                    //noinspection JSUnusedAssignment
                    result = -1;
                    return false;
                } else if (partA > partB) {
                    //noinspection JSUnusedAssignment
                    result = 1;
                    return false;
                }
                result = 0;
            });

            if (result == 0 && partsA.length != partsB.length) {
                return (partsA.length > partsB.length) ? 1 : -1;
            }

            return result;
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/SpeechRecognition.js' */
define('wiki-edit/SpeechRecognition', [
    'jquery',
    'aui/flag'
], function ($, auiFlag)
{
    function getIsFinal(results)
    {
        return results && results[0] && results[0].isFinal;
    }
    function getTranscript(results)
    {
        return results && results[0] && results[0][0] && results[0][0].transcript || '';
    }

    return {
        start: function (textareaInstance)
        {
            var self = this;
            var recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = true;
            // if lang is converted into something that Chrome does not understand, it defaults to the system language
            recognition.lang = AJS.Meta.get("user-locale").replace("_", "-");
            // stops any recognition in progress to start a new session
            recognition.stop();
            recognition.start();

            recognition.onstart = function()
            {
                self.showTimedMessage({title: "You can start speaking now :)"}, "info", 10);
                self.selectionStart = textareaInstance.manipulationEngine.getSelection().start;
            }
            recognition.onresult = function(event)
            {
                self.dismissCurrentMessage();
                var isFinal = getIsFinal(event.results);
                var speechResult = getTranscript(event.results);
                // capitalise first letter
                speechResult = speechResult.charAt(0).toUpperCase() + speechResult.slice(1);

                if (isFinal)
                {
                    textareaInstance.undoRedoEl.recordHistoryItem();
                }
                textareaInstance.manipulationEngine.replaceSelectionWith.call(textareaInstance.manipulationEngine, speechResult, false);
                var selectionEnd = self.selectionStart + speechResult.length;
                if (isFinal)
                {
                    // clears the selection
                    textareaInstance.manipulationEngine.setSelection(selectionEnd);
                    textareaInstance.undoRedoEl.recordHistoryItem();
                    textareaInstance.$el.trigger("input");
                    recognition.stop();
                }
                else
                {
                    textareaInstance.manipulationEngine.setSelection(self.selectionStart, selectionEnd);
                }
            }
            recognition.onerror = function(event)
            {
                recognition.stop();

                // this is a generic error message in case no specific error is raised
                var message = {
                    title: "Sorry, I can\'t hear you :(",
                    body: ''
                }
                switch (event.error)
                {
                    case "not-allowed":
                        message.title = "Speech recognition is currently disabled";
                        message.body = "Click the camera icon in the browser\'s address bar to enable it.";
                        break;
                    case "network":
                        message.title = "No internet connection";
                        message.body = "You need a working internet connection to use speech recognition.";
                        break;
                    case "no-speech":
                        message.title = "Sorry, I couldn\'t hear anything :(";
                        message.body = "Is your microphone working and unmuted?";
                        break;
                    // this only happens by user interaction, so there is no need to display a message
                    case "aborted":
                        return;
                }
                self.showTimedMessage(message, "warning", 5);
            }
            recognition.onend = function()
            {
                recognition.stop();
            }
        },

        /**
         * Shows a specific auiFlag and automatically hides it after the specified timeout
         *
         * @param message
         * @param flagType
         * @param duration in seconds
         */
        showTimedMessage: function(message, flagType, duration)
        {
            this.dismissCurrentMessage();
            this.speakFlag = auiFlag({
                type: flagType,
                title: message.title,
                body: message.body,
                persistent: true
            });

            clearTimeout(this.flagTimer);
            this.flagTimer = setTimeout(this.dismissCurrentMessage.bind(this), duration * 1000);
        },
        dismissCurrentMessage: function()
        {
            if (this.speakFlag && this.speakFlag.close)
            {
                this.speakFlag.close();
                this.speakFlag = null;
            }
        }
    }
})
;;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:skate', location = '/js/lib/skate.js' */
define('wiki-edit/skate', ['jira/skate'], function(skate) {
    return skate;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources-init', location = '/js/wiki-editor-init.js' */
require([
    'wiki-edit/WikiEditor',
    'wiki-edit/JIRA',
    'wiki-edit/skate',
    'jquery',
    'underscore'
], function(WikiEditor, JIRA, skate, $, _) {

    function createWikiTextfield(element) {
        var el = (this instanceof Element) ? this : element;
        var create = function(elem) {
            WikiEditor.create(elem);
            WikiEditor.initBrowseLink(elem);
            elem.wikiEnabled = true;
        };

        if (el.wikiEnabled === false) {
            if ($(el).is(':hidden')) {
                _.defer(create, el);
            } else {
                create(el);
            }
        }
    }

    function wikiEditorDefinition() {
        return {
            type: skate.type.CLASSNAME,
            attached: createWikiTextfield,
            prototype: {
                wikiEnabled: false
            }
        };
    }

    skate('wiki-textfield', wikiEditorDefinition());

    skate('wiki-enabled-textfield', wikiEditorDefinition());

    $(function() {
        if ($("#gh").length > 0) {
            JIRA.Dialogs.comment.options.width = 810;
            JIRA.Dialogs.assignIssue.options.width = 810;
            JIRA.Dialogs.attachFile.options.width = 810;
            JIRA.Dialogs.logWork.options.width = 810;
            JIRA.Dialogs.logWork.options.width = 810;
        }
    });

});
;
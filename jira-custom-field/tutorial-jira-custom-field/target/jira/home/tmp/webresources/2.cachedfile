;
/* module-key = 'jira.webresources:initMainDashboard', location = '/includes/jira/dashboard/initMainDashboard.js' */
AJS.$(function() {
    var infoMessage = WRM.data.claim("dashboardInfoMessage");
    var installMessage = WRM.data.claim("dashboardInstallMessage");
    if(infoMessage || installMessage) {
        var flag = require("jira/flag");
        if(infoMessage) {
            flag.showInfoMsg('', infoMessage);
        }
        if (installMessage) {
            flag.showSuccessMsg('', installMessage);
        }
    }
});;
;
/* module-key = 'com.atlassian.plugins.browser.metrics.browser-metrics-plugin:api', location = 'probe.js' */
;(function() {
var util_window, is_supported, event_stream, api_addReporter, api_delegateTo, api_end, util_table, util_document, util_element_hound, util_element_wolf, api_start_is_ready_supported, util_is_dom_content_loaded_done, api_start, api_subscribe, index;
util_window = function () {
  return window;
}();
is_supported = function (window) {
  /**
   * Feature detection for whether mandatory browser features are supported.
   */
  // required for .start() and .end() timing
  // http://caniuse.com/#search=performance.now
  return !!(window.performance && window.performance.now);
}(util_window);
event_stream = [];
api_addReporter = function (eventStream) {
  /**
   * Add a custom reporter to contribute to transition reports.
   *
   * @param {Reporter} reporter
   * @example
   *     api.addReporter(function dateReporter(transition) {
   *         return {
   *             date: Date.now()
   *         };
   *     });
   */
  return function addReporter(reporter) {
    // "addReporter" API has highest priority, so we use .unshift() rather than .push()
    eventStream.unshift({ addReporter: reporter });
  };
}(event_stream);
api_delegateTo = function (eventStream) {
  /**
   * Yield control to another object, giving it all events captured thus far, and all events in the future.
   * @param {function} subscriber
   */
  return function delegateTo(subscriber) {
    while (eventStream.length) {
      subscriber(eventStream.splice(0, 1)[0]);
    }
    eventStream.unshift = subscriber;
    eventStream.push = subscriber;
  };
}(event_stream);
api_end = function (eventStream, window) {
  /**
   * Finish timing and report the results.
   *
   * @param {String} options.key A key that identifies the page that has now finished loading. It must match the
   *     key provided to `start`.
   * @returns {undefined}
   * @example
   *     api.end({key: "jira.issue.view"});
   */
  return function end(options) {
    eventStream.push({
      end: {
        key: options.key,
        timestamp: window.performance.now()
      }
    });
  };
}(event_stream, util_window);
util_table = function () {
  /**
   * A multi-dimensional map that supports multiple values per key.
   * @constructor
   */
  function Table() {
    this._ = {};
  }
  /**
   * Recursive iteration over all keys and values. Function argument explanation:
   * {function} args[0] callback Called with arguments: values, key, higherKey, moreHigherKey,...
   * {Object} args[1] items to iterate
   * {string} args[2..n] keys from bottom to top
   *
   * @param {Array} args
   * @returns {undefined}
   */
  var _forEachRecursive = function (args) {
    var callback = args[0];
    var items = args[1];
    // at 1st level it's -> this;
    if (items instanceof Table) {
      if (args.length >= 3) {
        Object.keys(items._).forEach(function (key) {
          _forEachRecursive([
            callback,
            items._[key],
            key
          ].concat(args.slice(2)));
        });
      } else {
        Object.keys(items._).forEach(function (key) {
          _forEachRecursive([
            callback,
            items._[key],
            key
          ]);
        });
      }
    } else if (Array.isArray(items)) {
      callback.apply(null, [items].concat(args.slice(2)));
    }
  };
  /**
   * Iterate over all keys and values.
   * @param {function} callback Called with two arguments: values, key
   * @returns {undefined}
   */
  Table.prototype.forEach = function (callback) {
    _forEachRecursive([
      callback,
      this
    ]);
  };
  /**
   * Adds an object to a multi-dimension table. Head arguments are keys in order of deepness,
   * 1st goes highest key (e.g.: row key) and the one before last is the deepest level key (e.g.: column key).
   * Last argument considered as a value.
   *
   * @param arguments array of keys from top to bottom, ending with value (e.g.: [0] > rowKey, [1] > columnKey, [2] > value)
   */
  Table.prototype.add = function () {
    // selector, hasNone, callback
    var obj = this;
    // current level row
    var prev = null;
    // previous argument/key
    var cur = null;
    // current func argument/key/value
    for (var i = 0; i < arguments.length; i++) {
      cur = arguments[i];
      // then "obj" is an Array and "cur" is a value
      if (i === arguments.length - 1 && Array.isArray(obj)) {
        obj.push(cur);
        break;  // creating new level of table
      } else if (i < arguments.length - 2 && !obj._.hasOwnProperty(cur)) {
        obj._[cur] = new Table();  // {_: {}, length: 0}
                                   // considered as last level, we need to create an Array for values if not exists
      } else if (i === arguments.length - 2 && !obj._.hasOwnProperty(cur)) {
        obj._[cur] = [];
      }
      obj = obj._[cur];
      // this is an Array if i === arguments.length - 2
      prev = cur;
    }
  };
  /**
   *
   * @param visited an Array of tupples of "table key" > "object under that key" (root key is always null)
   * @param keyToRemove a key on the table structure which needs to be removed
   */
  var _cleanUpRecursive = function (visited, keyToRemove) {
    if (visited.length === 0) {
      return;
    }
    var tuple = visited.pop();
    var key = tuple[0];
    var obj = tuple[1];
    if (key === keyToRemove) {
      _cleanUpRecursive(visited, key);
    } else if (obj._.hasOwnProperty(keyToRemove)) {
      delete obj._[keyToRemove];
    }
    if (Object.keys(obj).length === 0) {
      _cleanUpRecursive(visited, key);
    }
  };
  /**
   * Remove an object under a key.
   * @param arguments array of keys from top to bottom, ending with value (e.g.: [0] > rowKey, [1] > columnKey, [2] > value)
   * @returns {boolean} true if an item was removed
   */
  Table.prototype.remove = function () {
    // e.g.: rowKey, columnKey, value
    var index;
    // index of the Array element that is about to be removed
    var mutated = false;
    // true if Table was changed, i.e. element was removed
    var key = null;
    // current level key
    var obj = this;
    // current level row
    // Visited elements - Array of tuples, root key is always null (e.g.: [aKey1, {_: { aKey2 : Table/Array }, length: 1}]
    var visited = [[
        key,
        obj
      ]];
    var cur = null;
    // current func argument
    for (var i = 0; i < arguments.length; i++) {
      cur = arguments[i];
      // then "obj" is Array and "cur" is an entry in this Array.
      if (Array.isArray(obj)) {
        index = obj.indexOf(cur);
        if (index > -1) {
          obj.splice(index, 1);
          if (obj.length === 0 && visited.length > 1) {
            _cleanUpRecursive(visited, key);  // cleaning all upper levels if they are empty as well
          }
          mutated = true;
        }
      } else if (obj._.hasOwnProperty(cur)) {
        // When only some key is specified, _all_ values under that key are removed.
        if (i === arguments.length - 1) {
          delete obj._[cur];
          // if we want correct reduce, we need to count all inner keys being removed
          if (Object.keys(obj).length === 0 && visited.length > 1) {
            _cleanUpRecursive(visited, key);  // cleaning all upper levels if they are empty either
          }
          mutated = true;
        }
        key = cur;
        obj = obj._[cur];
        visited.push([
          key,
          obj
        ]);  // at the previous to last index step obj is an Array
      } else {
        break;
      }
    }
    return mutated;
  };
  /**
   * Get objects under a key.
   * @returns {Array}
   * @param key under which sought-for element stored
   */
  Table.prototype.get = function (key) {
    if (this._.hasOwnProperty(key)) {
      return this._[key];
    }
    return [];
  };
  return Table;
}();
util_document = function (window) {
  return window.document;
}(util_window);
util_element_hound = function (Table, window, document) {
  var MutationObserver = window.MutationObserver;
  var observer;
  var observing = false;
  var Promise = window.Promise;
  var targets;
  // MutationObserver -- Required for determining whether selectors are satisfied in the DOM;
  // Promise -- Required for combining multiple conditions together.
  if (!(MutationObserver && Promise)) {
    return;
  }
  // A table of selector -> [hasNone -> [callbacks, ...], ... ] of things to find.
  targets = new Table();
  function isNothing(obj) {
    return !obj || obj == null || obj === 'null' || obj === 'undefined';
  }
  /**
   * Add a target to watch for, ensuring the MutationObserver is enabled.
   * @param {string} selector
   * @param {string} hasNone
   * @param {function} callback
   */
  function addTarget(selector, hasNone, callback) {
    if (!observing) {
      observer.observe(document, {
        attributes: true,
        childList: true,
        subtree: true
      });
      observing = true;
    }
    targets.add(selector, hasNone, callback);
  }
  /**
   * Find candidate elements that satisfy the "selector predicate".
   * @param selector
   * @param hasNone
   * @returns {boolean}
   */
  function satisfies(selector, hasNone) {
    var candidates = document.querySelectorAll(selector);
    return candidates.length && (isNothing(hasNone) || Array.prototype.every.call(candidates, function (element) {
      return !element.querySelector(hasNone);
    }));
  }
  // A MutationObserver so we know when the DOM changes.
  observer = new MutationObserver(function (mutations) {
    // 1. Gather list of elements that satisfy the "selector" predicate
    // 2. For each of those "candidate" elements, check if it satisfies the "hasNone" predicate.
    targets.forEach(function (callbacks, hasNone, selector) {
      if (satisfies(selector, hasNone)) {
        callbacks.forEach(function (callback) {
          callback();
        });
        targets.remove(selector, hasNone);
      }
    });
  });
  /**
   * @typedef {Promise} ElementHound
   * @property {function} dismiss When called, dismissed the hound.
   */
  /**
   * Find some elements!
   *
   * @param {string|string[]} selectors One ore more CSS selectors that must all match elements of interest.
   * @param {string|string[]} hasNones If not null, selectors only match elements that do not have descendants matching
   *     this selector.
   * @returns {ElementHound}
   * @constructor
   */
  function ElementHound(selectors, hasNones) {
    var dismiss;
    // Normalise selectors to an array.
    if (!selectors.forEach) {
      selectors = [selectors];
    }
    // Join all "hasNones" into one big comma separated selector
    if (!isNothing(hasNones) && Array.isArray(hasNones)) {
      hasNones = hasNones.join(',');
    }
    /**
     * @type {ElementHound}
     */
    var result = new Promise(function (resolve, reject) {
      var requirementPromises = [];
      var requirementCleanups = [];
      selectors.forEach(function (selector) {
        var promise;
        var cleanup;
        if (!satisfies(selector, hasNones)) {
          promise = new Promise(function (resolve) {
            addTarget(selector, hasNones, resolve);
            cleanup = function () {
              targets.remove(selector, hasNones, resolve);
            };
            requirementCleanups.push(cleanup);
          });
          requirementPromises.push(promise);
        }
      });
      // Clean-up after ourselves, to reduce the work done by the mutation observer.
      function cleanup() {
        requirementCleanups.forEach(function (requirementCleanup) {
          requirementCleanup();
        });
      }
      Promise.all(requirementPromises).then(cleanup).then(resolve, reject);
      dismiss = function () {
        cleanup();
        reject();
      };
    });
    // Allow the caller to explicitly dismiss the hound. This allows the caller to say
    // they don't care about the result any more, and allows us to stop looking for it.
    result.dismiss = dismiss;
    return result;
  }
  return ElementHound;
}(util_table, util_window, util_document);
util_element_wolf = function (Table, window, document) {
  var MutationObserver = window.MutationObserver;
  var observer;
  var observing = false;
  var Promise = window.Promise;
  var targets;
  // MutationObserver -- Required for determining whether selectors are satisfied in the DOM;
  // Promise -- Required for combining multiple conditions together.
  if (!(MutationObserver && Promise)) {
    return;
  }
  // A map of selector->[callback] of things to find.
  targets = new Table();
  /**
   * Add a target to watch for, ensuring the MutationObserver is enabled.
   * @param {string} selector
   * @param {function} callback
   */
  function addTarget(selector, callback) {
    if (!observing) {
      observer.observe(document, {
        attributes: true,
        childList: true,
        subtree: true
      });
      observing = true;
    }
    targets.add(selector, callback);
  }
  // A MutationObserver so we know when the DOM changes.
  observer = new MutationObserver(function (mutations) {
    targets.forEach(function (callbacks, selector) {
      if (!document.querySelector(selector)) {
        callbacks.forEach(function (callback) {
          callback();
        });
        targets.remove(selector);
      }
    });
  });
  /**
   * @typedef {Promise} ElementWolf
   * @property {function} dismiss When called, dismisses the wolf.
   */
  /**
   * Find some elements!
   *
   * @param {string|string[]} selectors One ore more CSS selectors that must all match elements of interest.
   * @returns {ElementWolf}
   * @constructor
   */
  function ElementWolf(selectors) {
    var dismiss;
    // Normalise selectors to an array.
    if (!selectors.forEach) {
      selectors = [selectors];
    }
    /**
     * @type {ElementWolf}
     */
    var result = new Promise(function (resolve, reject) {
      var requirementPromises = [];
      var requirementCleanups = [];
      selectors.forEach(function (selector) {
        var promise;
        var cleanup;
        if (document.querySelector(selector)) {
          promise = new Promise(function (resolve) {
            addTarget(selector, resolve);
            cleanup = function () {
              targets.remove(selector, resolve);
            };
          });
          requirementPromises.push(promise);
          requirementCleanups.push(cleanup);
        }
      });
      // Clean-up after ourselves, to reduce the work done by the mutation observer.
      function cleanup() {
        requirementCleanups.forEach(function (requirementCleanup) {
          requirementCleanup();
        });
      }
      Promise.all(requirementPromises).then(cleanup).then(resolve, reject);
      dismiss = function () {
        cleanup();
        reject();
      };
    });
    // Allow the caller to explicitly dismiss the hound. This allows the caller to say
    // they don't care about the result any more, and allows us to stop looking for it.
    result.dismiss = dismiss;
    return result;
  }
  return ElementWolf;
}(util_table, util_window, util_document);
api_start_is_ready_supported = function (ElementHound, ElementWolf) {
  /**
   * Feature detection for whether the .api({ready: …}) API option is supported.
   */
  return !!(ElementHound && ElementWolf);
}(util_element_hound, util_element_wolf);
util_is_dom_content_loaded_done = function (document, window) {
  var done = false;
  document.addEventListener('DOMContentLoaded', function () {
    // setTimeout matters here because the purpose of this module is to let know when all the DOMContentLoaded
    // event handlers have run. In order to know that, it would have to run after all the other handlers have run.
    // Hence we're using setTimeout to wait until the next tick. We know for certain that on the next tick all
    // the handlers have been executed due to JavaScript being single threaded.
    window.setTimeout(function () {
      done = true;
    });
  });
  /**
   * Return true if the DOMContentLoaded event handlers have been called.
   * @returns {boolean}
   */
  function isDOMContentLoadedDone() {
    return done;
  }
  return isDOMContentLoadedDone;
}(util_document, util_window);
api_start = function (end, isReadySupported, eventStream, ElementHound, ElementWolf, isDOMContentLoadedDone, window) {
  var Promise = window.Promise;
  var executeOnceOnStart = [];
  /**
   * In the .start() API, there are multiple short-hand versions of the 'ready' value that can be used. In the
   * interest of sanity, this function normalises them all to the most complex form.
   *
   * @param {string|string[]|{selector: string, requireUpdate: boolean, hasNone?: string|null}} conditions
   * @param {boolean} defaultRequireUpdate When a ready condition is a string (i.e. selector only), use this value for
   *     requireUpdate.
   * @returns {Array<{selector: string, requireUpdate: boolean, hasNone?: string|null}>}
   */
  function normalisedReady(conditions, defaultRequireUpdate) {
    if (!Array.isArray(conditions)) {
      conditions = [conditions];
    }
    return conditions.map(function (c) {
      return typeof c === 'string' ? {
        selector: c,
        requireUpdate: defaultRequireUpdate,
        hasNone: null
      } : c;
    });
  }
  /**
   * Combine all the ready conditions into a single promise.
   *
   * @param {{selector: string, requireUpdate: boolean, hasNone?: string|null}[]} conditions
   * @returns {Promise} a promise that is resolved when all conditions are satisfied
   */
  function combinedReady(conditions) {
    var combined;
    combined = conditions.map(function (condition) {
      var precondition;
      if (condition.requireUpdate) {
        precondition = new ElementWolf(condition.selector);
        // In case another transition happens _before_ we can finish.
        executeOnceOnStart.push(function () {
          precondition.dismiss();
        });
      } else {
        precondition = Promise.resolve();
      }
      return precondition.then(function () {
        var hound = new ElementHound(condition.selector, condition.hasNone);
        // In case another transition happens _before_ we can finish.
        executeOnceOnStart.push(function () {
          hound.dismiss();
        });
        return hound;
      });
    });
    return Promise.all(combined);
  }
  /**
   * Start measuring the duration of a transition.
   *
   * @param {String} options.key A key that identifies the page where the user is headed.
   * @param {boolean} [options.isInitial] If specified, indicates whether the transition should be treated as a
   *     "full page load" (initial). If not specified, this will be determined automatically based on whether or not
   *     DOMContentLoaded has fired.
   * @param {number} [options.threshold=1000] Declares the target (in milliseconds) duration for the navigation. The
   *     performance of the navigation is considered *good* if it completes within this threshold.
   * @param {String|String[]|{selector: string, requireUpdate: boolean}[]} [options.ready] A CSS selector that matches
   *     one or more DOM elements. When the selector matches something in the DOM, the page is considered "ready" for
   *     the user.
   *
   *     For non-initial page loads, if the selector _immediately_ matches one or more elements in the DOM, it will
   *     first wait a matching element to be removed, and then wait for a DOM mutation to expose a matching element.
   *     This behaviour can be turned off (i.e. don't require an element to be removed first) via the
   *     `requireUpdate=false` option.
   * @returns {undefined}
   * @example
   *     api.start({key: "jira.issue.view"});
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         threshold: 1000
   *     });
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         ready: ".issue-main-content",
   *         threshold: 1000
   *     });
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         ready: [
   *             ".issue-main-content",
   *             {selector: ".issue-main-content", hasNone: ".loading"},
   *             ".another-required-thing"
   *         ],
   *         threshold: 1000
   *     });
   * @example
   *     api.start({
   *         key: "jira.issue.view",
   *         ready: [
   *             {selector: ".issue-main-content", requireUpdate: false, hasNone: ".aui-loading, .loading"},
   *             ".another-required-thing"
   *         ],
   *         threshold: 1000
   *     });
   */
  return function start(options) {
    var conditions;
    var isInitial = 'isInitial' in options ? options.isInitial : isDOMContentLoadedDone() === false;
    var threshold = 'threshold' in options ? options.threshold : 1000;
    eventStream.push({
      start: {
        key: options.key,
        isInitial: isInitial,
        threshold: threshold,
        timestamp: isInitial ? 0 : window.performance.now()
      }
    });
    executeOnceOnStart.forEach(function (callback) {
      callback();
    });
    // Empty the array of callbacks now that we've called them.
    executeOnceOnStart.splice(0, executeOnceOnStart.length);
    if (options.ready && isReadySupported) {
      conditions = normalisedReady(options.ready, /*defaultRequireUpdate=*/
      !isInitial);
      combinedReady(conditions).then(function () {
        end({ key: options.key });
      });
    }
  };
}(api_end, api_start_is_ready_supported, event_stream, util_element_hound, util_element_wolf, util_is_dom_content_loaded_done, util_window);
api_subscribe = function (eventStream) {
  /**
   * Add a subscriber that's interested in reports.
   */
  return function subscribe(subscriber) {
    eventStream.push({ subscribe: subscriber });
  };
}(event_stream);
index = function (isSupported, addReporter, delegateTo, end, start, subscribe) {
  var noop = function () {
  };
  return {
    start: isSupported ? start : noop,
    end: isSupported ? end : noop,
    addReporter: isSupported ? addReporter : noop,
    delegateTo: isSupported ? delegateTo : noop,
    subscribe: isSupported ? subscribe : noop
  };
}(is_supported, api_addReporter, api_delegateTo, api_end, api_start, api_subscribe);
window['browser-metrics'] = index;
if (window.define) {
  window.define('internal/browser-metrics', function () {
    return index;
  });
}
}());;
;
/* module-key = 'com.atlassian.plugins.browser.metrics.browser-metrics-plugin:api', location = 'internal/browser-metrics-aa-beacon.js' */
define("internal/browser-metrics-aa-beacon",function(){var n={};return n=function(n){function e(n,e){Object.keys(e).forEach(function(r){n[r]=e[r]})}var r=[],t=[];return n.addUrlCleaner=function(n){t.push(n)},n.cleanUrl=function(n){return t.reduce(function(e,r){var t=r(n);return t.length>e.length?t:e},"")},n.addReportMarshaller=function(n){r.push(n)},n.beacon=function(n){var t={};r.forEach(function(r){var a=r(n);"object"==typeof a&&e(t,a)});var a={name:"browser.metrics.navigation",properties:t};AJS.EventQueue.push(a)},n}(n)});;
;
/* module-key = 'com.atlassian.plugins.browser.metrics.browser-metrics-plugin:api', location = 'loader.js' */
;(function() {
var lib_window = {}, lib_wrm = {}, loader = {};
lib_window = function (exports) {
  var w = window;
  return w;
}(lib_window);
lib_wrm = function (exports, window) {
  var wrm = window.WRM;
  return wrm;
}(lib_wrm, lib_window);
loader = function (exports, window, WRM) {
  var contribInstallers = 0;
  var contribInstalls = 0;
  var collectorInstaller = null;
  function tryInstallCollector() {
    if (contribInstallers === contribInstalls && collectorInstaller) {
      collectorInstaller();
      collectorInstaller = null;
    }
  }
  var api = {
    install: function (installer) {
      contribInstallers += 1;
      installer(function () {
        contribInstalls += 1;
        tryInstallCollector();
      });
    }
  };
  window['browser-metrics-plugin'] = api;
  WRM.require(['wrc!browser-metrics-plugin.contrib'], function () {
    window.require(['internal/browser-metrics-plugin/collector'], function (collector) {
      collectorInstaller = function () {
        collector.install();
      };
      tryInstallCollector();
    });
  });
  return exports;
}(loader, lib_window, lib_wrm);
}());;
;
/* module-key = 'jira.webresources:dashboard-performance-metrics', location = '/includes/jira/dashboard/performanceMetrics.js' */
/**
 * This script might yield overly pessimistic measurements, depending on how late it is executed.
 * For this reason, the script SHOULD NOT be an `async` script nor be loaded dynamically long after
 * `domContentLoadedEventEnd`.
 */
(function integrateDashboardWithBrowserMetrics() {
    var metrics = require("internal/browser-metrics");
    var $ = require("jquery");
    var DASHBOARD_PAGE_KEY = "jira.dashboard";

    /**
     * @param {HTMLIFrameElement} iframe
     * @returns a jQuery promise that is resolved when the element has loaded.
     */
    function whenIframeLoaded(iframe) {
        var loading = $.Deferred();

        // jQuery.load() does not execute the callback if the iframe is already loaded, so we need to handle the case
        // where it's already loaded.
        //
        // We wait for readyState "complete" (i.e. loadEventEnd) so we wait for images, as some gadgets (e.g. charts)
        // use dynamically generated images as core content. The down side of this is that we'll be overly pessimistic
        // for gadgets that _don't_ make critical use of images, but it's better to err on this side than the other.
        if (iframe.contentDocument && iframe.contentDocument.readyState === "complete") {
            // iframe was already loaded, so this will make the measurement more pessimistic
            loading.resolve();
        } else {
            $(iframe).load(function resolveIframeLoading() {
                loading.resolve();
            });
        }
        return loading.promise();
    }

    /**
     * @param {HTMLIFrameElement[]} iframes
     * @returns a jQuery promise that is resolved when all iframes matching the selector (at the point in time when the
     * method was called) have loaded. If no elements match the selector, the promise is resolved immediately.
     */
    function whenIframesLoaded(iframes) {
        var loadPromises = iframes.map(function toIframeLoadedPromise() {
            return whenIframeLoaded(this);
        });

        return $.when.apply($, loadPromises);
    }

    /**
     * @returns a jQuery promise that is resolved when the dashboard has initialized (i.e. all gadgets have been added
     * to the DOM).
     */
    function whenDashboardInitialized() {
        var initialized = $.Deferred();

        // Wait for the DOM to be ready so we can inspect the dashboard element.
        $(function inspectDashboard() {
            var dashboard = $("#dashboard");

            // Harden against this code running _not_ on a dashboard page.
            if (dashboard.length === 0) {
                initialized.reject();
            }

            // The HTML that's delivered to the browser has <div id="dashboard" class="initializing"> and when the
            // dashboard is been initialized the "initializing" class is removed. This can be used in a similar manner
            // to document.readyState to detect if the dashboard is _already_ initialized, or if we need to wait for the
            // "initialized" event.
            if (dashboard.hasClass("initializing")) {
                dashboard.on("initialized", function resolveDeferred() {
                    initialized.resolve();
                });
            } else {
                // dashboard was already loaded, but the iframes might not yet be, so the measurement accuracy
                // is unknown at this point
                initialized.resolve();
            }
        });

        return initialized.promise();
    }

    metrics.start({
        key: DASHBOARD_PAGE_KEY,
        isInitial: true
    });

    // Wait for the dashboard to be loaded, otherwise gadget iframes may not yet exist in the DOM.
    whenDashboardInitialized()
        .pipe(function waitForIframesToLoaded() {
            var iframes = $("#dashboard").find("iframe").get();
            return whenIframesLoaded(iframes);
        })
        .done(function endMeasurement() {
            metrics.end({key: DASHBOARD_PAGE_KEY});
        });
})();
;
;
/* module-key = 'com.atlassian.auiplugin:dialog2', location = 'js/dialog2.js' */
;(function (init) {
    'use strict';

    AJS.dialog2 = init(AJS.$, AJS.layer, AJS._internal.widget);
})(function ($, layerWidget, widget) {
    'use strict';


    var defaults = {
        'aui-focus': 'false', // do not focus by default as it's overridden below
        'aui-blanketed': 'true'
    };

    function applyDefaults($el) {
        $.each(defaults, function (key, value) {
            var dataKey = 'data-' + key;
            if (!$el[0].hasAttribute(dataKey)) {
                $el.attr(dataKey, value);
            }
        });
    }

    function Dialog2(selector) {
        if (selector) {
            this.$el = $(selector);
        }
        else {
            this.$el = $(aui.dialog.dialog2({}));
        }
        applyDefaults(this.$el);
    }

    Dialog2.prototype.on = function (event, fn) {
        layerWidget(this.$el).on(event, fn);
        return this;
    };

    Dialog2.prototype.off = function (event, fn) {
        layerWidget(this.$el).off(event, fn);
        return this;
    };

    Dialog2.prototype.show = function () {
        layerWidget(this.$el).show();
        return this;
    };

    Dialog2.prototype.hide = function () {
        layerWidget(this.$el).hide();
        return this;
    };

    Dialog2.prototype.remove = function () {
        layerWidget(this.$el).remove();
        return this;
    };

    Dialog2.prototype.isVisible = function () {
        return layerWidget(this.$el).isVisible();
    };

    var dialog2Widget = widget('dialog2', Dialog2);

    dialog2Widget.on = function (eventName, fn) {
        layerWidget.on(eventName, '.aui-dialog2', fn);
        return this;
    };

    dialog2Widget.off = function (eventName, fn) {
        layerWidget.off(eventName, '.aui-dialog2', fn);
        return this;
    };

    /* Live events */

    $(document).on('click', '.aui-dialog2-header-close', function (e) {
        e.preventDefault();
        dialog2Widget($(this).closest('.aui-dialog2')).hide();
    });

    dialog2Widget.on('show', function (e, $el) {
        var selectors = ['.aui-dialog2-content', '.aui-dialog2-footer', '.aui-dialog2-header'];
        var $selected;
        selectors.some(function (selector) {
            $selected = $el.find(selector + ' :aui-tabbable');
            return $selected.length;
        });
        $selected && $selected.first().focus();
    });

    dialog2Widget.on('hide', function (e,$el) {
        var layer = layerWidget($el);

        if ($el.data('aui-remove-on-hide')) {
            layer.remove();
        }
    });

    return dialog2Widget;
});
;
;
/* module-key = 'com.atlassian.auiplugin:dialog2', location = 'soy/dialog2.soy' */
// This file was automatically generated from dialog2.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace aui.dialog.
 */

if (typeof aui == 'undefined') { var aui = {}; }
if (typeof aui.dialog == 'undefined') { aui.dialog = {}; }


aui.dialog.dialog2 = function(opt_data, opt_ignored) {
  return '' + aui.dialog.dialog2Chrome({id: opt_data.id, titleId: opt_data.id ? opt_data.id + '-dialog-title' : null, modal: opt_data.modal, tagName: opt_data.tagName, removeOnHide: opt_data.removeOnHide, visible: opt_data.visible, size: opt_data.size, extraClasses: opt_data.extraClasses, extraAttributes: opt_data.extraAttributes, content: '' + aui.dialog.dialog2Content({id: null, titleText: opt_data.titleText, titleContent: opt_data.titleContent, headerActionContent: opt_data.headerActionContent, headerSecondaryContent: opt_data.headerSecondaryContent, modal: opt_data.modal, content: opt_data.content, footerHintText: opt_data.footerHintText, footerHintContent: opt_data.footerHintContent, footerActionContent: opt_data.footerActionContent})});
};
if (goog.DEBUG) {
  aui.dialog.dialog2.soyTemplateName = 'aui.dialog.dialog2';
}


aui.dialog.dialog2Chrome = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<' + soy.$$escapeHtml(opt_data.tagName ? opt_data.tagName : 'section') + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ((opt_data.titleId) ? ' aria-labelledby="' + soy.$$escapeHtml(opt_data.titleId) + '"' : '') + ' role="dialog" class=" aui-layer aui-dialog2 aui-dialog2-' + soy.$$escapeHtml(opt_data.size ? opt_data.size : 'medium') + aui.renderExtraClasses(opt_data) + '"' + ((opt_data.modal) ? 'data-aui-modal="true"' : '') + ((opt_data.removeOnHide) ? 'data-aui-remove-on-hide="true"' : '') + ((opt_data.visible != true) ? 'aria-hidden="true"' : '') + aui.renderExtraAttributes(opt_data) + '>' + ((opt_data.content) ? soy.$$filterNoAutoescape(opt_data.content) : '') + '</' + soy.$$escapeHtml(opt_data.tagName ? opt_data.tagName : 'section') + '>';
};
if (goog.DEBUG) {
  aui.dialog.dialog2Chrome.soyTemplateName = 'aui.dialog.dialog2Chrome';
}


aui.dialog.dialog2Content = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + aui.dialog.dialog2Header({titleId: opt_data.id ? opt_data.id + '-dialog-title' : null, titleText: opt_data.titleText, titleContent: opt_data.titleContent, actionContent: opt_data.headerActionContent, secondaryContent: opt_data.headerSecondaryContent, modal: opt_data.modal}) + aui.dialog.dialog2Panel(opt_data) + aui.dialog.dialog2Footer({hintText: opt_data.footerHintText, hintContent: opt_data.footerHintContent, actionContent: opt_data.footerActionContent});
};
if (goog.DEBUG) {
  aui.dialog.dialog2Content.soyTemplateName = 'aui.dialog.dialog2Content';
}


aui.dialog.dialog2Header = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<header' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ' class="aui-dialog2-header' + aui.renderExtraClasses(opt_data) + '"' + aui.renderExtraAttributes(opt_data) + '><h2 ' + ((opt_data.titleId) ? ' id="' + soy.$$escapeHtml(opt_data.titleId) + '"' : '') + ' class="aui-dialog2-header-main">' + ((opt_data.titleText) ? soy.$$escapeHtml(opt_data.titleText) : '') + ((opt_data.titleContent) ? soy.$$filterNoAutoescape(opt_data.titleContent) : '') + '</h2>' + ((opt_data.actionContent) ? '<div class="aui-dialog2-header-actions">' + soy.$$filterNoAutoescape(opt_data.actionContent) + '</div>' : '') + ((opt_data.secondaryContent) ? '<div class="aui-dialog2-header-secondary">' + soy.$$filterNoAutoescape(opt_data.secondaryContent) + '</div>' : '') + ((opt_data.modal != true) ? '<a class="aui-dialog2-header-close"><span class="aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Close") + '</span></a>' : '') + '</header>';
};
if (goog.DEBUG) {
  aui.dialog.dialog2Header.soyTemplateName = 'aui.dialog.dialog2Header';
}


aui.dialog.dialog2Footer = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<footer' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ' class="aui-dialog2-footer' + aui.renderExtraClasses(opt_data) + '"' + aui.renderExtraAttributes(opt_data) + '>' + ((opt_data.actionContent) ? '<div class="aui-dialog2-footer-actions">' + soy.$$filterNoAutoescape(opt_data.actionContent) + '</div>' : '') + ((opt_data.hintText || opt_data.hintContent) ? '<div class="aui-dialog2-footer-hint">' + ((opt_data.hintText) ? soy.$$escapeHtml(opt_data.hintText) : '') + ((opt_data.hintContent) ? soy.$$filterNoAutoescape(opt_data.hintContent) : '') + '</div>' : '') + '</footer>';
};
if (goog.DEBUG) {
  aui.dialog.dialog2Footer.soyTemplateName = 'aui.dialog.dialog2Footer';
}


aui.dialog.dialog2Panel = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ' class="aui-dialog2-content' + aui.renderExtraClasses(opt_data) + '"' + aui.renderExtraAttributes(opt_data) + '>' + ((opt_data.content) ? soy.$$filterNoAutoescape(opt_data.content) : '') + '</div>';
};
if (goog.DEBUG) {
  aui.dialog.dialog2Panel.soyTemplateName = 'aui.dialog.dialog2Panel';
}
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:client-side-soy-templates', location = 'templates/dashboard.soy' */
// This file was automatically generated from dashboard.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Gadgets.Templates.Dashboard.
 */

if (typeof Gadgets == 'undefined') { var Gadgets = {}; }
if (typeof Gadgets.Templates == 'undefined') { Gadgets.Templates = {}; }
if (typeof Gadgets.Templates.Dashboard == 'undefined') { Gadgets.Templates.Dashboard = {}; }


Gadgets.Templates.Dashboard.attr = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ((opt_data.styleClass) ? ' class="' + soy.$$escapeHtml(opt_data.styleClass) + '"' : '') + ((opt_data.href) ? ' href="' + soy.$$escapeHtml(opt_data.href) + '"' : '') + ((opt_data.value) ? ' value="' + soy.$$escapeHtml(opt_data.value) + '"' : '') + ((opt_data.name) ? ' name="up_' + soy.$$escapeHtml(opt_data.name) + '"' : '') + ((opt_data.selected) ? ' selected="selected"' : '');
};
if (goog.DEBUG) {
  Gadgets.Templates.Dashboard.attr.soyTemplateName = 'Gadgets.Templates.Dashboard.attr';
}


Gadgets.Templates.Dashboard.dropdown = function(opt_data, opt_ignored) {
  var output = '';
  var dropdownStyleClass__soy32 = opt_data.styleClass ? 'aui-dd-parent ' + opt_data.styleClass : 'aui-dd-parent';
  var triggerStyleClass__soy33 = opt_data.trigger.styleClass ? opt_data.trigger.styleClass : 'aui-dd-trigger';
  output += '<li ' + Gadgets.Templates.Dashboard.attr(soy.$$augmentMap(opt_data, {styleClass: dropdownStyleClass__soy32})) + '><a id="' + soy.$$escapeHtml(opt_data.trigger.id) + '" class="' + soy.$$escapeHtml(triggerStyleClass__soy33) + ' standard " href="#"><span>' + soy.$$escapeHtml(opt_data.trigger.text) + '</span></a><ul class="aui-dropdown standard hidden">';
  var itemList44 = opt_data.list.items;
  var itemListLen44 = itemList44.length;
  for (var itemIndex44 = 0; itemIndex44 < itemListLen44; itemIndex44++) {
    var itemData44 = itemList44[itemIndex44];
    output += Gadgets.Templates.Dashboard.menuItem(itemData44);
  }
  output += '</ul></li>';
  return output;
};
if (goog.DEBUG) {
  Gadgets.Templates.Dashboard.dropdown.soyTemplateName = 'Gadgets.Templates.Dashboard.dropdown';
}


Gadgets.Templates.Dashboard.menuItem = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.useTemplate == 'dropdown') {
    output += Gadgets.Templates.Dashboard.dropdown(opt_data);
  } else {
    output += '<li ' + Gadgets.Templates.Dashboard.attr(opt_data) + '>';
    if (opt_data.items) {
      output += '<ul>';
      var subItemList59 = opt_data.items;
      var subItemListLen59 = subItemList59.length;
      for (var subItemIndex59 = 0; subItemIndex59 < subItemListLen59; subItemIndex59++) {
        var subItemData59 = subItemList59[subItemIndex59];
        output += Gadgets.Templates.Dashboard.menuItem(subItemData59);
      }
      output += '</ul>';
    } else {
      output += '<a ' + Gadgets.Templates.Dashboard.attr(opt_data.link) + '>' + soy.$$escapeHtml(opt_data.link.text) + '</a>';
    }
    output += '</li>';
  }
  return output;
};
if (goog.DEBUG) {
  Gadgets.Templates.Dashboard.menuItem.soyTemplateName = 'Gadgets.Templates.Dashboard.menuItem';
}


Gadgets.Templates.Dashboard.gadget = function(opt_data, opt_ignored) {
  var output = '<div class="gadget ' + ((opt_data.color) ? soy.$$escapeHtml(opt_data.color) : '') + '" id="gadget-' + soy.$$escapeHtml(opt_data.id) + '-renderbox"><div class="dashboard-item-frame gadget-container" id="gadget-' + soy.$$escapeHtml(opt_data.id) + '-chrome"><div class="dashboard-item-header"><h3 id="gadget-' + soy.$$escapeHtml(opt_data.id) + '-title" class="dashboard-item-title">' + ((opt_data.titleUrl) ? '<a href="' + soy.$$escapeHtml(opt_data.titleUrl) + '">' + soy.$$escapeHtml(opt_data.title) + '</a>' : soy.$$escapeHtml(opt_data.title)) + '</h3><div class="gadget-menu"><ul>' + ((opt_data.layout.writable) ? '<li class="aui-icon i-move">move</li>' : '') + ((opt_data.isMaximizable) ? '<li><a href="#" id="gadget-' + soy.$$escapeHtml(opt_data.id) + '-maximize" class="aui-icon maximize" title="' + soy.$$escapeHtml("Maximise") + '">' + soy.$$escapeHtml("Maximise") + '</a></li>' : '') + Gadgets.Templates.Dashboard.dropdown(opt_data.menu) + '</ul></div></div><div class="dashboard-item-content ' + ((opt_data.minimized) ? 'minimization' : '') + '">';
  if (opt_data.userPrefs) {
    output += '<form action="' + soy.$$escapeHtml(opt_data.userPrefs.action) + '" class="aui userpref-form hidden" method="post" id="gadget-' + soy.$$escapeHtml(opt_data.id) + '-edit"><fieldset><legend><span class="dashboard-item-title">' + soy.$$escapeHtml(opt_data.title) + '</span> ' + soy.$$escapeHtml("Preferences") + '</legend>';
    var fieldList121 = opt_data.userPrefs.fields;
    var fieldListLen121 = fieldList121.length;
    for (var fieldIndex121 = 0; fieldIndex121 < fieldListLen121; fieldIndex121++) {
      var fieldData121 = fieldList121[fieldIndex121];
      if (fieldData121.type == 'hidden') {
        output += '<input id="gadget-' + soy.$$escapeHtml(opt_data.id) + '-form-' + soy.$$escapeHtml(fieldData121.name) + '-pref" type="hidden" class="hidden" ' + Gadgets.Templates.Dashboard.attr(fieldData121) + '/>';
      } else if (fieldData121.type == 'list') {
        output += '<div id="up_' + soy.$$escapeHtml(fieldData121.name) + '-container" class="list-container field-group"><label for="gadget-' + soy.$$escapeHtml(opt_data.id) + '-form-' + soy.$$escapeHtml(fieldData121.name) + '-pref">' + soy.$$escapeHtml(fieldData121.displayName) + '</label><input id="gadget-' + soy.$$escapeHtml(opt_data.id) + '-form-' + soy.$$escapeHtml(fieldData121.name) + '-pref" type="text" class="list text med" ' + Gadgets.Templates.Dashboard.attr(fieldData121) + ' />' + ((fieldData121.required) ? 'field.required' : '') + '<div class="description">' + soy.$$escapeHtml("(pipe-delimited)") + '</div></div>';
      } else if (fieldData121.type == 'bool') {
        output += '<div class="checkbox field-group"><input type="checkbox" value="true" class="bool" id="gadget-' + soy.$$escapeHtml(opt_data.id) + '-form-' + soy.$$escapeHtml(fieldData121.name) + '-pref" ' + ((fieldData121.value) ? 'checked' : '') + ' ' + Gadgets.Templates.Dashboard.attr(fieldData121) + ' /><label for="gadget-' + soy.$$escapeHtml(opt_data.id) + '-form-' + soy.$$escapeHtml(fieldData121.name) + '-pref">' + soy.$$escapeHtml(fieldData121.displayName) + ' ' + ((fieldData121.required) ? 'field.required' : '') + '</label><br/></div>';
      } else if (fieldData121.type == 'enum') {
        output += '<div class="field-group"><label for="gadget-' + soy.$$escapeHtml(opt_data.id) + '-form-' + soy.$$escapeHtml(fieldData121.name) + '-pref">' + soy.$$escapeHtml(fieldData121.displayName) + ' ' + ((fieldData121.required) ? 'field.required' : '') + '</label><select id="gadget-' + soy.$$escapeHtml(opt_data.id) + '-form-' + soy.$$escapeHtml(fieldData121.name) + '-pref" class="enum" ' + Gadgets.Templates.Dashboard.attr(fieldData121) + '>';
        var optionList193 = fieldData121.options;
        var optionListLen193 = optionList193.length;
        for (var optionIndex193 = 0; optionIndex193 < optionListLen193; optionIndex193++) {
          var optionData193 = optionList193[optionIndex193];
          output += '<option class="enum" ' + Gadgets.Templates.Dashboard.attr(optionData193) + '>' + soy.$$escapeHtml(optionData193.label) + '</option>';
        }
        output += '</select></div>';
      } else if (fieldData121.type == 'string') {
        output += '<div class="field-group"><label for="gadget-' + soy.$$escapeHtml(opt_data.id) + '-form-' + soy.$$escapeHtml(fieldData121.name) + '-pref">' + soy.$$escapeHtml(fieldData121.displayName) + '</label><input id="gadget-' + soy.$$escapeHtml(opt_data.id) + '-form-' + soy.$$escapeHtml(fieldData121.name) + '-pref" type="text" ' + Gadgets.Templates.Dashboard.attr(fieldData121) + ' class="string text">' + ((fieldData121.required) ? 'field.required' : '') + '<br/></div>';
      }
    }
    output += '</fieldset><div class="buttons-container submit"><input type="submit" class="submit" value="' + soy.$$escapeHtml("Save") + '" name="save" id="gadget-' + soy.$$escapeHtml(opt_data.id) + '-save"/><input type="reset" class="cancel" value="' + soy.$$escapeHtml("Cancel") + '" name="reset" id="gadget-' + soy.$$escapeHtml(opt_data.id) + '-cancel" class="userpref-form-cancel"/></div></form>';
  }
  var gadgetHeight__soy229 = opt_data.height ? opt_data.height : 300;
  output += ((opt_data.inlineHtml || opt_data.amdModule) ? '<div id="gadget-' + soy.$$escapeHtml(opt_data.id) + '" class="gadget-inline">' + soy.$$filterNoAutoescape(opt_data.inlineHtml) + '</div>' : '<iframe id="gadget-' + soy.$$escapeHtml(opt_data.id) + '" class="gadget-iframe" name="gadget-' + soy.$$escapeHtml(opt_data.id) + '" src="' + soy.$$escapeHtml(opt_data.renderedGadgetUrl) + '" height="' + soy.$$escapeHtml(gadgetHeight__soy229) + '" width="100%" scrolling="no" frameborder="no"></iframe>') + '</div></div></div>';
  return output;
};
if (goog.DEBUG) {
  Gadgets.Templates.Dashboard.gadget.soyTemplateName = 'Gadgets.Templates.Dashboard.gadget';
}


Gadgets.Templates.Dashboard.layoutDialog = function(opt_data, opt_ignored) {
  var output = '<div class="dialog-components"><h2 class="dialog-title">' + soy.$$escapeHtml("Edit Layout") + '</h2><div class="dialog-page-body"><div class="dialog-panel-body panel-body"><p><strong>' + soy.$$escapeHtml("Choose dashboard layout") + '</strong></p><ul>';
  var layoutList255 = opt_data.layouts;
  var layoutListLen255 = layoutList255.length;
  for (var layoutIndex255 = 0; layoutIndex255 < layoutListLen255; layoutIndex255++) {
    var layoutData255 = layoutList255[layoutIndex255];
    output += '<li><a href="#" id="' + soy.$$escapeHtml(layoutData255.layoutAttrName) + '"><strong>' + soy.$$escapeHtml(layoutData255.layout) + '</strong></a></li>';
  }
  output += '</ul></div></div><div class="dialog-button-panel"><button class="button-panel-button" id="' + soy.$$escapeHtml(opt_data.closeId) + '">' + soy.$$escapeHtml("Close") + '</button></div></div>';
  return output;
};
if (goog.DEBUG) {
  Gadgets.Templates.Dashboard.layoutDialog.soyTemplateName = 'Gadgets.Templates.Dashboard.layoutDialog';
}


Gadgets.Templates.Dashboard.dashboardMenu = function(opt_data, opt_ignored) {
  var output = '<div class="aui-page-header"><div class="aui-page-header-inner"><div class="aui-page-header-main"><h1>' + soy.$$escapeHtml(opt_data.title) + '</h1></div><div class="aui-page-header-actions" id="dash-options"><div id="dash-throbber" class="throbber">&nbsp;</div><ul class="operations enabled">';
  var itemList271 = opt_data.items;
  var itemListLen271 = itemList271.length;
  for (var itemIndex271 = 0; itemIndex271 < itemListLen271; itemIndex271++) {
    var itemData271 = itemList271[itemIndex271];
    output += Gadgets.Templates.Dashboard.menuItem(itemData271);
  }
  output += '</ul></div></div></div>';
  return output;
};
if (goog.DEBUG) {
  Gadgets.Templates.Dashboard.dashboardMenu.soyTemplateName = 'Gadgets.Templates.Dashboard.dashboardMenu';
}
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:client-side-soy-templates', location = 'templates/dashboard-item-directory.soy' */
// This file was automatically generated from dashboard-item-directory.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Dashboard.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Dashboard == 'undefined') { JIRA.Dashboard = {}; }
if (typeof JIRA.Dashboard.Templates == 'undefined') { JIRA.Dashboard.Templates = {}; }


JIRA.Dashboard.Templates.gadgetDirectoryDialog = function(opt_data, opt_ignored) {
  return '<section role="dialog" id="' + soy.$$escapeHtml(opt_data.id) + '" class="aui-layer aui-dialog2 aui-dialog2-xlarge" aria-hidden="true"><header class="aui-dialog2-header"><h1 class="aui-dialog2-header-main">' + soy.$$escapeHtml(opt_data.headerText) + '</h1>' + ((opt_data.canManageGadgets) ? '<div class="aui-dialog2-header-secondary"><a href="' + soy.$$escapeHtml(opt_data.gadgetsAdminUrl) + '">' + soy.$$escapeHtml(opt_data.manageGadgetsLabel) + '</a></div>' : '') + '<a class="aui-dialog2-header-close"><span class="aui-icon aui-icon-small aui-iconfont-close-dialog">' + soy.$$escapeHtml("Close") + '</span></a></header><div class="aui-dialog2-content"></div></section>';
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.gadgetDirectoryDialog.soyTemplateName = 'JIRA.Dashboard.Templates.gadgetDirectoryDialog';
}


JIRA.Dashboard.Templates.gadgetDirectoryLoadingPage = function(opt_data, opt_ignored) {
  return '<div class="message-panel"><div class="loading-spinner"></div><p class="loading-text">' + soy.$$escapeHtml(opt_data.loadingText) + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.gadgetDirectoryLoadingPage.soyTemplateName = 'JIRA.Dashboard.Templates.gadgetDirectoryLoadingPage';
}


JIRA.Dashboard.Templates.gadgetDirectoryLoadFailurePage = function(opt_data, opt_ignored) {
  return '<div class="message-panel"><p class="title" style="text-align: center;"><strong>' + soy.$$escapeHtml("Failed to load gadgets") + '</strong></p><p style="text-align: center;">' + soy.$$escapeHtml("Something went wrong while trying to load the gadgets.") + '</p><p style="text-align: center;"><a href="#" data-purpose="reload-directory">' + soy.$$escapeHtml("Try again") + '</a></p></div>';
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.gadgetDirectoryLoadFailurePage.soyTemplateName = 'JIRA.Dashboard.Templates.gadgetDirectoryLoadFailurePage';
}


JIRA.Dashboard.Templates.gadgetDirectoryPage = function(opt_data, opt_ignored) {
  return '<div id="directory-page" class="aui-group"><div id="nav-panel" class="aui-item aui-page-panel-nav"><form class="directory-search aui" action="#"><input id="search" class="text" type="text" placeholder="' + soy.$$escapeHtml(opt_data.searchPlaceholder) + '"></input></form><nav class="aui-navgroup aui-navgroup-vertical"><div class="aui-navgroup-inner"></div></nav></div><div id="right-panel" class="aui-item"><div id="message-panel"></div><div id="list-panel"></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.gadgetDirectoryPage.soyTemplateName = 'JIRA.Dashboard.Templates.gadgetDirectoryPage';
}


JIRA.Dashboard.Templates.directoryNavList = function(opt_data, opt_ignored) {
  var output = '<div class="aui-nav-heading"><strong>' + soy.$$escapeHtml(opt_data.headerText) + '</strong></div><ul class="aui-nav">';
  var categoryList38 = opt_data.categories;
  var categoryListLen38 = categoryList38.length;
  for (var categoryIndex38 = 0; categoryIndex38 < categoryListLen38; categoryIndex38++) {
    var categoryData38 = categoryList38[categoryIndex38];
    var isSelected__soy39 = categoryData38.label == opt_data.selectedCategoryLabel;
    output += JIRA.Dashboard.Templates.directoryNavItem({category: categoryData38, selected: isSelected__soy39});
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.directoryNavList.soyTemplateName = 'JIRA.Dashboard.Templates.directoryNavList';
}


JIRA.Dashboard.Templates.directoryNavItem = function(opt_data, opt_ignored) {
  return '<li class="category-nav-item' + ((opt_data.selected) ? ' aui-nav-selected' : '') + '" ><a href="#" data-category-label="' + soy.$$escapeHtml(opt_data.category.label) + '" data-purpose="category-nav" title="' + soy.$$escapeHtml(opt_data.category.label) + '"><span class="aui-badge">' + soy.$$escapeHtml(opt_data.category.count) + '</span>' + soy.$$escapeHtml(opt_data.category.label) + '</a></li>';
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.directoryNavItem.soyTemplateName = 'JIRA.Dashboard.Templates.directoryNavItem';
}


JIRA.Dashboard.Templates.directoryItems = function(opt_data, opt_ignored) {
  var output = '';
  var itemList60 = opt_data.items;
  var itemListLen60 = itemList60.length;
  for (var itemIndex60 = 0; itemIndex60 < itemListLen60; itemIndex60++) {
    var itemData60 = itemList60[itemIndex60];
    output += (itemData60.specUri) ? JIRA.Dashboard.Templates.directoryItem({item: itemData60, id: itemData60.specUri, type: 'gadget'}) : JIRA.Dashboard.Templates.directoryItem({item: itemData60, id: itemData60.completeModuleKey, type: 'dashboard-item'});
  }
  output += JIRA.Dashboard.Templates.noResultsPage(null);
  return output;
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.directoryItems.soyTemplateName = 'JIRA.Dashboard.Templates.directoryItems';
}


JIRA.Dashboard.Templates.directoryItem = function(opt_data, opt_ignored) {
  var output = '';
  var localityLabel__soy75 = opt_data.item.isLocal ? "Local" : "External";
  output += '<div class="aui-group item-group" data-item-id="' + soy.$$escapeHtml(opt_data.id) + '" data-item-title="' + soy.$$escapeHtml(opt_data.item.titleLabel) + '">' + ((opt_data.item.thumbnailUri) ? '<div class="aui-item item-thumbnail"><img width="120" height="60" src="' + soy.$$escapeHtml(opt_data.item.thumbnailUri) + '"></img></div>' : '') + '<div class="aui-item item-description"><h4>' + soy.$$escapeHtml(opt_data.item.titleLabel) + '</h4><p class="item-author">' + soy.$$escapeHtml(opt_data.item.authorLineItem) + '  &bull;  ' + soy.$$escapeHtml(localityLabel__soy75) + '</p><p>' + soy.$$escapeHtml(opt_data.item.description) + '</p>' + ((opt_data.item.specUri) ? '<div class="aui-group"><textarea style="width: 350px; height: 50px; display: none;">' + soy.$$escapeHtml(opt_data.item.specUriDisplay) + '</textarea><a href="#" class="toggle-xml" data-purpose="toggle-xml">' + soy.$$escapeHtml("Show XML link") + '</a></div>' : '') + '</div><div class="aui-item item-actions"><button type="button" class="aui-button" data-purpose="add-dashboard-item" data-item-type="' + soy.$$escapeHtml(opt_data.type) + '" data-item-id="' + soy.$$escapeHtml(opt_data.item.id) + '">' + soy.$$escapeHtml("Add gadget") + '</button></div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.directoryItem.soyTemplateName = 'JIRA.Dashboard.Templates.directoryItem';
}


JIRA.Dashboard.Templates.directoryMessages = function(opt_data, opt_ignored) {
  return '' + ((opt_data.payload.directoryIsVisible && opt_data.payload.hasUnrenderedData) ? JIRA.Dashboard.Templates.moreDataMessage(null) : '') + ((opt_data.payload.retrievalInProgress) ? JIRA.Dashboard.Templates.inProgressMessage(null) : (opt_data.payload.retrievalFailed) ? JIRA.Dashboard.Templates.retrievalFailedMessage(null) : '');
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.directoryMessages.soyTemplateName = 'JIRA.Dashboard.Templates.directoryMessages';
}


JIRA.Dashboard.Templates.inProgressMessage = function(opt_data, opt_ignored) {
  return '' + aui.message.info({id: 'in-progress-message', titleContent: "Not all gadgets have loaded", content: '<p>' + soy.$$escapeHtml("We\x27re still trying to fetch all of the available gadgets.") + '</p>'});
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.inProgressMessage.soyTemplateName = 'JIRA.Dashboard.Templates.inProgressMessage';
}


JIRA.Dashboard.Templates.retrievalFailedMessage = function(opt_data, opt_ignored) {
  return '' + aui.message.warning({id: 'failure-message', titleContent: "Some gadgets failed to load", content: '<p>' + soy.$$escapeHtml("We were unable to load all of the available gadgets.") + '</p><p><a href=\'#\' data-purpose=\'retry\'>' + soy.$$escapeHtml("Try again") + '</a></p>'});
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.retrievalFailedMessage.soyTemplateName = 'JIRA.Dashboard.Templates.retrievalFailedMessage';
}


JIRA.Dashboard.Templates.moreDataMessage = function(opt_data, opt_ignored) {
  return '' + aui.message.info({id: 'more-data-message', titleContent: "More gadgets available", content: '<p>' + soy.$$escapeHtml("Additional gadgets have been found and can be loaded.") + '</p><p><a href=\'#\' id="load-more-directory-items" data-purpose=\'load\'>' + soy.$$escapeHtml("Load all gadgets") + '</a></p>'});
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.moreDataMessage.soyTemplateName = 'JIRA.Dashboard.Templates.moreDataMessage';
}


JIRA.Dashboard.Templates.noResultsPage = function(opt_data, opt_ignored) {
  return '<div class="message-panel" data-item-id="no-result"><p class="title" style="text-align: center;"><strong>' + soy.$$escapeHtml("No results") + '</strong></p><p style="text-align: center;">' + soy.$$escapeHtml("Try a different category or change your search") + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.Dashboard.Templates.noResultsPage.soyTemplateName = 'JIRA.Dashboard.Templates.noResultsPage';
}
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/json.js' */
/*
    http://www.JSON.org/json2.js
    2008-11-19

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html

    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the object holding the key.

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.

    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/

/*jslint evil: true */

/*global JSON */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (!this.JSON) {
    JSON = {};
}
(function () {

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return this.getUTCFullYear()   + '-' +
                 f(this.getUTCMonth() + 1) + '-' +
                 f(this.getUTCDate())      + 'T' +
                 f(this.getUTCHours())     + ':' +
                 f(this.getUTCMinutes())   + ':' +
                 f(this.getUTCSeconds())   + 'Z';
        };

        String.prototype.toJSON =
        Number.prototype.toJSON =
        Boolean.prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' :
                    gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                                mind + ']' :
                          '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' :
                gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                        mind + '}' : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                     typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/.
test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
})();;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/lib/effects.js' */
/*
 * jQuery UI Effects 1.8rc3
 *
 * Copyright (c) 2010 AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * http://docs.jquery.com/UI/Effects/
 */
;jQuery.effects || (function($) {

$.effects = {};



/******************************************************************************/
/****************************** COLOR ANIMATIONS ******************************/
/******************************************************************************/

// override the animation for color styles
$.each(['backgroundColor', 'borderBottomColor', 'borderLeftColor',
	'borderRightColor', 'borderTopColor', 'color', 'outlineColor'],
function(i, attr) {
	$.fx.step[attr] = function(fx) {
		if (!fx.colorInit) {
			fx.start = getColor(fx.elem, attr);
			fx.end = getRGB(fx.end);
			fx.colorInit = true;
		}

		fx.elem.style[attr] = 'rgb(' +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[0] - fx.start[0])) + fx.start[0], 10), 255), 0) + ',' +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[1] - fx.start[1])) + fx.start[1], 10), 255), 0) + ',' +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[2] - fx.start[2])) + fx.start[2], 10), 255), 0) + ')';
	};
});

// Color Conversion functions from highlightFade
// By Blair Mitchelmore
// http://jquery.offput.ca/highlightFade/

// Parse strings looking for color tuples [255,255,255]
function getRGB(color) {
		var result;

		// Check if we're already dealing with an array of colors
		if ( color && color.constructor == Array && color.length == 3 )
				return color;

		// Look for rgb(num,num,num)
		if (result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(color))
				return [parseInt(result[1],10), parseInt(result[2],10), parseInt(result[3],10)];

		// Look for rgb(num%,num%,num%)
		if (result = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(color))
				return [parseFloat(result[1])*2.55, parseFloat(result[2])*2.55, parseFloat(result[3])*2.55];

		// Look for #a0b1c2
		if (result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(color))
				return [parseInt(result[1],16), parseInt(result[2],16), parseInt(result[3],16)];

		// Look for #fff
		if (result = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(color))
				return [parseInt(result[1]+result[1],16), parseInt(result[2]+result[2],16), parseInt(result[3]+result[3],16)];

		// Look for rgba(0, 0, 0, 0) == transparent in Safari 3
		if (result = /rgba\(0, 0, 0, 0\)/.exec(color))
				return colors['transparent'];

		// Otherwise, we're most likely dealing with a named color
		return colors[$.trim(color).toLowerCase()];
}

function getColor(elem, attr) {
		var color;

		do {
				color = $.curCSS(elem, attr);

				// Keep going until we find an element that has color, or we hit the body
				if ( color != '' && color != 'transparent' || $.nodeName(elem, "body") )
						break;

				attr = "backgroundColor";
		} while ( elem = elem.parentNode );

		return getRGB(color);
};

// Some named colors to work with
// From Interface by Stefan Petre
// http://interface.eyecon.ro/

var colors = {
	aqua:[0,255,255],
	azure:[240,255,255],
	beige:[245,245,220],
	black:[0,0,0],
	blue:[0,0,255],
	brown:[165,42,42],
	cyan:[0,255,255],
	darkblue:[0,0,139],
	darkcyan:[0,139,139],
	darkgrey:[169,169,169],
	darkgreen:[0,100,0],
	darkkhaki:[189,183,107],
	darkmagenta:[139,0,139],
	darkolivegreen:[85,107,47],
	darkorange:[255,140,0],
	darkorchid:[153,50,204],
	darkred:[139,0,0],
	darksalmon:[233,150,122],
	darkviolet:[148,0,211],
	fuchsia:[255,0,255],
	gold:[255,215,0],
	green:[0,128,0],
	indigo:[75,0,130],
	khaki:[240,230,140],
	lightblue:[173,216,230],
	lightcyan:[224,255,255],
	lightgreen:[144,238,144],
	lightgrey:[211,211,211],
	lightpink:[255,182,193],
	lightyellow:[255,255,224],
	lime:[0,255,0],
	magenta:[255,0,255],
	maroon:[128,0,0],
	navy:[0,0,128],
	olive:[128,128,0],
	orange:[255,165,0],
	pink:[255,192,203],
	purple:[128,0,128],
	violet:[128,0,128],
	red:[255,0,0],
	silver:[192,192,192],
	white:[255,255,255],
	yellow:[255,255,0],
	transparent: [255,255,255]
};



/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/

var classAnimationActions = ['add', 'remove', 'toggle'],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

function getElementStyles() {
	var style = document.defaultView
			? document.defaultView.getComputedStyle(this, null)
			: this.currentStyle,
		newStyle = {},
		key,
		camelCase;

	// webkit enumerates style porperties
	if (style && style.length && style[0] && style[style[0]]) {
		var len = style.length;
		while (len--) {
			key = style[len];
			if (typeof style[key] == 'string') {
				camelCase = key.replace(/\-(\w)/g, function(all, letter){
					return letter.toUpperCase();
				});
				newStyle[camelCase] = style[key];
			}
		}
	} else {
		for (key in style) {
			if (typeof style[key] === 'string') {
				newStyle[key] = style[key];
			}
		}
	}

	return newStyle;
}

function filterStyles(styles) {
	var name, value;
	for (name in styles) {
		value = styles[name];
		if (
			// ignore null and undefined values
			value == null ||
			// ignore functions (when does this occur?)
			$.isFunction(value) ||
			// shorthand styles that need to be expanded
			name in shorthandStyles ||
			// ignore scrollbars (break in IE)
			(/scrollbar/).test(name) ||

			// only colors or values that can be converted to numbers
			(!(/color/i).test(name) && isNaN(parseFloat(value)))
		) {
			delete styles[name];
		}
	}

	return styles;
}

function styleDifference(oldStyle, newStyle) {
	var diff = { _: 0 }, // http://dev.jquery.com/ticket/5459
		name;

	for (name in newStyle) {
		if (oldStyle[name] != newStyle[name]) {
			diff[name] = newStyle[name];
		}
	}

	return diff;
}

$.effects.animateClass = function(value, duration, easing, callback) {
	if ($.isFunction(easing)) {
		callback = easing;
		easing = null;
	}

	return this.each(function() {

		var that = $(this),
			originalStyleAttr = that.attr('style') || ' ',
			originalStyle = filterStyles(getElementStyles.call(this)),
			newStyle,
			className = that.attr('className');

		$.each(classAnimationActions, function(i, action) {
			if (value[action]) {
				that[action + 'Class'](value[action]);
			}
		});
		newStyle = filterStyles(getElementStyles.call(this));
		that.attr('className', className);

		that.animate(styleDifference(originalStyle, newStyle), duration, easing, function() {
			$.each(classAnimationActions, function(i, action) {
				if (value[action]) { that[action + 'Class'](value[action]); }
			});
			// work around bug in IE by clearing the cssText before setting it
			if (typeof that.attr('style') == 'object') {
				that.attr('style').cssText = '';
				that.attr('style').cssText = originalStyleAttr;
			} else {
				that.attr('style', originalStyleAttr);
			}
			if (callback) { callback.apply(this, arguments); }
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function(classNames, speed, easing, callback) {
		return speed ? $.effects.animateClass.apply(this, [{ add: classNames },speed,easing,callback]) : this._addClass(classNames);
	},

	_removeClass: $.fn.removeClass,
	removeClass: function(classNames,speed,easing,callback) {
		return speed ? $.effects.animateClass.apply(this, [{ remove: classNames },speed,easing,callback]) : this._removeClass(classNames);
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function(classNames, force, speed, easing, callback) {
		if ( typeof force == "boolean" || force === undefined ) {
			if ( !speed ) {
				// without speed parameter;
				return this._toggleClass(classNames, force);
			} else {
				return $.effects.animateClass.apply(this, [(force?{add:classNames}:{remove:classNames}),speed,easing,callback]);
			}
		} else {
			// without switch parameter;
			return $.effects.animateClass.apply(this, [{ toggle: classNames },force,speed,easing]);
		}
	},

	switchClass: function(remove,add,speed,easing,callback) {
		return $.effects.animateClass.apply(this, [{ add: add, remove: remove },speed,easing,callback]);
	}
});



/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

$.extend($.effects, {
	version: "1.8rc3",

	// Saves a set of properties in a data storage
	save: function(element, set) {
		for(var i=0; i < set.length; i++) {
			if(set[i] !== null) element.data("ec.storage."+set[i], element[0].style[set[i]]);
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function(element, set) {
		for(var i=0; i < set.length; i++) {
			if(set[i] !== null) element.css(set[i], element.data("ec.storage."+set[i]));
		}
	},

	setMode: function(el, mode) {
		if (mode == 'toggle') mode = el.is(':hidden') ? 'show' : 'hide'; // Set for toggle
		return mode;
	},

	getBaseline: function(origin, original) { // Translates a [top,left] array into a baseline value
		// this should be a little more flexible in the future to handle a string & hash
		var y, x;
		switch (origin[0]) {
			case 'top': y = 0; break;
			case 'middle': y = 0.5; break;
			case 'bottom': y = 1; break;
			default: y = origin[0] / original.height;
		};
		switch (origin[1]) {
			case 'left': x = 0; break;
			case 'center': x = 0.5; break;
			case 'right': x = 1; break;
			default: x = origin[1] / original.width;
		};
		return {x: x, y: y};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function(element) {

		// if the element is already wrapped, return it
		if (element.parent().is('.ui-effects-wrapper')) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				'float': element.css('float')
			},
			wrapper = $('<div></div>')
				.addClass('ui-effects-wrapper')
				.css({
					fontSize: '100%',
					background: 'transparent',
					border: 'none',
					margin: 0,
					padding: 0
				});

		element.wrap(wrapper);
		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually loose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if (element.css('position') == 'static') {
			wrapper.css({ position: 'relative' });
			element.css({ position: 'relative' });
		} else {
			$.extend(props, {
				position: element.css('position'),
				zIndex: element.css('z-index')
			});
			$.each(['top', 'left', 'bottom', 'right'], function(i, pos) {
				props[pos] = element.css(pos);
				if (isNaN(parseInt(props[pos], 10))) {
					props[pos] = 'auto';
				}
			});
			element.css({position: 'relative', top: 0, left: 0 });
		}

		return wrapper.css(props).show();
	},

	removeWrapper: function(element) {
		if (element.parent().is('.ui-effects-wrapper'))
			return element.parent().replaceWith(element);
		return element;
	},

	setTransition: function(element, list, factor, value) {
		value = value || {};
		$.each(list, function(i, x){
			unit = element.cssUnit(x);
			if (unit[0] > 0) value[x] = unit[0] * factor + unit[1];
		});
		return value;
	}
});


function _normalizeArguments(effect, options, speed, callback) {
	// shift params for method overloading
	if (typeof effect == 'object') {
		callback = options;
		speed = null;
		options = effect;
		effect = options.effect;
	}
	if ($.isFunction(options)) {
		callback = options;
		speed = null;
		options = {};
	}
	if (typeof options == 'number' || $.fx.speeds[options]) {
		callback = speed;
		speed = options;
		options = {};
	}

	options = options || {};

	speed = speed || options.duration;
	speed = $.fx.off ? 0 : typeof speed == 'number'
		? speed : $.fx.speeds[speed] || $.fx.speeds._default;

	callback = callback || options.complete;

	return [effect, options, speed, callback];
}

$.fn.extend({
	effect: function(effect, options, speed, callback) {
		var args = _normalizeArguments.apply(this, arguments),
			// TODO: make effects takes actual parameters instead of a hash
			args2 = {
				options: args[1],
				duration: args[2],
				callback: args[3]
			},
			effectMethod = $.effects[effect];

		return effectMethod && !$.fx.off ? effectMethod.call(this, args2) : this;
	},

	_show: $.fn.show,
	show: function(speed) {
		if (!speed || typeof speed == 'number' || $.fx.speeds[speed]) {
			return this._show.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = 'show';
			return this.effect.apply(this, args);
		}
	},

	_hide: $.fn.hide,
	hide: function(speed) {
		if (!speed || typeof speed == 'number' || $.fx.speeds[speed]) {
			return this._hide.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = 'hide';
			return this.effect.apply(this, args);
		}
	},

	// jQuery core overloads toggle and create _toggle
	__toggle: $.fn.toggle,
	toggle: function(speed) {
		if (!speed || typeof speed == 'number' || $.fx.speeds[speed] ||
			typeof speed == 'boolean' || $.isFunction(speed)) {
			return this.__toggle.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = 'toggle';
			return this.effect.apply(this, args);
		}
	},

	// helper functions
	cssUnit: function(key) {
		var style = this.css(key), val = [];
		$.each( ['em','px','%','pt'], function(i, unit){
			if(style.indexOf(unit) > 0)
				val = [parseFloat(style), unit];
		});
		return val;
	}
});



/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

/*
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Uses the built in easing capabilities added In jQuery 1.1
 * to offer multiple easing options
 *
 * TERMS OF USE - jQuery Easing
 *
 * Open source under the BSD License.
 *
 * Copyright 2008 George McGinley Smith
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

// t: current time, b: begInnIng value, c: change In value, d: duration
$.easing.jswing = $.easing.swing;

$.extend($.easing,
{
	def: 'easeOutQuad',
	swing: function (x, t, b, c, d) {
		return $.easing[$.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - $.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t < d/2) return $.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return $.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

})(jQuery);
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/lib/ajs.clone.js' */
AJS.clone = function (o) {
    function F() {}
    F.prototype = o;
    return new F();
};;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/lib/ajs.parseUri.js' */


/*global AJS, document, setTimeout */
if (!console.error) {
    console.log = console.warn = console.error = console.time = console.timeEnd = function () {};
}


// Library from http://blog.stevenlevithan.com/archives/parseuri

AJS.parseUri = function (uri, strict) {
    var unesc = window.decodeURIComponent || unescape;
    var esc = window.encodeURIComponent || escape;
    
    function parseUri (str) {
        var	o   = parseUri.options,
            m   = o.parser[o.strictMode ? "strict" : "loose"].exec(str),
            uri = {},
            i   = 14;

        while (i--) uri[o.key[i]] = m[i] || "";

        uri[o.q.name] = {};
        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
            if ($1) uri[o.q.name][unesc($1)] = unesc($2);
        });

        return uri;
    };

    parseUri.options = {
        strictMode: !!strict,
        key: ["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],
        q:   {
            name:   "queryKey",
            parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
            strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
            loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
    };

    uri = parseUri(uri);

    uri.toString = function () {
        var params = [];
        AJS.$.each(uri.queryKey, function (name, value) {
            params.push(esc(name) + "=" + esc(value));
        });
        
        return uri.protocol + "://" + uri.authority + uri.path + "?" + params.join("&") + "#" + uri.anchor;
    };
    
    return uri;
};





;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/AG.window.js' */
window.AG = window.AG || {};
AG.window = window;
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/AG.DOMEvent.js' */
window.AG = window.AG || {};

/**
 * Create a native event object.
 *
 * @example
 *
 *     var initialised = AG.DOMEvent("initialised");
 *     document.querySelector("#dashboard").dispatchEvent(initialised);
 *
 * @param name
 * @returns {Event} a native event object
 * @constructor
 *
 * @requires
 *
 *     AG.window.js
 */
AG.DOMEvent = function (name) {
    var window = AG.window;
    var event;

    if (typeof window.Event === "function") {
        event = new window.Event(name);
    } else {
        event = window.document.createEvent("HTMLEvents");
        event.initEvent(name, true, false); // name, bubbles, cancelable
    }

    return event;
};
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/AG.DashboardManager.js' */
/**
 * Manages dashboard. Besides rendering the dashboard menu, this singleton is responsible for delegating actions to
 * layoutManagers.
 *
 * @module dashboard
 * @class DashboardManager
 * @constructor
 * @namespace AG
 */

/*global AJS, console, document*/
/*jslint bitwise: true, eqeqeq: true, immed: true, newcap: true, nomen: true, onevar: true, plusplus: true, regexp: true, undef: true, white: true, indent: 4 */

window.AG = window.AG || {}; // set namespace


AG.DashboardManager = (function () {

    var

    dashboard,

    /**
     * Data store of AG.LayoutMangers
     *
     * @property layouts
     * @private
     * @type {Array}
     */
    layouts = [],

    initializeMenuHandlers = function() {
        AJS.$("#layout-changer").click(function (e) {
            // stop default link action (do not follow link)
            e.preventDefault();
            // opens edit layout dialog
            AG.DashboardManager.editLayout();
        });

        AJS.$("#dashboard-tools-dropdown").dropDown("standard", {
            trigger: ".aui-dd-link"
        });
    },

    initializeDirectory = function() {
        if (AG.param.get("writable")) {
            new JIRA.Dashboard.Modules.Directory('.add-gadget-link');
        }
    };

    return {


        /**
         * Gets dashboard container. The &lt;div&gt; that serves as the container for all other dashboard HTML.
         *
         * @method getDashboard
         * @return {jQuery} dashboard htmlElement
         */
        getDashboard: function () {
            return dashboard;
        },
        
        /**
         * Creates a new instance of AG.LayoutManger. On construction the Layout Manager will build the html for the
         * columns, and if descriptors provided, gadgets also. If gadget descriptors are provided, layout will be set to
         * active.
         *
         * <dl>
         *  <dt>Usage</dt>
         *  <dd>
         *      <pre>
         *
         *      // This will create a layout. It will set it to active because you have specified gadgets
         *      AG.DashboardManager.addLayout({
         *           title: "Dashboard for Scott Harwood",
         *           type: "layout-aaa",
         *           gadgets: [
         *               {
         *                   "height": "300",
         *                   "id":"1",
         *                   "title":"All Hidden Prefs test",
         *                   "gadgetSpecUrl":"http://gadgetspeclocation.com",
         *                   "color":"color4",
         *                   "isMaximizable":false,
         *                   "userPrefs":null,
         *                   "renderedGadgetUrl":"http://gadgetlocationrenderlocation.com"
         *               },
         *               {
         *                   "height": "300",
         *                   "id":"1",
         *                   "title":"All Hidden Prefs test",
         *                   "gadgetSpecUrl":"http://gadgetspeclocation.com",
         *                   "color":"color4",
         *                   "isMaximizable":false,
         *                   "userPrefs":null,
         *                   "renderedGadgetUrl":"http://gadgetlocationrenderlocation.com"
         *               }
         *           ]
         *       });
         *      </pre>
         *  </dd>
         *  <dd>
         *      <pre>
         *
         *      // This will create a layout. It will be inactive as you have specifed a url of which to retrieve gadget descriptors from, when selected.
         *      AG.DashboardManager.addLayout({
         *           title: "Dashboard for Scott Harwood",
         *           type: "layout-aaa",
         *           gadgets: "http://gadget-decriptor-url-for-this-layout/
         *      });
         *      </pre>
         *      </pre>
         *  </dd>
         * </dl>
         *
         * @method addLayout
         * @param {Object} descriptor - JSON describing layout <em>type</em>, <em>title</em>, & <em>gadgets</em>.
         * Gadgets can be an array of gadget descriptors or a url that can be requested to retrieve them.
         */
        addLayout: function (descriptor) {
            var layout = AG.LayoutManager(descriptor);
            layouts.push(layout);

            if (descriptor.active !== false) {
                // make this layout (tab) the active one
                this.setLayout(layout);
            }

            layout.init();
        },

        showShims: function () {
            if (!AJS.$("body").hasClass("propagation-blocker")) {
                AJS.$("body").addClass("propagation-blocker");
                this.getDashboard().shim.height(this.getDashboard().outerHeight());
            }
        },

        hideShims: function () {
            if (AJS.$("body").hasClass("propagation-blocker")) {
                AJS.$("body").removeClass("propagation-blocker");
            }

        },

        /**
         * Executes the diagnostics script, or retrieves the result if it has already been executed before.
         */
        doDiagnostics: function() {
            AJS.$.ajax({
                type: "post",
                url : AG.param.get("dashboardDiagnosticsUrl"),
                data: {
                    uri: document.location.href
                },
                error: function(request) {
                    if (request.status == 500) {
                        diagnosticsErrorDisplay(request);
                    }
                },
                success: function(data) {
                    // do not show warning
                    AJS.$("#diagnostic-warning").addClass("hidden");
                }
            });

            var diagnosticsErrorDisplay = function(request) {
                var diagnosticsWarningDiv = AJS.$("#diagnostic-warning");

                diagnosticsWarningDiv.html(request.responseText);

                var learnMoreText = "Click here to learn more";
                var diagnosticsContentDiv = AJS.$("#diagnostic-content", diagnosticsWarningDiv);
                var learnMoreLink = AJS.$("#learn-more-link", diagnosticsWarningDiv);
                var displayErrorLink = AJS.$("#display-error-link", diagnosticsWarningDiv);
                var stackTraceDiv = AJS.$("#error-stack-trace", diagnosticsWarningDiv);

                var closeWarning = function() {
                    diagnosticsWarningDiv.slideUp();
                    diagnosticsWarningDiv.addClass("hidden");
                    AJS.$.ajax({
                        type: "post",
                        url: AG.param.get("dashboardDiagnosticsUrl"),
                        data: {
                            method: "delete"
                        }
                    });
                };

                var setToggleDetails = function(link, detailDiv) {
                    link.click(function(){
                        if (link.text() == "Hide") {
                            link.text(learnMoreText);
                            detailDiv.slideUp();
                            detailDiv.addClass("hidden");
                        } else {
                            detailDiv.removeClass("hidden");
                            detailDiv.slideDown('slow');
                            link.text("Hide");
                        }
                    });
                };

                setToggleDetails(learnMoreLink, diagnosticsContentDiv);
                setToggleDetails(displayErrorLink, stackTraceDiv);

                AJS.$("#diagnostic-warning .close").click(function() {
                    closeWarning();
                });

                diagnosticsWarningDiv.removeClass("hidden");
            };

        },

        /**
         * Displays edit layout dialog. This function evolves. First time it is called will constuct the html and
         * show layout dialog. Subsequent times it will simply toggle it's visibility.
         *
         * @method editLayout
         */
        editLayout: function () {

            var // local variable declarations
            layoutHtml, /* {String} Rendered layout dialog contents */
            popup,      /* {AJS.popup} instance of AJS.popup */
            layouts = [];

            AJS.$.each(AG.LayoutManager.layouts, function() {
                var layout = this,
                        layoutAttrName = AG.LayoutManager.getLayoutAttrName(layout);
               layouts.push({layoutAttrName:layoutAttrName, layout: layout});
            });

            // get properties for layout dialog
            layoutHtml = Gadgets.Templates.Dashboard.layoutDialog({
                layouts:layouts,
                closeId: "dialog-close"
            });

            // create instance of AJS.popup. This does NOT show popup.
            popup = AJS.popup(507, 224, "layout-dialog");

            popup.element
                    .html(layoutHtml)
                    .addClass(AG.LayoutManager.getLayoutAttrName(AG.DashboardManager.getLayout().getLayout())).addClass("aui-dialog");

            // adds close button & close behaviour
            AJS.$("#dialog-close", popup.element).click(function (e) {

                popup.hide();

                // don't follow link
                e.preventDefault();
            });

            // Find all the layout representations in dialog. Assign a click handler to them that will change the
            // current layout.
            AJS.$.each(AG.LayoutManager.layouts, function () {
                var
                layout = this,
                layoutAttrName = AG.LayoutManager.getLayoutAttrName(layout);

                AJS.$("#" + layoutAttrName).click(function (e) {

                    // Find the layout we are going to affect.
                    var activeLayout = AG.DashboardManager.getLayout();
                    // Set the highlighted layout for this dialog. So next time we open the dialog, the correct one is
                    // highlighted.

                    popup.element
                            .removeClass(AG.LayoutManager.getLayoutAttrName(activeLayout.getLayout()))
                            .addClass(layoutAttrName);

                    // Finally display the selected layout.
                    activeLayout.setLayout(layout);
                    popup.hide();

                    AG.Sortable.update();
                    
                    // Don't follow link.
                    e.preventDefault();
                });
            });

            // Re-define this method (thankyou javascript), so that the next time we call editActive layout we do not
            // constuct the html everytime. All we do is toggle it's visibility with a call to the show method.
            this.editLayout = (function () {
                popup.show();
                AJS.$(document).keyup(function (e) {
                    if (e.keyCode === 27) {
                        popup.hide();
                        AJS.$(document).unbind("keyup", arguments.callee);
                        e.preventDefault();
                    }
                });
                return arguments.callee;
            }()); // call myself straight away. Don't worry! I will be restored by returning myself (arguments.callee)


        },


        /**
         * Gets active layout manager
         *
         * @method getLayout
         * @return {AG.LayoutManager}
         */
        getLayout: function () {
            return this.activeLayout;
        },

        markReadOnlyLayouts: function () {
            AJS.$.each(layouts, function () {
                if (!this.isWritable()) {
                    this.markReadOnlyLayout();
                }
            });
        },

        unmarkReadOnlyLayouts: function () {
            AJS.$.each(layouts, function () {
                if (!this.isWritable()) {
                    this.unmarkReadOnlyLayout();
                }
            });
        },

        /**
         * Sets active layout manager
         * @method setLayout
         * @param {AG.LayoutManager} layout
         * @this {AG.DashboardManager}
         */
        setLayout: function (layout) {
//            if (this.activeLayout) {
//                this.activeLayout.deactivate();
//                this.activeLayout.tab.removeClass("active");
//                layout.activate();
//            }
            // layout.tab.addClass("active");
            this.activeLayout = layout;
            this.getDashboard().header.html(AJS.$("<h1></h1>").text(layout.getName()));
        },

        /**
         * Creates gadget using the provided <em>gadgetDesriptor</em> and appends it to the specified column of the
         * active layout/tab. If column is not specified, will be added as first gadget in the first column.
         *
         * <dl>
         *  <dt>Usage</dt>
         *  <dd>
         *      <pre>
         *      AG.DashboardManager.addGadget({
         *          "height": "300",
         *          "id":"1",
         *          "title":"All Hidden Prefs test",
         *          "gadgetSpecUrl":"http://gadgetspeclocation.com",
         *          "color":"color4",
         *          "isMaximizable":false,
         *          "userPrefs":null,
         *          "renderedGadgetUrl":"http://gadgetlocationrenderlocation.com"
         *       }, 1);
         *       </pre>
         * </dl>
         *
         *
         * @method addGadget
         * @param {Object} gadgetDescriptor - JSON with gadget properites
         * @param {Number} column - Column to append gadget to. (optional)
         */
        addGadget: function (gadget, column) {
            this.activeLayout.addGadget(gadget, column);
        },

        /**
         * Creates furniture & layouts, sets params & il8n strings.
         *
         * @method setup
         * @param options
         * @fires an "initialized" event on the dashboard DOM element when gadgets have been initialized (added to the
         * DOM).
         */
        setup: function (options) {
            var
            that = this,     /* {AG.DashboardManager} 'this' reference for inside of inner functions */
            securityTokenRefreshRate = AJS.parseUri(document.location.href).queryKey["__st_refresh"] || 1000*60*12;

            console.debug = console.debug || function() {};

            // add a point cut to the setHeight service so that it refreshes the positioning of our gadgets. They are
            // absolute positioned so a change of height affects their offset.
            AJS.$.aop.after({target: AG.window.gadgets.IfrGadgetService.prototype, method: "setHeight"}, function () {
                that.getLayout().onInit(function () {
                    that.getLayout().refresh();
                });
            });

            // adds all the il8n and param strings to data store
            AG.param.set(options.params);

            // creates shim that sits over dashboard to prevent propagation of events during actions like dragging
            AG.Sortable.init();

            dashboard = AJS.$("#dashboard");
            dashboard.contents = AJS.$('#dashboard-content');
            dashboard.shim = AJS.$('<div class="dashboard-shim"> </div>').appendTo(dashboard.contents);
            dashboard.tabContainer = dashboard.find('.dashboard-tabs');
            dashboard.header = dashboard.contents.find('.aui-page-header-main');
            initializeMenuHandlers();

            AJS.$.each(options.layouts, function () {
                // creates layout instance and appends gadgets, if provided.
                that.addLayout(this);
            });

            initializeDirectory();
            dashboard.removeClass("initializing");
            dashboard[0].dispatchEvent(AG.DOMEvent("initialized"));

            function updateSecurityTokens() {
                var gadgetTokenFrames = [], updateTokenParams = {};
                console.debug("Updating all gadget security tokens");

                AJS.$.each(AG.DashboardManager.getLayout().getGadgets(), function(index) {
                    gadgetTokenFrames.push({
                        gadget: this,
                        iframeId: this.getElement().find("iframe.gadget-iframe").attr("id")
                    });
                    updateTokenParams["st." + index] = this.getSecurityToken();
                });
                if (!updateTokenParams["st.0"]) {
                    console.debug("No gadgets on dashboard, so there is no need to update security tokens.")
                    return;
                }
                AJS.$.ajax({
                    type: "POST",
                    url: AG.param.get("securityTokensUrl"),
                    data: updateTokenParams,
                    dataType: "json",
                    success: function(newSecurityTokens) {
                        AJS.$.each(gadgetTokenFrames, function(index) {
                            this.gadget.setSecurityToken(newSecurityTokens["st." + index]);
                            try {
                                AG.window.gadgets.rpc.call(this.iframeId, "update_security_token", null, this.gadget.getSecurityToken());
                            } catch (e) {
                                console.debug(
                                                "Unable to update the security token for gadget with iframe id " +
                                                this.iframeId + ".  This likely means that the gadget does not use the " +
                                                "'auth-refresh' feature.  If the gadget uses gadgets.io.makeRequest after its" +
                                                "initial startup, it is a good idea to use the 'auth-refresh' feature " +
                                                "by adding <Optional feature='auth-refresh' /> to your gadget's " +
                                                "<ModulePrefs> section.  Otherwise, the gadget's security token could expire" +
                                                " and subsequent calls to gadgets.io.makeRequest will fail.");
                            }
                        });
                        console.debug("Updating security tokens complete.");
                    },
                    error: function(request, textStatus) {
                        if (request.status != 200) {
                            console.debug(
                                            "Failed to get new security tokens. Response was had a status of '" +
                                            request.status + "' saying '" + request.statusText + "'");
                        } else {
                            console.debug("There was an error processing the response. Error was '" +
                                    textStatus + "'");
                        }
                    }
                });
            }

            console.debug("Security tokens will be refreshed every " + securityTokenRefreshRate + "ms");
            window.setInterval(updateSecurityTokens, securityTokenRefreshRate);
            that.doDiagnostics();
        }
    };
}());


// JRA-19963: If a gadget's iframe size is updated then we need to refresh the layout. We need to do this because all the
// gadgets are absolutely positioned so the dashboard chrome height needs to be calculated and applied.

(function () {

    var buffer;

    jQuery(AG).bind("AG.iframeResize", function () {

        if (buffer) {
            clearTimeout(buffer);
        }
        
        buffer = window.setTimeout(function () {
            AG.DashboardManager.getLayout().refresh();
            buffer = null;
        }, 100);
    });

})();


;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/AG.LayoutManager.js' */
/**
 * Manages Dashboard layout. This includes organising of gadgets and drag and drop functionality. Dashboard specific
 * methods, NOT gadget specific.
 *
 * @module dashboard
 * @class LayoutManager
 * @constructor
 * @namespace AG
 */

/*jslint bitwise: true, eqeqeq: true, immed: true, newcap: true, nomen: true, onevar: true, plusplus: true, regexp: true, undef: true, white: true, indent: 4 */
/*global AG, AJS, alert, console */

(function () {

    if (typeof Object.create !== 'function') {
        Object.create = function (o) {
            function F() {}
            F.prototype = o;
            return new F();
        };
    }

    var LayoutManager = {

        /**
         * Sends request to server to persist current layout, including gadget ordering and column layout.
         *
         * @method saveLayout
         * @private
         */
        saveLayout: function () {

            var that = this;

            function getData() {
                return AJS.$.extend({
                    layout: that.layout
                }, AG.Sortable.serialize());
            }

            AJS.$.ajax({

                type: "post",
                url: AG.param.get("layoutAction"),

                // Self executing function that firstly sets the layout type & method of storge (put). Secondly sets
                // gadget positioning in layout, by looping through, sequentially, all columns and their gadgets,
                // binding gadget id's to column id's.
                contentType: "application/json",
                data: JSON.stringify(getData()),

                beforeSend: function(xhr) {
                    xhr.setRequestHeader("X-HTTP-Method-Override", "PUT");
                },

                success: function () {
                    if(AJS.debug) {
                        console.log("AG.LayoutManager.saveLayout: Layout (" + that.layout + ") saved successfully");
                    }
                },

                // In the case of an error. This can be caused by a timeout (if specified), http error or parseError
                error: function (request) {
                    if (request.status == 403 || request.status == 401) {
                        alert("Sorry, you do not have permission to modify this dashboard. Your dashboard may be out of sync with the server: please reload the page.");
                    }
                    else {
                        alert("Sorry, your changes to this dashboard could not be saved. Your dashboard may be out of sync with the server: please reload the page.");
                    }
                    if(AJS.debug) {
                        console.log("AG.LayoutManager.saveLayout: Request failed! Printing response object...");
                        console.log(request);
                    }
                }
            });
        },

        getColumn: function (idx) {

            var
            that = this,
            i    = parseInt(idx, 16);

            if (arguments.length) {
                return that.columns;
            } else if (!isNaN(i) || !that.columns[i]) {
                return that.columns.eq(i);
            }
            else if(AJS.debug) {
                console.error("AG.LayoutManager.getColumn: The column index you provided is invalid. " +
                        "Expected a number in the range of 0-" + that.columns.length - 1 + " but recieved " + idx);
            }
        },


        /**
         * Sets the type of layout.
         *
         * @method setLayout
         * @param {String} layout - valid layout code
         * @param {Boolean} save (optional) - Flag to presist layout by sending request to server.
         */
        setLayout: function (layout, save) {

            layout = AJS.$.trim(layout);

            // checking if the layout is not the same as current
            if (this.layout === layout) {
                if(AJS.debug) {
                    console.warn("AG.LayoutManager.setLayout: Ignoring! The layout supplied is the same as the current " +
                    "layout (" + layout + ")");
                }
                return;
            }

            // checking if valid layout
            if (AJS.$.inArray(layout, AG.LayoutManager.layouts) === -1) {
                if(AJS.debug) {
                    console.error("AG.LayoutManager.setLayout: Invalid layout! Was given " + layout + ", but expected " +
                                  "either of '" + AG.LayoutManager.layouts.toString() + "'");
                }
            }

            this.container.addClass("layout-" + layout.toLowerCase());

            // cannot set layout if it is not writable
            if (!this.isWritable()) {
                if(AJS.debug) {
                    console.log("AG.LayoutManager.setLayout: Can't manipulate layout. Layout is not writable");
                }
                return;
            }

            // toggle class that defines column visibility and width's
            if (this.layout) {
                this.container.removeClass("layout-" + this.layout.toLowerCase());
            }

            // move any gadgets in this layout, that are hidden due to layout changes, into the closest visible column.
            AJS.$.each(this.gadgets, function () {

                var
                layoutRep = this.getElement().layoutRep, /* Gadget representaion in column layout */
                prevColumn = layoutRep.parent().prev(); /* Column preceeding gadget's current column */

                if (!layoutRep.is(":visible")) {
                    if (prevColumn.is(":visible")) {
                        prevColumn.append(layoutRep);
                    } else {
                        prevColumn.prev().append(layoutRep);
                    }
                }
            });

            // Add "sortable" classes to columns. AG.Sortable uses these classes to find columns to apply sortable
            // functionality to.
            if (layout === "AB" || layout === "BA" || layout === "AA") {
                this.columns.eq(0).addClass("sortable");
                this.columns.eq(1).addClass("sortable");
                this.columns.eq(2).removeClass("sortable");
            } else if (layout === "A") {
                this.columns.eq(0).addClass("sortable");
                this.columns.eq(1).removeClass("sortable");
                this.columns.eq(2).removeClass("sortable");
            } else if (layout === "AAA") {
                this.columns.eq(0).addClass("sortable");
                this.columns.eq(1).addClass("sortable");
                this.columns.eq(2).addClass("sortable");
            }


            this.layout = layout;
            this.refresh();

            if (save !== false) {
                this.saveLayout();
            }
            else if(AJS.debug) {
                console.log("AG.LayoutManager.setLayout: Layout successfully set to '" + this.layout + "'");
            }
        },

        getGadgets: function () {
            return this.gadgets;
        },

        removeGadget: function (gadget) {
            var that = this;
            AJS.$.each(this.gadgets, function (idx) {
                if (this === gadget) {
                    that.gadgets.splice(idx, 1);
                    return false;
                }
            });
        },

        deactivate: function () {
            this.container.hide();
            AJS.$.each(this.gadgets, function () {
                if (this.getElement().layoutRep.css("display") === "list-item") {
                    this.getElement().hide();
                }
            });
        },

        activate: function () {
            this.container.show();
            AJS.$.each(this.gadgets, function () {
                this.getElement().show();
            });
            this.refresh();
        },

        restoreDefaultView: function () {

            var that = this;

            AJS.$(".operations li", AG.DashboardManager.getDashboard()).toggleClass("hidden");

            this.container.removeClass("maximized");

            jQuery.each(this.getGadgets(), function () {
                if (that.getPublicInstance() !== this) {
                    this.getElement().show();
                }
            });

            this.refresh();
        },

        refresh: function () {

            var that = this, isIE6OrBelow = !!(AJS.$.browser.msie && parseInt(jQuery.browser.version) <= 6);

            function appendEmptyMsgElem(col, idx) {
                var message = AJS.format("Drag your gadgets here or {0}add a new gadget.{1}", "<a class='add-gadget-link' id='add-gadget-" + idx + "' href='#'>", "</a>");
                return AJS.$("<li class='empty-text'>" + message + "</li>").appendTo(col);
            }

            function isCanvasMode() {
                return !!AJS.$('.layout.maximized').size();
            }

            if (!this.initialized && !isCanvasMode()) {
                return;
            }

            if (!AG.DashboardManager.getDashboard().hasClass("dragging")) {

                this.columns.css(isIE6OrBelow ? "height" : "minHeight", "");

                this.columns.filter(":visible").each(function (idx) {

                    var column = AJS.$(this);

                    if (AJS.$("li:visible:not(.empty-text)", column).length === 0) {
                        column.addClass("empty");
                        if (that.isWritable()) {
                            if (!this.msgElem) {
                                this.msgElem = appendEmptyMsgElem(column, idx);
                            } else if (this.msgElem) {
                                this.msgElem.show();
                            }
                        }

                    } else if (column.hasClass("empty")) {
                        column.removeClass("empty");
                        if (this.msgElem) {
                            this.msgElem.hide();
                        }
                    }
                });
            }

            AJS.$("li.gadget", this.container).each(function () {
                this.getGadgetInstance().updatePosition();
            });

            if (!AG.DashboardManager.getDashboard().hasClass("dragging")) {
                this.columns.each(function () {
                    var column = AJS.$(this);
                    column.css(isIE6OrBelow ? "height" : "minHeight", column.parent().height());
                });
            }
        },

        /**
         * Adds the gadget to specified column. If the column is not specified then the gadget is added to the first column.
         *
         * @method addGadget
         * @param {AG.Gadget, Object} gadget - Gadget instance to add
         * @param {Number} column - Column in current layout (optionial)
         */
        addGadget: function (gadget, column) {

            var that = this,
                rpctoken;

            function hideGadget () {
                gadget.getElement().layoutRep.addClass("hidden");
                gadget.getElement().hide();
                gadget.getLayoutManager().refresh();
            }

            function showGadget () {
                delete gadget.hasBeenDropped;
                gadget.getElement().layoutRep.removeClass("hidden");
                gadget.getElement().show();
                gadget.getLayoutManager().refresh();
            }

            function validateAdd (numGadgets) {
                if (parseInt(numGadgets) >= AG.param.get("maxGadgets")) {
                    showGadget();
                    alert("Sorry, you have exceeded the maximum number of gadgets supported by your dashboard.  You must remove some gadgets before proceeding.");
                } else {
                    gadget.move(that.options.resourceUrl);
                }
            }

            function appendToColumn () {

                if (!that.initialized) {
                    that.columns.eq(column).append(gadget.getElement().layoutRep);
                } else {
                    that.columns.eq(column).prepend(gadget.getElement().layoutRep);
                }
            }

            function isFromDifferentLayout () {
                return AJS.$.isFunction(gadget.getLayoutManager);
            }

            function ensureIframeDoesntCache () {
                AJS.$("iframe", gadget.getElement()).each(function() {
                    this.src = this.src;
                    this.contentWindow.location = this.src;
                });
            }

            function raiseIframeAppendedEvent () {
                AJS.$("iframe", gadget.getElement()).each(function(idx, elem) {
                    AJS.$(document).trigger("iframeAppended", elem);
                });
            }

            if (!isFromDifferentLayout()) {
                column = column || gadget.column || 0;

                gadget = gadget.loaded ? gadget : AG.Gadget.getNullGadgetRepresentation(gadget);

                // create the rpctoken that will be used in rpc calls
                rpctoken = Math.round(Math.random() * 10000000);
                if (gadget.renderedGadgetUrl) {
                    if (gadget.renderedGadgetUrl.indexOf("#rpctoken") == -1) {
                        gadget.renderedGadgetUrl += "#rpctoken=" + rpctoken;
                    } else {
                        gadget.renderedGadgetUrl = gadget.renderedGadgetUrl.replace(/#rpctoken=\d*/, "#rpctoken=" + rpctoken);
                    }
                }

                // extend gadget descriptor with layout descriptor.
                gadget.layout = this.options;

                // constructs gadget object & methods.
                gadget = AG.Gadget(gadget);

                appendToColumn();

                AG.DashboardManager.getDashboard().contents.append(gadget.getElement());
                gadget.updatePosition();

                gadget.freezeHeight(); // prevent item to grow after it has been placed on the dashboard

                // setup the iframe to send/receive rpc calls
                gadgets.rpc.setAuthToken(gadget.getElement().find("iframe").attr("id"), rpctoken);

                ensureIframeDoesntCache();

                // adds to sortable control
                AG.Sortable.update();

                // Raise iframeAppended event, so people can hook in additional controls as required
                raiseIframeAppendedEvent();

                gadget.onAfterRender();
            } else {
                hideGadget();
                AJS.$.get(this.options.resourceUrl + "/numGadgets", function (numGadgets) {
                    validateAdd(numGadgets);
                });
            }

            // note: only refreshes after all gadgets are appended.
            this.refresh();

            // store reference to instance
            this.gadgets.push(gadget);

            return gadget;
        },

        markReadOnlyLayout: function () {
            if (!this.isWritable()) {
                this.tab.addClass("inactive");
            }
        },
        onInit: function (callback) {
            if (!this.initialized) {
                this.onInit.callbacks = this.onInit.callbacks || [];
                this.onInit.callbacks.push(callback);
            } else {
                callback();
            }
        },
        unmarkReadOnlyLayout: function () {
            if (!this.isWritable() && this.tab.hasClass("inactive")) {
                this.tab.removeClass("inactive");
            }
        },

        isWritable: function () {
            return this.options.writable;
        },

        getPublicInstance: function () {

            var that = this;

            if (!this.publicInterface) {
                this.publicInterface = {
                    unmarkReadOnlyLayout: function () {
                        return that.unmarkReadOnlyLayout.apply(that, arguments);
                    },
                    restoreDefaultView: function () {
                        return that.restoreDefaultView.apply(that, arguments);
                    },
                    markReadOnlyLayout: function () {
                        return that.markReadOnlyLayout.apply(that, arguments);
                    },
                    isWritable: function () {
                        return that.isWritable.apply(that, arguments);
                    },
                    activate: function () {
                        return that.activate.apply(that, arguments);
                    },
                    deactivate: function () {
                        return that.deactivate.apply(that, arguments);
                    },
                    getGadgets: function () {
                        return that.getGadgets.apply(that, arguments);
                    },
                    getLayout: function () {
                        return that.layout;
                    },
                    getContainer: function () {
                        return that.container;
                    },
                    getColumn: function () {
                        return that.columns;
                    },
                    setLayout: function () {
                        return that.setLayout.apply(that, arguments);
                    },
                    addGadget: function () {
                        return that.addGadget.apply(that, arguments);
                    },
                    removeGadget: function () {
                        return that.removeGadget.apply(that, arguments);
                    },
                    refresh: function () {
                        return that.refresh.apply(that, arguments);
                    },
                    init: function () {
                        return that.init.apply(that, arguments);
                    },
                    saveLayout: function () {
                        return that.saveLayout.apply(that, arguments);
                    },
                    getId: function () {
                        return that.options.id;
                    },
                    getName: function () {
                        return that.options.title;
                    },
                    onInit: function () {
                        return that.onInit.apply(that, arguments);
                    }
                };
            }

            return this.publicInterface;
        },



        init: function () {
            var that = this, canvasGadget;
            this.gadgets = [];
            this.options.gadgets = this.options.gadgets || [];


            function getCanvasGadgetRepresentation (gadgets) {
                var canvasGadget;
                 AJS.$.each(that.options.gadgets, function () {
                    if (AG.Gadget.isCanvasView(this.id)) {
                        canvasGadget = this;
                        return false;
                    }
                });
                return canvasGadget;
            }

            /**
             * Auto-adjust the number of characters to truncate in the tab label
             * to fit the capacity of the tab.
             *
             * @param label The jQuery object of the tab label in a "span".
             * @param capacity The width of the tab available for rendering a tab (pixel).
             */
            function fitTab(label, capacity) {
                var labelText = label.text();

                /*
                 * HtmlUnit doesn't seem to update the element width while executing this, which results in an infinite
                 * loop when running the integration tests against a page with tabs if we don't have a second condition
                 * that terminates the loop.  So, as a failsafe, don't let the label text go below three characters.
                 * (AG-882)
                 */
                while (label.width() >= capacity && labelText.length >= 3) {
                    labelText = labelText.slice(0, labelText.length - 1);
                    label.text(labelText + '...');
                }
            }

            function appendTab () {
                var labelSpan = AJS.$('<span />').text(that.options.title).attr("title", that.options.title),
                    labelStrong = AJS.$("<strong />").append(labelSpan),
                    capacity;

                that.tab = AJS.$("<li />");

                if (!that.options.active) {
                    that.tab.append(AJS.$("<a href='" + that.options.uri + "' />").append(labelStrong));
                } else {
                    that.tab.append(labelStrong);
                    that.tab.addClass("active");
                }

                that.tab.get(0).getLayoutInstance = function () {
                    return that.getPublicInstance();
                };

                that.tab.appendTo(AG.DashboardManager.getDashboard().tabContainer);

                capacity = AG.DashboardManager.getDashboard().tabContainer.innerWidth() -
                               parseInt(labelStrong.css('padding-left')) -
                               parseInt(labelStrong.css('padding-right'));
                fitTab(labelSpan, capacity);

                AJS.$("li:first",  AG.DashboardManager.getDashboard().tabContainer).addClass("first");

                if(that.isWritable() && that.options.active === false) {
                    AG.Sortable.addHotSpot(that.tab, function (gadget) {
                        that.addGadget(gadget);
                    });
                }
            }

            function appendColumns () {
                that.container = AJS.$("<div class='layout' />").appendTo(AG.DashboardManager.getDashboard().contents);
                that.columns = AJS.$("<ul />").addClass("column first")
                .add(AJS.$("<ul />").addClass("column second"))
                .add(AJS.$("<ul />").addClass("column third"))
                .appendTo(that.container);
            }

            function appendGadgets () {
                AJS.$.each(that.options.gadgets, function () {
                    that.addGadget(this);
                });
            }

            function setInitialized () {
                that.initialized = true;
                if (that.onInit.callbacks) {
                    AJS.$.each(that.onInit.callbacks, function () {
                        this();
                    });
                }
                that.refresh();
            }

            if (this.options.active !== false) {
                appendColumns();

                this.setLayout(this.options.layout, false);

                canvasGadget = getCanvasGadgetRepresentation(this.options.gadgets);

                if (canvasGadget) {
                    canvasGadget = this.addGadget(canvasGadget);
                    canvasGadget.setView("canvas");
                    canvasGadget.updatePosition();

                    AJS.$.aop.after({target: canvasGadget, method: "setView"}, function () {
                        canvasGadget.remove();
                        that.removeGadget(canvasGadget);
                        appendGadgets();
                        setInitialized();
                    });
                } else {
                    appendGadgets();
                    setInitialized();
                }
            }
        }
    };

    AG.LayoutManager = function (options) {

        // Using prototype as there could be many gadgets on the page. This is most memory efficient.
        var layoutManager = Object.create(LayoutManager);


        layoutManager.options = options;

        // define public interface
        return layoutManager.getPublicInstance();

    };


    /**
     * @property layouts
     * @type Array
     * @static
     */
    AG.LayoutManager.layouts = ["A", "AA", "BA", "AB", "AAA"];

    /**
     * @method getLayoutAttrName
     * @static
     * @param layout
     */
    AG.LayoutManager.getLayoutAttrName = function (layout) {
        return "layout-" + layout.toLowerCase();
    };

}());



;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/AG.Gadget.js' */
/**
 * Gadget implementation.
 *
 * @module dashboard
 * @class Gadget
 * @constructor
 * @namespace AG
 */

(function () {

    function FauxList(listContainer) {

        var that = this, ENTER_KEY = 13;

        this.container = AJS.$(listContainer);
        this.values = AJS.$("input.list", this.container).hide().val().split("|");
        this.originalValues = this.values.join("|").split("|"); // creating a separate array - ugly but it works.

        // Create fake form elements and add to container
        this.container.append("<input class=\"add-to-list text med js\" type=\"text\" value=\"\" />" + "<button class=\"submit-to-list js\">" + "Add" + "</button>");

        // Add list items to list individually
        this.container.children(".submit-to-list").click(function (e) {
            that.addToList();
            e.preventDefault();
        });

        AJS.$("input.add-to-list", this.container).keydown(function (e) {
            if (e.keyCode == ENTER_KEY) {
                that.addToList();
                e.preventDefault();
            }
        });

        AJS.$(".description", this.container).appendTo(this.container);

        this.create(this.values);
    }

    FauxList.prototype = {

        reset: function () {
            this.create(this.originalValues);
        },

        create: function (values) {

            var ul, listItem, that = this;

            // If the list is empty, skip all of this.
            if (values) {

                // Strip empty values
                AJS.$.each(values, function () {
                    if (this == "") {
                        values.splice(values.indexOf(this), 1);
                    }
                });

                // Create UL to hold visible list
                ul = AJS.$("<ul class=\"faux-list\"></ul>");

                // Create list for any list items
                // Else, remove if none
                if (values.length > 0) {
                    for (var i = 0, ii = values.length; i < ii; i++) {

                        // Make LI element with delete functionality
                        listItem = AJS.$("<li class=\"listvalue-" + i + "\"><span>" + values[i] + "</span><a class=\"remove\" href=\"#remove-from-list\" title=\"" + "Remove from list." + "\">x</a></li>");

                        // Remove list items from list individually
                        AJS.$("a", listItem).click(function (e) {

                            // Grab the value to be removed from the array
                            var removeValue = AJS.$(this).parent("li").attr("class").split("-")[1];

                            // Find the index of the value and remove it
                            values.splice(removeValue, 1);

                            if (values.length > 0) {
                                that.create(values);
                            } else {
                                AJS.$("input.list", this.container).val("");
                            }

                            // Remove LI from visible list
                            listItem.remove();
                            e.preventDefault();
                        });

                        // Add new list items to ul.faux-list
                        ul.append(listItem);
                    }

                    // If no values existed, add ul.faux-list before the old input
                    // Else, replace old .faux-list with new version
                    if (AJS.$("ul.faux-list", this.container).length == 0) {
                        AJS.$("input.list", this.container).before(ul);
                    } else {
                        AJS.$("ul.faux-list", this.container).replaceWith(ul);
                    }
                } else {
                    AJS.$("ul.faux-list", this.container).remove();
                }

                // Rewrite the old input value with current array
                AJS.$("input.list", this.container).val(values.join("|"));

                AG.DashboardManager.getLayout().refresh();

            }
        },

        addToList: function () {
            // Stripping pipes from our pipe-delimited input
            var newValue = AJS.$("input.add-to-list", this.container).val().replace(/\|+/g, '%7C');

            //Grab value from new input and add to array
            this.values.push(newValue);

            // Clear new input
            AJS.$("input.add-to-list", this.container).val("");

            // Remake the list
            this.create(this.values);
        }
    };

    var Gadget = {

        /**
         * Draws gadget, preference form and furniture
         *
         * @method draw
         */
        draw: function (json) {

            var that = this;

            function addRenderingData(args) {

                function generateMenuItems() {
                    var menu = [];

                    function isEditable() {
                        return !!(isWritable() && args.hasNonHiddenUserPrefs);
                    }

                    function isWritable() {
                        return args.layout.writable;
                    }

                    function generateColorList() {
                        var colorList = [];
                        AJS.$.each(AG.Gadget.COLORS, function (colorIndex) {
                            var color = AG.Gadget.getColorAttrName(this);
                            colorList.push({
                                styleClass: color, link: {
                                    href: "#", text: colorNames[colorIndex]
                                }
                            });
                        });
                        return {
                            styleClass: "item-link gadget-colors", items: colorList
                        };
                    }

                    if (isEditable()) {
                        menu.push({
                            styleClass: "dropdown-item", link: {
                                styleClass: "item-link edit",
                                href: "#gadget-" + args.id + "-edit",
                                text: "Edit"
                            }
                        });
                    }

                    menu.push({
                        styleClass: "dropdown-item", link: {
                            styleClass: "item-link " + (args.minimized ? "maximization" : "minimization"),
                            href: "#",
                            text: args.minimized ? "Expand" : "Minimise"
                        }
                    });

                    if (isWritable()) {
                        menu.push(generateColorList());
                        menu.push({
                            styleClass: "dropdown-item", link: {
                                styleClass: "item-link delete", href: "#", text: "Delete"
                            }
                        });
                    }

                    return menu;
                }

                return AJS.$.extend({
                    menu: {
                        trigger: {
                            text: "Gadget menu", href: "#"
                        }, list: {
                            items: generateMenuItems()
                        }
                    }
                }, args);
            }

            function createElement() {
                json.minimized = that.minimized;
                json.view = that.view;
                var renderingData = addRenderingData(json);
                that.$ = AJS.$(Gadgets.Templates.Dashboard.gadget(renderingData));
            }

            // setHeightFromCookie must be called before rendering the gadget
            function setHeightFromCookie() {
                if (json) {
                    var height = AG.Cookie.read("gadget-" + json.id + "-fh", null);
                    if (!isNaN(parseInt(height))) {
                        json = AJS.$.extend(json, {height: height});
                    }
                }
            }

            function setElementShortcuts() {
                that.$.layoutRep = AJS.$("<li class='gadget' id='rep-" + json.id + "' />").height(that.$.height());
                that.$.layoutRep.get(0).getGadgetInstance = that.$.get(0).getGadgetInstance = function () {
                    return that.getPublicInstance();
                };
            }

            function applyDropdownControls() {

                var ACTIVE_CLASS = "dropdown-active", ddParent = AJS.$("li.aui-dd-parent", that.$);

                ddParent.mousedown(function (e) {
                    e.stopPropagation();
                });

                that.$.dropdown = ddParent.dropDown("standard", {
                    selectionHandler: function (e) {
                        e.preventDefault();
                    }, item: "> li"
                })[0];

                that.$.dropdown.addCallback("show", function () {
                    that.$.addClass(ACTIVE_CLASS);
                    AG.DashboardManager.showShims();
                });

                that.$.dropdown.addCallback("hide", function () {
                    that.$.removeClass(ACTIVE_CLASS);
                    // if we are not dragging
                    AG.DashboardManager.hideShims();
                });

                that.$.hover(function () {}, function () {
                    if (that.$.dropdown.$.is(":visible")) {
                        that.$.dropdown.hide();
                    }
                });
            }

            function applyGadgetHoverControls() {

                var HOVER_CLASS = "gadget-hover";

                that.$.hover(function () {
                    AJS.$(".gadget-container", that.$).addClass(HOVER_CLASS);
                }, function () {
                    AJS.$(".gadget-container", that.$).removeClass(HOVER_CLASS);
                });
            }

            function applyColorControls() {
                AJS.$(".gadget-colors a", that.$).click(function (e) {
                    that.setColor(this.parentNode.className);
                    e.preventDefault();
                });
            }

            function applyMinimizeControls() {

                var menuElem = AJS.$("a.minimization, a.maximization", that.$), titleElem = AJS.$(".dashboard-item-title", that.$),

                        maxMinToggle = function (e) {

                            if (that.minimized) {
                                that.maximize();
                            } else {
                                that.minimize();
                            }

                            AJS.$(this).one(e.type, function (e) {
                                if (that.minimized) {
                                    that.maximize();
                                } else {
                                    that.minimize();
                                }
                                AJS.$(this).one(e.type, maxMinToggle);
                            });
                        };

                titleElem.one("dblclick", maxMinToggle);
                menuElem.one("click", maxMinToggle);

                /* AJS.$.browser is deprecated, for the preferred feature detection. However feature detection cannot detect safari. */
                if (AJS.$.browser.safari) {
                    /* stops double click from selecting title text */
                    titleElem.get(0).onselectstart = function () {
                        return false;
                    };
                }

            }

            function applyFocusControls() {

                var column;

                AJS.$(".dashboard-item-header", that.$).mousedown(function (e) {
                    // Don't make draggable in Canvas mode unless there are multiple Dashboards.
                    if (!that.$.hasClass("maximized") || AG.DashboardManager.getDashboard().hasClass("v-tabs")) {

                        if (!column) {
                            column = that.$.layoutRep.parent();
                        }

                        // hide dropdown if it is visible
                        that.$.dropdown.hide();

                        that.$.focusTimeout = setTimeout(function () {
                            delete that.$.focusTimeout;
                        }, 150);

                        // Our sortable control uses the layout rep to manage sorting. For this to work we modify the
                        // event and trigger it on the layout rep. This way it is as if the click occured on it.
                        // See AG.Sortable for wiring of layout rep to sortable control.
                        e.target = that.$.layoutRep[0];
                        that.$.layoutRep.trigger(e);
                    }

                });
                that.$.mouseup(function () {
                    if (that.$.focusTimeout) {
                        clearTimeout(that.$.focusTimeout);
                    } else if (that.$.layoutRep.is(":visible")) {
                        that.$.stop(true, true);
                    }
                });
            }

            function applyUserPrefControls() {

                var fauxLists = [], prefForm = AJS.$(".userpref-form", that.$), prefsChanged = false, savePrefForm = function (success) {
                    var formArray = prefForm.serializeArray(), submittedState = {};
                    AJS.$.each(formArray, function () {
                        submittedState[this.name] = this.value || '';
                    });

                    AJS.$(":checkbox:not(:checked)", prefForm).each(function () {
                        submittedState[this.name] = false;
                    });

                    AJS.$.ajax({
                        url: prefForm.attr("action"),
                        type: "POST",
                        contentType: "application/json",
                        data: JSON.stringify(submittedState),
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader("X-HTTP-Method-Override", "PUT");
                        },
                        dataType: "text",
                        success: success
                    });
                };

                if (that.isEditable()) {
                    // Creates a neater form element for adding multiple values
                    AJS.$(".list-container", that.$).each(function () {
                        fauxLists.push(new FauxList(this));
                    });

                    AJS.$(".edit", that.$).click(function (e) {
                        if (!prefForm.is(":visible")) {
                            if (that.minimized) {
                                that.maximize();
                            }
                            prefForm.show();
                            AJS.$(".field-group :input:first", prefForm).focus();
                            that.getLayoutManager().refresh();
                        } else {
                            prefForm.hide();
                            that.getLayoutManager().refresh();
                        }
                        e.preventDefault();
                    });

                    prefForm.submit(function (e) {
                        savePrefForm(function () {
                            window.location.reload();
                        });

                        e.preventDefault();
                    });

                    AJS.$(":reset", prefForm).click(function () {
                        AJS.$.each(fauxLists, function () {
                            this.reset();
                        });
                        prefForm.hide();
                        that.getLayoutManager().refresh();
                    });
                }

                /*
                 * Event handler for a customed event "setUserPref".  This event
                 * is triggered inside gadgets-dashboard.js -> setUserPref().
                 * It acts like a buffer for all the setPref() calls.
                 * The results are flushed to the server using ajax later.
                 * arguments e is something like [name1, value1, name2, value2]
                 */
                AJS.$("iframe.gadget-iframe", that.$).bind("setUserPref", function (e) {

                    // update the preference form with the given name value pairs
                    for (var i = 1, j = arguments.length; i < j; i += 2) {
                        if (pref_name = arguments[i]) {
                            var pref_value = arguments[i + 1];
                            var input = AJS.$(":input[name='up_" + pref_name + "']", prefForm);
                            // checkbox needs a default value of false
                            if (input.attr("type") == "checkbox") {
                                input.attr("checked", pref_value);
                            } else {
                                input.val(pref_value);
                            }
                        }
                    }

                    // flag for whether a flush is scheduled
                    if (!prefsChanged) {
                        setTimeout(function () {
                            savePrefForm(function () {});
                            prefsChanged = false;
                        }, 100);
                        prefsChanged = true;
                    }
                });

            }

            function applyDeleteControls() {
                AJS.$("a.delete", that.$).bind("click", function (e) {
                    that.destroy();
                    e.preventDefault();
                });
            }

            function applyViewToggleControls() {

                AJS.$("a.maximize", that.$).click(function (e) {
                    if (!AG.Gadget.isCanvasView(that.id)) {
                        that.getPublicInstance().setView("canvas");
                        e.preventDefault();
                    } else {
                        that.getPublicInstance().setView("default");
                        e.preventDefault();
                    }
                });
            }

            function applyErrorMessage() {
                AJS.$("iframe.gadget-iframe", that.$).load(function () {
                    AJS.$("#error-gadget-message", AJS.$(this).contents()).html(that.errorMessage);
                });
            }

            setHeightFromCookie();
            createElement();
            setElementShortcuts();
            applyDropdownControls();
            applyGadgetHoverControls();
            applyMinimizeControls();

            if (this.isMaximizable) {
                applyViewToggleControls();
            }

            if (!this.loaded) {
                applyErrorMessage();
            }

            if (this.getLayoutManager().isWritable()) {
                applyDeleteControls();
                applyFocusControls();
                applyColorControls();
                applyUserPrefControls();
            }
        },

        isEditable: function () {
            //dashboard items provide a 'configurable' property if they can be edited.
            if (this.configurable) {
                return this.getLayoutManager().isWritable();
            } else {
                return !!(this.getLayoutManager().isWritable() && this.hasNonHiddenUserPrefs);
            }
        },

        setLayoutManager: function (layoutManager) {
            if (layoutManager) {
                this.layoutManager = layoutManager;
            } else {
                this.layoutManager = AG.DashboardManager.getLayout();
            }
        },

        /**
         *
         * Provides access to gadget's Layout manager. When the gadget
         * needs to know how it's owner is. Such as in the method destroy
         * where we need to also remove it from the layout.
         *
         * @method getLayoutManager
         */
        getLayoutManager: function () {
            if (!this.layoutManager) {
                this.setLayoutManager();
            }
            return this.layoutManager;
        },

        /**
         * Sets gadget chrome colour. Gets chrome and applies associated class and
         * sends preference back to server to persist.
         *
         * @method setColor
         */
        setColor: function (color) {

            var that = this;

            that.$.removeClass(that.color).addClass(color);
            that.color = color;
            AJS.$.ajax({
                type: "post",
                url: that.colorUrl,
                contentType: "application/json",
                data: JSON.stringify({color: color}),
                beforeSend: function (xhr) {
                    xhr.setRequestHeader("X-HTTP-Method-Override", "PUT");
                },
                error: function (request) {
                    if (request.status == 403 || request.status == 401) {
                        alert("Sorry, you do not have permission to modify this dashboard. Your dashboard may be out of sync with the server: please reload the page.");
                    } else {
                        alert("Sorry, your changes to this dashboard could not be saved. Your dashboard may be out of sync with the server: please reload the page.");
                    }
                }
            });
        },

        updatePosition: function () {

            var gadgetCSSToUpdate, layoutCSSToUpdate, that = this;

            function isGadgetBeingDragged() {
                return that.$.hasClass("dragging");
            }

            function getCurrentGadgetCSS() {
                var LAYOUT_REP_OFFSET, dashboard = AG.DashboardManager.getDashboard().contents, DASHBOARD_OFFSET = dashboard.offset();

                if (!getCurrentGadgetCSS.cache) {
                    LAYOUT_REP_OFFSET = that.$.layoutRep.offset();
                    getCurrentGadgetCSS.cache = {
                        left: (LAYOUT_REP_OFFSET.left - DASHBOARD_OFFSET.left) / dashboard.width() * 100 + "%",
                        top: LAYOUT_REP_OFFSET.top - DASHBOARD_OFFSET.top,
                        width: that.$.layoutRep.width() / dashboard.width() * 100 + "%"
                    };
                }
                return getCurrentGadgetCSS.cache;
            }

            function getCurrentLayoutRepCSS() {
                if (!getCurrentLayoutRepCSS.cache) {
                    getCurrentLayoutRepCSS.cache = {
                        height: that.$.height()
                    };
                }
                return getCurrentLayoutRepCSS.cache;
            }

            function filterModifiedCSS(lastRecordedCSS, currentCSS) {
                if (lastRecordedCSS) {
                    AJS.$.each(lastRecordedCSS, function (property) {
                        if (this === currentCSS[property]) {
                            delete currentCSS[property];
                        }
                    });
                }
                return currentCSS;
            }

            if (!isGadgetBeingDragged()) {
                layoutCSSToUpdate = filterModifiedCSS(this.$.layoutRep.lastRecordedCSS, getCurrentLayoutRepCSS());
                this.$.layoutRep.css(layoutCSSToUpdate);
                this.$.layoutRep.lastRecordedCSS = layoutCSSToUpdate;

                gadgetCSSToUpdate = filterModifiedCSS(this.$.lastRecordedCSS, getCurrentGadgetCSS());
                this.$.css(gadgetCSSToUpdate);
                this.$.lastRecordedCSS = gadgetCSSToUpdate;

                if (this.$.hasClass("hidden")) {
                    this.$.removeClass("hidden");
                }
            }

        },

        /**
         * Minimises gadget. Hides everything but title bar.
         *
         * @method maximize
         */
        maximize: function () {
            var MIN_CLASS = "minimization",
                MAX_CLASS = "maximization",
                MIN_TEXT = "Minimise",
                menuElem = AJS.$("a.minimization, a.maximization", this.$);

            menuElem.removeClass(MAX_CLASS).addClass(MIN_CLASS).text(MIN_TEXT);

            // need to reset height to auto because sortable control sets an explicit pixel height
            this.$.css({height: "auto"});
            AJS.$(".dashboard-item-content", this.$).removeClass(MIN_CLASS);
            // updates positioning of gadgets & their layout references
            this.getLayoutManager().refresh();

            /* erase cookie */
            AG.Cookie.erase(this.COOKIE_MINIMIZE);

            if (this.minimized) {
                this.moduleAPI.trigger("expand");
            }
            this.minimized = false;
        },

        minimize: function () {
            var MIN_CLASS = "minimization",
                MAX_CLASS = "maximization",
                MAX_TEXT = "Expand",
                menuElem = AJS.$("a.minimization, a.maximization", this.$);

            menuElem.removeClass(MIN_CLASS).addClass(MAX_CLASS).text(MAX_TEXT);

            // need to reset height to auto because sortable control sets an explicit pixel height
            this.$.css({height: "auto"});
            AJS.$(".dashboard-item-content", this.$).addClass(MIN_CLASS);
            this.getLayoutManager().refresh();
            AG.Cookie.save(this.COOKIE_MINIMIZE, "true");
            this.minimized = true;
            this.moduleAPI.trigger("minimize");
        },

        remove: function () {
            var that = this;
            that.$.layoutRep.remove();
            that.$.remove();

            this.moduleAPI.trigger("remove");
            that.getLayoutManager().removeGadget(that.getPublicInstance());
            that.getLayoutManager().refresh();
            // remove from memory
            AJS.$.each(this, function (name, property) {
                property = null;
            });
            AG.Cookie.erase("gadget-" + that.id + "-fh");
        },

        /**
         * Moves gadget from the dashboard it's currently on to a new dashboard specified
         * by the target resource URL
         */
        move: function (targetResourceUrl) {
            this.remove();

            AJS.$(AJS.$.ajax({
                type: "post",
                data: {
                    id: this.id,
                    title: this.title,
                    titleUrl: this.titleUrl,
                    gadgetSpecUrl: this.gadgetSpecUrl,
                    height: this.$.height(),
                    width: this.$.width(),
                    color: this.color,
                    isMaximizable: this.isMaximizable,
                    userPrefs: this.userPrefs,
                    renderedGadgetUrl: this.renderedGadgetUrl,
                    colorUrl: this.colorUrl,
                    gadgetUrl: this.gadgetUrl,
                    hasNonHiddenUserPrefs: this.hasNonHiddenUserPrefs,
                    column: this.column,
                    loaded: this.loaded
                },
                contentType: "application/json",
                url: targetResourceUrl + "/gadget/" + this.id,
                beforeSend: function (xhr) {
                    xhr.setRequestHeader("X-HTTP-Method-Override", "PUT");
                }
            })).throbber({target: AJS.$("#dash-throbber")});
        },

        /**
         * Removes gadget from dashboard and deletes object references
         *
         * @method destroy
         */
        destroy: function () {

            var that = this;

            if (confirm(AJS.format("Are you sure you want to permanently remove the {0} gadget?", that.title))) {

                AJS.$("#dash-throbber").addClass("loading");

                AJS.$.ajax({
                    type: "DELETE", url: this.gadgetUrl, beforeSend: function (xhr) {
                        xhr.setRequestHeader("X-HTTP-Method-Override", "DELETE");
                    }, complete: function () {
                        AJS.$("#dash-throbber").removeClass("loading");
                    }, success: function () {
                        that.$.fadeOut(function () {
                            that.remove();
                            if (that.view === "canvas") {
                                that.getLayoutManager().restoreDefaultView();
                            }
                        });
                    }, error: function (request) {
                        if (request.status == 403 || request.status == 401) {
                            alert("Sorry, you do not have permission to modify this dashboard. Your dashboard may be out of sync with the server: please reload the page.");
                        } else {
                            alert("Sorry, your changes to this dashboard could not be saved. Your dashboard may be out of sync with the server: please reload the page.");
                        }
                    }
                });
            }
        },

        /**
         * Sets the layout of the gadget to either canvas or dashboard. Does
         * so by delegating layout actions to LayoutManager.
         *
         * @method setView
         * @param {String} view - Accepts either "canvas" or "dashboard"
         */
        setView: function (view) {
            var MAXIMIZED_CLASS = "maximized", uri = {}, that = this, anchor = this.title.replace(/\s/g, "-") + "/" + this.id, layoutManager = this.getLayoutManager(), rpctoken;

            function toDefaultViewHandler() {
                that.getPublicInstance().setView("default");
            }

            if (this.view === view) {
                return;
            }

            if (view === "canvas" || view === "default") {

                // use rendered url to get latest user prefs and a fresh security token
                if (this.gadgetUrl) {
                    AJS.$.ajax({
                        async: false, type: "GET", url: this.gadgetUrl, dataType: "json", success: function (rep) {
                            // create the rpctoken that will be used in rpc calls
                            rpctoken = Math.round(Math.random() * 10000000);
                            uri = AJS.parseUri(rep.renderedGadgetUrl + "#rpctoken=" + rpctoken);
                        }
                    });
                }

                // setup the iframe to send/receive rpc calls
                gadgets.rpc.setAuthToken(AJS.$("iframe.gadget-iframe", this.$).attr("id"), rpctoken);

                if (view === "canvas") {

                    AJS.$(".operations li", AG.DashboardManager.getDashboard()).toggleClass("hidden");

                    AJS.$.extend(uri.queryKey, {view: "canvas"});
                    AJS.$("iframe.gadget-iframe", this.$).attr("src", uri.toString());

                    layoutManager.getContainer().addClass(MAXIMIZED_CLASS);
                    AJS.$(".gadget-container", this.$).addClass(MAXIMIZED_CLASS);
                    this.$.addClass(MAXIMIZED_CLASS);
                    AJS.$(".aui-icon", this.$).attr("title", "Restore");
                    this.$.layoutRep.addClass(MAXIMIZED_CLASS);
                    this.$.layoutRep.parent().addClass(MAXIMIZED_CLASS);

                    // Not really sure about this, would prefer to add a class to the body tag. Problem is I can't as I
                    // do not want every gadget to be hidden, in the case of multiple tabs this would cause problems.
                    AJS.$.each(this.getLayoutManager().getGadgets(), function () {
                        if (that.getPublicInstance() !== this) {
                            this.getElement().hide();
                        }
                    });

                    AJS.$.extend(uri.queryKey, {view: "canvas"});
                    AJS.$("iframe.gadget-iframe", this.$).attr("src", uri.toString());

                    this.maximize();
                    // add bookmarking capabilities
                    window.location.href = window.location.href.replace(/#.*/, "") + "#" + anchor;
                    AJS.$(".minimize", AG.DashboardManager.getDashboard()).click(toDefaultViewHandler);
                    this.view = "canvas";

                    this.moduleAPI.trigger("maximize");
                } else {

                    AJS.$(".gadget-container", this.$).removeClass(MAXIMIZED_CLASS);
                    this.$.removeClass(MAXIMIZED_CLASS);
                    AJS.$(".aui-icon", this.$).attr("title", "Maximise");
                    this.$.layoutRep.removeClass(MAXIMIZED_CLASS);
                    this.$.layoutRep.parent().removeClass(MAXIMIZED_CLASS);

                    this.getLayoutManager().restoreDefaultView();

                    AJS.$.extend(uri.queryKey, {view: "default"});
                    AJS.$("iframe.gadget-iframe", this.$).attr("src", uri.toString());
                    this.getLayoutManager().refresh();
                    window.location.href = window.location.href.replace(anchor, "");
                    AJS.$("a.minimize", AG.DashboardManager.getDashboard()).unbind("click", toDefaultViewHandler);
                    this.view = "default";

                    this.moduleAPI.trigger("restore");
                }

            } else if (AJS.debug) {
                console.warn("AG.Gadget.setView: Ignored! not a valid view. Was supplied '" + view + "' but expected " + "either 'default' or 'canvas'");
            }
        },

        /**
         * Displays edit preferences form
         *
         * @method editPrefs
         */
        editPrefs: function () {},

        getPublicInstance: function () {
            var gadget = this;
            var itemContent = gadget.$.find(".gadget-inline");
            var freezeHeight = function() {
                itemContent.css('height', itemContent.height() + 'px');
            };

            if (!this.publicInterface) {
                this.publicInterface = {
                    updatePosition: function () {
                        return gadget.updatePosition.apply(gadget, arguments);
                    },
                    getLayoutManager: function () {
                        return gadget.getLayoutManager.apply(gadget, arguments);
                    },
                    setLayoutManager: function () {
                        return gadget.setLayoutManager.apply(gadget, arguments);
                    },
                    getElement: function () {
                        return gadget.$;
                    },
                    move: function (targetUrl) {
                        return gadget.move(targetUrl);
                    },
                    remove: function () {
                        return gadget.remove.apply(gadget, arguments);
                    },
                    getId: function () {
                        return gadget.id;
                    },
                    showShim: function () {
                        return gadget.showShim.apply(gadget, arguments);
                    },
                    hideShim: function () {
                        return gadget.hideShim.apply(gadget, arguments);
                    },
                    minimize: function () {
                        return gadget.minimize.apply(gadget, arguments);
                    },
                    maximize: function () {
                        return gadget.minimize.apply(gadget, arguments);
                    },
                    getSecurityToken: function () {
                        return gadget.securityToken;
                    },
                    setSecurityToken: function (securityToken) {
                        gadget.securityToken = securityToken;
                    },
                    onDragStart: function () {
                        gadget.moduleAPI.trigger("dragStart");
                    },
                    onDragStop: function () {
                        gadget.moduleAPI.trigger("dragStop");
                    },
                    onAfterRender: function () {
                        gadget.moduleAPI.trigger("afterRender");
                    },
                    freezeHeight: freezeHeight,
                    resize: function() {
                        itemContent.css('height', '');
                        gadget.moduleAPI.trigger("force-layout-refresh");
                        freezeHeight();
                    }
                };

                if (this.isMaximizable) {
                    this.publicInterface.setView = function () {
                        return gadget.setView.apply(gadget, arguments);
                    };
                }
            }

            return this.publicInterface;
        },

        init: function (options) {
            this.COOKIE_MINIMIZE = options.id + ":minimized";
            this.minimized = AG.Cookie.read(this.COOKIE_MINIMIZE) === "true";
            this.title = options.title;
            this.color = options.color;
            this.colorUrl = options.colorUrl;
            this.gadgetUrl = options.gadgetUrl;
            this.id = options.id;
            this.hasNonHiddenUserPrefs = options.hasNonHiddenUserPrefs;
            this.isMaximizable = options.isMaximizable;
            this.titleUrl = options.titleUrl;
            this.gadgetSpecUrl = options.gadgetSpecUrl;
            this.userPrefs = options.userPrefs;
            this.renderedGadgetUrl = options.renderedGadgetUrl;
            this.column = options.column;
            this.loaded = options.loaded;
            this.errorMessage = options.errorMessage;
            this.inlineHtml = options.inlineHtml;
            this.configurable = options.configurable;
            this.amdModule = options.amdModule;
            this.webResourceKey = options.webResourceKey;
            this.context = options.context;
            this.securityToken = AJS.parseUri(options.renderedGadgetUrl).queryKey["st"];
            this.draw(options);

            this.moduleAPI = new AG.InlineGadgetAPI(this);

            if (this.amdModule) {
                if (this.webResourceKey) {
                    WRM.require(['wr!' + this.webResourceKey], function() {
                        this.initializeAmdModule(options);
                    }.bind(this));
                }
                else {
                    this.initializeAmdModule(options);
                }
            }
        },
        initializeAmdModule: function initializeAmdModule(options) {
            var gadget = this;
            var gadgetElement = this.$.find("#gadget-" + this.id);
            var Module = AG.Util.safeInit(function () {
                return require(gadget.amdModule);
            }, gadgetElement, gadget, "Can not import amd Module " + this.amdModule);

            if (Module) {
                var userPreferences = AG.Util.extractUserPreferences(options.userPrefs.fields);
                var moduleApi = this.moduleAPI;
                var moduleInstance = AG.Util.safeInit(function () {
                    return new Module(moduleApi);
                }, gadgetElement, gadget, "Error initializing");

                var safeRender = function (renderingFunction) {
                    AG.Util.safeRender(renderingFunction, gadgetElement, gadget);
                };

                if (this.isEditable()) {
                    var dropdown = this.getPublicInstance().getElement().dropdown;
                    var configureLink = AJS.$('<li class="dropdown-item configure"><a class="item-link no_target" href="#">' + "Edit" + '</a></li>');
                    configureLink.on("click", function () {
                        safeRender(function () {
                            moduleInstance.renderEdit(gadgetElement, userPreferences);
                            gadget.moduleAPI.trigger("afterRender");
                        });
                    });
                    configureLink.appendTo(dropdown.$);
                    dropdown.reset();
                }

                if (this.isEditable() && !userPreferences.isConfigured) {
                    safeRender(function () {
                        moduleInstance.renderEdit(gadgetElement, userPreferences);
                    });
                } else {
                    safeRender(function () {
                        moduleInstance.render(gadgetElement, userPreferences);
                    });
                }
                //afterRender is triggered by the layout manager here after the gadget is inserted
                //into the DOM, so no need to call it explicitly.

                this.moduleAPI.on("preferencesSaved", function (prefs) {
                    userPreferences = AG.Util.extractUserPreferences(prefs);
                    safeRender(function () {
                        moduleInstance.render(gadgetElement, userPreferences);
                        gadget.moduleAPI.trigger("afterRender");
                    });
                });
                this.moduleAPI.on("close-edit", function () {
                    safeRender(function () {
                        moduleInstance.render(gadgetElement, userPreferences);
                        gadget.moduleAPI.trigger("afterRender");
                    });
                });
                this.moduleAPI.on("force-layout-refresh", _.bind(function () {
                    this.getLayoutManager().refresh();
                }, this));
            }
        }
    };

    AG.Gadget = function (options) {
        // Using prototype as there could be many gadgets on the page. This is most memory efficient.
        var gadget = AJS.clone(Gadget);

        gadget.init(options);

        return gadget.getPublicInstance();
    };

    AG.Gadget.COLORS = [1, 2, 3, 4, 5, 6, 7, 8];

    AG.Gadget.getColorAttrName = function (color) {
        return "color" + color;
    };

    var colorNames = [
        "Color 1",
        "Color 2",
        "Color 3",
        "Color 4",
        "Color 5",
        "Color 6",
        "Color 7",
        "Color 8"
    ];

    AG.Gadget.isCanvasView = function (gadgetId) {
        var uri = AJS.parseUri(window.location.href);
        return new RegExp(gadgetId).test(uri.anchor);
    };

    AG.Gadget.getNullGadgetRepresentation = function (errorGadget) {
        return AJS.$.extend(errorGadget, {
            title: "Gadget Error",
            renderedGadgetUrl: AG.param.get("errorGadgetUrl"),
            color: errorGadget.color || "color7"
        });
    };

    AG.Util = {
        extractUserPreferences: function (userPreferences) {
            var preferences = {};
            _.each(userPreferences, function (preference) {
                var parsedValue;
                if (preference.value === "true" || preference.value === "false") {
                    parsedValue = preference.value === "true";
                } else {
                    parsedValue = preference.value;
                }
                preferences[preference.name] = parsedValue;
            });
            return preferences;
        },
        safeRender: function (renderFunction, gadgetElement, gadget) {
            this.safeInvokeFunction(renderFunction, gadgetElement, gadget, "Unknown error occurred rendering this gadget.", "Error rendering")
        },
        safeInit: function(initFunction, gadgetElement, gadget, errorMsg) {
            return this.safeInvokeFunction(initFunction, gadgetElement, gadget, "Unknown error occurred initializing this gadget.", errorMsg)
        },
        safeInvokeFunction: function (functionToInvoke, gadgetElement, gadget, userErrorMsg, consoleErrorMsg) {
            try {
                return functionToInvoke();
            } catch (err) {
                var errorContainer = AJS.$('<div class="item-error"/>').append(aui.message.error({
                    content: "<p>" + userErrorMsg + "</p>"
                }));
                AJS.$(gadgetElement).append(errorContainer);
                console.error(consoleErrorMsg + " gadget with id '" + gadget.id + "': " + err.message, err);
                gadget.moduleAPI.hideLoadingBar();
            }
        }
    };

})();
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/AG.Param.js' */
/**
 * <p>Singleton that provides simple get and set mechanism for param strings. Has support for
 * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/text/MessageFormat.html">Java's MessageFormat</a> syle.</p>
 *
 * <p><strong>Note:</strong> this is a replacement for AJS.params because it is leaner and faster then getting strings
 * form html document. It should <strong>ONLY</strong> be used for <strong>SAFE STRINGS</strong></p>
 *
 * @module dashboard
 * @class param
 * @static
 * @namespace AG
 */

/*global console, AJS*/
/*jslint bitwise: true, eqeqeq: true, immed: true, newcap: true, nomen: true, onevar: true, plusplus: true, regexp: true, undef: true, white: true, indent: 4 */

AG = AG || {};

if (!console.warn) {
    console.warn = function () {};
}

AG.param = (function () {

    /**
     * Map containing param strings
     * @property strs
     * @private
     * @type Object
     */
    var strs = {};

    return {

        /**
         * Gets param string of provided key, and if necessary substitutes params using Javas MessageFormat
         *
         * <dl>
         *  <dt>Usage</dt>
         *  <dd>
         *      <pre>AG.param.get ("dashboard.add.message", "simple", "test");</pre>
         *  </dd>
         * </dl>
         *
         * @method get
         * @param {String} key of param string
         * @param {String} arg replacement value for token 0, with subsequent arguments being 1, etc.
         * @return {String} the param string with tokens replaced with supplied arguments
         */
        get: function (key) {
            var args = arguments;
            if (strs[key] !== undefined) {
                if (arguments.length > 1) {
                    args[0] = strs[key];
                    return AJS.format.apply(this, args);
                } else {
                    return strs[key];
                }
            }

            else {
                if(AJS.debug) {
                    console.warn("param.get: Key '" + key + "' does not exist.");
                }
                return null;
            }
        },

        /**
         * Sets param strings in bulk or individually
         *
         * <dl>
         *  <dt>Usage</dt>
         *
         * <dd>
         *  <pre>
         *   // bulk
         *   AG.param.set ([
         *      {
         *          key: "help.question",
         *          str: "I need help with my dashboard jim"
         *      },
         *      {
         *          key: "help.response",
         *          str: "No worries, {0}
         *      }
         *   ]);
         * </pre>
         * </dd>
         *
         * <dd>
         * <pre>
         *   // individual
         *   AG.param.set({
         *      key: "help.question",
         *      str: "I need help with my dashboard Jim"
         *   });
         * </pre>
         * </dd>
         * </dl>
         *
         *
         * @method set
         * @param {Object, Array} param An object with keys <em>key</em> & <em>str</em> and their associated values,
         * or an array of those objects.
         */
        set: function (key, str) {
            var setParam = function () {
                var k = arguments[0];
                var v = arguments[1];
                if (typeof k === "string") {
                    strs[k] = v;
                }
                else if(AJS.debug) {
                    console.warn("param.set: Ignored param.set, key may be undefined. " +
                            "Printing value...");
                    console.log(k);
                }
            };
            if (arguments.length === 1 && typeof arguments[0] === "object") {
                AJS.$.each(arguments[0], function (key, str) {
                    setParam(key, str);
                });
            } else if (arguments.length === 2) {
                setParam(arguments[0], arguments[1]);
            }
            else if(AJS.debug) {
                console.warn("param.set: Expected arguments to be of length 1 or 2, however recieved a length of " + 
                             arguments.length + ". Printing value...");
                console.log(arguments);
            }
        },

        clear: function () {
            if(AJS.debug) {
              strs = {};
            }
        }
    };

}());
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/AG.Cookie.js' */

// A conglomerate cookie, so we don't run out.

(function () {

    // Cookie handling functions

    var COOKIE_NAME = "AG.congolmerate.cookie";


    function getValueFromCongolmerate(name, cookieValue) {
        // a null cookieValue is just the first time through so create it
        if(cookieValue == null) {
            cookieValue = "";
        }
        var eq = name + "=";
        var cookieParts = cookieValue.split('|');
        for(var i = 0; i < cookieParts.length; i++) {
            var cp = cookieParts[i];
            while (cp.charAt(0)==' ') {
                cp = cp.substring(1,cp.length);
            }
            // rebuild the value string exluding the named portion passed in
            if (cp.indexOf(name) == 0) {
                return cp.substring(eq.length, cp.length);
            }
        }
        return null;
    }

    //either append or replace the value in the cookie string
    function addOrAppendToValue(name, value, cookieValue)
    {
        var newCookieValue = "";
        // a null cookieValue is just the first time through so create it
        if(cookieValue == null) {
            cookieValue = "";
        }

        var cookieParts = cookieValue.split('|');
        for(var i = 0; i < cookieParts.length; i++) {
            var cp = cookieParts[i];

            // ignore any empty tokens
            if(cp != "") {
                while (cp.charAt(0)==' ') {
                    cp = cp.substring(1,cp.length);
                }
                // rebuild the value string exluding the named portion passed in
                if (cp.indexOf(name) != 0) {
                    newCookieValue += cp + "|";
                }
            }
        }

        // always append the value passed in if it is not null or empty
        if(value != null && value != '') {
            var pair = name + "=" + value;
            if((newCookieValue.length + pair.length) < 4020) {
                newCookieValue += pair;
            }
        }
        return newCookieValue;
    }

    function getCookieValue(name) {
        var
        eq = name + "=",
        ca = document.cookie.split(';');

        for(var i=0;i<ca.length;i++) {
            var c = ca[i];
            while (c.charAt(0)==' ') {
                c = c.substring(1,c.length);
            }
            if (c.indexOf(eq) == 0) {
                return c.substring(eq.length,c.length);
            }
        }

        return null;
    }

    function saveCookie(name, value, days) {
      var ex;
      if (days) {
        var d = new Date();
        d.setTime(d.getTime()+(days*24*60*60*1000));
        ex = "; expires="+d.toGMTString();
      } else {
        ex = "";
      }
      document.cookie = name + "=" + value + ex + ";path=/";
    }

    AG.Cookie = {
        save : function (name, value) {
            
            var cookieValue;

            if (window.localStorage) {
                cookieValue = localStorage.getItem(COOKIE_NAME);
            } else {
                cookieValue = getCookieValue(COOKIE_NAME);
            }

            cookieValue = addOrAppendToValue(name, value, cookieValue);

            if (window.localStorage) {
                localStorage.setItem(COOKIE_NAME, cookieValue);
            } else {
                saveCookie(COOKIE_NAME, cookieValue, 365);
            }
        },

        read : function(name, defaultValue) {
            var cookieValue,
                value;

            if (window.localStorage) {
                cookieValue = localStorage.getItem(COOKIE_NAME);
            } else {
                cookieValue = getCookieValue(COOKIE_NAME);
            }

            value = getValueFromCongolmerate(name, cookieValue);

            if(value != null) {
                return value;
            }
            
            return defaultValue;
        },
        erase: function (name) {
            this.save(name, "");
        }
    };
    
})();

;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/AG.Sortable.js' */
AG.Sortable = function () {

    var
    sortableControl,
    dragGadget,
    hotspots = [],

    options = {
        cursor: "move",
        // The actual trigger from sorting is done through the absolute positioned gadget.
        // The gadget just triggers the click event onto this element.
        // See applyFocusControls in AG.Gadget to see how this happens.
        items: "li.gadget",
        tolerance: "pointer",
        placeholder: "placeholder",
        forcePointerForContainers: true,
        scroll: true,
        // not supporting in safari because it does not work in safari 3.
        // I also cannot find a reliable way to check for version.
        revert: AJS.$.browser.safari ? false : 250,
        scrollSensitivity: 300,
        scrollSpeed: 16,
        zIndex: 10,
        helper: function (event, item) {
            return item.get(0).getGadgetInstance().getElement();
        },
        change: function () {
            AG.DashboardManager.getLayout().refresh();
        },
        start: function (event, obj) {

            dragGadget = obj.item.get(0).getGadgetInstance();

            function preventTextSelection () {
                if (typeof document.onselectstart !== "undefined") {
                    document.onselectstart = function () {
                        return false;
                    };
                }
            }

            function preventHelperRemovalOnDrop () {
                obj.item.removeValidator = AJS.$.aop.around({target: AJS.$, method: "remove"}, function (invocation) {
                   if (obj.helper !== this) {
                       invocation.proceed();
                   }
                });
            }

            function setPlaceholder () {
                 obj.placeholder
                    .height(obj.helper.outerHeight() - 2)
                    .html("<p>" + "Drag your gadget here." + "</p>");
            }

            obj.helper.addClass("dragging");

            preventTextSelection();
            preventHelperRemovalOnDrop();
            setPlaceholder();

            AG.DashboardManager.getLayout().refresh();
            AG.DashboardManager.getDashboard().addClass("dragging");
            AG.DashboardManager.showShims();
            AG.DashboardManager.markReadOnlyLayouts();

            dragGadget.onDragStart();
        },
        stop: function (event, obj) {

            var gadgetElement = dragGadget.getElement();

            function enableTextSelection () {
                if (typeof document.onselectstart !== "undefined") {
                    document.onselectstart = null;
                }
            }

            gadgetElement.layoutRep.css({display: ""});
            gadgetElement.css({height: "auto"}).removeClass("dragging");

            if (!dragGadget.hasBeenDropped) {
                AG.DashboardManager.getLayout().saveLayout();
            } else {
                sortableControl.sortable( 'option' , "revert" , 250);
            }

            enableTextSelection();

            //Revert the jQuery remove function back to the default functionality
            obj.item.removeValidator[0].unweave();

            AG.DashboardManager.getDashboard().removeClass("dragging");
            AG.DashboardManager.hideShims();
            AG.DashboardManager.getLayout().refresh();
            AG.DashboardManager.unmarkReadOnlyLayouts();

            dragGadget.onDragStop();
        }
    };

    return {
        serialize: function () {
            var params = {};
            AJS.$.each(this.columns.filter(":visible"), function (i) {
                params[i] = [];
                AJS.$.each(AJS.$(this).sortable("toArray"), function () {
                    params[i].push(AJS.$("#" + this).get(0).getGadgetInstance().getId());
                });
            });
            return params;
        },
        addHotSpot: function (elem, callback) {
            var offset = elem.offset(), dashboardOffset = AG.DashboardManager.getDashboard().offset();
            hotspots.push(
                AJS.$("<div class='hotspot-shim hidden' />")
                    .hover(function() {
                        dragGadget.getElement().css({opacity: 0.5});
                        elem.addClass("hover");
                    }, function () {
                        dragGadget.getElement().css({opacity: ""});
                        elem.removeClass("hover");
                    })
                    .mouseup(function () {
                        sortableControl.sortable( 'option' , "revert" , false );
                        dragGadget.hasBeenDropped = true;
                        callback(dragGadget);
                    })
                    .css({
                        height: elem.outerHeight(),
                        width: elem.outerWidth(),
                        left: offset.left - dashboardOffset.left,
                        top: offset.top - dashboardOffset.top
                    })
                    .appendTo(AG.DashboardManager.getDashboard())
            );
        },
        update: function () {
            AG.Sortable.init();
        },
        init: function () {
            if (sortableControl) {
                sortableControl.sortable("destroy");
            }
            this.columns = AJS.$(".draggable .column.sortable");
            if (this.columns.length > 0) {
                sortableControl = this.columns.sortable(AJS.$.extend(options, {
                    connectWith: this.columns
                }));
            }
        }
    };
}();

;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/api/AG.InlineGadgetAPI.js' */
;(function() {

    var API = function(gadget) {
        this.gadget = gadget;
        this.publicInstace = gadget.getPublicInstance && gadget.getPublicInstance(); // API can be created with gadgets that don't provide public instance (e.g. by other plugins like Wallboard)
    };

    var resize = function(API) {
        if (API.publicInstace) {
            API.publicInstace.resize();
        }
    };

    _.extend(API.prototype, Backbone.Events, {

        /**
         * @event expand
         */

        /**
         * @event restore
         */

        /**
         * @event minimize
         */

        /**
         * @event maximize
         */

        /**
         * @event remove
         */

        /**
         * @event dragStart
         */

        /**
         * @event dragStop
         */

        /**
         * @event afterRender
         */

        /**
         * Check if a dashboard item is configurable and if the current user has permission to edit this
         * dashboard item's configuration.
         * @returns {boolean} true if the current user can edit the gaget
         */
        isEditable: function() {
            return this.gadget.isEditable();
        },

        _preparePreferencesToBeSaved: function(preferences) {
            var userPreferences = {};

            userPreferences["up_isConfigured"] = true;
            _.each(preferences, function(value, name) {
                userPreferences["up_"+name] = String(value);
            });

            return userPreferences;
        },

        /**
         * Helper to extract the correct value to be persisted for a refresh field rendered with .refreshInterval
         * @param {string} [fieldName=refresh] - Refresh field name, defaults to "refresh"
         * @returns {string} value that should be persisted as preference
         */
        getRefreshFieldValue: function(fieldName) {
            fieldName = fieldName || 'refresh';

            var input = this.gadget.$.find('input[name=' + fieldName + ']');
            return input.is(':checked') ? input.val() : 'false';
        },

        /**
         * Tries to save the passed preferences on the server for this dashboard item.
         * If the user doesn't have permission to edit this dashboard item, no action will be performed.
         *
         * @fires AG.InlineGadgetAPI#preferencesSaved
         * @fires AG.InlineGadgetAPI#error:preferencesSaved
         * @param {Object} preferences the new preferences object to save for this dashboard item
         */
        savePreferences: function(preferences) {
            if(!this.isEditable()) {
                this.trigger("error:preferencesSaved");
                return;
            }
            return AJS.$.ajax({
                url: this.gadget.userPrefs.action,
                type: "PUT",
                contentType: "application/json",
                data: JSON.stringify(this._preparePreferencesToBeSaved(preferences))
            })
                .done(_.bind(function() {
                    AJS.$.ajax({
                        url: this.gadget.userPrefs.action,
                        type: "GET",
                        dataType: "json"
                    })
                        .done(_.bind(function(results) {
                            this.trigger("preferencesSaved", results.fields);
                        }, this))
                        .fail(_.bind(function(){
                            this.trigger("error:preferencesSaved");
                        }, this));
                }, this))
                .fail(_.bind(function(){
                    this.trigger("error:preferencesSaved");
                }, this));
        },

        setTitle: function(title) {
            if (!this.gadget.$) {
                return; // The gadget has not been rendered yet.
            }
            this.gadget.$.find('.dashboard-item-title').text(title);
        },

        initRefresh: function(preferences, cb) {
            if(this.gadget.refreshIntervalId) {
                clearInterval(this.gadget.refreshIntervalId);
            }
            if(!isNaN(parseInt(preferences.refresh))) {
                var refreshIntervalMillis = parseInt(preferences.refresh) * 60000;
                this.gadget.refreshIntervalId = setInterval(cb, refreshIntervalMillis);
            }
        },

        showLoadingBar: function() {
            if (!this.gadget.$) {
                return; // The gadget has not been rendered yet.
            }

            var self = this;
            if (!this.gadget.showLoadingBarTimeoutId) {
                this.gadget.showLoadingBarTimeoutId = setTimeout(function () {
                    var $gadgetContainer = self.gadget.$.find('#gadget-' + self.gadget.id);
                    var cls = $gadgetContainer.width() < 250 ? 'loading-small' : 'loading';
                    self.$loadingBar = AJS.$('<div class="' + cls + '"></div>');
                    self.$loadingBar.height(Math.max(40, $gadgetContainer.height()));
                    $gadgetContainer.after(self.$loadingBar);
                    $gadgetContainer.addClass('hidden');
                    self.forceLayoutRefresh();
                }, 1000);
            }
        },

        hideLoadingBar: function () {
            //clear any loading bars waiting to show;
            if (this.gadget.showLoadingBarTimeoutId) {
                clearTimeout(this.gadget.showLoadingBarTimeoutId);
                delete this.gadget.showLoadingBarTimeoutId;
            }
            if (!this.$loadingBar) {
                return; // 'showLoadingBar' has not been called
            }
            if (!this.gadget.$) {
                return; // The gadget has not been rendered yet.
            }

            this.$loadingBar.detach();
            this.$loadingBar = null;
            this.gadget.$.find('#gadget-' + this.gadget.id).removeClass('hidden');
            this.forceLayoutRefresh();
        },

        getContext: function() {
          return this.gadget.context;
        },

        closeEdit: function() {
            this.trigger("close-edit");
        },

        /**
         * This method is deprecated. You should have no reason to refresh the layout.
         * Use API.resize() to resize your item if needed.
         */
        forceLayoutRefresh: function() {
            console.warn('forceLayoutRefresh() is deprecated. Use resize() instead.');
            resize(this); // in the former API there was no scroll on overflow, so layout refresh was all that was needed to make things work, but now this is equivalent to resize()
        },

        getGadgetId: function() {
            return this.gadget.id;
        },

        /**
         * When you add some content dynamically to your dashboard item and it causes the height to increase a scroll will appear.
         * Call this method to resize the content automatically and make the scroll go away.
         */
        resize: function() {
            resize(this);
        }
    });

    AG = window.AG || {};
    AG.InlineGadgetAPI = API;
})();
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/dashboard-directory-constants.js' */
AJS.namespace('JIRA.Dashboard.Directory.Constants');

JIRA.Dashboard.Directory.Constants.getDefaultCategoryName = function() {
    return "All";
};
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/dashboard-service.js' */
AJS.namespace("JIRA.Dashboard.DashboardService");

JIRA.Dashboard.DashboardService = {
    addItem: function(directoryItem, callback) {
        if (AG.DashboardManager.getLayout().getGadgets().length >= AG.param.get("maxGadgets")) {
            callback.onError("Sorry, you have exceeded the maximum number of gadgets supported by your dashboard.  You must remove some gadgets before proceeding.");
            return;
        }

        var dashboardResourceUrl = AG.param.get("dashboardResourceUrl");
        var localeLang = AJS.$('.locale-lang','#i18n-settings').val();
        var localeCountry = AJS.$('.locale-country','#i18n-settings').val();
        AJS.$.ajax({
            type: "POST",
            url: dashboardResourceUrl + ".json?" + (localeLang ? "locale.lang="+localeLang : "") + (localeCountry ? "&locale.country="+localeCountry : ""),
            contentType: "application/json",
            dataType: "json",
            data: JSON.stringify({
                dashboardItemId: directoryItem.id,
                type: directoryItem.type,
                columnIndex: AJS.activeColumn
            }),
            processData: false,
            success: function(data) {
                AG.Cookie.erase("gadget-" + data.id + "-fh");
                AG.DashboardManager.addGadget(data, AJS.activeColumn);
                callback.onSuccess();
            },
            error: function(request, textStatus, errorThrown) {
                console.error("DashboardService: Failed to add item to the dashboard. Reason: " + errorThrown);
                callback.onError();
            }
        });
    }
};;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/entities/dashboard-item-retriever.js' */
AJS.namespace("JIRA.Dashboard.Services");

JIRA.Dashboard.Services.ItemRetriever =  function() {
    this.inProgressUrls = [];
    this.retrievedUrls = [];
    this.failedUrls = [];
};

JIRA.Dashboard.Services.ItemRetriever.prototype = _.extend({
    retrieve: function(endpointUrls) {
        this.trigger("batchRetrieving");
        _.each(endpointUrls, retrieveFromUrl, this);

        function retrieveFromUrl(endpointUrl)
        {
            this.inProgressUrls.push(endpointUrl);
            this.trigger("retrieving");

            AJS.$.ajax({
                type: "GET",
                dataType: "json",
                global: false,
                cache: false,
                url: endpointUrl,
                context: this,
                success: function(data) {
                    this.inProgressUrls = _.reject(this.inProgressUrls, function(url){ return url === endpointUrl });
                    this.retrievedUrls.push(endpointUrl);
                    this.trigger("retrieve", data);
                    this.checkForCompletion();
                },
                error: function(request, textStatus, errorThrown) {
                    this.inProgressUrls = _.reject(this.inProgressUrls, function(url){ return url === endpointUrl });
                    this.failedUrls.push(endpointUrl);
                    this.trigger("retrieveFailure", endpointUrl);
                    this.checkForCompletion();
                }
            });
        }
    },

    retrievalStarted: function() {
        return this.inProgressUrls.length !== 0 || this.retrievedUrls.length !== 0 || this.failedUrls.length !== 0;
    },

    retrievalInProgress: function() {
        return this.inProgressUrls.length !== 0;
    },

    retrievalCompleted: function() {
        return this.inProgressUrls.length === 0 && ( this.retrievedUrls.length !== 0 || this.failedUrls.length !== 0 );
    },

    retrievalFailed: function() {
        return this.inProgressUrls.length === 0 && this.retrievedUrls.length === 0 && this.failedUrls.length !== 0;
    },

    hasSomeFailure: function() {
        return this.failedUrls.length !== 0;
    },

    isReady: function() {
        return this.retrievedUrls.length > 0;
    },

    checkForCompletion: function() {
        if(this.retrievalCompleted())
        {
            this.trigger("batchRetrieveComplete")
        }
    },

    reset: function() {
        this.inProgressUrls.length = 0;
        this.retrievedUrls.length = 0;
        this.failedUrls.length = 0;
    },

    retryFailedEndpoints: function() {
        var failedUrls = this.failedUrls;
        this.failedUrls = [];
        this.retrieve(failedUrls);
    }
}, Backbone.Events);;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/entities/dashboard-item-directory-entities.js' */
AJS.namespace("JIRA.Dashboard.Entities");

JIRA.Dashboard.Entities.DirectoryItem = Backbone.Model.extend({});

JIRA.Dashboard.Entities.DirectoryItems = Backbone.Collection.extend({
    model: JIRA.Dashboard.Entities.DirectoryItem,

    initialize: function(models, options) {
        this.localItemsEndpointUrl = AJS.contextPath() + "/rest/config/1.0/directoryitems/local.json";
        this.externalItemsEndpointUrl = AJS.contextPath() + "/rest/config/1.0/directoryitems/external.json";
        this.endpointUrls = [this.localItemsEndpointUrl, this.externalItemsEndpointUrl];

        this.retriever = options.retriever;
        this.listenTo(this.retriever, {
            "retrieving": this.beforeRetrieve,
            "retrieve": this.processRetrievedItems,
            "retrieveFailure": this.handleRetrievalError,
            "batchRetrieving": function() {
                this.trigger("batchRetrieving");
            },
            "batchRetrieveComplete": function() {
                this.trigger("batchRetrieveComplete");
            }
        });

        this.categorisedItems = {};
    },

    comparator: "titleLabel",

    retrievalStarted: function() {
        return this.retriever.retrievalStarted();
    },

    retrievalInProgress: function() {
        return this.retriever.retrievalInProgress();
    },

    retrievalCompleted: function() {
        return this.retriever.retrievalCompleted();
    },

    retrievalFailed: function() {
        return this.retriever.retrievalFailed();
    },

    isReady: function() {
        return this.retriever.isReady();
    },

    hasSomeFailure: function() {
        return this.retriever.hasSomeFailure();
    },

    retrieve: function() {
        this.retriever.retrieve(this.endpointUrls);
    },

    beforeRetrieve: function() {
        this.trigger("retrieving");
    },

    processRetrievedItems: function(data) {
        this.set(this.transformResponseData(data), {remove: false});
        this.updateCategorisedItems();
        this.trigger("retrieve", data);
    },

    handleRetrievalError: function(failedEndpointUrl) {
        this.trigger("retrieveFailure", failedEndpointUrl);
    },

    updateCategorisedItems: function() {
        this.categorisedItems = {};
        this.categorisedItems[JIRA.Dashboard.Directory.Constants.getDefaultCategoryName()] = [];

        _.each(this.models, function(model){
            this.categorisedItems[JIRA.Dashboard.Directory.Constants.getDefaultCategoryName()].push(model);

            _.each(model.get("categories"), function(category){
                this.categorisedItems[category] = this.categorisedItems[category] || [];
                this.categorisedItems[category].push(model);
            }, this);
        }, this);
    },

    getCategorisedItems: function() {
        return this.categorisedItems;
    },

    reset: function() {
        this.set([]);
        this.categorisedItems = {};
        this.retriever.reset();
        this.trigger("reset");
    },

    retryFailedEndpoints: function() {
        this.retriever.retryFailedEndpoints();
    },

    transformResponseData: function(data) {
        return _.map(data, function(item) {
            item.isLocal = false;
            item.specUriDisplay = item.specUri;
            item.description = item.description || "Description not available";
            item.authorLabel = item.authorLabel || "Author unknown";
            item.authorLineItem = AJS.format("By {0}", item.authorLabel);

            if(!/^http/.test(item.specUri)) {
                item.specUriDisplay = AG.param.get("dashboardDirectoryBaseUrl") + item.specUri;
                item.isLocal = true;
            } else if (_.has("completeModuleKey")) {
                item.isLocal = true;
            }

            return item;
        });
    }
});;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/entities/directory-view-state.js' */
AJS.namespace("JIRA.Dashboard.Entities");

JIRA.Dashboard.Entities.DirectoryViewModel = Backbone.Model.extend({
    initialize: function(attributes,options) {
        this.directoryItems = options.directoryItems;
        this.initializeStates();

        this.listenTo(this.directoryItems, {
            "batchRetrieving": this.handleBatchRetrievalStart,
            "retrieve": this.handleRetrieval,
            "retrieveFailure": this.handleRetrievalFailure,
            "reset": this.initializeStates
        });
    },

    initializeStates: function () {
        this.set({
            retrievalInProgress: false,
            retrievalFailed: false,
            hasUnrenderedData: false,
            directoryIsVisible: false,
            searchText: "",
            selectedCategory: JIRA.Dashboard.Directory.Constants.getDefaultCategoryName(),
            categorisedItems: {},
            filteredCategorisedItems: {}
        });
    },

    handleBatchRetrievalStart: function() {
        this.set("retrievalInProgress", true);
        this.trigger("messageUpdate");
    },

    handleRetrieval: function(data) {
        this.checkRetrievalCompleted();
        if(this.get("directoryIsVisible") && data.length > 0)
        {
            this.set("hasUnrenderedData", true);
        }

        if(!this.get("retrievalInProgress") || this.get("hasUnrenderedData"))
        {
            this.trigger("messageUpdate");
        }

        if(!this.get("directoryIsVisible") && data.length > 0)
        {
            this.loadData();
        }
    },

    loadData: function() {
        this.updateCategorisedItems();
        this.trigger("dataUpdate");
    },

    loadUnrenderedData: function() {
        this.loadData();

        this.set("hasUnrenderedData", false);
        this.trigger("messageUpdate");
    },

    handleRetrievalFailure: function() {
        this.checkRetrievalCompleted();
        if(!this.get("retrievalInProgress"))
        {
            this.trigger("messageUpdate");
        }
    },

    checkRetrievalCompleted: function() {
        if(this.directoryItems.retrievalCompleted())
        {
            this.set("retrievalInProgress", false);
            this.set("retrievalFailed", this.directoryItems.hasSomeFailure());
        }
    },

    setDirectoryVisible: function() {
        this.set("directoryIsVisible", true);
    },

    setDirectoryNotVisible: function() {
        this.set("directoryIsVisible", false);
    },

    setSearchText: function(searchText) {
        this.set("searchText", searchText.toLowerCase());
        this.updateFilteredCategorisedItems();
    },

    getSearchText: function() {
        return this.get("searchText");
    },

    setSelectedCategory: function(category) {
        this.set("selectedCategory", category);
    },

    getSelectedCategory: function() {
        return this.get("selectedCategory");
    },

    updateCategorisedItems: function() {
        this.set("categorisedItems", this.directoryItems.getCategorisedItems());
        this.updateFilteredCategorisedItems();
    },

    getCategorisedItems: function() {
        return this.get("categorisedItems");
    },

    updateFilteredCategorisedItems: function() {
        this.set("filteredCategorisedItems", this.filterCategorisedItems(this.getSearchText()));
    },

    getFilteredCategorisedItems: function() {
        return this.get("filteredCategorisedItems");
    },

    filterCategorisedItems: function(searchText) {
        if(!searchText) {
            return this.getCategorisedItems();
        }

        var filtered = {};
        _.each(this.getCategorisedItems(), function(items, category){
            filtered[category] = _.filter(items, function(item){
                return this.matchesSearchText(searchText, item);
            }, this);
        }, this);
        return filtered;
    },

    matchesSearchText: function(searchText, item) {
        searchText = searchText.toLowerCase();
        return item.get("id").toLowerCase().indexOf(searchText) > -1
            || item.get("titleLabel").toLowerCase().indexOf(searchText) > -1
            || item.get("authorLabel").toLowerCase().indexOf(searchText) > -1
            || item.get("description").toLowerCase().indexOf(searchText) > -1;
    },

    getCategoryCount: function() {
        return this.transformCategoryCountForDisplay(this.getCategorisedItems());
    },

    getFilteredCategoryCount: function() {
        return this.transformCategoryCountForDisplay(this.getFilteredCategorisedItems());
    },

    transformCategoryCountForDisplay: function (categorisedItems) {
        var categoryCount = [];
        _.each(categorisedItems, function (items, category) {
            categoryCount.push({
                label: category,
                count: items.length
            });
        });

        return _.sortBy(categoryCount, "label");
    },

    getItemsForCategory: function(category) {
        return this.getCategorisedItems()[category];
    },

    getVisibleItemsForCategory: function(category) {
        return this.getFilteredCategorisedItems()[category];
    }
});;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/views/directory-items-view.js' */
AJS.namespace("JIRA.Dashboard.Views");

JIRA.Dashboard.Views.DirectoryItems = Backbone.View.extend({
    template: JIRA.Dashboard.Templates.directoryItems,

    events: {
        "click button[data-purpose='add-dashboard-item']": function(e) {
            var addButton = AJS.$(e.target);
            var directoryItem = {
                id: addButton.attr("data-item-id"),
                type: addButton.attr("data-item-type")
            };
            this.trigger("dashboardItemAdd", directoryItem);
        },

        "click a[data-purpose='toggle-xml']": function(e) {
            e.preventDefault();

            var $textArea = AJS.$(e.target.parentNode).find("textarea");
            var $anchor = AJS.$(e.target);
            if($textArea.is(":visible")) {
                $textArea.hide();
                $anchor.text("Show XML link");
            } else {
                $textArea.show();
                $textArea.select();
                $anchor.text("Hide XML link");
            }
        }
    },

    render: function() {
        var items = [];
        _.each(this.model.getItemsForCategory(this.model.getSelectedCategory()),function(model){
            items.push(model.attributes)
        });

        this.$el.html(this.template({items: items}));
        this.applySearchTextFiltering();
        this.$el.children().filter(".item-group").last().addClass("last");
    },

    applySearchTextFiltering: function() {
        var visibleItemIds = {};
        var visibleCount = 0;
        _.each(this.model.getVisibleItemsForCategory(this.model.getSelectedCategory()), function(model){
            visibleItemIds[model.get("id")] = true;
            visibleCount++;
        });

        if(visibleCount === 0) {
            visibleItemIds["no-result"] = true;
        }

        var $items = this.$el.children();
        _.each($items, function(item) {
            var $item = AJS.$(item);
            if(!visibleItemIds[$item.attr("data-item-id")]) {
                $item.addClass("hidden");
            } else {
                $item.removeClass("hidden");
            }
        });
        $items.removeClass("last").filter(".item-group:visible").last().addClass("last");
    },

    enableAddButtons: function() {
        this.delegateEvents();
        this.$("button[data-purpose='add-dashboard-item']").removeAttr("aria-disabled");
    },

    disableAddButtons: function() {
        this.undelegateEvents();
        this.$("button[data-purpose='add-dashboard-item']").attr("aria-disabled", "true");
    }
});;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/views/directory-view.js' */
AJS.namespace("JIRA.Dashboard.Views");

JIRA.Dashboard.Views.Directory = Backbone.View.extend({
    initialize: function() {
        this.$shell = AJS.$(JIRA.Dashboard.Templates.gadgetDirectoryPage({
            searchPlaceholder: "Search"
        }));

        this.$searchBox = this.$shell.find("#search");
    },

    events: {
        "submit form.directory-search": function(e) {
            e.preventDefault();
        },

        "keyup #search": function(e) {
            e.preventDefault();
            this.trigger("searchTextUpdate", AJS.$(e.target).val());
        }
    },

    getNavRootElement: function() {
        return this.$shell.find("div.aui-navgroup-inner")
    },

    getItemsRootElement: function() {
        return this.$shell.find("div#list-panel");
    },

    getMessagesRootElement: function() {
        return this.$shell.find("div#message-panel");
    },

    render: function() {
        this.$el.html(this.$shell);
    },

    detach: function() {
        this.$shell.detach();
    },

    resetUserInput: function() {
        this.$searchBox.val("");
    },

    setFocusOnSearch: function() {
        this.$searchBox.focus();
    }
});;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/views/directory-nav-view.js' */
AJS.namespace("JIRA.Dashboard.Views");

JIRA.Dashboard.Views.DirectoryNav = Backbone.View.extend({
    template: JIRA.Dashboard.Templates.directoryNavList,

    events: {
        "click a[data-purpose='category-nav']": function(e) {
            this.trigger("categorySelect", AJS.$(e.target).attr("data-category-label"));
            e.preventDefault();
        },

        "click a[data-purpose='category-nav'] > span": function(e) {
            this.trigger("categorySelect", AJS.$(e.target.parentNode).attr("data-category-label"));
            e.stopPropagation();
        }
    },

    render: function() {
        var self = this;
        this.$el.html(this.template({
            categories: self.model.getFilteredCategoryCount(),
            selectedCategoryLabel: self.model.getSelectedCategory(),
            headerText: "CATEGORIES"
        }));
    }
});;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/views/directory-loading-view.js' */
AJS.namespace("JIRA.Dashboard.Views");

JIRA.Dashboard.Views.DirectoryLoadingView = Backbone.View.extend({
    template: JIRA.Dashboard.Templates.gadgetDirectoryLoadingPage,

    initialize: function() {
        this.$content = AJS.$(this.template({
            loadingText: "Loading gadgets..."
        }));
    },

    render: function() {
        this.$el.html(this.$content);
        var spinnerOpts = AJS.$.fn.spin && AJS.$.fn.spin.presets ? AJS.$.fn.spin.presets.medium : {};
        var spinner = new Spinner(spinnerOpts).spin();
        this.$el.find(".loading-spinner").html(spinner.el);
    },

    detach: function() {
        this.$content.detach();
    }
});;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/views/directory-load-failure-view.js' */
AJS.namespace("JIRA.Dashboard.Views");

JIRA.Dashboard.Views.DirectoryLoadFailureView = Backbone.View.extend({
    template: JIRA.Dashboard.Templates.gadgetDirectoryLoadFailurePage,

    events: {
        "click a[data-purpose='reload-directory']": function() {
            this.trigger("directoryReloadRequest");
        }
    },

    initialize: function() {
        this.$content = AJS.$(this.template());
    },

    render: function() {
        this.$el.html(this.$content);
    },

    detach: function() {
        this.$content.detach();
    }
});;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/views/directory-message-view.js' */
AJS.namespace("JIRA.Dashboard.Views");

JIRA.Dashboard.Views.DirectoryMessageView = Backbone.View.extend({
    template: JIRA.Dashboard.Templates.directoryMessages,

    events: {
        "click a[data-purpose='retry']": function() {
            this.trigger("retrieveRetryRequest");
        },

        "click a[data-purpose='load']": function() {
            this.trigger("additionalItemsLoadRequest");
        }
    },

    render: function(payload) {
        this.$el.html(this.template({
            payload: payload
        }));
    }
});;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/controllers/directory-controller.js' */
AJS.namespace("JIRA.Dashboard.Controllers");

JIRA.Dashboard.Controllers.DirectoryController = function(model, contentRootElement) {
    this.model = model;
    this.viewState = new JIRA.Dashboard.Entities.DirectoryViewModel({},{
        directoryItems: model
    });

    this.directory = new JIRA.Dashboard.Views.Directory({
        el: contentRootElement
    });
    this.directoryNav = new JIRA.Dashboard.Views.DirectoryNav({
        model: this.viewState,
        el: this.directory.getNavRootElement()
    });
    this.directoryItemsView = new JIRA.Dashboard.Views.DirectoryItems({
        model: this.viewState,
        el: this.directory.getItemsRootElement()
    });
    this.messageView = new JIRA.Dashboard.Views.DirectoryMessageView({
        el: this.directory.getMessagesRootElement()
    });

    this.listenTo(this.viewState, {
        "messageUpdate": this.refreshMessage,
        "dataUpdate": this.refreshData
    });
    this.listenTo(this.directoryItemsView, "dashboardItemAdd", this.handleDashboardItemAddition);
    this.listenTo(this.directoryNav, "categorySelect", this.updatedSelectedCategory);
    this.listenTo(this.directory, "searchTextUpdate", this.updateSearchText);
    this.listenTo(this.messageView, {
        "additionalItemsLoadRequest": function() {
            this.viewState.loadUnrenderedData();
        },
        "retrieveRetryRequest": function() {
            this.model.retryFailedEndpoints();
        }
    });
};

JIRA.Dashboard.Controllers.DirectoryController.prototype = _.extend({
    refreshMessage: function() {
        this.messageView.render({
            "retrievalInProgress": this.viewState.get("retrievalInProgress"),
            "retrievalFailed": this.viewState.get("retrievalFailed"),
            "directoryIsVisible": this.viewState.get("directoryIsVisible"),
            "hasUnrenderedData": this.viewState.get("hasUnrenderedData")
        });
    },

    refreshData: function() {
        this.directoryNav.render();
        this.directoryItemsView.render();
    },

    handleDashboardItemAddition: function(directoryItem) {
        this.trigger("dashboardItemAdd", directoryItem);
    },

    disableDirectoryAddButtons: function() {
        this.directoryItemsView.disableAddButtons();
    },

    enableDirectoryAddButtons: function() {
        this.directoryItemsView.enableAddButtons();
    },

    updatedSelectedCategory: function(category) {
        this.viewState.setSelectedCategory(category);
        this.directoryNav.render();
        this.directoryItemsView.render();
    },

    updateSearchText: function(searchText) {
        if(searchText === this.viewState.getSearchText()) {
            return;
        }

        this.viewState.setSearchText(searchText);
        this.directoryNav.render();
        this.directoryItemsView.applySearchTextFiltering();
    },

    render: function() {
        this.directory.render();
        this.viewState.setDirectoryVisible();
    },

    detach: function() {
        this.directory.detach();
        this.viewState.setDirectoryNotVisible();
    },

    resetUserInput: function() {
        this.viewState.setSelectedCategory(JIRA.Dashboard.Directory.Constants.getDefaultCategoryName());
        this.viewState.setSearchText("");
        this.directoryNav.render();
        this.directoryItemsView.render();
        this.directory.resetUserInput();
    },

    setFocusOnSearch: function() {
        this.directory.setFocusOnSearch();
    }
}, Backbone.Events);;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/controllers/directory-loader.js' */
AJS.namespace("JIRA.Dashboard.Controllers");

JIRA.Dashboard.Controllers.DirectoryLoader = function(triggersSelector) {
    this.directoryItems = new JIRA.Dashboard.Entities.DirectoryItems([], {
        retriever: new JIRA.Dashboard.Services.ItemRetriever()
    });
    this.dialogController = new JIRA.Dashboard.Controllers.DialogController(this.directoryItems);
    this.directoryController = this.dialogController.getDirectoryController();

    this.triggersSelector = triggersSelector;
    this.startListeningToTriggers();

    this.listenTo(this.directoryController, "dashboardItemAdd", function(directoryItem) {
        this.trigger("dashboardItemAdd", directoryItem);
    });
    this.listenTo(this.dialogController, "directoryReloadRequest", this.reload);
};

JIRA.Dashboard.Controllers.DirectoryLoader.prototype = _.extend({
    handleClickEvent: function(e) {
        var id = AJS.$(e.currentTarget).attr('id') || '';
        AJS.activeColumn = id.substring(11) || 0;

        this.load();
        return e.preventDefault();
    },

    load: function () {
        if(this.directoryItems.isReady()) {
            this.dialogController.showDirectory();
        } else if(!this.directoryItems.retrievalStarted()) {
                this.dialogController.showDirectoryLoadingPage();
                this.listenTo(this.directoryItems, "retrieve", this.handleFirstRetrieve);
                this.listenTo(this.directoryItems, "retrieveFailure", this.handleRetrieveFailure);
                this.directoryItems.retrieve();
        } else if(this.directoryItems.retrievalFailed()) {
            this.dialogController.showDirectoryLoadFailurePage();
        } else {
            this.dialogController.showDirectoryLoadingPage();
        }
    },

    reload: function() {
        this.directoryItems.reset();
        this.load();
    },

    handleFirstRetrieve: function(data) {
        if(data.length == 0 && this.directoryItems.retrievalInProgress()) {
            return;
        }

        this.stopListening(this.directoryItems);
        this.dialogController.renderDirectory();
    },

    handleRetrieveFailure: function() {
        if(!this.directoryItems.retrievalInProgress())
        {
            this.stopListening(this.directoryItems);
            this.dialogController.renderDirectoryLoadFailurePage();
        }
    },

    disableDirectoryAddButtons: function() {
        this.directoryController.disableDirectoryAddButtons();
    },

    enableDirectoryAddButtons: function() {
        this.directoryController.enableDirectoryAddButtons();
    },

    startListeningToTriggers: function() {
        AJS.$(document).on('click.dashboard-directory-loader', this.triggersSelector, _.bind(this.handleClickEvent, this));
    },

    stopListeningToTriggers: function() {
        AJS.$(document).off('click.dashboard-directory-loader', this.triggersSelector);
    }
}, Backbone.Events);
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/controllers/dialog-controller.js' */
AJS.namespace("JIRA.Dashboard.Controllers");

JIRA.Dashboard.Controllers.DialogController = function(model, dialogId) {
    var $dialog = AJS.$(JIRA.Dashboard.Templates.gadgetDirectoryDialog({
        id: dialogId || "gadget-dialog",
        headerText: "Add a gadget",
        gadgetsAdminUrl: AG.param.get("gadgetDirectoryAdminUrl"),
        manageGadgetsLabel: "Manage gadgets",
        canManageGadgets: AG.param.get("canAddExternalGadgetsToDirectory")
    }));
    var $contentRootElement = $dialog.find("div.aui-dialog2-content");
    this.dialog = AJS.dialog2($dialog);
    this.dialogVisible = false;

    var self = this;
    this.dialog.on("hide", function() {
        self.dialogVisible = false;
        self.resetUserInputOnCurrentPage();
    });

    this.currentPage = "";
    this.loadingView = new JIRA.Dashboard.Views.DirectoryLoadingView({
        el: $contentRootElement[0]
    });
    this.loadFailureView = new JIRA.Dashboard.Views.DirectoryLoadFailureView({
        el: $contentRootElement[0]
    });
    this.directoryController = new JIRA.Dashboard.Controllers.DirectoryController(model, $contentRootElement[0]);

    this.listenTo(this.loadFailureView, "directoryReloadRequest", function() {
        this.trigger("directoryReloadRequest")
    });

    this.windowIsUnloading = false;
    window.onbeforeunload = function() {
        self.windowIsUnloading = true;
        if(self.dialogVisible) {
            self.dialog.hide();
        }
    }
};

JIRA.Dashboard.Controllers.DialogController.prototype = _.extend({
    showDirectoryLoadingPage: function() {
        this.renderDirectoryLoadingPage(true);
    },

    renderDirectoryLoadingPage: function(showDialog) {
        this.renderPage("loading", _.bind(function(){
            this.loadingView.render();
        }, this), showDialog);
    },

    showDirectory: function() {
        this.renderDirectory(true);
    },

    renderDirectory: function(showDialog) {
        this.renderPage("directory", _.bind(function(){
            this.directoryController.render();
            this.directoryController.setFocusOnSearch();
        }, this), showDialog);
    },

    showDirectoryLoadFailurePage: function() {
        this.renderDirectoryLoadFailurePage(true);
    },

    renderDirectoryLoadFailurePage: function(showDialog) {
        if(this.windowIsUnloading) {
            return;
        }

        this.renderPage("loadFailure", _.bind(function(){
            this.loadFailureView.render();
        }, this), showDialog);
    },

    renderPage: function(pageName, renderFn, showDialog) {
        if(this.currentPage !== pageName) {
            this.detachCurrentPage();
            renderFn();
            this.currentPage = pageName;
        }

        if(showDialog && !this.dialogVisible) {
            this.showDialog();
        }
    },

    detachCurrentPage: function() {
        switch(this.currentPage)
        {
            case "":
                break;
            case "loading":
                this.loadingView.detach();
                break;
            case "directory":
                this.directoryController.detach();
                break;
            case "loadFailure":
                this.loadFailureView.detach();
                break;
            default:
                throw "Unknown page: " + this.currentPage;
        }
    },

    resetUserInputOnCurrentPage: function() {
        if(this.currentPage === "directory") {
            this.directoryController.resetUserInput();
        }
    },

    getDirectoryController: function() {
        return this.directoryController;
    },

    showDialog: function() {
        this.dialog.show();
        this.dialogVisible = true;
    },

    destroyDialog: function() {
        this.dialog.remove();
    }
}, Backbone.Events);;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/dashboard-item-directory.js' */
AJS.namespace("JIRA.Dashboard.Modules");

JIRA.Dashboard.Modules.Directory = function(triggersSelector) {
    this.controller = new JIRA.Dashboard.Controllers.DirectoryLoader(triggersSelector);
    this.controller.on("dashboardItemAdd", this.onDashboardItemAdd, this);
};

JIRA.Dashboard.Modules.Directory.prototype = {
    onDashboardItemAdd: function(directoryItem){
        this.controller.disableDirectoryAddButtons();

        var self = this;
        JIRA.Dashboard.DashboardService.addItem(directoryItem,{
            onSuccess: function() {
                self.controller.enableDirectoryAddButtons();
            },
            onError: function(errorMsg) {
                if(errorMsg) {
                    alert(errorMsg);
                }
                self.controller.enableDirectoryAddButtons();
            }
        })
    }
};
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard', location = 'js/jquery.cookie.js' */
/**
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
 * @desc Create a cookie with all available options.
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.cookie('the_cookie', null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

/**
 * Get the value of a cookie with the given name.
 *
 * @example $.cookie('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
jQuery.cookie = function(name, value, options) {
    if (typeof value != 'undefined') { // name and value given, set cookie
        options = options || {};
        if (value === null) {
            value = '';
            options.expires = -1;
        }
        var expires = '';
        if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
            var date;
            if (typeof options.expires == 'number') {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
        }
        // CAUTION: Needed to parenthesize options.path and options.domain
        // in the following expressions, otherwise they evaluate to undefined
        // in the packed version for some reason...
        var path = options.path ? '; path=' + (options.path) : '';
        var domain = options.domain ? '; domain=' + (options.domain) : '';
        var secure = options.secure ? '; secure' : '';
        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
    } else { // only name given, get cookie
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};;
;
/* module-key = 'jira.webresources:captcha', location = '/includes/jira/captcha/Captcha.js' */
/**
 * @namespace JIRA.Captcha
 */
JIRA.Captcha = {
    setup: function() {
        AJS.$("#captcha").delegate("span.captcha-reload", "click", function (e) {
            JIRA.Captcha.refresh();
            e.preventDefault();
        });
    },
    refresh: function() {
        var $img = AJS.$(".captcha-image", "#captcha .captcha-container"),
            src = $img.attr("src");
        if (src.indexOf("__r") >= 0) {
            src = src.replace(/__r=([^&]+)/, "__r=" + Math.random());
        } else {
            src = src.indexOf('?') >= 0 ? (src + "&__r=" + Math.random()) : (src + "?__r=" + Math.random());
        }
        $img.attr("src", src);
        AJS.$("#captcha .captcha-response").focus();
    }
};

jQuery(JIRA.Captcha.setup);
;
;
/* module-key = 'com.atlassian.jira.gadgets:login-dashboard-item-resources', location = 'static/dashboarditem/login/login.soy' */
// This file was automatically generated from login.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.Login.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.Login == 'undefined') { JIRA.DashboardItem.Login = {}; }
if (typeof JIRA.DashboardItem.Login.Templates == 'undefined') { JIRA.DashboardItem.Login.Templates = {}; }


JIRA.DashboardItem.Login.Templates.Login = function(opt_data, opt_ignored) {
  var output = '<div id="login-container" class=""><form id="loginform" method="post" action="#" name="loginform" class="aui gdt">';
  if (opt_data.recoveryModeEnabled) {
    var help__soy6 = '<a target="_blank" href="' + soy.$$escapeHtml(opt_data.recoveryModeHelpUrl) + '">';
    var end__soy10 = '</a>';
    output += aui.message.warning({content: '' + soy.$$filterNoAutoescape(AJS.format("JIRA is running in recovery mode. You can log in as {0}, using the password specified when starting JIRA. See {1}the documentation{2} for more details.",opt_data.recoveryModeUser,help__soy6,end__soy10))});
  }
  output += ((opt_data.errorMessage) ? '<div id="usernameerror" class="aui-message error"><span id="usernamerror-icon" class="aui-icon icon-error"></span><p>' + soy.$$escapeHtml(opt_data.errorMessage) + '</p></div>' : '') + '<div class="field-group"><label accesskey="u" for="login-form-username" id="usernamelabel">' + soy.$$filterNoAutoescape(AJS.format("{0}U{1}sername",'<u>','</u>')) + '</label><input class="text medium-field" id="login-form-username" name="os_username" type="text"></div><div class="field-group"><label accesskey="p" for="login-form-password" id="passwordlabel">' + soy.$$filterNoAutoescape(AJS.format("{0}P{1}assword",'<u>','</u>')) + '</label><input class="text medium-field" id="login-form-password" name="os_password" type="password"></div>' + ((opt_data.showRememberMe) ? '<fieldset class="group"><div class="checkbox" id="rememberme"><input class="checkbox" id="login-form-remember-me" name="os_cookie" type="checkbox" value="true"><label accesskey="r" for="login-form-remember-me" id="remembermelabel">' + soy.$$filterNoAutoescape(AJS.format("{0}R{1}emember my login on this computer",'<u>','</u>')) + '</label></div></fieldset>' : '') + ((opt_data.showCaptcha) ? '<div class="field-group" id="captcha"><label id="captchalabel" for="login-form-captcha" accesskey="c">' + soy.$$escapeHtml("Please enter the word as shown below") + '</label><input type="text" name="os_captcha" id="login-form-captcha" class="text medium-field captcha-response"><div class="captcha-container"><img alt="" class="captcha-image" height="100px" id="captchaimg" src="' + soy.$$escapeHtml("/jira") + '/captcha?ts=' + soy.$$escapeHtml(opt_data.captchaTimestamp) + '" width="200px"><a id="os-captcha-icon" href="#login-form-os-captcha" tabindex="-1" class="captcha-trigger" title="' + soy.$$escapeHtml("Refresh the image") + '"><span class="aui-icon captcha-reload icon-reload">' + soy.$$escapeHtml("Refresh the image") + '</span></a></div></div>' : '') + ((opt_data.isPublicMode) ? '<div class="field-group" id="publicmodeon"><div id="publicmodeonmsg">' + soy.$$filterNoAutoescape(AJS.format("Not a member? {0}{1}{2} for an account.",'<a id="signup" href="' + "/jira" + '/secure/Signup!default.jspa" tabindex="-1" target="_parent">',"Sign up",'</a>')) + '</div></div>' : (opt_data.adminFormOn) ? '<div class="field-group" id="publicmodeooff"><div id="publicmodeoffmsg">' + soy.$$filterNoAutoescape(AJS.format("Not a member? To request an account, {0}.",AJS.format("please contact your {0}JIRA administrators{1}",'<a id="contact-admin" href="' + "/jira" + '/secure/ContactAdministrators!default.jspa">','</a>'))) + '</div></div>' : '<div class="field-group" id="publicmodeooff"><div id="publicmodeoffmsg">' + soy.$$escapeHtml(AJS.format("Not a member? To request an account, {0}.",AJS.format("please contact your {0}JIRA administrators{1}",'',''))) + '</div></div>') + '<div class="buttons-container"><div class="buttons"><input class="button" id="login" name="login" type="submit" value="' + soy.$$escapeHtml("Log In") + '">' + ((opt_data.showForgotPassword) ? '<a class="cancel" href="' + soy.$$escapeHtml("/jira") + '/secure/ForgotLoginDetails.jspa" id="forgotpassword" target="_parent">' + soy.$$escapeHtml("Can\x27t access your account?") + '</a>' : '') + '</div></div></form></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Login.Templates.Login.soyTemplateName = 'JIRA.DashboardItem.Login.Templates.Login';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:login-dashboard-item-resources', location = 'static/dashboarditem/login/login.js' */
define("jira-dashboard-items/login", [
    'underscore',
    'jquery'
], function(
    _,
    $
) {

    function renderTemplate($element, userPreferences, currentError) {
        $element.empty().html(JIRA.DashboardItem.Login.Templates.Login({
            isPublicMode: userPreferences.isPublicMode,
            adminFormOn: userPreferences.isAdminFormOn,
            showForgotPassword: !userPreferences.externalUserManagement && !userPreferences.externalPasswordManagement,
            showRememberMe: userPreferences.allowCookies,
            errorMessage: currentError,
            showCaptcha: userPreferences.isElevatedSecurityCheckShown,
            captchaTimestamp: Date.now()
        }));
    }

    function applyResponsiveLayout($element, $form) {
        if ($element.width() < 490) {
            $form.addClass("top-label");
        } else {
            $form.removeClass("top-label");
        }
    }

    function focusInputUsername($element) {
        setTimeout(function() {
            $element.find("#login-form-username").focus();
        }, 200);
    }

    function onAfterRender() {
        applyResponsiveLayout(this.$element, this.$form);
        focusInputUsername(this.$element);
        JIRA.Captcha.setup();
        this.API.resize();
    }

    function responseToErrorMessage(data) {
        data = data || {};
        if (data.communicationError) {
            return "Sorry, a communication error occurred while trying to contact the remote authentication server.";
        }
        if (data.loginError) {
            return "Sorry, an error occurred trying to log you in - please try again.";
        }
        if (data.loginFailedByPermissions) {
            return AJS.format("You do not have a permission to log in. If you think this is incorrect, {0}.", data.contactAdminLink);
        }
        if (data.isElevatedSecurityCheckShown) {
            return "Sorry, your userid is required to answer a CAPTCHA question correctly.";
        }
        return "Sorry, your username and password are incorrect - please try again.";
    }

    function updateTemplate(data, userPreferences) {
        this.currentError = responseToErrorMessage(data);
        this.render(this.$element, userPreferences, true);
        this.API.hideLoadingBar();
        onAfterRender.call(this);
    }

    var DashboardItem = function(API) {
        this.currentError = null;
        this.API = API;
        this.API.on("afterRender", onAfterRender, this);
    };

    DashboardItem.prototype.render = function(element, userPreferences, forceRender) {
        var $element = this.$element = $(element);
        var currentError = this.currentError;

        if (forceRender || $element.find("#loginform").length === 0) {
            renderTemplate($element, userPreferences, currentError);
        }

        var $form = this.$form = $element.find("#loginform");
        $form.submit(_.bind(function(e) {
            e.preventDefault();
            this.API.showLoadingBar();

            $.ajax({
                type: "POST",
                url: AJS.contextPath() + "/rest/gadget/1.0/login",
                data: $form.serialize(),
                success: _.bind(function(data) {
                    if (data.loginSucceeded) {
                        window.location = AJS.contextPath();
                    } else {
                        // After a few errors, we might need to show the captcha.
                        userPreferences.isElevatedSecurityCheckShown = data.isElevatedSecurityCheckShown;
                        updateTemplate.call(this, data, userPreferences);
                    }
                }, this),
                error: _.bind(function(data) {
                    updateTemplate.call(this, data, userPreferences);
                }, this)
            });
        }, this));
    };

    return DashboardItem;
});
;
;
/* module-key = 'com.atlassian.gadgets.publisher:dashboard-item-common', location = 'dashboard-item/common/dashboard-item-common.soy' */
// This file was automatically generated from dashboard-item-common.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Atlassian.DashboardItem.Common.Templates.
 */

if (typeof Atlassian == 'undefined') { var Atlassian = {}; }
if (typeof Atlassian.DashboardItem == 'undefined') { Atlassian.DashboardItem = {}; }
if (typeof Atlassian.DashboardItem.Common == 'undefined') { Atlassian.DashboardItem.Common = {}; }
if (typeof Atlassian.DashboardItem.Common.Templates == 'undefined') { Atlassian.DashboardItem.Common.Templates = {}; }


Atlassian.DashboardItem.Common.Templates.config = function(opt_data, opt_ignored) {
  return '<div class="dashboard-item-preferences-config"><div class="dashboard-item-error"></div><form action="#" method="post" class="aui">' + soy.$$filterNoAutoescape(opt_data.fields) + '<div class="buttons-container"><div class="buttons"><input class="button submit" type="submit" value="' + soy.$$escapeHtml("Save") + '">' + ((opt_data.isConfigured) ? '<input class="aui-button aui-button-link cancel" type="button" value="' + soy.$$escapeHtml("Cancel") + '">' : '') + '</div></div></form></div>';
};
if (goog.DEBUG) {
  Atlassian.DashboardItem.Common.Templates.config.soyTemplateName = 'Atlassian.DashboardItem.Common.Templates.config';
}


Atlassian.DashboardItem.Common.Templates.refreshInterval = function(opt_data, opt_ignored) {
  var output = '';
  var prefixedId__soy16 = opt_data.prefix + opt_data.id;
  output += '<div class="field-group ' + soy.$$escapeHtml(opt_data.id) + '"><label for="' + soy.$$escapeHtml(prefixedId__soy16) + '">' + soy.$$escapeHtml("Auto refresh") + '</label><div class="checkbox"><label><input type="checkbox" id="' + soy.$$escapeHtml(prefixedId__soy16) + '" name="' + soy.$$escapeHtml(opt_data.id) + '" value="15" class="checkbox" ' + ((opt_data.value != 'false' && opt_data.value != '') ? 'checked="checked"' : '') + '>' + soy.$$escapeHtml("Update every 15 minutes") + '</label></div><div class="description">&nbsp;</div></div>';
  return output;
};
if (goog.DEBUG) {
  Atlassian.DashboardItem.Common.Templates.refreshInterval.soyTemplateName = 'Atlassian.DashboardItem.Common.Templates.refreshInterval';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:dashboard-item-common-resources', location = 'static/dashboarditem/common/DashboardItemCommonFunctions.js' */
define("jira-dashboard-items/common-functions", [
    'underscore'
], function(
    _
) {

    //TODO: Move this to Atlassian Gadgets plugin.
    /**
     * Given a set of preferences with a projectOrFilterId, creates a type and id preference.
     * @param preferences for the DashboardItem
     * @returns {Object}
     */
    function projectFilterBackwardCompatible(preferences) {
        var newPreferences = _.extend({}, preferences);
        if (newPreferences.projectOrFilterId && (!newPreferences.type || !newPreferences.id)) {
            newPreferences.name = newPreferences.projectOrFilterId;

            var projectOrFilterSplit = newPreferences.projectOrFilterId.split("-");
            if (projectOrFilterSplit.length === 2) {
                newPreferences.type = projectOrFilterSplit[0];
                newPreferences.id = projectOrFilterSplit[1];
            }
        }
        delete newPreferences.projectOrFilterId;
        return newPreferences;
    }


    /**
     * Given a set of preferences in the new project or filter style, revert to the old preferences.
     * @param preferences for the DashboardItem
     * @returns {Object} gadget preferences
     */
    function getSafeLegacyProjectOrFilterId(preferences) {
        var newPreferences = _.extend({}, preferences);
        if (!newPreferences.projectOrFilterId && newPreferences.type && newPreferences.id) {
            newPreferences.projectOrFilterId = newPreferences.type + '-' + newPreferences.id;
        }

        delete newPreferences.id;
        delete newPreferences.type;
        return newPreferences;
    }

    return {
        projectFilterBackwardCompatible: projectFilterBackwardCompatible,
        getSafeLegacyProjectOrFilterId: getSafeLegacyProjectOrFilterId
    };
});
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/dropdown/Dropdown.js' */
/**
 * Creates a dropdown list from a JSON object
 *
 * @constructor JIRA.Dropdown
 * @deprecated
 * @author Scott Harwood
 *
 * NOTE: Please use {@link Dropdown} instead of this for future dropdown implementations.
 */
JIRA.Dropdown = (function() {

    // private

    var instances = [];

    return /** @lends JIRA.Dropdown */ {

        // public

        /**
         * Adds this instance to private var <em>instances</em>
         * This reference can be used to access all instances
         */
        addInstance: function() {
            instances.push(this);
        },


        /**
         * Calls the hideList method on all instances of <em>dropdown</em>
         */
        hideInstances: function() {
            var that = this;
            jQuery(instances).each(function(){
                if (that !== this) {
                    this.hideDropdown();
                }
            });
        },


        getHash: function () {
            if (!this.hash) {
                this.hash = {
                    container: this.dropdown,
                    hide: this.hideDropdown,
                    show: this.displayDropdown
                };
            }
            return this.hash;
        },

        /**
         * Calls <em>hideInstances</em> method to hide all other dropdowns.
         * Adds <em>active</em> class to <em>dropdown</em> and styles to make it visible.
         */
        displayDropdown: function() {
            if (JIRA.Dropdown.current === this) {
                return;
            }

            this.hideInstances();
            JIRA.Dropdown.current = this;
            this.dropdown.css({display: "block"});

            this.displayed = true;

            var dd = this.dropdown;
            if (window.top.JIRA && !window.top.JIRA.Dialog.current) {
                setTimeout(function() {
                    // Scroll dropdown into view
                    var win = jQuery(window);
                    var minScrollTop = dd.offset().top + dd.prop("offsetHeight") - win.height() + 10;

                    if (win.scrollTop() < minScrollTop) {
                        jQuery("html,body").animate({scrollTop: minScrollTop}, 300, "linear");
                    }
                }, 100);
            }
        },

        /**
         * Removes <em>active</em> class from <em>dropdown</em> and styles to make it hidden.
         */
        hideDropdown: function() {
            if (this.displayed === false) {
                return;
            }

            JIRA.Dropdown.current = null;
            this.dropdown.css({display: "none"});

            this.displayed = false;
        },

        /**
         * Initialises instance by, applying primary handler, user options and a Internet Explorer hack.
         * @param {HTMLElement} trigger
         * @param {HTMLElement} dropdown
         */
        init: function(trigger, dropdown) {

            var that = this;

            this.addInstance(this);
            this.dropdown = jQuery(dropdown);

            this.dropdown.css({display: "none"});

            // hide dropdown on tab
            jQuery(document).keydown(function(e){
                if(e.keyCode === 9) {
                    that.hideDropdown();
                }
            });

            // this instance is triggered by a method call
            if (trigger.target) {
                jQuery.aop.before(trigger, function(){
                    if (!that.displayed) {
                        that.displayDropdown();
                    }
                });

            // this instance is triggered by a click event
            } else {
                that.dropdown.css("top",jQuery(trigger).outerHeight() + "px");
                trigger.click(function(e){
                    if (!that.displayed) {
                        that.displayDropdown();
                        e.stopPropagation();
                        // lets not follow the link (if it is a link)
                    } else {
                        that.hideDropdown();
                    }
                    e.preventDefault();
                });
            }

            // hide dropdown when click anywhere other than on this instance
            jQuery(document.body).click(function(){
                if (that.displayed) {
                    that.hideDropdown();
                }
            });
        }
    };

})();

/**
 * Standard dropdown constructor
 * @constuctor JIRA.Dropdown.Standard
 * @extends JIRA.Dropdown
 * @param {HTMLElement} trigger
 * @param {HTMLElement} dropdown
 * @return {JIRA.Dropdown} instance
 */
JIRA.Dropdown.Standard = function(trigger, dropdown) {

    /** @lends JIRA.Dropdown.Standard.prototype */
    var that = begetObject(JIRA.Dropdown);
    that.init(trigger, dropdown);

    return that;
};

/**
 * Standard dropdown constructor
 * @constructor JIRA.Dropdown.AutoComplete
 * @extends JIRA.Dropdown
 * @param {HTMLElement} trigger
 * @param {HTMLElement} dropdown
 * @return {Object} - instance
 */
JIRA.Dropdown.AutoComplete = function(trigger, dropdown) {

    /** @lends JIRA.Dropdown.AutoComplete.prototype */
    var that = begetObject(JIRA.Dropdown);

    that.init = function(trigger, dropdown) {

        this.addInstance(this);
        this.dropdown = jQuery(dropdown).click(function(e){
            // lets not hide dropdown when we click on it
            e.stopPropagation();
        });
        this.dropdown.css({display: "none"});

        // this instance is triggered by a method call
        if (trigger.target) {
            jQuery.aop.before(trigger, function(){
                if (!that.displayed) {
                    that.displayDropdown();
                }
            });

        // this instance is triggered by a click event
        } else {
            trigger.click(function(e){
                if (!that.displayed) {
                    that.displayDropdown();
                    e.stopPropagation();
                }
            });
        }

        // hide dropdown when click anywhere other than on this instance
        jQuery(document.body).click(function(){
            if (that.displayed) {
                that.hideDropdown();
            }
        });
    };

    that.init(trigger, dropdown);

    return that;
};

/** Preserve legacy namespace
    @deprecated jira.widget.dropdown */
AJS.namespace("jira.widget.dropdown", null, JIRA.Dropdown);
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/AutoComplete.js' */
define('jira/autocomplete/autocomplete', [
    'jira/ajs/ajax/smart-ajax',
    'jira/util/objects',
    'jquery'
], function(
    SmartAjax,
    Objects,
    jQuery
) {

    /**
     * @class AutoComplete
     * @requires jQuery.aop
     */
    return function() {

        var inFocus;

        /**
         * Calls a callback after specified delay
         * @memberof AutoComplete.prototype
         * @param {Number} l - length of delay in <em>seconds</em>
         * @param {Function} callback - function to call after delay
         */
        var delay = function(callback,l) {
            if (delay.t) {
                clearTimeout(delay.t);
                delay.t = undefined;
            }
            delay.t = setTimeout(callback, l * 1000);
        };

        var INVALID_KEYS = {
              9: true,
             13: true,
             14: true,
             25: true,
             27: true,
             38: true,
             40: true,
            224: true
        };

        return /** @lends AutoComplete.prototype */{

            /**
            * Checks whether a saved version (cached) of the request exists, if not performs a request and saves response,
            * then dispatches saved response to <em>renderSuggestions</em> method.
            *
            * @public
            */
            dispatcher: function() {},


            /**
             * Gets cached response
             *
             * @public
             * @param {String} val
             * @returns {Object}
             */
            getSavedResponse: function() {},

            /**
             * Saves response
             *
             * @public
             * @param {String} val
             * @param {Object} response
             */
            saveResponse: function() {},

            /**
             * Called to render suggestions. Used to define interface only.
             * Rendering is difficult to make generic, best to leave this to extending prototypes.
             *
             * @public
             * @param {Object} res - results object
             */
            renderSuggestions: function() {},

            /**
             * Disables autocomplete. Useful for shared inputs.
             * i.e The selection of a radio button may disable the instance
             * @Public
             */
            disable: function() {
                this.disabled = true;
            },

            /**
             * Enables autocomplete. Useful for shared inputs.
             * i.e The selection of a radio button may disable the instance
             * @Public
             */
            enable: function() {
                this.disabled = false;
            },

            /**
             * Sets instance variables from options object
             * to do: make function create getters and setters
             * @public
             * @param {Object} options
             */
            set: function(options) {
                for (var name in options) {
                    // safeguard to stop looping up the inheritance chain
                    if (options.hasOwnProperty(name)) {
                        this[name] = options[name];
                    }
                }
            },

            /**
             * Adds value to input field
             * @public
             * @param {String} value
             */
            completeField: function(value) {
                if (value) {
                    this.field.val(value).focus();
                    this.field.trigger("change");
                }
            },

            /**
             * Returns the text from the start of the field up to the end of
             * the position where suggestions are generated from.
             */
            textToSuggestionCursorPosition: function () {
                return this.field.val();
            },


            /**
             * An ajax request filter that only allows one request at a time. If there is another it will abort then issue
             * the new request.
             *
             * @param options - jQuery formatted ajax options
             */
            _makeRequest: function (options) {
                var that = this,
                    requestParams = Objects.copyObject(options);

                // if we have we are still waiting for an old request, lets abort it as we are firing a new
                if (this.pendingRequest) {
                    this.pendingRequest.abort();
                }

                requestParams.complete = function () {
                    that.pendingRequest = null;
                };

                requestParams.error = function (xhr) {

                    // We abort stale requests and this subsequently throws an error so we need to check if the request is aborted first.
                    // We detect this using xhr.aborted property for native XHR requests but for "Microsoft.XMLHTTP" we use the status code, which is 0.
                    // Status code is set to 0 when it is an unknown error so sense to fail silently.
                    if (!xhr.aborted && xhr.status !== 0 && options.error) {
                        options.error.apply(this, arguments);
                    }
                };

                return this.pendingRequest = SmartAjax.makeRequest(requestParams);
            },

            /**
             * Allows users to navigate/select suggestions using the keyboard
             * @public
             */
             addSuggestionControls: function(suggestionNodes) {

                // reference to this for closures
                var that = this;

                /**
                 * Make sure the index is within the threshold
                 * Looks ugly! Has to be a better way.
                 * @private
                 * @param {Integer} idx
                 * @param {Integer} max
                 * @return {Integer} valid threshold
                 */
                var evaluateIndex = function(idx, max) {
                    var minBoundary = (that.autoSelectFirst === false) ? -1 : 0;
                    if (that.allowArrowCarousel) {
                        if (idx > max) {
                            return minBoundary;
                        } else if (idx < minBoundary) {
                            return max;
                        } else {
                            return idx;
                        }
                    }
                    else {
                        if (idx > max) {
                            return max;
                        } else if (idx < minBoundary) {
                            that.responseContainer.scrollTop(0);
                            return minBoundary;
                        } else {
                            return idx;
                        }
                    }
                };

                /**
                 * Highlights focused node and removes highlight from previous.
                 * Actual highlight styles to come from css, adding and removing classes here.
                 * @private
                 * @param {Integer} idx - Index of node to be highlighted
                 */
                var setActive = function(idx) {

                        // if nothing is selected, select the first suggestion
                        if (that.selectedIndex !== undefined && that.selectedIndex > -1) {
                            that.suggestionNodes[that.selectedIndex][0].removeClass("active");
                        }
                        that.selectedIndex = evaluateIndex(idx, that.suggestionNodes.length-1);
                        if (that.selectedIndex > -1) {
                            that.suggestionNodes[that.selectedIndex][0].addClass("active");
                        }
                };

                 /**
                  * Checks to see if there is actually a suggestion in focus before attempting to use it
                  * @private
                  * @returns {boolean}
                  */
                 var evaluateIfActive = function() {
                    return that.suggestionNodes && that.suggestionNodes[that.selectedIndex] &&
                           that.suggestionNodes[that.selectedIndex][0].hasClass("active");
                 };


                /**
                 * When the responseContainer (dropdown) is visible listen for keyboard events
                 * that represent focus or selection.
                 * @private
                 * @param {Object} e - event object
                 */
                var keyPressHandler = function(e) {
                    // only use keyboard events if dropdown is visible
                    if (that.responseContainer.is(":visible")) {
                        // if enter key is pressed check that there is a node selected, then hide dropdown and complete field
                        if (e.keyCode === 13) {
                            if (evaluateIfActive() && !that.pendingRequest) {
                                that.completeField(that.suggestionNodes[that.selectedIndex][1]);
                            }
                            e.preventDefault();
                            // hack - stop propagation to prevent dialog from submitting. Looking for eg JIRA.Dropdown.current doesn't work.
                            e.stopPropagation();
                        }
                    }
                };

                /**
                * sets focus on suggestion nodes using the "up" and "down" arrows
                * These events need to be fired on mouseup as modifier keys don't register on keypress
                * @private
                * @param {Object} e - event object
                */
                var keyboardNavigateHandler = function(e) {

                    // only use keyboard events if dropdown is visible
                    if (that.responseContainer.is(":visible")) {

                        // keep cursor inside input field
                        if (that.field[0] !== document.activeElement){
                            that.field.focus();
                        }
                        // move selection down when down arrow is pressed
                        if (e.keyCode === 40) {
                            setActive(that.selectedIndex + 1);
                            if (that.selectedIndex >= 0) {
                                // move selection up when up arrow is pressed
                                var containerHeight = that.responseContainer.height();
                                var bottom = that.suggestionNodes[that.selectedIndex][0].position().top + that.suggestionNodes[that.selectedIndex][0].outerHeight() ;

                                if (bottom - containerHeight > 0){
                                    that.responseContainer.scrollTop(that.responseContainer.scrollTop() + bottom - containerHeight + 2);
                                }
                            } else {
                                that.responseContainer.scrollTop(0);
                            }
                            e.preventDefault();
                        } else if (e.keyCode === 38) {
                            setActive(that.selectedIndex-1);
                            if (that.selectedIndex >= 0) {
                                // if tab key is pressed check that there is a node selected, then hide dropdown and complete field
                                var top = that.suggestionNodes[that.selectedIndex][0].position().top;
                                if (top < 0){
                                    that.responseContainer.scrollTop(that.responseContainer.scrollTop() + top - 2);
                                }
                            }
                            e.preventDefault();
                        } else if (e.keyCode === 9) {
                            if (evaluateIfActive()) {
                                that.completeField(that.suggestionNodes[that.selectedIndex][1]);
                                e.preventDefault();
                            } else {
                                that.dropdownController.hideDropdown();
                            }
                        }
                    }
                };

                if (suggestionNodes.length) {

                    this.selectedIndex = 0;
                    this.suggestionNodes = suggestionNodes;

                    for (var i=0; i < that.suggestionNodes.length; i++) {
                        var eventData = { instance: this, index: i };
                        this.suggestionNodes[i][0]
                            .bind("mouseover", eventData, activate)
                            .bind("mouseout", eventData, deactivate)
                            .bind("click", eventData, complete);
                    }

                    // make sure we don't bind more than once
                    if (!this.keyboardHandlerBinded) {
                        jQuery(this.field).keypress(keyPressHandler);
                        jQuery(this.field).keydown(keyboardNavigateHandler);
                        this.keyboardHandlerBinded = true;
                    }

                    // automatically select the first in the list
                    if(that.autoSelectFirst === false) {
                        setActive(-1);
                    } else {
                        setActive(0);
                    }

                    // sets the autocomplete singleton infocus var to this instance
                    // is used to toggle event propagation. In short, the instance that it is set to will not hide the
                    // dropdown each time you click the input field
                    inFocus = this;
                }

                function activate(event) {
                    if (that.dropdownController.displayed) {
                        setActive(event.data.index);
                    }
                }
                function deactivate(event) {
                    if (event.data.index === 0) {
                        that.selectedIndex = -1;
                    }
                    jQuery(this).removeClass("active");
                }
                function complete(event) {
                    that.completeField(that.suggestionNodes[event.data.index][1]);
                }
            },


            /**
             * Uses jquery empty command, this is VERY important as it unassigns handlers
             * used for mouseover, click events which expose an opportunity for memory leaks
             * @public
             */
            clearResponseContainer: function() {
                this.responseContainer.empty();
                this.suggestionNodes = undefined;
            },

            delay: delay,

            /**
             * Builds HTML container for suggestions.
             * Positions container top position to be that of the field height
             * @public
             */
            buildResponseContainer: function() {
                var inputParent = this.field.parent().addClass('atlassian-autocomplete');
                this.responseContainer = jQuery(document.createElement("div"));
                this.responseContainer.addClass("suggestions");
                this.positionResponseContainer();
                this.responseContainer.appendTo(inputParent);
            },

            positionResponseContainer: function() {
                this.responseContainer.css({ top: this.field.outerHeight() });
            },

            /**
             * Validates the keypress by making sure the field value is beyond the set threshold and the key was either an
             * up or down arrow
             * @public
             * @param {Object} e - event object
             */
            keyUpHandler: (function () {
                function callback() {
                    if (!this.responseContainer) {
                        this.buildResponseContainer();
                    }
                    // send value to dispatcher to check if we have already got the response or if we need to go
                    // back to the server
                    this.dispatcher(this.field.val());
                }

                return function (e) {
                    // only initialises once the field length is past set length
                    if (this.field.val().length >= this.minQueryLength) {
                        // don't do anything if the key pressed is "enter" or "down" or "up" or "right" "left"
                        if (!(e.keyCode in INVALID_KEYS) || (this.responseContainer && !this.responseContainer.is(":visible") && (e.keyCode === 38 || e.keyCode === 40))) {
                            callback.call(this);
                        }
                    }
                    return e;
                };
            })(),

            /**
             * Adds in methods via AOP to handle multiple selections
             * @Public
             */
            addMultiSelectAdvice: function(delim) {

                // reference to this for closures
                var that = this;

                /**
                 * Alerts user if value already exists
                 * @private
                 * @param {String} val - value that already exists, will be displayed in message to user.
                 */
                var alertUserValueAlreadyExists = function(val) {

                    // check if there is an existing alert before adding another
                    if (!alertUserValueAlreadyExists.isAlerting) {

                        alertUserValueAlreadyExists.isAlerting = true;

                        // create alert node and append it to the input field's parent, fade it in then out with a short
                        // delay in between.
                        //TODO: JRA-1800 - Needs i18n!
                        var userAlert = jQuery(document.createElement("div"))
                        .css({"float": "left", display: "none"})
                        .addClass("warningBox")
                        .html("Oops! You have already entered the value <em>" + val + "</em>" )
                        .appendTo(that.field.parent())
                        .show("fast", function(){
                            // display message for 4 seconds before fading out
                            that.delay(function(){
                                userAlert.hide("fast",function(){
                                    // removes element from dom
                                    userAlert.remove();
                                    alertUserValueAlreadyExists.isAlerting = false;
                                });
                            }, 4);
                        });
                    }
                };

              // rather than request the entire field return the last comma seperated value
                jQuery.aop.before({target: this, method: "dispatcher"}, function(innvocation){
                    // matches everything after last comma
                    var val = this.field.val();
                    innvocation[0] = jQuery.trim(val.slice(val.lastIndexOf(delim) + 1));
                    return innvocation;
                });

                // rather than replacing this field just append the new value
                jQuery.aop.before({target: this, method: "completeField"}, function(args){
                    var valueToAdd = args[0],
                    // create array of values
                    untrimmedVals = this.field.val().split(delim);
                    // trim the values in the array so we avoid extra spaces being appended to the usernames - see JRA-20657
                    var trimmedVals = jQuery(untrimmedVals).map(function() {
                            return jQuery.trim(this);
                       }).get();
                    // check if the value to append already exists. If it does then call alert to to tell user and sets
                    // the last value to "". The value to add will either appear:
                    // 1) at the start of the string
                    // 2) after some whitespace; or
                    // 3) directly after the delimiter
                    // It is assumed that the value is delimited by the delimiter character surrounded by any number of spaces.
                    if (!this.allowDuplicates && new RegExp("(?:^|[\\s" + delim + "])" + valueToAdd + "\\s*" + delim).test(this.field.val())) {
                        alertUserValueAlreadyExists(valueToAdd);
                        trimmedVals[trimmedVals.length-1] = "";
                    } else {
                        // add the new value to the end of the array and then an empty value so we
                        // can get an extra delimiter at the end of the joined string
                        trimmedVals[trimmedVals.length-1] = valueToAdd;
                        trimmedVals[trimmedVals.length] = "";
                    }

                    // join the array of values with the delimiter plus an extra space to make the list of values readable
                    args[0] = trimmedVals.join(delim.replace(/([^\s]$)/,"$1 "));

                    return args;
                });
            },


            /**
             * Adds and manages state of dropdown control
             * @Public
             */
            addDropdownAdvice: function() {
                var that = this;

                // add dropdown functionality to response container
                jQuery.aop.after({target: this, method: "buildResponseContainer"}, function(args){
                    this.dropdownController = JIRA.Dropdown.AutoComplete({target: this, method: "renderSuggestions"}, this.responseContainer);

                    jQuery.aop.after({ target: this.dropdownController, method: "hideDropdown" }, function () {
                        this.dropdown.removeClass("dropdown-ready");
                    });

                    return args;
                });

                // display dropdown afer suggestions are updated
                jQuery.aop.after({target: this, method: "renderSuggestions"}, function(args){
                    if (args && args.length > 0) {
                        this.dropdownController.displayDropdown();

                        if (this.maxHeight && this.dropdownController.dropdown.prop("scrollHeight") > this.maxHeight) {
                            this.dropdownController.dropdown.css({
                                height: this.maxHeight,
                                overflowX: "visible",
                                overflowY: "scroll"
                            });
                        } else if (this.maxHeight) {
                            this.dropdownController.dropdown.css({
                                height: "",
                                overflowX: "",
                                overflowY: ""
                            });
                        }
                        this.dropdownController.dropdown.addClass("dropdown-ready");
                    } else {
                        this.dropdownController.hideDropdown();
                    }
                    return args;
                });

                // hide dropdown after suggestion value is applied to field
                jQuery.aop.after({target: this, method: "completeField"}, function(args){
                    this.dropdownController.hideDropdown();
                    return args;
                });

                jQuery.aop.after({target: this, method: "keyUpHandler"}, function(e) {
                    // only initialises once the field length is past set length
                    if ((!(this.field.val().length >= this.minQueryLength) || e.keyCode === 27)
                            && this.dropdownController && this.dropdownController.displayed) {
                        this.dropdownController.hideDropdown();
                        if (e.keyCode === 27) {
                            e.stopPropagation();
                        }
                    }
                    return e;
                });
            },

            /**
             * Initialises autocomplete by setting options, and assigning event handler to input field.
             * @param {Object} options
             * @constructs
             */
            init: function(options) {
                var that = this;
                this.set(options);
                this.field = this.field || jQuery("#" + this.fieldID);
                 // turn off browser default autocomplete
                this.field.attr("autocomplete","off")
                .keyup(function(e){
                    if (!that.disabled) {
                        that.keyUpHandler(e);
                    }
                })
                .keydown(function (e) {
                    var ESC_KEY = 27;
                    // do not clear field in IE
                    if (e.keyCode === ESC_KEY && that.responseContainer && that.responseContainer.is(":visible")) {
                        e.preventDefault();
                    }
                })
                // this will stop the dropdown with the suggestions hiding whenever you click the field
                .click(function(e){
                    if (inFocus === that) {
                        e.stopPropagation();
                    }
                })
                .blur(function () {
                    // we don't want the request to come back and show suggestions if we have already moved away from field
                    if (that.pendingRequest) {
                        that.pendingRequest.abort();
                    }
                });

                this.addDropdownAdvice();

                if (options.delimChar) {
                    this.addMultiSelectAdvice(options.delimChar);
                }
            }
        };

    }();

});

/** Preserve legacy namespace
 @deprecated jira.widget.autocomplete */
AJS.namespace("jira.widget.autocomplete", null, require('jira/autocomplete/autocomplete'));
AJS.namespace('JIRA.AutoComplete', null, require('jira/autocomplete/autocomplete'));
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/RESTAutoComplete.js' */
define('jira/autocomplete/rest-autocomplete', [
    'jira/autocomplete/autocomplete',
    'jira/util/objects'
], function(
    AutoComplete,
    Objects
) {
    /**
     * Designed for prototypical inheritance !!Abstract only
     * @class RESTAutoComplete
     * @extends AutoComplete
     * @abstract
     */
    return function() {

        /** @lends RESTAutoComplete.prototype */
        var that = Objects.begetObject(AutoComplete);

       /**
        * Checks whether a saved version (cached) of the request exists, if not performs a request and saves response,
        * then dispatches saved response to <em>renderSuggestions</em> method.
        * @param {String} reqFieldVal
        */
        that.dispatcher = function(reqFieldVal) {

            // reference to "this" for use in closures
             var that = this;

             if (reqFieldVal.length < this.minQueryLength) {
                 return;
             }

             if (!this.getSavedResponse(reqFieldVal)) {
                // Add a delay so that we don't go the server for every keypress,
                // some people type fast and may have already typed an entire word by the time the server comes
                // back with a response

                this.delay(function(){
                    var params = that.getAjaxParams();
                    params.data.query = reqFieldVal;
                    params.success = function(data){
                        // for use later so we don't have to go back to the server for the same query
                        that.saveResponse(reqFieldVal, data);
                        // creates html elements from JSON object
                        that.responseContainer.scrollTop(0);
                        that.renderSuggestions(data);

                    };
                    that._makeRequest(params);

                }, that.queryDelay);
            } else {
                that.renderSuggestions(that.getSavedResponse(reqFieldVal));
                that.responseContainer.scrollTop(0);
            }
        };


        that.getAjaxParams = function(){};

        /**
         * Gets cached response from <em>requested</em> object
         * @param {String} val
         * @returns {Object}
         */
        that.getSavedResponse = function(val) {
            if (!this.requested) {
                this.requested = {};
            }
            return this.requested[val];
        };

        /**
         * Saves response to <em>requested</em> object
         * @param {String} val
         * @param {Object} response
         */
        that.saveResponse = function(val, response) {
            if (typeof val === "string" && typeof response === "object") {
                if (!this.requested) {
                    this.requested = {};
                }
                this.requested[val] = response;
            }
        };

        return that;

    }();

});

/** Preserve legacy namespace
 @deprecated jira.widget.autocomplete.REST */
AJS.namespace("jira.widget.autocomplete.REST", null, require('jira/autocomplete/rest-autocomplete'));
AJS.namespace('JIRA.RESTAutoComplete', null, require('jira/autocomplete/rest-autocomplete'));
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/IssueAutoComplete.js' */
define('jira/autocomplete/issue-autocomplete', [
    'jira/autocomplete/rest-autocomplete',
    'jira/util/objects',
    'jquery'
], function(
    RESTAutoComplete,
    Objects,
    jQuery
) {
    /**
     * @constructor IssueAutoComplete
     * @extends RESTAutoComplete
     * @param options
     */
    var IssueAutoComplete = function(options) {

        /** @lends IssueAutoComplete.prototype */
        var that = Objects.begetObject(RESTAutoComplete);

        that.getAjaxParams = function(){
            return {
                url: contextPath + "/rest/api/2/issue/picker",
                data: options.ajaxData,
                dataType: "json",
                type: "GET"
            };
        };

        /**
         * @param {Object} response
         */
        that.renderSuggestions = function(response) {

            var resultsContainer, suggestionNodes = [];

            // remove previous results
            this.clearResponseContainer();

            if (response && response.sections && response.sections.length > 0) {

                resultsContainer = jQuery("<ul/>").appendTo(this.responseContainer);

                jQuery(response.sections).each(function() {
                    var section = this;
                    var subSection = jQuery("<div/>").attr("id", options.fieldID + "_s_" + section.id).addClass("yag").text(section.label);
                    if (section.sub){
                        subSection.append(jQuery("<span/>").addClass("yagt").text("(" + section.sub + ")"));
                    }
                    resultsContainer.append(jQuery("<li/>").append(subSection).mouseover(function(){
                            jQuery(this).addClass("active");
                        }).mouseout(function(){
                            jQuery(this).removeClass("active");
                        })
                    );

                    if (section.msg){
                        // add message node
                        var msg = jQuery("<div/>").attr("id", options.fieldID + "_i_" + section.id + "_n").addClass("yad").text(section.msg);
                        resultsContainer.append(jQuery("<li/>").append(msg).mouseover(function(){
                                jQuery(this).addClass("active");
                            }).mouseout(function(){
                                jQuery(this).removeClass("active");
                            })
                        );
                    }

                    if (section.issues && section.issues.length > 0){
                        jQuery(section.issues).each(function(){
                            // add issue
                            var imgUrl;
                            if (/^http/.test(this.img)){
                                imgUrl = this.img;
                            } else {
                                imgUrl =  contextPath + this.img;
                            }
                            var issueNode = jQuery("<li/>").append(
                                jQuery("<div/>").attr("id", options.fieldID + "_i_" + section.id + "_" + this.key).addClass("yad").append(
                                    jQuery("<table/>").addClass("yat").attr({
                                        cellpadding: "0",
                                        cellspacing: "0"
                                    }).append(
                                        jQuery("<tr/>").append(
                                            jQuery("<td/>").append(
                                                jQuery("<img/>").attr("src", imgUrl)
                                            )
                                        ).append(
                                             jQuery("<td/>").append(
                                                jQuery("<div/>").addClass("yak").html(this.keyHtml)
                                            )
                                        ).append(
                                             jQuery("<td/>").css("width", "100%").html(this.summary)
                                        )
                                    )
                                )
                            );

                            resultsContainer.append(issueNode);
                            suggestionNodes.push([issueNode, this.key]);
                        });
                    }
                });

                that.addSuggestionControls(suggestionNodes);

                return suggestionNodes;

            }
        };
        options.minQueryLength = 1;
        options.queryDelay = 0.25;

        that.init(options);

        return that;

    };

    /**
     * Iterates over the entire DOM to find issue autocomplete controls to initialize, and initializes them.
     * @static
     */
    IssueAutoComplete.init = function(){

        jQuery("fieldset.issue-picker-params").each(function(){
            var params = JIRA.parseOptionsFromFieldset(jQuery(this)),
                $container = jQuery("#" + params.fieldId + "-container").add("#" + params.fieldName + "_container");

            $container.find("a.popup-trigger").click(function(e){
                var url = contextPath + '/secure/popups/IssuePicker.jspa?';
                url += 'currentIssue=' + params.currentIssueKey + '&';
                url += 'singleSelectOnly=' + params.singleSelectOnly + '&';
                url += 'showSubTasks=' + params.showSubTasks + '&';
                url += 'showSubTasksParent=' + params.showSubTaskParent;
                if (params.currentProjectId && params.currentProjectId !== "")
                {
                    url += '&selectedProjectId=' + params.currentProjectId;
                }

                /**
                 * Provide a callback to the window for execution when the user selects an issue. This implies that only one
                 * popup can be displayed at a time.
                 *
                 * @param keysMap the issue keys selected.
                 */
                JIRA.IssuePicker.callback = function(keysMap){
                    var $formElement, keys = [];

                    keysMap = JSON.parse(keysMap);

                    if (params.fieldId && keys) {
                        $formElement = jQuery("#" + params.fieldId);
                        if ($formElement){
                            jQuery.each(keysMap, function () {
                                keys.push(this.value);
                            });
                            $formElement.val(keys.join(", "));
                        }
                    }
                };

                var vWinUsers = window.open(url, 'IssueSelectorPopup', 'status=no,resizable=yes,top=100,left=200,width=620,height=500,scrollbars=yes,resizable');
                vWinUsers.opener = self;
                vWinUsers.focus();
                e.preventDefault();
            });

            if (!params.fieldId) {
                params.fieldId = params.fieldName;
            }

            if (params.issuePickerEnabled === true){
                IssueAutoComplete({
                    fieldID: params.fieldId,
                    delimChar: params.singleSelectOnly === true ? undefined : ",",
                    ajaxData: params
                });
            }
        });
    };

    return IssueAutoComplete;
});

/** Preserve legacy namespace
 @deprecated jira.widget.autocomplete.Issues */
AJS.namespace("jira.widget.autocomplete.Issues", null, require('jira/autocomplete/issue-autocomplete'));
AJS.namespace('JIRA.IssueAutoComplete', null, require('jira/autocomplete/issue-autocomplete'));
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/UserAutoComplete.js' */
define('jira/autocomplete/user-autocomplete', [
    'jira/autocomplete/rest-autocomplete',
    'jira/data/parse-options-from-fieldset',
    'jira/util/browser',
    'jira/util/elements',
    'jira/util/objects',
    'jquery'
], function(
    RESTAutoComplete,
    parseOptionsFromFieldset,
    Browser,
    Elements,
    Objects,
    jQuery
) {
    /**
     * User picker - converted from YUI based autocomplete. There is some code in here that probably isn't necessary,
     * if removed though selenium tests would need to be re-written.
     * @class UserAutoComplete
     * @extends RESTAutoComplete
     * @param {Object} options
     */
    var UserAutoComplete = function(options) {

        /** @lends UserAutoComplete.prototype */
        var that = Objects.begetObject(RESTAutoComplete);

        that.getAjaxParams = function(){
            return {
                url: contextPath + "/rest/api/1.0/users/picker",
                data: {
                    fieldName: options.fieldID,
                    fieldConfigId: options.fieldConfigID,
                    projectId: options.projectId
                },
                dataType: "json",
                type: "GET"
            };
        };

        /**
         * Returns true if the field's containing form has the 'submitted' class.
         *
         * @param field The reference to the field whose form to check for the 'submitted' class.
         * @return {Boolean}
         */
        function fieldsFormHasBeenSubmitted(field) {
            var submitting = false,
                form = field.closest("form");

            if (form.length && form.hasClass("submitting")) {
                submitting = true;
            }

            return submitting;
        }

        /**
         * Create html elements from JSON object
         * @param {Object} response - JSON object
         * @returns {Array} Multidimensional array, one column being the html element and the other being its
         * corresponding complete value.
         */
        that.renderSuggestions = function(response) {

            if (fieldsFormHasBeenSubmitted(this.field) || !Browser.isSelenium() && !Elements.elementIsFocused(this.field)) {
                return false;
            }

            var resultsContainer, suggestionNodes = [];

            // remove previous results
            this.clearResponseContainer();


            if (response && response.users && response.users.length > 0) {

                resultsContainer = jQuery("<ul/>").appendTo(this.responseContainer);

                jQuery(response.users).each(function() {

                    // add html element and corresponding complete value  to sugestionNodes Array
                    suggestionNodes.push([jQuery("<li/>")
                    .html(this.html)
                    .appendTo(resultsContainer), this.name]);

                });
            }

            if (response.footer) {
                this.responseContainer.append(jQuery("<div/>")
                .addClass("yui-ac-ft")
                .html(response.footer)
                .css("display","block"));
            }

            if (suggestionNodes.length > 0) {
                that.addSuggestionControls(suggestionNodes);
                jQuery('.atlassian-autocomplete div.yad, .atlassian-autocomplete .labels li').textOverflow({
                    autoUpdate: true
                });
            }

            return suggestionNodes;

        };

        // Use autocomplete only once the field has at least 2 characters
        options.minQueryLength = 2;

        // wait 1/4 of after someone starts typing before going to server
        options.queryDelay = 0.25;

        that.init(options);

        return that;

    };

    /**
     * Searches for and initialises User autocomplete controls within a DOM context.
     * @param {HTMLElement|String} [parent] - element or CSS selector within which
     * autocomplete controls will be searched for. Defaults to entire DOM.
     * @static
     */
    UserAutoComplete.init = function(parent){
        jQuery("fieldset.user-picker-params", parent).each(function(){
            var params = parseOptionsFromFieldset(jQuery(this)),
                field = (params.fieldId || params.fieldName),
                $container = jQuery("#" + field + "_container");


            $container.find("a.popup-trigger").click(function(e){
                var url = contextPath,
                    vWinUsers;

                e.preventDefault();

                if (!params.formName)
                {
                    params.formName = $container.find("#" + field).parents("form").attr("name");
                }

                if (params.actionToOpen) {
                    url = url + params.actionToOpen;
                } else {
                    url = url + '/secure/popups/UserPickerBrowser.jspa';
                }
                url += '?formName=' + params.formName + '&';
                url += 'multiSelect=' + params.multiSelect + '&';
                url += 'decorator=popup&';
                url += 'element=' + field;

                if (params.fieldConfigId) {
                    url += '&fieldConfigId=' + params.fieldConfigId;
                }
                if (params.projectId) { // an array of project ids
                    if (jQuery.isArray(params.projectId)) {
                        for (var projectId in params.projectId) {
                            url += '&projectId=' + projectId;
                        }
                    } else {
                        url += '&projectId=' + params.projectId;
                    }
                }

                vWinUsers = window.open(url, 'UserPicker', 'status=yes,resizable=yes,top=100,left=100,width=800,height=750,scrollbars=yes');
                vWinUsers.opener = self;
                vWinUsers.focus();
            });


            if (params.userPickerEnabled === true ){
                UserAutoComplete({
                    field: parent ? parent.find("#" + field) : null,
                    fieldID: field,
                    fieldConfigID: params.fieldConfigId,
                    projectId: params.projectId,
                    delimChar: params.multiSelect === false ? undefined : ",",
                    ajaxData: {
                        fieldName: params.fieldName
                    }
                });
            }
        });
    };

    return UserAutoComplete;
});

/** Preserve legacy namespace
    @deprecated jira.widget.autocomplete.Users */
AJS.namespace("jira.widget.autocomplete.Users", null, require('jira/autocomplete/user-autocomplete'));
AJS.namespace('JIRA.UserAutoComplete', null, require('jira/autocomplete/user-autocomplete'));
;
;
/* module-key = 'jira.webresources:autocomplete', location = '/includes/jira/autocomplete/initAutoCompleteFields.js' */
(function() {
    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            JIRA.UserAutoComplete.init(context);
            JIRA.IssueAutoComplete.init(context);
        }
    });

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            AJS.$("fieldset.user-searcher-params", context).each(function () {
                var params = JIRA.parseOptionsFromFieldset(AJS.$(this)),
                    $container = AJS.$("#" + params.fieldId + "_container", context);

                if (params.userPickerEnabled === true) {
                    var autocompleter = JIRA.UserAutoComplete({
                        fieldID: params.fieldId,
                        delimChar: params.multiSelect === true ? "," : undefined,
                        ajaxData: {
                            fieldName: params.fieldName
                        }
                    });
                }

                var setupFields = function (related) {
                    var field = AJS.$("#" + params.fieldId, context);
                    var userImage = AJS.$("#" + params.fieldId + "Image", context);
                    var groupImage = AJS.$("#" + params.fieldId + "GroupImage", context);
                    var fieldDesc = AJS.$("#" + params.fieldId + "_desc", context);
                    if (related === "select.list.none") {
                        field.val("").attr("disabled", "true");
                        userImage.hide();
                        groupImage.hide();
                        fieldDesc.hide();
                    } else {
                        field.removeAttr("disabled");
                        if (related === "select.list.group") {
                            userImage.hide();
                            groupImage.show();
                            if (params.userPickerEnabled === true) {
                                autocompleter.disable();
                                fieldDesc.hide();
                            }
                        } else {
                            userImage.show();
                            groupImage.hide();
                            if (params.userPickerEnabled === true) {
                                autocompleter.enable();
                                fieldDesc.show();
                            }
                        }
                    }
                };

                AJS.$("#" + params.userSelect, context).change(function () {
                    var related = AJS.$(this).find("option:selected").attr("rel");
                    setupFields(related);
                }).find("option:selected").each(function () {
                    setupFields(AJS.$(this).attr("rel"));
                });

                $container.find("a.user-popup-trigger").click(function (e) {
                    var url = contextPath + '/secure/popups/UserPickerBrowser.jspa?';
                    url += 'formName=' + params.formName + '&';
                    url += 'multiSelect=' + params.multiSelect + '&';
                    url += 'decorator=popup&';
                    url += 'element=' + params.fieldId;

                    var vWinUsers = window.open(url, 'UserPicker', 'status=yes,resizable=yes,top=100,left=100,width=800,height=750,scrollbars=yes');
                    vWinUsers.opener = self;
                    vWinUsers.focus();
                    e.preventDefault();
                });

                $container.find("a.group-popup-trigger").click(function (e) {
                    var url = contextPath + '/secure/popups/GroupPickerBrowser.jspa?';
                    url += 'formName=' + params.formName + '&';
                    url += 'multiSelect=' + params.multiSelect + '&';
                    url += 'decorator=popup&';
                    url += 'element=' + params.fieldId;

                    var vWinUsers = window.open(url, 'GroupPicker', 'status=yes,resizable=yes,top=100,left=100,width=800,height=750,scrollbars=yes');
                    vWinUsers.opener = self;
                    vWinUsers.focus();
                    e.preventDefault();
                });
            });
        }
    });
})();
;
;
/* module-key = 'com.atlassian.jira.gadgets:project-filter-autocomplete-component', location = 'static/components/project-filter-autocomplete/project-filter-autocomplete.soy' */
// This file was automatically generated from project-filter-autocomplete.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.ProjectFilterAutoComplete == 'undefined') { JIRA.DashboardItem.ProjectFilterAutoComplete = {}; }
if (typeof JIRA.DashboardItem.ProjectFilterAutoComplete.Templates == 'undefined') { JIRA.DashboardItem.ProjectFilterAutoComplete.Templates = {}; }


JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.ConfigurationField = function(opt_data, opt_ignored) {
  var output = '';
  var prefixedId__soy3 = opt_data.prefix + opt_data.id;
  output += '<div class="field-group"><label for="' + soy.$$escapeHtml(prefixedId__soy3) + '">' + soy.$$escapeHtml("Project or Saved Filter") + '<span class="aui-icon icon-required"> ' + soy.$$escapeHtml("required") + '</span></label><div class="builder-container"><input type="hidden" name="name" ' + ((opt_data.selectionName) ? 'value="' + soy.$$escapeHtml(opt_data.selectionName) + '"' : '') + '><input type="hidden" name="type" ' + ((opt_data.selectionType) ? 'value="' + soy.$$escapeHtml(opt_data.selectionType) + '"' : '') + '><input type="hidden" name="id" ' + ((opt_data.selectionID) ? 'value="' + soy.$$escapeHtml(opt_data.selectionID) + '"' : '') + '><span class="filterpicker-value-name field-value">' + ((opt_data.selectionName) ? soy.$$filterNoAutoescape(opt_data.selectionName) : soy.$$escapeHtml("No Filter/Project selected")) + '</span><div class="quick-find"><input class="text" id="' + soy.$$escapeHtml(prefixedId__soy3) + '" placeholder="' + soy.$$escapeHtml("Search") + '"><span class="inline-error"></span></div><input class="hidden" id="filter_' + soy.$$escapeHtml(prefixedId__soy3) + '_id"/><input class="hidden" id="filter_' + soy.$$escapeHtml(prefixedId__soy3) + '_name"/></div><div class="projectOrFilter-error error"></div><div class="description">' + soy.$$escapeHtml("Project or saved filter to use as the basis for the graph.") + '<br/><a id="filter_' + soy.$$escapeHtml(prefixedId__soy3) + '_advance" class="advanced-search" href="#" title="' + soy.$$escapeHtml("Click here to select/change filter or project.") + '" target="_parent">' + soy.$$escapeHtml("Advanced Search") + '</a></div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.ConfigurationField.soyTemplateName = 'JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.ConfigurationField';
}


JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.SuggestionSection = function(opt_data, opt_ignored) {
  return '<div class=\'suggestionBlock\'><h5>' + soy.$$escapeHtml(opt_data.sectionTitle) + '</h5><ul class=\'aui-list-section\'></ul></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.SuggestionSection.soyTemplateName = 'JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.SuggestionSection';
}


JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.SuggestionProject = function(opt_data, opt_ignored) {
  return '<li class="aui-list-item" data-type="project" data-id="' + soy.$$escapeHtml(opt_data.suggestion.id) + '"><a href="#" class="aui-list-item-link aui-indented-link" target="_parent">' + soy.$$filterNoAutoescape(opt_data.suggestion.html) + '(' + soy.$$escapeHtml(opt_data.suggestion.key) + ')</a></li>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.SuggestionProject.soyTemplateName = 'JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.SuggestionProject';
}


JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.SuggestionFilter = function(opt_data, opt_ignored) {
  return '<li class="aui-list-item" data-type="filter" data-id="' + soy.$$escapeHtml(opt_data.suggestion.id) + '"><a href="#" class="aui-list-item-link aui-indented-link" target="_parent">' + soy.$$filterNoAutoescape(opt_data.suggestion.nameHtml) + '</a></li>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.SuggestionFilter.soyTemplateName = 'JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.SuggestionFilter';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:project-filter-autocomplete-component', location = 'static/components/project-filter-autocomplete/ProjectFilterAutoComplete.js' */
define('jira-dashboard-items/components/autocomplete/project-filter-autocomplete', [
    'jira/autocomplete/rest-autocomplete',
    'jira/util/events',
    'jira/util/objects',
    'jquery'
], function(
    RESTAutoComplete,
    Events,
    Objects,
    $
) {

    var Templates = JIRA.DashboardItem.ProjectFilterAutoComplete.Templates;

    /**
     * Allows the user to open the advanced search window for the filter picker
     * @param options
     */
    var initialiseAdvancedSearch = function (options) {
        var parentElement = options.parentElement;
        var fieldID = options.fieldID;

        var updateSelect = function () {
            var id = $("#filter_" + fieldID + "_id").attr("value");
            var type = id.substr(0, id.indexOf('-'));
            id = id.substr(id.indexOf('-') + 1);
            var label = $("#filter_" + fieldID + "_name").text();

            parentElement.find("input[name=type]").val(type);
            parentElement.find("input[name=id]").val(id);
            parentElement.find("input[name=name]").val(label);
            parentElement.find(".filterpicker-value-name").text(label).addClass('success');

            Events.trigger("gadget-advancedprojectfilter-selected");
        };

        /*
         * Listening for DOMAttrModified works in all browsers except WEBKIT.  MutationObservers work for all
         * browsers except IE9 and IE10.  So I am using a combination of both to listen for the updates from the
         * advanced filter picker.  This does mean that some browsers will pick up the change twice, so we must
         * ensure that updateSelect can be executed twice without any negative side affects.
         */
        var advancedFilterResultIdField = parentElement.find("#filter_" + fieldID + "_id");
        advancedFilterResultIdField.on("DOMAttrModified", updateSelect);
        if (window.MutationObserver || window.WebkitMutationObserver || window.MozMutationObserver) {
            observer = new MutationObserver(updateSelect);
            observer.observe(advancedFilterResultIdField[0], {attributes: true});
        }

        parentElement.find("#filter_" + fieldID + "_advance").click(function (e) {
            var url = AJS.contextPath() + "/secure/FilterPickerPopup.jspa?showProjects=true&field=" + fieldID;
            var windowVal = "filter_" + fieldID.replace(new RegExp('-', 'g'), '') + "_window";
            var prefs = "width=800, height=500, resizable, scrollbars=yes";
            window.open(url, windowVal, prefs).focus();

            e.preventDefault();
        });
    };

    /**
     * @name ProjectFilterOptions
     * @global
     *
     * @property {function} completeField is function executed when selection is chosen
     */

    /**
     * @class ProjectFilterAutoComplete
     * @extends RESTAutoComplete
     * @abstract
     *
     * @param {ProjectFilterOptions} options for the ProjectFilterAutocomplete
     */
    var ProjectFilterAutoComplete = function(options) {
        options = options || {};

        /** @lends ProjectFilterAutoComplete# */
        var that = Objects.begetObject(RESTAutoComplete);


        that.getAjaxParams = function(){
            return {
                url: AJS.contextPath() + "/rest/gadget/1.0/pickers/projectsAndFilters",
                data: options.ajaxData || {},
                dataType: "json",
                type: "GET"
            };
        };

        that.completeField =  function (selection) {
            if (selection) {
                options.parentElement.find("input[name=type]").val(selection.type);
                options.parentElement.find("input[name=id]").val(selection.id);
                options.parentElement.find("input[name=name]").val(selection.name);
                options.parentElement.find(".filterpicker-value-name").text(selection.name).addClass('success');
                this.field.val('');
                this.field.trigger("change");
            }
        };

        var createSuggestionBlock = function(element, sectionType, sectionName, data, renderer) {
            var suggestionNodes = [];
            var suggestionSectionElement = $(Templates.SuggestionSection({sectionTitle: sectionName}));
            var suggestionSectionList = suggestionSectionElement.find("ul.aui-list-section");


            $(data).each(function() {
                var suggestion = this;
                var suggestionElement = $(renderer({
                    suggestion: suggestion
                }));

                suggestion.type = sectionType;

                suggestionElement.mouseover(function() {
                    $(this).addClass("active");
                });
                suggestionNodes.push([suggestionElement, suggestion]);
                suggestionSectionList.append(suggestionElement);
            });

            element.append(suggestionSectionElement);

            return suggestionNodes;
        };

        /**
         * @param {Object} response
         */
        that.renderSuggestions = function(response) {
            // remove previous results
            this.clearResponseContainer();

            this.responseContainer.addClass('aui-list');
            var suggestionNodes = [];
            if (response && response.projects && response.projects.length > 0) {
                var projectSectionNodes = createSuggestionBlock(this.responseContainer, 'project', "Projects",
                    response.projects, Templates.SuggestionProject);
                suggestionNodes = suggestionNodes.concat(projectSectionNodes);
            }

            if (response && response.filters && response.filters.length > 0) {
                var filterSectionNodes = createSuggestionBlock(this.responseContainer, 'filter', "Filters",
                    response.filters, Templates.SuggestionFilter);
                suggestionNodes = suggestionNodes.concat(filterSectionNodes);
            }

            this.responseContainer.find(".aui-list-item-link").click(function(event) {
                event.preventDefault();
            });

            that.addSuggestionControls(suggestionNodes);

            return suggestionNodes;
        };

        options.minQueryLength = 1;
        options.queryDelay = 0.25;

        that.init(options);
        initialiseAdvancedSearch(options);

        return that;
    };

    return ProjectFilterAutoComplete;
});
;
;
/* module-key = 'com.atlassian.plugin.jslibs:d3-3.4.13', location = 'libs/d3/3.4.13/d3-3.4.13.js' */
!function() {
  var d3 = {
    version: "3.4.13"
  };
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = document, d3_documentElement = d3_document.documentElement, d3_window = window;
  try {
    d3_array(d3_documentElement.childNodes)[0].nodeType;
  } catch (e) {
    d3_array = function(list) {
      var i = list.length, array = new Array(i);
      while (i--) array[i] = list[i];
      return array;
    };
  }
  try {
    d3_document.createElement("div").style.setProperty("opacity", 0, "");
  } catch (error) {
    var d3_element_prototype = d3_window.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
    d3_element_prototype.setAttribute = function(name, value) {
      d3_element_setAttribute.call(this, name, value + "");
    };
    d3_element_prototype.setAttributeNS = function(space, local, value) {
      d3_element_setAttributeNS.call(this, space, local, value + "");
    };
    d3_style_prototype.setProperty = function(name, value, priority) {
      d3_style_setProperty.call(this, name, value + "", priority);
    };
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && !((a = array[i]) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && !((a = array[i]) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n && !((a = c = array[i]) != null && a <= a)) a = c = undefined;
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n && !((a = c = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    return j ? s / j : undefined;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    return numbers.length ? d3.quantile(numbers.sort(d3_ascending), .5) : undefined;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array) {
    var m = array.length, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m], array[m] = array[i], array[i] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  function d3_zipLength(d) {
    return d.length;
  }
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object) {
    var map = new d3_Map();
    if (object instanceof d3_Map) object.forEach(function(key, value) {
      map.set(key, value);
    }); else for (var key in object) map.set(key, object[key]);
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatcher = d3_documentElement.matches || d3_documentElement[d3_vendorSymbol(d3_documentElement, "matchesSelector")], d3_selectMatches = function(n, s) {
    return d3_selectMatcher.call(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3_selectionRoot;
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0) {
        prefix = name.slice(0, i);
        name = name.slice(i + 1);
      }
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? function() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    } : function() {
      return this.ownerDocument.createElementNS(this.namespaceURI, name);
    };
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(function() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    });
  };
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
            exitNodes[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
          keyValues[i] = keyValue;
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3_selectionPrototype.transition = function() {
    var id = d3_transitionInheritId || ++d3_transitionId, subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_selectionPrototype.interrupt = function() {
    return this.each(d3_selection_interrupt);
  };
  function d3_selection_interrupt() {
    var lock = this.__transition__;
    if (lock) ++lock.active;
  }
  d3.select = function(node) {
    var group = [ typeof node === "string" ? d3_select(node, d3_document) : node ];
    group.parentNode = d3_documentElement;
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group = d3_array(typeof nodes === "string" ? d3_selectAll(nodes, d3_document) : nodes);
    group.parentNode = d3_documentElement;
    return d3_selection([ group ]);
  };
  var d3_selectionRoot = d3.select(d3_documentElement);
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  d3_selection_onFilters.forEach(function(k) {
    if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
  });
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect = "onselectstart" in d3_document ? null : d3_vendorSymbol(d3_documentElement.style, "userSelect"), d3_event_dragId = 0;
  function d3_event_dragSuppress() {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect) {
      var style = d3_documentElement.style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        function off() {
          w.on(click, null);
        }
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {
        svg = d3.select("body").append("svg").style({
          position: "absolute",
          top: 0,
          left: 0,
          margin: 0,
          padding: 0,
          border: "none"
        }, "important");
        var ctm = svg[0][0].getScreenCTM();
        d3_mouse_bug44083 = !(ctm.f || ctm.e);
        svg.remove();
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX,
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_behavior_dragMouseSubject, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_behavior_dragTouchSubject, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject()).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged && d3.event.target === target);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  function d3_behavior_dragTouchSubject() {
    return d3.event.target;
  }
  function d3_behavior_dragMouseSubject() {
    return d3_window;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var π = Math.PI, τ = 2 * π, halfπ = π / 2, ε = 1e-6, ε2 = ε * ε, d3_radians = π / 180, d3_degrees = 180 / π;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
    var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
    function interpolate(t) {
      var s = t * S;
      if (dr) {
        var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
      }
      return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
    }
    interpolate.duration = S * 1e3;
    return interpolate;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = dx / 2, cy = dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: +_
      };
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      dispatch({
        type: "zoomend"
      });
    }
    function mousedowned() {
      var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress();
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged && d3.event.target === target);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress();
      d3_selection_interrupt.call(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0], l = locations0[p.identifier];
            scaleTo(view.k * 2);
            translateTo(p, l);
            d3_eventPreventDefault();
            zoomed(dispatch);
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else translate0 = location(center0 = center || d3.mouse(this)),
      d3_selection_interrupt.call(this), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var dispatch = event.of(this, arguments), p = d3.mouse(this), l = location(p), k = Math.log(view.k) / Math.LN2;
      zoomstarted(dispatch);
      scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));
      translateTo(p, l);
      zoomed(dispatch);
      zoomended(dispatch);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ];
  var d3_behavior_zoomDelta, d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
    return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
  }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
    return d3.event.wheelDelta;
  }, "mousewheel") : (d3_behavior_zoomDelta = function() {
    return -d3.event.detail;
  }, "MozMousePixelScroll");
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/i.exec(format);
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) return rgb(color.r, color.g, color.b);
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  function d3_identity(d) {
    return d;
  }
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType,
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (d3_window.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = d3_window[d3_vendorSymbol(d3_window, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      f: false,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  };
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now();
    d3_timer_active = d3_timer_queueHead;
    while (d3_timer_active) {
      if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
      d3_timer_active = d3_timer_active.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.f) {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      } else {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string,
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4),
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
  }
  d3.geo.bounds = function() {
    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dλSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
        range[0] = λ0, range[1] = λ1;
      }
    };
    function point(λ, φ) {
      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
      if (φ < φ0) φ0 = φ;
      if (φ > φ1) φ1 = φ;
    }
    function linePoint(λ, φ) {
      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = inflection[1] * d3_degrees;
          if (φi > φ1) φ1 = φi;
        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = -inflection[1] * d3_degrees;
          if (φi < φ0) φ0 = φi;
        } else {
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        if (antimeridian) {
          if (λ < λ_) {
            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
          } else {
            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
          }
        } else {
          if (λ1 >= λ0) {
            if (λ < λ0) λ0 = λ;
            if (λ > λ1) λ1 = λ;
          } else {
            if (λ > λ_) {
              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
            } else {
              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
            }
          }
        }
      } else {
        point(λ, φ);
      }
      p0 = p, λ_ = λ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = λ0, range[1] = λ1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(λ, φ) {
      if (p0) {
        var dλ = λ - λ_;
        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
      } else λ__ = λ, φ__ = φ;
      d3_geo_area.point(λ, φ);
      linePoint(λ, φ);
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(λ__, φ__);
      d3_geo_area.lineEnd();
      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
      range[0] = λ0, range[1] = λ1;
      p0 = null;
    }
    function angle(λ0, λ1) {
      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      φ1 = λ1 = -(λ0 = φ0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, dλ;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
        }
      }
      ranges = range = null;
      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < ε2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < ε2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00, x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ00 = λ, φ00 = φ;
      d3_geo_centroid.point = nextPoint;
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(λ00, φ00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        var point = rotate(λ, φ);
        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        var point = rotate(λ, φ);
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(λ, φ) {
        ring.push([ λ, φ ]);
        var point = rotate(λ, φ);
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
        if (abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * halfπ;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (abs(from[0] - to[0]) > ε) {
      var s = from[0] < to[0] ? π : -π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
      }
    }
    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(λ, φ) {
      var r = smallRadius ? radius : π - radius, code = 0;
      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_geo_conic(projectAt) {
    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function forward(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x, y);
      context.arc(x, y, pointRadius, 0, τ);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(λ, φ) {
        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(λ, φ) {
    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * τ;
      } else {
        from = radius + direction * τ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ε;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ε;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var λ0, sinφ0, cosφ0;
    d3_geo_length.point = function(λ, φ) {
      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(λ, φ) {
      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), t = function(φ) {
      return Math.tan(π / 4 + φ / 2);
    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(λ, φ) {
      if (F > 0) {
        if (φ < -halfπ + ε) φ = -halfπ + ε;
      } else {
        if (φ > halfπ - ε) φ = halfπ - ε;
      }
      var ρ = F / Math.pow(t(φ), n);
      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
    if (abs(n) < ε) return d3_geo_equirectangular;
    function forward(λ, φ) {
      var ρ = G - φ;
      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = G - y;
      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(λ, φ) {
    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k = π * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(λ, φ) {
    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(),
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ε) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ε) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -ε) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -ε) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
            x: x0,
            y: abs(x2 - x0) < ε ? y2 : y1
          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
            x: abs(y2 - y1) < ε ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
            x: x1,
            y: abs(x2 - x1) < ε ? y2 : y0
          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
            x: abs(y2 - y0) < ε ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -ε2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ε) * ε,
          y: Math.round(fy(d, i) / ε) * ε,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, right = x >= sx, bottom = y >= sy, i = (bottom << 1) + right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = sx; else x2 = sx;
        if (bottom) y1 = sy; else y2 = sy;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0],
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfπ);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransform(a, b) {
    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
    if (ta[0] != tb[0] || ta[1] != tb[1]) {
      s.push("translate(", null, ",", null, ")");
      q.push({
        i: 1,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: 3,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    } else {
      s.push("");
    }
    if (ra != rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(s.pop() + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(s.pop() + "rotate(" + rb + ")");
    }
    if (wa != wb) {
      q.push({
        i: s.push(s.pop() + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(s.pop() + "skewX(" + wb + ")");
    }
    if (ka[0] != kb[0] || ka[1] != kb[1]) {
      n = s.push(s.pop() + "scale(", null, ",", null, ")");
      q.push({
        i: n - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: n - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] != 1 || kb[1] != 1) {
      s.push(s.pop() + "scale(" + kb + ")");
    }
    n = q.length;
    return function(t) {
      var i = -1, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (τ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: (x - x0) / k
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) alpha = x; else alpha = 0;
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        d3.timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, m = candidates.length, x;
        while (++j < m) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ;
    function pie(data) {
      var values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      });
      var a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle);
      var k = ((typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a) / d3.sum(values);
      var index = d3.range(data.length);
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      var arcs = [];
      index.forEach(function(i) {
        var d;
        arcs[i] = {
          data: data[i],
          value: d = values[i],
          startAngle: a,
          endAngle: a += d * k
        };
      });
      return arcs;
    }
    pie.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return pie;
    };
    pie.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return pie;
    };
    pie.startAngle = function(x) {
      if (!arguments.length) return startAngle;
      startAngle = x;
      return pie;
    };
    pie.endAngle = function(x) {
      if (!arguments.length) return endAngle;
      endAngle = x;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = 0;
      root.y = 0;
      root.dx = size[0];
      root.dy = size[1];
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ],
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12,
      Math.floor), e;
      return function(d) {
        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
      range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)), error = stop - start - (domain.length - padding) * step;
      range = steps(start + Math.round(error / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function arc() {
      var r0 = innerRadius.apply(this, arguments), r1 = outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset, a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset, da = (a1 < a0 && (da = a0,
      a0 = a1, a1 = da), a1 - a0), df = da < π ? "0" : "1", c0 = Math.cos(a0), s0 = Math.sin(a0), c1 = Math.cos(a1), s1 = Math.sin(a1);
      return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2, a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcOffset = -halfπ, d3_svg_arcMax = τ - ε;
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.join("L");
  }
  function d3_svg_lineLinearClosed(points) {
    return d3_svg_lineLinear(points) + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]),
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ε) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] + d3_svg_arcOffset;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset, a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] + d3_svg_arcOffset;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  function d3_transition(groups, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection) {
    return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, id, node.__transition__[id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node.__transition__[id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id;
    if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node.__transition__[id].tween.remove(name);
    } : function(node) {
      node.__transition__[id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node.__transition__[id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    return this.each("end.transition", function() {
      var p;
      if (this.__transition__.count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id;
    if (arguments.length < 1) return this.node().__transition__[id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node.__transition__[id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id;
    if (arguments.length < 1) return this.node().__transition__[id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node.__transition__[id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id;
    if (arguments.length < 1) return this.node().__transition__[id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node.__transition__[id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      d3_transitionInheritId = id;
      d3_selection_each(this, function(node, i, j) {
        d3_transitionInherit = node.__transition__[id];
        type.call(node, node.__data__, i, j);
      });
      d3_transitionInherit = inherit;
      d3_transitionInheritId = inheritId;
    } else {
      d3_selection_each(this, function(node) {
        var transition = node.__transition__[id];
        (transition.event || (transition.event = d3.dispatch("start", "end"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = Object.create(node.__transition__[id0]);
          transition.delay += transition.duration;
          d3_transitionNode(node, i, id1, transition);
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id1);
  };
  function d3_transitionNode(node, i, id, inherit) {
    var lock = node.__transition__ || (node.__transition__ = {
      active: 0,
      count: 0
    }), transition = lock[id];
    if (!transition) {
      var time = inherit.time;
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        ease: inherit.ease,
        delay: inherit.delay,
        duration: inherit.duration
      };
      ++lock.count;
      d3.timer(function(elapsed) {
        var d = node.__data__, ease = transition.ease, delay = transition.delay, duration = transition.duration, timer = d3_timer_active, tweened = [];
        timer.t = delay + time;
        if (delay <= elapsed) return start(elapsed - delay);
        timer.c = start;
        function start(elapsed) {
          if (lock.active > id) return stop();
          lock.active = id;
          transition.event && transition.event.start.call(node, d, i);
          transition.tween.forEach(function(key, value) {
            if (value = value.call(node, d, i)) {
              tweened.push(value);
            }
          });
          d3.timer(function() {
            timer.c = tick(elapsed || 1) ? d3_true : tick;
            return 1;
          }, 0, time);
        }
        function tick(elapsed) {
          if (lock.active !== id) return stop();
          var t = elapsed / duration, e = ease(t), n = tweened.length;
          while (n > 0) {
            tweened[--n].call(node, e);
          }
          if (t >= 1) {
            transition.event && transition.event.end.call(node, d, i);
            return stop();
          }
        }
        function stop() {
          if (--lock.count) delete lock[id]; else delete node.__transition__;
          return 1;
        }
      }, 0, time);
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"),
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = arguments;
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
/////////// Modified by Atlassian ///////////
//  if (typeof define === "function" && define.amd) define(d3); else if (typeof module === "object" && module.exports) module.exports = d3;
//  this.d3 = d3;
  define('atlassian/libs/d3-3.4.13', d3);
/////// End of Atlassian modification ///////
}();
;
;
/* module-key = 'com.atlassian.jira.gadgets:d3', location = 'static/lib/d3-amd.js' */
define('jira-dashboard-items/lib/d3', ['atlassian/libs/d3-3.4.13'], function(d3) {
    return d3;
});

AJS.namespace('d3', null, require('jira-dashboard-items/lib/d3'));
;
;
/* module-key = 'com.atlassian.jira.gadgets:piechart', location = 'static/components/charts/piechart/PieChart.js' */
define('jira-dashboard-items/components/charts/piechart', [
    'jquery',
    'jira-dashboard-items/lib/d3'
], function(
    $,
    d3
) {

    function DEFAULT_COLOUR_PICKER(colours, numberElements) {
        var LIME_GREEN = "#8eb021",
            BLUE = "#3b7fc4",
            RED = "#d04437",
            YELLOW = "#f6c342",
            VIOLET = "#654982",
            PINK = "#f691b2",
            GRAY = "#999999",
            ASH_GRAY = "#cccccc",
            BROWN = "#815b3a",
            CHEETO_ORANGE = "#f79232",
            TAN = "#f1a257",
            LIGHT_BROWN = "#d39c3f",
            CYAN = "#59afe1",
            SLATE = "#4a6785",
            COOL_BLUE = "#84bbc6",
            MID_GREEN = "#67ab49",
            MAUVE = "#ac707a",
            BRIGHT_PINK = "#f15c75";


        colours = colours || [
            LIME_GREEN,
            BLUE,
            RED,
            YELLOW,
            VIOLET,
            PINK,
            GRAY,
            BROWN,
            CHEETO_ORANGE,
            CYAN,
            BRIGHT_PINK
        ];

        /**
         *
         * @type {colourPickerFunction}
         */
        function getNextColour(piechart, data, index, sectorElement) {
            var colourIndex = index % colours.length;
            var isLast = (index + 1 === numberElements);
            var isFirstColour = (colourIndex === 0);
            var oneSector = (numberElements === 1);

            /**
             * This solves problems where if there is one more sector then the number of colours two sectors have the
             * same colour next to each other. E.g. colours (A B C) and 4 sectors would place colours: A B C A, which
             * is two A's together. This code will make it A B C B.
             */
            if (isLast && isFirstColour && !oneSector) {
                colourIndex = 1;
            }
            return colours[colourIndex];
        }

        return getNextColour;
    }

    function noop() {}

    /**
     * Class used to represent piechart options.
     * @name PieChartOptions
     * @global
     *
     * Required parameters
     * @property {number}               radius  of the pie chart
     * @property {getValueFunction}     getValue given a data element, return the value
     *
     * Design parameters
     * @property {boolean}              [centerChart]  whether the chart should be centered
     * @property {boolean}              [clickable]  whether the sectors are clickable and should have a click cursor on hover
     * @property {colourPickerFunction} [colourPicker]  given data and an index return what colour it should be
     * @property {string[]}             [colours] that should be displayed
     * @property {number}               [hoverExpansion] size of expansion when hovered over
     * @property {number}               [innerRadius]  used to create a donut pie chart
     * @property {number}               [sectorGap] gap size between sectors
     *
     * Functionality parameters
     * @property {getPrimaryTextFunction}[getPrimaryText] function called to populate the primary text within the piechart
     * @property {getSecondaryTextFunction}[getSecondaryText] function called to populate the secondary text within the piechart
     * @property {onClickFunction}      [onClick]  executed when a sector is clicked
     * @property {onEachSectorFunction} [onEachSector] executed on each sector where own content/changes can be applied
     * @property {onMouseOverFunction}  [onMouseOver] executed when hover over a sector
     * @property {onMouseOutFunction}   [onMouseOut]  executed when leaving the sector
     */

    /**
     * Functions that can be passed into PieChart
     **/
    /**
     * Function to get the value for a pie chart sector.
     * @name getValueFunction
     * @function
     * @global
     * @arg data {Object} - The search term to highlight.
     * @return {number} value for sector
     */

    /**
     * Function to get the value for a pie chart sector.
     * @name getPrimaryTextFunction
     * @function
     * @global
     * @arg data {Object} - The search term to highlight.
     * @arg index {number} - The index for the data item
     * @return {number} value for sector
     */

    /**
     * Function to get the value for a pie chart sector.
     * @name getSecondaryTextFunction
     * @function
     * @global
     * @arg data {Object} - The search term to highlight.
     * @arg index {number} - The index for the data item
     * @return {number} value for sector
     */

    /**
     * Function that takes pie chart information, manipulates or returns information.
     * @name colourPickerFunction
     * @function
     * @global
     *
     * @param {PieChart} piechart that the colour is being used on
     * @param {Object} data for sector
     * @param {number} index of sector
     * @param {node} sectorElement for sector
     * @return {string} colour for selection.
     */

    /**
     * Function that takes pie chart information and does some event on a click.
     * @name onClickFunction
     * @function
     * @global
     * @param {PieChart} piechart that the colour is being used on
     * @param {Object} data for sector
     * @param {number} index of sector
     * @param {node} sectorElement for sector
     */

    /**
     * Executed on each sector when a piechart is created.
     * @name onEachSectorFunction
     * @function
     * @global
     * @param {PieChart} piechart that the colour is being used on
     * @param {Object} data for sector
     * @param {number} index of sector
     * @param {node} sectorElement for sector
     */

    /**
     * Function that takes pie chart information and does some event on a mouseover on a sector.
     * @name onMouseOverFunction
     * @function
     * @global
     * @param {PieChart} piechart that the colour is being used on
     * @param {Object} data for sector
     * @param {number} index of sector
     * @param {node} sectorElement for sector
     */

    /**
     * Function that takes pie chart information and does some event on a mouseout on a sector.
     * @name onMouseOutFunction
     * @function
     * @global
     * @param {PieChart} piechart that the colour is being used on
     * @param {Object} data for sector
     * @param {number} index of sector
     * @param {node} sectorElement for sector
     */

    /**
     * Render function
     * @name renderFunction
     * @function
     * @arg {node} element to render piechart onto
     */

    /**
     * @constructor
     *
     * @name PieChart
     * @class
     *
     * Generate a pie chart
     * @param {Object[]} data  to pass into the chart. Note: Should be in sorted order otherwise some colours may appear
     *           next to each other.
     *
     * @param {PieChartOptions} options fo the PieChart
     *
     * @return {PieChart}
     *
     */
    var PieChart = function(data, options) {
        this.radius = options.radius;
        this.data = data;
        this.getValue = options.getValue || function(dataElement) { return dataElement; };


        this.centerChart = options.centerChart || false;
        this.clickable = options.clickable || false;
        this.colourPicker = options.colourPicker || DEFAULT_COLOUR_PICKER(options.colours, this.data.length);
        this.hoverExpansion = options.hoverExpansion || 0;
        this.innerRadius = options.innerRadius || 0;
        this.sectorGap = options.sectorGap || 2;
        this.innerCirclePadding = Math.min(10, Math.max(this.innerRadius, 0));

        this.getPrimaryText = options.getPrimaryText || noop;
        this.getSecondaryText = options.getSecondaryText || noop;
        this.onClick = options.onClick || noop;
        this.onEachArc = options.onEachArc || noop;
        this.onMouseOver = options.onMouseOver || noop;
        this.onMouseOut = options.onMouseOut || noop;

        this.pieCenter = this.radius + this.hoverExpansion;

        this.width = this.pieCenter * 2;
        this.height = this.pieCenter * 2;

        this.render = function(element) {
            var self = this;

            var chart = d3.select(element[0])
                .append("svg")
                .data([this.data])
                .classed({'piechart': true, 'centered': this.centerChart})
                .attr("width", this.width)
                .attr("height", this.height);

            chart
                .append("g")
                .classed({'piechart-graph': true})
                .attr("transform", "translate(" + this.pieCenter  + "," + this.pieCenter + ")");

            var centerTextBlockOptions = {
                width: 2 * (this.innerRadius - this.innerCirclePadding),
                height: Math.sqrt(2 * this.innerRadius * this.innerRadius),
                dx: (this.pieCenter - this.innerRadius + this.innerCirclePadding),
                dy: (this.pieCenter - this.innerRadius + 2 * this.innerCirclePadding)
            };

            var arc = d3.svg.arc()
                .outerRadius(this.radius)
                .innerRadius(this.innerRadius);

            var arcLarger = d3.svg.arc()
                .outerRadius(this.radius + this.hoverExpansion)
                .innerRadius(this.innerRadius);

            var pie = d3.layout.pie()
                //Given a sector what is the value for it.
                .value(this.getValue);

            this.arcs = chart.select("g.piechart-graph").selectAll("g")
                .data(pie)
                .enter()
                .append("g")
                .classed({'piechart-arc': true, 'clickable': this.clickable})

                .each(function(sector, index) {
                    self.onEachArc(self, sector.data, index, $(d3.select(this).node()));
                });



            //Add primary text

            this.arcs
                .append("text")
                .attr("width", centerTextBlockOptions.width)
                .attr("text-anchor", "middle")
                .classed("piechart-center-primary", true)
                .attr("y", 5)
                .attr("fill", function(sector, index) {
                    return self.colourPicker(self, sector.data, index, d3.select(this).node());
                })
                .text(function(sector, index) {
                    return self.getPrimaryText(sector.data, index);
                });

            //Add secondary text
            this.arcs
                .append("text")
                .attr("width", centerTextBlockOptions.width)
                .attr("text-anchor", "middle")
                .classed("piechart-center-secondary", true)
                .attr("fill", "#333333")
                .attr("y", 25)
                .text(function(sector, index) {
                    return self.getSecondaryText(sector.data, index);
                });


            this.arcs.append("path")
                .attr('stroke', '#fff')
                .attr('stroke-width', this.sectorGap)
                .attr("fill", function(sector, index) {
                    return self.colourPicker(self, sector.data, index, d3.select(this).node());
                })
                .classed({'piechart-fill': true})
                .attr("d", arc);

            this.arcs.on("click", function(sector, index) {
                self.onClick(self, sector.data, index, d3.select(this).node());
            });

            this.mouseOver = function(dataIndex) {
                _mouseOver.call(this.arcs[0][dataIndex], this.arcs.data()[dataIndex], dataIndex);
            };

            this.mouseOut = function(dataIndex) {
                _mouseOut.call(this.arcs[0][dataIndex], this.arcs.data()[dataIndex], dataIndex);
            };

            var _mouseOver = function(sector, index) {
                d3.select(this).classed({'piechart-arc-highlighted': true});
                d3.select(this).select("path").transition().duration(100).attr("d", arcLarger);
                self.onMouseOver(self, sector.data, index, d3.select(this).node());
            };

            var _mouseOut = function(sector, index) {
                d3.select(this).classed({'piechart-arc-highlighted': false});
                d3.select(this).select("path").transition().duration(100).attr("d", arc);
                self.onMouseOut(self, sector.data, index, d3.select(this).node());
            };

            this.arcs.on("mouseover", function(sector, index) {
                _mouseOver.call(this, sector, index);
            });

            this.arcs.on("mouseout", function(sector, index) {
                _mouseOut.call(this, sector, index);
            });
        };
    };

    return PieChart;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:piechart-with-legend', location = 'static/components/charts/piechart/piechart-with-legend.soy' */
// This file was automatically generated from piechart-with-legend.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Charts.PieChart.Legend.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Charts == 'undefined') { JIRA.Charts = {}; }
if (typeof JIRA.Charts.PieChart == 'undefined') { JIRA.Charts.PieChart = {}; }
if (typeof JIRA.Charts.PieChart.Legend == 'undefined') { JIRA.Charts.PieChart.Legend = {}; }
if (typeof JIRA.Charts.PieChart.Legend.Templates == 'undefined') { JIRA.Charts.PieChart.Legend.Templates = {}; }


JIRA.Charts.PieChart.Legend.Templates.Container = function(opt_data, opt_ignored) {
  return '<div class=\'piechart-with-legend\'><div class=\'piechart-wrapper\'></div><div class=\'legend-wrapper\'><div class="legend-title"></div><ul class=\'legend\'></ul></div></div>';
};
if (goog.DEBUG) {
  JIRA.Charts.PieChart.Legend.Templates.Container.soyTemplateName = 'JIRA.Charts.PieChart.Legend.Templates.Container';
}


JIRA.Charts.PieChart.Legend.Templates.ListItem = function(opt_data, opt_ignored) {
  return '<li class=\'legend-item\' data-piechartsector=\'' + soy.$$escapeHtml(opt_data.index) + '\'></li>';
};
if (goog.DEBUG) {
  JIRA.Charts.PieChart.Legend.Templates.ListItem.soyTemplateName = 'JIRA.Charts.PieChart.Legend.Templates.ListItem';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:piechart-with-legend', location = 'static/components/charts/piechart/PieChartWithLegend.js' */
define('jira-dashboard-items/components/charts/piechart-with-legend', [
    'jquery',
    'jira-dashboard-items/components/charts/piechart'
], function(
    $,
    PieChart
) {

    function noop() {}


    var Templates = JIRA.Charts.PieChart.Legend.Templates;

    /**
     *  @name LegendOptions
     *  @global
     *
     *  @property {RenderLegendTitle} renderLegendTitle renders the title for the legend.
     *  @property
     */

    /**
     * Function used to render the title of the legend.
     * @name RenderLegendTitle
     * @function
     * @global
     *
     * @param {JQuery} element to render onto
     * @param {Object[]} data for the piechart
     **/


    /**
     * Function used to render an item in the legend
     * @name RenderLegendItem
     * @function
     * @global
     *
     * @param {JQuery} element to render onto
     * @param {Object} data for this item.
     **/

    /**
     * @name PieChartWithLegendOptions
     * @global
     *
     * @property {PieChartOptions} piechart options
     * @property {LegendOptions} legend options
     *
     */

    /**
     * @constructor
     *
     * Generate a pie chart
     * @param data for the chart
     * @param {PieChartWithLegendOptions} options

     * @return {PieChartWithLegend}
     *      render{function} renders the PieChart
     *
     */
    var PieChartWithLegend = function(data, options) {
        options.legend = options.legend || {};

        var self = this;
        this.data = data;
        this.PieChart = new PieChart(data, options.piechart);
        this.renderLegendItem = options.legend.renderLegendItem || noop;
        this.renderLegendTitle = options.legend.renderLegendTitle || noop;

        function renderPieChart(element) {
            var chartEl = $('.piechart-wrapper', element);

            self.PieChart.render(chartEl);
        }

        function renderLegend(element) {
            var legendEl = $('.legend-wrapper', element);
            var legendTitle = $('.legend-title', legendEl);

            self.renderLegendTitle(legendTitle, self.data);

            var list = $("ul.legend", legendEl);
            for(var i = 0; i < self.data.length; ++i) {
                var dataItem = self.data[i];

                var listItem = $(Templates.ListItem({index: i}));
                self.renderLegendItem(listItem, self.PieChart, dataItem, i);

                list.append(listItem);
            }
        }

        this.render = function(element) {
            element = $(element);
            element.html(Templates.Container());

            renderPieChart(element);

            renderLegend(element);

            $(".legend .legend-item", element).each(function(index) {
                $(this).mouseover(function() {
                    self.PieChart.mouseOver(index);
                });
                $(this).mouseleave(function() {
                    self.PieChart.mouseOut(index);
                });
            });
        };
    };

    return PieChartWithLegend;
});;
;
/* module-key = 'com.atlassian.jira.gadgets:resize', location = 'static/lib/jquery.resize/jquery.resize.js' */
/**
 * Detect Element Resize Plugin for jQuery
 *
 * https://github.com/sdecima/javascript-detect-element-resize
 * Sebastian Decima
 *
 * version: 0.5
 **/

(function ( $ ) {
    var attachEvent = document.attachEvent,
        stylesCreated = false;

    var jQuery_resize = $.fn.resize;

    $.fn.resize = function(callback) {
        return this.each(function() {
            if(this == window)
                jQuery_resize.call(jQuery(this), callback);
            else
                addResizeListener(this, callback);
        });
    }

    $.fn.removeResize = function(callback) {
        return this.each(function() {
            removeResizeListener(this, callback);
        });
    }

    if (!attachEvent) {
        var requestFrame = (function(){
            var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame ||
                function(fn){ return window.setTimeout(fn, 20); };
            return function(fn){ return raf(fn); };
        })();

        var cancelFrame = (function(){
            var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame ||
                window.clearTimeout;
            return function(id){ return cancel(id); };
        })();

        function resetTriggers(element){
            var triggers = element.__resizeTriggers__,
                expand = triggers.firstElementChild,
                contract = triggers.lastElementChild,
                expandChild = expand.firstElementChild;
            contract.scrollLeft = contract.scrollWidth;
            contract.scrollTop = contract.scrollHeight;
            expandChild.style.width = expand.offsetWidth + 1 + 'px';
            expandChild.style.height = expand.offsetHeight + 1 + 'px';
            expand.scrollLeft = expand.scrollWidth;
            expand.scrollTop = expand.scrollHeight;
        };

        function checkTriggers(element){
            return element.offsetWidth != element.__resizeLast__.width ||
                element.offsetHeight != element.__resizeLast__.height;
        }

        function scrollListener(e){
            var element = this;
            resetTriggers(this);
            if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);
            this.__resizeRAF__ = requestFrame(function(){
                if (checkTriggers(element)) {
                    element.__resizeLast__.width = element.offsetWidth;
                    element.__resizeLast__.height = element.offsetHeight;
                    element.__resizeListeners__.forEach(function(fn){
                        fn.call(element, e);
                    });
                }
            });
        };
    }

    function createStyles() {
        if (!stylesCreated) {
            var css = '.resize-triggers { visibility: hidden; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
                head = document.head || document.getElementsByTagName('head')[0],
                style = document.createElement('style');

            style.type = 'text/css';
            if (style.styleSheet) {
                style.styleSheet.cssText = css;
            } else {
                style.appendChild(document.createTextNode(css));
            }

            head.appendChild(style);
        }
    }

    window.addResizeListener = function(element, fn){
        if (attachEvent) element.attachEvent('onresize', fn);
        else {
            if (!element.__resizeTriggers__) {
                if (getComputedStyle(element).position == 'static') element.style.position = 'relative';
                createStyles();
                element.__resizeLast__ = {};
                element.__resizeListeners__ = [];
                (element.__resizeTriggers__ = document.createElement('div')).className = 'resize-triggers';
                element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div>' +
                    '<div class="contract-trigger"></div>';
                element.appendChild(element.__resizeTriggers__);
                resetTriggers(element);
                element.addEventListener('scroll', scrollListener, true);
            }
            element.__resizeListeners__.push(fn);
        }
    };

    window.removeResizeListener = function(element, fn){
        if (attachEvent) element.detachEvent('onresize', fn);
        else {
            element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
            if (!element.__resizeListeners__.length) {
                element.removeEventListener('scroll', scrollListener);
                element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
            }
        }
    }
}( jQuery ));;
;
/* module-key = 'com.atlassian.jira.gadgets:piechart-dashboard-item-resources', location = 'static/dashboarditem/piechart/PieChart.soy' */
// This file was automatically generated from PieChart.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.PieChart.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.PieChart == 'undefined') { JIRA.DashboardItem.PieChart = {}; }
if (typeof JIRA.DashboardItem.PieChart.Templates == 'undefined') { JIRA.DashboardItem.PieChart.Templates = {}; }


JIRA.DashboardItem.PieChart.Templates.Configuration = function(opt_data, opt_ignored) {
  return '' + Atlassian.DashboardItem.Common.Templates.config({fields: '' + JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.ConfigurationField({prefix: opt_data.prefix, id: 'project-filter-picker', selectionType: opt_data.preferences.type, selectionID: opt_data.preferences.id, selectionName: opt_data.preferences.name}) + JIRA.DashboardItem.PieChart.Templates.statTypePicker({prefix: opt_data.prefix, id: 'stat-type', statTypes: opt_data.statTypes, value: opt_data.preferences.statType}) + Atlassian.DashboardItem.Common.Templates.refreshInterval({prefix: opt_data.prefix, id: 'refresh-interval', value: opt_data.preferences.refresh}), isConfigured: opt_data.preferences.isConfigured});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.Configuration.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.Configuration';
}


JIRA.DashboardItem.PieChart.Templates.SuggestionDropdownSection = function(opt_data, opt_ignored) {
  return '<h5>' + soy.$$escapeHtml(opt_data.section) + '</h5><ul class="aui-list-section"></ul>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.SuggestionDropdownSection.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.SuggestionDropdownSection';
}


JIRA.DashboardItem.PieChart.Templates.statTypePicker = function(opt_data, opt_ignored) {
  var output = '';
  var prefixedId__soy26 = opt_data.prefix + opt_data.id;
  output += '<div class="field-group"><label for="' + soy.$$escapeHtml(prefixedId__soy26) + '">' + soy.$$escapeHtml("Statistic Type") + '<span class="aui-icon icon-required"> ' + soy.$$escapeHtml("required") + '</span></label><select id="' + soy.$$escapeHtml(prefixedId__soy26) + '" name="statType" class="select">';
  var typeList36 = opt_data.statTypes;
  var typeListLen36 = typeList36.length;
  for (var typeIndex36 = 0; typeIndex36 < typeListLen36; typeIndex36++) {
    var typeData36 = typeList36[typeIndex36];
    output += '<option value="' + soy.$$escapeHtml(typeData36.value) + '"' + ((typeData36.value == opt_data.value) ? ' selected="selected"' : '') + '>' + soy.$$escapeHtml(typeData36.label) + '</option>';
  }
  output += '</select><div class="error"></div><div class="description">' + soy.$$escapeHtml("Select which type of statistic to display for this filter.") + '</div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.statTypePicker.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.statTypePicker';
}


JIRA.DashboardItem.PieChart.Templates.SectorInlineDialog = function(opt_data, opt_ignored) {
  return '<div class="piechart-inline-dialog"><h2 class="piechart-inline-dialog-title">' + soy.$$escapeHtml(opt_data.key) + '</h2><p><strong>' + soy.$$escapeHtml("Total Issues") + ':</strong> ' + soy.$$escapeHtml(opt_data.value) + ' (' + soy.$$escapeHtml(opt_data.percentage) + '%)</p><p>' + ((opt_data.url) ? '<a href="' + soy.$$escapeHtml(opt_data.url) + '" title="' + soy.$$escapeHtml(opt_data.value) + '">' + soy.$$escapeHtml("View in Issue Navigator") + '</a>' : '') + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.SectorInlineDialog.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.SectorInlineDialog';
}


JIRA.DashboardItem.PieChart.Templates.GroupedSectorInlineDialog = function(opt_data, opt_ignored) {
  var output = '<div class="piechart-inline-dialog grouped-sector-inline-dialog"><h2>' + soy.$$escapeHtml(opt_data.key) + ' (' + soy.$$escapeHtml(opt_data.percentage) + '%)</h2><p><strong>' + soy.$$escapeHtml("Total Issues") + ':</strong> ' + soy.$$escapeHtml(opt_data.value) + '</p><ul>';
  var resultList80 = opt_data.subResults;
  var resultListLen80 = resultList80.length;
  for (var resultIndex80 = 0; resultIndex80 < resultListLen80; resultIndex80++) {
    var resultData80 = resultList80[resultIndex80];
    output += '<li>' + ((resultData80.url) ? '<a class=\'grouped-list-label\' href=\'' + soy.$$escapeHtml(resultData80.url) + '\' title=\'' + soy.$$escapeHtml(resultData80.key) + '\'>' + soy.$$escapeHtml(resultData80.key) + '</a>' : '<span class=\'grouped-list-label\'>' + soy.$$escapeHtml(resultData80.key) + '</span>') + '<div class=\'item-value\'>' + soy.$$escapeHtml(resultData80.value) + '</div></li>';
  }
  output += '<ul></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.GroupedSectorInlineDialog.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.GroupedSectorInlineDialog';
}


JIRA.DashboardItem.PieChart.Templates.PieChart = function(opt_data, opt_ignored) {
  return '<div class=\'piechart-gadget\'></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.PieChart.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.PieChart';
}


JIRA.DashboardItem.PieChart.Templates.Errors = function(opt_data, opt_ignored) {
  var param105 = '<ul>';
  var errorList107 = opt_data.errors;
  var errorListLen107 = errorList107.length;
  for (var errorIndex107 = 0; errorIndex107 < errorListLen107; errorIndex107++) {
    var errorData107 = errorList107[errorIndex107];
    param105 += '<li>' + soy.$$escapeHtml(errorData107.message) + '</li>';
  }
  param105 += '</ul>';
  var output = '' + aui.message.error({titleContent: "Unfortunately, one or more of your preferences are now unavailable. Please update your preferences, or remove gadget by clicking delete from the title bar above.", closeable: 'false', content: param105});
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.Errors.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.Errors';
}


JIRA.DashboardItem.PieChart.Templates.NoPieChartContent = function(opt_data, opt_ignored) {
  return '' + aui.message.info({content: "No Data Available", closeable: 'false'});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.NoPieChartContent.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.NoPieChartContent';
}


JIRA.DashboardItem.PieChart.Templates.ErrorRenderingConfiguration = function(opt_data, opt_ignored) {
  return '' + aui.message.error({titleContent: "Oops - an error has occurred", content: '', closeable: 'false'});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.ErrorRenderingConfiguration.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.ErrorRenderingConfiguration';
}


JIRA.DashboardItem.PieChart.Templates.LegendTitle = function(opt_data, opt_ignored) {
  var output = '<h3>' + soy.$$escapeHtml(opt_data.statType) + '</h3><a href=\'' + soy.$$escapeHtml(opt_data.filterUrl) + '\' title=\'' + soy.$$escapeHtml(opt_data.filterTitle) + '\'>';
  var boldedCount__soy131 = '<b>' + opt_data.issueCount + '</b>';
  output += soy.$$filterNoAutoescape(AJS.format("Total Issues: {0}",boldedCount__soy131)) + '</a>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.LegendTitle.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.LegendTitle';
}


JIRA.DashboardItem.PieChart.Templates.LegendSection = function(opt_data, opt_ignored) {
  return '<div class=\'legend-content\'></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.LegendSection.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.LegendSection';
}


JIRA.DashboardItem.PieChart.Templates.LegendItem = function(opt_data, opt_ignored) {
  return '<div class="legend-item-wrapper"><div class="legend-item-value">' + soy.$$escapeHtml(opt_data.value) + '</div><div class="icon piechart-fill legend-icon" style="background-color: ' + soy.$$escapeHtml(opt_data.colour) + '"></div><div class="legend-item-label-wrapper">' + ((opt_data.url) ? '<a class=\'legend-item-label\' href=\'' + soy.$$escapeHtml(opt_data.url) + '\' ' + ((! opt_data.subResults) ? 'title=\'' + soy.$$escapeHtml(opt_data.key) + '\'' : '') + '>' + soy.$$escapeHtml(opt_data.key) + '</a>' : '<span class=\'legend-item-label\'>' + soy.$$escapeHtml(opt_data.key) + '</span>') + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.LegendItem.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.LegendItem';
}


JIRA.DashboardItem.PieChart.Templates.LegendSubItem = function(opt_data, opt_ignored) {
  return '<div class="legend-item-wrapper"><div class="legend-item-value">' + soy.$$escapeHtml(opt_data.value) + '</div><div class="legend-item-label-wrapper">' + ((opt_data.url) ? '<a class=\'legend-item-label\' href=\'' + soy.$$escapeHtml(opt_data.url) + '\' title=\'' + soy.$$escapeHtml(opt_data.key) + '\'>' + soy.$$escapeHtml(opt_data.key) + '</a>' : '<span class=\'legend-item-label\'>' + soy.$$escapeHtml(opt_data.key) + '</span>') + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.LegendSubItem.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.LegendSubItem';
}


JIRA.DashboardItem.PieChart.Templates.LegendMultiItem = function(opt_data, opt_ignored) {
  var output = '<div class="legend-sublist-container"><ul class="legend sublist" >';
  var itemList181 = opt_data.subResults;
  var itemListLen181 = itemList181.length;
  for (var itemIndex181 = 0; itemIndex181 < itemListLen181; itemIndex181++) {
    var itemData181 = itemList181[itemIndex181];
    output += '<li><div class=\'legend-content\'>' + JIRA.DashboardItem.PieChart.Templates.LegendSubItem(itemData181) + '</div></li>';
  }
  output += '</ul></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.LegendMultiItem.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.LegendMultiItem';
}


JIRA.DashboardItem.PieChart.Templates.UpdateCenterBlock = function(opt_data, opt_ignored) {
  return '<div class=\'piechart-center-primary\' style=\'color: ' + soy.$$escapeHtml(opt_data.colour) + '\'>' + soy.$$escapeHtml(opt_data.header) + '</div><div class=\'piechart-center-secondary\'>' + soy.$$escapeHtml(opt_data.subheader) + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.PieChart.Templates.UpdateCenterBlock.soyTemplateName = 'JIRA.DashboardItem.PieChart.Templates.UpdateCenterBlock';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:piechart-dashboard-item-resources', location = 'static/dashboarditem/piechart/PieChart.js' */
define("jira-dashboard-items/piechart", [
   'jquery',
   'underscore',
   'jira-dashboard-items/components/charts/piechart-with-legend',
   'jira-dashboard-items/components/autocomplete/project-filter-autocomplete'
], function(
    $,
    _,
    PieChartWithLegend,
    ProjectFilterAutoComplete
) {

    /**
     *
     * @param {InlineGadgetAPI} API
     * @param {Object} [options] for gadget
     * @constructor
     */
    var DashboardItem = function(API, options) {
        this.API = API;
        this.options = options || {};
    };

    /**
     * Given a JSON string extract the errors into an array.
     * @param {JSON} errorString to parse
     * @returns {string[]} of errors
     */
    function parseErrorMessage(errorString) {
        var errorArray = [];
        var errorJSON = JSON.parse(errorString);
        for (var key in errorJSON){
            if (errorJSON.hasOwnProperty(key)) {
                errorArray.push({
                    key: key,
                    message: errorJSON[key]
                });
            }
        }
        return errorArray;
    }

    /**
     * @property {number} the max number of sectors allowed in a piechart gadget.
     */
    DashboardItem.prototype.SECTOR_LIMIT = 11;

    /**
     * Given a set of preferences it takes deprecated preference values and applies them to the new format.
     *
     * @param {Object} preferences of the gadget
     * @returns {Object}
     */
    function preferencesBackwardCompatible(preferences) {
        if (preferences.projectOrFilterId) {
            // If projectOrFilterId exists, it means we are migrating from the old pie chart gadget, so our
            // stored type and id may be out of date.
            var projectOrFilterSplit = preferences.projectOrFilterId.split("-");
            preferences.type = projectOrFilterSplit[0];
            preferences.id = projectOrFilterSplit[1];
            delete preferences.projectOrFilterId;
        }
        return preferences;
    }

    DashboardItem.prototype._renderChart = function(gadgetElement, response) {
        var gadget = this;

        if (response.filterTitle) {
            gadget.API.setTitle(AJS.format("Pie Chart: {0}", response.filterTitle));
        } else {
            gadget.API.setTitle("Pie Chart");
        }

        if (!response.results || response.results.length === 0) {
            gadgetElement.html(JIRA.DashboardItem.PieChart.Templates.NoPieChartContent());
            gadget.API.resize();
        } else {

            //Group data
            var limit = gadget.SECTOR_LIMIT;
            if (response.results.length > limit) {
                var other = {
                    key: "Other",
                    percentage: 0,
                    value: 0,
                    url: '#',
                    subResults: []
                };

                var overflow = response.results.length - limit + 1;
                other.subResults = response.results.splice(limit - 1, overflow);
                other.value = _.reduce(other.subResults, function (total, entry) { return total + entry.value; }, 0);
                other.percentage = Math.floor(other.value * 100 / response.issueCount);

                response.results.push(other);
            }

            for (var i = 0; i < response.results.length; ++i) {
                response.results[i].percentage = Math.floor(response.results[i].value * 100 / response.issueCount);
                if (response.results[i].percentage === 0) {
                    response.results[i].percentage = "<1";
                }
            }

            var MAX_RADIUS = 200;
            var radius = Math.min(MAX_RADIUS, gadgetElement.width() / 2);

            var ellipsifyText = function(element, width) {
                var text = element.text();
                while (element[0].getBBox().width > width && text.length > 0) {
                    text = text.substr(0, text.length - 1);
                    element.text(AJS.format("{0}...", text));
                }
                return element.text();
            };

            //Calculates the font-size given the size of the inner radius.
            var MIN_INNER_RADIUS = 40;
            var MAX_INNER_RADIUS = 75;
            var INNER_RADIUS_RANGE = MAX_INNER_RADIUS - MIN_INNER_RADIUS;
            var innerRadius = Math.max(MIN_INNER_RADIUS, Math.min(radius / 2, MAX_INNER_RADIUS));

            var innerRadiusMinDifference = innerRadius - MIN_INNER_RADIUS;
            var percentageInner = innerRadiusMinDifference / INNER_RADIUS_RANGE;

            var MIN_PRIMARY_FONT_SIZE = 28;
            var MAX_PRIMARY_FONT_SIZE = 48;
            var PRIMARY_FONT_SIZE_RANGE = MAX_PRIMARY_FONT_SIZE - MIN_PRIMARY_FONT_SIZE;
            var primaryFontSize = MIN_PRIMARY_FONT_SIZE + (percentageInner * PRIMARY_FONT_SIZE_RANGE);

            var options = {
                piechart: {
                    radius: radius,
                    innerRadius: innerRadius,
                    hoverExpansion: 0,
                    centerChart: true,

                    clickable: true,

                    getValue: function (dataElement) {
                        return dataElement.value;
                    },

                    onEachArc: function (piechart, data, index, sectorElement) {
                        AJS.InlineDialog(sectorElement, "piechart-sector-" + gadget.API.getGadgetId() + "-" + index,
                            function (content, trigger, showPopup) {
                                if (data.subResults) {
                                    content.html(JIRA.DashboardItem.PieChart.Templates.GroupedSectorInlineDialog(data));
                                } else {
                                    content.html(JIRA.DashboardItem.PieChart.Templates.SectorInlineDialog(data));
                                }
                                showPopup();
                                return false;
                            },
                            {
                                gravity: 'w',
                                hideDelay: 1000,
                                closeOnTriggerClick: true
                            }
                        );
                    },

                    getPrimaryText: function(data) {
                        return data.percentage + "%";
                    },

                    getSecondaryText: function(data) {
                        return data.key;
                    },

                    onMouseOver: function(piechart, data, index, sectorElement) {
                         var primaryElement = $(sectorElement).find(".piechart-center-primary");
                         primaryElement.css("font-size", primaryFontSize + "px");
                         var secondaryElement = $(sectorElement).find(".piechart-center-secondary");
                         ellipsifyText(secondaryElement, secondaryElement.attr("width"));
                    }
                },

                legend: {
                    renderLegendTitle: function(element, data) {
                        element.html(JIRA.DashboardItem.PieChart.Templates.LegendTitle(response));
                    },

                    renderLegendItem: function(element, pieChart, data, index) {
                        element.html(JIRA.DashboardItem.PieChart.Templates.LegendSection());

                        data.colour = pieChart.colourPicker(pieChart, data, index);

                        var legendContent = $(".legend-content", element);
                        legendContent.html(JIRA.DashboardItem.PieChart.Templates.LegendItem(data));

                        if (data.subResults) {
                            var grouptoggle = legendContent.find("a");
                            grouptoggle.append("...");

                            var dialogId = "piechart-legend-" + gadget.API.getGadgetId() + "-" + index;

                            var dialog = AJS.InlineDialog(grouptoggle, dialogId,
                                function (content, trigger, showPopup) {
                                    content.css({"padding": "20px"}).html(JIRA.DashboardItem.PieChart.Templates.LegendMultiItem(data));
                                    showPopup();
                                    content.focus();
                                    return false;
                                },
                                {
                                    onHover: true,
                                    gravity: 'n',
                                    width: 175,
                                    hideDelay: 500,
                                    isRelativeToMouse: true
                                }
                            );
                            grouptoggle.click(function(event) {
                                event.preventDefault();
                            });

                            var isEnter = function(event) {
                                return event.keyCode === 13;
                            };

                            var isShiftTab = function(event) {
                                return event.keyCode === 9 && event.shiftKey === true;
                            };

                            var isTab = function(event) {
                                return event.keyCode === 9 && event.shiftKey === false;
                            };

                            grouptoggle.keydown(function(event) {
                                if (isEnter(event)) {
                                    dialog.show();
                                    var dialogContainer = $("#inline-dialog-" + dialogId);

                                    //needed the timeout as the dialog is not shown yet.
                                    _.defer(function() {

                                        var otherDialogFocusable = dialogContainer.find(":focusable");

                                        var firstFocusable = otherDialogFocusable.first();
                                        firstFocusable.focus();
                                        firstFocusable.keydown(function(event) {
                                            if(isShiftTab(event)) {
                                                event.preventDefault();
                                                dialog.hide();
                                                grouptoggle.focus();
                                            }
                                        });

                                        var lastFocusable = otherDialogFocusable.last();
                                        lastFocusable.keydown(function(event) {
                                            if(isTab(event)) {
                                                dialog.hide();
                                                grouptoggle.focus();
                                            }
                                        });
                                    });
                                }
                            });
                        }
                    }
                }
            };


            var chart = new PieChartWithLegend(response.results, options);

            chart.render(gadgetElement);
            gadget.API.resize();
        }
    };

    /**
     * Render the configured piechart gadget.
     * @param {node} element to apply gadget to
     * @param {Object} preferences for gadget that have been configured.
     */
    DashboardItem.prototype.render = function(element, preferences) {
        var gadgetElement = $(".piechart-gadget", element);
        var gadget = this;

        preferences = preferencesBackwardCompatible(preferences);

        gadget.API.initRefresh(preferences, _.bind(gadget.render, gadget, element, preferences));
        gadget.API.showLoadingBar();

        var requestData;
        if (preferences.type === 'filter') {
            requestData = {
                filterId: preferences.id,
                statType: preferences.statType
            };
        } else {
            requestData = {
                jql: preferences.type + "=" + preferences.id,
                statType: preferences.statType
            };
        }

        $.ajax({
            method: "GET",
            url: AJS.contextPath() + '/rest/gadget/1.0/statistics',
            dataType: "json",
            data: requestData

        // The hide loading bar is in done/fail, not always, because d3 needs the element to be visible to render.  The
        // loading bar hides the element and therefore if the loading bar is still there when trying to render the chart
        // the piechart is rendered with size of 0.
        }).done(function(response) {
            if (response.filterTitle) {
                // Save the filter title so that we can display it in the edit screen.
                // This can't be saved to the actual preferences because calling `savePreferences`
                // will cause a re-render.
                gadget.filterTitleForEditScreen = response.filterTitle;
            }

            gadget.API.hideLoadingBar();
            gadget.resizeHandler = _.throttle(_.bind(gadget._renderChart, gadget, gadgetElement, response), 100);
            $(element).resize(gadget.resizeHandler);
            gadget._renderChart(gadgetElement, response);
        }).fail(function(message) {
            gadget.API.hideLoadingBar();
            var errors = parseErrorMessage(message.responseText);

            gadgetElement.html(JIRA.DashboardItem.PieChart.Templates.Errors({
                errors: errors
            }));
        });
    };

    /**
     * Render the configuration screen for the piechart gadget
     * @param {Node} element to render into
     * @param {Object} preferences for object.
     */
    DashboardItem.prototype.renderEdit = function(element, preferences) {
        var gadget = this;
        var gadgetElement = $(".piechart-gadget", element);
        if (gadget.resizeHandler)
        {
            $(element).removeResize(gadget.resizeHandler);
            delete gadget.resizeHandler;
        }

        gadget.API.showLoadingBar();
        $.ajax({
            method: "GET",
            url: AJS.contextPath() + "/rest/gadget/1.0/statTypes"
        }).done(function(data) {

            // Random prefix to avoid collisions with other instances of this gadget
            var prefix = gadget.API.getGadgetId() + "-";

            preferences = preferencesBackwardCompatible(preferences);

            preferences.name = gadget.filterTitleForEditScreen;

            gadget.API.setTitle( "Pie Chart" );

            // mark preferences.name as already escaped so soy doesn't re-escape it
            if (preferences.name) {
                preferences.name = soydata.VERY_UNSAFE.ordainSanitizedHtml(preferences.name);
            }

            gadgetElement.html(JIRA.DashboardItem.PieChart.Templates.Configuration({
                prefix: prefix,
                statTypes: data.stats,
                preferences: preferences
            }));

            var projectFilterOptions = {
                fieldID: prefix + "project-filter-picker",
                parentElement: gadgetElement,
                maxHeight: 140
            };

            //Mostly used for testing where we don't want a delay;
            if (gadget.options.delay) {
                projectFilterOptions.delay = gadget.options.delay;
            }

            ProjectFilterAutoComplete(projectFilterOptions);

            var form = $("form", gadgetElement);

            var cancelButton = $(".cancel", form);
            if (cancelButton) {
                cancelButton.click(function() {
                    gadget.API.closeEdit();
                });
            }

            function completeValidation(preferences, form) {
                if (!preferences.id || !preferences.type) {
                    $(".projectOrFilter-error", form).text("No project or filter specified.").show();
                    return false;
                }

                return true;
            }

            form.on("submit",function(e){
                e.preventDefault();

                var form = $(e.target);

                var preferences = {
                    name: form.find("input[name=name]").val(),
                    type: form.find("input[name=type]").val(),
                    id: form.find("input[name=id]").val(),
                    statType: form.find("select[name=statType]").val(),
                    refresh: gadget.API.getRefreshFieldValue('refresh-interval'),
                    // We need to override the stored `projectOrFilterId` so that when we go from this
                    // dashboard item back to the old gadget, the correct filter will be displayed.
                    // We can't use `undefined` or `null` because `savePreferences` stringifies the
                    // contents of the object it's given, so `null` becomes `"null"`, `undefined` becomes `"undefined"`,
                    // which won't be valid filters to search for.
                    projectOrFilterId: ''
                };

                if (completeValidation(preferences, form)) {
                    gadget.API.savePreferences(preferences);
                }
            });

            gadget.API.resize();
        }).fail(function() {
            gadgetElement.html(JIRA.DashboardItem.PieChart.Templates.ErrorRenderingConfiguration());
        }).always(function() {
            gadget.API.hideLoadingBar();
        });
    };

    return DashboardItem;
});;
;
/* module-key = 'com.atlassian.jira.gadgets:c3', location = 'static/lib/c3.js' */
// FOLLOWING LINE ADDED BY ATLASSIAN
define('jira-dashboard-items/lib/c3', ['jira-dashboard-items/lib/d3', 'underscore'], function(d3, _) {
/** @typedef {Object} c3 */
var c3 = {};

/**
 * A set of common defaults that c3 components can use.
 * Components should always be written to use sensible defaults in their properties,
 * instead of null or undefined, where possible.
 * This object is NOT designed to be overwritten at runtime to change global defaults.
 */
c3.defaults = {
    x: function(d) { return d[0]; },
    y: function(d) { return d[1]; }
};

/**
 * Throws an error if the value is not a number (either NaN or other types).
 *
 * Detect problems early by checking that values are numbers when expected,
 * rather than continuing to operate on NaNs as if things are all good.
 *
 * @param  {*} value - value to be tested
 * @return {*} the same value that was passed in
 */
c3.checkIsNumber = function(value) {
    if (typeof value !== 'number') {
        throw new Error("Expected a number, but received: " + value);
    }
    return value;
};

c3.isEmpty = function(value) {
    return !value || !value.length;
};

/**
 * Creates a property getter/setter function a la d3's getters and setters.
 * The actual property value is stored inside a closure.
 *
 *    var color = c3.prop('red');
 *    color(); // red
 *    color('blue'); // set value to blue
 *
 * The property's getter or setter can be customised by calling .get() or .set()
 * on the property function.
 * The getter function is passed the stored value and should return a transformed value.
 * The setter function is passed the newValue and the oldValue and should return
 * the value to be stored.
 *
 *    c3.prop(10).get(function(value) {
 *        return value + 'px';
 *    }).set(function(newValue, oldValue) {
 *        // Prevent the value from being set below 10
 *        if (newValue < 10) return oldValue;
 *        return newValue;
 *    });
 *
 * @param {*} [defaultValue] - the initial value of the property
 */
c3.prop = function(defaultValue) {
    var value = defaultValue;

    var getter = function(value) {
        return value;
    };

    var setter = function(newValue, oldValue) {
        return newValue;
    };

    function prop(newValue) {
        if (arguments.length === 0) {
            return getter.call(this, value);
        }

        value = setter.call(this, newValue, value);

        return this;
    }

    prop.get = function(newGetter) {
        getter = newGetter;
        return this;
    };

    prop.set = function(newSetter) {
        setter = newSetter;
        return this;
    };

    return prop;
};

/**
 * Generates a c3.prop that inherits its value from parent components if
 * the prop contains a null or undefined value.
 *
 * A defaultValue should be supplied in case no parent supplies a value.
 *
 *    c3.inherit('color', 'red');
 *
 * If the defaultValue needs to be evaluated, pass a function to .onDefault() instead.
 *
 *    c3.inherit('color').onDefault(function() {
 *        // Random color between red and blue
 *        return d3.scale.linear().range(['red', 'blue'])(Math.random());
 *    });
 *
 * @param {string} from - the name of the property on the parent to inherit from
 * @param {*} [defaultValue] - default value that is returned if no parent returns a value
 */
c3.inherit = function(from, defaultValue) {
    var onDefault;
    var prop = c3.prop().get(function(value) {
        if (value != null) return value;
        for (var parent = this.parent(); parent; parent = parent.parent()) {
            if (typeof parent[from] === 'function') {
                value = parent[from]();
                if (value != null) return value;
            }
        }
        return onDefault ? onDefault.call(this) : defaultValue;
    });
    prop.onDefault = function(fn) {
        onDefault = fn;
        return this;
    };
    return prop;
};

/**
 * Creates a function that can be used as an event trigger or to bind an event
 * handler.
 *
 *    var click = c3.event();
 *    click(handler); // bind an event handler
 *    click();        // trigger the event
 *
 * @param {function} [defaultHandler] - a handler that is run after other handlers,
 *    defining the default behaviour for the event.
 */
c3.event = function(defaultHandler) {
    var handlers = [];

    function bind(handler, context) {
        handlers.push({
            handler: handler,
            context: context
        });
    }

    function emit(eventData) {
        var emitContext = this;
        eventData = eventData || {};

        _.each(handlers, function(handlerEntry) {
            handlerEntry.handler.call(handlerEntry.context || emitContext, eventData);
        });

        if (defaultHandler) defaultHandler.call(this, eventData);
    }

    function event() {
        if (typeof arguments[0] === 'function') {
            bind.apply(this, arguments);
        } else {
            emit.apply(this, arguments);
        }
        return this;
    }

    event.off = function(handler, context) {
        handlers = _.reject(handlers, function(handlerEntry) {
            var matchesHandler = handler == null || handlerEntry.handler == handler;
            var matchesContext = context == null || handlerEntry.context == context;
            return matchesHandler && matchesContext;
        });
        return this;
    };

    return event;
};


/**
 * Plot an array of points as an area under the points
 */
c3.areaPlot = function() {
    return c3.component('areaPlot')
        .extend(c3.drawable())
        .extend(c3.plottable())
        .elementTag('path')
        .elementClass('area')
        .dataFilter(function(data) {
            return [data];
        })
        .extend({
            areaConstructor: c3.prop(d3.svg.area)
        })
        .update(function(event) {
            var area = this.areaConstructor()()
                .x(this.x());
            if (this.cartesian()) {
                area
                    .y0(this.height())
                    .y1(this.y());
            } else {
                area
                    .y0(this.y())
                    .y1(0);
            }

            event.selection.attr('d', area(this.data()));
        });
};

c3.axis = function() {
    return c3.component('axis')
        .extend(c3.plottable())
        .extend(function() {
            this.selection().call(this.axis());
        })
        .extend({
            axisConstructor: c3.inherit('axisConstructor', d3.svg.axis),
            orient: c3.prop('bottom'),
            horizontal: function() {
                var orient = this.orient();
                return orient === 'bottom' || orient === 'top';
            },
            axis: function() {
                var horizontal = this.horizontal();
                return this.axisConstructor().call(this)
                    .scale(horizontal ? this.xScale() : this.yScale())
                    .orient(this.orient());
            }
        });
};

/**
 * A layout that consists of 5 regions (center, north, south, west, east),
 * each of which can contain a single component.
 *   - North and south must have their height set
 *   - West and east must have their width set
 *
 * The width and height of center is automatically calculated based on the other regions.
 */
c3.borderLayout = function() {
    var region = function() {
        return c3.prop().set(function(component) {
            return component.parent(this);
        });
    };
    var regionsDrawable = c3.drawable()
        .extend({
            data: function() {
                return borderLayout.occupiedRegions();
            }
        }).dataKey(function(d) {
            return d.name;
        })
        .update(function(event) {
            var positions = borderLayout.positions();
            event.selection.each(function(d) {
                var regionContainer = d3.select(this);
                var position = positions[d.name];
                regionContainer.attr('transform', 'translate(' + position.left + ',' + position.top + ')');
                d.component
                    .width(position.width)
                    .height(position.height);
                d.component(regionContainer);
            });
        });
    var borderLayout = c3.component('borderLayout')
        .extend(c3.plottable())
        .extend(function() {
            regionsDrawable(this.selection());
        })
        .extend({
            center: region(),
            north:  region(),
            south:  region(),
            west:   region(),
            east:   region(),

            xRange: function() {
                return [0, this.centerWidth()];
            },
            yRange: function() {
                return [this.centerHeight(), 0];
            },
            centerWidth: function() {
                // TODO Optimise
                return this.positions().center.width;
            },
            centerHeight: function() {
                // TODO Optimise
                return this.positions().center.height;
            },
            occupiedRegions: function() {
                var borderLayout = this;
                return _.compact(_.map(['north', 'south', 'west', 'east', 'center'], function(name) {
                    var component = borderLayout[name]();
                    return component ? {
                        name: name,
                        component: borderLayout[name]()
                    } : null;
                }));
            },
            positions: function() {
                var margins = {
                    top:    c3.checkIsNumber(this.north() ? this.north().height() : 0),
                    bottom: c3.checkIsNumber(this.south() ? this.south().height() : 0),
                    left:   c3.checkIsNumber(this.west() ? this.west().width() : 0),
                    right:  c3.checkIsNumber(this.east() ? this.east().width() : 0)
                };
                var layoutWidth = c3.checkIsNumber(this.width());
                var layoutHeight = c3.checkIsNumber(this.height());

                var positions = {};
                var center = positions.center = {
                    left: margins.left,
                    top: margins.top,
                    width: layoutWidth - margins.left - margins.right,
                    height: layoutHeight - margins.top - margins.bottom
                };
                if (this.north()) {
                    positions.north = {
                        top: margins.top,
                        left: margins.left,
                        height: margins.top,
                        width: center.width
                    };
                }
                if (this.south()) {
                    positions.south = {
                        top: layoutHeight - margins.bottom,
                        left: margins.left,
                        height: margins.bottom,
                        width: center.width
                    };
                }
                if (this.west()) {
                    positions.west = {
                        top: margins.top,
                        left: margins.left,
                        height: center.height,
                        width: margins.left
                    };
                }
                if (this.east()) {
                    positions.east = {
                        top: margins.top,
                        left: layoutWidth - margins.right,
                        height: center.height,
                        width: margins.right
                    };
                }
                return positions;
            }
        });
    return borderLayout;
};

/**
 * Plot an array of points as circles
 */
c3.circlePlot = function() {
    return c3.component('circlePlot')
        .extend(c3.drawable())
        .extend(c3.plottable())
        .elementTag('circle')
        .update(function(event) {
            event.selection
                .attr('cx', this.x())
                .attr('cy', this.y())
                .attr('r', this.radiusAccessor());
        })
        .extend({
            radiusAccessor: c3.prop(function() { return 4; })
        });
};

/**
 * A component mixin that add a boolean `clipped` property (default: false)
 * to a c3.component. If set to true, sets a clipping path on the component
 * that prevents it's content from overflowing
 *
 */
c3.clippable = (function() {
    var clippingPathCounter = 0;

    return function () {
        return c3.component('clippable')
            .extend({
                clipped: c3.prop(false)
            })
            .extend(function() {
                if (!this.clipped()) return;

                var target = this;
                var clip = c3.singular()
                    .elementTag('clipPath')
                    .enter(function(event) {
                        var randomId = 'c3clip' + clippingPathCounter;
                        clippingPathCounter++;
                        target.selection().attr('clip-path', 'url(#' + randomId + ')');
                        event.selection
                            .attr('id', randomId)
                            .append('rect')
                            .attr('x', '0')
                            .attr('y', '0')
                            .attr('fill', 'none');
                    })
                    .update(function(event) {
                        event.selection.select('rect')
                            .attr('width', target.width())
                            .attr('height', target.height());
                    });
                clip(this.selection());
            });
    };
}());

/*
 * Author: Patrick Teen (Atlassian) 2013
 */
(function (figue) {
    if (!figue) return;

    function _internalXAccessor(d) { return d.point[0]; }
    function _internalYAccessor(d) { return d.point[1]; }
    function _buildPointFromTree(tree) {
        var point = _.extend({}, {
            point: [
                this.xScale().invert(tree.centroid[0]),
                this.yScale().invert(tree.centroid[1])
            ],
            size: tree.size,
            distance: tree.dist,
            isCluster: false
        });
        if (tree.left || tree.right) {
            point.isCluster = true;
        }
        point.label = _resolveAllChildLabels(tree);
        return point;
    }
    function _resolveAllChildLabels(tree) {
        var result = [];
        if (tree && tree.label == -1) {
            result.push.apply(result, _resolveAllChildLabels(tree.left));
            result.push.apply(result, _resolveAllChildLabels(tree.right));
        } else {
            result.push(tree.label);
        }
        return result;
    }
    function _pruneAgglomerate(tree, clusteredResult, unclusteredResult) {
        if (tree) {
            if (tree.dist && tree.dist > this.threshold()) {
                _pruneAgglomerate.call(this, tree.left, clusteredResult, unclusteredResult);
                _pruneAgglomerate.call(this, tree.right, clusteredResult, unclusteredResult);
            } else {
                var point = _buildPointFromTree.call(this, tree );
                point.isCluster ? clusteredResult.push(point) : unclusteredResult.push(point);
            }
        }
    }
    function _updateClustering() {
        var clustered = [],
            unclustered = [];

        var x = this.x(),
            y = this.y();

        var vectorLabels = _.map(this.data(), this.labelAccessor());
        var scaledVectors = _.map(this.data(), function(element) {
            return [
                x(element),
                y(element)
            ]
        }, this);

        var agglomerate = figue.agglomerate(vectorLabels, scaledVectors, figue.MAX_DISTANCE, figue.COMPLETE_LINKAGE);

        _pruneAgglomerate.call(this, agglomerate, clustered, unclustered);

        this.getLayer('clusteredLayer').data(clustered);
        this.getLayer('unclusteredLayer').data(unclustered);
    }
    c3.clusteredCirclePlot = function() {
        var clusteredCirclePlot = c3.component()
            .extend({
                clustered: c3.prop([]),
                unclustered: c3.prop([]),
                clusterRadiusAccessor: c3.prop(function() { return 10; }),
                singletonRadiusAccessor: c3.prop(function() { return 5; })
            });
        clusteredCirclePlot
            .extend(_updateClustering)
            .extend(c3.layerable()
                .addLayer('clusteredLayer', c3.circlePlot()
                    .xAccessor(_internalXAccessor)
                    .yAccessor(_internalYAccessor)
                    .elementClass('cluster')
                    .radiusAccessor(function (elem) {
                        return clusteredCirclePlot.clusterRadiusAccessor()(elem);
                    })
            )
                .addLayer('unclusteredLayer', c3.circlePlot()
                    .xAccessor(_internalXAccessor)
                    .yAccessor(_internalYAccessor)
                    .elementClass('singleton')
                    .radiusAccessor(function (elem) {
                        return clusteredCirclePlot.singletonRadiusAccessor()(elem);
                    })
            )
                .extend({
                    labelAccessor: c3.prop(function(element) { return element.issue; }),
                    threshold: c3.prop(10)
                })
        );
        return clusteredCirclePlot;
    };
}(window.figue));

/**
 * The root c3 component constructor.
 *
 * A component is a function that can be applied to a d3 selection.
 *
 * A component can be applied to any number of selections.
 *
 *    var myComponent = c3.component();
 *    myComponent(selection1);
 *    myComponent(selection2);
 *
 * When applied to a selection, the component has access to the selection through
 * this.selection().
 *
 * A component can be extended by adding properties before it is applied.
 *
 *    var myComponent = c3.component().extend({
 *        color: c3.prop('red'),
 *        click: c3.event(),
 *        saySomething: function() { alert('Something!'); }
 *    });
 *
 * A component can also be extended by mixing in another component.
 *
 *    var myComponent = c3.component().extend(otherComponent);
 *
 * A component can have a parent component, by setting the parent as property.
 *
 *    var parent = c3.component();
 *    var child = c3.component().parent(parent);
 *
 * This allows children components to access their parents' properties by
 * calling this.parent(), and to inherit parent properties through c3.inherit().
 *
 * @param {string} [displayName] - name to show when debugging
 */
c3.component = function(displayName) {
    var mixins = [];

    function makeComponentFunction() {
        var component = function (selection) {
            return component.applyTo(component, selection);
        };
        return component;
    }

    var component = makeComponentFunction();

    /**
     * Copy src into dest, but excluding keys in exclude
     * @param {function|object} dest
     * @param {function|object} src
     * @param {function|object} [exclude]
     */
    function selectiveCopy(dest, src, exclude) {
        // Can't use _.each as src can be a function, in which case
        // _.each will see src.length and think it's an array
        for (var key in src) {
            if (exclude && key in exclude) continue;
            dest[key] = src[key];
        }
        return dest;
    }

    var componentCommon = {
        displayName: displayName,
        selection: c3.prop(null),
        parent: c3.prop(null),
        /**
         * Applies a component to a selection, setting base as the context
         * @param {c3.component} base
         * @param {d3.selection} selection
         */
        applyTo: function(base, selection) {
            if (selection) component.selection(selection);
            _.each(mixins, function(mixin) {
                if (mixin.applyTo) {
                    mixin.applyTo(base, selection);
                } else {
                    mixin.call(base, selection);
                }
            });
            return component;
        },
        /**
         * Extend the component with additional behaviour and/or properties.
         * @param {c3.component|function|object} mixable
         */
        extend: function(mixable) {
            if (typeof mixable === 'function') {
                if (mixable.parent) {
                    mixable.parent(component);
                }
                mixins.push(mixable);
            }
            return selectiveCopy(component, mixable, componentCommon);
        }
    };

    return _.extend(component, componentCommon);
};

c3.deviationPlot = function() {
    return c3.component('deviationPlot')
        .extend(c3.drawable())
        .extend(c3.plottable())
        .elementTag('path')
        .elementClass('area')
        .dataFilter(function(data) {
            return [data];
        })
        .update(function(event) {
            var yAccessor = this.yAccessor();
            var deviationAccessor = this.deviationAccessor();
            var yScale = this.yScale();
            var area = d3.svg.area()
                .x(this.x())
                .y0(function(d) {
                    return yScale(yAccessor(d) + deviationAccessor(d));
                })
                .y1(function(d) {
                    return yScale(Math.max(yAccessor(d) - deviationAccessor(d), 0));
                });

            event.selection.attr('d', area(this.data()));
        })
        .extend({
            deviationAccessor: c3.prop(function(d) { return d[2]; })
        });
};

/**
 * A component that maps data to elements, using d3's enter and exit joins
 * to add/remove elements as necessary.
 */
c3.drawable = function() {
    return c3.component('drawable')
        .extend(c3.withData())
        .extend(c3.withElements())
        .extend(function() {
            var binding = this.dataBinding();
            this.enter({ selection: this.drawEnter(binding.enter()) });
            this.exit({ selection: this.drawExit(binding.exit()) });
            this.update({ selection: binding });
        })
        .extend({
            enter:         c3.event(),
            exit:          c3.event(),
            update:        c3.event(),
            dataFilter:    c3.prop(_.identity),
            dataBinding: function() {
                var data = this.dataFilter()(this.data());
                return this.elements().data(data, this.dataKey());
            },
            drawEnter: function(enter) {
                var elements = enter.append(this.elementTag());
                var elementClass = this.elementClass();
                if (elementClass) {
                    elements.classed(elementClass, true);
                }
                return elements;
            },
            drawExit: function(exit) {
                return exit.remove();
            }
        });
};

/**
 * Fits the component to the dimensions of it's parent node.
 */
c3.fitToParent = function () {
    return c3.component('fitToParent')
        .extend({
            width: c3.prop(),
            height: c3.prop()
        })
        .extend(function (){
            var domParent = this.selection().node().domNode.parentElement;

            this.height(c3.checkIsNumber(domParent.clientHeight));
            this.width(c3.checkIsNumber(domParent.clientWidth));
        });
};
c3.gridLines = function() {
    return c3.component('gridLines')
        .extend(c3.axis())
        .axisConstructor(function() {
            var tickSize;
            switch (this.orient()) {
                case 'left': tickSize = -this.width(); break;
                case 'right': tickSize = this.width(); break;
                case 'top': tickSize = -this.height(); break;
                case 'bottom': tickSize = this.height(); break;
            }
            return d3.svg.axis().tickSize(tickSize).tickFormat('');
        });
};

/**
 * IE8 and below use r2d3 to render c3 charts. Because we need responsive
 * charts and can't set fixed dimensions on the SVG element, r2d3 fails to get
 * a useable height and width for RaphaelJS to initialise a canvas. So we look
 * for the dimensions of the parent DOM node and pass those instead.
 */
c3.ieDimensions = function () {
    // Only apply for IE8 and below
    if (document.documentMode && document.documentMode < 9) {
        return c3.component('ieDimensions')
            .extend(c3.fitToParent());
    }
};

c3.labelledAxis = function() {
    return c3.component('labelledAxis')
        .extend(c3.axis())
        .extend({
            text: c3.prop('')
        })
        .extend(function() {
            // Render label
            var text = this.text();
            var label = c3.singular()
                .elementTag('text')
                .elementClass('axis-label')
                .enter(function(event) {
                    event.selection.attr('text-anchor', 'middle');
                })
                .update(function(event) {
                    event.selection.text(text);
                });
            var labelElement = label(this.selection()).elements();

            // Positioning
            var x = 0,
                y = 0,
                degrees = 0;
            var bBox = labelElement.node().getBBox();
            switch(this.orient()) {
                case 'left':
                    degrees = 270;
                    x = -1 * this.width() + bBox.height; // bbox not yet rotated
                    y = this.height() / 2;
                    break;
                case 'right':
                    degrees = 90;
                    x = this.width() - bBox.height;
                    y = this.height() / 2;
                    break;
                case 'top':
                    degrees = 0;
                    x = this.width() / 2;
                    y = -1 * this.height() + bBox.height;
                    break;
                default: // bottom
                    degrees = 0;
                    x = this.width() / 2;
                    y = this.height() - bBox.height / 2;
            }
            labelElement.attr('transform', 'translate(' + x + ', ' + y +') rotate(' + degrees + ', 0, 0)');
        });
};

/**
 * Allows components to be layered on top of each other and
 * share common data and/or scales
 */
c3.layerable = function() {
    var layerDrawable = c3.drawable()
        .elementClass('layer')
        .update(function(event) {
            event.selection.each(function(d, i) {
                d.component(d3.select(this).classed(d.name, true));
            });
        });

    return c3.component('layerable')
        .extend(function() {
            layerDrawable(this.selection());
        })
        .extend(c3.plottable())
        .extend({
            layers: function() {
                return layerDrawable.data();
            },
            getLayer: function(name) {
                var layer = _.findWhere(this.layers(), { name: name });
                return layer ? layer.component : undefined;
            },
            addLayer: function(name, component) {
                if (!this.getLayer(name)) {
                    this.layers().push({
                        name: name,
                        component: component.parent(this)
                    });
                }
                return this;
            },
            //TODO: Talk to david about adding this.
            prependLayer: function(name, component) {
                if (!this.getLayer(name)) {
                    this.layers().unshift({
                        name: name,
                        component: component.parent(this)
                    });
                }
                return this;
            },
            removeLayer: function(name) {
                var layers = this.layers();
                var removed = _.reject(layers, function(layer) {
                    return layer.name === name;
                });
                if (removed.length !== layers.length) {
                    this.layers(removed);
                }
                return this;
            }
        });
};

/**
 * Plot an array of points as a line
 */
c3.linePlot = function() {
    return c3.component('linePlot')
        .extend(c3.drawable())
        .extend(c3.plottable())
        .elementTag('path')
        .elementClass('line')
        .dataFilter(function(data) {
            return [data]; // Map all of the data values to a single element
        })
        .extend({
            lineConstructor: c3.prop(d3.svg.line)
        })
        .update(function(event) {
            var line = this.lineConstructor()()
                .x(this.x())
                .y(this.y());

            event.selection.attr('d', line(this.data()))
                .attr('stroke', 'black')
                .attr('fill', 'none');
        });
};

/**
 * A component that maps data to x and y coordinates in a container
 * with width and height.
 */
c3.plottable = function() {
    return c3.component('plottable')
        .extend(c3.withData())
        .extend(c3.withDimensions())
        .extend(c3.clippable())
        .extend({
            x: function() {
                var xScale = this.xScale();
                var xAccessor = this.xAccessor();
                return function(d, i) {
                    return xScale(xAccessor(d, i));
                };
            },
            y: function() {
                var yScale = this.yScale();
                var yAccessor = this.yAccessor();
                return function(d, i) {
                    return yScale(yAccessor(d, i));
                };
            },
            xAccessor: c3.inherit('xAccessor', c3.defaults.x),
            yAccessor: c3.inherit('yAccessor', c3.defaults.y),
            xScaleConstructor: c3.inherit('xScaleConstructor', d3.scale.linear),
            yScaleConstructor: c3.inherit('yScaleConstructor', d3.scale.linear),
            xDomain: c3.inherit('xDomain').onDefault(function() {
                if (c3.isEmpty(this.data())) return;

                var min = c3.checkIsNumber(d3.min(this.data(), this.xAccessor()));
                var max = c3.checkIsNumber(d3.max(this.data(), this.xAccessor()));
                return [min, max];
            }),
            yDomain: c3.inherit('yDomain').onDefault(function() {
                if (c3.isEmpty(this.data())) return;

                var min = c3.checkIsNumber(d3.min(this.data(), this.yAccessor()));
                var max = c3.checkIsNumber(d3.max(this.data(), this.yAccessor()));
                return [min, max];
            }),
            xRange: c3.inherit('xRange').onDefault(function() {
                var width = c3.checkIsNumber(this.width());
                return [0, width];
            }),
            yRange: c3.inherit('yRange').onDefault(function() {
                var height = c3.checkIsNumber(this.height());
                return this.cartesian() ? [height, 0] : [0, height];
            }),
            xScale: function() {
                return this.xScaleConstructor()()
                    .domain(this.xDomain())
                    .range(this.xRange());
            },
            yScale: function() {
                return this.yScaleConstructor()()
                    .domain(this.yDomain())
                    .range(this.yRange());
            },
            cartesian: c3.prop(true)
        });
};

c3.singular = function() {
    return c3.component('singular')
        .extend(c3.withElements())
        .extend({
            enter: c3.event(),
            update: c3.event()
        })
        .extend(function() {
            var element = this.elements();
            if (!element.node()) {
                element = this.selection().append(this.elementTag());
                if (this.elementClass()) {
                    element.classed(this.elementClass(), true);
                }
                this.enter({ selection: element });
            }
            this.update({ selection: element });
        });
};

c3.withData = function() {
    return c3.component('withData')
        .extend({
            data: c3.inherit('data', []),
            dataKey: c3.inherit('dataKey')
        });
};

c3.withDimensions = function() {
    return c3.component('withDimensions')
        .extend({
            width: c3.inherit('width').onDefault(function() {
                return parseInt(this.selection().style('width'), 10) || 0;
            }),
            height: c3.inherit('height').onDefault(function() {
                return parseInt(this.selection().style('height'), 10) || 0;
            })
        });
};

c3.withElements = function() {
    return c3.component('withElements')
        .extend({
            elementTag: c3.prop('g'),
            elementClass: c3.prop(''),
            elementSelector: function() {
                return this.elementClass() ?
                    this.elementTag() + '.' + this.elementClass() :
                    this.elementTag();
            },
            elements: function() {
                var containerNode = this.selection().node();
                return this.selection().selectAll(this.elementSelector()).filter(function() {
                    return this.parentNode === containerNode;
                });
            }
        });
};

// FOLLOWING LINES ADDED BY ATLASSIAN
return c3;
});

AJS.namespace('c3', null, require('jira-dashboard-items/lib/c3'));
;
;
/* module-key = 'com.atlassian.jira.gadgets:dual-plottable', location = 'static/components/charts/components/DualPlottable.js' */
/**
 * Represents a plottable data set that for each x maps to two y values where the y value is [y0, y1].
 * The main role of this component is to provide helper functions to access the y values for a dataset.
 *
 * @module DualPlottable
 */
define('jira-dashboard-items/components/charts/components/dualplottable', [
    'jira-dashboard-items/lib/c3',
    'jira-dashboard-items/lib/d3'
], function(
    c3,
    d3
) {

    return c3.component('dualPlottable')
        .extend(c3.plottable())
        .extend({
            y0: function () {
                var yScale = this.yScale();
                var y0Accessor = this.y0Accessor();
                return function (d, i) {
                    return yScale(y0Accessor(d, i));
                };
            },
            y1: function () {
                var yScale = this.yScale();
                var y1Accessor = this.y1Accessor();
                return function (d, i) {
                    return yScale(y1Accessor(d, i));
                };
            },
            y0Accessor: function () {
                var yAccessor = this.yAccessor();
                return function (d, i) {
                    return yAccessor(d, i)[0];
                };
            },
            y1Accessor: function () {
                var yAccessor = this.yAccessor();
                return function (d, i) {
                    return yAccessor(d, i)[1];
                };
            },
            yDomain: function() {
                if (c3.isEmpty(this.data())) {
                    return;
                }

                var y0Accessor = this.y0Accessor();
                var y1Accessor = this.y1Accessor();

                var min = c3.checkIsNumber(d3.min(this.data(), function(data, index) {
                    var y0 = y0Accessor(data, index);
                    var y1 = y1Accessor(data, index);
                    return d3.min([y0, y1]);
                }));

                var max = c3.checkIsNumber(d3.max(this.data(), function(data, index) {
                    var y0 = y0Accessor(data, index);
                    var y1 = y1Accessor(data, index);
                    return d3.max([y0, y1]);
                }));
                return [min, max];
            }
        });
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:area-between-plot', location = 'static/components/charts/components/AreaBetweenPlot.js' */
define('jira-dashboard-items/components/charts/components/area-between-plot', [
    'jira-dashboard-items/components/charts/components/dualplottable',
    'jira-dashboard-items/lib/c3'
], function(
    DualPlottable,
    c3
) {

    /**
     * Creates an area between two y values. This depends on dual plottable, therefore the yAccessor must return an
     * array of size of at least 2.
     *
     * @exports jira-dashboard-items/components/charts/components/area-between-plot
     * @returns {c3.component}
     */
    return function() {

        return c3.component('areaBetweenPlot')
            .extend(c3.areaPlot())
            .extend(DualPlottable())
            .extend({

                /**
                 * Creates a function to determine the bottom of the area plot at a certain x position.
                 * @returns {Function}
                 */
                areaBottom: function () {
                    var y0 = this.y0();
                    return function (d) {
                        return y0(d);
                    };
                },

                /**
                 * Creates a function to determine the top of the area plot at a certain x position.
                 * @returns {Function}
                 */
                areaTop: function () {
                    var y1 = this.y1();
                    return function (d) {
                        return y1(d);
                    };
                },

                /**
                 * Calculate the area range for the given point.
                 * @param event
                 */
                update: function (event) {
                    var area = this.areaConstructor()()
                        .x(this.x());

                    area.y0(this.areaBottom());

                    area.y1(this.areaTop());
                    event.selection.attr('d', area);
                }
            });
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:area-between-plot-one-way', location = 'static/components/charts/components/AreaBetweenPlotOneWay.js' */
/**
 * Only draws the area from one direction, e.g. if the first point is above the second we draw the area but not the
 * other way around.
 *
 * @pre data must be an array with the first value x and y accessor must return an array, where first is y0 and
 * second is y1. TODO: Tried fixing this but to get it working correctly takes too much time and fine tuning.
 *
 * @module jira-dashboard-items/components/charts/components/area-between-plot-one-way
 */
define('jira-dashboard-items/components/charts/components/area-between-plot-one-way', [
    'jira-dashboard-items/components/charts/components/area-between-plot',
    'jira-dashboard-items/lib/c3'
], function(
    AreaBetweenPlot,
    c3
) {

    var AREA_FIRST_ABOVE = 0; //Draw area down to second if first above
    var AREA_SECOND_ABOVE = 1; //Draw area down to first if second above

    /**
     * Used to generate an AreaBetweenPlotOneWay component with a certain direction.
     *
     * @constructor
     * @param {number} direction
     * @returns {c3.component}
     */
    var AreaBetweenPlotOneWay = function(direction) {
        return c3.component('areaBetweenPlotOneWay')
            .extend(AreaBetweenPlot())
            .extend({
                /**
                 * Add the point of intersections into the data so that it can properly generate the area when
                 * the overlap between points.
                 * @returns {Function}
                 */
                dataFilter: function() {
                    var self = this;
                    return function(data) {
                        var modifiedData = includePointsOfIntersection(data, self.xAccessor(), self.yAccessor());
                        return [modifiedData];
                    };
                },

                /**
                 * TODO: Remove this. Creates dependency that data must be in the format [x, [y0, y1]].
                 * Don't even bother trying to fix this. It is hell and you will not succeeed.
                 * @returns {Function}
                 */
                x: function() {
                    var xScale = this.xScale();
                    var xAccessor = function(d) {
                        return d[0];
                    };
                    return function(d) {
                        return xScale(xAccessor(d));
                    };
                },

                /**
                 * @override AreaBetweenPlot.areaBottom
                 * @returns {Function}
                 */
                areaBottom: function() {
                    var self = this;
                    //Put the smallest line value at the bottom
                    return function(d) {
                        var first = self.y0Accessor()(d);
                        var second = self.y1Accessor()(d);
                        if (first > second) {
                            return self.y1()(d);
                        } else {
                            return self.y0()(d);
                        }
                    };
                },

                /**
                 * @override AreaBetweenPlot.areaTop
                 * @returns {Function}
                 */
                areaTop: function() {
                    var self = this;
                    return function(d) {
                        //Put itself as the top
                        if (direction === AREA_FIRST_ABOVE) {
                            return self.y0()(d);
                        } else if (direction === AREA_SECOND_ABOVE) {
                            return self.y1()(d);
                        }
                        throw "SHOULD HAVE A VALID DIRECTION";
                    };
                }
            });
    };


    /**
     * Determine if these values have opposite sign values.
     * @param {number} a
     * @param {number} b
     * @returns {boolean}
     */
    function oppositeSigns(a, b) {
        if (a < 0 && b > 0) {
            return true;
        } else if (a > 0 && b < 0) {
            return true;
        }
        return false;
    }

    /**
     * Given a data set it calculates any points of intersections and places them in between the data slots.
     * @param {Array} data to process
     * @param {Function} xAccessor to grab the x value from the data point.
     * @param {Function} yAccessor to grab the y value from the data point.
     * @returns {Array} including any point of interceptions
     */
    function includePointsOfIntersection(data, xAccessor, yAccessor) {
        var newData = [];

        data.forEach(function(entry, index) {

            var currentX = xAccessor(entry);
            var currentY = yAccessor(entry);

            var notFirst = index > 0;

            if (notFirst) {
                var previous = data[index - 1];
                var previousX = xAccessor(previous);
                var previousY = yAccessor(previous);
                var previousYA = previousY[0];
                var previousYB = previousY[1];

                var currentYA = currentY[0];
                var currentYB = currentY[1];

                var hasFlippedBetween = (oppositeSigns(previousYA - previousYB, currentYA - currentYB));

                if (hasFlippedBetween) {
                    var midX;
                    var midY;

                    var gradientA = (currentYA - previousYA) / (currentX - previousX);
                    var gradientB = (currentYB - previousYB) / (currentX - previousX);

                    var yInterceptA = currentYA - gradientA * currentX;
                    var yInterceptB = currentYB - gradientB * currentX;

                    midX = (yInterceptB - yInterceptA) / (gradientA - gradientB);

                    midY = gradientA * midX + yInterceptA;

                    newData.push([midX, [midY, midY]]);
                }
            }

            newData.push([currentX, currentY]);
        });
        return newData;
    }

    /**
     * @exports jira-dashboard-items/components/charts/components/area-between-plot-one-way
     */
    return {
        firstAbove: function() {
            return AreaBetweenPlotOneWay(AREA_FIRST_ABOVE);
        },
        secondAbove: function() {
            return AreaBetweenPlotOneWay(AREA_SECOND_ABOVE);
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:linecomparison-graph', location = 'static/components/charts/components/LineComparisonGraph.js' */
/**
 * Represents a dual line graph with areas between that can be individually styled.
 *
 * @note The data must be in the format [x, [y0, y1]]. This is a huge flaw in re-useability. However, getting it to
 * work like this is too difficult with the time for this project. Tried to be fixed but it is too hard.
 *
 * @module LineComparisonGraph
 */
define('jira-dashboard-items/components/charts/components/linecomparison-graph', [
    'jquery',
    'jira-dashboard-items/components/charts/components/area-between-plot-one-way',
    'jira-dashboard-items/lib/c3'
], function(
    $,
    AreaBetweenPlotOneWay,
    c3
) {

    var LineAndAreaBetweenPlotOneWay = {
        first: function() {
            return c3.layerable()
                .addLayer('area', AreaBetweenPlotOneWay.firstAbove())
                .addLayer('line', c3.linePlot()
                    .yAccessor(function(d) {
                        return d[1][0];
                    })
                );
        },
        second: function() {
            return c3.layerable()
                .addLayer('area', AreaBetweenPlotOneWay.secondAbove())
                .addLayer('line', c3.linePlot()
                    .yAccessor(function(d) {
                        return d[1][1];
                    })
            );
        }
    };

    /**
     * @typedef {Object} LineComparisonGraphOptions
     * @property {String} firstName is the class name of the first line
     * @property {String} secondName is the class name of the second line
     **/


    /**
     * @constructor
     * @param {LineComparisonGraphOptions} options
     */
    return function(options) {
        return c3.layerable()
            .addLayer(options.firstName, LineAndAreaBetweenPlotOneWay.first())
            .addLayer(options.secondName,  LineAndAreaBetweenPlotOneWay.second());
    };
});
;
;
/* module-key = 'com.atlassian.plugin.jslibs:moment-2.6.0', location = 'libs/moment/2.6.0/moment-2.6.0.js' */
/////////// Modified by Atlassian ///////////
(function(factory) {
    define('atlassian/libs/moment-2.6.0', function () {
        var env = {};
        factory.call(env);
        return env.moment;
    });
})(function(){
/////// End of Atlassian modification ///////


//! moment.js
//! version : 2.6.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
     Constants
     ************************************/

    var moment,
        VERSION = "2.6.0",
    // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

    // internal storage for language config files
        languages = {},

    // moment internal properties
        momentProperties = {
            _isAMomentObject: null,
            _i : null,
            _f : null,
            _l : null,
            _strict : null,
            _isUTC : null,
            _offset : null,  // optional. Combine with _isUTC
            _pf : null,
            _lang : null  // optional
        },

    // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

    // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

    // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

    // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

    //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

    // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

    // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

    // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

    // format function strings
        formatFunctions = {},

    // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        function printMsg() {
            if (moment.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' && console.warn) {
                console.warn("Deprecation warning: " + msg);
            }
        }
        return extend(function () {
            if (firstTime) {
                printMsg();
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
     Constructors
     ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
     Helpers
     ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function cloneMoment(m) {
        var result = {}, i;
        for (i in m) {
            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                result[i] = m[i];
            }
        }

        return result;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                    m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                        m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                            m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                                    m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                                        -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
     Languages
     ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
     Formatting
     ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
     Parsing
     ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
            case 'Q':
                return parseTokenOneDigit;
            case 'DDDD':
                return parseTokenThreeDigits;
            case 'YYYY':
            case 'GGGG':
            case 'gggg':
                return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
            case 'Y':
            case 'G':
            case 'g':
                return parseTokenSignedNumber;
            case 'YYYYYY':
            case 'YYYYY':
            case 'GGGGG':
            case 'ggggg':
                return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
            case 'S':
                if (strict) { return parseTokenOneDigit; }
            /* falls through */
            case 'SS':
                if (strict) { return parseTokenTwoDigits; }
            /* falls through */
            case 'SSS':
                if (strict) { return parseTokenThreeDigits; }
            /* falls through */
            case 'DDD':
                return parseTokenOneToThreeDigits;
            case 'MMM':
            case 'MMMM':
            case 'dd':
            case 'ddd':
            case 'dddd':
                return parseTokenWord;
            case 'a':
            case 'A':
                return getLangDefinition(config._l)._meridiemParse;
            case 'X':
                return parseTokenTimestampMs;
            case 'Z':
            case 'ZZ':
                return parseTokenTimezone;
            case 'T':
                return parseTokenT;
            case 'SSSS':
                return parseTokenDigits;
            case 'MM':
            case 'DD':
            case 'YY':
            case 'GG':
            case 'gg':
            case 'HH':
            case 'hh':
            case 'mm':
            case 'ss':
            case 'ww':
            case 'WW':
                return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
            case 'M':
            case 'D':
            case 'd':
            case 'H':
            case 'h':
            case 'm':
            case 's':
            case 'w':
            case 'W':
            case 'e':
            case 'E':
                return parseTokenOneOrTwoDigits;
            case 'Do':
                return parseTokenOrdinal;
            default :
                a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
                return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
            // QUARTER
            case 'Q':
                if (input != null) {
                    datePartArray[MONTH] = (toInt(input) - 1) * 3;
                }
                break;
            // MONTH
            case 'M' : // fall through to MM
            case 'MM' :
                if (input != null) {
                    datePartArray[MONTH] = toInt(input) - 1;
                }
                break;
            case 'MMM' : // fall through to MMMM
            case 'MMMM' :
                a = getLangDefinition(config._l).monthsParse(input);
                // if we didn't find a month name, mark the date as invalid.
                if (a != null) {
                    datePartArray[MONTH] = a;
                } else {
                    config._pf.invalidMonth = input;
                }
                break;
            // DAY OF MONTH
            case 'D' : // fall through to DD
            case 'DD' :
                if (input != null) {
                    datePartArray[DATE] = toInt(input);
                }
                break;
            case 'Do' :
                if (input != null) {
                    datePartArray[DATE] = toInt(parseInt(input, 10));
                }
                break;
            // DAY OF YEAR
            case 'DDD' : // fall through to DDDD
            case 'DDDD' :
                if (input != null) {
                    config._dayOfYear = toInt(input);
                }

                break;
            // YEAR
            case 'YY' :
                datePartArray[YEAR] = moment.parseTwoDigitYear(input);
                break;
            case 'YYYY' :
            case 'YYYYY' :
            case 'YYYYYY' :
                datePartArray[YEAR] = toInt(input);
                break;
            // AM / PM
            case 'a' : // fall through to A
            case 'A' :
                config._isPm = getLangDefinition(config._l).isPM(input);
                break;
            // 24 HOUR
            case 'H' : // fall through to hh
            case 'HH' : // fall through to hh
            case 'h' : // fall through to hh
            case 'hh' :
                datePartArray[HOUR] = toInt(input);
                break;
            // MINUTE
            case 'm' : // fall through to mm
            case 'mm' :
                datePartArray[MINUTE] = toInt(input);
                break;
            // SECOND
            case 's' : // fall through to ss
            case 'ss' :
                datePartArray[SECOND] = toInt(input);
                break;
            // MILLISECOND
            case 'S' :
            case 'SS' :
            case 'SSS' :
            case 'SSSS' :
                datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
                break;
            // UNIX TIMESTAMP WITH MS
            case 'X':
                config._d = new Date(parseFloat(input) * 1000);
                break;
            // TIMEZONE
            case 'Z' : // fall through to ZZ
            case 'ZZ' :
                config._useUTC = true;
                config._tzm = timezoneMinutesFromString(input);
                break;
            case 'w':
            case 'ww':
            case 'W':
            case 'WW':
            case 'd':
            case 'dd':
            case 'ddd':
            case 'dddd':
            case 'e':
            case 'E':
                token = token.substr(0, 1);
            /* falls through */
            case 'gg':
            case 'gggg':
            case 'GG':
            case 'GGGG':
            case 'GGGGG':
                token = token.substr(0, 2);
                if (input) {
                    config._w = config._w || {};
                    config._w[token] = input;
                }
                break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                var intVal = parseInt(val, 10);
                return val ?
                    (val.length < 3 ? (intVal > 68 ? 1900 + intVal : 2000 + intVal) : intVal) :
                    (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            }
            else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ?  parseWeekday(w.d, lang) :
                    (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
     Relative Time
     ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
     Week of Year
     ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
     Top Level Functions
     ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = cloneMoment(input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = lang;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
        "moment construction falls back to js Date. This is " +
        "discouraged and will be removed in upcoming major " +
        "release. Please refer to " +
        "https://github.com/moment/moment/issues/1407 for more info.",
        function (config) {
            config._d = new Date(config._i);
        });

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = lang;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
        // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
     Moment Prototype
     ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                    (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                    (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                        units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                            units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                                units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var sod = makeAs(moment(), this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                        diff < 0 ? 'lastDay' :
                            diff < 1 ? 'sameDay' :
                                diff < 2 ? 'nextDay' :
                                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
            this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
                case 'year':
                    this.month(0);
                /* falls through */
                case 'quarter':
                case 'month':
                    this.date(1);
                /* falls through */
                case 'week':
                case 'isoWeek':
                case 'day':
                    this.hours(0);
                /* falls through */
                case 'hour':
                    this.minutes(0);
                /* falls through */
                case 'minute':
                    this.seconds(0);
                /* falls through */
                case 'second':
                    this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        // keepTime = true means only change the timezone, without affecting
        // the local hour. So 5:31:26 +0300 --[zone(2, true)]--> 5:31:26 +0200
        // It is possible that 5:31:26 doesn't exist int zone +0200, so we
        // adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepTime) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    if (!keepTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                            moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this._lang._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.lang().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
            daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
     Duration Prototype
     ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
     Default Lang
     ************************************/


        // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                    (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                            (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
     Exposing Moment
     ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                "Accessing Moment through the global scope is " +
                "deprecated, and will be removed in an upcoming " +
                "release.",
                moment);
        } else {
            globalScope.moment = moment;
        }
    }

    /////////// Modified by Atlassian ///////////
    // CommonJS module is defined
    //if (hasModule) {
    //    module.exports = moment;
    //} else if (typeof define === "function" && define.amd) {
    //    define("moment", function (require, exports, module) {
    //        if (module.config && module.config() && module.config().noGlobal === true) {
    //            // release the global variable
    //            globalScope.moment = oldGlobalMoment;
    //        }
    //
    //        return moment;
    //    });
    //    makeGlobal(true);
    //} else {
    //    makeGlobal();
    //}
    // Bypassing in-library AMD
    makeGlobal();
    /////// End of Atlassian modification ///////

}).call(this);

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.lib.js' */
define('jira/moment/moment.lib', ['atlassian/libs/moment-2.6.0'], function(moment) {
    return moment;
});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.jira.formatter.js' */
define("jira/moment/moment.jira.formatter", ["underscore", "exports"], function(_, exports) {
    "use strict";
    var map = {
        d: "D",       // day
        y: "Y",       // year
        a: "A",       // meridiem
        E: "d",       // day name of week
        u: "d",       // day number of week
        Z: "ZZ",      // RFC 822 time zone
        z: "[GMT]ZZ", // replacing time zone name with offset
        XX: "ZZ",     // ISO 8601 time zone
        XXX: "Z"      // ISO 8601 time zone
    };

    function actuallyTranslate(tmpBuffer) {
        return map[tmpBuffer] || _.reduce(tmpBuffer, function (memo, value) {
            return memo + (map[value] || value);
        }, "");
    }

    function translateSimpleDateFormat(pattern) {
        var inQuote = false;
        var skip = false;
        var tmpBuffer = "";
        var reduction = _.reduce(pattern, function (memo, value, index, list) {
                if (skip) {
                    skip = false;
                }
                else if (value === '\'') {
                    if (tmpBuffer) {
                        memo += actuallyTranslate(tmpBuffer);
                        tmpBuffer = "";
                    }
                    if (list[index + 1] === '\'') {
                        memo += value;
                        skip = true;
                    }
                    else {
                        memo += !inQuote ? "[" : "]";
                        inQuote = !inQuote;
                    }
                }
                else if (inQuote) {
                    memo += value;
                }
                else if (!/[a-zA-Z]/.test(value)) {
                    if (tmpBuffer) {
                        memo += actuallyTranslate(tmpBuffer);
                        tmpBuffer = "";
                    }
                    memo += value;
                }
                else if (!tmpBuffer || tmpBuffer[tmpBuffer.length - 1] === value) {
                    tmpBuffer += value;
                }
                else {
                    memo += actuallyTranslate(tmpBuffer);
                    tmpBuffer = value;
                }
                return memo;
            }, "");
        if (tmpBuffer) {
            reduction += actuallyTranslate(tmpBuffer);
        }
        return reduction;
    }

    exports.translateSimpleDateFormat = translateSimpleDateFormat;
});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.jira.i18n.js' */
/* global WRM */
define("jira/moment/moment.jira.i18n", [
    "jira/moment/moment.lib",
    "jira/moment/moment.jira.formatter",
    "jira/util/data/meta"
], function (moment, formatter, Meta) {

    "use strict";

    var timeUnits = WRM.data.claim("jira.webresources:dateFormatProvider.dateFormat");

    moment.lang("jira", {
        months: timeUnits.months,
        monthsShort: timeUnits.monthsShort,
        weekdays: timeUnits.weekdays,
        weekdaysShort: timeUnits.weekdaysShort,
        weekdaysMin: timeUnits.weekdaysShort,
        longDateFormat: {
            LT: formatter.translateSimpleDateFormat(Meta.get("date-time")),
            L: formatter.translateSimpleDateFormat(Meta.get("date-day")),
            LL: formatter.translateSimpleDateFormat(Meta.get("date-dmy")),
            LLL: formatter.translateSimpleDateFormat(Meta.get("date-complete"))
        },
        meridiem: function (hours) {
            return timeUnits.meridiem[+(hours > 11)];
        },

        calendar: {
            sameDay:  "LLL",
            nextDay:  "LLL",
            nextWeek: "LLL",
            lastDay:  "LLL",
            lastWeek: "LLL",
            sameElse: "LLL"
        },

        // TODO Deprecate?
        relativeTime: {
            future: AJS.format("in {0}", "%s"),
            past: AJS.format("{0} ago", "%s"),
            s: "a few seconds",
            m: "a minute",
            mm: AJS.format("{0} minutes", "%d"),
            h: "an hour",
            hh: AJS.format("{0} hours", "%d"),
            d: "a day",
            dd: AJS.format("{0} days", "%d"),
            M: "a month",
            MM: AJS.format("{0} months", "%d"),
            y: "a year",
            yy: AJS.format("{0} years", "%d")
        }
    });

});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.js' */
/**
 * @fileOverview
 * Pulls in the core Moment.js library, defines JIRA's i18n mappings,
 * then returns a moment instance that always uses the correct i18n setting.
 * See {@link http://momentjs.com/docs/#/i18n/instance-locale/} for details
 * on Moment.js' (changes in its) support for i18n.
 */

/**
 * @module jira/moment
 */
define('jira/moment', ['jira/moment/moment.lib', 'jira/moment/moment.jira.i18n'], function(moment, i18n) {
    return moment;
});
;
;
/* module-key = 'jira.webresources:momentjs', location = '/static/lib/moment/moment.legacy.js' */
(function() {
    AJS.namespace('JIRA.translateSimpleDateFormat', null, require('jira/moment/moment.jira.formatter').translateSimpleDateFormat);
    AJS.namespace('window.moment', null, require('jira/moment'));
}());
;
;
/* module-key = 'com.atlassian.jira.gadgets:date-range', location = 'static/components/dates/DateRange.js' */
/**
 * @name DateRange
 * @global
 *
 * Helper functions used for dealing with date ranges.
 */
define('jira-dashboard-items/components/dates/daterange', [
    'jira/moment'
], function(
    moment
) {

    return {
        /**
         * Given two dates generate a human readable format.
         * @param {number} startDate
         * @param {number} endDate
         * @returns {string}
         */
        rangeToText: function(startDate, endDate) {
            //Default day if same date
            if (startDate === endDate) {
                return moment(startDate).format("Do MMM YYYY");
            }

            startDate = moment(startDate);
            endDate = moment(endDate);

            var differentYear = startDate.year() !== endDate.year();
            if (differentYear) {
                var startString = startDate.format("Do MMM YYYY");
                var endString = endDate.format("Do MMM YYYY");
                return AJS.format("Between {0} and {1}", startString, endString);
            }

            var differentMonth = startDate.month() !== endDate.month();
            if (differentMonth) {
                startString = startDate.format("Do MMM");
                endString = endDate.format("Do MMM YYYY");
                return AJS.format("Between {0} and {1}", startString, endString);
            }

            var differentDay = startDate.dayOfYear() !== endDate.dayOfYear();
            if (differentDay) {
                startString = startDate.format("Do");
                endString = endDate.format("Do MMM YYYY");
                return AJS.format("Between {0} and {1}", startString, endString);
            }

            //Doesn't care about seconds for simplicity.
            var fullDay = ((startDate.get('hour') === 0 && startDate.get('minute') === 0) &&
                           (endDate.get('hour') === 23 && endDate.get('minute') === 59));

            if (fullDay) {
                return moment(startDate).format("Do MMM YYYY");
            }

            startString = moment(startDate).format("HH:mm");
            endString = moment(endDate).format("HH:mm Do MMM YYYY");
            return AJS.format("Between {0} and {1}", startString, endString);

        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:binary-search', location = 'static/components/search/BinarySearch.js' */
/**
 * @name BinarySearch
 * @global
 *
 * Implements Binary search functionality.
 */
define("jira-dashboard-items/components/search/binary-search", [
    'underscore'
], function(
    _
) {

    /**
     * @function
     * @name ComparatorFunction
     * @global
     *
     * @param goal the value you are trying to find
     * @param other the value you are comparing to
     * @returns {Number} < 0 if goal is before other, 0 if equal, > 0 if goal after other
     */
    function defaultComparator(goal, other) {
        return goal - other;
    }

    /**
     * Create a comparator function if non specified
     * @param {*} comparator
     * @returns {ComparatorFunction}
     */
    function generateComparator(comparator) {
        if (!comparator || !_.isFunction(comparator)) {
            return defaultComparator;
        }
        return comparator;
    }


    return {

        /**
         * @param {Array} array to search in
         * @param {*} object that is being searched for
         * @param {ComparatorFunction} comparator is the function that will test whether the object is greater than, equal or less than
         *        a given other object.
         * @returns {Number}
         */
        search: function(array, object, comparator) {
            comparator = generateComparator(comparator);

            var low = 0;
            var high = array.length;
            while (low < high) {
                var middle = (high + low) >> 1;

                var comparison = comparator(object, array[middle]);
                if (comparison === 0) {
                    return middle;
                } else if (comparison < 0) {
                    high = middle;
                } else {
                    low = middle + 1;
                }
            }

            return -1;
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:markers', location = 'static/components/charts/components/Markers.js' */
/**
 * Creates a set of lines that go down the graph vertically at different points.
 *
 * @module Markers
 */
define('jira-dashboard-items/components/charts/components/markers', [
    'jira-dashboard-items/lib/c3'
], function(c3) {

    return function () {
        return c3.component("marker")
            .extend(c3.drawable())
            .extend(c3.plottable())
            .elementTag('line')
            .elementClass('marker-line')

            .extend({
                y1: c3.prop(0),

                y2: function() {
                    var self = this;
                    return function() {
                        return self.height();
                    };
                }
            })
            .update(function(event) {
                event.selection
                    .attr('x1', this.x())
                    .attr('x2', this.x())
                    .attr('y1', this.y1())
                    .attr('y2', this.y2());
            })
            .extend(function() {
                this.selection().style('pointer-events', 'none');
            });
    };

});
;
;
/* module-key = 'com.atlassian.jira.gadgets:marker-following-mouse', location = 'static/components/charts/components/MarkerFollowingMouse.js' */
/**
 * @module MarkerFollowingMouse
 */
define('jira-dashboard-items/components/charts/components/marker-following-mouse', [
    'underscore',
    'jira-dashboard-items/components/charts/components/interactive',
    'jira-dashboard-items/components/charts/components/markers',
    'jira-dashboard-items/lib/c3'
], function(
    _,
    Interactive,
    Markers,
    c3
) {

    /**
     * @typedef {Object} MarkerFollowingMouseOptions
     *
     * @property {Number} yTopOffset if we want to extend the marker further to the top (negative means further up)
     * @property {Function} [canShow] whether it is possible to show the marker
     * @property {Node} domContext the mouse events will be bound to.
     * @property {c3.component} region that the mouse enter events, etc want to actually be called on.
     *
     */

    /**
     * @param {MarkerFollowingMouseOptions} options
     *
     * Creates a component which generates a vertical line on the graph and which chases the mouse.
     * It also displays a dialog next to the line.
     */
    return function(options) {


        //Only a single marker
        var data = [[0]];

        var markers =  Markers().data(data).xAccessor(function() { return 0;});

        markers.extend(function() {
            this.selection().classed('following-marker', true);
        });

        //Create events that can be bound to.
        markers.extend({
            showCallback: c3.event(),
            refreshCallback: c3.event(),
            hideCallback: c3.event(),
            show: function() {
                if (canShow()) {
                    isVisible = true;
                    markers.elements()
                        .style('visibility', '');

                    markers.showCallback();
                }
            },

            refresh: function() {
                var mouse = region.mouseCoordinates();

                markers.elements()
                    .attr('x1', mouse[0])
                    .attr('x2', mouse[0])
                    .attr('y1', options.yTopOffset || 0);

                if (!canShow() && isVisible) {
                    this.hide();
                }
                else if (!isVisible && canShow()) {
                   this.show();
                }

                markers.refreshCallback(markers.parent().xScale().invert(mouse[0]));
            },

            hide: function() {
                isVisible = false;
                markers.elements()
                    .style('visibility', 'hidden');

                markers.hideCallback();
            }
        });


        //Listen to the regions mouse events to call marker functions.
        var domContext = options.domContext;
        var region = options.region;

        var interactive = Interactive().domContext(domContext).region(region);

        region.extend(interactive);

        region.mouseenter(function() {
           markers.show();
        });

        region.mousemove(function() {
            markers.refresh();
        });

        region.mouseout(function() {
            markers.hide();
        });

        var canShow = options.canShow || _.constant(true);
        var isVisible = false;

        return markers;
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:marker-following-mouse-with-dialog', location = 'static/components/charts/components/MarkerFollowingMouseWithDialog.js' */
/**
 * @module MarkerFollowingMouseWithDialog
 */
define('jira-dashboard-items/components/charts/components/marker-following-mouse-with-dialog', [
    'jquery',
    'underscore',
    'jira-dashboard-items/components/charts/components/marker-following-mouse'
], function(
    $,
    _,
    MarkerFollowingMouse
) {

    /**
     * @typedef {Object} MarkerFollowingMouseWithDialogOptions
     *
     * @property {Number} yTopOffset if we want to extend the marker further to the top (negative means further up)
     * @param {Function} generateContent give the data and x coordinate create content for the dialog
     * @param {String} domContextSelector used to select the dom using jQuery.
     * @param {c3.component} region used to bind mouse events to.
     */

    /**
     * @constructor
     *
     * @param {MarkerFollowingMouseWithDialogOptions} options
     */
    return function (options) {
        var generateContent = options.generateContent;

        var dialog;
        function createDialog(trigger, content) {
            dialog = AJS.InlineDialog($(trigger), 'marker-following-mouse', function(element, trigger, showPopup) {
                element.parent().addClass('marker-following-mouse-dialog');
                element.html(content);
                showPopup();
                return false;
            }, {
                fadeTime: 0,
                cacheContent: false, // don't cache the dialog content
                hideDelay: 60000, // set longer timeout (default is 10 seconds)
                gravity: 's',
                persistent: true,
                offsetX: -20
            });
        }

        options.domContext = $(options.domContextSelector);

        var markers = MarkerFollowingMouse(options);

        markers.showCallback(function() {
            createDialog(markers.elements()[0], "");

            dialog.show();
        });

        markers.refreshCallback(function(xCoordinate) {
            var content = generateContent(xCoordinate);

            if (content) {
                if (!dialog) {
                    createDialog(markers.elements()[0], content);
                } else {
                    dialog.find(".contents").first().html(content);
                    dialog.refresh();
                }
            } else {
                markers.hide();
            }
        });

        markers.hideCallback(function() {
            if (dialog) {
                dialog.hide();
                dialog.remove();
                dialog = null;
            }
        });

        return markers;
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:labels', location = 'static/components/charts/components/Labels.js' */
/**
 * Creates labels at a point on the chart.
 *
 * @module Labels
 */
define('jira-dashboard-items/components/charts/components/labels', [
    'jquery',
    'underscore',
    'jira-dashboard-items/lib/c3'
], function(
    $,
    _,
    c3
) {

    function horizontallyCenter(x, width) {
        return x - (width / 2);
    }

    /**
     * @returns {Labels}
     */
    var Labels = function () {
        return c3.component("labels")
            .extend(c3.drawable())
            .extend(c3.plottable())
            .elementTag('text')
            .elementClass('label')
            .extend({
                textGenerator:  c3.prop(function(d) {
                    return String(d);
                }),
                mouseenter: c3.event(),
                mouseleave: c3.event(),
                centerXValue: function(x, width) {
                    x = horizontallyCenter(x, width);

                    var boundaryRight = this.xRange()[1];

                    var maximumX = Math.max(0, boundaryRight - width);

                    return Math.max(0, Math.min(x, maximumX));
                },
                sortLabelsByXValue: function() {
                    // As the labels may have different x positions due to centering the text, sort them so they
                    // are in order.
                    $(this.elements()[0]).sort(function(a, b) {
                        var aXCoordinate = parseFloat($(a).attr('x'));
                        var bXCoordinate = parseFloat($(b).attr('x'));
                        return aXCoordinate > bXCoordinate;
                    }).appendTo(this.selection());
                }

            }).update(function(event) {
                var self = this;
                event.selection
                    .text(this.textGenerator())
                    .attr('data-index', function(d, i) {
                        return i;
                    })
                    .attr('x', function(d) {
                        var x = self.x()(d);
                        var width = this.getBBox().width;

                        return self.centerXValue(x, width);
                    })
                    .attr('y', this.y());
            }).extend(self.sortLabelsByXValue);
    };

    Labels.INDEX_ATTR = 'data-index';

    return Labels;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:grouped-labels', location = 'static/components/charts/components/GroupedLabels.js' */
/**
 * Generates labels and any that overlap horizontally are grouped into a single label, with the id's of the labels
 * grouped for future use.
 *
 * @module GroupedLabels
 */
define('jira-dashboard-items/components/charts/components/grouped-labels', [
    'underscore',
    'jira-dashboard-items/components/charts/components/labels',
    'jira-dashboard-items/lib/d3'
], function(
    _,
    Labels,
    d3
) {

    /**
     * @typedef {Object} GroupedLabelOptions
     * @property {Function} [groupTextGenerator] given the number of grouped elements generate a label.
     */

    /**
     * @param {GroupedLabelOptions} [options] for the labels
     * @returns {c3.component}
     * @constructor
     */
    var GroupedLabels = function (options) {

        options = options || {};
        options.groupTextGenerator = options.groupTextGenerator || _.identity;

        return Labels()
            .extend({
                getGroupedIndexes: function(label) {
                    return label.attr(Labels.INDEX_ATTR).split(',');
                },

                getMiddleXCoordinate: function(label) {
                    var indexes = this.getGroupedIndexes(label);

                    var first = 0;
                    var last = indexes.length - 1;

                    var xValue = this.x();
                    var data = this.data();

                    var min = xValue(data[indexes[first]]);
                    var max = xValue(data[indexes[last]]);

                    return (max + min) / 2;
                }
            })

            //Hide overlapping ticks, keeps merging labels while there is still merges occuring.  Cannot just do
            //a single iteration over the labels as we are centering the group label when we merge to keep it in
            //the center of the group which could result in it moving left or right. Therefore, it could move left
            //into another group and so we need to go over and make sure that those groups get merged again.
            .extend(function() {
                var self = this;
                var labelMerged = true;
                while (labelMerged) {
                    labelMerged = false;

                    var labels = this.selection().selectAll(".label");

                    var currentLabelIndex = 0;
                    while (currentLabelIndex < labels.size()) {
                        var label = d3.select(labels[0][currentLabelIndex]);

                        //For each label after it in the DOM.
                        var otherLabelIndex = currentLabelIndex + 1;
                        while (otherLabelIndex < labels.size()) {

                            var otherLabel = d3.select(labels[0][otherLabelIndex]);

                            var overlap = parseFloat(label.attr('x')) + label.node().getBBox().width > parseFloat(otherLabel.attr('x'));

                            if (overlap) {
                                var unionIndexes = _.union(self.getGroupedIndexes(label), self.getGroupedIndexes(otherLabel));

                                labelMerged = true;

                                label.attr(Labels.INDEX_ATTR, unionIndexes.join(','));

                                var middleXCoordinate = self.getMiddleXCoordinate(label);

                                label.text(options.groupTextGenerator(unionIndexes.length));
                                var width = label.node().getBBox().width;

                                label.attr('x', self.centerXValue(middleXCoordinate, width));
                                otherLabel.remove();
                            } else {
                                break;
                            }
                            ++otherLabelIndex;
                        }
                        currentLabelIndex = otherLabelIndex;
                    }
                }
            });
    };

    GroupedLabels.GROUPING_DATA_ATTR = Labels.INDEX_ATTR;

    return GroupedLabels;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:chart-interactions', location = 'static/components/charts/components/interactive.js' */
/**
 * Note: Taken and slightly modified from JIRA Agile control chart code.
 * A component mixin that allows a g svg element to be interacted with by the mouse.
 *
 * @module Interactive
 */
define('jira-dashboard-items/components/charts/components/interactive', [
    'jquery',
    'jira-dashboard-items/lib/c3',
    'underscore'
], function(
    $,
    c3,
    _
) {
    return function() {

        var component = c3.component();

        var cachedOffset;

        /**
         * Update the cached offset at most once every 200ms.
         */
        var updateCachedOffset = _.throttle(function() {
            cachedOffset = $(component.region().selection().node()).offset();
        }, 200);

        /**
         * Test whether or not a mouse event occurred within the bounds
         *
         * @param e
         * @returns {boolean}
         */
        function isWithinBounds(e) {
            var coordinates = getRelativeMouseCoordinates(e);
            var x = coordinates[0];
            var y = coordinates[1];

            component.mouseCoordinates([x, y]);

            return (x > 0 && y > 0) &&
                        (x <= component.region().selection().node().getBBox().width &&
                         y <= component.region().selection().node().getBBox().height);
        }

        /**
         * Calculate the coordinates at which a mouse event occured, relative to the component's selection.
         *
         * @param {jQuery.event} e the mouse event
         * @returns {[number, number]}
         */
        function getRelativeMouseCoordinates(e) {

            updateCachedOffset();

            var x = (e.pageX - cachedOffset.left);
            var y = (e.pageY - cachedOffset.top);

            return [x, y];
        }

        /**
         * Initialise the component:
         *
         *  - Binds to the mousemove event of the domContext to determine when the mouseout/mouseover events occur
         *  - Prevent native behaviour of dragstart event to fix Firefox glitches
         */
        function initialise() {
            var inDom = false;
            component.domContext()
                .on('mousemove', function(e) {
                    var isMouseWithinBounds = isWithinBounds(e);
                    if (isMouseWithinBounds) {
                        if (!inDom) {
                            component.mouseenter(e);
                            inDom = true;
                        }
                        component.mousemove(e);
                    } else {
                        if (inDom) {
                            component.mouseout(e);
                            inDom = false;
                        }
                    }
                })
                .on('mouseleave', function(e) {
                    component.mouseout(e);
                });
        }

        return component
            .extend(c3.withDimensions())
            .extend(_.once(initialise))
            .extend({
                mouseCoordinates: c3.prop(),
                domContext: c3.prop(),
                region: c3.prop(),
                mousedown: c3.event(),
                mouseup: c3.event(),
                mousemove: c3.event(),
                mouseover: c3.event(),
                mouseout: c3.event(),
                mouseenter: c3.event(),
                mouseleave: c3.event()
            });
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:number-factor-generator', location = 'static/components/factors/NumberFactorGenerator.js' */
/**
* @name NumberFactorGenerator
*
* Implements functionality to find the factors of a given number, e.g. 8 would result in [1,2,4,8]
*/
define('jira-dashboard-items/components/factors/number-factor-generator', function() {

    return {
        /**
         * Generates all the factors of a given positive number into a sorted array.
         * @param {Number} n, larger than 1, to find the factors of
         * @return {Number[]}
         *
         */
        generate: function(n) {
            if (n < 1) {
                throw new Error('JIRA.NumberFactorGenerator.generate: number must be >= 1');
            }

            if (n === 1) {
                return [1];
            }

            var factors = [1];

            for (var i = 2; i <= n / 2; ++i) {
                if (n % i === 0) {
                    factors.push(i);
                }
            }

            factors.push(n);

            return factors;
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:overlap-remover', location = 'static/components/overlap-remover/OverlapRemover.js' */
/**
 * @name OverlapRemover
 *
 */
define('jira-dashboard-items/components/overlap-remover/overlap-remover', [
    'underscore',
    'jira-dashboard-items/components/factors/number-factor-generator'
], function(
    _,
    numberFactorGenerator
) {

    return {
        /**
         * Given a list of sorted elements from left to right we want to reduce the minimum number of elements to
         * remove overlaps, whilst maintaining the same distance between elements.
         * @param {*[]} elements to be tested for overlaps
         * @param {Function} isOverlapping is given two elements and returns true if they overlap
         * @return {*[]} elements remaining
         */
        reduce: function(elements, isOverlapping) {
            if (_.isUndefined(isOverlapping)) {
                throw new Error("No comparison function provided");
            }
            //Wants the gaps between labels to be even and so finds the factors to do this.
            var factors = numberFactorGenerator.generate(elements.length - 1);

            var nonOverlappingJump = _.find(factors, function(jump) {
                var indices = _.range(0, elements.length, jump);
                var nonOverlap =  _.all(_.rest(indices), function(i) {
                    return !isOverlapping(elements[i - jump], elements[i]);
                });
                return nonOverlap;
            });

            //If even the first and last elements overlap, just show those two anyway.
            if (_.isUndefined(nonOverlappingJump)) {
                nonOverlappingJump = _.last(factors);
            }

            console.log("JUMP: " + nonOverlappingJump);
            var nonOverlappingIndices =_.range(0, elements.length, nonOverlappingJump);
            return _.filter(elements, function(element, index) {
                return _.contains(nonOverlappingIndices, index);
            });
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:non-overlapping-horizontal-axis', location = 'static/components/charts/components/NonOverlappingHorizontalAxis.js' */
/**
 * @name NonOverlappingHorizontalAxis
 *
 * Represents a X axis which removes axis labels that overlap with each other.
 * NOTE: The first and last labels must be shown.
 */
define('jira-dashboard-items/components/charts/components/non-overlapping-horizontal-axis', [
    'jquery',
    'jira-dashboard-items/components/overlap-remover/overlap-remover',
    'jira-dashboard-items/lib/c3',
    'underscore'
], function(
    $,
    overlapRemover,
    c3,
    _
) {

    return function() {

        //minimum gap between the labels to make sure they aren't too close together
        var MIN_LABEL_GAP = 5;

        return c3.labelledAxis()

            .extend(function() {
                var ticks =  this.selection().selectAll(".tick")[0];

                var reducedTicks = overlapRemover.reduce(ticks, function(a, b) {
                    var $a = $(a);
                    var $b = $(b);
                    return $a.position().left + $a[0].getBBox().width + MIN_LABEL_GAP > $b.position().left;
                });

                _.each(_.difference(ticks, reducedTicks), function(tick) {
                    $(tick).remove();
                });
            });
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:chart', location = 'static/components/charts/components/Chart.js' */
/**
 * Applies axis and grid lines to a graph to generate a chart.
 * @module Chart
 */
define('jira-dashboard-items/components/charts/components/chart', [
    'jira-dashboard-items/components/charts/components/non-overlapping-horizontal-axis',
    'jira-dashboard-items/lib/d3',
    'jira-dashboard-items/lib/c3'
], function(
    NonOverlappingHorizontalAxis,
    d3,
    c3
) {

    /**
     * @typedef {Object} ChartOptions
     *
     * @property {Function} [xAxisValue] give an x value convert it to a readable format
     * @property {Function} [yAxisValue] give an y value convert it to a readable format
     **/


    /**
     * @param {c3.component} graph to generate axis for.
     * @param {ChartOptions} [options] for the charting.
     */
    return function(graph, options) {
        options = options || {};

        var chart = c3.borderLayout();

        var content = c3.layerable()
            .extend(function() {
                this.selection().classed('graph', true);
            })
            .addLayer('grid', c3.gridLines().orient('left'))
            .addLayer('graph', graph);

        chart.center(content);

        if (options.yAxisValue) {
            var yAxis = c3.labelledAxis()
                .axisConstructor(function () {
                    return d3.svg.axis()
                        .ticks(5)
                        .tickFormat(function (d) {
                            return options.yAxisValue(d);
                        });
                }).extend(function() {
                    this.selection().classed('yAxis', true);
                }).extend({
                    //Override yDomain so that it always has a range of 1.
                    yDomain: function() {
                        var yDomain = this.parent().yDomain();

                        if (yDomain[0] === yDomain[1]) {
                            return [yDomain[0], yDomain[0] + 1];
                        } else {
                            return yDomain;
                        }
                    }
                })
                .width(60)
                .orient('left');

            chart.west(yAxis);
        } else {
            chart.west(c3.withDimensions().width(10));
        }

        if (options.xAxisValue) {
            var xAxis = NonOverlappingHorizontalAxis()
                .axisConstructor(function () {
                    return d3.svg.axis()
                        .tickFormat(function (d) {
                            return options.xAxisValue(d);
                        });
                })
                .extend(function() {
                    this.selection().classed('xAxis', true);
                })
                .height(30)
                .orient('bottom');

            chart.south(xAxis);
        } else {
            chart.south(c3.withDimensions().height(10));
        }

        chart
            .north(c3.withDimensions().height(10))
            .east(c3.withDimensions().width(10));


        return chart;
    };
});
;
;
/* module-key = 'jira.webresources:jquery-livestamp', location = '/includes/jquery/plugins/livestamp/time.js' */
/**
 * @note Mostly copied from Stash by skalsi on 10/01/14.
 * @module jira/jquery/plugins/livestamp/time
 */
define('jira/jquery/plugins/livestamp/time', [
    'jquery',
    'jira/moment',
    'jira/util/data/meta'
], function ($, moment, Meta) {

    'use strict';

    /** @exports jira/jquery/plugins/livestamp/time */
    var Time = {};

    function Type(str, isAge) {
        this.key = str;
        this.isAge = isAge;
    }

    var relativize = Meta.getBoolean("date-relativize");

    Type.types = {};

    for (var a = ['shortAge', 'longAge', 'fullAge', 'short', 'long', 'full', 'timestamp'], i = 0, l = a.length, t; i < l; i++) {
        t = a[i];
        Type.types[t] = new Type(t, t.toLowerCase().indexOf('age') !== -1);
    }

    var momentTranslations = {};
    Time.FormatType = Type;

    function getTextForRelativeAge(age, type, param) {
        // NOTE: AJS cannot be an AMD dependency as the minifier then changes the AJS.I18n.getText references
        // NOTE: and the transformer doesn't do any translation. IMO this is a webresources _bug_ (https://ecosystem.atlassian.net/browse/PLUGWEB-17).
        if (age in momentTranslations) {
            return AJS.format(momentTranslations[age], param);
        } else {
            return null;
        }
    }

    // TODO These should match http://developer-fe.stg.internal.atlassian.com/design/1.3/foundations/dates/
    // by default.
    function getFormatString(type) {
        switch (type.key) {
            case 'short':
            case 'shortAge':
                return 'll';
            case 'long':
            case 'longAge':
                return 'LL';
            case 'full':
            case 'fullAge':
                return 'LLL';
            case 'timestamp':
                return "LLL";
            default:
                return null;
        }
    }

    function beginningOfDay(time)
    {
        return time.clone().hours(0).minutes(0).seconds(0).milliseconds(0);
    }

    function isYesterday(now, date) {
        var end = beginningOfDay(now);
        var start = end.clone().subtract('d', 1);
        return start <= date && date < end;
    }

    function isTomorrow(now, date) {
        var start = beginningOfDay(now).add('d', 1);
        var end = start.clone().add('d', 1);
        return start <= date && date < end;
    }

    function getMinutesBetween(start, end) {
        return Math.floor(end.diff(start, 'minutes', true));
    }

    function getHoursBetween(start, end) {
        var hourDiff = end.diff(start, 'hours', true);  // Moment's diff does a floor rather than a round so we pass 'true' for a float value
        return Math.round(hourDiff);                    // Then round it ourself
    }

    function getDaysBetween(start, end) {
        return Math.floor(end.diff(start, 'days', true));
    }

    function formatDateWithFormatString(date, type) {
        var formatString = getFormatString(type);
        return date.format(formatString);
    }

    function formatDateWithRelativeAge(date, type, now) {
        now = now || moment();

        if (date <= now) {
            if (date > now.clone().subtract('m', 1)) {
                return getTextForRelativeAge('aMomentAgo', type);
            } else if (date > now.clone().subtract('m', 2)) {
                return getTextForRelativeAge('oneMinuteAgo', type);
            } else if (date > now.clone().subtract('m', 50)) {
                return getTextForRelativeAge('xMinutesAgo', type, getMinutesBetween(date, now));
            } else if (date > now.clone().subtract('m', 90)) {
                return getTextForRelativeAge('oneHourAgo', type);
            } else if (isYesterday(now, date) && date < now.clone().subtract('h', 5)) {
                return getTextForRelativeAge('oneDayAgo', type);
            } else if (date > now.clone().subtract('d', 1)) {
                return getTextForRelativeAge('xHoursAgo', type, getHoursBetween(date, now));
            } else if (date > now.clone().subtract('d', 7)) {
                return getTextForRelativeAge('xDaysAgo', type, Math.max(getDaysBetween(date, now), 2));// if it's not yesterday then don't say it's one day ago
            } else if (date > now.clone().subtract('d', 8)) {
                return getTextForRelativeAge('oneWeekAgo', type);
            }
        } else {
            if (date < now.clone().add('m', 1)) {
                return getTextForRelativeAge('inAMoment', type);
            } else if (date < now.clone().add('m', 2)) {
                return getTextForRelativeAge('inOneMinute', type);
            } else if (date < now.clone().add('m', 50)) {
                return getTextForRelativeAge('inXMinutes', type, getMinutesBetween(now, date));
            } else if (date < now.clone().add('m', 90)) {
                return getTextForRelativeAge('inOneHour', type);
            } else if (isTomorrow(now, date) && date > now.clone().add('h', 5)) {
                return getTextForRelativeAge('inOneDay', type);
            } else if (date < now.clone().add('d', 1)) {
                return getTextForRelativeAge('inXHours', type, getHoursBetween(now, date));
            } else if (date < now.clone().add('d', 7)) {
                return getTextForRelativeAge('inXDays', type, Math.max(getDaysBetween(now, date), 2));// if it's not yesterday then don't say it's one day ago
            } else if (date < now.clone().add('d', 8)) {
                return getTextForRelativeAge('inOneWeek', type);
            }
        }
        return formatDateWithFormatString(date, type);
    }

    Time.formatDate = function formatDate(momentDate, type, forceRelativize) {
        if (momentDate && type) {
            if ((relativize || forceRelativize) && type.isAge) {
                return formatDateWithRelativeAge(momentDate, type);
            } else {
                return formatDateWithFormatString(momentDate, type);
            }
        } else {
            return null;
        }
    };

    Time.setRelativeTranslations = function(values) {
        for (var k in values) {
            momentTranslations[k] = values[k];
        }
    };

    Time.restoreDefaultRelativeTranslations = function() {
        this.setRelativeTranslations({
            'inAMoment': "Now",
            'inOneMinute': "In 1 minute",
            'inXMinutes': "In {0} minutes",
            'inOneHour': "In 1 hour",
            'inXHours': "In {0} hours",
            'inOneDay': "Tomorrow",
            'inXDays': "In {0} days",
            'inOneWeek': "In 1 week",
            'aMomentAgo': "Just now",
            'oneMinuteAgo': "1 minute ago",
            'xMinutesAgo': "{0} minutes ago",
            'oneHourAgo': "1 hour ago",
            'xHoursAgo': "{0} hours ago",
            'oneDayAgo': "Yesterday",
            'xDaysAgo': "{0} days ago",
            'oneWeekAgo': "1 week ago"
        });
    };
    Time.restoreDefaultRelativeTranslations();

    Time.formatDateWithRelativeAge = formatDateWithRelativeAge;
    Time.formatDateWithFormatString = formatDateWithFormatString;

    return Time;
});

AJS.namespace('JIRA.Time', null, require('jira/jquery/plugins/livestamp/time'));
;
;
/* module-key = 'jira.webresources:jquery-livestamp', location = '/includes/jquery/plugins/livestamp/livestamp.js' */
define('jira/jquery/plugins/livestamp/livestamp', [
    'jquery',
    'jira/moment',
    'jira/util/data/meta',
    'jira/jquery/plugins/livestamp/time'
], function ($, moment, Meta, Time) {

    "use strict";

    var timeout,

        updateInterval = 6000,

        relativize = Meta.getBoolean("date-relativize"),

        livestamps = [],

        prep = function ($el, timestamp) {
            $el.data("livestampdata", timestamp);
            livestamps.push($el);
        },

        run = function () {
            clearTimeout(timeout);
            update();
            timeout = setTimeout(run, updateInterval);
        },

        update = function () {
            livestamps = $.grep(livestamps, function ($el) {
                var timestamp = $el.data("livestampdata"),
                    forceRelativize = $el.data('relativize'),
                    from,
                    to;
                if (!moment.isMoment(timestamp) || !$el.closest("html").length) {
                    $el.removeData("livestampdata");
                } else {
                    from = $el.text();
                    var tsFormat = $el.data("datetime-format");

                    tsFormat = tsFormat ? tsFormat : "fullAge"; // TODO We should transition to longAge.
                    if (!(relativize || forceRelativize)) {
                        // We should try not to have any tsFormats like 'AgeAge'
                        tsFormat = tsFormat.replace("Age", "");
                    }

                    to = Time.formatDate(timestamp, Time.FormatType.types[tsFormat], forceRelativize);

                    if (from !== to) {
                        $el.text(to);
                    }
                }
                return !!$el.data("livestampdata");
            });
        },

        add = function ($el) {
            $el.each(function () {
                var $this = $(this),
                    timestamp = $this.attr("datetime");
                if (timestamp) {
                    //reset the timezone to what's specified by the timestamp
                    var timestampMoment = isNaN(timestamp) ?
                        // assuming iso8601 timestamp, let moment#zone() handle it
                        moment(timestamp).zone(timestamp) :
                        // unix epoch timestamp (in milli-seconds)
                        moment(parseInt(timestamp, 10));
                    prep($this, timestampMoment);
                }
            });
            run();
            return $el;
        };

    $.fn.livestamp = function () {
        return add(this);
    };

    return add;
});

// Make extension available in global scope immediately / synchronously.
// TODO INC-71 - remove synchronous require
(function() {
    require('jira/jquery/plugins/livestamp/livestamp');
})();
;
;
/* module-key = 'com.atlassian.jira.gadgets:createdvsresolved-chart', location = 'static/components/charts/createdvsresolved/CreatedVsResolvedChart.js' */
/**
 * @module CreatedVsResolvedChart
 */
define('jira-dashboard-items/components/charts/createdvsresolved-chart', [
    'jquery',
    'backbone',
    'jira/moment',
    'jira-dashboard-items/lib/d3',
    'jira-dashboard-items/lib/c3',
    'jira-dashboard-items/components/charts/components/linecomparison-graph',
    'jira-dashboard-items/components/charts/components/chart',
    'jira-dashboard-items/components/charts/components/interactive',
    'jira-dashboard-items/components/charts/components/dualplottable',
    'jira-dashboard-items/components/dates/daterange',
    'jira-dashboard-items/components/search/binary-search',
    'jira-dashboard-items/components/charts/components/marker-following-mouse-with-dialog',
    'jira-dashboard-items/components/charts/components/markers',
    'jira-dashboard-items/components/charts/components/grouped-labels',
    'underscore'
], function(
    $,
    Backbone,
    moment,
    d3,
    c3,
    LineComparisonGraph,
    Chart,
    Interactive,
    DualPlottable,
    DateRange,
    BinarySearch,
    MarkerFollowingMouseWithDialog,
    Markers,
    GroupedLabels,
    _
) {
    /**
     * @typedef {Object} CreatedVsResolvedData
     * @property {Object[]} created data points
     * @property {Object[]} resolved data points
     * @property {Object[]} domain of the graph
     */

    /**
     * @typedef {Object} CreatedVsResolvedsOptions
     * @property {Number} id unique for this chart
     * @property {Object} [axisOptions]
     * @property {CreatedVsResolvedData} data for the chart
     * @property {Object[]} versionData of any versions for the filter
     * @property {Number} chartHeight of the chart
     */


    var CHART_RIGHT_PADDING = 50;
    var VERSION_TOP_SPACING = 25; //Represents height where the version label will be above the chart.
    var VERSION_HEIGHT = 10; //An estimate for the space needed to render the version label
    var VERSION_LINE_SPACING = 3; //Space below the version text to the line
    var VERSION_GROUP_NUB_HEIGHT = 10; //Height of the nub above the horizontal line joining labels

    //Calculates how high the markers should go above the chart
    var VERSION_MARKER_TOP = VERSION_TOP_SPACING - VERSION_GROUP_NUB_HEIGHT - VERSION_LINE_SPACING;

    var VERSIONS_INLINE_DIALOG_VERT_TOP_OFFSET = -(VERSION_TOP_SPACING + VERSION_HEIGHT);
    var NO_VERSIONS_INLINE_DIALOG_VERT_TOP_OFFSET = -10;

    var CreatedVsResolvedChart = Backbone.View.extend({
        CLASS_NAME: "CreatedVsResolvedChart",

        /**
         * @name LineType
         * @enum {String}
         *
         * The line type of the chart
         */
        LINE_TYPE: {
            CREATED: "created",
            RESOLVED: "resolved"
        },

        INLINE_DIALOG_CLASS: "created-vs-resolved-inline-dialog",

        Templates: JIRA.DashboardItem.CreatedVsResolvedChart.Templates,

        /**
         * @param {CreatedVsResolvedsOptions} options
         */
        initialize: function(options) {
            options = options || {};

            this.parseOptions(options);
        },

        /**
         * Makes sure the options passed into the view are correct.
         * @param {CreatedVsResolvedsOptions} options
         */
        parseOptions: function(options) {
            options = options || {};


            if (!options.id) {
                throw new Error(this.CLASS_NAME + ": Should have supplied an ID");
            }

            if (!options.data) {
                throw new Error(this.CLASS_NAME + ": No data passed into options");
            }

            if (!options.data.created) {
                throw new Error(this.CLASS_NAME + ": No created data passed into options");
            }

            if (!options.data.resolved) {
                throw new Error(this.CLASS_NAME + ": No resolved data passed into options");
            }

            if (!options.data.domain) {
                throw new Error(this.CLASS_NAME + ": No domain data passed into options");
            }

            this.id = options.id;

            this.cumulative = options.cumulative;

            this.days = options.days;

            this.period = options.period;

            this.rawData = options.data;

            this.data = this._formatData(options.data);

            this.hasVersionData = (options.versionData && options.versionData.length > 0);

            this.versionData = options.versionData;

            this.chartHeight = options.chartHeight;

            this.axisOptions = options.axisOptions || {};
        },

        render: function() {
            this.$el.html(this.Templates.Container({
                id: this.id
            }));

            this._chartContainerSelector = "#" + this.id + "-createdvsresolved-chart-wrapper";

            this._generateGraph();

            this._overlayVersionGraphics();

            this._generateMouseFollowingMarker();

            this._generateChart();

            //Specifically sets the top level yDomain function as children like LinePlot in Line Comparison
            //Cannot calculate it, without losing generalisation. This sucks.
            this.chart.yDomain(DualPlottable().yDomain());


            var chartElement = this.$(".createdvsresolved-chart", this.$el);
            chartElement.height(this.chartHeight);

            this.chart(d3.select(chartElement[0]));
        },

        /**
         * Takes domain, created and resolved data and formats it into the desired format
         * @param {Object} data
         * @returns {Object[]} correctly formatted data.
         * @private
         */
        _formatData: function (data) {
            //Assumes at least two elements in domain.
            var gap = data.domain[1].start - data.domain[0].end;
            var length = data.domain[0].end - data.domain[0].start;
            var end = data.domain[0].start - gap;
            var start = end - length;
            var formattedData = [
                [{start: start, end: end}, [0, 0]]
            ];

            data.domain.forEach(function(x, index) {
                formattedData.push([x, [
                    data.created[index].count,
                    data.resolved[index].count
                ]]);
            });
            return formattedData;
        },

        /**
         * Create a circle plot component for a line of data.
         * @param lineType
         * @returns {circlePlot}
         * @private
         */
        _createCirclePlot: function(lineType) {
            var self = this;

            var MIN_RADIUS = 2;
            var MAX_RADIUS = 5;

            var BORDER_WIDTH = 2;

            return c3.circlePlot()
                .radiusAccessor(function() {
                    return MAX_RADIUS;
                })
                .extend({
                    hoverRadiusAccessor: function() {
                        return this.radiusAccessor() * 1.75;
                    }
                })
                .enter(function(event) {
                    var c3Self = this;

                    event.selection.each(function(data, index) {
                        d3.select(this).attr("stroke-width", BORDER_WIDTH);
                    });
                    event.selection.on('click', function(data, index) {
                        if (index > 0) {
                            var dialog = self._createCirclePlotInlineDialog(this, 'circle-plot-' + index, data, index - 1, lineType);
                            dialog.show();
                        }
                    });
                    event.selection.on('mouseover', function() {
                        d3.select(this).transition().duration(100).attr("r", c3Self.hoverRadiusAccessor());
                    });

                    event.selection.on('mouseleave', function() {
                        d3.select(this).transition().duration(100).attr("r", c3Self.radiusAccessor());
                    });
                })

                //Decrease the size of the circles if they are close together...hacky.
                .extend(function() {

                    var circlePoints = this.selection().selectAll("circle");

                    var firstX = d3.select(circlePoints[0][0]).attr('cx');
                    var secondX = d3.select(circlePoints[0][1]).attr('cx');

                    var width = secondX - firstX;


                    var radius = Math.max(MIN_RADIUS, Math.min((width - 1) / 2, MAX_RADIUS));
                    this.radiusAccessor(radius);

                    circlePoints.attr('r', this.radiusAccessor());
                    circlePoints.attr('stroke-width', this.radiusAccessor() / 1.5);
                });
        },

        /**
         * Creates the main graph for the chart. This includes the line, area and circle plots for created and
         * resolved data.
         *
         * @private
         */
        _generateGraph: function() {
            this.graph = LineComparisonGraph({
                firstName: 'created',
                secondName: 'resolved'
            });

            this._modifyLineWidth();

            var createdPlot = this._createCirclePlot(this.LINE_TYPE.CREATED).yAccessor(function(d) {
                return d[1][0];
            });

            var resolvedPlot = this._createCirclePlot(this.LINE_TYPE.RESOLVED).yAccessor(function(d) {
                return d[1][1];
            });

            this.graph
                .addLayer('created-points', createdPlot)
                .addLayer('resolved-points', resolvedPlot);
        },

        /**
         * Change the size of the line depending on how much space there is between points.
         * @private
         */
        _modifyLineWidth: function() {
            function calculateDistanceBetweenPoints(line) {
                var points = line.attr("d").split(/[a-zA-Z]/);
                points.shift();

                if (points.length < 2) {
                    return null;
                }

                var firstX = points[0].split(',')[0];
                var secondX = points[1].split(',')[0];

                return secondX - firstX;
            }

            function modifyLineWidth() {
                var line = this.selection().selectAll("path");

                var width = calculateDistanceBetweenPoints(line);

                if (width) {
                    var lineWidth = Math.max(2, Math.min(width / 2, 5));
                    line.attr('stroke-width', lineWidth);
                } else {
                    line.attr('stroke-width', 5);
                }
            }


            this.graph.extend(modifyLineWidth);
        },

        /**
         * Add a marker that follows the mouse movement onto the graph, with a dialog next to it.
         * This should only show if no element has opened an inline dialog in the chart.
         *
         * @private
         */
        _generateMouseFollowingMarker: function() {
            var self = this;

            this.markerFollowingMouse = MarkerFollowingMouseWithDialog({
                region: this.graph,
                domContextSelector: "#" + this.id + "-createdvsresolved-chart-wrapper",
                canShow: function() {
                    return !$("." + self.INLINE_DIALOG_CLASS).is(":visible");
                },
                yTopOffset: (self.hasVersionData ? VERSIONS_INLINE_DIALOG_VERT_TOP_OFFSET : NO_VERSIONS_INLINE_DIALOG_VERT_TOP_OFFSET),

                generateContent: function(date) {

                    //Given a value calculate what index it is in the data set.
                    var dataIndex = BinarySearch.search(self.data, date, function(goal, test) {
                        var start = test[0].start;
                        var end = test[0].end;

                        if (start <= goal && goal <= end) {
                            return 0;
                        } else if (goal < start) {
                            return -1;
                        } else {
                            return 1;
                        }
                    });

                    if (dataIndex < 0 || dataIndex >= self.data.length) {
                        return null;
                    }

                    var indicatedTime;
                    if (self.cumulative) {
                        indicatedTime = DateRange.rangeToText(self._getFirstDate(), self.data[dataIndex][0].end);
                    } else {
                        indicatedTime = DateRange.rangeToText(self.data[dataIndex][0].start, self.data[dataIndex][0].end);
                    }

                    return self.Templates.renderScrubberDialogContent({
                        indicatedTime: indicatedTime,
                        created: self.data[dataIndex][1][0],
                        resolved: self.data[dataIndex][1][1]
                    });
                }
            });

            this.graph.prependLayer('following-marker', this.markerFollowingMouse);
        },

        /**
         * Apply version lines and labels onto the graph. Allows the user to click a version to get information.
         * @private
         */
        _overlayVersionGraphics: function() {
            var self = this;

            if (this.hasVersionData) {
                var versions = c3.layerable();
                versions.addLayer('lines', Markers().data(this.versionData).xDomain(this.graph.xDomain()).xAccessor(function (d) {
                    return d[0];
                }).extend({
                    y1: function () {
                        return -(VERSION_TOP_SPACING - VERSION_GROUP_NUB_HEIGHT - VERSION_LINE_SPACING);
                    }
                }));

                var labels = GroupedLabels({
                    groupTextGenerator: function(totalGroupedLabels) {
                        return AJS.format("{0} versions", totalGroupedLabels);
                    }
                }).data(this.versionData).xDomain(this.graph.xDomain()).xAccessor(function (d) {
                    return d[0];
                }).extend({
                    y: function () {
                        return function () {
                            //Want the labels to be placed above the chart by a certain amount
                            return (-VERSION_TOP_SPACING);
                        };
                    },
                    textGenerator: function () {
                        return function (d) {
                            return d[1].name;
                        };
                    }
                }).extend(function() {
                    var labelsSelf = this;
                    var labelData = labelsSelf.data();

                    var dialogCount = 0;
                    this.elements().each(function() {
                        var groupedIds = d3.select(this).attr(GroupedLabels.GROUPING_DATA_ATTR);
                        self._createVersionInlineDialog(this, 'version-info-' + self.id + "-" + (dialogCount++), labelData, groupedIds.split(","));
                    });
                });

                versions.addLayer('labels', labels);

                // TODO: Make the code below not as hacky.
                // create joining lines, should probably be moved to it's own component with some interface to define
                // when it should merge markers...too late to do this now.
                versions.extend(function() {
                    var lineGroup = $(".lines", this.selection().node());
                    var lines = $(".marker-line", lineGroup);
                    var labels = $(".labels .label", this.selection().node());

                    labels.each(function(index) {
                        var label = $(labels.get(index));
                        var lineIndexes = label.attr(GroupedLabels.GROUPING_DATA_ATTR).split(",");

                        var multipleLines = document.createElementNS('http://www.w3.org/2000/svg','g');
                        multipleLines.setAttribute('class','multiple-lines');

                        var start = parseFloat($(lines.get(lineIndexes[0])).attr('x1'));
                        var end = parseFloat($(lines.get(lineIndexes[lineIndexes.length - 1])).attr('x1'));

                        //Need to draw a horizontal line
                        //assumed that they are in x-ordering.
                        var horizontalLine = document.createElementNS('http://www.w3.org/2000/svg','line');
                        horizontalLine.setAttribute('class','horizontal-line');
                        horizontalLine.setAttribute('x1',start);
                        horizontalLine.setAttribute('x2',end);
                        horizontalLine.setAttribute('y1', -VERSION_MARKER_TOP);
                        horizontalLine.setAttribute('y2', -VERSION_MARKER_TOP);
                        multipleLines.appendChild(horizontalLine);

                        var middle = start + ((end - start) / 2);
                        var nubLine = document.createElementNS('http://www.w3.org/2000/svg','line');
                        nubLine.setAttribute('class','nub-line');
                        nubLine.setAttribute('x1', middle);
                        nubLine.setAttribute('x2', middle);
                        nubLine.setAttribute('y1', -(VERSION_MARKER_TOP));
                        nubLine.setAttribute('y2', -(VERSION_MARKER_TOP + VERSION_GROUP_NUB_HEIGHT));
                        multipleLines.appendChild(nubLine);

                        _.each(lineIndexes, function(value) {
                            multipleLines.appendChild($(lines.get(parseInt(value))).remove().get(0));
                        });
                        lineGroup.append(multipleLines);
                    });

                });

                //Highlight lines on label hover
                versions.extend(function() {
                    var versionLines = $(".lines .marker-line", this.selection().node());
                    var groupingLines = $(".lines .horizontal-line", this.selection().node());
                    var nubLines = $(".lines .nub-line", this.selection().node());
                    var labels = $(".labels .label", this.selection().node());

                    labels.mouseenter(function() {
                        var index = labels.index(this);

                        d3.select(groupingLines.get(index)).classed('line-highlighted', true);
                        d3.select(nubLines.get(index)).classed('line-highlighted', true);


                        $(this).attr(GroupedLabels.GROUPING_DATA_ATTR).split(",").forEach(function(value) {
                            d3.select(versionLines.get(value)).classed('line-highlighted', true);
                        });
                    });

                    labels.mouseleave(function() {
                        var index = labels.index(this);

                        d3.select(groupingLines.get(index)).classed('line-highlighted', false);
                        d3.select(nubLines.get(index)).classed('line-highlighted', false);

                        $(this).attr(GroupedLabels.GROUPING_DATA_ATTR).split(",").forEach(function(value) {
                            d3.select(versionLines.get(value)).classed('line-highlighted', false);
                        });
                    });
                });


                this.graph.prependLayer('versions', versions);
            }
        },

        /**
         * Create an inline dialog for the Chart.
         * @param {Node} trigger to click to open dialog
         * @param {String} id of the dialog
         * @param {String} content to place into the dialog.
         * @private
         */
        _createInlineDialog: function(trigger, id, content) {
            var self = this;

            $(trigger).click(function() {
               self.markerFollowingMouse.hide();
            });

            return AJS.InlineDialog($(trigger), id, function(element, trigger, showPopup) {
                element.parent().addClass('created-vs-resolved-inline-dialog');
                element.html(content);


                //this stops closing the dialog if you click anything in it
                //the dialog closes if you click outside it, see JRA-24215
                $(element).click(function(e){
                    e.stopPropagation();
                });


                showPopup();
                return false;
            }, {
                fadeTime: 0,
                cacheContent: false, // don't cache the dialog content
                hideDelay: 60000, // set longer timeout (default is 10 seconds)
                gravity: 'w',
                width: 350
            });
        },

        /**
         * Create an inline dialog for a circle plot.
         * @param {Node} trigger of the circle on the graph
         * @param {String} id to assign to the inline dialog
         * @param {Object} data for the given x axis point
         * @param {Number} index of the data point in the data array
         * @param {String} lineType for the point
         * @private
         */
        _createCirclePlotInlineDialog: function(trigger, id, data, index, lineType) {

            var dialogContent = "";
            if (data[1][0] === data[1][1]) {
                dialogContent =  this._createdAndResolvedClickDialogContent(data, index);
            } else if (lineType === this.LINE_TYPE.CREATED) {
                dialogContent = this._createdClickDialogContent(data, index);
            } else if (lineType === this.LINE_TYPE.RESOLVED) {
                dialogContent = this._resolvedClickDialogContent(data, index);
            }

            return this._createInlineDialog(trigger, id, dialogContent);
        },

        /**
         * Given version data and groups of versions generate a version dialog.
         * @param trigger
         * @param id
         * @param data
         * @param groupedIndexes
         * @private
         */
        _createVersionInlineDialog: function(trigger, id, data, groupedIndexes) {
            var firstDate = data[groupedIndexes[0]][0];
            var lastDate = data[groupedIndexes[groupedIndexes.length - 1]][0];
            var dateRangeString = DateRange.rangeToText(firstDate, lastDate);

            var dialogContent = this.Templates.VersionDialog({
                dateRange: dateRangeString,
                data: data,
                groupedIndexes: groupedIndexes
            });

            this._createInlineDialog(trigger, id, dialogContent);
        },


        /**
         * Takes the graph and applies axis' and grids to generate a chart.
         * @private
         */
        _generateChart: function() {
            var self = this;
            var axisOptions = {};

            if (this.axisOptions.includeXAxis) {
                axisOptions.xAxisValue = function(d) {

                    if (self.period === "hourly") {
                        return moment(d).format("ha DD MMM YYYY");
                    } else {
                        return moment(d).format("DD MMM YYYY");
                    }
                };
            }

            if (this.axisOptions.includeYAxis) {
                axisOptions.yAxisValue = function(d) {
                    var noDecimals = d3.format("d")(d);
                    if (noDecimals) {
                        return JIRA.NumberFormatter.format(parseInt(noDecimals));
                    } else {
                        return noDecimals;
                    }
                };
            }

            this.chart = Chart(this.graph, axisOptions)
                .data(this.data).extend({
                    xAccessor: function() {
                        return function(d) {
                            return d[0].end;
                        };
                    }
                });


            //JC-400: Add some more padding on the right so the last label should always be fully visible
            this.chart.east(c3.withDimensions().width(CHART_RIGHT_PADDING));


            //If we are applying version information create padding on the top for the version labels to go into.
            if (this.hasVersionData) {
                this.chart.north(c3.withDimensions().height(VERSION_TOP_SPACING + VERSION_HEIGHT));
            }
        },

        /**
         * Given a type of type and a date range create a query string for JQL.
         * @param {Number} index of the data element
         * @param {LineType} lineType of the data
         *
         * @return {String} of the url for the data
         * @private
         */
        _getSectionUrl: function(index, lineType) {
            return this.rawData[lineType][index].searchUrl;
        },

        /**
         * Create content for the created circle plot inline dialog.
         * @param {Object} data of the point
         * @param {Number} index of the data point
         *
         * @returns {String} HTML representing content
         * @private
         */
        _createdClickDialogContent: function(data, index) {
            return this._createClickDialogContent(data, index, true, false);
        },

        /**
         * Create content for the resolved circle plot inline dialog.
         * @param {Object} data of the point
         * @param {Number} index of the data point
         *
         * @returns {String} HTML representing content
         * @private
         */
        _resolvedClickDialogContent: function(data, index) {
            return this._createClickDialogContent(data, index, false, true);
        },

        /**
         * Create content for the inline dialog which represents both created and resolved.
         * @param {Object} data of the point
         * @returns {String} HTML representing content
         * @private
         */
        _createdAndResolvedClickDialogContent: function(data, index) {
            return this._createClickDialogContent(data, index, true, true);
        },

        /**
         * Generate the content for the point click inline dialog.
         * @param {Object} data for the x coordinate of the point
         * @param {Number} index of the data point
         * @param {Boolean} includeCreated whether to show created info
         * @param {Boolean} includeResolved whether to show resolved info
         * @returns {String} HTML representing content
         * @private
         */
        _createClickDialogContent: function(data, index, includeCreated, includeResolved) {
            var values = [];
            if (includeCreated) {
                values.push({
                    label: AJS.format("{0} created", data[1][0]),
                    url: this._getSectionUrl(index, this.LINE_TYPE.CREATED),
                    value: data[1][0]
                });
            }

            if (includeResolved) {
                values.push({
                    label: AJS.format("{0} resolved", data[1][1]),
                    url: this._getSectionUrl(index, this.LINE_TYPE.RESOLVED),
                    value: data[1][1]
                });
            }

            var dialogTitle;
            if (this.cumulative) {
                dialogTitle = DateRange.rangeToText(this._getFirstDate(), data[0].end);
            } else {
                dialogTitle = DateRange.rangeToText(data[0].start, data[0].end);
            }

            return this.Templates.pointDialogMulti({
                title: dialogTitle,
                values: values
            });
        },

        _getFirstDate: function() {
            return this.data[1][0].start;
        }
    });

    return CreatedVsResolvedChart;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:createdvsresolved-chart', location = 'static/components/charts/createdvsresolved/CreatedVsResolvedChart.soy' */
// This file was automatically generated from CreatedVsResolvedChart.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.CreatedVsResolvedChart.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.CreatedVsResolvedChart == 'undefined') { JIRA.DashboardItem.CreatedVsResolvedChart = {}; }
if (typeof JIRA.DashboardItem.CreatedVsResolvedChart.Templates == 'undefined') { JIRA.DashboardItem.CreatedVsResolvedChart.Templates = {}; }


JIRA.DashboardItem.CreatedVsResolvedChart.Templates.Container = function(opt_data, opt_ignored) {
  return '<div id="' + soy.$$escapeHtml(opt_data.id) + '-createdvsresolved-chart-wrapper" class="createdvsresolved-chart-wrapper"><svg class="createdvsresolved-chart"/></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolvedChart.Templates.Container.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolvedChart.Templates.Container';
}


JIRA.DashboardItem.CreatedVsResolvedChart.Templates.renderScrubberDialogContent = function(opt_data, opt_ignored) {
  return '<div class="scrubber-dialog-heading"><span class="ghx-iconfont aui-icon aui-icon-small aui-iconfont-calendar"></span> ' + soy.$$escapeHtml(opt_data.indicatedTime) + '</div><table class="scrubber-dialog-table"><tr><td class="content-label">' + soy.$$escapeHtml("Created") + '</td><td class="content-value">' + soy.$$escapeHtml(opt_data.created) + '</td></tr><tr><td class="content-label">' + soy.$$escapeHtml("Resolved") + '</td><td class="content-value">' + soy.$$escapeHtml(opt_data.resolved) + '</td></tr></table>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolvedChart.Templates.renderScrubberDialogContent.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolvedChart.Templates.renderScrubberDialogContent';
}


JIRA.DashboardItem.CreatedVsResolvedChart.Templates.pointDialogMulti = function(opt_data, opt_ignored) {
  var output = '<div class="createdvsresolved-point-inline-dialog"><h3 class="createdvsresolved-point-title">' + soy.$$escapeHtml(opt_data.title) + '</h3>';
  var valueList22 = opt_data.values;
  var valueListLen22 = valueList22.length;
  for (var valueIndex22 = 0; valueIndex22 < valueListLen22; valueIndex22++) {
    var valueData22 = valueList22[valueIndex22];
    output += '<p><span class="createdvsresolved-point-label">' + soy.$$escapeHtml(valueData22.label) + '</span>' + ((valueData22.value > 0) ? ' <a href="' + soy.$$escapeHtml(valueData22.url) + '">' + soy.$$escapeHtml("View in Issue Navigator") + '</a>' : '') + '</p>';
  }
  output += '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolvedChart.Templates.pointDialogMulti.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolvedChart.Templates.pointDialogMulti';
}


JIRA.DashboardItem.CreatedVsResolvedChart.Templates.VersionDialog = function(opt_data, opt_ignored) {
  var output = '<h3>' + soy.$$escapeHtml(opt_data.dateRange) + '</h3><ul class="version-list">';
  var indexList40 = opt_data.groupedIndexes;
  var indexListLen40 = indexList40.length;
  for (var indexIndex40 = 0; indexIndex40 < indexListLen40; indexIndex40++) {
    var indexData40 = indexList40[indexIndex40];
    output += '<li class="version-information"><div class="version-name"><a href="' + soy.$$escapeHtml(opt_data.data[indexData40][1].url) + '">' + soy.$$escapeHtml(opt_data.data[indexData40][1].name) + '</a>' + ((opt_data.groupedIndexes.length > 1) ? '<span class="version-date">' + soy.$$escapeHtml(opt_data.data[indexData40][1].releaseDatePretty) + '</span>' : '') + '</div>' + ((opt_data.data[indexData40][1].description) ? '<div class="version-description">' + soy.$$escapeHtml(opt_data.data[indexData40][1].description) + '</div>' : '') + '</li>';
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolvedChart.Templates.VersionDialog.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolvedChart.Templates.VersionDialog';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:unresolvedtrend-chart', location = 'static/components/charts/unresolvedtrend/UnresolvedTrendChart.js' */
/**
 * Creates a c3 component representing the UnresolvedTrendChart.
 *
 * @module UnresolvedTrendChart
 */
define('jira-dashboard-items/components/charts/unresolved-trend-chart', [
    'jquery',
    'backbone',
    'jira-dashboard-items/components/charts/components/chart',
    'jira-dashboard-items/components/charts/components/markers',
    'jira-dashboard-items/components/charts/components/marker-following-mouse-with-dialog',
    'jira-dashboard-items/components/dates/daterange',
    'jira-dashboard-items/components/search/binary-search',
    'jira-dashboard-items/lib/d3',
    'jira-dashboard-items/lib/c3',
    'jira/moment'
], function(
    $,
    Backbone,
    Chart,
    Markers,
    MarkerFollowingMouseWithDialog,
    DateRange,
    BinarySearch,
    d3,
    c3,
    moment
) {

    return Backbone.View.extend({
        Templates: JIRA.DashboardItem.UnresolvedChart.Templates,

        initialize: function(options) {
            options = options || {};

            this._parseOptions(options);
        },

        _parseOptions: function(options) {
            //TODO: Validation for this
            this.id = options.id;
            this.data = options.data;
            this.domain = options.domain;
            this.versionData = options.versionData;
            this.chartHeight = options.chartHeight;
            this.period = options.period;
            this.axisOptions = options.axisOptions || {};
        },

        render: function() {
            var instance = this;

            this.$el.html(instance.Templates.Container({
                id: this.id
            }));

            var svgElement = $("svg.unresolvedtrend-chart", this.$el);

            var unresolvedData = formatAsLineData(this.data, this.domain);

            var graph = c3.layerable();


            graph.addLayer('line', c3.linePlot().elementClass('unresolved-trend'))
                .addLayer('movingMarker', MarkerFollowingMouseWithDialog({
                    region: graph,
                    domContextSelector: "#" + this.id + "-unresolvedtrend-chart-wrapper",
                    canShow: function() {
                        return !$(".created-vs-resolved-inline-dialog").is(":visible");
                    },

                    generateContent: function(date) {

                        //Given a value calculate what index it is in the data set.
                        var dataIndex = BinarySearch.search(unresolvedData, date, function(goal, test) {
                            var start = test[0].start;
                            var end = test[0].end;

                            if (start <= goal && goal <= end) {
                                return 0;
                            } else if (goal < start) {
                                return -1;
                            } else {
                                return 1;
                            }
                        });

                        if (dataIndex < 0 || dataIndex >= unresolvedData.length) {
                            return null;
                        }

                        return instance.Templates.renderScrubberDialogContent({
                            indicatedTime: DateRange.rangeToText(unresolvedData[dataIndex][0].start, unresolvedData[dataIndex][0].end),
                            unresolved: unresolvedData[dataIndex][1]
                        });
                    }
                }));

            if (this.versionData && this.versionData.length > 0) {
                var markers = Markers().data(this.versionData).xDomain(graph.xDomain()).xAccessor(function(d) {
                    return d[0];
                });
                graph.prependLayer('versions', markers);
            }

            var chartOptions = {};

            if (this.axisOptions.includeXAxis) {
                chartOptions.xAxisValue = function(d) {
                    if (this.period === "hourly") {
                        return moment(d).format("ha DD MMM YYYY");
                    } else {
                        return moment(d).format("DD MMM YYYY");
                    }
                };
            }

            if (this.axisOptions.includeYAxis) {
                chartOptions.yAxisValue = function(d) {
                    var noDecimals = d3.format("d")(d);
                    if (noDecimals) {
                        return JIRA.NumberFormatter.format(parseInt(noDecimals));
                    } else {
                        return noDecimals;
                    }
                };
            }

            var chart = Chart(graph, chartOptions).data(unresolvedData).extend({
                xAccessor: function() {
                    return function(d) {
                        return d[0].end;
                    };
                }
            });

            svgElement.height(this.chartHeight);

            chart(d3.select(svgElement.get(0)));
        }
    });

    /**
     * Merge the Unresolved Data and domain into a form usable by the LinePlot
     * @param {Number[]} unresolvedData
     * @param {Object[]} domain
     * @returns {Object[]}
     */
    function formatAsLineData(unresolvedData, domain) {
        var gap = domain[1].start - domain[0].end;
        var length = domain[0].end - domain[0].start;
        var end = domain[0].start - gap;
        var start = end - length;
        var data = [
            [{start: start, end: end}, 0]
        ];

        domain.forEach(function(x, index) {
            data.push([x, unresolvedData[index]]);
        });
        return data;
    }
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:unresolvedtrend-chart', location = 'static/components/charts/unresolvedtrend/UnresolvedTrendChart.soy' */
// This file was automatically generated from UnresolvedTrendChart.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.UnresolvedChart.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.UnresolvedChart == 'undefined') { JIRA.DashboardItem.UnresolvedChart = {}; }
if (typeof JIRA.DashboardItem.UnresolvedChart.Templates == 'undefined') { JIRA.DashboardItem.UnresolvedChart.Templates = {}; }


JIRA.DashboardItem.UnresolvedChart.Templates.Container = function(opt_data, opt_ignored) {
  return '<div id="' + soy.$$escapeHtml(opt_data.id) + '-unresolvedtrend-chart-wrapper" class="unresolvedtrend-chart-wrapper"><svg class="unresolvedtrend-chart"/></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.UnresolvedChart.Templates.Container.soyTemplateName = 'JIRA.DashboardItem.UnresolvedChart.Templates.Container';
}


JIRA.DashboardItem.UnresolvedChart.Templates.renderScrubberDialogContent = function(opt_data, opt_ignored) {
  return '<div class="scrubber-dialog-heading"><span class="ghx-iconfont aui-icon aui-icon-small aui-iconfont-calendar"></span> ' + soy.$$escapeHtml(opt_data.indicatedTime) + '</div><table class="scrubber-dialog-table"><tr><td class="content-label">' + soy.$$escapeHtml("Unresolved") + '</td><td class="content-value">' + soy.$$escapeHtml(opt_data.unresolved) + '</td></tr></table>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.UnresolvedChart.Templates.renderScrubberDialogContent.soyTemplateName = 'JIRA.DashboardItem.UnresolvedChart.Templates.renderScrubberDialogContent';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:createdvsresolved-dashboard-item-resources', location = 'static/dashboarditem/createdvsresolved/CreatedVsResolved.js' */
define("jira-dashboard-items/createdvsresolved", [
    'jquery',
    'jira/moment',
    'jira-dashboard-items/createdvsresolved-config-view',
    'jira-dashboard-items/components/charts/createdvsresolved-chart',
    'jira-dashboard-items/components/charts/unresolved-trend-chart',
    'jira-dashboard-items/common-functions',
    'underscore'
], function(
    $,
    moment,
    ConfigView,
    CreatedVsResolvedChart,
    UnresolvedTrendChart,
    DashboardHelperFunctions,
    _
) {

    var Templates = JIRA.DashboardItem.CreatedVsResolved.Templates;

    var PERIOD_I18N = {
        'hourly': "Hourly",
        'daily': "Daily",
        'weekly': "Weekly",
        'monthly': "Monthly",
        'quarterly': "Quarterly",
        'yearly': "Yearly"
    };

    /**
     *
     * @param {InlineGadgetAPI} API
     * @param {Object} [options] for gadget
     * @constructor
     */
    var DashboardItem = function(API, options) {
        this.API = API;
        this.options = options || {};
    };

    /**
     * Render the configuration screen for the created vs resolved gadget
     * @param {Node} element to render into
     * @param {Object} preferences for object.
     */
    DashboardItem.prototype.renderEdit = function(element, preferences) {
        var gadget = this;

        if (gadget.resizeHandler)
        {
            $(element).removeResize(gadget.resizeHandler);
            delete gadget.resizeHandler;
        }


        var dashboardPreferences = gadget._backwardCompatability(preferences);
        var configViewPreferences = gadget._dashboardToConfigViewPreferences(dashboardPreferences);

        $(".createdvsresolved-gadget", element).html(Templates.ConfigContainer());

        gadget.API.setTitle( "Created vs Resolved Chart" );

        this.configView = new ConfigView({
            id: gadget.API.getGadgetId(),
            el: $(".createdvsresolved-config-container", element),
            projectFilterDelay: this.options.delay
        });

        this.configView.render(configViewPreferences);

        this.configView.bind("cancel", function() {
            gadget.API.closeEdit();
        });

        this.configView.bind("submit", function(gadgetPreferences) {
            gadget.API.resize();

            var dashboardPreferences = gadget._configViewToDashboardPreferences(gadgetPreferences);

            gadget.API.savePreferences(dashboardPreferences).fail(function(message) {
                if (message.status === 401) {
                    gadget.configView.unauthorisedFormSave();
                } else {
                    var errors = parseErrorMessage(message.responseText);
                    gadget.configView.errorSavingForm(errors);
                }
            });
        });

        this.configView.bind("layoutUpdate", function() {
            gadget.API.resize();
        });

        this.API.once("afterRender", function () {
            if (element.width() < 350) {
                $(element).find("form.aui").addClass("top-label");
            }
            gadget.API.resize();
        });

    };


    /**
     * Render the configured created vs resolved gadget.
     * @param {node} element to apply gadget to
     * @param {Object} preferences for gadget that have been configured.
     */
    DashboardItem.prototype.render = function(element, preferences) {
        var gadget = this;

        var gadgetElement = $(".createdvsresolved-gadget", element);
        gadgetElement.html(Templates.RenderChart({showUnresolvedTrend:preferences.showUnresolvedTrend}));

        gadget.API.initRefresh(preferences, _.bind(gadget.render, gadget, element, preferences));
        gadget.API.showLoadingBar();

        preferences = gadget._backwardCompatability(preferences);

        var dateInfoRequest = this._requestDateData(preferences);

        $.when(dateInfoRequest).done(function(dateInfoResponse) {
            gadget.API.hideLoadingBar();

            var formattedData = gadget._generateCreatedVsResolvedData(dateInfoResponse.results);
            var versionData = gadget._generateVersionData(preferences.type, preferences.versionLabel, dateInfoResponse.versions, formattedData.domain);

            gadget.initialRender = true;
            gadget._renderChart($(element).attr('id'), gadgetElement, preferences, dateInfoResponse, formattedData, versionData);
            gadget.resizeHandler = function() {
                if(gadget.initialRender) {
                    gadget.initialRender = false;
                } else {
                    _.bind(gadget._renderChart, gadget, $(element).attr('id'), gadgetElement, preferences, dateInfoResponse, formattedData, versionData)();
                }
            };
            $(element).resize(_.throttle(gadget.resizeHandler, 600));

        }).fail(function(message) {
            if (message.statusText === 'timeout') {
                gadgetElement.html(JIRA.DashboardItem.CreatedVsResolved.Templates.Timeout());
            } else if (message.status === 400) {
                var errors = parseErrorMessage(message.responseText);

                gadgetElement.html(JIRA.DashboardItem.CreatedVsResolved.Templates.Errors({
                    errors: errors
                }));
            } else {
                gadgetElement.html(JIRA.DashboardItem.CreatedVsResolved.Templates.ServerError());
            }
            gadget.API.hideLoadingBar();

            gadget.API.resize();

        });
    };

    /**
     * Get the chart data for the given preferences.
     *
     * @param {Object} preferences for the chart
     * @returns {jQuery.deferred}
     * @private
     */
    DashboardItem.prototype._requestDateData = function(preferences) {
        var dateInfoRequestData = {
            jql: preferences.type + "=" + preferences.id,
            period: preferences.periodName,
            daysprevious: preferences.daysprevious,
            operation: preferences.operation,
            field: ['created', 'resolved'],
            includeVersions: preferences.versionLabel && preferences.versionLabel !== 'none'
        };

        if (preferences.showUnresolvedTrend) {
            dateInfoRequestData.field.push('unresolvedTrend');
        }

        return $.ajax({
            method: "GET",
            url: AJS.contextPath() + '/rest/gadget/1.0/dateCountInPeriod',
            dataType: "json",
            data: dateInfoRequestData
        });
    };


    /**
     * This takes the REST rest resource results and puts it into a format that the CreatedVsResolvedChart understands.
     * @param {Object[]} results from REST resource
     * @returns {{domain: Array, created: Array, resolved: Array, unresolvedTrend: Array}}
     */
    DashboardItem.prototype._generateCreatedVsResolvedData = function(results) {
        var domain = [];
        var createdValues = [];
        var resolvedValues = [];
        var unresolvedTrend = [];
        results.forEach(function(result) {
            domain.push({
                start: result.start,
                end: result.end
            });

            createdValues.push(result.data.created);
            resolvedValues.push(result.data.resolved);
            if (result.data.unresolvedTrend) {
                unresolvedTrend.push(result.data.unresolvedTrend.count);
            }
        });

        return {
            domain: domain,
            created: createdValues,
            resolved: resolvedValues,
            unresolvedTrend: unresolvedTrend
        };
    };

    /**
     * Given a version response transform it into a format useful for the charts and filter out unwanted versions.
     * @param {String} type of the issue searcher, e.g. project or filter.
     * @param {String} versionsAllowed states what type of versions we should display
     * @param {Object[]} versions from the server
     * @param {Object[]} domain for the graph
     * @returns {*}
     */
    DashboardItem.prototype._generateVersionData = function(type, versionsAllowed, versions, domain) {
        var dashboardItem = this;
        var start = domain[0].start;
        var end = domain[domain.length - 1].end;
        var data = [];
        versions.forEach(function(version) {
            var hasReleaseDate = !!version.releaseDate;
            var isInRange = (start <= version.releaseDate) && (version.releaseDate <= end);
            var isValidVersionName = dashboardItem._isValidVersionName(versionsAllowed, version.name);

            if (hasReleaseDate && isInRange && isValidVersionName) {
                //generate url

                if (type === "filter") {
                    version.name = version.project.key + ":" + version.name;
                }

                version.releaseDatePretty = moment(version.releaseDate).format("DD-MMM-YYYY");

                data.push([version.releaseDate, version]);
            }
        });

        return _.sortBy(data, function(version) {
            return version[0];
        });
    };


    /**
     * Given a JSON string extract the errors into an array.
     * @param {JSON} errorString to parse
     * @returns {string[]} of errors
     */
    function parseErrorMessage(errorString) {
        var errorArray = [];
        try {
            var errorJSON = JSON.parse(errorString);
        } catch (error) {
            return errorArray;
        }
        for (var key in errorJSON){
            if (errorJSON.hasOwnProperty(key)) {
                errorArray.push({
                    key: key,
                    message: errorJSON[key]
                });
            }
        }
        return errorArray;
    }

    /**
     * @typedef Object GadgetPreferences
     * @global
     *
     * @property {String} [projectFilterID] of a selected filter/project
     * @property {String} [periodName] for the period grouping
     * @property {Number} [daysprevious] for looking back by the period
     * @property {Boolean} [isCumulative] for grouping the issue number
     * @property {Boolean} [showUnresolvedTrend] should include the unresolved trend
     * @property {String} [versionLabel] whether to populate the version
     * @property {Boolean} [refresh] whether to check the refresh value
     **/

    /**
     *
     * @param {GadgetPreferences} gadgetPreferences
     * @returns DashboardPreferences
     * @private
     */
    DashboardItem.prototype._backwardCompatability = function(gadgetPreferences) {
        // lenient check if a value is present
        // https://jira.atlassian.com/browse/JRA-59364
        function isBlank(value) {
            return value === null || value === undefined || value === '';
        }

        if (!_.isUndefined(gadgetPreferences.isCumulative) && isBlank(gadgetPreferences.operation)) {
            if (gadgetPreferences.isCumulative) {
                gadgetPreferences.operation = 'cumulative';
            } else {
                gadgetPreferences.operation = 'count';
            }

            delete gadgetPreferences.isCumulative;
        }

        return DashboardHelperFunctions.projectFilterBackwardCompatible(gadgetPreferences);
    };

    /**
     * @typedef Object DashboardPreferences
     * @global
     *
     * @property {Boolean} [isConfigured] whether the dashboard item is configured
     * @property {String} [name] of a selected filter/project
     * @property {String} [type] of the selected filter/project
     * @property {String} [id] of the selected filter/project
     * @property {String} [periodName] for the period grouping
     * @property {Number} [daysprevious] for looking back by the period
     * @property {String} [operation] for grouping the issue number
     * @property {Boolean} [showUnresolvedTrend] should include the unresolved trend
     * @property {String} [versionLabel] whether to populate the version
     * @property {Boolean} [refresh] whether to check the refresh value
     **/


    /**
     * Convert the dashboard preferences type to the format that the config view expects.
     * @param {DashboardPreferences} dashboardPreferences
     * @returns {CreatedVsResolvedConfigViewPreferences}
     * @private
     */
    DashboardItem.prototype._dashboardToConfigViewPreferences = function(dashboardPreferences) {
        return {
            name: dashboardPreferences.name,
            id: dashboardPreferences.id,
            type: dashboardPreferences.type,
            periodName: dashboardPreferences.periodName,
            range: dashboardPreferences.daysprevious,
            operation: dashboardPreferences.operation,
            showUnresolvedTrend: dashboardPreferences.showUnresolvedTrend,
            versionLabel: dashboardPreferences.versionLabel,
            refresh: dashboardPreferences.refresh,
            isConfigured: dashboardPreferences.isConfigured
        };
    };

    /**
     * Convert the config view preferences format to the expected dashboard item preferences format.
     * @param {CreatedVsResolvedConfigViewPreferences} configViewPreferences
     * @returns DashboardPreferences
     * @private
     */
    DashboardItem.prototype._configViewToDashboardPreferences = function(configViewPreferences) {
        var refresh = false;
        if (configViewPreferences.refresh === true) {
            refresh = '15';
        }

        return {
            name: configViewPreferences.name,
            id: configViewPreferences.id,
            type: configViewPreferences.type,
            periodName: configViewPreferences.periodName,
            daysprevious: configViewPreferences.range,
            operation: configViewPreferences.operation,
            showUnresolvedTrend: configViewPreferences.showUnresolvedTrend,
            versionLabel: configViewPreferences.versionLabel,
            refresh: refresh
        };
    };

    /**
     * If all versions area allowed, any version name is valid. Major versions will filter out any
     * minor versions as defined by the _isMinorVersion function
     *
     * @param {String} versionsAllowed The versions allowed for the chart. Either 'all', 'major' or 'none'
     * @param {String} version the version name
     */
    DashboardItem.prototype._isValidVersionName = function(versionsAllowed, version) {
       return  versionsAllowed === "all" || versionsAllowed === "major" && !this._isMinorVersion(version);
    };

    /**
     * A version is minor if it contains more than 1 '.' separators or 'alpha' or 'beta' in the name.
     *
     * This logic may seem a bit strange, however it is what it is from JIRA core from ages back.
     * Changing it would mean changing behaviour of the created vs resolved chart for thousands of
     * users.
     *
     * @param {String} version the version name
     */
    DashboardItem.prototype._isMinorVersion = function(version) {
        if(version) {
            var numberOfVersionSeparators = (version.match(/\./g) || []).length;
            var isAlphaOrBetaVersion = version.indexOf("alpha") >= 0 || version.indexOf("beta") >= 0;
            return numberOfVersionSeparators > 1 || isAlphaOrBetaVersion;
        }
        return false;
    };

    /**
     * Render the chart into the dashboard item.
     * @param {String} id of the dashboard item.
     * @param {Node} gadgetElement to render the chart
     * @param {Object} preferences
     * @param {Object} dateInfoResponse includes the raw response for the data.
     * @param formattedData
     * @param versionData
     * @private
     */
    DashboardItem.prototype._renderChart = function(id, gadgetElement, preferences, dateInfoResponse, formattedData, versionData) {
        var gadget = this;

        var createdVsResolvedChartContainer = gadgetElement.find(".createdvsresolved-chart-container");

        var containerWidth = createdVsResolvedChartContainer.outerWidth();
        var containerHeight = containerWidth * 2/3;

        //if no trend is shown account for 20px bottom padding of the trend chart and spacing between charts so charts line up
        var createdVsResolvedChartHeight = preferences.showUnresolvedTrend ? containerHeight * 3/4 : containerHeight + 20;
        var trendChartHeight = Math.max(containerHeight/4, 80);

        var createdVsResolvedOptions = {
            id: id,
            data: formattedData,
            versionData: versionData,
            el: createdVsResolvedChartContainer,
            filterUrl: dateInfoResponse.filterUrl,
            axisOptions: {
                includeXAxis: true,
                includeYAxis: true
            },
            cumulative: preferences.operation === "cumulative",
            days: preferences.daysprevious,
            period: preferences.periodName,
            chartHeight: createdVsResolvedChartHeight
        };

        var createdVsResolvedChart = new CreatedVsResolvedChart(createdVsResolvedOptions);

        createdVsResolvedChart.render();

        if (preferences.showUnresolvedTrend) {

            var unresolvedTrendChart = new UnresolvedTrendChart({
                el: gadgetElement.find(".unresolvedtrend-chart-container").get(0),

                id: id,
                data: formattedData.unresolvedTrend,
                domain: formattedData.domain,
                versionData: versionData,
                period: preferences.periodName,
                chartHeight: trendChartHeight,
                axisOptions: {
                    includeXAxis: true,
                    includeYAxis: true
                }
            });

            unresolvedTrendChart.render();
        }

        var chartInfoContainer = gadgetElement.find(".createdvsresolved-chart-info");

        chartInfoContainer.html(Templates.ChartDetailsContent({
            createdCount: dateInfoResponse.totals.created,
            resolvedCount: dateInfoResponse.totals.resolved,
            dayCount: JIRA.NumberFormatter.format(parseInt(preferences.daysprevious)),
            period: PERIOD_I18N[preferences.periodName],
            filterUrl: dateInfoResponse.filterUrl
        }));

        gadget.API.setTitle( AJS.format("Created vs Resolved Chart: {0}", dateInfoResponse.filterTitle) );

        gadget.API.resize();
    };

    return DashboardItem;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:createdvsresolved-dashboard-item-resources', location = 'static/dashboarditem/createdvsresolved/CreatedVsResolved.soy' */
// This file was automatically generated from CreatedVsResolved.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.CreatedVsResolved.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.CreatedVsResolved == 'undefined') { JIRA.DashboardItem.CreatedVsResolved = {}; }
if (typeof JIRA.DashboardItem.CreatedVsResolved.Templates == 'undefined') { JIRA.DashboardItem.CreatedVsResolved.Templates = {}; }


JIRA.DashboardItem.CreatedVsResolved.Templates.Container = function(opt_data, opt_ignored) {
  return '<div class=\'createdvsresolved-gadget\'></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.Container.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.Container';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.ConfigContainer = function(opt_data, opt_ignored) {
  return '<div class=\'createdvsresolved-config-container\'></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.ConfigContainer.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.ConfigContainer';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.RenderChart = function(opt_data, opt_ignored) {
  return '' + JIRA.DashboardItem.CreatedVsResolved.Templates.ChartContainer(opt_data) + JIRA.DashboardItem.CreatedVsResolved.Templates.ChartDetailsContainer(null);
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.RenderChart.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.RenderChart';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.ChartContainer = function(opt_data, opt_ignored) {
  return '<div class=\'chart-container\'><div class=\'createdvsresolved-chart-container\'></div>' + ((opt_data.showUnresolvedTrend) ? '<div class=\'unresolvedtrend-chart-container\'></div>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.ChartContainer.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.ChartContainer';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.ChartDetailsContainer = function(opt_data, opt_ignored) {
  return '<div class=\'createdvsresolved-chart-info\'></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.ChartDetailsContainer.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.ChartDetailsContainer';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.ChartDetailsContent = function(opt_data, opt_ignored) {
  return '<div class=\'createdvsresolved-chart-details-header\'><div class=\'createdvsresolved-chart-details-title\'>' + soy.$$escapeHtml(AJS.format("Issues in the last {0} days",opt_data.dayCount)) + '</div><div class=\'createdvsresolved-chart-details-grouping\'>' + soy.$$escapeHtml(AJS.format("(grouped {0})",opt_data.period)) + '</div><a class=\'createdvsresolved-chart-details-link\' href="' + soy.$$escapeHtml(opt_data.filterUrl) + '">' + soy.$$escapeHtml("View in Issue Navigator") + '</a></div><div class=\'createdvsresolved-chart-details-totals\'><div class=\'created-totals\'><svg height="16" width="16" class="created-point"><circle cx="8" cy="8" r="5"></circle></svg>' + soy.$$escapeHtml(AJS.format("Created issues ({0})",opt_data.createdCount)) + '</div><div class=\'resolved-totals\'><svg height="16" width="16" class="resolved-point"><circle cx="8" cy="8" r="5"></circle></svg>' + soy.$$escapeHtml(AJS.format("Resolved issues ({0})",opt_data.resolvedCount)) + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.ChartDetailsContent.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.ChartDetailsContent';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.Configuration = function(opt_data, opt_ignored) {
  return '' + Atlassian.DashboardItem.Common.Templates.config({fields: '' + JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.ConfigurationField({prefix: opt_data.prefix, id: 'project-filter-picker', selectionType: opt_data.preferences.type, selectionID: opt_data.preferences.id, selectionName: opt_data.preferences.name}) + JIRA.DashboardItem.CreatedVsResolved.Templates.PeriodField({prefix: opt_data.prefix, options: opt_data.periodOptions.options, value: opt_data.preferences.periodName}) + JIRA.DashboardItem.CreatedVsResolved.Templates.RangeField({prefix: opt_data.prefix, label: "Days Previously", value: opt_data.preferences.range}) + JIRA.DashboardItem.CreatedVsResolved.Templates.Operations({prefix: opt_data.prefix, options: opt_data.chartValueOptions.options, value: opt_data.preferences.operation}) + JIRA.DashboardItem.CreatedVsResolved.Templates.Unresolved({prefix: opt_data.prefix, options: opt_data.unresolvedOptions.options, value: opt_data.preferences.showUnresolvedTrend}) + JIRA.DashboardItem.CreatedVsResolved.Templates.Versions({prefix: opt_data.prefix, options: opt_data.versionsOptions.options, value: opt_data.preferences.versionLabel}) + Atlassian.DashboardItem.Common.Templates.refreshInterval({prefix: opt_data.prefix, id: 'refresh-interval', value: opt_data.preferences.refresh}), isConfigured: opt_data.preferences.isConfigured});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.Configuration.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.Configuration';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.Errors = function(opt_data, opt_ignored) {
  var param69 = '<ul>';
  var errorList71 = opt_data.errors;
  var errorListLen71 = errorList71.length;
  for (var errorIndex71 = 0; errorIndex71 < errorListLen71; errorIndex71++) {
    var errorData71 = errorList71[errorIndex71];
    param69 += '<li>' + soy.$$escapeHtml(errorData71.message) + '</li>';
  }
  param69 += '</ul>';
  var output = '' + aui.message.error({titleContent: "Unfortunately, one or more of your preferences are now unavailable. Please update your preferences, or remove gadget by clicking delete from the title bar above.", closeable: 'false', content: param69});
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.Errors.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.Errors';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.ServerError = function(opt_data, opt_ignored) {
  return '' + aui.message.error({titleContent: "The JIRA server was contacted but has returned an error response. We are unsure of the result of this operation.", closeable: 'false', content: ''});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.ServerError.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.ServerError';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.Timeout = function(opt_data, opt_ignored) {
  return '' + aui.message.error({titleContent: "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.", closeable: 'false', content: ''});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.Timeout.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.Timeout';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.ErrorSaving = function(opt_data, opt_ignored) {
  var param91 = '<ul>';
  var errorList93 = opt_data.errors;
  var errorListLen93 = errorList93.length;
  for (var errorIndex93 = 0; errorIndex93 < errorListLen93; errorIndex93++) {
    var errorData93 = errorList93[errorIndex93];
    param91 += '<li>' + soy.$$escapeHtml(errorData93.message) + '</li>';
  }
  param91 += '</ul>';
  var output = '' + aui.message.error({titleContent: "The JIRA server was contacted but has returned an error response. We are unsure of the result of this operation.", closeable: 'false', content: param91});
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.ErrorSaving.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.ErrorSaving';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.UnauthorisedFormSave = function(opt_data, opt_ignored) {
  return '' + aui.message.error({titleContent: "You are not authorised to perform this operation. Please log in.", closeable: 'false', content: ''});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.UnauthorisedFormSave.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.UnauthorisedFormSave';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.PeriodField = function(opt_data, opt_ignored) {
  var output = '';
  var id__soy106 = opt_data.prefix + 'period';
  output += aui.form.selectField({id: id__soy106, name: 'periodName', value: opt_data.value, labelContent: "Period", options: opt_data.options, isRequired: true, descriptionText: "The length of periods represented on the graph."});
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.PeriodField.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.PeriodField';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.RangeField = function(opt_data, opt_ignored) {
  var output = '';
  var id__soy116 = opt_data.prefix + 'range';
  output += aui.form.textField({id: id__soy116, name: 'range', labelContent: opt_data.label, value: opt_data.value, isRequired: true, descriptionText: "Days in the past to collect data for the selected period."});
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.RangeField.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.RangeField';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.Operations = function(opt_data, opt_ignored) {
  var output = '';
  var id__soy125 = opt_data.prefix + 'operation';
  output += aui.form.selectField({id: id__soy125, name: 'operation', value: opt_data.value, labelContent: "Collection Operation", options: opt_data.options, isRequired: true, descriptionText: "Progressively add totals (1.. 2.. 3), or show individual values (1.. 1.. 1)."});
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.Operations.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.Operations';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.Unresolved = function(opt_data, opt_ignored) {
  var output = '';
  var id__soy135 = opt_data.prefix + 'showUnresolvedTrend';
  var showUnresolved__soy136 = opt_data.value ? 'true' : 'false';
  output += aui.form.selectField({id: id__soy135, name: 'showUnresolvedTrend', value: showUnresolved__soy136, labelContent: "Display the Trend of Unresolved", options: opt_data.options, isRequired: true, descriptionText: "Show the number of unresolved issues over time in a subplot."});
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.Unresolved.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.Unresolved';
}


JIRA.DashboardItem.CreatedVsResolved.Templates.Versions = function(opt_data, opt_ignored) {
  var output = '';
  var id__soy146 = opt_data.prefix + 'versionLabel';
  output += aui.form.selectField({id: id__soy146, name: 'versionLabel', value: opt_data.value, labelContent: "Display Versions", options: opt_data.options, isRequired: true, descriptionText: "Show when versions were released on the chart."});
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.CreatedVsResolved.Templates.Versions.soyTemplateName = 'JIRA.DashboardItem.CreatedVsResolved.Templates.Versions';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:createdvsresolved-dashboard-item-resources', location = 'static/dashboarditem/createdvsresolved/CreatedVsResolvedConfigView.js' */
define('jira-dashboard-items/createdvsresolved-config-view', [
    'jquery',
    'backbone',
    'jira-dashboard-items/components/autocomplete/project-filter-autocomplete'
], function(
    $,
    Backbone,
    ProjectFilterAutoComplete
) {

    /**
     * Represents there own preference type so simplify this class as it does not need to know about the old or new
     * gadget preference format.  Therefore, not needing to deal with backwards compatibility.
     * @typedef Object CreatedVsResolvedConfigViewPreferences
     * @global
     *
     * @property {String} [name] of a selected filter/project
     * @property {String} [type] of the selected filter/project
     * @property {String} [id] of the selected filter/project
     * @property {String} [periodName] for the period grouping
     * @property {Number} [range] for looking back by the period
     * @property {String} [operation] for grouping the issue number
     * @property {Boolean} [showUnresolvedTrend] should include the unresolved trend
     * @property {String} [versionLabel] whether to populate the version
     * @property {Boolean} [refresh] whether to check the refresh value
     **/


    /**
     * Represents the view for the configuration screen of the CreatedVsResolved Dashboard Item.
     * @type {Backbone.View} CreatedVsResolvedConfigView
     */
    var CreatedVsResolvedConfigView = Backbone.View.extend({

        templates: JIRA.DashboardItem.CreatedVsResolved.Templates,

        events: {
            "click .cancel": "cancel",
            "submit": "submit"
        },

        initialize: function(options) {
            this.id = options.id;
            this.projectFilterDelay = options.projectFilterDelay;
        },

        /**
         * Render the screen with the current fields populated with the preferences
         * @param {CreatedVsResolvedConfigViewPreferences} preferences
         */
        render: function(preferences) {
            preferences = preferences || {};
            var self = this;

            this.$el.html(this.templates.Configuration({
                prefix: this.id + "-",
                preferences: preferences,
                periodOptions: PERIOD_OPTIONS,
                chartValueOptions: OPERATION_OPTIONS,
                unresolvedOptions: UNRESOLVED_OPTIONS,
                versionsOptions: VERSIONS_OPTIONS
            }));

            this._bindProjectFilterAutocomplete();
        },

        /**
         * Apply the project filter autocomplete to the field in the form.
         * @private
         */
        _bindProjectFilterAutocomplete: function() {
            var self = this;

            var projectFilterOptions = {
                field: $("#" + this.id + "-project-filter-picker", this.$el),

                completeField: function(selection) {
                    if (selection) {
                        self.$el.find("input[name=type]").val(selection.type);
                        self.$el.find("input[name=id]").val(selection.id);
                        self.$el.find("input[name=name]").val(selection.name);
                        self.$el.find(".filterpicker-value-name").text(selection.name).addClass('success');
                        this.field.val('');
                        this.field.trigger("change");
                    }
                },

                maxHeight: 140
            };

            //Mostly used for testing where we don't want a delay;
            if (this.projectFilterDelay) {
                projectFilterOptions.delay = this.projectFilterDelay;
            }

            //To account for advanced search mechanism
            projectFilterOptions.parentElement = this.$el.find("form");
            projectFilterOptions.fieldID = projectFilterOptions.field.attr("id");

            //Instantiate project filter autocomplete
            ProjectFilterAutoComplete(projectFilterOptions);
        },


        submit: function(event) {
            event.preventDefault();

            if (this._validate()) {
                this.trigger("submit", this.getFields());
            }
        },

        cancel: function() {
            this.trigger("cancel");
        },

        /**
         * @returns {CreatedVsResolvedConfigViewPreferences}
         */
        getFields: function() {
            return {
                name: this.$el.find("input[name=name]").val(),
                type: this.$el.find("input[name=type]").val(),
                id: this.$el.find("input[name=id]").val(),
                periodName: this.$el.find("select[name=periodName]").val(),
                range: this.$el.find("input[name=range]").val(),
                operation: this.$el.find("select[name=operation]").val(),
                showUnresolvedTrend: this.$el.find("select[name=showUnresolvedTrend]").val() === 'true',
                versionLabel: this.$el.find("select[name=versionLabel]").val(),
                refresh: this.$el.find("input[name=refresh-interval]").prop('checked')
            };
        },

        /**
         * Validate the configuration and any fields that are not correct apply an error message to the field.
         * @returns {boolean} if it is valid or not
         * @private
         */
        _validate: function() {
            var preferences = this.getFields();
            var valid = true;
            if (!preferences.id || !preferences.type) {
                $(".projectOrFilter-error", this.$el).text("No project or filter specified.").show();
                valid = false;
            } else {
                $(".projectOrFilter-error", this.$el).hide();
            }

            if (!RANGE_INPUT_LIMIT[preferences.periodName]) {
                throw "Period invalid";
            }

            var range = preferences.range;

            var rangeFieldGroup = $("input[name=range]", this.$el).closest('.field-group');
            if (/^\s*$/.test(preferences.range)) {
                this._addError(rangeFieldGroup, "Days previously is a required field.");
                valid = false;
            } else if (isNaN(preferences.range)) {
                this._addError(rangeFieldGroup, "Field must be a number");
                valid = false;
            } else if (preferences.range <= 0) {
                this._addError(rangeFieldGroup, "Field must be positive");
                valid = false;
            } else if (!/^\d+$/.test(preferences.range)) {
                this._addError(rangeFieldGroup,"Field must be a number");
                valid = false;
            } else if (range > RANGE_INPUT_LIMIT[preferences.periodName]) {
                this._addError(rangeFieldGroup, AJS.format("Maximum allowed value is {0} days for the \'\'{1}\'\' period.", RANGE_INPUT_LIMIT[preferences.periodName], PERIOD_LABELS[preferences.periodName]));
                valid = false;
            } else {
                this._removeError(rangeFieldGroup);
            }

            this.trigger("layoutUpdate");

            return valid;
        },

        /**
         * Remove any errors in the field group
         * @param {Node} fieldGroup
         * @private
         */
        _removeError: function(fieldGroup) {
            $(fieldGroup).find('.error').remove();
        },

        /**
         * Add an error to the field group
         * @param {Node} fieldGroup
         * @param {String} errorMessage
         * @private
         */
        _addError: function(fieldGroup, errorMessage) {
            this._removeError(fieldGroup);
            fieldGroup = $(fieldGroup);

            var error = $("<div class='error'/>");
            error.html(errorMessage);
            fieldGroup.append(error);
            error.show();
        },

        /**
         * Trying to save the preferences resulted in a 401.
         */
        unauthorisedFormSave: function() {
            this.removeErrors();
            this.$el.append(this.templates.UnauthorisedFormSave());
            this.trigger("layoutUpdate");
        },

        /**
         * There was an error saving the form.
         */
        errorSavingForm: function(errors) {
            errors = errors || [];
            this.removeErrors();
            this.$el.append(this.templates.ErrorSaving({
                errors: errors
            }));
            this.trigger("layoutUpdate");
        },

        /**
         * Remove any previous messages in the form.
         */
        removeErrors: function() {
            this.$el.find('.aui-message').remove();
            this.trigger("layoutUpdate");
        }
    });

    /**
     * Constants used for population the view options and limits for the fields, etc.
     */

    var RANGE_INPUT_LIMIT = {
        hourly: 10,
        daily: 300,
        weekly: 1750,
        monthly: 7500,
        quarterly: 22500,
        yearly: 36500
    };

    var PERIOD_LABELS = {
        'hourly': "Hourly",
        'daily' : "Daily",
        'weekly' : "Weekly",
        'monthly' : "Monthly",
        'quarterly' : "Quarterly",
        'yearly' : "Yearly"
    };

    var PERIOD_OPTIONS = {
        options: [
            {
                value: 'hourly',
                text: PERIOD_LABELS.hourly
            },
            {
                value: 'daily',
                text: PERIOD_LABELS.daily
            },
            {
                value: 'weekly',
                text: PERIOD_LABELS.weekly

            },
            {
                value: 'monthly',
                text: PERIOD_LABELS.monthly

            },
            {
                value: 'quarterly',
                text: PERIOD_LABELS.quarterly
            },
            {
                value: 'yearly',
                text: PERIOD_LABELS.yearly
            }
        ]
    };

    var OPERATION_OPTIONS = {
        options: [
            {
                value: 'count',
                text: "Count"
            },
            {
                value: 'cumulative',
                text: "Cumulative"
            }
        ]
    };

    var UNRESOLVED_OPTIONS = {
        options: [
            {
                value: 'false',
                text: "No"
            },
            {
                value: 'true',
                text: "Yes"
            }
        ]
    };

    var VERSIONS_OPTIONS = {
        options: [
            {
                value: 'all',
                text: "All versions"
            },
            {
                value: 'major',
                text: "Only major versions"
            },
            {
                value: 'none',
                text: "None"
            }
        ]
    };

    return CreatedVsResolvedConfigView;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:filter-picker-component', location = 'static/components/filterpicker/FilterPicker.soy' */
// This file was automatically generated from FilterPicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.Common.Config.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.Common == 'undefined') { JIRA.DashboardItem.Common = {}; }
if (typeof JIRA.DashboardItem.Common.Config == 'undefined') { JIRA.DashboardItem.Common.Config = {}; }
if (typeof JIRA.DashboardItem.Common.Config.Templates == 'undefined') { JIRA.DashboardItem.Common.Config.Templates = {}; }


JIRA.DashboardItem.Common.Config.Templates.filterPicker = function(opt_data, opt_ignored) {
  var output = '';
  var prefixedId__soy3 = opt_data.prefix + opt_data.id;
  output += '<div class="field-group ' + soy.$$escapeHtml(opt_data.id) + '"><label for="' + soy.$$escapeHtml(prefixedId__soy3) + '">' + soy.$$escapeHtml("Saved Filter") + '<span class="aui-icon icon-required"> ' + soy.$$escapeHtml("required") + '</span></label><select class="select" id="' + soy.$$escapeHtml(prefixedId__soy3) + '" name="' + soy.$$escapeHtml(opt_data.id) + '"></select><div class="error">' + soy.$$escapeHtml("No Filter selected") + '</div><input class="hidden" id="filter_' + soy.$$escapeHtml(prefixedId__soy3) + '_id"/><input class="hidden" id="filter_' + soy.$$escapeHtml(prefixedId__soy3) + '_name"/><div class="description"><a id="filter_' + soy.$$escapeHtml(prefixedId__soy3) + '_advance" class="advanced-search" href="#" title="' + soy.$$escapeHtml("Click here to select/change filter or project.") + '" target="_parent">' + soy.$$escapeHtml("Advanced Search") + '</a></div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Common.Config.Templates.filterPicker.soyTemplateName = 'JIRA.DashboardItem.Common.Config.Templates.filterPicker';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:filter-picker-component', location = 'static/components/filterpicker/FilterPicker.js' */
define("jira-dashboard-items/components/filter-picker", [
    'underscore',
    'jquery',
    'jira/ajs/ajax/smart-ajax',
    'jira/ajs/select/single-select'
], function (
    _,
    $,
    SmartAjax,
    SingleSelect
) {

    'use strict';

    return function () {
        var observer;

        var initialiseAdvancedSearch = function(parentElement, fieldId, select)
        {
            /*
             * Listening for DOMAttrModified works in all browsers except WEBKIT.  MutationObservers work for all
             * browsers except IE9 and IE10.  So I am using a combination of both to listen for the updates from the
             * advanced filter picker.  This does mean that some browsers will pick up the change twice, so we must
             * ensure that updateSelect can be executed twice without any negative side affects.
             */

            var updateSelect = function () {
                var id = $("#filter_" + fieldId + "_id").attr("value");
                if (id.indexOf("filter-") === 0) {
                    id = id.substr(7);
                }
                var label = $("#filter_" + fieldId + "_name").text();
                var descriptor = new AJS.ItemDescriptor({
                    value: id,
                    label: label
                });

                select.setSelection(descriptor, true);
            };

            var advancedFilterResultIdField = parentElement.find("#filter_" + fieldId + "_id");

            advancedFilterResultIdField.on("DOMAttrModified", updateSelect);
            if (window.MutationObserver || window.WebkitMutationObserver || window.MozMutationObserver) {
                observer = new MutationObserver(updateSelect);
                observer.observe(advancedFilterResultIdField[0], {attributes: true});
            }

            parentElement.find("#filter_" + fieldId + "_advance").click(function (e) {
                var url = AJS.contextPath() + "/secure/FilterPickerPopup.jspa?showProjects=false&field=" + fieldId;
                var windowVal = "filter_" + fieldId.replace(new RegExp('-', 'g'), '') + "_window";
                var prefs = "width=800, height=500, resizable, scrollbars=yes";
                window.open(url, windowVal, prefs).focus();

                e.preventDefault();
            });
        };


        return {
            init: function (options) {
                var element = options.element;
                var selectedValue = options.selectedValue;
                var self = this;

                this.select = new SingleSelect({
                    element: element,
                    itemAttrDisplayed: "label",
                    revertOnInvalid: true,
                    removeDuplicates: true,
                    submitInputVal: false,
                    showDropdownButton: true,
                    removeOnUnSelect: false,
                    // override the default matching strategy, allowing matches to start with any kind of prefix
                    matchingStrategy: '(^|(.*))({0})(.*)',
                    ajaxOptions: {
                        url: AJS.contextPath() + "/rest/gadget/1.0/pickers/filters",
                        query: true,
                        data: {
                            fieldName: "quickfind"
                        },
                        formatResponse: function (response) {
                            var ret = [];
                            if (response.filters && response.filters.length) {
                                var groupDescriptor = new AJS.GroupDescriptor();
                                _.each(response.filters, function (filter) {
                                    groupDescriptor.addItem(new AJS.ItemDescriptor({
                                        value: filter.id,
                                        label: filter.name
                                    }));
                                });
                                ret.push(groupDescriptor);
                            }
                            return ret;
                        }
                    }
                });

                if (selectedValue) {
                    self.select.disable();

                    SmartAjax.makeRequest({
                        method: "GET",
                        url: AJS.contextPath() + "/rest/api/2/filter/" + selectedValue,
                        success: function (data) {
                            self.select.setSelection(new AJS.ItemDescriptor({
                                value: selectedValue,
                                label: data.name
                            }));
                        },
                        complete: function() {
                            self.select.enable();
                        }
                    });
                }

                initialiseAdvancedSearch(options.parentElement, element.attr('id'), self.select);

                this.errorField = element.parents(".field-group").find(".error");
                self.select.hideErrorMessage = function () { }; //noop
                self.select.showErrorMessage = function () { }; //noop
                return this;
            },

            getValue: function () {
                if(this.select.lastSelection) {
                    return {
                        "id": this.select.lastSelection.value(),
                        "label": this.select.lastSelection.label()
                    };
                }
                return null;
            },

            validate: function () {
                if (this.select.lastSelection && this.select.lastSelection.value()) {
                    this.errorField.hide();
                    return true;
                }
                else {
                    this.errorField.show();
                    return false;
                }
            },

            disconnectObserver: function() {
                if (observer) {
                    observer.disconnect();
                }
            }
        };
    };
});;
;
/* module-key = 'com.atlassian.jira.gadgets:two-dimensional-stats-dashboard-item-resources', location = 'static/dashboarditem/two-dimensional-stats/TwoDimensionalStats.js' */
define("jira-dashboard-items/two-dimensional-stats", [
    'jquery',
    'underscore',
    'jira-dashboard-items/components/filter-picker'
], function (
    $,
    _,
    FilterPicker
) {
    "use strict";

    /**
     *
     * @param {InlineGadgetAPI} API
     * @param {Object} [options] for gadget
     * @constructor
     */
    var DashboardItem = function (API, options) {
        this.API = API;
        this.options = options || {};

        // field configurations
        this.fields = createStaticSelectFieldsConfigurations();
        this.filterPicker = new FilterPicker();
    };

    /**
     * Render the configured piechart gadget.
     * @param {node} element to apply gadget to
     * @param {Object} preferences for gadget that have been configured.
     */
    DashboardItem.prototype.render = function (element, preferences) {
        var $element = $(element);
        var self = this;

        self.API.initRefresh(preferences, _.bind(self.render, self, element, preferences));
        self.API.showLoadingBar();

        var normalizedFilterId = preferences.filterId !== undefined ? preferences.filterId.replace('filter-', '') : preferences.filterId;

        $.ajax({
            method: "GET",
            url: AJS.contextPath() + '/rest/gadget/1.0/twodimensionalfilterstats/generate',
            dataType: "json",
            data: {
                filterId: 'filter-' + normalizedFilterId,
                xstattype: preferences.xstattype,
                ystattype: preferences.ystattype,
                sortDirection: preferences.sortDirection,
                sortBy: preferences.sortBy,
                numberToShow: ( preferences.more ? 1000 : preferences.numberToShow )
            }
        }).done(function (response) {
            if (response.filter) {
                self.API.setTitle(AJS.format("Two Dimensional Filter Statistics: {0}", response.filter.filterTitle));
            } else {
                self.API.setTitle("Two Dimensional Filter Statistics");
            }

            if (response.totalRows === 0) {
                $element.html(JIRA.DashboardItem.TwoDimensionalStats.Templates.EmptyResultMessage({
                    href: AJS.contextPath() + "/issues/?filter=" + normalizedFilterId
                }));
                return;
            }

            prepareCssClassesToBePrinted(response);
            $element.html(JIRA.DashboardItem.TwoDimensionalStats.Templates.Table({
                yAxisLabel: response.yHeading,
                xHeaderLabels: response.firstRow.cells,
                contentRows: response.rows,
                totalRows: response.totalRows,
                xHeading: response.xHeading,
                filterUrl: response.filter.filterUrl,
                filterTitle: response.filter.filterTitle,
                visibleContentRows: response.rows.length - 1, // - 1 because totals row is also included in response.rows
                showMore: preferences.more
            }));
            AJS.trigger('analyticsEvent', {name: 'jira.dashboard.gadgets.twodstats.rowscount', data: {value: response.rows.length}});
            AJS.trigger('analyticsEvent', {name: 'jira.dashboard.gadgets.twodstats.colscount', data: {value: response.firstRow.cells.length}});

            $element.find('.content-control-link').click( function(e) {
                preferences.more = $(e.target).data('more');
                if(self.API.isEditable()) {
                    self.API.savePreferences(preferences);
                } else {
                    self.render(element, preferences);
                }
            });
        }).fail(function () {
            $element.html(JIRA.DashboardItem.TwoDimensionalStats.Templates.ServerErrorMessage({
                filterId: normalizedFilterId
            }));
        }).always(function () {
            self.API.hideLoadingBar();

            self.API.resize();

            $element.find('.two-d-container').
                // check if horizontal scrollbar is present
                toggleClass('h-scrollbar', $element.find('.table-container').width() < $element.find('.table-container > .extra-container > table').width());
        });
    };

    /**
     * Render the configuration screen for the piechart gadget
     * @param {jQuery} element to render into
     * @param {Object} saved preferences for this gadget
     */
    DashboardItem.prototype.renderEdit = function (element, preferences) {
        var $element = $(element);
        var self = this;

        self.API.setTitle( "Two Dimensional Filter Statistics" );
        self.API.showLoadingBar();

        $.ajax({
            method: "GET",
            url: AJS.contextPath() + '/rest/gadget/1.0/statTypes',
            dataType: "json"
        }).done(function (response) {
            self.fields.statTypeOptions = self._updateStatTypeFieldNames(response.stats);

            $element.html(JIRA.DashboardItem.TwoDimensionalStats.Templates.Form({
                prefix: self.API.getGadgetId() + "-",
                preferences: preferences,
                fields: self.fields
            }));

            self.filterPicker.init({
                gadgetErrorContainer: $element.find(".dashboard-item-error"),
                element: $element.find("#" + self.API.getGadgetId() + "-filterId"),
                selectedValue: preferences.filterId !== undefined ? preferences.filterId.replace('filter-', '') : preferences.filterId,
                parentElement: $element
            });
            $element.find('.buttons-container .cancel').click(self.API.closeEdit.bind(self.API));
            $element.find('form').on("submit", function(e) {
                e.preventDefault();
                var $form = $(e.target);

                var preferences = self._getPreferencesObject($form);
                preferences.filterId = 'filter-' + (self.filterPicker.validate() ? self.filterPicker.getValue().id : ''); // prefix "filter-" is necessary to make the stored value compatible with the old gadget
                preferences.refresh = self.API.getRefreshFieldValue();
                preferences.more = false;

                if (self._validPreferences($form, preferences)) {
                    self.API.savePreferences(preferences);
                }
                else {
                    self.API.resize();
                }
            });
        }).fail(function() {
            $element.html(JIRA.DashboardItem.TwoDimensionalStats.Templates.ServerErrorMessage());
        }).always(function () {
            self.API.hideLoadingBar();

            self.API.resize();
        });
    };

    /**
     * Prepare the attribute classes to be rendered via Soy templates
     * @param response with classes attributes converted from Array to String.join(' ')
     * @private
     */
    function prepareCssClassesToBePrinted(response) {
        _.each( response.firstRow.cells, function(cell) {
            if( cell['classes'] && cell['classes'].join )
                cell['classes'] = cell['classes'].join(' ');
        });
        _.each( response.rows, function(row) {
            _.each( row.cells, function(cell) {
                if( cell['classes'] && cell['classes'].join )
                    cell['classes'] = cell['classes'].join(' ');
            });
        });
    }

    /**
     * Extract data from a form using jQuery.serializeArray. An internal whitelist is used to control data read.
     * @param $form
     * @returns a map of preferences, where keys are the field names and values are the input values
     * @private
     */
    DashboardItem.prototype._getPreferencesObject = function($form) {
        var formData = $form.serializeArray();
        var paramsWhitelist = ['filterId', 'numberToShow', 'sortBy', 'sortDirection', 'xstattype', 'ystattype'];
        var preferences = {};

        _.each( formData, function(element) {
            if( _.indexOf(paramsWhitelist, element.name) === -1 )
                return;

            preferences[element.name] = element.value;
        });

        return preferences;
    };

    /**
     * Response from statType service should use .text instead of .label to be used by AUI templates
     * @param statTypes
     * @returns a map with label properties replaced by text properties
     * @private
     */
    DashboardItem.prototype._updateStatTypeFieldNames = function(statTypes) {
        var i = statTypes.length;
        while ( i-- ) {
            statTypes[i].text = statTypes[i].label;
            delete statTypes[i].label;
        }

        return statTypes;
    };

    /**
     * Verify given preferences. Fields verified: filterId and numberToShow
     * @param $form
     * @param preferences
     * @returns {boolean}
     * @private
     */
    DashboardItem.prototype._validPreferences = function($form, preferences) {
        $form.find('.error').remove();

        if ( preferences.filterId === '' || preferences.filterId === 'filter-' ) {
            var field = $form.find('[name=filterId]');
            field.parent().append('<div class="error">' + "No Filter selected" + '</div>');
        }

        if ( !this._validNumberToShow( preferences.numberToShow ) ) {
            var field = $form.find('input[name=numberToShow]');
            field.after('<div class="error">' + "The value must be an integer greater than 0 and less than or equal to 50" + '</div>');
        }

        $form.find('.error').show();

        return $form.find('.error').size() === 0;
    };

    /**
     * Is this a validNumberToShow? (number AND 1 <= x <= 50)
     * @param number
     * @returns {boolean}
     * @private
     */
    DashboardItem.prototype._validNumberToShow = function(number) {
        return ( (/^\d+$/).test(number) === true && number >= 1 && number <= 50 );
    };

    /**
     * Create a configuration map to render static select fields in the edit form
     * @returns {Object} map of fields with two properties each: text and value
     */
    function createStaticSelectFieldsConfigurations() {
        var fields = {};

        fields.sortByOptions = [
            {
                text: "Natural",
                value: 'natural'
            },
            {
                text: "Total",
                value: 'total'
            }
        ];
        fields.sortDirectionOptions = [
            {
                text: "Ascending",
                value: 'asc'
            },
            {
                text: "Descending",
                value: 'desc'
            }
        ];

        return fields;
    }

    return DashboardItem;
});;
;
/* module-key = 'com.atlassian.jira.gadgets:two-dimensional-stats-dashboard-item-resources', location = 'static/dashboarditem/two-dimensional-stats/TwoDimensionalStats.soy' */
// This file was automatically generated from TwoDimensionalStats.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.TwoDimensionalStats.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.TwoDimensionalStats == 'undefined') { JIRA.DashboardItem.TwoDimensionalStats = {}; }
if (typeof JIRA.DashboardItem.TwoDimensionalStats.Templates == 'undefined') { JIRA.DashboardItem.TwoDimensionalStats.Templates = {}; }


JIRA.DashboardItem.TwoDimensionalStats.Templates.Table = function(opt_data, opt_ignored) {
  var output = '<div class="two-d-container"><div class="table-container"><div class="extra-container"><table class="aui aui-table-interactive"><thead><tr><th class="axis">' + soy.$$escapeHtml(opt_data.yAxisLabel) + '</th>';
  var labelList6 = opt_data.xHeaderLabels;
  var labelListLen6 = labelList6.length;
  for (var labelIndex6 = 0; labelIndex6 < labelListLen6; labelIndex6++) {
    var labelData6 = labelList6[labelIndex6];
    output += '<th ' + ((labelData6.classes) ? 'class="' + soy.$$escapeHtml(labelData6.classes) + '"' : '') + '>' + soy.$$filterNoAutoescape(labelData6.markup) + '</th>';
  }
  output += '</thead><tbody>';
  var rowList19 = opt_data.contentRows;
  var rowListLen19 = rowList19.length;
  for (var rowIndex19 = 0; rowIndex19 < rowListLen19; rowIndex19++) {
    var rowData19 = rowList19[rowIndex19];
    output += '<tr>';
    var dataList21 = rowData19.cells;
    var dataListLen21 = dataList21.length;
    for (var dataIndex21 = 0; dataIndex21 < dataListLen21; dataIndex21++) {
      var dataData21 = dataList21[dataIndex21];
      output += (dataIndex21 == 0) ? '<th class="scope ' + ((dataData21.classes) ? soy.$$escapeHtml(dataData21.classes) : '') + '">' + soy.$$filterNoAutoescape(dataData21.markup) + '</th>' : '<td ' + ((dataData21.classes) ? 'class="' + soy.$$escapeHtml(dataData21.classes) + '"' : '') + '>' + soy.$$filterNoAutoescape(dataData21.markup) + '</td>';
    }
    output += '</tr>';
  }
  output += '</tbody></table></div></div> <!-- .table-container --><div class="data-footer"><p class="numbers">' + soy.$$filterNoAutoescape(AJS.format("Showing {0} of {1} statistics.",'<strong>' + opt_data.visibleContentRows + '</strong>','<a href="' + opt_data.filterUrl + '" title="' + opt_data.filterTitle + '">' + '<strong>' + opt_data.totalRows + '</strong></a>')) + ((opt_data.showMore) ? ' <a class="content-control-link" data-more="false">' + soy.$$escapeHtml("Show less") + '</a>' : (opt_data.visibleContentRows < opt_data.totalRows) ? ' <a class="content-control-link" data-more="true">' + soy.$$escapeHtml("Show more") + '</a>' : '') + '</p><p class="grouped-by">' + soy.$$escapeHtml(AJS.format("Grouped by: {0}",opt_data.xHeading)) + '</p></div></div> <!-- .two-d-container -->';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.TwoDimensionalStats.Templates.Table.soyTemplateName = 'JIRA.DashboardItem.TwoDimensionalStats.Templates.Table';
}


JIRA.DashboardItem.TwoDimensionalStats.Templates.Form = function(opt_data, opt_ignored) {
  return '<div class="two-d-container">' + Atlassian.DashboardItem.Common.Templates.config({fields: '' + JIRA.DashboardItem.Common.Config.Templates.filterPicker({prefix: opt_data.prefix, id: 'filterId'}) + aui.form.selectField({id: opt_data.prefix + 'xstattype', name: 'xstattype', labelContent: "XAxis", isRequired: true, options: opt_data.fields.statTypeOptions, value: opt_data.preferences.xstattype}) + aui.form.selectField({id: opt_data.prefix + 'ystattype', name: 'ystattype', labelContent: "YAxis", isRequired: true, options: opt_data.fields.statTypeOptions, value: opt_data.preferences.ystattype}) + aui.form.selectField({id: opt_data.prefix + 'sortBy', name: 'sortBy', labelContent: "Sort By", isRequired: true, options: opt_data.fields.sortByOptions, value: '' + opt_data.preferences.sortBy, descriptionContent: "Sort by row total or natural field order."}) + aui.form.selectField({id: opt_data.prefix + 'sortDirection', name: 'sortDirection', labelContent: "Sort Direction", isRequired: true, options: opt_data.fields.sortDirectionOptions, value: opt_data.preferences.sortDirection}) + aui.form.textField({id: opt_data.prefix + 'numberToShow', name: 'numberToShow', labelContent: "Number of Results", isRequired: true, value: opt_data.preferences.numberToShow, descriptionContent: "Number of results to display."}) + Atlassian.DashboardItem.Common.Templates.refreshInterval({prefix: opt_data.prefix, id: 'refresh', value: opt_data.preferences.refresh}), isConfigured: opt_data.preferences.isConfigured}) + '</div> <!-- .two-d-container -->';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.TwoDimensionalStats.Templates.Form.soyTemplateName = 'JIRA.DashboardItem.TwoDimensionalStats.Templates.Form';
}


JIRA.DashboardItem.TwoDimensionalStats.Templates.EmptyResultMessage = function(opt_data, opt_ignored) {
  var output = '<div class="two-d-container"><div class="empty-results search-results-dashboard-item">';
  var filterLink__soy112 = '<a href="' + soy.$$escapeHtml(opt_data.href) + '">';
  output += soy.$$filterNoAutoescape(AJS.format("No matching {0}issues{1} found.",filterLink__soy112,'</a>')) + '</div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.TwoDimensionalStats.Templates.EmptyResultMessage.soyTemplateName = 'JIRA.DashboardItem.TwoDimensionalStats.Templates.EmptyResultMessage';
}


JIRA.DashboardItem.TwoDimensionalStats.Templates.ServerErrorMessage = function(opt_data, opt_ignored) {
  var output = '<div class="two-d-container">';
  var filterLink__soy121 = '<a href="' + soy.$$escapeHtml("/jira") + '/issues/?filter=' + soy.$$escapeHtml(opt_data.filterId) + '">';
  output += aui.message.error({content: '<p>' + soy.$$filterNoAutoescape(AJS.format("The filter configured for this gadget could not be retrieved. Please verify it is still valid on the {0}issue navigator{1}.",filterLink__soy121,'</a>')) + '</p>'}) + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.TwoDimensionalStats.Templates.ServerErrorMessage.soyTemplateName = 'JIRA.DashboardItem.TwoDimensionalStats.Templates.ServerErrorMessage';
}
;
;
/* module-key = 'com.atlassian.auiplugin:aui-experimental-restfultable', location = 'js/experimental-events/events.js' */
(function ($) {

    /**
     * Triggers a custom event on the AJS object
     *
     * @param {String} name - name of event
     * @param {Array} args - args for event handler
     */
    AJS.triggerEvt = function (name, args) {
        $(AJS).trigger(name, args);
    };

    /**
     * Binds handler to the AJS object
     *
     * @param {String} name
     * @param {Function} func
     */
    AJS.bindEvt = function (name, func) {
        $(AJS).bind(name, func);
    };

    /**
     * Some generic error handling that fires event in multiple contexts
     * - on AJS object
     * - on Instance
     * - on AJS object with prefixed id.
     *
     * @param evt
     * @param inst
     * @param args
     */
    AJS.triggerEvtForInst = function (evt, inst, args) {
        $(inst).trigger(evt, args);
        AJS.triggerEvt(evt, args);
        if (inst.id) {
            AJS.triggerEvt(inst.id + '_' + evt, args);
        }
    };

})(AJS.$);
;
;
/* module-key = 'com.atlassian.auiplugin:aui-experimental-restfultable', location = 'js-vendor/jquery/serializetoobject.js' */
/**
 * Serializes form fields within the given element to a JSON object
 *
 * {
 *    fieldName: "fieldValue"
 * }
 *
 * @returns {Object}
 */
jQuery.fn.serializeObject = function () {

    var data = {};

    this.find(":input:not(:button):not(:submit):not(:radio):not('select[multiple]')").each(function () {

        if (this.name === "") {
            return;
        }

        if (this.value === null) {
            this.value = "";
        }

        data[this.name] = this.value.match(/^(tru|fals)e$/i) ?
                            this.value.toLowerCase() == "true" : this.value;
    });

    this.find("input:radio:checked").each(function(){
        data[this.name] = this.value;
    });

    this.find("select[multiple]").each(function(){

        var $select = jQuery(this),
            val = $select.val();

        if ($select.data("aui-ss")) {
            if (val) {
                data[this.name] = val[0];
            } else {
                data[this.name] = "";
            }
        } else {

            if (val !== null) {
                data[this.name] = val;
            } else {
                data[this.name] = [];
            }
        }
    });

    return data;
};;
;
/* module-key = 'com.atlassian.auiplugin:aui-experimental-restfultable', location = 'js/experimental-restfultable/restfultable.js' */
(function ($) {

    /**
     * A table whose entries/rows can be retrieved, added and updated via REST (CRUD).
     * It uses backbone.js to sync the table's state back to the server, avoiding page refreshes.
     *
     * @class RestfulTable
     */
    AJS.RestfulTable = Backbone.View.extend({

        /**
         * @constructor
         * @param {!Object} options
         * ... {!Object} resources
         * ... ... {(string|function(function(Array.<Object>)))} all - URL of REST resource OR function that retrieves all entities.
         * ... ... {string} self - URL of REST resource to sync a single entities state (CRUD).
         * ... {!(selector|Element|jQuery)} el - Table element or selector of the table element to populate.
         * ... {!Array.<Object>} columns - Which properties of the entities to render. The id of a column maps to the property of an entity.
         * ... {Object} views
         * ... ... {AJS.RestfulTable.EditRow} editRow - Backbone view that renders the edit & create row. Your view MUST extend AJS.RestfulTable.EditRow.
         * ... ... {AJS.RestfulTable.Row} row - Backbone view that renders the readonly row. Your view MUST extend AJS.RestfulTable.Row.
         * ... {boolean} allowEdit - Is the table editable. If true, clicking row will switch it to edit state. Default true.
         * ... {boolean} allowDelete - Can entries be removed from the table, default true.
         * ... {boolean} allowCreate - Can new entries be added to the table, default true.
         * ... {boolean} allowReorder - Can we drag rows to reorder them, default false.
         * ... {boolean} autoFocus - Automatically set focus to first field on init, default false.
         * ... {boolean} reverseOrder - Reverse the order of rows, default false.
         * ... {boolean} silent - Do not trigger a "refresh" event on sort, default false.
         * ... {String} id - The id for the table. This id will be used to fire events specific to this instance.
         * ... {string} createPosition - If set to "bottom", place the create form at the bottom of the table instead of the top.
         * ... {string} addPosition - If set to "bottom", add new rows at the bottom of the table instead of the top. If undefined, createPosition will be used to define where to add the new row.
         * ... {string} noEntriesMsg - Text to display under the table header if it is empty, default empty.
         * ... {string} loadingMsg - Text/HTML to display while loading, default "Loading".
         * ... {string} submitAccessKey - Access key for submitting.
         * ... {string} cancelAccessKey - Access key for canceling.
         * ... {function(Object): (string|function(number, string): string)} deleteConfirmation - HTML to display in popup to confirm deletion.
         * ... {function(string): (selector|jQuery|Element)} fieldFocusSelector - Element to focus on given a name.
         * ... {AJS.RestfulTable.EntryModel} model - Backbone model representing a row, default AJS.RestfulTable.EntryModel.
         * ... {Backbone.Collection} Collection - Backbone collection representing the entire table, default Backbone.Collection.
         */
        initialize: function (options) {

            var instance = this;


            // combine default and user options
            instance.options = $.extend(true, instance._getDefaultOptions(options), options);

            // Prefix events for this instance with this id.
            instance.id = this.options.id;

            // faster lookup
            instance._event = AJS.RestfulTable.Events;
            instance.classNames = AJS.RestfulTable.ClassNames;
            instance.dataKeys = AJS.RestfulTable.DataKeys;

            // shortcuts to popular elements
            this.$table = $(options.el)
                    .addClass(this.classNames.RESTFUL_TABLE)
                    .addClass(this.classNames.ALLOW_HOVER)
                    .addClass('aui')
                    .addClass(instance.classNames.LOADING);

            this.$table.wrapAll("<form class='aui' action='#' />");

            this.$thead = $('<thead/>');
            this.$theadRow = $('<tr />').appendTo(this.$thead);
            this.$tbody = $('<tbody/>');

            if (!this.$table.length) {
                throw new Error('AJS.RestfulTable: Init failed! The table you have specified [' + this.$table.selector + '] cannot be found.');
            }

            if (!this.options.columns) {
                throw new Error("AJS.RestfulTable: Init failed! You haven't provided any columns to render.");
            }

            // Let user know the table is loading
            this.showGlobalLoading();

            $.each(this.options.columns, function (i, column) {
                var header = $.isFunction(column.header) ? column.header() : column.header;
                if (typeof header === 'undefined') {
                    AJS.warn('You have not specified [header] for column [' + column.id + ']. Using id for now...');
                    header = column.id;
                }

                instance.$theadRow.append('<th>' + header + '</th>');
            });

            // columns for submit buttons and loading indicator used when editing
            instance.$theadRow.append('<th></th><th></th>');

            // create a new Backbone collection to represent rows (http://documentcloud.github.com/backbone/#Collection)
            this._models = this._createCollection();

            // shortcut to the class we use to create rows
            this._rowClass = this.options.views.row;

            this.editRows = []; // keep track of rows that are being edited concurrently

            this.$table.closest('form').submit(function (e) {
                if (instance.focusedRow) {
                    // Delegates saving of row. See AJS.RestfulTable.EditRow.submit
                    instance.focusedRow.trigger(instance._event.SAVE);
                }
                e.preventDefault();
            });

            if (this.options.allowReorder) {

                // Add allowance for another cell to the <thead>
                this.$theadRow.prepend('<th />');

                // Allow drag and drop reordering of rows
                this.$tbody.sortable({
                    handle: '.' + this.classNames.DRAG_HANDLE,
                    helper: function (e, elt) {
                        var helper = $('<div/>').attr('class', elt.attr('class')).addClass(instance.classNames.MOVEABLE);
                        elt.children().each(function (i) {
                            var $td = $(this);

                            // .offsetWidth/.outerWidth() is broken in webkit for tables, so we do .clientWidth + borders
                            // Need to coerce the border-left-width to an in because IE - http://bugs.jquery.com/ticket/10855
                            var borderLeft = parseInt(0 + $td.css('border-left-width'), 10);
                            var borderRight = parseInt(0 + $td.css('border-right-width'), 10);
                            var width = $td[0].clientWidth + borderLeft + borderRight;

                            helper.append($('<div/>').html($td.html()).attr('class', $td.attr('class')).width(width));
                        });

                        helper = $("<div class='aui-restfultable-readonly'/>").append(helper); // Basically just to get the styles.
                        helper.css({left: elt.offset().left}); // To align with the other table rows, since we've locked scrolling on x.
                        helper.appendTo(document.body);

                        return helper;
                    },
                    start: function (event, ui) {
                        var cachedHeight = ui.helper[0].clientHeight;
                        var $this = ui.placeholder.find('td');

                        // Make sure that when we start dragging widths do not change
                        ui.item
                                .addClass(instance.classNames.MOVEABLE)
                                .children().each(function (i) {
                                    $(this).width($this.eq(i).width());
                                });

                        // Create a <td> to add to the placeholder <tr> to inherit CSS styles.
                        var td = '<td colspan="' + instance.getColumnCount() + '">&nbsp;</td>';

                        ui.placeholder.html(td).css({
                            height: cachedHeight,
                            visibility: 'visible'
                        });

                        // Stop hover effects etc from occuring as we move the mouse (while dragging) over other rows
                        instance.getRowFromElement(ui.item[0]).trigger(instance._event.MODAL);
                    },
                    stop: function (event, ui) {
                        if (AJS.$(ui.item[0]).is(':visible')) {
                            ui.item
                                    .removeClass(instance.classNames.MOVEABLE)
                                    .children().attr('style', '');

                            ui.placeholder.removeClass(instance.classNames.ROW);

                            // Return table to a normal state
                            instance.getRowFromElement(ui.item[0]).trigger(instance._event.MODELESS);
                        }
                    },
                    update: function (event, ui) {

                        var context = {
                            row: instance.getRowFromElement(ui.item[0]),
                            item: ui.item,
                            nextItem: ui.item.next(),
                            prevItem: ui.item.prev()
                        };

                        instance.move(context);
                    },
                    axis: 'y',
                    delay: 0,
                    containment: 'document',
                    cursor: 'move',
                    scroll: true,
                    zIndex: 8000
                });

                // Prevent text selection while reordering.
                this.$tbody.bind('selectstart mousedown', function (event) {
                    return !$(event.target).is('.' + instance.classNames.DRAG_HANDLE);
                });
            }


            if (this.options.allowCreate !== false) {

                // Create row responsible for adding new entries ...
                this._createRow = new this.options.views.editRow({
                    columns: this.options.columns,
                    isCreateRow: true,
                    model: this.options.model.extend({
                        url: function () {
                            return instance.options.resources.self;
                        }
                    }),
                    cancelAccessKey: this.options.cancelAccessKey,
                    submitAccessKey: this.options.submitAccessKey,
                    allowReorder: this.options.allowReorder,
                    fieldFocusSelector: this.options.fieldFocusSelector
                })
                        .bind(this._event.CREATED, function (values) {
                            if ((instance.options.addPosition == undefined && instance.options.createPosition === 'bottom')
                                || instance.options.addPosition === 'bottom') {
                                instance.addRow(values);
                            }
                            else {
                                instance.addRow(values, 0);
                            }
                        })
                        .bind(this._event.VALIDATION_ERROR, function () {
                            this.trigger(instance._event.FOCUS);
                        })
                        .render({
                            errors: {},
                            values: {}
                        });

                // ... and appends it as the first row
                this.$create = $('<tbody class="' + this.classNames.CREATE + '" />')
                        .append(this._createRow.el);

                // Manage which row has focus
                this._applyFocusCoordinator(this._createRow);

                // focus create row
                this._createRow.trigger(this._event.FOCUS);
            }

            // when a model is removed from the collection, remove it from the viewport also
            this._models.bind('remove', function (model) {
                $.each(instance.getRows(), function (i, row) {
                    if (row.model === model) {
                        if (row.hasFocus() && instance._createRow) {
                            instance._createRow.trigger(instance._event.FOCUS);
                        }
                        instance.removeRow(row);
                    }
                });
            });

            this.fetchInitialResources();
        },

        fetchInitialResources: function () {
            var instance = this;
            if ($.isFunction(this.options.resources.all)) {
                this.options.resources.all(function (entries) {
                    instance.populate(entries);
                });
            }
            else {
                $.get(this.options.resources.all, function (entries) {
                    instance.populate(entries);
                });
            }
        },

        move: function (context) {

            var instance = this;

            var createRequest = function (afterElement) {
                if (!afterElement.length) {
                    return {
                        position: 'First'
                    };
                }
                else {
                    var afterModel = instance.getRowFromElement(afterElement).model;
                    return {
                        after: afterModel.url()
                    };
                }
            };

            if (context.row) {

                var data = instance.options.reverseOrder ? createRequest(context.nextItem) : createRequest(context.prevItem);

                $.ajax({
                    url: context.row.model.url() + '/move',
                    type: 'POST',
                    dataType: 'json',
                    contentType: 'application/json',
                    data: JSON.stringify(data),
                    complete: function () {
                        // hides loading indicator (spinner)
                        context.row.hideLoading();
                    },
                    success: function (xhr) {
                        AJS.triggerEvtForInst(instance._event.REORDER_SUCCESS, instance, [xhr]);
                    },
                    error: function (xhr) {
                        var responseData = $.parseJSON(xhr.responseText || xhr.data);
                        AJS.triggerEvtForInst(instance._event.SERVER_ERROR, instance, [responseData, xhr, this]);
                    }
                });

                // shows loading indicator (spinner)
                context.row.showLoading();
            }
        },

        _createCollection: function () {
            var instance = this;

            // create a new Backbone collection to represent rows (http://documentcloud.github.com/backbone/#Collection)
            var RowsAwareCollection = this.options.Collection.extend({
                // Force the collection to re-sort itself. You don't need to call this under normal
                // circumstances, as the set will maintain sort order as each item is added.
                sort:function (options) {
                    options || (options = {});
                    if (!this.comparator) {
                        throw new Error('Cannot sort a set without a comparator');
                    }
                    this.tableRows = instance.getRows();
                    this.models = this.sortBy(this.comparator);
                    this.tableRows = undefined;
                    if (!options.silent) {
                        this.trigger('refresh', this, options);
                    }
                    return this;
                },
                remove:function (models, options) {
                    this.tableRows = instance.getRows();
                    Backbone.Collection.prototype.remove.apply(this, arguments);
                    this.tableRows = undefined;
                    return this;
                }
            });

            return new RowsAwareCollection([], {
                comparator:function (row) {
                    // sort models in collection based on dom ordering
                    var index;
                    $.each(this.tableRows !== undefined ? this.tableRows : instance.getRows(), function (i) {
                        if (this.model.id === row.id) {
                            index = i;
                            return false;
                        }
                    });
                    return index;
                }
            });
        },

        /**
         * Refreshes table with entries
         *
         * @param entries
         */
        populate: function (entries) {

            if (this.options.reverseOrder) {
                entries.reverse();
            }

            this.hideGlobalLoading();
            if (entries && entries.length) {
                // Empty the models collection
                this._models.reset([], {silent: true});
                // Add all the entries to collection and render them
                this.renderRows(entries);
                // show message to user if we have no entries
                if (this.isEmpty()) {
                    this.showNoEntriesMsg();
                }
            }
            else {
                this.showNoEntriesMsg();
            }

            // Ok, lets let everyone know that we are done...
            this.$table
                    .append(this.$thead);

            if (this.options.createPosition === 'bottom') {
                this.$table.append(this.$tbody)
                        .append(this.$create);
            }
            else {
                this.$table
                        .append(this.$create)
                        .append(this.$tbody);
            }

            this.$table.removeClass(this.classNames.LOADING)
                    .trigger(this._event.INITIALIZED, [this]);

            AJS.triggerEvtForInst(this._event.INITIALIZED, this, [this]);

            if (this.options.autoFocus) {
                this.$table.find(':input:text:first').focus(); // set focus to first field
            }
        },

        /**
         * Shows loading indicator and text
         *
         * @return {AJS.RestfulTable}
         */
        showGlobalLoading: function () {

            if (!this.$loading) {
                this.$loading =  $('<div class="aui-restfultable-init">' + AJS.RestfulTable.throbber() +
                        '<span class="aui-restfultable-loading">' + this.options.loadingMsg + '</span></div>');
            }
            if (!this.$loading.is(':visible')) {
                this.$loading.insertAfter(this.$table);
            }

            return this;
        },

        /**
         * Hides loading indicator and text
         * @return {AJS.RestfulTable}
         */
        hideGlobalLoading: function () {
            if (this.$loading) {
                this.$loading.remove();
            }
            return this;
        },


        /**
         * Adds row to collection and renders it
         *
         * @param {Object} values
         * @param {number} index
         * @return {AJS.RestfulTable}
         */
        addRow: function (values, index) {

            var view,
                    model;

            if (!values.id) {
                throw new Error('AJS.RestfulTable.addRow: to add a row values object must contain an id. ' +
                        'Maybe you are not returning it from your restend point?' +
                        'Recieved:' + JSON.stringify(values));
            }

            model = new this.options.model(values);


            view = this._renderRow(model, index);

            this._models.add(model);
            this.removeNoEntriesMsg();

            // Let everyone know we added a row
            AJS.triggerEvtForInst(this._event.ROW_ADDED, this, [view, this]);
            return this;
        },

        /**
         * Provided a view, removes it from display and backbone collection
         *
         * @param row {AJS.RestfulTable.Row}
         */
        removeRow: function (row) {

            this._models.remove(row.model);
            row.remove();

            if (this.isEmpty()) {
                this.showNoEntriesMsg();
            }

            // Let everyone know we removed a row
            AJS.triggerEvtForInst(this._event.ROW_REMOVED, this, [row, this]);
        },

        /**
         * Is there any entries in the table
         *
         * @return {Boolean}
         */
        isEmpty: function () {
            return this._models.length === 0;
        },

        /**
         * Gets all models
         *
         * @return {Backbone.Collection}
         */
        getModels: function () {
            return this._models;
        },

        /**
         * Gets table body
         *
         * @return {jQuery}
         */
        getTable: function () {
            return this.$table;
        },

        /**
         * Gets table body
         *
         * @return {jQuery}
         */
        getTableBody: function () {
            return this.$tbody;
        },

        /**
         * Gets create Row
         *
         * @return {?AJS.RestfulTable.EditRow}
         */
        getCreateRow: function () {
            return this._createRow;
        },

        /**
         * Gets the number of table columns, accounting for the number of
         * additional columns added by RestfulTable itself
         * (such as the drag handle column, buttons and actions columns)
         *
         * @return {Number}
         */
        getColumnCount: function () {
            var staticFieldCount = 2; // accounts for the columns allocated to submit buttons and loading indicator
            if (this.allowReorder) {
                ++staticFieldCount;
            }
            return this.options.columns.length + staticFieldCount;
        },

        /**
         * Get the AJS.RestfulTable.Row that corresponds to the given <tr> element.
         *
         * @param {HTMLElement} tr
         * @return {?AJS.RestfulTable.Row}
         */
        getRowFromElement: function (tr) {
            return $(tr).data(this.dataKeys.ROW_VIEW);
        },

        /**
         * Shows message {options.noEntriesMsg} to the user if there are no entries
         *
         * @return {AJS.RestfulTable}
         */
        showNoEntriesMsg: function () {

            if (this.$noEntries) {
                this.$noEntries.remove();
            }

            this.$noEntries = $('<tr>')
                    .addClass(this.classNames.NO_ENTRIES)
                    .append($('<td>')
                    .attr('colspan', this.getColumnCount())
                    .text(this.options.noEntriesMsg)
            )
                    .appendTo(this.$tbody);

            return this;
        },

        /**
         * Removes message {options.noEntriesMsg} to the user if there ARE entries
         *
         * @return {AJS.RestfulTable}
         */
        removeNoEntriesMsg: function () {
            if (this.$noEntries && this._models.length > 0) {
                this.$noEntries.remove();
            }
            return this;
        },

        /**
         * Gets the AJS.RestfulTable.Row from their associated <tr> elements
         *
         * @return {Array<AJS.RestfulTable.Row>}
         */
        getRows: function () {

            var instance = this,
                    views = [];

            this.$tbody.find('.' + this.classNames.READ_ONLY).each(function () {

                var $row = $(this),
                        view = $row.data(instance.dataKeys.ROW_VIEW);

                if (view) {
                    views.push(view);
                }
            });

            return views;
        },

        /**
         * Appends entry to end or specified index of table
         *
         * @param {AJS.RestfulTable.EntryModel} model
         * @param index
         * @return {jQuery}
         */
        _renderRow: function (model, index) {

            var instance = this,
                    $rows = this.$tbody.find('.' + this.classNames.READ_ONLY),
                    $row,
                    view;

            view = new this._rowClass({
                model: model,
                columns: this.options.columns,
                allowEdit: this.options.allowEdit,
                allowDelete: this.options.allowDelete,
                allowReorder: this.options.allowReorder,
                deleteConfirmation: this.options.deleteConfirmation
            });

            this.removeNoEntriesMsg();

            view.bind(this._event.ROW_EDIT, function (field) {
                AJS.triggerEvtForInst(this._event.EDIT_ROW, {}, [this, instance]);
                instance.edit(this, field);
            });

            $row = view.render().$el;

            if (index !== -1) {

                if (typeof index === 'number' && $rows.length !== 0) {
                    $row.insertBefore($rows[index]);
                }
                else {
                    this.$tbody.append($row);
                }
            }

            $row.data(this.dataKeys.ROW_VIEW, view);

            // deactivate all rows - used in the cases, such as opening a dropdown where you do not want the table editable
            // or any interactions
            view.bind(this._event.MODAL, function () {
                instance.$table.removeClass(instance.classNames.ALLOW_HOVER);
                instance.$tbody.sortable('disable');
                $.each(instance.getRows(), function () {
                    if (!instance.isRowBeingEdited(this)) {
                        this.delegateEvents({}); // clear all events
                    }
                });
            });

            // activate all rows - used in the cases, such as opening a dropdown where you do not want the table editable
            // or any interactions
            view.bind(this._event.MODELESS, function () {
                instance.$table.addClass(instance.classNames.ALLOW_HOVER);
                instance.$tbody.sortable('enable');
                $.each(instance.getRows(), function () {
                    if (!instance.isRowBeingEdited(this)) {
                        this.delegateEvents(); // rebind all events
                    }
                });
            });

            // ensure that when this row is focused no other are
            this._applyFocusCoordinator(view);

            this.trigger(this._event.ROW_INITIALIZED, view);

            return view;
        },

        /**
         * Returns if the row is edit mode or note
         *
         * @param row {AJS.RestfulTable.Row} - read-only row to check if being edited
         * @return {Boolean}
         */
        isRowBeingEdited: function (row) {

            var isBeingEdited = false;

            $.each(this.editRows, function () {
                if (this.el === row.el) {
                    isBeingEdited = true;
                    return false;
                }
            });

            return isBeingEdited;
        },

        /**
         * Ensures that when supplied view is focused no others are
         *
         * @param {Backbone.View} view
         * @return {AJS.RestfulTable}
         */
        _applyFocusCoordinator: function (view) {

            var instance = this;

            if (!view.hasFocusBound) {

                view.hasFocusBound = true;

                view.bind(this._event.FOCUS, function () {
                    if (instance.focusedRow && instance.focusedRow !== view) {
                        instance.focusedRow.trigger(instance._event.BLUR);
                    }
                    instance.focusedRow = view;
                    if (view instanceof AJS.RestfulTable.Row && instance._createRow) {
                        instance._createRow.enable();
                    }
                });
            }

            return this;
        },

        /**
         * Remove specified row from collection holding rows being concurrently edited
         *
         * @param {AJS.RestfulTable.EditRow} editView
         * @return {AJS.RestfulTable}
         */
        _removeEditRow: function (editView) {
            var index = $.inArray(editView, this.editRows);
            this.editRows.splice(index, 1);
            return this;
        },

        /**
         * Focuses last row still being edited or create row (if it exists)
         *
         * @return {AJS.RestfulTable}
         */
        _shiftFocusAfterEdit: function () {

            if (this.editRows.length > 0) {
                this.editRows[this.editRows.length - 1].trigger(this._event.FOCUS);
            }
            else if (this._createRow) {
                this._createRow.trigger(this._event.FOCUS);
            }

            return this;
        },

        /**
         * Evaluate if we save row when we blur. We can only do this when there is one row being edited at a time, otherwise
         * it causes an infinite loop JRADEV-5325
         *
         * @return {boolean}
         */
        _saveEditRowOnBlur: function () {
            return this.editRows.length <= 1;
        },

        /**
         * Dismisses rows being edited concurrently that have no changes
         */
        dismissEditRows: function () {
            var instance = this;
            $.each(this.editRows, function () {
                if (!this.hasUpdates()) {
                    this.trigger(instance._event.FINISHED_EDITING);
                }
            });
        },

        /**
         * Converts readonly row to editable view
         *
         * @param {Backbone.View} row
         * @param {String} field - field name to focus
         * @return {Backbone.View} editRow
         */
        edit: function (row, field) {

            var instance = this,
                    editRow = new this.options.views.editRow({
                        el: row.el,
                        columns: this.options.columns,
                        isUpdateMode: true,
                        allowReorder: this.options.allowReorder,
                        fieldFocusSelector: this.options.fieldFocusSelector,
                        model: row.model,
                        cancelAccessKey: this.options.cancelAccessKey,
                        submitAccessKey: this.options.submitAccessKey
                    }),
                    values = row.model.toJSON();
            values.update = true;
            editRow.render({
                errors: {},
                update: true,
                values: values
            })
                    .bind(instance._event.UPDATED, function (model, focusUpdated) {
                        instance._removeEditRow (this);
                        this.unbind();
                        row.render().delegateEvents(); // render and rebind events
                        row.trigger(instance._event.UPDATED); // trigger blur fade out
                        if (focusUpdated !== false) {
                            instance._shiftFocusAfterEdit();
                        }
                    })
                    .bind(instance._event.VALIDATION_ERROR, function () {
                        this.trigger(instance._event.FOCUS);
                    })
                    .bind(instance._event.FINISHED_EDITING, function () {
                        instance._removeEditRow(this);
                        row.render().delegateEvents();
                        this.unbind();  // avoid any other updating, blurring, finished editing, cancel events being fired
                    })
                    .bind(instance._event.CANCEL, function () {
                        instance._removeEditRow(this);
                        this.unbind();  // avoid any other updating, blurring, finished editing, cancel events being fired
                        row.render().delegateEvents(); // render and rebind events
                        instance._shiftFocusAfterEdit();
                    })
                    .bind(instance._event.BLUR, function () {
                        instance.dismissEditRows(); // dismiss edit rows that have no changes
                        if (instance._saveEditRowOnBlur()) {
                            this.trigger(instance._event.SAVE, false);  // save row, which if successful will call the updated event above
                        }
                    });

            // Ensure that if focus is pulled to another row, we blur the edit row
            this._applyFocusCoordinator(editRow);

            // focus edit row, which has the flow on effect of blurring current focused row
            editRow.trigger(instance._event.FOCUS, field);

            // disables form fields
            if (instance._createRow) {
                instance._createRow.disable();
            }

            this.editRows.push(editRow);

            return editRow;
        },


        /**
         * Renders all specified rows
         *
         * @param rows {Array<Backbone.Model>} array of objects describing Backbone.Model's to render
         * @return {AJS.RestfulTable}
         */
        renderRows: function (rows) {
            var comparator = this._models.comparator, els = [];

            this._models.comparator = undefined; // disable temporarily, assume rows are sorted

            var models = _.map(rows, function (row) {
                var model = new this.options.model(row);
                els.push(this._renderRow(model, -1).el);
                return model;
            }, this);
            this._models.add(models, {silent:true});

            this._models.comparator = comparator;

            this.removeNoEntriesMsg();

            this.$tbody.append(els);

            return this;
        },

        /**
         * Gets default options
         *
         * @param {Object} options
         */
        _getDefaultOptions: function (options) {
            return {
                model: options.model || AJS.RestfulTable.EntryModel,
                allowEdit: true,
                views: {
                    editRow: AJS.RestfulTable.EditRow,
                    row: AJS.RestfulTable.Row
                },
                Collection: Backbone.Collection.extend({
                    url: options.resources.self,
                    model: options.model || AJS.RestfulTable.EntryModel
                }),
                allowReorder: false,
                fieldFocusSelector: function (name) {
                    return ':input[name=' + name + '], #' + name;
                },
                loadingMsg: options.loadingMsg || "Loading"
            };
        }

    });

    AJS.RestfulTable.throbber = function throbberHtml () {
        return '<span class="aui-restfultable-throbber"></span>';
    };

    AJS.RestfulTable.throbber = function throbberHtml () {
        return '<span class="aui-restfultable-throbber"></span>';
    };

    // jQuery data keys (http://api.jquery.com/jQuery.data/)
    AJS.RestfulTable.DataKeys = {
        ENABLED_SUBMIT: 'enabledSubmit',
        ROW_VIEW: 'RestfulTable_Row_View'
    };

    // CSS style classes. DON'T hard code
    AJS.RestfulTable.ClassNames = {
        NO_VALUE: 'aui-restfultable-editable-no-value',
        NO_ENTRIES: 'aui-restfultable-no-entires',
        RESTFUL_TABLE: 'aui-restfultable',
        ROW: 'aui-restfultable-row',
        READ_ONLY: 'aui-restfultable-readonly',
        ACTIVE: 'aui-restfultable-active',
        ALLOW_HOVER: 'aui-restfultable-allowhover',
        FOCUSED: 'aui-restfultable-focused',
        MOVEABLE: 'aui-restfultable-movable',
        DISABLED: 'aui-restfultable-disabled',
        SUBMIT: 'aui-restfultable-submit',
        CANCEL: 'aui-restfultable-cancel',
        EDIT_ROW: 'aui-restfultable-editrow',
        CREATE: 'aui-restfultable-create',
        DRAG_HANDLE: 'aui-restfultable-draghandle',
        ORDER: 'aui-restfultable-order',
        EDITABLE: 'aui-restfultable-editable',
        ERROR: 'error',
        DELETE: 'aui-restfultable-delete',
        LOADING: 'loading'
    };

    // Custom events
    AJS.RestfulTable.Events = {

        // AJS events
        REORDER_SUCCESS: 'RestfulTable.reorderSuccess',
        ROW_ADDED: 'RestfulTable.rowAdded',
        ROW_REMOVED: 'RestfulTable.rowRemoved',
        EDIT_ROW: 'RestfulTable.switchedToEditMode',
        SERVER_ERROR: 'RestfulTable.serverError',

        // backbone events
        CREATED: 'created',
        UPDATED: 'updated',
        FOCUS: 'focus',
        BLUR: 'blur',
        SUBMIT: 'submit',
        SAVE: 'save',
        MODAL: 'modal',
        MODELESS: 'modeless',
        CANCEL: 'cancel',
        CONTENT_REFRESHED: 'contentRefreshed',
        RENDER: 'render',
        FINISHED_EDITING: 'finishedEditing',
        VALIDATION_ERROR: 'validationError',
        SUBMIT_STARTED: 'submitStarted',
        SUBMIT_FINISHED: 'submitFinished',
        INITIALIZED: 'initialized',
        ROW_INITIALIZED: 'rowInitialized',
        ROW_EDIT: 'editRow'
    };

})(AJS.$);
;
;
/* module-key = 'com.atlassian.auiplugin:aui-experimental-restfultable', location = 'js/experimental-restfultable/restfultable.entrymodel.js' */
(function ($) {

    /**
     * A class provided to fill some gaps with the out of the box Backbone.Model class. Most notiably the inability
     * to send ONLY modified attributes back to the server.
     *
     * @class EntryModel
     * @namespace AJS.RestfulTable
     */
    AJS.RestfulTable.EntryModel = Backbone.Model.extend({


        sync: function (method, model, options) {
            var instance = this;
            var oldError = options.error;

            options.error = function (xhr) {
                instance._serverErrorHandler(xhr, this);
                if (oldError) {
                    oldError.apply(this, arguments);
                }
            };

            return Backbone.sync.apply(Backbone, arguments);
        },

        /**
         * Overrides default save handler to only save (send to server) attributes that have changed.
         * Also provides some default error handling.
         *
         * @override
         * @param attributes
         * @param options
         */
        save: function (attributes, options) {


            options = options || {};

            var instance = this,
                Model,
                syncModel,
                error = options.error, // we override, so store original
                success = options.success;


            // override error handler to provide some defaults
            options.error = function (model, xhr) {

                var data = $.parseJSON(xhr.responseText || xhr.data);

                // call original error handler
                if (error) {
                    error.call(instance, instance, data, xhr);
                }
            };

            // if it is a new model, we don't have to worry about updating only changed attributes because they are all new
            if (this.isNew()) {

                // call super
                Backbone.Model.prototype.save.call(this, attributes, options);

                // only go to server if something has changed
            }
            else if (attributes) {

                // create temporary model
                Model = AJS.RestfulTable.EntryModel.extend({
                    url: this.url()
                });

                syncModel = new Model({
                    id: this.id
                });

                syncModel.save = Backbone.Model.prototype.save;

                options.success = function (model, xhr) {

                    // update original model with saved attributes
                    instance.clear().set(model.toJSON());

                    // call original success handler
                    if (success) {
                        success.call(instance, instance, xhr);
                    }
                };

                // update temporary model with the changed attributes
                syncModel.save(attributes, options);
            }
        },

        /**
         * Destroys the model on the server. We need to override the default method as it does not support sending of
         * query paramaters.
         *
         * @override
         * @param options
         * ... {function} success - Server success callback
         * ... {function} error - Server error callback
         * ... {object} data
         *
         * @return AJS.RestfulTable.EntryModel
         */
        destroy: function (options) {

            options = options || {};

            var instance = this,
                url = this.url(),
                data;

            if (options.data) {
                data = $.param(options.data);
            }

            if (data !== '') {
                // we need to add to the url as the data param does not work for jQuery DELETE requests
                url = url + '?' + data;
            }

            $.ajax({
                url: url,
                type: 'DELETE',
                dataType: 'json',
                contentType: 'application/json',
                success: function (data) {
                    if (instance.collection){
                        instance.collection.remove(instance);
                    }
                    if (options.success) {
                        options.success.call(instance, data);
                    }
                },
                error: function (xhr) {
                    instance._serverErrorHandler(xhr, this);
                    if (options.error) {
                        options.error.call(instance, xhr);
                    }
                }
            });

            return this;
        },


        /**
         * A more complex lookup for changed attributes then default backbone one.
         *
         * @param attributes
         */
        changedAttributes: function (attributes) {

            var changed = {},
                current = this.toJSON();

            $.each(attributes, function (name, value) {

                if (!current[name]) {
                    if (typeof value === 'string') {
                        if ($.trim(value) !== '') {
                            changed[name] = value;
                        }
                    }
                    else if ($.isArray(value)) {
                        if (value.length !== 0) {
                            changed[name] = value;
                        }
                    }
                    else {
                        changed[name] = value;
                    }
                }
                else if (current[name] && current[name] !== value) {

                    if (typeof value === 'object') {
                        if (!_.isEqual(value, current[name])) {
                            changed[name] = value;
                        }
                    }
                    else {
                        changed[name] = value;
                    }
                }
            });

            if (!_.isEmpty(changed)) {
                this.addExpand(changed);
                return changed;
            }
        },

        /**
         * Useful point to override if you always want to add an expand to your rest calls.
         *
         * @param changed attributes that have already changed
         */
        addExpand: function (changed) {},

        /**
         * Throws a server error event unless user input validation error (status 400)
         *
         * @param xhr
         */
        _serverErrorHandler: function (xhr, ajaxOptions) {
            var data;
            if (xhr.status !== 400) {
                data = $.parseJSON(xhr.responseText || xhr.data);
                AJS.triggerEvtForInst(AJS.RestfulTable.Events.SERVER_ERROR, this, [data, xhr, ajaxOptions]);
            }
        },

        /**
         * Fetches values, with some generic error handling
         *
         * @override
         * @param options
         */
        fetch: function (options) {

            options = options || {};

            this.clear(); // clear the model, so we do not merge the old with the new

            // call super
            Backbone.Model.prototype.fetch.call(this, options);
        }
    });

})(AJS.$);
;
;
/* module-key = 'com.atlassian.auiplugin:aui-experimental-restfultable', location = 'js/experimental-restfultable/restfultable.editrow.js' */
(function ($) {

    /**
     * An abstract class that gives the required behaviour for the creating and editing entries. Extend this class and pass
     * it as the {views.row} property of the options passed to AJS.RestfulTable in construction.
     *
     * @class EditRow
     * @namespace AJS.RestfulTable
     */
    AJS.RestfulTable.EditRow = Backbone.View.extend({

        tagName: 'tr',

        // delegate events
        events: {
            'focusin': '_focus',
            'click': '_focus',
            'keyup': '_handleKeyUpEvent'
        },

        /**
         * @constructor
         * @param {Object} options
         */
        initialize: function (options) {

            this.$el = $(this.el);

            // faster lookup
            this._event = AJS.RestfulTable.Events;
            this.classNames = AJS.RestfulTable.ClassNames;
            this.dataKeys = AJS.RestfulTable.DataKeys;
            this.columns = options.columns;
            this.isCreateRow = options.isCreateRow;

            this.allowReorder = options.allowReorder;

            // Allow cancelling an edit with support for setting a new element.
            this.events['click .' + this.classNames.CANCEL] = '_cancel';
            this.delegateEvents();

            if (options.isUpdateMode) {
                this.isUpdateMode = true;
            }
            else {
                this._modelClass = options.model;
                this.model = new this._modelClass();
            }

            this.fieldFocusSelector = options.fieldFocusSelector;

            this.bind(this._event.CANCEL, function () {
                this.disabled = true;
            })
                    .bind(this._event.SAVE, function (focusUpdated) {
                        if (!this.disabled) {
                            this.submit(focusUpdated);
                        }
                    })
                    .bind(this._event.FOCUS, function (name) {
                        this.focus(name);
                    })
                    .bind(this._event.BLUR, function () {
                        this.$el.removeClass(this.classNames.FOCUSED);
                        this.disable();
                    })
                    .bind(this._event.SUBMIT_STARTED, function () {
                        this._submitStarted();
                    })
                    .bind(this._event.SUBMIT_FINISHED, function () {
                        this._submitFinished();
                    });
        },

        /**
         * Renders default cell contents
         *
         * @param data
         */
        defaultColumnRenderer: function (data) {
            if (data.allowEdit !== false) {
                return $("<input type='text' />")
                        .addClass('text')
                        .attr({
                            name: data.name,
                            value: data.value
                        });
            }
            else if (data.value) {
                return document.createTextNode(data.value);
            }
        },

        /**
         * Renders drag handle
         * @return jQuery
         */
        renderDragHandle: function () {
            return '<span class="' + this.classNames.DRAG_HANDLE + '"></span></td>';

        },

        /**
         * Executes cancel event if ESC is pressed
         *
         * @param {Event} e
         */
        _handleKeyUpEvent: function (e) {
            if (e.keyCode === 27) {
                this.trigger(this._event.CANCEL);
            }
        },

        /**
         * Fires cancel event
         *
         * @param {Event} e
         * @return AJS.RestfulTable.EditRow
         */
        _cancel: function (e) {
            this.trigger(this._event.CANCEL);
            e.preventDefault();
            return this;
        },


        /**
         * Disables events/fields and adds safe guard against double submitting
         *
         * @return AJS.RestfulTable.EditRow
         */
        _submitStarted: function () {
            this.submitting = true;
            this.showLoading()
                    .disable()
                    .delegateEvents({});

            return this;
        },

        /**
         * Enables events & fields
         *
         * @return AJS.RestfulTable.EditRow
         */
        _submitFinished: function () {
            this.submitting = false;
            this.hideLoading()
                    .enable()
                    .delegateEvents(this.events);

            return this;
        },

        /**
         * Handles dom focus event, by only focusing row if it isn't already
         *
         * @param {Event} e
         * @return AJS.RestfulTable.EditRow
         */
        _focus: function (e) {
            if (!this.hasFocus()) {
                this.trigger(this._event.FOCUS, e.target.name);
            }
            return this;
        },


        /**
         * Returns true if row has focused class
         *
         * @return Boolean
         */
        hasFocus: function () {
            return this.$el.hasClass(this.classNames.FOCUSED);
        },

        /**
         * Focus specified field (by name or id - first argument), first field with an error or first field (DOM order)
         *
         * @param name
         * @return AJS.RestfulTable.EditRow
         */
        focus: function (name) {

            var $focus,
                    $error;

            this.enable();

            if (name) {
                $focus = this.$el.find(this.fieldFocusSelector(name));
            }
            else {

                $error = this.$el.find(this.classNames.ERROR + ':first');

                if ($error.length === 0) {
                    $focus = this.$el.find(':input:text:first');
                }
                else {
                    $focus = $error.parent().find(':input');
                }
            }

            this.$el.addClass(this.classNames.FOCUSED);

            //            if (this.$el.find(":input").isInView()) {
            $focus.focus().trigger('select');
            //            }

            return this;
        },

        /**
         * Disables all fields
         *
         * @return AJS.RestfulTable.EditRow
         */
        disable: function () {

            var $replacementSubmit,
                    $submit;

            // firefox does not allow you to submit a form if there are 2 or more submit buttons in a form, even if all but
            // one is disabled. It also does not let you change the type="submit' to type="button". Therfore he lies the hack.
            if ($.browser.mozilla) {

                $submit = this.$el.find(':submit');

                if ($submit.length) {

                    $replacementSubmit = $("<input type='submit' class='" + this.classNames.SUBMIT + "' />")
                            .addClass($submit.attr('class'))
                            .val($submit.val())
                            .data(this.dataKeys.ENABLED_SUBMIT, $submit);

                    $submit.replaceWith($replacementSubmit);
                }
            }

            this.$el.addClass(this.classNames.DISABLED)
                    .find(':submit')
                    .attr('disabled', 'disabled');

            return this;
        },

        /**
         * Enables all fields
         *
         * @return AJS.RestfulTable.EditRow
         */
        enable: function () {

            var $placeholderSubmit,
                    $submit;

            // firefox does not allow you to submit a form if there are 2 or more submit buttons in a form, even if all but
            // one is disabled. It also does not let you change the type="submit' to type="button". Therfore he lies the hack.
            if ($.browser.mozilla) {
                $placeholderSubmit = this.$el.find(this.classNames.SUBMIT),
                        $submit = $placeholderSubmit.data(this.dataKeys.ENABLED_SUBMIT);

                if ($submit && $placeholderSubmit.length) {
                    $placeholderSubmit.replaceWith($submit);
                }
            }


            this.$el.removeClass(this.classNames.DISABLED)
                    .find(':submit')
                    .removeAttr('disabled');

            return this;
        },

        /**
         * Shows loading indicator
         * @return AJS.RestfulTable.EditRow
         */
        showLoading: function () {
            this.$el.addClass(this.classNames.LOADING);
            return this;
        },

        /**
         * Hides loading indicator
         * @return AJS.RestfulTable.EditRow
         */
        hideLoading: function () {
            this.$el.removeClass(this.classNames.LOADING);
            return this;
        },

        /**
         * If any of the fields have changed
         * @return {Boolean}
         */
        hasUpdates: function () {
            return !!this.mapSubmitParams(this.serializeObject());
        },

        /**
         * Serializes the view into model representation.
         * Default implementation uses simple jQuery plugin to serialize form fields into object
         * @return Object
         */
        serializeObject: function () {
            return this.$el.serializeObject();
        },

        mapSubmitParams: function (params) {
            return this.model.changedAttributes(params);
        },

        /**
         *
         * Handle submission of new entries and editing of old.
         *
         * @param {Boolean} focusUpdated - flag of whether to focus read-only view after succssful submission
         * @return AJS.RestfulTable.EditRow
         */
        submit: function (focusUpdated) {


            var instance = this,
                    values;

            // IE doesnt like it when the focused element is removed

            if (document.activeElement !== window) {
                $(document.activeElement).blur();
            }

            if (this.isUpdateMode) {

                values = this.mapSubmitParams(this.serializeObject()); // serialize form fields into JSON

                if (!values) {
                    return instance.trigger(instance._event.CANCEL);
                }
            }
            else {
                this.model.clear();
                values = this.mapSubmitParams(this.serializeObject()); // serialize form fields into JSON
            }

            this.trigger(this._event.SUBMIT_STARTED);

            /* Attempt to add to server model. If fail delegate to createView to render errors etc. Otherwise,
             add a new model to this._models and render a row to represent it. */
            this.model.save(values, {

                success: function () {

                    if (instance.isUpdateMode) {
                        instance.trigger(instance._event.UPDATED, instance.model, focusUpdated);
                    }
                    else {
                        instance.trigger(instance._event.CREATED, instance.model.toJSON());
                        instance.model = new instance._modelClass(); // reset

                        instance.render({errors: {}, values: {}}); // pulls in instance's model for create row
                        instance.trigger(instance._event.FOCUS);
                    }

                    instance.trigger(instance._event.SUBMIT_FINISHED);
                },

                error: function (model, data, xhr) {

                    if (xhr.status === 400) {

                        instance.renderErrors(data.errors)
                                .trigger(instance._event.VALIDATION_ERROR, data.errors);
                    }

                    instance.trigger(instance._event.SUBMIT_FINISHED);
                },

                silent: true
            });

            return this;
        },
        /**
         * Render an error message
         * @param msg
         * @return {jQuery}
         */
        renderError: function (name, msg) {
            return $('<div />').attr('data-field', name).addClass(this.classNames.ERROR).text(msg);
        },

        /**
         * Render and append error messages. The property name will be matched to the input name to determine which cell to
         * append the error message to. If this does not meet your needs please extend this method.
         *
         * @param errors
         */
        renderErrors: function (errors) {

            var instance = this;

            this.$('.' + this.classNames.ERROR).remove(); // avoid duplicates

            if (errors) {
                $.each(errors, function (name, msg) {
                    instance.$el.find("[name='" + name + "']")
                            .closest('td')
                            .append(instance.renderError(name, msg));
                });
            }

            return this;
        },


        /**
         * Handles rendering of row
         *
         * @param {Object} renderData
         * ... {Object} vales - Values of fields
         */
        render: function  (renderData) {

            var instance = this;

            this.$el.empty();

            if (this.allowReorder) {
                $('<td  class="' + this.classNames.ORDER + '" />').append(this.renderDragHandle()).appendTo(instance.$el);
            }

            $.each(this.columns, function (i, column) {

                var contents,
                        $cell,
                        value = renderData.values[column.id],
                        args = [
                            {name: column.id, value: value, allowEdit: column.allowEdit},
                            renderData.values,
                            instance.model
                        ];

                if (value) {
                    instance.$el.attr('data-' + column.id, value); // helper for webdriver testing
                }

                if (instance.isCreateRow && column.createView) {
                    // TODO AUI-1058 - The row's model should be guaranteed to be in the correct state by this point.
                    contents = new column.createView({
                        model: instance.model
                    }).render(args[0]);

                }
                else if (column.editView) {
                    contents = new column.editView({
                        model: instance.model
                    }).render(args[0]);
                }
                else {
                    contents = instance.defaultColumnRenderer.apply(instance, args);
                }

                $cell = $('<td />');

                if (typeof contents === 'object' && contents.done) {
                    contents.done(function (contents) {
                        $cell.append(contents);
                    });
                }
                else {
                    $cell.append(contents);
                }

                if (column.styleClass) {
                    $cell.addClass(column.styleClass);
                }

                $cell.appendTo(instance.$el);
            });

            this.$el
                    .append(this.renderOperations(renderData.update, renderData.values)) // add submit/cancel buttons
                    .addClass(this.classNames.ROW + ' ' + this.classNames.EDIT_ROW);

            this.trigger(this._event.RENDER, this.$el, renderData.values);

            this.$el.trigger(this._event.CONTENT_REFRESHED, [this.$el]);

            return this;
        },

        /**
         *
         * Gets markup for add/update and cancel buttons
         *
         * @param {Boolean} update
         */
        renderOperations: function (update) {

            var $operations = $('<td class="aui-restfultable-operations" />');

            if (update) {
                $operations.append($('<input class="aui-button" type="submit" />').attr({
                    accesskey: this.submitAccessKey,
                    value: "Update"
                }))
                    .append($('<a class="aui-button aui-button-link" href="#" />')
                        .addClass(this.classNames.CANCEL)
                        .text("Cancel")
                        .attr({
                            accesskey:  this.cancelAccessKey
                        }));
            }
            else {
                $operations.append($('<input class="aui-button" type="submit" />').attr({
                    accesskey: this.submitAccessKey,
                    value: "Add"
                }));
            }
            return $operations.add($('<td class="aui-restfultable-status" />').append(AJS.RestfulTable.throbber()));
        }
    });

})(AJS.$);
;
;
/* module-key = 'com.atlassian.auiplugin:aui-experimental-restfultable', location = 'js/experimental-restfultable/restfultable.customview.js' */
/*
 * Defining Custom renderer classes for people to extend.
 * We do this to
 * - Hide implementation (backbone)
 * - Future proof ourselves. We can modify peoples custom renderers easy in the future by adding to base class.
 */
AJS.RestfulTable.CustomEditView = AJS.RestfulTable.CustomCreateView = AJS.RestfulTable.CustomReadView = Backbone.View;
;
;
/* module-key = 'com.atlassian.auiplugin:aui-experimental-restfultable', location = 'js/experimental-restfultable/restfultable.row.js' */
(function ($) {

    /**
     * An abstract class that gives the required behaviour for RestfulTable rows.
     * Extend this class and pass it as the {views.row} property of the options passed to AJS.RestfulTable in construction.
     *
     * @class Row
     * @namespace AJS.RestfulTable
     */
    AJS.RestfulTable.Row = Backbone.View.extend({

        // Static Const
        tagName: 'tr',

        // delegate events
        events: {
            'click .aui-restfultable-editable': 'edit'
        },

        /**
         * @constructor
         * @param {object} options
         */
        initialize: function (options) {

            var instance = this;

            options = options || {};

            // faster lookup
            this._event = AJS.RestfulTable.Events;
            this.classNames = AJS.RestfulTable.ClassNames;
            this.dataKeys = AJS.RestfulTable.DataKeys;

            this.columns = options.columns;
            this.allowEdit = options.allowEdit;
            this.allowDelete = options.allowDelete;

            if (!this.events['click .aui-restfultable-editable']) {
                throw new Error('It appears you have overridden the events property. To add events you will need to use' +
                        'a work around. https://github.com/documentcloud/backbone/issues/244');
            }
            this.index = options.index || 0;
            this.deleteConfirmation = options.deleteConfirmation;
            this.allowReorder = options.allowReorder;

            this.$el = $(this.el);

            this.bind(this._event.CANCEL, function () {
                this.disabled = true;
            })
                    .bind(this._event.FOCUS, function (field) {
                        this.focus(field);
                    })
                    .bind(this._event.BLUR, function () {
                        this.unfocus();
                    })
                    .bind(this._event.MODAL, function () {
                        this.$el.addClass(this.classNames.ACTIVE);
                    })
                    .bind(this._event.MODELESS, function () {
                        this.$el.removeClass(this.classNames.ACTIVE);
                    });
        },

        /**
         * Renders drag handle
         * @return jQuery
         */
        renderDragHandle: function () {
            return '<span class="' + this.classNames.DRAG_HANDLE + '"></span></td>';

        },

        /**
         * Renders default cell contents
         *
         * @param data
         * @return {undefiend, String}
         */
        defaultColumnRenderer: function (data) {
            if (data.value) {
                return document.createTextNode(data.value.toString());
            }
        },

        /**
         * Save changed attributes back to server and re-render
         *
         * @param attr
         * @return {AJS.RestfulTable.Row}
         */
        sync: function (attr) {

            this.model.addExpand(attr);

            var instance = this;

            this.showLoading();

            this.model.save(attr, {
                success: function () {
                    instance.hideLoading().render();
                    instance.trigger(instance._event.UPDATED);
                },
                error: function () {
                    instance.hideLoading();
                }
            });

            return this;
        },

        /**
         * Get model from server and re-render
         *
         * @return {AJS.RestfulTable.Row}
         */
        refresh: function (success, error) {

            var instance = this;

            this.showLoading();

            this.model.fetch({
                success: function () {
                    instance.hideLoading().render();
                    if (success) {
                        success.apply(this, arguments);
                    }
                },
                error: function () {
                    instance.hideLoading();
                    if (error) {
                        error.apply(this, arguments);
                    }
                }
            });

            return this;
        },

        /**
         * Returns true if row has focused class
         *
         * @return Boolean
         */
        hasFocus: function () {
            return this.$el.hasClass(this.classNames.FOCUSED);
        },

        /**
         * Adds focus class (Item has been recently updated)
         *
         * @return AJS.RestfulTable.Row
         */
        focus: function () {
            $(this.el).addClass(this.classNames.FOCUSED);
            return this;
        },

        /**
         * Removes focus class
         *
         * @return AJS.RestfulTable.Row
         */
        unfocus: function () {
            $(this.el).removeClass(this.classNames.FOCUSED);
            return this;

        },

        /**
         * Adds loading class (to show server activity)
         *
         * @return AJS.RestfulTable.Row
         */
        showLoading: function () {
            this.$el.addClass(this.classNames.LOADING);
            return this;
        },

        /**
         * Hides loading class (to show server activity)
         *
         * @return AJS.RestfulTable.Row
         */
        hideLoading: function () {
            this.$el.removeClass(this.classNames.LOADING);
            return this;
        },

        /**
         * Switches row into edit mode
         *
         * @param e
         */
        edit: function (e) {
            var field;
            if ($(e.target).is('.' + this.classNames.EDITABLE)) {
                field = $(e.target).attr('data-field-name');
            }
            else {
                field = $(e.target).closest('.' + this.classNames.EDITABLE).attr('data-field-name');
            }
            this.trigger(this._event.ROW_EDIT, field);
            return this;
        },

        /**
         * Can be overriden to add custom options
         *
         */
        renderOperations: function () {
            var instance = this;
            if (this.allowDelete !== false) {
                return $("<a href='#' class='aui-button' />")
                        .addClass(this.classNames.DELETE)
                        .text("Delete").click(function (e) {
                            e.preventDefault();
                            instance.destroy();
                        });
            }
        },

        /**
         * Removes entry from table
         */
        destroy: function () {
            if (this.deleteConfirmation) {
                var popup = AJS.popup(400, 200, 'delete-entity-' + this.model.get('id'));
                popup.element.html(this.deleteConfirmation(this.model.toJSON()));
                popup.show();
                popup.element.find('.cancel').click(function () {
                    popup.hide();
                });
                popup.element.find('form').submit(_.bind(function (e) {
                    popup.hide();
                    this.model.destroy();
                    e.preventDefault();
                }, this));
            }
            else {
                this.model.destroy();
            }

        },

        /**
         * Renders a generic edit row. You probably want to override this in a sub class.
         *
         * @return AJS.RestfulTable.Row
         */
        render: function  () {

            var instance = this,
                    renderData = this.model.toJSON(),
                    $opsCell = $("<td class='aui-restfultable-operations' />").append(this.renderOperations({}, renderData)),
                    $throbberCell = $("<td class='aui-restfultable-status' />").append(AJS.RestfulTable.throbber());

            // restore state
            this.$el
                    .removeClass(this.classNames.DISABLED + ' ' + this.classNames.FOCUSED + ' ' + this.classNames.LOADING + ' ' + this.classNames.EDIT_ROW)
                    .addClass(this.classNames.READ_ONLY)
                    .empty();


            if (this.allowReorder) {
                $('<td  class="' + this.classNames.ORDER + '" />').append(this.renderDragHandle()).appendTo(instance.$el);
            }

            this.$el.attr('data-id', this.model.id); // helper for webdriver testing

            $.each(this.columns, function (i, column) {

                var contents,
                        $cell = $('<td />'),
                        value = renderData[column.id],
                        fieldName = column.fieldName || column.id,
                        args = [{name: fieldName, value: value, allowEdit: column.allowEdit}, renderData, instance.model];

                if (value) {
                    instance.$el.attr('data-' + column.id, value); // helper for webdriver testing

                }

                if (column.readView) {
                    contents = new column.readView({
                        model: instance.model
                    }).render(args[0]);
                }
                else {
                    contents = instance.defaultColumnRenderer.apply(instance, args);
                }

                if (instance.allowEdit !== false && column.allowEdit !== false) {
                    var $editableRegion = $('<span />')
                            .addClass(instance.classNames.EDITABLE)
                            .append(aui.icons.icon({useIconFont: true, icon: 'edit'}))
                            .append(contents)
                            .attr('data-field-name', fieldName);

                    $cell  = $('<td />').append($editableRegion).appendTo(instance.$el);

                    if (!contents || $.trim(contents) == '') {
                        $cell.addClass(instance.classNames.NO_VALUE);
                        $editableRegion.html($('<em />').text(this.emptyText || "Enter value"));
                    }

                }
                else {
                    $cell.append(contents);
                }

                if (column.styleClass) {
                    $cell.addClass(column.styleClass);
                }

                $cell.appendTo(instance.$el);
            });

            this.$el
                    .append($opsCell)
                    .append($throbberCell)
                    .addClass(this.classNames.ROW + ' ' + this.classNames.READ_ONLY);

            this.trigger(this._event.RENDER, this.$el, renderData);
            this.$el.trigger(this._event.CONTENT_REFRESHED, [this.$el]);
            return this;
        }
    });

})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.gadgets:column-picker-component', location = 'static/components/columnpicker/ColumnPicker.soy' */
// This file was automatically generated from ColumnPicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.Common.Config.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.Common == 'undefined') { JIRA.DashboardItem.Common = {}; }
if (typeof JIRA.DashboardItem.Common.Config == 'undefined') { JIRA.DashboardItem.Common.Config = {}; }
if (typeof JIRA.DashboardItem.Common.Config.Templates == 'undefined') { JIRA.DashboardItem.Common.Config.Templates = {}; }


JIRA.DashboardItem.Common.Config.Templates.columnPicker = function(opt_data, opt_ignored) {
  var output = '';
  var tableId__soy3 = opt_data.id + '-table';
  var selectId__soy4 = opt_data.id + '-select';
  var prefixedTableId__soy5 = opt_data.prefix + tableId__soy3;
  var prefixedSelectId__soy6 = opt_data.prefix + selectId__soy4;
  output += '<div class="field-group ' + soy.$$escapeHtml(tableId__soy3) + '"><label for="' + soy.$$escapeHtml(prefixedTableId__soy5) + '">' + soy.$$escapeHtml("Columns to display") + '<span class="aui-icon icon-required"> ' + soy.$$escapeHtml("required") + '</span></label><table class="column-picker-order" id="' + soy.$$escapeHtml(prefixedTableId__soy5) + '"></table><div class="description">' + soy.$$escapeHtml("Drag-drop to reorder the fields.") + '</div><div class="error">' + soy.$$escapeHtml("You must select at least one field.") + '</div></div><div class="field-group ' + soy.$$escapeHtml(selectId__soy4) + '"><select class="select" id="' + soy.$$escapeHtml(prefixedSelectId__soy6) + '" name="' + soy.$$escapeHtml(opt_data.id) + '"></select><div class="description">' + soy.$$escapeHtml("Add fields to the list above by selecting them.") + '</div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Common.Config.Templates.columnPicker.soyTemplateName = 'JIRA.DashboardItem.Common.Config.Templates.columnPicker';
}


JIRA.DashboardItem.Common.Config.Templates.deleteColumnButton = function(opt_data, opt_ignored) {
  return '<button class="aui-button aui-button-subtle"><span class="aui-icon aui-icon-small aui-iconfont-delete">' + soy.$$escapeHtml("Delete") + '</span></button>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Common.Config.Templates.deleteColumnButton.soyTemplateName = 'JIRA.DashboardItem.Common.Config.Templates.deleteColumnButton';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:column-picker-component', location = 'static/components/columnpicker/ColumnPicker.js' */
define("jira-dashboard-items/components/column-picker", [
    'underscore',
    'jquery',
    'jira/ajs/ajax/smart-ajax',
    'jira/ajs/select/single-select'
], function (
    _,
    $,
    SmartAjax,
    SingleSelect
) {
    'use strict';

    var showAjaxError = function (container, result) {
        $(container).empty();
        AJS.messages.error(container, {
            title: "Error",
            body: '<p>' + SmartAjax.buildSimpleErrorContent(result) + '</p>',
            closeable: false
        });
        $(container).show();
    };

    var createTable = function (tableElement) {
        var LocalEntryModel = AJS.RestfulTable.EntryModel.extend({
            destroy: function () {
                this.collection.remove(this);
            }
        });

        var ReorderableRowView = AJS.RestfulTable.Row.extend({
            initialize: function (options) {
                options = _.extend({}, options, {allowReorder: true});
                AJS.RestfulTable.Row.prototype.initialize.call(this, options);
            },
            renderOperations: function () {
                return $(JIRA.DashboardItem.Common.Config.Templates.deleteColumnButton())
                        .click(_.bind(function (e) {
                            e.preventDefault();
                            this.destroy();
                        }, this));
            }
        });

        var table = new AJS.RestfulTable({
            el: tableElement,
            allowReorder: false,
            allowEdit: false,
            allowCreate: false,
            autoFocus: false,
            model: LocalEntryModel,
            resources: {
                all: function (populate) {
                    populate([]);
                }
            },
            columns: [
                {
                    id: "label",
                    header: ""
                }
            ],
            views: {
                row: ReorderableRowView
            }
        });
        table.$thead.detach();

        // Add allowance for another cell to the <thead>
        table.$theadRow.prepend("<th />");

        // Allow drag and drop reordering of rows
        table.$tbody.sortable({
            handle: "." + table.classNames.DRAG_HANDLE,
            helper: function (e, elt) {
                var helper = $("<div/>").addClass(table.classNames.MOVEABLE + " " + elt.attr("class"));
                elt.children().each(function (i) {
                    var $td = $(this);

                    // .offsetWidth/.outerWidth() is broken in webkit for tables, so we do .clientWidth + borders
                    // Need to coerce the border-left-width to an in because IE - http://bugs.jquery.com/ticket/10855
                    var borderLeft = parseInt(0 + $td.css("border-left-width"), 10);
                    var borderRight = parseInt(0 + $td.css("border-right-width"), 10);
                    var width = $td[0].clientWidth + borderLeft + borderRight;

                    helper.append($("<div/>").html($td.html()).addClass($td.attr("class")).width(width));
                });

                helper = $("<div class='aui-restfultable-readonly'/>").append(helper); // Basically just to get the styles.
                helper.css({left: elt.offset().left}); // To align with the other table rows, since we've locked scrolling on x.
                helper.appendTo(document.body);

                return helper;
            },
            start: function (event, ui) {
                var cachedHeight = ui.helper[0].clientHeight;
                var $this = ui.placeholder.find("td");

                // Make sure that when we start dragging widths do not change
                ui.item
                        .addClass(table.classNames.MOVEABLE)
                        .children().each(function (i) {
                            $(this).width($this.eq(i).width());
                        });

                // Create a <td> to add to the placeholder <tr> to inherit CSS styles.
                var td = '<td colspan="' + table.getColumnCount() + '">&nbsp;</td>';

                ui.placeholder.html(td).css({
                    height: cachedHeight,
                    visibility: 'visible'
                });

                // Stop hover effects etc from occuring as we move the mouse (while dragging) over other rows
                table.getRowFromElement(ui.item[0]).trigger(table._event.MODAL);
            },
            stop: function (event, ui) {
                if ($(ui.item[0]).is(":visible")) {
                    ui.item
                            .removeClass(table.classNames.MOVEABLE)
                            .children().attr("style", "");

                    ui.placeholder.removeClass(table.classNames.ROW);

                    // Return table to a normal state
                    table.getRowFromElement(ui.item[0]).trigger(table._event.MODELESS);
                }
            },
            axis: "y",
            delay: 0,
            containment: "document",
            cursor: "move",
            scroll: true,
            zIndex: 8000
        });

        // Prevent text selection while reordering.
        table.$tbody.bind("selectstart mousedown", function (event) {
            return !$(event.target).is("." + table.classNames.DRAG_HANDLE);
        });

        return table;
    };

    var createSelectField = function (options, table) {
        var errorContainer = options.errorContainer;
        var columnNames = options.columnNames;
        var availableColumns = [];

        // Get options for the select field
        SmartAjax.makeRequest({
            url: AJS.contextPath() + "/rest/gadget/1.0/availableColumns",
            method: "GET",
            success: function (response) {
                if (response.availableColumns && response.availableColumns.length) {
                    _.each(response.availableColumns, function (column) {
                        availableColumns.push(new AJS.ItemDescriptor(column));
                    });
                }

                if (columnNames === "--Default--") {
                    _.each(response.defaultColumns, function (column) {
                        table.addRow({
                            id: column.value,
                            label: column.label
                        });
                    });
                }
                else {
                    var columns = columnNames.split("|");
                    _.each(columns, function (columnId) {
                        var availableColumn = _.find(availableColumns, function (availableColumn) {
                            return (availableColumn.value() === columnId);
                        });
                        if (availableColumn) {
                            table.addRow({
                                id: availableColumn.value(),
                                label: availableColumn.label()
                            });
                        }
                    });
                }
                select.enable();
            },
            error: function (result) {
                showAjaxError(errorContainer, result);
            },
            complete: function () {
                if(options.onContentLoaded) {
                    options.onContentLoaded();
                }
            }
        });

        // Create the select field
        var select = new SingleSelect({
            element: options.fieldElement,
            itemAttrDisplayed: "label",
            revertOnInvalid: true,
            submitInputVal: false,
            showDropdownButton: true,
            suggestions: function (query) {
                return _.filter(availableColumns, function (columnDescriptor) {
                    var isAlreadyInTheTable = table._models.get(columnDescriptor.value());
                    var matchesQuery = columnDescriptor.label().toLocaleLowerCase().indexOf(query.toLocaleLowerCase()) > -1;
                    return !isAlreadyInTheTable && matchesQuery;
                });
            }
        });
        select.disable();
        select.model.$element.on('selected', function (e, descriptor) {
            select.clear();
            if (!descriptor.value()) {
                return;
            }
            if (table._models.get(descriptor.value())) {
                return;
            }
            table.addRow({
                id: descriptor.value(),
                label: descriptor.label()
            });
            if(options.onContentLoaded) {
                options.onContentLoaded();
            }
        });

        return select;
    };

    return function () {
        return {
            init: function (options) {
                var self = this;
                this.tableElement = options.tableElement;

                this.table = createTable(options.tableElement);
                this.select  = createSelectField(options, this.table);

                this.table.getColumnValues = function () {
                    return _.map(self.table.$table.find("tr"), function (tr) {
                        return $(tr).attr("data-id");
                    });
                };

                return this;
            },

            getValue: function () {
                return this.table.getColumnValues().join("|");
            },

            validate: function () {
                var errorField = this.tableElement.parents(".field-group").find(".error");
                if (this.table._models.length > 0) {
                    errorField.hide();
                    return true;
                }
                else {
                    errorField.show();
                    return false;
                }
            }
        };
    };
});;
;
/* module-key = 'com.atlassian.jira.gadgets:search-results-component', location = 'static/components/searchresults/SearchResults.soy' */
// This file was automatically generated from SearchResults.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.Common.SearchResults.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.Common == 'undefined') { JIRA.DashboardItem.Common = {}; }
if (typeof JIRA.DashboardItem.Common.SearchResults == 'undefined') { JIRA.DashboardItem.Common.SearchResults = {}; }
if (typeof JIRA.DashboardItem.Common.SearchResults.Templates == 'undefined') { JIRA.DashboardItem.Common.SearchResults.Templates = {}; }


JIRA.DashboardItem.Common.SearchResults.Templates.errorResult = function(opt_data, opt_ignored) {
  return '<div class="empty-results search-results-dashboard-item">' + aui.message.error({content: '<p>' + soy.$$escapeHtml("Error occurred running search.") + '</p>'}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Common.SearchResults.Templates.errorResult.soyTemplateName = 'JIRA.DashboardItem.Common.SearchResults.Templates.errorResult';
}


JIRA.DashboardItem.Common.SearchResults.Templates.noResults = function(opt_data, opt_ignored) {
  return '<div class="empty-results search-results-dashboard-item">' + soy.$$escapeHtml("Search returned no results.") + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Common.SearchResults.Templates.noResults.soyTemplateName = 'JIRA.DashboardItem.Common.SearchResults.Templates.noResults';
}


JIRA.DashboardItem.Common.SearchResults.Templates.resultsTable = function(opt_data, opt_ignored) {
  return '<div class="results-wrap search-results-dashboard-item"><div class="search-results-dashboard-item-issue-table ' + ((opt_data.pagination == true) ? 'paging-table' : '') + '">' + soy.$$filterNoAutoescape(opt_data.table) + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Common.SearchResults.Templates.resultsTable.soyTemplateName = 'JIRA.DashboardItem.Common.SearchResults.Templates.resultsTable';
}


JIRA.DashboardItem.Common.SearchResults.Templates.searchLink = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.href) + '" ' + ((opt_data.title) ? 'title="' + soy.$$escapeHtml(opt_data.title) + '"' : '') + '>' + soy.$$escapeHtml(opt_data.issueCount) + '</a>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Common.SearchResults.Templates.searchLink.soyTemplateName = 'JIRA.DashboardItem.Common.SearchResults.Templates.searchLink';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:search-results-component', location = 'static/components/searchresults/SearchResults.js' */
define("jira-dashboard-items/components/search-results", [
    'jquery',
    'underscore',
    'backbone'
], function (
    $,
    _,
    Backbone
) {
    'use strict';

    // JC-303, JC-278: In ancient JIRA we used to store '--Default--' in the column config to get the default
    // columns in the gadgets. There's still some data out there that has this for the gadget config.
    // need to ensure we handle this correctly here before sending the request to theserver.
    var updateDataForLegacyDefaultColumns = function(data) {
        var legacyDefaultColsIndex = _.indexOf(data.columnNames, "--Default--");
        if(legacyDefaultColsIndex !== -1) {
            data.addDefault = true;
            data.columnNames.splice(legacyDefaultColsIndex, 1);
        }
    };

    return function (options) {
        var context = options.context;
        var preferences = options.preferences;
        var tableUrl;
        var dataDefaults = {
            num: preferences.num,
            tableContext: options.tableContext || "jira.table.cols.dashboard",
            addDefault: false,
            columnNames: preferences.columnNames.split("|"),
            enableSorting: true,
            paging: true,
            showActions: true
        };

        updateDataForLegacyDefaultColumns(dataDefaults);

        function onSuccess(data, textStatus, jqXHR) {
            var $resultCountLink;
            var $table;

            context.empty();

            // we need to append ids with a random prefix to avoid clashes between different instances of
            // the search results dashboard item
            data.table = "<div>" + data.table + "</div>";
            $table = $(data.table);
            $table.find('#issuetable').removeAttr('id').addClass('issue-table');
            $table.find('[id]').removeAttr('id');
            data.table = $table.html();

            if (data.displayed != 0) {
                //if all issues are showing on one page then pagination is not required
                var showPagination = data.displayed === data.total;
                context.append(JIRA.DashboardItem.Common.SearchResults.Templates.resultsTable({
                    pagination: showPagination,
                    table: data.table
                }));

                $resultCountLink = context.find(".results-count-link");
                var link;
                if(data.url) {
                    link = AJS.contextPath() + data.url;
                } else if (preferences.jql) {
                    link = AJS.contextPath() + "/issues/?jql=" + encodeURIComponent(preferences.jql);
                }

                if(link) {
                    $resultCountLink.replaceWith(JIRA.DashboardItem.Common.SearchResults.Templates.searchLink({
                        href: link,
                        title: data.title,
                        issueCount: $resultCountLink.html()
                    }));
                }

                $("th.sortable", context).each(function () {
                    this.onclick = null;
                }).click(function (e) {
                    e.preventDefault();
                    context.find(".search-results-dashboard-item-issue-table").addClass("loading");
                    preferences.sortBy = $(this).attr("rel");
                    publicApi.trigger("sorted", {
                       "sortBy": preferences.sortBy
                    });
                });

                $(".pagination a", context).click(function (event) {
                    event.preventDefault();
                    context.find(".search-results-dashboard-item-issue-table").addClass("loading");
                    preferences.startIndex = $(this).attr("rel");
                    renderTable();
                });

                AJS.Dropdown.create({
                    trigger: ".issue-actions-trigger",
                    autoScroll: false,
                    ajaxOptions: {
                        dataType: "json",
                        cache: false,
                        formatSuccess: JIRA.FRAGMENTS.issueActionsFragment
                    }
                });

                //TODO: This is so that the dashboard item resizes correctly if the content contains
                //      images. We should probably look at switching to something more advanced like ImageLoader.js
                //      in future. For now this is what the old gadget code did as well.
                if(options.onContentLoaded) {
                    setTimeout(options.onContentLoaded, 500);
                }
            }
            else {
                if(options.onEmptyResult) {
                    options.onEmptyResult(data, textStatus, jqXHR);
                } else {
                    context.empty().append(JIRA.DashboardItem.Common.SearchResults.Templates.noResults());
                }
            }
        }

        function renderTable() {
            return $.ajax({
                url: tableUrl,
                type: "GET",
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: $.extend({}, dataDefaults, {
                    sortBy: (preferences.sortBy && preferences.sortBy !== "") ? preferences.sortBy : "",
                    startIndex: preferences.startIndex ? preferences.startIndex : 0
                }),
                error: function(jqXHR, textStatus, errorThrown) {
                    if(options.onError) {
                        options.onError(jqXHR, textStatus, errorThrown);
                    } else {
                        context.empty().append(JIRA.DashboardItem.Common.SearchResults.Templates.errorResult());
                    }
                },
                success: onSuccess,
                complete: options.onContentLoaded
            });
        }

        var publicApi = _.extend({
            render: function () {
                if (preferences.filterId) {
                    tableUrl = AJS.contextPath() + '/rest/gadget/1.0/issueTable/filter';
                    dataDefaults.filterId = preferences.filterId;
                    return renderTable();
                }
                else if (preferences.jql) {
                    tableUrl = AJS.contextPath() + '/rest/gadget/1.0/issueTable/jql';
                    dataDefaults.jql = preferences.jql;
                    return renderTable();
                }
                else {
                    throw new Error("Unable to render search results. filterId or jql are required.");
                }
            }
        }, Backbone.Events);

        return publicApi;
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:search-results-component', location = 'static/components/searchresults/SearchResultsConfig.soy' */
// This file was automatically generated from SearchResultsConfig.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.Common.SearchResults.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.Common == 'undefined') { JIRA.DashboardItem.Common = {}; }
if (typeof JIRA.DashboardItem.Common.SearchResults == 'undefined') { JIRA.DashboardItem.Common.SearchResults = {}; }
if (typeof JIRA.DashboardItem.Common.SearchResults.Templates == 'undefined') { JIRA.DashboardItem.Common.SearchResults.Templates = {}; }


JIRA.DashboardItem.Common.SearchResults.Templates.config = function(opt_data, opt_ignored) {
  return '' + Atlassian.DashboardItem.Common.Templates.config({isConfigured: opt_data.preferences.isConfigured, fields: '<fieldset>' + JIRA.DashboardItem.Common.SearchResults.Templates.numberResults({prefix: opt_data.prefix, id: 'number-results', value: opt_data.preferences.num}) + JIRA.DashboardItem.Common.Config.Templates.columnPicker({prefix: opt_data.prefix, id: 'fields-to-display'}) + Atlassian.DashboardItem.Common.Templates.refreshInterval({prefix: opt_data.prefix, id: 'refresh-interval', value: opt_data.preferences.refresh}) + '</fieldset>'});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Common.SearchResults.Templates.config.soyTemplateName = 'JIRA.DashboardItem.Common.SearchResults.Templates.config';
}


JIRA.DashboardItem.Common.SearchResults.Templates.numberResults = function(opt_data, opt_ignored) {
  var output = '';
  var prefixedId__soy20 = opt_data.prefix + opt_data.id;
  output += '<div class="field-group ' + soy.$$escapeHtml(opt_data.id) + '"><label for="' + soy.$$escapeHtml(prefixedId__soy20) + '">' + soy.$$escapeHtml("Number of Results") + '<span class="aui-icon icon-required"> ' + soy.$$escapeHtml("required") + '</span></label><input class="text" type="text" id="' + soy.$$escapeHtml(prefixedId__soy20) + '" name="' + soy.$$escapeHtml(opt_data.id) + '" value="' + soy.$$escapeHtml(opt_data.value) + '"><div class="error">' + soy.$$escapeHtml("The value must be an integer greater than 0 and less than or equal to 50") + '</div><div class="description">' + soy.$$escapeHtml("Number of results to display (maximum of 50).") + '</div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Common.SearchResults.Templates.numberResults.soyTemplateName = 'JIRA.DashboardItem.Common.SearchResults.Templates.numberResults';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:search-results-component', location = 'static/components/searchresults/SearchResultsConfig.js' */
define("jira-dashboard-items/components/search-results-config", [
    'jira-dashboard-items/components/column-picker',
    'jquery',
    'underscore'
], function(
    ColumnPicker,
    $,
    _
) {
    'use strict';

    return function (options) {
        var context = $(options.context);
        var preferences = options.preferences;

        return {
            renderConfig: function () {
                // Random prefix to avoid collisions with other instances of this gadget
                var prefix = (Math.random() + 1).toString(36).substring(7) + "-";

                // Render the template
                context.empty().html(JIRA.DashboardItem.Common.SearchResults.Templates.config({
                    prefix: prefix,
                    preferences: {
                        num: preferences.num,
                        refresh: preferences.refresh,
                        isConfigured: preferences.isConfigured
                    }
                }));

                var form = context.find("form");

                var columnPicker = new ColumnPicker().init({
                    errorContainer: context.find(".dashboard-item-error"),
                    tableElement: form.find("#" + prefix + "fields-to-display-table"),
                    fieldElement: form.find("#" + prefix + "fields-to-display-select"),
                    columnNames: preferences.columnNames,
                    onContentLoaded: options.onContentLoaded
                });

                function validateNumberResults() {
                    var field = form.find("input[name=number-results]");
                    var value = field.val();

                    if (value > 0 && value <= 50) {
                        field.parents(".field-group").find(".error").hide();
                        return true;
                    } else {
                        field.parents(".field-group").find(".error").show();
                        return false;
                    }
                }

                function validateFields() {
                    var numberResultsIsValid = validateNumberResults();
                    var fieldsToDisplayIsValid = columnPicker.validate();

                    return numberResultsIsValid && fieldsToDisplayIsValid;
                }

                form.on("submit", _.bind(function (e) {
                    e.preventDefault();
                    if (!validateFields()) {
                        options.onContentLoaded();
                        return;
                    }

                    var form = $(e.target);
                    options.onSave({
                        "num": form.find("input[name=number-results]").val(),
                        "refresh": options.gadgetAPI.getRefreshFieldValue('refresh-interval'),
                        "columnNames": columnPicker.getValue()
                    });
                }, this));

                form.find(".buttons-container .cancel").on("click", _.bind(function () {
                    options.onCancel();
                }, this));

                return form;
            }
        };
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:filter-results-dashboard-item-resources', location = 'static/dashboarditem/filterresults/FilterResults.soy' */
// This file was automatically generated from FilterResults.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.FilterResults.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.FilterResults == 'undefined') { JIRA.DashboardItem.FilterResults = {}; }
if (typeof JIRA.DashboardItem.FilterResults.Templates == 'undefined') { JIRA.DashboardItem.FilterResults.Templates = {}; }


JIRA.DashboardItem.FilterResults.Templates.filterErrorResult = function(opt_data, opt_ignored) {
  var output = '<div class="empty-results search-results-dashboard-item">';
  var filterLink__soy4 = '<a href="' + soy.$$escapeHtml("/jira") + '/issues/?filter=' + soy.$$escapeHtml(opt_data.filterId) + '">';
  output += aui.message.error({content: '<p>' + soy.$$filterNoAutoescape(AJS.format("The filter configured for this gadget could not be retrieved. Please verify it is still valid on the {0}issue navigator{1}.",filterLink__soy4,'</a>')) + '</p>'}) + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.FilterResults.Templates.filterErrorResult.soyTemplateName = 'JIRA.DashboardItem.FilterResults.Templates.filterErrorResult';
}


JIRA.DashboardItem.FilterResults.Templates.noResults = function(opt_data, opt_ignored) {
  var output = '<div class="empty-results search-results-dashboard-item">';
  var filterLink__soy19 = '<a href="' + soy.$$escapeHtml(opt_data.href) + '" ' + ((opt_data.title) ? 'title="' + soy.$$escapeHtml(opt_data.title) + '"' : '') + '>';
  output += soy.$$filterNoAutoescape(AJS.format("No matching {0}issues{1} found.",filterLink__soy19,'</a>')) + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.FilterResults.Templates.noResults.soyTemplateName = 'JIRA.DashboardItem.FilterResults.Templates.noResults';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:filter-results-dashboard-item-resources', location = 'static/dashboarditem/filterresults/FilterResults.js' */
define("jira-dashboard-items/filter-results", [
    'jquery',
    'underscore',
    'jira-dashboard-items/components/filter-picker',
    'jira-dashboard-items/components/search-results-config',
    'jira-dashboard-items/components/search-results'
], function (
    $,
    _,
    FilterPicker,
    SearchResultsConfig,
    SearchResults
) {

    'use strict';

    var DashboardItem = function (API) {
        this.API = API;
    };

    DashboardItem.prototype.render = function (context, preferences) {
        var self = this;

        self.API.showLoadingBar();

        var displayPrefs = $.extend({}, preferences);
        //fix up potentially old filterIds first that may still be stored.
        displayPrefs.filterId = displayPrefs.filterId !== undefined ? displayPrefs.filterId.replace('filter-', '') : displayPrefs.filterId;

        this.searchResults = new SearchResults({
            context: context,
            preferences: displayPrefs,
            onContentLoaded: this.API.resize.bind(this.API),
            onEmptyResult: function () {
                context.append(JIRA.DashboardItem.FilterResults.Templates.noResults({
                    href: AJS.contextPath() + "/issues/?filter=" + displayPrefs.filterId
                }));
                self.API.resize();
            },
            onError: function () {
                context.empty().append(JIRA.DashboardItem.FilterResults.Templates.filterErrorResult({
                    filterId: displayPrefs.filterId
                }));
                self.API.resize();
            }
        });

        this.searchResults.render().
                done(function(data) {
                    if(data && data.title) {
                        self.API.setTitle(AJS.format("Filter Results: {0}", data.title));
                    }
                }).always(this.API.hideLoadingBar.bind(this.API));

        this.searchResults.on("sorted", function(eventData) {
            preferences.sortBy = eventData.sortBy;
            if(self.API.isEditable()) {
                self.API.savePreferences(preferences);
            } else {
                self.render(context, preferences);
            }
        });

        self.API.initRefresh(displayPrefs, _.bind(self.render, self, context, displayPrefs));
    };

    DashboardItem.prototype.renderEdit = function (element, preferences) {
        var self = this;

        var searchResultsConfig = new SearchResultsConfig({
            context: element,
            preferences: preferences,
            onContentLoaded: function () {
                self.API.hideLoadingBar();
                self.API.resize();
            },
            onCancel: this.API.closeEdit.bind(this.API),
            onSave: function (prefs) {
                var validFilter = self.filterPicker.validate();
                if (validFilter) {
                    var selectedFilter = self.filterPicker.getValue();
                    prefs.filterId = selectedFilter.id;
                    self.API.savePreferences(prefs);
                }
                else {
                    self.API.resize();
                }
            },
            gadgetAPI: self.API
        });

        var $form = searchResultsConfig.renderConfig();
        var prefix = self.API.getGadgetId() + "-";
        $form.find("fieldset:first").prepend(JIRA.DashboardItem.Common.Config.Templates.filterPicker({
            prefix:prefix,
            id:"saved-filter"
        }));
        // Instrument the special fields
        this.filterPicker = new FilterPicker().init({
            errorContainer: element.find(".dashboard-item-error"),
            element: $form.find("#" + prefix + "saved-filter"),
            selectedValue: preferences.filterId !== undefined ? preferences.filterId.replace('filter-', '') : preferences.filterId,
            parentElement: $form
        });

        this.API.once("afterRender", function () {
            if (element.width() < 350) {
                $form.addClass("top-label");
            }
            self.API.showLoadingBar();
        });
    };

    return DashboardItem;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:assigned-to-me-dashboard-item-resources', location = 'static/dashboarditem/assignedtome/AssignedToMe.soy' */
// This file was automatically generated from AssignedToMe.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.AssignedToMe.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.AssignedToMe == 'undefined') { JIRA.DashboardItem.AssignedToMe = {}; }
if (typeof JIRA.DashboardItem.AssignedToMe.Templates == 'undefined') { JIRA.DashboardItem.AssignedToMe.Templates = {}; }


JIRA.DashboardItem.AssignedToMe.Templates.errorResult = function(opt_data, opt_ignored) {
  return '<div class="empty-results search-results-dashboard-item">' + aui.message.error({content: '<p>' + soy.$$escapeHtml("An unknown error occurred while trying to perform a search.") + '</p>'}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.AssignedToMe.Templates.errorResult.soyTemplateName = 'JIRA.DashboardItem.AssignedToMe.Templates.errorResult';
}


JIRA.DashboardItem.AssignedToMe.Templates.noResults = function(opt_data, opt_ignored) {
  var output = '<div class="empty-results search-results-dashboard-item">';
  var filterLink__soy12 = '<a href="' + soy.$$escapeHtml(opt_data.href) + '">';
  output += soy.$$filterNoAutoescape(AJS.format("You currently have no {0}issues{1} assigned to you. Enjoy your day!",filterLink__soy12,'</a>')) + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.AssignedToMe.Templates.noResults.soyTemplateName = 'JIRA.DashboardItem.AssignedToMe.Templates.noResults';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:assigned-to-me-dashboard-item-resources', location = 'static/dashboarditem/assignedtome/AssignedToMe.js' */
define("jira-dashboard-items/assigned-to-me", [
    'jquery',
    'underscore',
    'jira-dashboard-items/components/search-results-config',
    'jira-dashboard-items/components/search-results'
], function (
    $,
    _,
    SearchResultsConfig,
    SearchResults
) {
    'use strict';

    var DashboardItem = function (API) {
        this.API = API;
    };

    DashboardItem.prototype.render = function (context, preferences) {
        var self = this;

        self.API.showLoadingBar();
        self.API.setTitle("Assigned to Me");

        var displayPrefs = $.extend({}, preferences);
        displayPrefs.jql = "assignee = currentUser() AND resolution = unresolved ORDER BY priority DESC, created ASC";
        //the old assigned to me gadget would store which column to sort by in a 'sortColumn' property
        if(displayPrefs.sortColumn) {
            displayPrefs.sortBy = displayPrefs.sortColumn;
        }

        this.searchResults = new SearchResults({
            context: context,
            preferences: displayPrefs,
            onContentLoaded: this.API.resize.bind(this.API),
            onEmptyResult: function () {
                context.append(JIRA.DashboardItem.AssignedToMe.Templates.noResults({
                    href: AJS.contextPath() + "/issues/?jql=" + encodeURIComponent(displayPrefs.jql)
                }));
                self.API.resize();
            },
            onError: function () {
                context.empty().append(JIRA.DashboardItem.AssignedToMe.Templates.errorResult());
                self.API.resize();
            }
        });

        this.searchResults.on("sorted", function(eventData) {
            preferences.sortBy = preferences.sortColumn = eventData.sortBy;
            if(self.API.isEditable()) {
                self.API.savePreferences(preferences);
            } else {
                self.render(context, preferences);
            }

        });

        this.searchResults.render().always(this.API.hideLoadingBar.bind(this.API));
        self.API.initRefresh(displayPrefs, this.searchResults.render);
    };

    DashboardItem.prototype.renderEdit = function (element, preferences) {
        var self = this;

        var searchResultsConfig = new SearchResultsConfig({
            context: element,
            preferences: preferences,
            onContentLoaded: function () {
                self.API.hideLoadingBar();
                self.API.resize();
            },
            onCancel: this.API.closeEdit.bind(this.API),
            onSave: this.API.savePreferences.bind(this.API),
            gadgetAPI: self.API
        });

        var $form = searchResultsConfig.renderConfig();

        this.API.once("afterRender", function () {
            if (element.width() < 350) {
                $form.addClass("top-label");
            }
            self.API.showLoadingBar();
        });
    };

    return DashboardItem;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:in-progress-dashboard-item-resources', location = 'static/dashboarditem/inprogress/InProgress.soy' */
// This file was automatically generated from InProgress.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.InProgress.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.InProgress == 'undefined') { JIRA.DashboardItem.InProgress = {}; }
if (typeof JIRA.DashboardItem.InProgress.Templates == 'undefined') { JIRA.DashboardItem.InProgress.Templates = {}; }


JIRA.DashboardItem.InProgress.Templates.errorResult = function(opt_data, opt_ignored) {
  return '<div class="empty-results search-results-dashboard-item">' + aui.message.error({content: '<p>' + soy.$$escapeHtml("An unknown error occurred while trying to perform a search.") + '</p>'}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.InProgress.Templates.errorResult.soyTemplateName = 'JIRA.DashboardItem.InProgress.Templates.errorResult';
}


JIRA.DashboardItem.InProgress.Templates.noResults = function(opt_data, opt_ignored) {
  var output = '<div class="empty-results search-results-dashboard-item">';
  var filterLink__soy12 = '<a href="' + soy.$$escapeHtml(opt_data.href) + '">';
  output += soy.$$filterNoAutoescape(AJS.format("You currently have no {0}issues{1} in progress.",filterLink__soy12,'</a>')) + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.InProgress.Templates.noResults.soyTemplateName = 'JIRA.DashboardItem.InProgress.Templates.noResults';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:in-progress-dashboard-item-resources', location = 'static/dashboarditem/inprogress/InProgress.js' */
define("jira-dashboard-items/in-progress", [
    'jquery',
    'underscore',
    'jira-dashboard-items/components/search-results-config',
    'jira-dashboard-items/components/search-results'
], function (
    $,
    _,
    SearchResultsConfig,
    SearchResults
) {
    'use strict';

    var DashboardItem = function (API) {
        this.API = API;
    };

    DashboardItem.prototype.render = function (context, preferences) {
        var self = this;

        self.API.showLoadingBar();
        self.API.setTitle("Issues in progress");

        var displayPrefs = $.extend({}, preferences);
        displayPrefs.jql = "status = 'In Progress' AND resolution is EMPTY AND assignee = currentUser() ORDER BY priority DESC, created ASC";

        this.searchResults = new SearchResults({
            context: context,
            preferences: displayPrefs,
            onContentLoaded: this.API.resize.bind(this.API),
            onEmptyResult: function () {
                context.append(JIRA.DashboardItem.InProgress.Templates.noResults({
                    href: AJS.contextPath() + "/issues/?jql=" + encodeURIComponent(displayPrefs.jql)
                }));
                self.API.resize();
            },
            onError: function () {
                context.empty().append(JIRA.DashboardItem.InProgress.Templates.errorResult());
                self.API.resize();
            }
        });

        this.searchResults.render().always(this.API.hideLoadingBar.bind(this.API));
        this.searchResults.on("sorted", function(eventData) {
            preferences.sortBy = eventData.sortBy;
            if(self.API.isEditable()) {
                self.API.savePreferences(preferences);
            } else {
                self.render(context, preferences);
            }
        });
        self.API.initRefresh(displayPrefs, this.searchResults.render);
    };

    DashboardItem.prototype.renderEdit = function (element, preferences) {
        var self = this;

        var searchResultsConfig = new SearchResultsConfig({
            context: element,
            preferences: preferences,
            onContentLoaded: function () {
                self.API.hideLoadingBar();
                self.API.resize();
            },
            onCancel: this.API.closeEdit.bind(this.API),
            onSave: this.API.savePreferences.bind(this.API),
            gadgetAPI: self.API
        });

        var $form = searchResultsConfig.renderConfig();

        this.API.once("afterRender", function () {
            if (element.width() < 350) {
                $form.addClass("top-label");
            }
            self.API.showLoadingBar();
        });
    };

    return DashboardItem;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:voted-dashboard-item-resources', location = 'static/dashboarditem/voted/Voted.soy' */
// This file was automatically generated from Voted.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.Voted.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.Voted == 'undefined') { JIRA.DashboardItem.Voted = {}; }
if (typeof JIRA.DashboardItem.Voted.Templates == 'undefined') { JIRA.DashboardItem.Voted.Templates = {}; }


JIRA.DashboardItem.Voted.Templates.extraConfig = function(opt_data, opt_ignored) {
  return '' + aui.form.checkboxField({legendContent: '', fields: opt_data.checkboxes});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Voted.Templates.extraConfig.soyTemplateName = 'JIRA.DashboardItem.Voted.Templates.extraConfig';
}


JIRA.DashboardItem.Voted.Templates.errorResult = function(opt_data, opt_ignored) {
  return '<div class="empty-results search-results-dashboard-item">' + aui.message.error({content: '<p>' + soy.$$escapeHtml("An unknown error occurred while trying to perform a search.") + '</p>'}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Voted.Templates.errorResult.soyTemplateName = 'JIRA.DashboardItem.Voted.Templates.errorResult';
}


JIRA.DashboardItem.Voted.Templates.noResults = function(opt_data, opt_ignored) {
  var output = '<div class="empty-results search-results-dashboard-item">';
  var filterLink__soy16 = '<a href="' + soy.$$escapeHtml(opt_data.href) + '">';
  output += soy.$$filterNoAutoescape(AJS.format("You are not currently voting for any {0}issues{1}.",filterLink__soy16,'</a>')) + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Voted.Templates.noResults.soyTemplateName = 'JIRA.DashboardItem.Voted.Templates.noResults';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:voted-dashboard-item-resources', location = 'static/dashboarditem/voted/Voted.js' */
define("jira-dashboard-items/voted", [
    'jquery',
    'underscore',
    'jira-dashboard-items/components/search-results-config',
    'jira-dashboard-items/components/search-results'
], function (
    $,
    _,
    SearchResultsConfig,
    SearchResults
) {
    'use strict';

    var DashboardItem = function (API) {
        this.API = API;
    };

    DashboardItem.prototype.render = function (context, preferences) {
        var self = this;

        self.API.showLoadingBar();
        self.API.setTitle("Voted Issues");

        var displayPrefs = $.extend({}, preferences);
        displayPrefs.jql = displayPrefs.showResolved ? "issue in votedIssues() order by votes desc" : "issue in votedIssues() AND resolution = EMPTY order by votes desc";

        if(displayPrefs.showTotalVotes) {
            displayPrefs.columnNames += "|votes";
        }

        this.searchResults = new SearchResults({
            context: context,
            tableContext: "jira.table.cols.voted",
            preferences: displayPrefs,
            onContentLoaded: this.API.resize.bind(this.API),
            onEmptyResult: function () {
                context.append(JIRA.DashboardItem.Voted.Templates.noResults({
                    href: AJS.contextPath() + "/issues/?jql=" + encodeURIComponent(displayPrefs.jql)
                }));
                self.API.resize();
            },
            onError: function () {
                context.empty().append(JIRA.DashboardItem.Voted.Templates.errorResult());
                self.API.resize();
            }
        });

        this.searchResults.render().always(this.API.hideLoadingBar.bind(this.API));
        this.searchResults.on("sorted", function(eventData) {
            preferences.sortBy = eventData.sortBy;
            if(self.API.isEditable()) {
                self.API.savePreferences(preferences);
            } else {
                self.render(context, preferences);
            }
        });
        self.API.initRefresh(displayPrefs, this.searchResults.render);
    };

    DashboardItem.prototype.renderEdit = function (element, preferences) {
        var self = this;

        var searchResultsConfig = new SearchResultsConfig({
            context: element,
            preferences: preferences,
            onContentLoaded: function () {
                self.API.hideLoadingBar();
                self.API.resize();
            },
            onCancel: this.API.closeEdit.bind(this.API),
            onSave: function (prefs) {
                prefs.showResolved = element.find("input[name=showResolved]").is(":checked");
                prefs.showTotalVotes = element.find("input[name=showTotalVotes]").is(":checked");
                self.API.savePreferences(prefs);
            },
            gadgetAPI: self.API
        });

        var $form = searchResultsConfig.renderConfig();
        var prefix = self.API.getGadgetId() + "-";
        $form.find(".field-group:last").before(JIRA.DashboardItem.Voted.Templates.extraConfig({
            checkboxes:[
                {
                    id: prefix + "show-resolved",
                    name: "showResolved",
                    labelText: "Include resolved issues",
                    isChecked: !!preferences.showResolved
                },
                {
                    id: prefix + "show-totals",
                    name: "showTotalVotes",
                    labelText: "Show the total votes per issue",
                    isChecked: !!preferences.showTotalVotes
                }
            ]
        }));

        this.API.once("afterRender", function () {
            if (element.width() < 350) {
                $form.addClass("top-label");
            }
            self.API.showLoadingBar();
        });
    };

    return DashboardItem;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:watched-dashboard-item-resources', location = 'static/dashboarditem/watched/Watched.soy' */
// This file was automatically generated from Watched.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.Watched.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.Watched == 'undefined') { JIRA.DashboardItem.Watched = {}; }
if (typeof JIRA.DashboardItem.Watched.Templates == 'undefined') { JIRA.DashboardItem.Watched.Templates = {}; }


JIRA.DashboardItem.Watched.Templates.extraConfig = function(opt_data, opt_ignored) {
  return '' + aui.form.checkboxField({legendContent: '', fields: opt_data.checkboxes});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Watched.Templates.extraConfig.soyTemplateName = 'JIRA.DashboardItem.Watched.Templates.extraConfig';
}


JIRA.DashboardItem.Watched.Templates.errorResult = function(opt_data, opt_ignored) {
  return '<div class="empty-results search-results-dashboard-item">' + aui.message.error({content: '<p>' + soy.$$escapeHtml("An unknown error occurred while trying to perform a search.") + '</p>'}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Watched.Templates.errorResult.soyTemplateName = 'JIRA.DashboardItem.Watched.Templates.errorResult';
}


JIRA.DashboardItem.Watched.Templates.noResults = function(opt_data, opt_ignored) {
  var output = '<div class="empty-results search-results-dashboard-item">';
  var filterLink__soy16 = '<a href="' + soy.$$escapeHtml(opt_data.href) + '">';
  output += soy.$$filterNoAutoescape(AJS.format("You are not currently watching any {0}issues{1}.",filterLink__soy16,'</a>')) + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Watched.Templates.noResults.soyTemplateName = 'JIRA.DashboardItem.Watched.Templates.noResults';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:watched-dashboard-item-resources', location = 'static/dashboarditem/watched/Watched.js' */
define("jira-dashboard-items/watched", [
    'jquery',
    'underscore',
    'jira-dashboard-items/components/search-results-config',
    'jira-dashboard-items/components/search-results'
], function (
    $,
    _,
    SearchResultsConfig,
    SearchResults
) {
    'use strict';

    var DashboardItem = function (API) {
        this.API = API;
    };

    DashboardItem.prototype.render = function (context, preferences) {
        var self = this;

        self.API.showLoadingBar();
        self.API.setTitle("Watched Issues");

        var displayPrefs = $.extend({}, preferences);
        displayPrefs.jql = displayPrefs.showResolved ? "issue in watchedIssues() order by watchers desc" : "issue in watchedIssues() AND resolution = EMPTY order by watchers desc";

        if(displayPrefs.showTotalWatches) {
            displayPrefs.columnNames += "|watches";
        }

        this.searchResults = new SearchResults({
            context: context,
            tableContext: "jira.table.cols.watched",
            preferences: displayPrefs,
            onContentLoaded: this.API.resize.bind(this.API),
            onEmptyResult: function () {
                context.append(JIRA.DashboardItem.Watched.Templates.noResults({
                    href: AJS.contextPath() + "/issues/?jql=" + encodeURIComponent(displayPrefs.jql)
                }));
                self.API.resize();
            },
            onError: function () {
                context.empty().append(JIRA.DashboardItem.Watched.Templates.errorResult());
                self.API.resize();
            }
        });

        this.searchResults.render().always(this.API.hideLoadingBar.bind(this.API));
        this.searchResults.on("sorted", function(eventData) {
            preferences.sortBy = eventData.sortBy;
            if(self.API.isEditable()) {
                self.API.savePreferences(preferences);
            } else {
                self.render(context, preferences);
            }
        });
        self.API.initRefresh(displayPrefs, this.searchResults.render);
    };

    DashboardItem.prototype.renderEdit = function (element, preferences) {
        var self = this;

        var searchResultsConfig = new SearchResultsConfig({
            context: element,
            preferences: preferences,
            onContentLoaded: function () {
                self.API.hideLoadingBar();
                self.API.resize();
            },
            onCancel: this.API.closeEdit.bind(this.API),
            onSave: function (prefs) {
                prefs.showResolved = element.find("input[name=showResolved]").is(":checked");
                prefs.showTotalWatches = element.find("input[name=showTotalWatches]").is(":checked");
                self.API.savePreferences(prefs);
            },
            gadgetAPI: self.API
        });

        var $form = searchResultsConfig.renderConfig();
        var prefix = self.API.getGadgetId() + "-";
        $form.find(".field-group:last").before(JIRA.DashboardItem.Watched.Templates.extraConfig({
            checkboxes:[
                {
                    id: prefix + "show-resolved",
                    name: "showResolved",
                    labelText: "Include resolved issues",
                    isChecked: !!preferences.showResolved
                },
                {
                    id: prefix + "show-totals",
                    name: "showTotalWatches",
                    labelText: "Show watchers per issue",
                    isChecked: !!preferences.showTotalWatches
                }
            ]
        }));

        this.API.once("afterRender", function () {
            if (element.width() < 350) {
                $form.addClass("top-label");
            }
            self.API.showLoadingBar();
        });
    };

    return DashboardItem;
});
;
;
/* module-key = 'com.atlassian.auiplugin:aui-experimental-progress-indicator', location = 'js/aui-experimental-progress-indicator.js' */
//API
(function () {
    'use strict';

    function updateProgress($progressBar, $progressBarContainer, progressValue) {
        AJS._internal.animation.recomputeStyle($progressBar);
        $progressBar.css('width', progressValue * 100 + '%');
        $progressBarContainer.attr('data-value', progressValue);
    }

    AJS.progressBars = {
        update: function (element, value) {
            var $progressBarContainer = AJS.$(element).first();
            var $progressBar = $progressBarContainer.children('.aui-progress-indicator-value');
            var valueAttribute = $progressBarContainer.attr('data-value');
            var currentProgress = parseFloat(valueAttribute) || 0;
            var isProgressNotChanged = valueAttribute && currentProgress === value;

            if (isProgressNotChanged) {
                return;
            }

            var afterTransitionEvent = 'aui-progress-indicator-after-update';
            var beforeTransitionEvent = 'aui-progress-indicator-before-update';
            var transitionEnd = 'transitionend webkitTransitionEnd';

            var isIndeterminate = !valueAttribute;

            //if the progress bar is indeterminate switch it.
            if (isIndeterminate) {
                $progressBar.css('width', 0);
            }

            if (typeof value === 'number' && value<= 1 && value >= 0) {
                $progressBarContainer.trigger(beforeTransitionEvent, [currentProgress, value]);

                //detect whether transitions are supported
                var documentBody = document.body || document.documentElement;
                var style = documentBody.style;
                var isTransitionSupported = typeof style.transition === 'string' ||
                    typeof style.WebkitTransition === 'string';

                //trigger the event after transition end if supported, otherwise just trigger it
                if (isTransitionSupported) {
                    $progressBar.one(transitionEnd, function () {
                        $progressBarContainer.trigger(afterTransitionEvent, [currentProgress, value]);
                    });
                    updateProgress($progressBar, $progressBarContainer, value);
                }
                else {
                    updateProgress($progressBar, $progressBarContainer, value);
                    $progressBarContainer.trigger(afterTransitionEvent, [currentProgress, value]);
                }
            }
            return $progressBarContainer;
        },
        setIndeterminate: function (element) {
            var $progressBarContainer = AJS.$(element).first();
            var $progressBar = $progressBarContainer.children('.aui-progress-indicator-value');

            $progressBarContainer.removeAttr('data-value');
            AJS._internal.animation.recomputeStyle($progressBarContainer);
            $progressBar.css('width', '100%');
        }
    };
}());

;
;
/* module-key = 'com.atlassian.jira.gadgets:stats-dashboard-item-resources', location = 'static/dashboarditem/stats/stats.soy' */
// This file was automatically generated from stats.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.Stats.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.Stats == 'undefined') { JIRA.DashboardItem.Stats = {}; }
if (typeof JIRA.DashboardItem.Stats.Templates == 'undefined') { JIRA.DashboardItem.Stats.Templates = {}; }


JIRA.DashboardItem.Stats.Templates.render = function(opt_data, opt_ignored) {
  var output = '<table class="aui">';
  var statTypeId__soy4 = opt_data.prefix + 'stats-category';
  var countId__soy5 = opt_data.prefix + 'stats-count';
  var percentageId__soy6 = opt_data.prefix + 'stats-percentage';
  output += '<thead><tr class="stats-gadget-table-header"><th id="' + soy.$$escapeHtml(statTypeId__soy4) + '" class="cell-type-collapsed">' + soy.$$escapeHtml(opt_data.data.statTypeDescription) + '</th><th id="' + soy.$$escapeHtml(countId__soy5) + '" class="stats-gadget-numeric">' + soy.$$escapeHtml("Count") + '</th><th id="' + soy.$$escapeHtml(percentageId__soy6) + '" colspan="2">' + soy.$$escapeHtml("Percentage") + '</th></tr></thead><tbody>';
  var rowList20 = opt_data.data.rows;
  var rowListLen20 = rowList20.length;
  for (var rowIndex20 = 0; rowIndex20 < rowListLen20; rowIndex20++) {
    var rowData20 = rowList20[rowIndex20];
    output += '<tr><td class="cell-type-collapsed" headers="' + soy.$$escapeHtml(statTypeId__soy4) + '">' + soy.$$filterNoAutoescape(rowData20.html) + '</td><td class="cell-type-collapsed stats-gadget-numeric" headers="' + soy.$$escapeHtml(countId__soy5) + '"><a href="' + soy.$$escapeHtml(rowData20.url) + '">' + soy.$$escapeHtml(rowData20.count) + '</a></td><td class="stats-gadget-progress-indicator"><div class="aui-progress-indicator" data-value="1"><span class="aui-progress-indicator-value" style="width: ' + soy.$$escapeHtml(rowData20.percentage) + '%"></span></div></td><td class="cell-type-collapsed stats-gadget-numeric" headers="' + soy.$$escapeHtml(percentageId__soy6) + '">' + soy.$$escapeHtml(rowData20.percentage) + '%</td></tr>';
  }
  output += '<tr class="stats-gadget-final-row"><td headers="' + soy.$$escapeHtml(statTypeId__soy4) + '">' + soy.$$escapeHtml("Total") + '</td><td headers="' + soy.$$escapeHtml(countId__soy5) + '" class="cell-type-collapsed stats-gadget-numeric"><a href="' + soy.$$escapeHtml(opt_data.data.filterOrProjectLink) + '">' + soy.$$escapeHtml(opt_data.data.totalIssueCount) + '</a></td><td colspan="2"></td></tr></tbody></table>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Stats.Templates.render.soyTemplateName = 'JIRA.DashboardItem.Stats.Templates.render';
}


JIRA.DashboardItem.Stats.Templates.NoStatsContent = function(opt_data, opt_ignored) {
  return '' + aui.message.info({content: "No Data Available", closeable: 'false'});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Stats.Templates.NoStatsContent.soyTemplateName = 'JIRA.DashboardItem.Stats.Templates.NoStatsContent';
}


JIRA.DashboardItem.Stats.Templates.Errors = function(opt_data, opt_ignored) {
  var output = '';
  var filterLink__soy56 = '<a href="' + soy.$$escapeHtml(opt_data.filterUrl) + '">';
  output += aui.message.error({content: '' + ((opt_data.queryType == 'project') ? '<p>' + soy.$$filterNoAutoescape(AJS.format("The project configured for this gadget could not be retrieved. Please verify it is still valid on the {0}issue navigator{1}.",filterLink__soy56,'</a>')) + '</p>' : '<p>' + soy.$$filterNoAutoescape(AJS.format("The filter configured for this gadget could not be retrieved. Please verify it is still valid on the {0}issue navigator{1}.",filterLink__soy56,'</a>')) + '</p>')});
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Stats.Templates.Errors.soyTemplateName = 'JIRA.DashboardItem.Stats.Templates.Errors';
}


JIRA.DashboardItem.Stats.Templates.Configuration = function(opt_data, opt_ignored) {
  return '' + Atlassian.DashboardItem.Common.Templates.config({fields: '' + JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.ConfigurationField({prefix: opt_data.prefix, id: 'project-filter-picker', selectionType: opt_data.preferences.type, selectionID: opt_data.preferences.id, selectionName: opt_data.preferences.name}) + JIRA.DashboardItem.Stats.Templates.statTypePicker({prefix: opt_data.prefix, id: 'stat-type', statTypes: opt_data.statTypes, value: opt_data.preferences.statType}) + JIRA.DashboardItem.Stats.Templates.sortBy({prefix: opt_data.prefix, value: opt_data.preferences.sortBy}) + JIRA.DashboardItem.Stats.Templates.sortDirection({prefix: opt_data.prefix, value: opt_data.preferences.sortDirection}) + JIRA.DashboardItem.Stats.Templates.showResolvedIssuesStats({prefix: opt_data.prefix, id: 'stat-type', statTypes: opt_data.statTypes, value: opt_data.preferences.includeResolvedIssues}) + Atlassian.DashboardItem.Common.Templates.refreshInterval({prefix: opt_data.prefix, id: 'refresh-interval', value: opt_data.preferences.refresh}), isConfigured: opt_data.preferences.isConfigured});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Stats.Templates.Configuration.soyTemplateName = 'JIRA.DashboardItem.Stats.Templates.Configuration';
}


JIRA.DashboardItem.Stats.Templates.sortBy = function(opt_data, opt_ignored) {
  var output = '';
  var prefixedId__soy104 = opt_data.prefix + 'stats-sort-by';
  output += '<div class="field-group"><label for="' + soy.$$escapeHtml(prefixedId__soy104) + '">' + soy.$$escapeHtml("Sort By") + '</label><select class="select" id="' + soy.$$escapeHtml(prefixedId__soy104) + '" name="sortBy"><option value="natural"' + ((opt_data.value == 'natural') ? ' selected="selected"' : '') + '>' + soy.$$escapeHtml("Natural") + '</option><option value="total"' + ((opt_data.value == 'total') ? ' selected="selected"' : '') + '>' + soy.$$escapeHtml("Total") + '</option></select><div class="description">' + soy.$$escapeHtml("Sort by row total or natural field order.") + '</div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Stats.Templates.sortBy.soyTemplateName = 'JIRA.DashboardItem.Stats.Templates.sortBy';
}


JIRA.DashboardItem.Stats.Templates.sortDirection = function(opt_data, opt_ignored) {
  var output = '';
  var prefixedId__soy127 = opt_data.prefix + 'stats-sort-direction';
  output += '<div class="field-group"><label for="' + soy.$$escapeHtml(prefixedId__soy127) + '">' + soy.$$escapeHtml("Sort Direction") + '</label><select class="select" id="' + soy.$$escapeHtml(prefixedId__soy127) + '" name="sortDirection"><option value="asc"' + ((opt_data.value == 'asc') ? ' selected="selected"' : '') + '>' + soy.$$escapeHtml("Ascending") + '</option><option value="desc"' + ((opt_data.value == 'desc') ? ' selected="selected"' : '') + '>' + soy.$$escapeHtml("Descending") + '</option></select></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Stats.Templates.sortDirection.soyTemplateName = 'JIRA.DashboardItem.Stats.Templates.sortDirection';
}


JIRA.DashboardItem.Stats.Templates.showResolvedIssuesStats = function(opt_data, opt_ignored) {
  var output = '';
  var prefixedId__soy148 = opt_data.prefix + 'stats-show-resolved';
  output += '<div class="field-group"><label for="' + soy.$$escapeHtml(prefixedId__soy148) + '">' + soy.$$escapeHtml("Show Resolved Issue Statistics") + '</label><select class="select" id="' + soy.$$escapeHtml(prefixedId__soy148) + '" name="includeResolvedIssues"><option value="false"' + ((opt_data.value == false) ? ' selected="selected"' : '') + '>' + soy.$$escapeHtml("No") + '</option><option value="true"' + ((opt_data.value == true) ? ' selected="selected"' : '') + '>' + soy.$$escapeHtml("Yes") + '</option></select><div class="description">' + soy.$$escapeHtml("Include resolved issues in the set of issues from which statistics are calculated.") + '</div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Stats.Templates.showResolvedIssuesStats.soyTemplateName = 'JIRA.DashboardItem.Stats.Templates.showResolvedIssuesStats';
}


JIRA.DashboardItem.Stats.Templates.statTypePicker = function(opt_data, opt_ignored) {
  var output = '';
  var prefixedId__soy171 = opt_data.prefix + opt_data.id;
  output += '<div class="field-group"><label for="' + soy.$$escapeHtml(prefixedId__soy171) + '">' + soy.$$escapeHtml("Statistic Type") + '</label><select id="' + soy.$$escapeHtml(prefixedId__soy171) + '" name="statType" class="select">';
  var typeList179 = opt_data.statTypes;
  var typeListLen179 = typeList179.length;
  for (var typeIndex179 = 0; typeIndex179 < typeListLen179; typeIndex179++) {
    var typeData179 = typeList179[typeIndex179];
    output += '<option value="' + soy.$$escapeHtml(typeData179.value) + '"' + ((typeData179.value == opt_data.value) ? ' selected="selected"' : '') + '>' + soy.$$escapeHtml(typeData179.label) + '</option>';
  }
  output += '</select><div class="error"></div><div class="description">' + soy.$$escapeHtml("Select which type of statistic to display for this filter.") + '</div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Stats.Templates.statTypePicker.soyTemplateName = 'JIRA.DashboardItem.Stats.Templates.statTypePicker';
}


JIRA.DashboardItem.Stats.Templates.ErrorRenderingConfiguration = function(opt_data, opt_ignored) {
  return '' + aui.message.error({titleContent: "Oops - an error has occurred", content: '', closeable: 'false'});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Stats.Templates.ErrorRenderingConfiguration.soyTemplateName = 'JIRA.DashboardItem.Stats.Templates.ErrorRenderingConfiguration';
}


JIRA.DashboardItem.Stats.Templates.title = function(opt_data, opt_ignored) {
  return soy.$$escapeHtml("Issue Statistics") + ': ' + soy.$$escapeHtml(opt_data.data.filterOrProjectName) + ' (' + soy.$$escapeHtml(opt_data.data.statTypeDescription) + ')';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Stats.Templates.title.soyTemplateName = 'JIRA.DashboardItem.Stats.Templates.title';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:stats-dashboard-item-resources', location = 'static/dashboarditem/stats/stats.js' */
define("jira-dashboard-items/stats", [
    'jquery',
    'underscore',
    'jira-dashboard-items/components/autocomplete/project-filter-autocomplete',
    'jira-dashboard-items/common-functions'
], function(
    $,
    _,
    ProjectFilterAutoComplete,
    CommonFunctions
) {
    'use strict';

    /**
     *
     * @param {InlineGadgetAPI} API
     * @param {Object} [options] for gadget
     * @constructor
     */
    var DashboardItem = function(API, options) {
        this.API = API;
        this.options = options || {};
    };

    /**
     * Extract type and ID fields from projectOrFilterId and add them to the preferences object.
     * @param {Object} [preferences] user prefs for this gadget
     */
    function extractFieldsFromProjectOrFilterId(preferences) {
        if (preferences.projectOrFilterId && !(preferences.type && preferences.id)) {
            var projectOrFilterSplit = preferences.projectOrFilterId.split("-");
            preferences.type = projectOrFilterSplit[0];
            preferences.id = projectOrFilterSplit[1];
        }
    }

    /**
     * Extract data from a form using jQuery.serializeArray. An internal whitelist is used to control data read.
     * Note: 'refresh-interval' is mapped to 'refresh' here
     * @param {Object} [$form]
     * @returns {Object} a map of preferences, where keys are the field names and values are the input values
     * @private
     */
    function getPreferencesObject($form) {
        var formData = $form.serializeArray(),
                paramsWhitelist = ['name', 'type', 'id', 'statType', 'refresh-interval', 'sortBy', 'sortDirection', 'includeResolvedIssues'],
                preferences = {};

        _.each( formData, function(element) {
            if( _.indexOf(paramsWhitelist, element.name) === -1 )
            {
                return;
            }
            if (element.name === 'refresh-interval') {
                preferences['refresh'] = element.value;
            }
            else {
                preferences[element.name] = element.value;
            }
        });

        return preferences;
    }

    /**
     * Construct a new projectOfFilterId and add it to the preferences object
     * @param {Object} [preferences] the preferences object
     */
    function updateProjectOrFilterId(preferences) {
        preferences.projectOrFilterId = preferences.type + "-" + preferences.id;
    }

    function getTitle(response) {
        var title = '';
        title += "Issue Statistics" + ': ';
        title += response.filterOrProjectName + ' (' + response.statTypeDescription + ')';
        return title;
    }

    /**
     * Render the configured stats gadget.
     * @param {node} element to apply gadget to
     * @param {Object} preferences for gadget that have been configured.
     */
    DashboardItem.prototype.render = function(element, preferences) {

        var gadget = this;
        var $gadgetElement = $(element);
        $gadgetElement.addClass('stats-gadget');

        gadget.API.showLoadingBar();

        extractFieldsFromProjectOrFilterId(preferences);

        gadget.API.initRefresh(preferences, _.bind(gadget.render, gadget, element, preferences));

        preferences = CommonFunctions.projectFilterBackwardCompatible(preferences);

        $.ajax({
            method: "GET",
            url: AJS.contextPath() + '/rest/gadget/1.0/stats/generate', // use the old opensocial gadget's rest endpoint
            dataType: "json",
            data: {
                includeResolvedIssues: preferences.includeResolvedIssues,
                projectOrFilterId: preferences.type + "-" + preferences.id,
                sortBy: preferences.sortBy,
                sortDirection: preferences.sortDirection,
                statType: preferences.statType
            }
        }).done(function(response) {

            if (!response.totalIssueCount || response.totalIssueCount === 0) {
                $gadgetElement.html(JIRA.DashboardItem.Stats.Templates.NoStatsContent());
            } else {

                // Random prefix to avoid collisions with other instances of this gadget
                var prefix = gadget.API.getGadgetId() + "-";

                $gadgetElement.html(JIRA.DashboardItem.Stats.Templates.render({
                    data: response,
                    prefix: prefix
                }));
            }
            gadget.API.setTitle(getTitle(response));

        }).fail(function(message) {
            var filterUrl = AJS.contextPath() + "/issues/";
            if(preferences.type === "project") {
                filterUrl += "?jql=" + encodeURIComponent("project = "+ preferences.id);
            } else {
                filterUrl += "?filter=" + encodeURIComponent(preferences.id);
            }

            $gadgetElement.html(JIRA.DashboardItem.Stats.Templates.Errors({
                queryType: preferences.type,
                filterUrl: filterUrl
            }));
        }).always(function() {
            gadget.API.hideLoadingBar();
            gadget.API.resize();
        });
    };

    /**
     * Render the configuration screen for the stats gadget
     * @param {JQuery} element to render into
     * @param {Object} preferences for object.
     */
    DashboardItem.prototype.renderEdit = function(element, preferences) {
        var gadget = this;
        var $gadgetElement = $(element);
        $gadgetElement.addClass('stats-gadget');

        gadget.API.showLoadingBar();

        preferences = CommonFunctions.projectFilterBackwardCompatible(preferences);

        $.ajax({
            method: "GET",
            url: AJS.contextPath() + "/rest/gadget/1.0/statTypes" // use the old opensocial gadget's rest endpoint
        }).done(function(data) {

            // Random prefix to avoid collisions with other instances of this gadget
            var prefix = gadget.API.getGadgetId()+ "-";

            extractFieldsFromProjectOrFilterId(preferences);

            if (!preferences.name && preferences.type && preferences.id) {
                preferences.name = preferences.type + "-" + preferences.id;
            }

            // mark preferences.name as already escaped so soy doesn't re-escape it
            if (preferences.name) {
                preferences.name = soydata.VERY_UNSAFE.ordainSanitizedHtml(preferences.name);
            }

            $gadgetElement.html(JIRA.DashboardItem.Stats.Templates.Configuration({
                prefix: prefix,
                statTypes: data.stats,
                preferences: preferences
            }));

            var projectFilterOptions = {
                fieldID: prefix + "project-filter-picker",
                parentElement: $gadgetElement,
                maxHeight: 140
            };

            //Mostly used for testing where we don't want a delay;
            if (gadget.options.delay) {
                projectFilterOptions.delay = gadget.options.delay;
            }

            ProjectFilterAutoComplete(projectFilterOptions);

            var form = $("form", $gadgetElement);

            var cancelButton = $(".cancel", form);
            if (cancelButton) {
                cancelButton.click(function() {
                    gadget.API.closeEdit();
                });
            }

            function completeValidation(preferences, form) {
                if (!preferences.id || !preferences.type) {
                    $(".projectOrFilter-error", form).text("No project or filter specified.").show();
                    return false;
                }

                return true;
            }

            form.on("submit",function(e){
                e.preventDefault();

                var $form = $(e.target);

                var preferences = getPreferencesObject($form);
                updateProjectOrFilterId(preferences);

                if (completeValidation(preferences, $form)) {
                    gadget.API.savePreferences(preferences);
                }
            });

        }).fail(function() {
            $gadgetElement.html(JIRA.DashboardItem.Stats.Templates.ErrorRenderingConfiguration());
        }).always(function() {
            gadget.API.hideLoadingBar();
            gadget.API.resize();
        });
    };

    return DashboardItem;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:favourite-filters-dashboard-item-resources', location = 'static/dashboarditem/favourite-filters/FavouriteFilters.soy' */
// This file was automatically generated from FavouriteFilters.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.FavouriteFilters.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.FavouriteFilters == 'undefined') { JIRA.DashboardItem.FavouriteFilters = {}; }
if (typeof JIRA.DashboardItem.FavouriteFilters.Templates == 'undefined') { JIRA.DashboardItem.FavouriteFilters.Templates = {}; }


JIRA.DashboardItem.FavouriteFilters.Templates.favouriteFilters = function(opt_data, opt_ignored) {
  var output = '<div class="favourite-filters-item"><div class="favourite-filters-view"><div class="filter-list-content"><table class="aui"><tbody>';
  var filterList4 = opt_data.filters;
  var filterListLen4 = filterList4.length;
  for (var filterIndex4 = 0; filterIndex4 < filterListLen4; filterIndex4++) {
    var filterData4 = filterList4[filterIndex4];
    var filterLink__soy5 = soy.$$escapeHtml("/jira") + '/issues/?filter=' + soy.$$escapeHtml(filterData4.value);
    output += '<tr><td><a href="' + soy.$$escapeHtml(filterLink__soy5) + '" ' + ((filterData4.description) ? 'title="' + soy.$$escapeHtml(filterData4.description) + '"' : '') + '>' + soy.$$escapeHtml(filterData4.label) + '</a></td>' + ((opt_data.showCounts) ? '<td class="counts">' + aui.badges.badge({text: '' + soy.$$escapeHtml(filterData4.count)}) + '</td>' : '') + '</tr>';
  }
  output += '</tbody></table></div>' + JIRA.DashboardItem.FavouriteFilters.Templates.configOptions(null) + '</div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.FavouriteFilters.Templates.favouriteFilters.soyTemplateName = 'JIRA.DashboardItem.FavouriteFilters.Templates.favouriteFilters';
}


JIRA.DashboardItem.FavouriteFilters.Templates.noFavouriteFilters = function(opt_data, opt_ignored) {
  return '<div class="favourite-filters-item"><div class="empty-container"><p class="empty-msg">' + soy.$$escapeHtml("Looks like you haven\x27t selected any favourite filters yet. You can either create a new filter, or add an existing filter to display them here on the dashboard.") + '</p><div>' + aui.buttons.button({text: '' + soy.$$escapeHtml("Create Filter"), href: soy.$$escapeHtml("/jira") + '/issues/?jql='}) + aui.buttons.button({text: '' + soy.$$escapeHtml("Manage Filters"), type: 'link', href: soy.$$escapeHtml("/jira") + '/secure/ManageFilters.jspa'}) + '</div></div></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.FavouriteFilters.Templates.noFavouriteFilters.soyTemplateName = 'JIRA.DashboardItem.FavouriteFilters.Templates.noFavouriteFilters';
}


JIRA.DashboardItem.FavouriteFilters.Templates.errorResult = function(opt_data, opt_ignored) {
  return '<div class="favourite-filters-item"><div class="empty-container">' + aui.message.error({content: '<p>' + soy.$$escapeHtml("Looks like something went wrong retrieving your filters :(.  Please try reloading this dashboard.") + '</p>'}) + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.FavouriteFilters.Templates.errorResult.soyTemplateName = 'JIRA.DashboardItem.FavouriteFilters.Templates.errorResult';
}


JIRA.DashboardItem.FavouriteFilters.Templates.configOptions = function(opt_data, opt_ignored) {
  return '<div class="config-options"><ul class="operations-list"><li><a href="' + soy.$$escapeHtml("/jira") + '/issues/?jql=">' + soy.$$escapeHtml("Create Filter") + '</a>&nbsp;</li><li><a href="' + soy.$$escapeHtml("/jira") + '/secure/ManageFilters.jspa">' + soy.$$escapeHtml("Manage Filters") + '</a></li></ul></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.FavouriteFilters.Templates.configOptions.soyTemplateName = 'JIRA.DashboardItem.FavouriteFilters.Templates.configOptions';
}


JIRA.DashboardItem.FavouriteFilters.Templates.configuration = function(opt_data, opt_ignored) {
  return '' + Atlassian.DashboardItem.Common.Templates.config({fields: '' + aui.form.checkboxField({legendContent: '', fields: opt_data.checkboxes}) + Atlassian.DashboardItem.Common.Templates.refreshInterval({prefix: opt_data.prefix, id: 'refresh', value: opt_data.preferences.refresh}), isConfigured: opt_data.preferences.isConfigured});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.FavouriteFilters.Templates.configuration.soyTemplateName = 'JIRA.DashboardItem.FavouriteFilters.Templates.configuration';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:favourite-filters-dashboard-item-resources', location = 'static/dashboarditem/favourite-filters/FavouriteFilters.js' */
define("jira-dashboard-items/favourite-filters", [
    'jquery',
    'underscore'
], function(
    $,
    _
) {
    var DashboardItem = function(API) {
        this.API = API;
    };

    /**
     * Called to render the view for a fully configured dashboard item.
     *
     * @param context The surrounding <div/> context that this items should render into.
     * @param preferences The user preferences saved for this dashboar item
     */
    DashboardItem.prototype.render = function (context, preferences) {
        var $element = $(context);
        var self = this;
        self.API.showLoadingBar();

        $.ajax({
            method: "GET",
            url: AJS.contextPath() + '/rest/gadget/1.0/favfilters',
            dataType: "json",
            data: {
                showCounts : preferences.showCounts
            }
        }).done(function(response) {
            if(response.filters.length > 0) {
                $element.html(JIRA.DashboardItem.FavouriteFilters.Templates.favouriteFilters({
                    filters:response.filters,
                    showCounts: preferences.showCounts
                }));
            } else {
                $element.html(JIRA.DashboardItem.FavouriteFilters.Templates.noFavouriteFilters());
            }
        }).fail(function() {
            $element.html(JIRA.DashboardItem.FavouriteFilters.Templates.errorResult());
        }).always(function() {
            self.API.hideLoadingBar();
            self.API.resize();
        });

        self.API.initRefresh(preferences, _.bind(self.render, self, context, preferences));
    };

    /**
     * Called to render the configuration form for this dashboard item if preferences.isConfigured
     * has not been set yet.
     *
     * @param context The surrounding <div/> context that this items should render into.
     * @param preferences The user preferences saved for this dashboard item
     */
    DashboardItem.prototype.renderEdit = function (context, preferences) {
        var self = this;
        var $context = $(context);

        var prefix = self.API.getGadgetId() + "-";
        $context.html(JIRA.DashboardItem.FavouriteFilters.Templates.configuration({
            prefix: prefix,
            preferences: preferences,
            checkboxes:[{
                id: prefix + "show-counts",
                name: "showCounts",
                labelText: "Show issue counts",
                descriptionText: "Display the number issues the filter returns (may impact performance).",
                isChecked: !!preferences.showCounts
            }]
        }));

        var form = $("form", $context);

        form.on("submit", function (e) {
            e.preventDefault();
            self.API.resize();

            var preferences = {
                showCounts: form.find("input[name=showCounts]").is(":checked"),
                refresh: self.API.getRefreshFieldValue()
            };

            self.API.savePreferences(preferences);
        });

        var cancelButton = $(".cancel", form);
        cancelButton.click(function () {
            self.API.closeEdit();
        });

        self.API.resize();
        this.API.once("afterRender", function () {
            self.API.resize();
        });
    };

    return DashboardItem;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:labels-dashboard-item-resources', location = 'static/dashboarditem/labels/Labels.soy' */
// This file was automatically generated from Labels.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.Labels.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.Labels == 'undefined') { JIRA.DashboardItem.Labels = {}; }
if (typeof JIRA.DashboardItem.Labels.Templates == 'undefined') { JIRA.DashboardItem.Labels.Templates = {}; }


JIRA.DashboardItem.Labels.Templates.Labels = function(opt_data, opt_ignored) {
  var output = '<div class="labels-dashboard-item labels-display">';
  var groupList4 = opt_data.groups;
  var groupListLen4 = groupList4.length;
  for (var groupIndex4 = 0; groupIndex4 < groupListLen4; groupIndex4++) {
    var groupData4 = groupList4[groupIndex4];
    output += JIRA.DashboardItem.Labels.Templates.LabelGroup({key: groupData4.key, labels: groupData4.labels});
  }
  output += '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Labels.Templates.Labels.soyTemplateName = 'JIRA.DashboardItem.Labels.Templates.Labels';
}


JIRA.DashboardItem.Labels.Templates.LabelGroup = function(opt_data, opt_ignored) {
  var output = '<div class="label-group"><h3>' + soy.$$escapeHtml(opt_data.key) + '</h3><p class="label-alphabetical">';
  var labelList14 = opt_data.labels;
  var labelListLen14 = labelList14.length;
  for (var labelIndex14 = 0; labelIndex14 < labelListLen14; labelIndex14++) {
    var labelData14 = labelList14[labelIndex14];
    output += '<a class="aui-label" href="' + soy.$$escapeHtml("/jira" + labelData14.searchUrl) + '">' + soy.$$escapeHtml(labelData14.label) + '</a>';
  }
  output += '</p></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Labels.Templates.LabelGroup.soyTemplateName = 'JIRA.DashboardItem.Labels.Templates.LabelGroup';
}


JIRA.DashboardItem.Labels.Templates.Configuration = function(opt_data, opt_ignored) {
  return '<div class="labels-dashboard-item labels-config">' + Atlassian.DashboardItem.Common.Templates.config({fields: '' + JIRA.DashboardItem.Labels.Templates.ProjectSelectPicker({prefixedId: opt_data.prefix + 'projects-select', label: opt_data.projectsLabel, projects: opt_data.projects, currentValue: opt_data.preferences.projectid}) + JIRA.DashboardItem.Labels.Templates.FieldSelectPicker({prefixedId: opt_data.prefix + 'labels-field', fields: opt_data.fields, currentValue: opt_data.preferences.fieldId}) + Atlassian.DashboardItem.Common.Templates.refreshInterval({prefix: opt_data.prefix, id: 'refresh-interval', value: opt_data.preferences.refresh}), isConfigured: opt_data.preferences.isConfigured});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Labels.Templates.Configuration.soyTemplateName = 'JIRA.DashboardItem.Labels.Templates.Configuration';
}


JIRA.DashboardItem.Labels.Templates.NoLabels = function(opt_data, opt_ignored) {
  return '<div class="labels-dashboard-item">' + aui.message.info({titleContent: "This field does not contain any labels yet!", content: "When users start adding labels to this field, the labels will appear here."}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Labels.Templates.NoLabels.soyTemplateName = 'JIRA.DashboardItem.Labels.Templates.NoLabels';
}


JIRA.DashboardItem.Labels.Templates.Error = function(opt_data, opt_ignored) {
  return '<div class="labels-dashboard-item">' + aui.message.error({titleContent: "Oops - an error has occurred", content: '', closeable: 'false'}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Labels.Templates.Error.soyTemplateName = 'JIRA.DashboardItem.Labels.Templates.Error';
}


JIRA.DashboardItem.Labels.Templates.FieldSelectPicker = function(opt_data, opt_ignored) {
  return '<div class="field-group">' + JIRA.DashboardItem.Labels.Templates.SelectPicker({prefixedId: opt_data.prefixedId, label: "Field", name: 'fieldId', options: opt_data.fields, currentValue: opt_data.currentValue}) + '<div class="error"></div><div class="description">' + soy.$$escapeHtml("Select the field which you wish to show labels from.") + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Labels.Templates.FieldSelectPicker.soyTemplateName = 'JIRA.DashboardItem.Labels.Templates.FieldSelectPicker';
}


JIRA.DashboardItem.Labels.Templates.ProjectSelectPicker = function(opt_data, opt_ignored) {
  return '<div class="field-group">' + JIRA.DashboardItem.Labels.Templates.SelectPicker({prefixedId: opt_data.prefixedId, label: opt_data.label, name: 'projectid', options: opt_data.projects, currentValue: opt_data.currentValue}) + '<div class="error"></div><div class="description">' + soy.$$escapeHtml("Show Labels from Project") + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Labels.Templates.ProjectSelectPicker.soyTemplateName = 'JIRA.DashboardItem.Labels.Templates.ProjectSelectPicker';
}


JIRA.DashboardItem.Labels.Templates.SelectPicker = function(opt_data, opt_ignored) {
  var output = '<label for="' + soy.$$escapeHtml(opt_data.prefixedId) + '">' + soy.$$escapeHtml(opt_data.label) + '</label><select id="' + soy.$$escapeHtml(opt_data.prefixedId) + '" name="' + soy.$$escapeHtml(opt_data.name) + '" class="select">';
  var optionList85 = opt_data.options;
  var optionListLen85 = optionList85.length;
  for (var optionIndex85 = 0; optionIndex85 < optionListLen85; optionIndex85++) {
    var optionData85 = optionList85[optionIndex85];
    output += '<option value="' + soy.$$escapeHtml(optionData85.value) + '"' + ((optionData85.value == opt_data.currentValue) ? ' selected="selected"' : '') + '>' + soy.$$escapeHtml(optionData85.label) + '</option>';
  }
  output += '</select>';
  return output;
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Labels.Templates.SelectPicker.soyTemplateName = 'JIRA.DashboardItem.Labels.Templates.SelectPicker';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:labels-dashboard-item-resources', location = 'static/dashboarditem/labels/Labels.js' */
define('jira-dashboard-items/labels', [
    'jquery',
    'underscore',
    'jira-dashboard-items/components/autocomplete/project-filter-autocomplete',
    'jira-dashboard-items/common-functions'
], function (
    $,
    _,
    ProjectFilterAutocomplete,
    CommonFunctions
) {
    'use strict';

    var DashboardItem = function (API, options) {
        this.API = API;
        this.options = options || {};
    };

    /**
     * Extract data from a form using jQuery.serializeArray. An internal whitelist is used to control data read.
     * Note: 'refresh-interval' is mapped to 'refresh' here
     * @param {Object} [$form]
     * @returns {Object} a map of preferences, where keys are the field names and values are the input values
     * @private
     */
    function getPreferencesObject($form) {
        var formData = $form.serializeArray();
        var paramsWhitelist = ['name', 'type', 'id', 'refresh-interval', 'fieldId', 'projectid'];
        var preferences = {};

        _.each(formData, function (element) {
            if (_.indexOf(paramsWhitelist, element.name) === -1) {
                return;
            }

            if (element.name === 'refresh-interval') {
                preferences.refresh = true;
            }
            else {
                preferences[element.name] = element.value;
            }
        });

        return preferences;
    }

    function ajaxRequestResolved() {
        this.API.resize();
        this.API.hideLoadingBar();
    }

    function displayError($element) {
        $element.html(JIRA.DashboardItem.Labels.Templates.Error());
    }

    DashboardItem.prototype.render = function (element, preferences) {
        this.API.showLoadingBar();
        this.API.initRefresh(preferences, _.bind(this.render, this, element, preferences));

        preferences = CommonFunctions.projectFilterBackwardCompatible(preferences);

        var endPoint = '/rest/gadget/1.0/labels/gadget/' + preferences.projectid + '/' +
            encodeURIComponent(preferences.fieldId);

        $.ajax({
            method: 'GET',
            url: AJS.contextPath() + endPoint,
            dataType: 'json'
        }).done(_.bind(displayLabelsDashboardItem, this, $(element))).fail(function(data) {
            if (data.status === 404) {
                $(element).html(JIRA.DashboardItem.Labels.Templates.NoLabels());
            } else {
                displayError($(element));
            }
        }).always(_.bind(ajaxRequestResolved, this));

        function displayLabelsDashboardItem($element, data) {
            // No label data for this field in this project
            if (data.groups.length === 0 || (data.groups.length === 1 && data.groups[0].labels.length === 0)) {
                $element.html(JIRA.DashboardItem.Labels.Templates.NoLabels());
                return;
            }

            // Display the labels
            $element.html(JIRA.DashboardItem.Labels.Templates.Labels({
                groups: data.groups
            }));

            // Set the gadget title
            var field = data.field;
            var project = data.project;
            if (field && project) {
                this.API.setTitle(AJS.format("Labels: {0} in {1}", field, project));
            }
            else {
                this.API.setTitle("Labels Gadget");
            }
        }
    };

    DashboardItem.prototype.renderEdit = function (element, preferences) {
        var $gadgetElement = $(element);

        this.API.showLoadingBar();
        preferences = CommonFunctions.projectFilterBackwardCompatible(preferences);

        var fieldsAjaxRequest = $.ajax(AJS.contextPath() + '/rest/gadget/1.0/labels/gadget/fields');
        var projectsAjaxRequest = $.ajax(AJS.contextPath() + '/rest/gadget/1.0/filtersAndProjects?showFilters=false');

        // It's not explicit from `$.when` that `fieldsAjaxRequest` will begin or end before `projectsAjaxRequest`.
        // We will enforce this in the `displayConfigurationPanelForMultipleQueries` callback.
        $.when(fieldsAjaxRequest, projectsAjaxRequest)
            .done(_.bind(displayConfigurationPanelForMultipleQueries, this, $gadgetElement))
            .fail(_.partial(displayError, $gadgetElement))
            .always(_.bind(ajaxRequestResolved, this));

        function displayConfigurationPanelForMultipleQueries($gadgetElement, fieldsRequest, projectsRequest) {
            // Enforce that `fieldsRequest` is genuinely for the fields request, and `projectsRequest` is actually for projects.
            // If either of them contain the data for the other, swap the variable names.
            if ((!fieldsRequest[0].labelFields && projectsRequest[0].labelFields) ||
                !projectsRequest[0].label && fieldsRequest[0].label) {
                var temp = projectsRequest;
                projectsRequest = fieldsRequest;
                fieldsRequest = temp;
            }

            if (!fieldsRequest[0].labelFields || !projectsRequest[0].label || !projectsRequest[0].options) {
                // No data retrieved.
                displayError($gadgetElement);
                return;
            }

            // Create a prefix from the gadget's id to prevent collisions with other instances of this dashboard item.
            var prefix = this.API.getGadgetId() + "-";

            // `fieldsRequest` and `projectsRequest` are arrays consisting of the response object,
            // the status, and a jqXHR object.
            // See the last example at http://api.jquery.com/jQuery.when/.
            var fieldsData = fieldsRequest[0].labelFields;
            var projectsSelectionLabel = projectsRequest[0].label;
            var projectsSelectionOptions = projectsRequest[0].options;

            // Load the template, and display the user's projects and custom labels
            var config = JIRA.DashboardItem.Labels.Templates.Configuration({
                prefix: prefix,
                preferences: preferences,
                fields: fieldsData,
                projectsLabel: AJS.I18n.getText(projectsSelectionLabel),
                projects: projectsSelectionOptions
            });

            $gadgetElement.html(config);

            var form = $("form", $gadgetElement);

            var cancelButton = $(".cancel", form);
            if (cancelButton) {
                cancelButton.click(_.bind(function () {
                    this.API.closeEdit();
                }, this));
            }

            form.on("submit", _.bind(function (e) {
                e.preventDefault();

                var $form = $(e.target);
                var preferences = getPreferencesObject($form);

                if (completeValidation(preferences, $form)) {
                    this.API.savePreferences(preferences);
                }
            }, this));
        }

        function completeValidation(preferences, form) {
            if (!preferences.projectid || !preferences.fieldId) {
                $(".projectOrFilter-error", form).text("No project or filter specified.").show();
                return false;
            }

            return true;
        }
    };

    return DashboardItem;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:colorable', location = 'static/components/charts/components/Colorable.js' */
/**
 * Extending Colorable indicates that a component can map data to colors.
 *
 * @module Colorable
 */
define('jira-dashboard-items/components/charts/components/colorable', [
    'jira-dashboard-items/lib/c3',
    'jira-dashboard-items/lib/d3'
], function(
    c3,
    d3
) {
    'use strict';

    return function() {
        var DEFAULT_COLOR_VALUE = 4;
        var DEFAULT_COLOR_RANGE = ['red', 'blue'];

        return c3.component('colorable')
            .extend(c3.withData())
            .extend({
                color: function() {
                    var colorScale = this.colorScale();
                    var colorAccessor = this.colorAccessor();

                    return function(d, i) {
                        return colorScale(colorAccessor(d, i));
                    };
                },
                colorAccessor: c3.prop(function() { return DEFAULT_COLOR_VALUE; }),
                colorScaleConstructor: c3.inherit('colorScaleConstructor', d3.scale.linear),
                colorDomain: c3.inherit('colorDomain').onDefault(function() {
                    if (c3.isEmpty(this.data())) return;

                    var min = c3.checkIsNumber(d3.min(this.data(), this.colorAccessor()));
                    var max = c3.checkIsNumber(d3.max(this.data(), this.colorAccessor()));
                    return [min, max];
                }),
                colorRange: c3.inherit('colorRange').onDefault(function() {
                    return DEFAULT_COLOR_RANGE;
                }),
                colorScale: function() {
                    return this.colorScaleConstructor()()
                        .domain(this.colorDomain())
                        .range(this.colorRange());
                }
            });
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:colored-circle-plot', location = 'static/components/charts/components/ColoredCirclePlot.js' */
/**
 * A circle plot component built on c3's circle plot that allows coloring of the circles.
 *
 * @module ColoredCirclePlot
 */
define('jira-dashboard-items/components/charts/components/colored-circle-plot', [
    'jquery',
    'jira-dashboard-items/components/charts/components/colorable',
    'jira-dashboard-items/lib/d3',
    'jira-dashboard-items/lib/c3'
], function(
    $,
    Colorable,
    d3,
    c3
) {
    'use strict';

    return function () {
        var MIN_RADIUS_RANGE = 10;
        var MAX_RADIUS_RANGE = 30;
        var RADIUS_DATA_VALUE = 4;

        return c3.component('colored-circle-plot')
            .extend(c3.circlePlot())
            .extend(Colorable())
            .update(function (event) {
                event.selection
                    .attr('cx', this.x())
                    .attr('cy', this.y())
                    .attr('r', this.radius())
                    .attr('fill', this.color())
                    .attr('stroke', this.strokeColor());
            })
            .extend({
                radius: function () {
                    var radiusScale = this.radiusScale();
                    var radiusAccessor = this.radiusAccessor();

                    return function (d, i) {
                        return radiusScale(radiusAccessor(d, i));
                    };
                },
                radiusAccessor: c3.prop(function () { return RADIUS_DATA_VALUE; }),
                radiusDomain: c3.inherit('radiusDomain').onDefault(function () {
                    if (c3.isEmpty(this.data())) return;

                    var min = c3.checkIsNumber(d3.min(this.data(), this.radiusAccessor()));
                    var max = c3.checkIsNumber(d3.max(this.data(), this.radiusAccessor()));

                    return [min, max];
                }),
                radiusRange: c3.inherit('radiusRange').onDefault(function () {
                    return [MIN_RADIUS_RANGE, MAX_RADIUS_RANGE];
                }),
                radiusScaleConstructor: c3.inherit('radiusScaleConstructor', d3.scale.linear),
                radiusScale: function () {
                    return this.radiusScaleConstructor()()
                        .domain(this.radiusDomain())
                        .range(this.radiusRange());
                },
                strokeColor: function () {
                    var fillColor = this.color();
                    return function (d, i) { return d3.rgb(fillColor(d, i)).darker(); };
                }
            });
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:bubble-chart-component', location = 'static/components/charts/bubble-chart/BubbleChartComponent.js' */
define('jira-dashboard-items/components/charts/bubble-chart/bubble-chart-component', [
    'jquery',
    'backbone',
    'jira-dashboard-items/components/charts/components/chart',
    'jira-dashboard-items/components/charts/components/colored-circle-plot',
    'jira-dashboard-items/lib/d3',
    'jira-dashboard-items/lib/c3'
], function(
    $,
    Backbone,
    Chart,
    ColoredCirclePlot,
    d3,
    c3
) {
    'use strict';

    var BubbleChartComponent = Backbone.View.extend({
        template: JIRA.DashboardItem.BubbleChartComponent.Templates.Container,

        initialize: function(options) {
            this.options = options || {};
            this.colors = options.colors || ['red', 'blue'];
            this.model = options.model;

            this.xAxisTitleLabel = this.model.get('xAxisLabel');
            this.yAxisTitleLabel = this.model.get('yAxisLabel');
            this.xScaleConstructor = (this.model.get('useLogarithmicScale')) ? d3.scale.log : d3.scale.linear;
            this.yScaleConstructor = (this.model.get('useLogarithmicScale')) ? d3.scale.log : d3.scale.linear;

            this.AMOUNT_TO_INCREASE_CHART_TO_PREVENT_CLIPPING = 10;
            this.X_TITLE_LABEL_BUFFER = 25;
            this.HOVER_STATE_CLASS_NAME = 'hovered';
            this.SELECTED_CIRCLE_CLASS = 'selected';
            this.BACKING_CIRCLE_CLASS = 'backing';
            this.TOOLTIP_DELAY_APPEAR_TIME = 0;
            this.TOOLTIP_CLASS = 'bubble-chart-component-tooltip';

            this.inlineDialog = null;
        },

        render: function() {
            var documentClick = this._handleDocumentClick.bind(this);
            var showLayer = this._handleShowLayer.bind(this);
            $(document).on('click', documentClick);
            $(document).on('showLayer', showLayer);

            // Remove event handlers when the gadget is destroyed
            this.$el.on('remove', function() {
                $(document).off('click', documentClick);
                $(document).off('showLayer', showLayer);
            }.bind(this));

            this.listenTo(this.model, {
                'change:highlightedCircle': this._changeHighlight,
                'change:selectedCircle':  this._changeSelection
            });

            this.$el.html(this.template({ id: this.options.id }));

            var bubblePlot = this._createBubblePlot();
            var bubblePlotGraph = c3.layerable()
                .data(this.model.get('data'))
                .addLayer('bubble-plot', bubblePlot);
            var chart = this._createChart(bubblePlotGraph);
            var $chartElement = this.$('.bubble-chart-component-plot');
            this._setInitialHeightOfChart($chartElement);

            var svg = d3.select($chartElement.get(0));
            svg.call(chart);

            this._preventClippingTheTopMostLabelOnYAxis($chartElement);
            this._addGridLinesToChart($chartElement);
            this._removeTicksWithoutText($chartElement);
        },

        /**
         * Get the circle from the DOM corresponding to the given issue key
         * @param issueKey The issue key, e.g. JC-426
         * @returns {DOM Object}
         * @private
         */
        _circleForIssueKey: function(issueKey) {
            return this.$('circle:data("' + issueKey + '")').get(0);
        },

        /**
         * Remove any backing circle currently in the component
         * @private
         */
        _removeAllBackingCircles: function() {
            this.$('circle.' + this.BACKING_CIRCLE_CLASS).remove();
        },

        _handleDocumentClick: function() {
            if ((!this.model.get('highlightedCircle') || !this.model.get('highlightedCircle').issueKey)) {
                if (this.model.get('selectedCircle') && this.model.get('selectedCircle').issueKey) {
                    this._removeSelectedClassFromAllCircles();
                    this.model.unset('selectedCircle');
                }
            }
        },

        _handleShowLayer: function(e, n, target) {
            // We set a custom property on our inline dialogs to tie them to their parent gadget.
            // Then if the dialog that is currently about to show doesn't match this id, we update the selected
            // state for this gadget. This is needed for the scenario where we click from one gadget's circle
            // to another gadget's circle.
            if (target.popup &&
                (target.popup.dashboardItemId !== this.options.id) &&
                this.inlineDialog) {
                this.model.unset('selectedCircle');
            }
        },

        /**
         * This is the handler that is called when the highlighted circle changes
         * @param model The model that changed
         * @param selection The new highlighted selection
         * @private
         */
        _changeHighlight: function(model, selection) {
            if (!selection.issueKey) {
                // Remove highlight styles from all circles
                d3.selectAll('.' + this.HOVER_STATE_CLASS_NAME)
                    .classed(this.HOVER_STATE_CLASS_NAME, false)
                    .attr('r', function() {
                        return Number(d3.select(this).attr('r')) - 1;
                    });

                return;
            }

            var circle = this._circleForIssueKey(selection.issueKey);
            var radius = Number(d3.select(circle).attr('r'));
            d3.select(circle).classed(this.HOVER_STATE_CLASS_NAME, true);
            d3.select(circle).attr('r', radius + 1);
            this._positionToolTipForCircle(circle, selection.index);
        },

        /**
         * This is the handler that is called when the selected circle changes
         * @param model The model that changed
         * @param selection The new selected selection
         * @private
         */
        _changeSelection: function(model, selection) {
            if (this.inlineDialog) {
                this.inlineDialog.hide();
                this.inlineDialog = undefined;
            }

            this._removeAllBackingCircles();

            // If we click from one circle to a circle in a different gadget, `selection` will be undefined.
            // In this case, we don't want to remove the selected class.
            // However, if we click from one circle to anywhere on the body, `selection` will be undefined as well.
            // In this case, we want to remove the selected class. We do this in the document.click handler above.

            if (!selection) {
                return;
            }

            this._removeSelectedClassFromAllCircles();

            var circle = this._circleForIssueKey(selection.issueKey);
            $(circle).tipsy('hide');

            this._addBackingCircleForSelectedCircle(circle);

            model.set('isSelectedCircleInTopColorBucket', selection.isTopColorBucket);

            var issue = model.getIssueForIssueKey(selection.issueKey);
            var inlineDialogContent = this._createInlineDialogContent(
                selection.issueKey,
                issue.bubbleDomain,
                issue.bubbleRange,
                issue.bubbleRadius,
                issue.bubbleColorValue
            );

            var newInlineDialog = this._createInlineDialog(
                $(circle),
                'bubble-chart-dialog-' + selection.issueKey,
                inlineDialogContent
            );

            this.inlineDialog = newInlineDialog;
            this.inlineDialog.show();
        },

        _removeSelectedClassFromAllCircles: function() {
            d3.select(this.el).selectAll('circle.' + this.SELECTED_CIRCLE_CLASS).classed(this.SELECTED_CIRCLE_CLASS, false);
        },

        /**
         * Removes any ticks and their respective grid lines that occur in a group without text.
         * This is likely to occur when using a log scale.
         * @param $chartElement The element that contains the chart
         * @private
         */
        _removeTicksWithoutText: function($chartElement) {
            var tickGroups = $chartElement.find('g.tick');
            tickGroups.each(function(index) {
                var textContent = $('text', this).text();
                if (textContent === '') {
                    $(this).remove();
                }
            });
        },

        /**
         * Tweak the spacing on the chart to ensure that we have enough room at the top for labels at the very top
         * of the y axis to appear without being clipped. This must be done after the graph is already rendered.
         * @param $chartElement
         * @private
         */
        _preventClippingTheTopMostLabelOnYAxis: function($chartElement) {
            var increase = this.AMOUNT_TO_INCREASE_CHART_TO_PREVENT_CLIPPING;

            // Shift each of the sub-groups of the chart (the x and y axes, and the actual plot), and shift them downwards
            // by enough to prevent the top label clipping.
            $chartElement.children('g').each(function(i, el) {
                d3.select(el)
                    .attr('transform', function() {
                        var originalX = d3.transform(d3.select(el).attr('transform')).translate[0];
                        var originalY = d3.transform(d3.select(el).attr('transform')).translate[1];
                        var shiftedY = originalY + increase;

                        return 'translate(' + originalX + ', ' + shiftedY + ')';
                    });
            });

            // We also need to increase the height of the chart element so the bottom axis doesn't clip.
            $chartElement.height('+=' + increase);
        },

        /**
         * Adds horizontal and vertical grid lines to the chart. This must be called after the chart is drawn
         * into the page, since we rely on the fact that we can use the groups created for the ticks, and append
         * our new grid lines in there.
         * @param $chartElement The element that contains the chart
         * @private
         */
        _addGridLinesToChart: function($chartElement) {
            var xAxisTickGroups = $chartElement.find('.xAxis g.tick');
            var graph = d3.select($chartElement.get(0)).select('.graph');
            var xAxis = $chartElement.find('.xAxis').get(0);
            var graphWidth = $chartElement.find('.graph-border').attr('width');
            var graphHeight = $chartElement.find('.graph-border').attr('height');
            var gridTickClass = 'grid-tick';

            var yAxisTickGroups = $chartElement.find('.yAxis g.tick');
            addValueTickClassToGroups(xAxisTickGroups);
            addValueTickClassToGroups(yAxisTickGroups);

            // Add the vertical grid lines, which extend off the x-axis.
            this._addVerticalGridLines(xAxisTickGroups, -graphHeight, gridTickClass);

            // Add the horizontal grid lines, which extend off the y-axis.
            this._addHorizontalGridLines(yAxisTickGroups, graphWidth, gridTickClass);

            // Add the class used to designate a value tick to the given group. Useful for styling
            // the ticks that point at a value differently to styling the grid lines.
            function addValueTickClassToGroups(groups) {
                var valueTickClass = 'value-tick';
                d3.selectAll(groups)
                    .selectAll('line')
                    .classed(valueTickClass, true);
            }
        },

        _addHorizontalGridLines: function(yAxisTickGroups, xAxisWidth, gridTickClass) {
            return d3.selectAll(yAxisTickGroups)
                .append('line')
                .attr('x2', xAxisWidth)
                .classed(gridTickClass, true);
        },

        _addVerticalGridLines: function(xAxisTickGroups, yAxisHeight, gridTickClass) {
            return d3.selectAll(xAxisTickGroups)
                .append('line')
                .attr('y2', yAxisHeight)
                .attr('x2', 0)
                .classed(gridTickClass, true);
        },

        _setInitialHeightOfChart: function($chartElement) {
            var width = this.$el.width();
            $chartElement.width(width);
            $chartElement.height(width * 0.5);
        },

        /**
         * Apply an x- and y-axis to a graph
         * @param graph The graph to apply the axes to
         * @returns {Chart} A chart with a graph and axes
         * @private
         */
        _createChart: function(graph) {
            var chart = c3.borderLayout()
                .xAccessor(function(d) { return d.bubbleDomain; })
                .yAccessor(function(d) { return d.bubbleRange; });
            var content = this._createGraphContentLayer(graph);
            var xAxis = this._createXAxis();
            var yAxis = this._createYAxis();

            chart.center(content);
            chart.west(yAxis);
            chart.south(xAxis);

            return chart.data(this.model.get('data'));
        },

        _createXAxis: function() {
            return c3.labelledAxis()
                .orient('bottom')
                .height(this.X_TITLE_LABEL_BUFFER * 2)
                .extend(function() {
                    this.selection().classed('xAxis', true);
                })
                .xAccessor(function(d) { return d.bubbleDomain; })
                .xScaleConstructor(this.xScaleConstructor)
                .axisConstructor(function() {
                    return d3.svg.axis()
                        .ticks(4, ',d');
                })
                .text(this.xAxisTitleLabel);
        },

        _createYAxis: function() {
            return c3.labelledAxis()
                .orient('left')
                .width(60)
                .extend(function() {
                    this.selection().classed('yAxis', true);
                })
                .yAccessor(function(d) { return d.bubbleRadius; })
                .yScaleConstructor(this.yScaleConstructor)
                .axisConstructor(function() {
                    return d3.svg.axis()
                        .ticks(5, ',d');
                })
                .text(this.yAxisTitleLabel);
        },

        _createGraphContentLayer: function(graph) {
            return c3.layerable()
                .extend(function() {
                    this.selection().classed('graph', true);
                })
                .addLayer('graph', graph);
        },

        /**
         * Get a unique identifier for each tooltip title in the component
         * @param index The index of the respective data element in the data array
         * @returns {string} A string that uniquely identifies each tooltip title
         * @private
         */
        _tooltipTitleSpanIdForIndex: function(index) {
            return 'bubble-chart-' + this.options.id + '-tooltip-' + index;
        },

        /**
         * Add AUI tooltips to each circle in the plot. These will appear on mouseenter.
         * @param data The data being plotted.
         * @param titleAccessor A function for accessing the title for a data element.
         * @param radius A function for computing the radius value for a data element subject to domain and range.
         * @private
         */
        _addTooltipsToCircles: function(data, titleAccessor, radius) {
            var backboneView = this;

            // If we lazily create tooltips--like creating a tooltip for a circle only when the circle is first
            // hovered--the tooltip won't appear until the next hover after we create it, i.e. the tooltip won't appear
            // for the first mouse hover if we don't create all of them up front.

            this.$('circle').each(function(index, element) {
                $(element).tooltip({
                    html: true,
                    title: function() {
                        // Tipsy/AUI tooltip only allows custom arrow positioning via `offset` in one dimension,
                        // but when we use it with SVGs, the tooltip is wrong in both its horizontal and vertical
                        // position.
                        // The tooltip also appears at the top of the DOM, so it's really hard to identify which
                        // circle the tipsy is associated with.
                        // Also, the tipsy doesn't allow us to give it a custom class (and $(element).tooltip
                        // returns the element to which the tipsy will be associated, not the tipsy itself), so
                        // using sensible classes on the tipsy directly via `index` isn't possible.
                        // To work around these limitations, we give tipsy an HTML string as its title (which it
                        // allows), with an id that will be unique to this tipsy. Then we can later access that
                        // tooltip, and use its parent accessors to get the tooltip itself, and thus we can
                        // position it correctly.
                        var spanId = backboneView._tooltipTitleSpanIdForIndex(index);
                        return '<span id="' + spanId + '">' + titleAccessor(data[index]) + '</span>' ;
                    },
                    trigger: 'manual',
                    gravity: 'w',
                    className: backboneView.TOOLTIP_CLASS // This class hides the tooltips by default. They will
                                                          // be un-hidden after being positioned correctly in
                                                          // each bubble's mouseover callback.
                });
            });
        },

        /**
         * Add a clip path around a certain frame of size and height to hide anything that occurs outside of that frame
         * @param containerSelection The d3 selection to which the clip path will be applied
         * @param width The width of the clip path rect
         * @param height The height of the clip path rect
         * @private
         */
        _addClipToHideCirclesOutsideBorder: function(containerSelection, width, height) {
            var clipId = 'bubble-chart-component-clip-' + this.options.id;

            // Add a clip so that bubbles outside the border do not appear
            d3.select(this.$('g.layer.graph').get(0))
                .insert('defs')
                .append('svg:clipPath')
                    .attr('id', clipId)
                    .append('rect')
                        .attr('width', width)
                        .attr('height', height);

            containerSelection.attr('clip-path', 'url(#' + clipId + ')');
        },

        /**
         * Add a graph border of width and height
         * @param width The width of the bordering frame
         * @param height The height of the bordering frame
         * @private
         */
        _addBorderToFrameOfSize: function(width, height) {
            // Add a border
            d3.select(this.$('g.layer.graph').get(0))
                .insert('rect')
                    .classed('graph-border', true)
                    .attr('width', width)
                    .attr('height', height);
        },

        /**
         * Create a plot of colored circles corresponding to the data given.
         * @returns {ColoredCirclePlot} The plot of the data
         * @private
         */
        _createBubblePlot: function() {
            var backboneView = this;

            return ColoredCirclePlot()
                .extend(function() {
                    backboneView._addTooltipsToCircles(backboneView.model.get('data'), this.titleAccessor(), this.radius());
                    backboneView._addClipToHideCirclesOutsideBorder(this.selection(), this.width(), this.height());
                    backboneView._addBorderToFrameOfSize(this.width(), this.height());
                })
                .xScaleConstructor(this.xScaleConstructor)
                .yScaleConstructor(this.yScaleConstructor)
                .xAccessor(function(d) { return d.bubbleDomain; })
                .yAccessor(function(d) { return d.bubbleRange; })
                .radiusAccessor(function (d) { return d.bubbleRadius; })
                .colorAccessor(function(d) { return d.bubbleColorValue; })
                .update(function(event, d) {
                    var titleAccessor = this.titleAccessor();

                    event.selection
                        .each(function(d, i) {
                            $(this).data(titleAccessor(d), 'true');
                        })
                        .on('click', this.click())
                        .on('mouseenter', this.mouseenter())
                        .on('mouseleave', this.mouseleave());
                })
                .extend({
                    colorScaleConstructor: c3.inherit('colorScaleConstructor', d3.scale.quantile),
                    colorRange: c3.inherit('colorRange').onDefault(function() {
                        return backboneView.model.get('colors');
                    }),
                    colorDomain: c3.inherit('colorDomain').onDefault(function() {
                        return backboneView.model.get('colorDomain');
                    }),
                    titleAccessor: c3.prop(function(data) { return data.key; }),
                    xRange: function() {
                        var width = c3.checkIsNumber(this.width());
                        var largestCircleRadius = c3.checkIsNumber(d3.max(backboneView.model.get('data'), this.radius()));
                        return [0, width - largestCircleRadius - 5];
                    },
                    yRange: function() {
                        var height = c3.checkIsNumber(this.height());
                        var largestCircleRadius = c3.checkIsNumber(d3.max(backboneView.model.get('data'), this.radius()));
                        return [height, largestCircleRadius + 5];
                    },
                    click: function() {
                        var titleAccessor = this.titleAccessor();
                        var colorConstructor = this.color();
                        var colorRange = this.colorRange();

                        return function(data) {
                            var indexInRange = colorRange.indexOf(colorConstructor(data));

                            AJS.trigger('analyticsEvent', {
                                name: 'jira.dashboard.gadgets.bubble-chart.bubble-clicked',
                                data: {
                                    colorBucket: indexInRange
                                }
                            });

                            backboneView.model.set('selectedCircle', {
                                issueKey: titleAccessor(data),
                                colorBucket: indexInRange,
                                isTopColorBucket: indexInRange === colorRange.length - 1
                            });
                        };
                    },
                    mouseenter: function() {
                        var colorRange = this.colorRange();
                        var color = this.color();
                        var titleAccessor = this.titleAccessor();

                        return function(data, index) {
                            var indexInRange = colorRange.indexOf(color(data));

                            $(this).tipsy('show');

                            backboneView.model.set('highlightedCircle', {
                                issueKey: titleAccessor(data),
                                colorBucket: indexInRange,
                                index: index
                            });
                        };
                    },
                    mouseleave: function() {
                        return function() {
                            $(this).tipsy('hide');

                            backboneView.model.set('highlightedCircle', {
                                issueKey: undefined,
                                colorBucket: undefined
                            });
                        };
                    }
                });
        },

        _positionToolTipForCircle: function(circle, index) {
            // Comments in `_addTooltipsToCircles` might be helpful
            // in understanding what we're doing here and why.
            //
            // The tooltip that appears will be in the wrong position so we need to override
            // that, taking into account the radius of the hovered circle.
            //
            // At this stage, the tooltip doesn't exist in the DOM, so we have to execute the
            // resizing after it is rendered (hence the setTimeout). The AUI tooltip/tipsy doesn't provide a callback
            // to indicate when the tooltip has appeared.
            //
            // And also, we need to hide the tooltip before we've finished positioning it--if we
            // don't hide it, there will be a flicker as it moves from its initial position to the
            // one that we provide it.
            //
            // We do it like this:
            //   1. Set up the tooltip in `_addTooltipsToCircles`,
            //      and add the TOOLTIP_CLASS, which sets its display to none so that it's not
            //      visible while incorrectly positioned.
            //   2. After the tooltip has had time to be inserted (but is still invisible), set its
            //      horizontal and vertical position to the correct position.
            //   3. Remove the TOOLTIP_CLASS so that the tooltip becomes visible

            setTimeout(function() {
                // Select the corresponding title span
                var spanId = this._tooltipTitleSpanIdForIndex(index);
                var $tooltip = $('#' + spanId).parent().parent();

                // Override all of the AUI tooltip's positioning.
                var circleRadius = Number($(circle).attr('r'));
                var heightOfTooltip = 20;
                // `getBoundingClientRect` is to the viewport, so doesn't take into account scroll position. We need to add this.
                var circleLeft = circle.getBoundingClientRect().left + window.pageXOffset;
                var circleTop = circle.getBoundingClientRect().top + window.pageYOffset;

                $tooltip.css({
                    'top': circleTop + circleRadius - heightOfTooltip,
                    'left': circleLeft + 2 * circleRadius
                });

                // Remove the class that hides the tooltip initially
                d3.select($tooltip.get(0)).classed(this.TOOLTIP_CLASS, false);
            }.bind(this), this.TOOLTIP_DELAY_APPEAR_TIME + 10);
        },

        /**
         * Construct the HTML to be displayed in the inline dialog when a bubble is clicked
         * @param key The issue key
         * @param x The x value of the issue
         * @param y The y value of the issue
         * @param radius The value that correlates to the radius of the bubble
         * @param color The value that correlates to the color of the bubble
         * @param colorDomain The color domain for the
         * @returns {String} The HTML to display within an inline dialog.
         * @private
         */
        _createInlineDialogContent: function(key, x, y, radius, color) {
            return JIRA.DashboardItem.BubbleChartComponent.Templates.InlineDialog({
                url: AJS.contextPath() + '/browse/' + key,
                title: key,
                x: x,
                xLabel: this.model.get('xAxisLabel'),
                y: y,
                yLabel: this.model.get('yAxisLabel'),
                radius: radius,
                radiusLabel: this.model.get('sizeAxisLabel'),
                color: color,
                colorLabel: this.model.get('colorAxisLabel'),
                isTopColorBucket: this.model.get('isSelectedCircleInTopColorBucket')
            });
        },

        /**
         * Create a new inline dialog styled for the bubble chart dashboard item
         * @param trigger The circle that was clicked to trigger the creation of the dialog
         * @param id A unique identifier for the inline dialog
         * @param content The html to be displayed in the dialog
         * @returns {InlineDialog}
         * @private
         */
        _createInlineDialog: function(trigger, id, content) {
            var dialogPadding = 10;
            var dialogWidth = 350;

            var dialog = AJS.InlineDialog($(trigger), id, function(element, trigger, showPopup) {
                element.addClass('bubble-chart-inline-dialog');
                element.css({padding: dialogPadding + 'px'});
                element.html(content);
                showPopup();
                return false;
            }, {
                hideDelay: 60000, // 60 seconds
                gravity: 'w',
                cacheContent: false,
                width: dialogWidth,
                fadeTime: 0
            });

            dialog.dashboardItemId = this.options.id;

            return dialog;
        },

        /**
         * Adds a circle behind another circle in the component. This gives us the double border effect when a circle
         * has been clicked.
         * @param circle The selected circle that needs to have a backing circle applied.
         * @private
         */
        _addBackingCircleForSelectedCircle: function(circle) {
            var backingCircle = circle.cloneNode(true);
            var currentRadius = Number($(backingCircle).attr('r'));

            d3.select(circle).classed(this.SELECTED_CIRCLE_CLASS, true);
            d3.select(backingCircle).classed(this.BACKING_CIRCLE_CLASS, true);
            $(backingCircle).attr('r', currentRadius + 3);
            $(circle).before(backingCircle);
        }
    });

    return BubbleChartComponent;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:bubble-chart-component', location = 'static/components/charts/bubble-chart/BubbleChartComponent.soy' */
// This file was automatically generated from BubbleChartComponent.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.BubbleChartComponent.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.BubbleChartComponent == 'undefined') { JIRA.DashboardItem.BubbleChartComponent = {}; }
if (typeof JIRA.DashboardItem.BubbleChartComponent.Templates == 'undefined') { JIRA.DashboardItem.BubbleChartComponent.Templates = {}; }


JIRA.DashboardItem.BubbleChartComponent.Templates.Container = function(opt_data, opt_ignored) {
  return '<div id="' + soy.$$escapeHtml(opt_data.id) + '-bubble-chart-component-wrapper" class="bubble-chart-component-wrapper"><svg class="bubble-chart-component-plot" /></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.BubbleChartComponent.Templates.Container.soyTemplateName = 'JIRA.DashboardItem.BubbleChartComponent.Templates.Container';
}


JIRA.DashboardItem.BubbleChartComponent.Templates.InlineDialog = function(opt_data, opt_ignored) {
  return '<div class="bubble-chart-inline-dialog-container"><h4>' + soy.$$escapeHtml(opt_data.title) + '<a href="' + soy.$$escapeHtml(opt_data.url) + '" target="_blank">' + aui.buttons.button({text: "View"}) + '</a></h4><table><tr class="chartHeader"><td>' + soy.$$escapeHtml(opt_data.xLabel) + '</td><td>' + soy.$$escapeHtml(opt_data.yLabel) + '</td><td>' + soy.$$escapeHtml(opt_data.radiusLabel) + '</td><td>' + soy.$$escapeHtml(opt_data.colorLabel) + '</td></tr><tr class="chartInfo"><td>' + soy.$$escapeHtml(opt_data.x) + '</td><td>' + soy.$$escapeHtml(opt_data.y) + '</td><td>' + soy.$$escapeHtml(opt_data.radius) + '</td><td class="hot">' + ((opt_data.isTopColorBucket) ? '<span class=\'d4-is-top\'>' + soy.$$escapeHtml(opt_data.color) + '</span>&nbsp;<div class="hot-icon" />' : soy.$$escapeHtml(opt_data.color)) + '</td></tr></table></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.BubbleChartComponent.Templates.InlineDialog.soyTemplateName = 'JIRA.DashboardItem.BubbleChartComponent.Templates.InlineDialog';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:relative-distribution', location = 'static/components/charts/components/RelativeDistribution.js' */
define('jira-dashboard-items/components/charts/components/relative-distribution', function() {
    'use strict';

    return {
        /**
         * When called on a sorted array, this method returns the end index of the slice that contains 'x' unique values.
         *
         * For example, [4, 4, 5, 5, 5, 6, 6, 7].sortedArraySliceForUniqueValueCount(2) will return 4, the index
         * of the last 5 in the list.
         *
         * @param array The sorted array to use.
         * @param x The number of unique values to include in the slice.
         * @returns {Integer} The index of the last unique value within the count of 'x'
         */
        sortedArraySliceForUniqueValueCount: function(array, x) {
            var countDistinct = 0;

            for (var i = 0; i < array.length; i++) {
                if (i === 0) {
                    countDistinct++;
                }

                if (i > 0 && array[i] !== array[i - 1]) {
                    countDistinct++;
                }

                if (countDistinct > x) {
                    return i - 1;
                }
            }

            return (array.length - 1);
        },

        /**
         * A distribution of values into population-sized percentage buckets.
         * This takes a collection of values and the percentage of the unique population that will be the size
         * of each partitioned subsegment.
         *
         * A good way to think about this is like a teacher marking exams. The teacher has a list of marks (`values`) and
         * wants to make sure that 10% of kids get an F, 20% get a D, 40% get a C, 20% get a B, and 10% get an A.
         * This module can compute that; in this case, the `percentages` argument should be [0.1, 0.2, 0.4, 0.2, 0.1].
         *
         * An important thing to note is that this module works on distinct values in the `values` array. This means that
         * identical values will be placed into the same bucket, regardless of how much it messes up the distribution
         * of the population in the result.
         *
         * If the percentages produce non-integer size, we _always round up_. This means the top-most bucket
         * will often be empty.
         *
         * @param values The values to be distributed
         * @param percentages The percentage of the total population size that each partition should contain. These should add up to 1.
         * @returns {Array} A 2D array of the values distributed into percentage buckets.
         * @throws {Error} An error if the percentages do not add up to 1.0 (100%)
         */
        distribute: function RelativeDistribution(values, percentages) {
            var total = parseFloat(percentages.reduce(function(a, b) { return a + b; }).toPrecision(3));
            if (total !== 1) {
                throw new Error('Percentages given to RelativeDistribution#distribute do not add up to 1.');
            }

            // Numeric sort on the input data (so that we can place equal items into the same bucket later)
            var sorted = values.sort(function (a, b) { return a - b; });

            // Get a count of how many times each data value occurs
            var unique = {};

            for (var i = 0; i < sorted.length; i++) {
                if (unique[sorted[i]]) {
                    unique[sorted[i]] = unique[sorted[i]]++;
                }
                else {
                    unique[sorted[i]] = 0;
                }
            }

            var numberOfUniqueValues = Object.keys(unique).length;

            // Compute how many items should go into each percentage bucket
            var percentageValueCounts = {};

            for (var i = 0; i < percentages.length; i++) {
                var numberOfUniqueValuesToInclude = percentages[i] * numberOfUniqueValues;
                numberOfUniqueValuesToInclude = Math.ceil(numberOfUniqueValuesToInclude);
                percentageValueCounts[percentages[i]] = numberOfUniqueValuesToInclude;
            }

            // Fill each percentage bucket
            var result = [];
            var valueIndex = 0;

            for (var bucket = 0; bucket < percentages.length; bucket++) {
                var sliceToEnd = sorted.slice(valueIndex);
                var valueCount = percentageValueCounts[percentages[bucket]];
                var endIndex = valueIndex + this.sortedArraySliceForUniqueValueCount(sliceToEnd, valueCount);

                result[bucket] = [];

                sorted.slice(valueIndex, endIndex + 1).forEach(function(v) {
                    result[bucket].push(v);
                });

                valueIndex = endIndex + 1;
            }

            return result;
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:bubble-chart-model', location = 'static/dashboarditem/bubble-chart/BubbleChartModel.js' */
define('jira-dashboard-items/bubble-chart-model', [
    'jquery',
    'underscore',
    'backbone',
    'jira-dashboard-items/components/charts/components/relative-distribution',
    'jira-dashboard-items/lib/d3'
], function(
    $,
    _,
    Backbone,
    RelativeDistribution,
    d3
) {
    'use strict';

    /**
     * BubbleChartModel manages the data and networking required for the bubble chart dashboard item.
     * Its initializer requires `projectOrFilterId`, `bubbleType`, and `recentCommentsPeriod` to be specified.
     * Optionally, `useLogarithmicScale`, `useRelativeColoring`, and `colors` can be overridden pass in the
     * configuration object to customize the model.
     * Provided that a network request has finished, users can access `keyLabel`, `xAxisLabel`, `yAxisLabel`,
     * `sizeAxisLabel`, `colorAxisLabel`, `filterTitle`, `issueCount`, `data`, `colorDomain`, and `legendData`.
     * @type {BubbleChartModel}
     */
    var BubbleChartModel = Backbone.Model.extend({
        urlRoot: AJS.contextPath() + '/rest/gadget/1.0/bubblechart',

        defaults: {
            useLogarithmicScale: false,
            useRelativeColoring: true,
            colors: ['#28892C', '#95B436', '#F5C342','#F1A256', '#F79232', '#D04436'],
            issueLimit: 200,
            sizeAxis: 'participants'
        },

        url: function() {
            return this.urlRoot + '/generate?projectOrFilterId=' + this.get('projectOrFilterId') +
                '&bubbleType=' + this.get('bubbleType') +
                '&recentCommentsPeriod=' + this.get('recentCommentsPeriod');
        },

        parse: function(response) {
            var parsed = {};

            parsed.keyLabel = "Issue key";
            parsed.xAxisLabel = "Days open";
            parsed.yAxisLabel = "Comments";
            parsed.sizeAxisLabel = this.get('bubbleType') === 'participants'
                ? "Participants"
                : "Votes";
            parsed.colorAxisLabel = "Recent comments";
            parsed.filterTitle = response.filterTitle;
            parsed.issueCount = response.issueCount;

            var data = response.data;
            if (this.get('useLogarithmicScale')) {
                data = this._filterZeroesForLogarithmicScale(data);
            }

            if (response.warning && response.issueCount >= this.get('issueLimit')
                || data.length > this.get('issueLimit')) {
                parsed.exceedsIssueLimit = true;
            } else {
                parsed.exceedsIssueLimit = false;
            }

            parsed.colorDomain = this.get('useRelativeColoring')
                ? this._domainForRelativeColorDistribution(data)
                : this._domainForAbsoluteColorDistribution(data);

            parsed.legendData = this.get('useRelativeColoring')
                ? this._legendDataForRelativeColoring(this.get('colors'))
                : this._legendDataForAbsoluteColoring(this.get('colors'));

            parsed.data = data;

            return parsed;
        },

        /**
         * Search for an issue by issue key
         * @param issueKey The issue key to search by--this is the first entry in each array of the network response
         * @returns {Array} An array representing an issue with x, y, radius, and color value as its entries
         */
        getIssueForIssueKey: function(issueKey) {
            // By the time this method would be called, the data will have been reformatted into a d3-suitable format
            // similar to [ [1, 2, 3, 2, 'JC-101'], [2, 34, 1, 2, 'JC-64'], ... ]. We access the last element of each
            // data entry to find based on the issue key. (Otherwise, we would need to maintain two copies of the data
            // in this model--one for the d3-suitable data, and one with the original objects returned from the server.)
            return _.findWhere(this.get('data'), {
                key: issueKey
            });
        },

        /**
         * Returns which segment of the domain a value lives in.
         * @param value
         */
        indexInDomainForValue: function(value) {
            var scale = d3.scale.quantile().domain(this.get('colorDomain')).range(this.get('colors'));
            return this.get('colors').indexOf(scale(value));
        },

        _domainForAbsoluteColorDistribution: function(chartData) {
            var min = d3.min(chartData, function(d) { return d.bubbleColorValue; });
            var max = d3.max(chartData, function(d) { return d.bubbleColorValue; });
            return [min, max];
        },

        _domainForRelativeColorDistribution: function(chartData) {
            var colorValues = chartData.map(function(dataPoint) { return dataPoint.bubbleColorValue; });
            var distribution = RelativeDistribution.distribute(colorValues, [0.1, 0.2, 0.4, 0.2, 0.1]);

            return distribution.map(function(arr) {
                // distribution is a 2D array. Get the first value of each bucket to use as our threshold.
                return arr[0];
            }).filter(Number);
        },

        /**
         * Filter data points that are 0 in the x or y component from the data set
         * @param chartData The data set
         * @returns {Array} The original data set except for anything that had a value of 0 in the x or y (0 or 1) component
         * @private
         */
        _filterZeroesForLogarithmicScale: function(chartData) {
            return chartData.filter(function(dataPoint) {
                return dataPoint.bubbleDomain !== 0 && dataPoint.bubbleRange !== 0;
            });
        },

        // We only want to render 'low' and 'high' labels on the first and last segments--the rest are empty
        _legendDataForRelativeColoring: function(colors) {
            var legendData = colors.map(function(_, i) { return '';});
            legendData[0] = "Low";
            legendData[legendData.length - 1] = "High";
            return legendData;
        },

        _legendDataForAbsoluteColoring: function(colors) {
            // We just use the same labelling as the relative coloring, but we don't want to leak that to the caller
            // since this might change.
            return this._legendDataForRelativeColoring(colors);
        }
    });

    return BubbleChartModel;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:discrete-legend', location = 'static/components/charts/components/discrete-legend/DiscreteLegend.js' */
/**
 * A horizontal segmented bar legend with discrete sub-segments of different colors.
 */
define('jira-dashboard-items/components/charts/components/discrete-legend/discrete-legend', [
    'jquery',
    'jira-dashboard-items/components/charts/components/colorable',
    'jira-dashboard-items/lib/d3',
    'jira-dashboard-items/lib/c3',
    'backbone'
], function(
    $,
    Colorable,
    d3,
    c3,
    Backbone
) {
    'use strict';

    var discreteLegendComponent = function() {
        return c3.component('discrete-legend')
            .extend(c3.layerable())
            .extend(c3.drawable())
            .extend(Colorable())
            .extend(function() {
                var OFFSET = 20 / this.data().length;
                var EACH_WIDTH = this.width() / this.data().length - OFFSET;
                var EACH_HEIGHT = this.height();

                var svg = this.selection()
                    .append('svg')
                        .attr('class', 'discrete-legend-svg');

                // Render three rects for each segment: the original rect, the backing segment rect,
                // and the selected-style rect. The backing and selected segments are initially hidden,
                // and we show them by adding the `selected` class to the rect segment group.

                // Segment group
                var rectGroup = svg
                    .append('g')
                    .attr('transform', 'translate(2, 2)')
                    .selectAll('rect')
                    .data(this.data())
                    .enter().append('g')
                    .attr('data-segment-id', function(d, i) { return i; })
                    .classed('segment-group', true);

                // Original
                rectGroup.append('rect')
                    .classed('original-segment', true)
                    .attr('width', EACH_WIDTH)
                    .attr('height', EACH_HEIGHT)
                    .attr('rx', 3)
                    .attr('x', function(d, i) { return i * EACH_WIDTH + i * OFFSET; })
                    .attr('y', 0)
                    .attr('fill', this.color());

                // Backing
                rectGroup.append('rect')
                    .classed('backing-segment', true)
                    .attr('width', EACH_WIDTH + 2)
                    .attr('height', EACH_HEIGHT + 2)
                    .attr('x', function(d, i) { return i * EACH_WIDTH + i * OFFSET - 1.25; })
                    .attr('y', -1.25)
                    .attr('fill', this.color())
                    .attr('rx', 3);

                // Selected (inner, slightly smaller than original)
                rectGroup.append('rect')
                    .classed('selected-segment', true)
                    .attr('width', EACH_WIDTH - 2.5)
                    .attr('height', EACH_HEIGHT - 2.5)
                    .attr('x', function(d, i) { return i * EACH_WIDTH + i * OFFSET + 1; })
                    .attr('y', 1)
                    .attr('rx', 1)
                    .attr('fill', this.color());

                // Text labels
                svg
                    .append('g')
                    .selectAll('text')
                        .data(this.data())
                    .enter().append('text')
                        .text(function(d, i) { return d;})
                        .attr('transform', function(d, i) {
                            return 'translate(' + (i * EACH_WIDTH + EACH_WIDTH / 2 + i * OFFSET) + ', 30)';
                        });
            })
            .extend({
                colorAccessor: c3.inherit('colorAccessor', function(d) {
                    return d;
                }),
                colorScaleConstructor: c3.inherit('colorScaleConstructor', d3.scale.quantize)
            });
    };

    /**
     * A segmented legend that is used on the Bubble Chart dashboard item.
     *
     * Each segment has two states: selected and highlighted. These are managed by the `model` object,
     * which should be passed in the constructor.
     *
     * To 'select' a segment, we apply the 'selected' class to that `g.segment-group`, which will add
     * a backing rect, display an inner rect lozenge, and hide the original rect. To 'deselect' a segment,
     * simply remove this class.
     *
     * Highlighting a segment is similar--add the 'highlighted class to the `g.segment-group` corresponding
     * to the segment you want to highlight.
     *
     * @type {DiscreteLegend}
     */
    var DiscreteLegend = Backbone.View.extend({
        initialize: function(options) {
            this.options = options || {};
            this.model = options.model;

            this.listenTo(this.model, 'change:selectedSegment', this._selectedSegmentDidChange);
            this.listenTo(this.model, 'change:highlightedSegment', this._highlightedSegmentDidChange);
        },

        _selectedSegmentDidChange: function(model, index) {
            if (index !== undefined) {
                this._deselectAllSegments();
                this._selectSegment(index);
            } else {
                this._deselectAllSegments();
            }
        },

        _highlightedSegmentDidChange: function(model, index) {
            if (index !== undefined) {
                this._highlightSegment(index);
            } else {
                this._unhighlightAllSegments();
            }
        },

        render: function() {
            var domain = this.model.get('data').map(function(_, i) { return i; });
            var width = this.$el.attr('width');

            var legend = discreteLegendComponent()
                .data(this.model.get('data'))
                .colorScaleConstructor(d3.scale.ordinal)
                .colorDomain(domain)
                .colorRange(this.model.get('colors'))
                .colorAccessor(function(d, i) {
                    return i;
                 })
                .height(10)
                .width(width);

            d3.select(this.el)
                .append('div')
                .attr('class', 'discrete-legend-component')
                .call(legend);
        },

        _selectSegment: function(index) {
            d3.select(this._segmentWithIndex(index)).classed('selected', true);
        },

        _deselectAllSegments: function() {
            d3.select(this.el).selectAll('.segment-group').classed('selected', false);
        },

        _highlightSegment: function(index) {
            d3.select(this._segmentWithIndex(index)).classed('highlighted', true);
        },

        _unhighlightAllSegments: function() {
            d3.select(this.el).selectAll('.segment-group').classed('highlighted', false);
        },

        _segmentWithIndex: function(index) {
            return $('g.segment-group[data-segment-id="' + index + '"]', this.$el).get(0);
        }
    });

    return DiscreteLegend;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:bubble-chart', location = 'static/dashboarditem/bubble-chart/BubbleChart.js' */
define('jira-dashboard-items/bubble-chart', [
    'jquery',
    'underscore',
    'backbone',
    'jira-dashboard-items/components/charts/bubble-chart/bubble-chart-component',
    'jira-dashboard-items/bubble-chart-model',
    'jira-dashboard-items/components/charts/components/discrete-legend/discrete-legend'
], function(
    $,
    _,
    Backbone,
    BubbleChartComponent,
    BubbleChartModel,
    DiscreteLegend
) {
    'use strict';

    var BubbleChart = Backbone.View.extend({
        template: JIRA.DashboardItem.BubbleChart.Templates,

        initialize: function(options) {
            this.RESIZE_RATE_LIMIT = 300;
            this.setTitle = options.setTitle;
            this.hideLoadingBar = options.hideLoadingBar;
            this.resize = options.resize;

            this.discreteLegendModel = new Backbone.Model({
                data: options.model.get('legendData'),
                colors: options.model.get('colors')
            });

            this.listenTo(options.model, {
                'change:legendData': function(model, data) { this.discreteLegendModel.set('data', data);},
                'change:colors': function(model, colors) { this.discreteLegendModel.set('colors', colors);}
            });
        },

        render: function() {
            this.listenTo(this.model, {
                'change:data': this._renderBubbleChart,
                'change:filterTitle': function (model, filterTitle) {
                    this.setGadgetTitleForFilter(filterTitle);
                },
                'change:highlightedCircle': function(model, options) {
                    this.discreteLegendModel.set('highlightedSegment', options.colorBucket);
                },
                'change:selectedCircle': function (model, options) {
                    this.discreteLegendModel.set('selectedSegment', options ? options.colorBucket : undefined);
                }
            });

            this.resizeHandler = _.debounce(this._renderBubbleChart.bind(this), this.RESIZE_RATE_LIMIT);
            // We'd prefer to resize when this element resizes rather than the window, however this only has partial browser support.
            // From what I can tell, it works in Chrome and Safari, but not Firefox. The resize event is also
            // only meant to exist for the window, so Firefox is correct. Other dashboard items don't resize in Firefox
            // if they rely on this. This means we don't resize when the dashboard changes width,
            // or when a dashboard item is dragged and dropped to a different column.
            $(window).resize(this.resizeHandler);

            this.$el.on('remove', function() {
                $(window).off('resize', this.resizeHandler);
            }.bind(this));
        },

        _renderBubbleChart: function() {
            this._removeExistingBubbleChartIfItExists();
            this.hideLoadingBar();

            var data = this.model.get('data');

            if (!data) {
                return;
            }

            if (data && data.length === 0) {
                this._displayNoDataInfoMessage();
                return;
            }

            var bubbleType = this.model.get('bubbleType');
            var displayWarning = this.model.get('exceedsIssueLimit');

            // Render the container for the chart with an optional warning if the issue limit has been exceeded
            this.$el.html(this.template.Container({
                type: this.model.get('bubbleType'),
                displayWarning: displayWarning
            }));

            // We use the position of the grid lines to set the legend's width, so we need to render the chart first.
            var $bubbleChartContainer = this.$('.bubble-chart-component-container');
            this.bubbleChart = this._createBubbleChart($bubbleChartContainer, this.model.get('data'), this.model.get('colors'));
            this.bubbleChart.render();

            var $legendElement = this.$('.discrete-legend-component-container');
            var graphWidth = $('.graph-border', $bubbleChartContainer).attr('width');
            var graphHeight = $('.graph-border', $bubbleChartContainer).attr('height');

            $legendElement.attr('width', graphWidth);
            $legendElement.attr('height', graphHeight);

            this.legend = this._createLegend($legendElement.get(0));
            this.legend.render();
            this.resize();
            this.setGadgetTitleForFilter(this.model.get('filterTitle'));
        },

        _removeExistingBubbleChartIfItExists: function() {
            if (this.bubbleChart) {
                this.bubbleChart.stopListening();
                this.bubbleChart.$el.remove();
                this.bubbleChart = null;
            }
        },

        _displayNoDataInfoMessage: function() {
            this.setTitle("Bubble Chart");
            this.$el.html(this.template.NoDataInfo());
            this.resize();
        },

        _createBubbleChart: function(element) {
            return new BubbleChartComponent({
                model: this.model,
                el: element,
                id: this.id
            });
        },

        _createLegend: function(element) {
            return new DiscreteLegend({
                el: element,
                model: this.discreteLegendModel
            });
        },

        /**
         * Set the title of the gadget
         * @param filterTitle The title of the filter that is currently on display
         */
        setGadgetTitleForFilter: function(filterTitle) {
            this.setTitle(AJS.format("Bubble Chart: {0}", filterTitle));
        }
    });

    return BubbleChart;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:bubble-chart', location = 'static/dashboarditem/bubble-chart/BubbleChart.soy' */
// This file was automatically generated from BubbleChart.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.BubbleChart.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.BubbleChart == 'undefined') { JIRA.DashboardItem.BubbleChart = {}; }
if (typeof JIRA.DashboardItem.BubbleChart.Templates == 'undefined') { JIRA.DashboardItem.BubbleChart.Templates = {}; }


JIRA.DashboardItem.BubbleChart.Templates.Container = function(opt_data, opt_ignored) {
  return '<div class="bubble-chart-gadget-container"><h3>' + soy.$$escapeHtml(AJS.format("Correlation between days open, number of comments, and {0}",opt_data.type)) + '</h3><div class="bubble-chart-gadget-plot-container"><div class="discrete-legend-component-container" /><div class="bubble-chart-component-container" /></div>' + ((opt_data.displayWarning) ? aui.message.warning({title: "Too many issues", closeable: 'false', content: '<p>' + soy.$$escapeHtml("This chart can display only the first 200 matching issues. Refine your search to return fewer issues.") + '</p>'}) : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.BubbleChart.Templates.Container.soyTemplateName = 'JIRA.DashboardItem.BubbleChart.Templates.Container';
}


JIRA.DashboardItem.BubbleChart.Templates.ConfigurationContainer = function(opt_data, opt_ignored) {
  return '<div class="bubble-chart-config-container"></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.BubbleChart.Templates.ConfigurationContainer.soyTemplateName = 'JIRA.DashboardItem.BubbleChart.Templates.ConfigurationContainer';
}


JIRA.DashboardItem.BubbleChart.Templates.Configuration = function(opt_data, opt_ignored) {
  return '' + Atlassian.DashboardItem.Common.Templates.config({fields: '' + JIRA.DashboardItem.ProjectFilterAutoComplete.Templates.ConfigurationField({prefix: opt_data.prefix, id: 'project-filter-picker', selectionType: opt_data.preferences.type, selectionID: opt_data.preferences.id, selectionName: opt_data.preferences.name}) + aui.form.selectField({id: opt_data.prefix, labelContent: "Bubble size", name: 'bubbleType', options: opt_data.types, value: opt_data.preferences.bubbleType, descriptionText: "Select the basis for the size of the bubbles."}) + aui.form.selectField({id: opt_data.prefix, labelContent: "Interval", name: 'recentCommentsPeriod', options: opt_data.intervals, value: opt_data.preferences.recentCommentsPeriod, descriptionText: "You can set the interval at which an issue comment is deemed recent."}) + aui.form.checkboxField({legendContent: "Relative coloring", fields: opt_data.relativeColoringCheckboxes}) + aui.form.checkboxField({legendContent: "Logarithmic scale", fields: opt_data.logarithmicScaleCheckboxes}) + Atlassian.DashboardItem.Common.Templates.refreshInterval({prefix: opt_data.prefix, id: 'refresh-interval', value: opt_data.preferences.refresh}), isConfigured: opt_data.preferences.isConfigured});
};
if (goog.DEBUG) {
  JIRA.DashboardItem.BubbleChart.Templates.Configuration.soyTemplateName = 'JIRA.DashboardItem.BubbleChart.Templates.Configuration';
}


JIRA.DashboardItem.BubbleChart.Templates.Error = function(opt_data, opt_ignored) {
  return '<div class="bubble-chart-gadget-container">' + aui.message.error({titleContent: opt_data.title, content: opt_data.content, closeable: 'false'}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.BubbleChart.Templates.Error.soyTemplateName = 'JIRA.DashboardItem.BubbleChart.Templates.Error';
}


JIRA.DashboardItem.BubbleChart.Templates.NoDataInfo = function(opt_data, opt_ignored) {
  return '<div class="bubble-chart-gadget-container">' + aui.message.info({titleContent: "No issues", content: "The project or filter did not return any issues"}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.BubbleChart.Templates.NoDataInfo.soyTemplateName = 'JIRA.DashboardItem.BubbleChart.Templates.NoDataInfo';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:bubble-chart-dashboard-item-resources', location = 'static/dashboarditem/bubble-chart/BubbleChartConfigView.js' */
define('jira-dashboard-items/bubble-chart-config-view', [
    'jquery',
    'backbone',
    'underscore',
    'jira-dashboard-items/components/autocomplete/project-filter-autocomplete'
], function (
    $,
    Backbone,
    _,
    ProjectFilterAutoComplete
) {
    'use strict';

    var BubbleChartConfigView = Backbone.View.extend({
        events: {
            'click .cancel': 'cancel',
            'submit': 'submit'
        },

        initialize: function(options) {
            this.id = options.id;
            this.intervals = options.intervals;
            this.types = options.types;
            this.projectFilterDelay = options.projectFilterDelay;

            this.intervalOptions = [
                {value: '1', text: "1 day"},
                {value: '7', text: "1 week"},
                {value: '14', text: "2 weeks"},
                {value: '28', text: "4 weeks"},
                {value: '57', text: "8 weeks"},
                {value: '84', text: "12 weeks"}
            ];

            this.typeOptions = [
                {value: 'participants', text: "Participants"},
                {value: 'votes', text: "Votes"}
            ];

        },

        render: function (preferences) {
            var newPreferences = _.clone(preferences || {});
            newPreferences = _.defaults(newPreferences, this._defaultPreferences);
            newPreferences.refresh = newPreferences.refresh === '15';

            this.$el.html(JIRA.DashboardItem.BubbleChart.Templates.Configuration({
                prefix: this.id + '-',
                preferences: newPreferences,
                intervals: this.intervalOptions,
                types: this.typeOptions,
                relativeColoringCheckboxes: this._relativeColoringCheckboxes(newPreferences),
                logarithmicScaleCheckboxes: this._logarithmicScaleCheckboxes(newPreferences)
            }));

            this._bindProjectFilterAutocomplete();
        },

        /**
         * Get the default preferences for the gadget
         * @returns {Object} An object containing the default preferences
         * @private
         */
        _defaultPreferences: {
            isConfigured: false,
            useRelativeColoring: true,
            recentCommentsPeriod: 7,
            refresh: '15',
            useLogarithmicScale: false
        },

        /**
         * Bind the component used to select the project or filter for the gadget
         * @private
         */
        _bindProjectFilterAutocomplete: function () {
            var bubbleChartConfigView = this;

            var projectFilterOptions = {
                field: $('#' + this.id + '-project-filter-picker', this.$el),

                completeField: function (selection) {
                    if (selection) {
                        bubbleChartConfigView.$el.find('input[name=type]').val(selection.type);
                        bubbleChartConfigView.$el.find('input[name=id]').val(selection.id);
                        bubbleChartConfigView.$el.find('input[name=name]').val(selection.name);
                        bubbleChartConfigView.$el.find('.filterpicker-value-name').text(selection.name).addClass('success');
                        this.field.val('');
                        this.field.trigger('change');
                    }
                },

                maxHeight: 140
            };

            // Mostly used for testing where we don't want a delay
            if (this.projectFilterDelay) {
                projectFilterOptions.delay = this.projectFilterDelay;
            }

            // To account for advanced search mechanism
            projectFilterOptions.parentElement = this.$el.find('form');
            projectFilterOptions.fieldID = projectFilterOptions.field.attr('id');

            ProjectFilterAutoComplete(projectFilterOptions);
        },

        /**
         * Called when the form is submitted, this method validates the current
         * fields and submits the form if they are valid.
         * @param event The form submission event.
         */
        submit: function (event) {
            var arrayData = $('form', this.$el).serializeArray();
            event.preventDefault();
            var fields = this._getPreferencesObjectFromSerializedArray(arrayData);

            if (this.validPreferences(fields)) {
                this.trigger('submit', fields);
            }
        },

        /**
         * Called when the form is cancelled.
         */
        cancel: function(event) {
            event.preventDefault();
            this.trigger('cancel');
        },

        _getPreferencesObjectFromSerializedArray: function(serializedArray) {
            var formFieldsObj = serializedArray.reduce(function(fieldsObj, field) {
                fieldsObj[field.name] = field.value;
                return fieldsObj;
            }, {});

            return this._mapFormFieldsToCorrectPreferenceNamesAndValues(formFieldsObj);
        },

        _mapFormFieldsToCorrectPreferenceNamesAndValues: function(formFieldsObj) {
            var preferences = $.extend({}, formFieldsObj);
            preferences.refresh = formFieldsObj['refresh-interval'];
            preferences.useLogarithmicScale = formFieldsObj.useLogarithmicScale === 'on';
            preferences.useRelativeColoring = formFieldsObj.useRelativeColoring === 'on';
            delete preferences['refresh-interval'];
            return preferences;
        },

        /**
         * Validate the configuration and any fields that are not correct apply an error message to the field.
         * @param {Object} preferences The set of preferences. Usually obtained from the form.
         * @returns {boolean} Whether the preferences are valid or not
         */
        validPreferences: function (preferences) {
            var valid = true;
            if (!preferences.id || !preferences.type) {
                $('.projectOrFilter-error', this.$el).text("No project or filter specified.").show();
                valid = false;
            }
            else {
                $('.projectOrFilter-error', this.$el).hide();
            }

            this.trigger('layoutUpdate');
            return valid;
        },

        _relativeColoringCheckboxes: function(preferences) {
            return [
                {
                    id: 'bubble-chart-relative-color-' + this.id,
                    name: 'useRelativeColoring',
                    labelText: "When enabled/selected, issues are grouped/distributed in different colors, to better distinguish the issues that receive more recent comments from the ones that receive fewer recent comments.",
                    isChecked: preferences.useRelativeColoring
                }
            ];
        },

        _logarithmicScaleCheckboxes: function(preferences) {
            return [
                {
                    id: 'bubble-chart-log-scale-' + this.id,
                    name: 'useLogarithmicScale',
                    labelText: "Distribute bubbles closer to or farther apart from each other.",
                    descriptionText: "This also filters any issue that has been open for zero days or has zero recent comments.",
                    isChecked: preferences.useLogarithmicScale
                }
            ];
        }
    });

    return BubbleChartConfigView;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:bubble-chart-dashboard-item-resources', location = 'static/dashboarditem/bubble-chart/BubbleChartDashboardItem.js' */
define('jira-dashboard-items/bubble-chart-dashboard-item', [
    'jira-dashboard-items/bubble-chart',
    'jira-dashboard-items/bubble-chart-config-view',
    'jira-dashboard-items/bubble-chart-model',
    'jquery',
    'underscore'
], function(
    BubbleChart,
    BubbleChartConfigView,
    BubbleChartModel,
    $,
    _
) {
    'use strict';

    var DashboardItem = function (API, options) {
        this.API = API;
        this.options = options || {};

        this.errors = {
            GENERIC: "Oops - an error has occurred",
            UNAUTHORIZED_TITLE: "You do not have permission to view this project or filter.",
            UNAUTHORIZED_CONTENT: '',
            NOT_FOUND_TITLE: "Not found",
            NOT_FOUND_CONTENT: "This project or filter could not be found."
        };

        // The user's options will be set in `render`
        this.model = new BubbleChartModel({});
    };

    /**
     * Render the dashboard item
     * @param element The element that will contain the dashboard item
     * @param preferences The dashboard item's preferences
     */
    DashboardItem.prototype.render = function (element, preferences) {
        AJS.trigger('analyticsEvent', {
            name: 'jira.dashboard.gadgets.bubble-chart.loaded',
            data: {
                bubbleType: preferences.bubbleType,
                useLogarithmicScale: preferences.useLogarithmicScale,
                useRelativeColoring: preferences.useRelativeColoring
            }
        });

        this.API.initRefresh(preferences, _.bind(this.render, this, element, preferences));
        this.API.showLoadingBar();

        if (!this.bubbleChart) {
            this.bubbleChart = new BubbleChart({
                model: this.model,
                id: this.API.getGadgetId(),
                setTitle: function(t) { this.API.setTitle(t); }.bind(this),
                hideLoadingBar: function() { this.API.hideLoadingBar(); }.bind(this),
                resize: function() { this.API.resize(); }.bind(this),
                el: element
            });
        }

        this.bubbleChart.render();

        this.model.set({
            data: undefined,
            projectOrFilterId: preferences.type + '-' + preferences.id,
            bubbleType: preferences.bubbleType,
            recentCommentsPeriod: preferences.recentCommentsPeriod,
            useLogarithmicScale: preferences.useLogarithmicScale,
            useRelativeColoring: preferences.useRelativeColoring
        });

        this.model.fetch()
            .always(function () {
                // The `.always` callback will be executed after the this.model.on('change:data') callback that is
                // used in BubbleChart.js. This is bad the loading bar controls the height and size of our container,
                // but we need to be able to do that for the bubble chart. We work around this by passing the
                // `hideLoadingBar` function to the bubble chart in its constructor, so that it can control when
                // the loading bar will hide.
                // We still want this line here for the error case.
                this.API.hideLoadingBar();
            }.bind(this))
            .fail(function (response) {
                this._displayErrorMessage(element, response);
            }.bind(this));
    };

    /**
     * Display a generic error message for the dashboard item
     * @param $element The element in which we will display the error
     * @param response The response from the network request
     */
    DashboardItem.prototype._displayErrorMessage = function($element, response) {
        var options = {};

        try {
            var errors = JSON.parse(response.responseText).errors;
            options.title = errors.projectOrFilterId;
            options.content = '';
        } catch(e) {
            options.title = this.errors.GENERIC;
            options.content = '';
        }

        $element.html(JIRA.DashboardItem.BubbleChart.Templates.Error(options));
        this.API.resize();
    };

    /**
     * Render the edit preferences screen
     * @param element The element that will contain the dashboard item
     * @param preferences The dashboard item's preferences
     */
    DashboardItem.prototype.renderEdit = function(element, preferences) {
        if (this.bubbleChart && this.bubbleChart.resizeHandler) {
            $(window).off('resize', this.bubbleChart.resizeHandler);
        }

        $(element).html(JIRA.DashboardItem.BubbleChart.Templates.ConfigurationContainer());

        this.configView = new BubbleChartConfigView({
            id: this.API.getGadgetId(),
            el: $('.bubble-chart-config-container', element),
            projectFilterDelay: this.options.delay
        });

        this.configView.render(preferences);
        this.configView.bind('cancel', _.bind(function () { this.API.closeEdit(); }, this));
        this.configView.bind('submit', _.bind(function (newPreferences) { this.configViewFormDidSubmit(newPreferences); }, this));

        this.configView.bind('layoutUpdate', function() {
            this.API.resize();
        }.bind(this));

        this.API.once('afterRender', function () {
            this.API.resize();
        }.bind(this));

        this.API.setTitle("Bubble Chart");
    };

    /**
     * Called when the configuration form has been submitted
     * @param gadgetPreferences The preferences of the gadget
     */
    DashboardItem.prototype.configViewFormDidSubmit = function(gadgetPreferences) {
        this.API.resize();
        this.API.savePreferences(gadgetPreferences);
    };

    return DashboardItem;
});
;
;
/* module-key = 'com.atlassian.jira.gadgets:text-dashboard-item-resource', location = 'static/dashboarditem/text/Text.soy' */
// This file was automatically generated from Text.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.DashboardItem.Text.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.DashboardItem == 'undefined') { JIRA.DashboardItem = {}; }
if (typeof JIRA.DashboardItem.Text == 'undefined') { JIRA.DashboardItem.Text = {}; }
if (typeof JIRA.DashboardItem.Text.Templates == 'undefined') { JIRA.DashboardItem.Text.Templates = {}; }


JIRA.DashboardItem.Text.Templates.Content = function(opt_data, opt_ignored) {
  return '<div class="text-dashboard-item-container"><iframe src="about:blank"></iframe></div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Text.Templates.Content.soyTemplateName = 'JIRA.DashboardItem.Text.Templates.Content';
}


JIRA.DashboardItem.Text.Templates.Configuration = function(opt_data, opt_ignored) {
  return '<div class="text-dashboard-item-config-container">' + Atlassian.DashboardItem.Common.Templates.config({fields: '' + aui.form.textField({name: 'title', labelContent: "Title", value: opt_data.preferences.title, descriptionText: "The text to be displayed as the title of this gadget."}) + aui.form.textareaField({name: 'html', labelContent: "HTML", value: opt_data.preferences.html, descriptionText: "The HTML to display in the body of this gadget."}), isConfigured: opt_data.preferences.isConfigured}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.DashboardItem.Text.Templates.Configuration.soyTemplateName = 'JIRA.DashboardItem.Text.Templates.Configuration';
}
;
;
/* module-key = 'com.atlassian.jira.gadgets:text-dashboard-item-resource', location = 'static/dashboarditem/text/Text.js' */
define("jira-dashboard-items/text", [
    "jquery",
    "underscore"
], function(
    $,
    _
) {
    "use strict";

    var DashboardItem = function(API, options) {
        this.API = API;
        this.options = options;
    };

    DashboardItem.prototype.render = function(element, preferences) {
        $(element).html(JIRA.DashboardItem.Text.Templates.Content());
        this.API.setTitle(preferences.title);

        // Write the HTML content in an iframe to maintain backwards compatibility with
        // users who are using the old text gadget, which displays content in an iframe.
        var gadget = this;
        this.API.once("afterRender", function() {
            var iframe = $(".text-dashboard-item-container iframe", $(element)).get(0);

            writeContentToIframe(iframe, _.unescape(preferences.html));

            // Add our page's styles into the iframe, which otherwise would just have default styling.
            applyPageStylesToIframe(iframe);
            updateIframeHeightToFitContent(iframe);

            gadget.API.resize();
        });
    };

    DashboardItem.prototype.renderEdit = function(element, preferences) {
        var gadget = this;

        preferences.html = _.unescape(preferences.html);

        $(element).html(JIRA.DashboardItem.Text.Templates.Configuration({
            preferences: preferences
        }));

        this.API.once("afterRender", this.API.resize);

        var $form = $("form", $(element));

        $(".cancel", $form).click(function() {
            gadget.API.closeEdit();
        });

        $form.submit(function(event) {
            event.preventDefault();

            var preferences = getPreferencesFromForm($form);
            gadget.API.savePreferences(preferences);
        });
    };

    function writeContentToIframe(iframe, content) {
        iframe.contentWindow.document.open();
        iframe.contentWindow.document.write(content);
        iframe.contentWindow.document.close();
    }

    function getPreferencesFromForm($form) {
        var preferencesArray = $form.serializeArray();
        var preferencesObject = {};

        preferencesArray.forEach(function(element) {
            preferencesObject[element.name] = element.value;
        });

        return preferencesObject;
    }

    function applyPageStylesToIframe(iframe) {
        // Insert the desired styles in the iframe's head.
        // We have to do this inline because css files get batched up in production, so we
        // can't get just the styles we want from the head.
        // We could also infer the styles from the containing element, but that isn't really reliable.
        // This way guarantees that we get the styles we want.

        // Minified from AUI's reset css.
        var auiResetStyles = 'html,body,p,div,h1,h2,h3,h4,h5,h6,img,pre,form,fieldset{margin:0;padding:0}' +
            'ul,ol,dl{margin:0}img,fieldset{border:0}img:-moz-broken{font-size:inherit}' +
            'details,main,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}' +
            'audio:not([controls]){display:none;height:0}[hidden],template{display:none}' +
            'input[type="button"],input[type="submit"],input[type="reset"]{-webkit-appearance:button}';

        // Minified from AUI's page typography css.
        var auiTypographicStyles = '[lang|=en],body{font-family:Arial,sans-serif}' +
            'body{color:#333;font-size:14px;line-height:1.4285714285714}' +
            '[lang|=ja]{font-family:"Hiragino Kaku Gothic Pro","?????? Pro W3","????",Meiryo,"?? ?????",Verdana,Arial,sans-serif}' +
            '.aui-group,.aui-panel,.aui-tabs,blockquote,dl,form.aui,h1,h2,h3,h4,h5,h6,ol,p,pre,table.aui,ul{margin:10px 0 0}' +
            '.aui-group:first-child,.aui-panel:first-child,.aui-tabs:first-child,blockquote:first-child,dl:first-child,form.aui:first-child,h1:first-child,h2:first-child,h3:first-child,h4:first-child,h5:first-child,h6:first-child,ol:first-child,p:first-child,pre:first-child,table.aui:first-child,ul:first-child{margin-top:0}' +
            '.aui-page-header-hero .aui-page-header-main h1,.aui-page-header-hero .aui-page-header-main h2,.aui-page-header-marketing .aui-page-header-main h1,.aui-page-header-marketing .aui-page-header-main h2,h1{color:#333;font-size:32px;font-weight:400;line-height:1.25;text-transform:none;margin:30px 0 0}' +
            'h2{color:#333;font-size:24px;font-weight:400;line-height:1.25;text-transform:none;margin:30px 0 0}' +
            '.aui-page-header-hero .aui-page-header-main p,.aui-page-header-marketing .aui-page-header-main p,h3{color:#333;font-size:20px;font-weight:400;line-height:1.5;text-transform:none;margin:30px 0 0}' +
            'h4,h5,h6{font-weight:700;margin:20px 0 0}' +
            'h6,small{font-size:12px}' +
            'blockquote,h6,q,small{color:#707070}' +
            'h4{color:#333;font-size:16px;line-height:1.25;text-transform:none}' +
            'h5{color:#333;font-size:14px;line-height:1.42857143;text-transform:none}' +
            'h6{line-height:1.66666667;text-transform:uppercase}' +
            'h1:first-child,h2:first-child,h3:first-child,h4:first-child,h5:first-child,h6:first-child{margin-top:0}' +
            'h1+h2,h2+h3,h3+h4,h4+h5,h5+h6{margin-top:10px}' +
            '.aui-group>.aui-item>h1:first-child,.aui-group>.aui-item>h2:first-child,.aui-group>.aui-item>h3:first-child,.aui-group>.aui-item>h4:first-child,.aui-group>.aui-item>h5:first-child,.aui-group>.aui-item>h6:first-child{margin-top:20px}' +
            '.aui-group:first-child>.aui-item>h1:first-child,.aui-group:first-child>.aui-item>h2:first-child,.aui-group:first-child>.aui-item>h3:first-child,.aui-group:first-child>.aui-item>h4:first-child,.aui-group:first-child>.aui-item>h5:first-child,.aui-group:first-child>.aui-item>h6:first-child{margin-top:0}' +
            'small{line-height:1.3333333333333}' +
            'code,kbd{font-family:monospace}' +
            'address,cite,dfn,var{font-style:italic}' +
            'blockquote{border-left:1px solid #ccc;margin-left:19px;padding:10px 20px}' +
            'blockquote>cite{display:block;margin-top:10px}' +
            'q:before{content:open-quote}' +
            'q:after{content:close-quote}' +
            'abbr{border-bottom:1px #707070 dotted;cursor:help}';

        $(iframe.contentWindow.document.head).prepend($('<style></style>').append(auiResetStyles + auiTypographicStyles));
    }

    function updateIframeHeightToFitContent(iframe) {
        $(iframe).css('height', iframe.contentWindow.document.body.scrollHeight);
    }

    return DashboardItem;
});;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard-skate', location = 'js/shims/skate-shim.js' */
define('dashboard/shims/skate', [
    'atlassian/libs/skate-0.12.6'
], function(
    skate
){
    return skate;
});;
;
/* module-key = 'com.atlassian.plugin.jslibs:underscore-1.5.2', location = 'libs/underscore/1.5.2/underscore-1.5.2.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
  define('atlassian/libs/underscore-1.5.2', function() {
    var env = {};
    factory.call(env);
    return env._.noConflict();
  });
})(function(){
/////// End of Atlassian modification ///////

  //     Underscore.js 1.5.2
  //     http://underscorejs.org
  //     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  //     Underscore may be freely distributed under the MIT license.

  (function() {

    // Baseline setup
    // --------------

    // Establish the root object, `window` in the browser, or `exports` on the server.
    var root = this;

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Establish the object that gets returned to break out of a loop iteration.
    var breaker = {};

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var
      push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var
      nativeForEach      = ArrayProto.forEach,
      nativeMap          = ArrayProto.map,
      nativeReduce       = ArrayProto.reduce,
      nativeReduceRight  = ArrayProto.reduceRight,
      nativeFilter       = ArrayProto.filter,
      nativeEvery        = ArrayProto.every,
      nativeSome         = ArrayProto.some,
      nativeIndexOf      = ArrayProto.indexOf,
      nativeLastIndexOf  = ArrayProto.lastIndexOf,
      nativeIsArray      = Array.isArray,
      nativeKeys         = Object.keys,
      nativeBind         = FuncProto.bind;

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) {
      if (obj instanceof _) return obj;
      if (!(this instanceof _)) return new _(obj);
      this._wrapped = obj;
    };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `_` as a global object via a string identifier,
    // for Closure Compiler "advanced" mode.
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = _;
      }
      exports._ = _;
    } else {
      root._ = _;
    }

    // Current version.
    _.VERSION = '1.5.2';

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles objects with the built-in `forEach`, arrays, and raw objects.
    // Delegates to **ECMAScript 5**'s native `forEach` if available.
    var each = _.each = _.forEach = function(obj, iterator, context) {
      if (obj == null) return;
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, length = obj.length; i < length; i++) {
          if (iterator.call(context, obj[i], i, obj) === breaker) return;
        }
      } else {
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
        }
      }
    };

    // Return the results of applying the iterator to each element.
    // Delegates to **ECMAScript 5**'s native `map` if available.
    _.map = _.collect = function(obj, iterator, context) {
      var results = [];
      if (obj == null) return results;
      if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
      each(obj, function(value, index, list) {
        results.push(iterator.call(context, value, index, list));
      });
      return results;
    };

    var reduceError = 'Reduce of empty array with no initial value';

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
    _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
      var initial = arguments.length > 2;
      if (obj == null) obj = [];
      if (nativeReduce && obj.reduce === nativeReduce) {
        if (context) iterator = _.bind(iterator, context);
        return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
      }
      each(obj, function(value, index, list) {
        if (!initial) {
          memo = value;
          initial = true;
        } else {
          memo = iterator.call(context, memo, value, index, list);
        }
      });
      if (!initial) throw new TypeError(reduceError);
      return memo;
    };

    // The right-associative version of reduce, also known as `foldr`.
    // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
    _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
      var initial = arguments.length > 2;
      if (obj == null) obj = [];
      if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
        if (context) iterator = _.bind(iterator, context);
        return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
      }
      var length = obj.length;
      if (length !== +length) {
        var keys = _.keys(obj);
        length = keys.length;
      }
      each(obj, function(value, index, list) {
        index = keys ? keys[--length] : --length;
        if (!initial) {
          memo = obj[index];
          initial = true;
        } else {
          memo = iterator.call(context, memo, obj[index], index, list);
        }
      });
      if (!initial) throw new TypeError(reduceError);
      return memo;
    };

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = function(obj, iterator, context) {
      var result;
      any(obj, function(value, index, list) {
        if (iterator.call(context, value, index, list)) {
          result = value;
          return true;
        }
      });
      return result;
    };

    // Return all the elements that pass a truth test.
    // Delegates to **ECMAScript 5**'s native `filter` if available.
    // Aliased as `select`.
    _.filter = _.select = function(obj, iterator, context) {
      var results = [];
      if (obj == null) return results;
      if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
      each(obj, function(value, index, list) {
        if (iterator.call(context, value, index, list)) results.push(value);
      });
      return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = function(obj, iterator, context) {
      return _.filter(obj, function(value, index, list) {
        return !iterator.call(context, value, index, list);
      }, context);
    };

    // Determine whether all of the elements match a truth test.
    // Delegates to **ECMAScript 5**'s native `every` if available.
    // Aliased as `all`.
    _.every = _.all = function(obj, iterator, context) {
      iterator || (iterator = _.identity);
      var result = true;
      if (obj == null) return result;
      if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
      each(obj, function(value, index, list) {
        if (!(result = result && iterator.call(context, value, index, list))) return breaker;
      });
      return !!result;
    };

    // Determine if at least one element in the object matches a truth test.
    // Delegates to **ECMAScript 5**'s native `some` if available.
    // Aliased as `any`.
    var any = _.some = _.any = function(obj, iterator, context) {
      iterator || (iterator = _.identity);
      var result = false;
      if (obj == null) return result;
      if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
      each(obj, function(value, index, list) {
        if (result || (result = iterator.call(context, value, index, list))) return breaker;
      });
      return !!result;
    };

    // Determine if the array or object contains a given value (using `===`).
    // Aliased as `include`.
    _.contains = _.include = function(obj, target) {
      if (obj == null) return false;
      if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
      return any(obj, function(value) {
        return value === target;
      });
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = function(obj, method) {
      var args = slice.call(arguments, 2);
      var isFunc = _.isFunction(method);
      return _.map(obj, function(value) {
        return (isFunc ? method : value[method]).apply(value, args);
      });
    };

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = function(obj, key) {
      return _.map(obj, function(value){ return value[key]; });
    };

    // Convenience version of a common use case of `filter`: selecting only objects
    // containing specific `key:value` pairs.
    _.where = function(obj, attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return _[first ? 'find' : 'filter'](obj, function(value) {
        for (var key in attrs) {
          if (attrs[key] !== value[key]) return false;
        }
        return true;
      });
    };

    // Convenience version of a common use case of `find`: getting the first object
    // containing specific `key:value` pairs.
    _.findWhere = function(obj, attrs) {
      return _.where(obj, attrs, true);
    };

    // Return the maximum element or (element-based computation).
    // Can't optimize arrays of integers longer than 65,535 elements.
    // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
    _.max = function(obj, iterator, context) {
      if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
        return Math.max.apply(Math, obj);
      }
      if (!iterator && _.isEmpty(obj)) return -Infinity;
      var result = {computed : -Infinity, value: -Infinity};
      each(obj, function(value, index, list) {
        var computed = iterator ? iterator.call(context, value, index, list) : value;
        computed > result.computed && (result = {value : value, computed : computed});
      });
      return result.value;
    };

    // Return the minimum element (or element-based computation).
    _.min = function(obj, iterator, context) {
      if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
        return Math.min.apply(Math, obj);
      }
      if (!iterator && _.isEmpty(obj)) return Infinity;
      var result = {computed : Infinity, value: Infinity};
      each(obj, function(value, index, list) {
        var computed = iterator ? iterator.call(context, value, index, list) : value;
        computed < result.computed && (result = {value : value, computed : computed});
      });
      return result.value;
    };

    // Shuffle an array, using the modern version of the
    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
    _.shuffle = function(obj) {
      var rand;
      var index = 0;
      var shuffled = [];
      each(obj, function(value) {
        rand = _.random(index++);
        shuffled[index - 1] = shuffled[rand];
        shuffled[rand] = value;
      });
      return shuffled;
    };

    // Sample **n** random values from an array.
    // If **n** is not specified, returns a single random element from the array.
    // The internal `guard` argument allows it to work with `map`.
    _.sample = function(obj, n, guard) {
      if (arguments.length < 2 || guard) {
        return obj[_.random(obj.length - 1)];
      }
      return _.shuffle(obj).slice(0, Math.max(0, n));
    };

    // An internal function to generate lookup iterators.
    var lookupIterator = function(value) {
      return _.isFunction(value) ? value : function(obj){ return obj[value]; };
    };

    // Sort the object's values by a criterion produced by an iterator.
    _.sortBy = function(obj, value, context) {
      var iterator = lookupIterator(value);
      return _.pluck(_.map(obj, function(value, index, list) {
        return {
          value: value,
          index: index,
          criteria: iterator.call(context, value, index, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
      }), 'value');
    };

    // An internal function used for aggregate "group by" operations.
    var group = function(behavior) {
      return function(obj, value, context) {
        var result = {};
        var iterator = value == null ? _.identity : lookupIterator(value);
        each(obj, function(value, index) {
          var key = iterator.call(context, value, index, obj);
          behavior(result, key, value);
        });
        return result;
      };
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = group(function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });

    // Indexes the object's values by a criterion, similar to `groupBy`, but for
    // when you know that your index values will be unique.
    _.indexBy = group(function(result, key, value) {
      result[key] = value;
    });

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    _.countBy = group(function(result, key) {
      _.has(result, key) ? result[key]++ : result[key] = 1;
    });

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = function(array, obj, iterator, context) {
      iterator = iterator == null ? _.identity : lookupIterator(iterator);
      var value = iterator.call(context, obj);
      var low = 0, high = array.length;
      while (low < high) {
        var mid = (low + high) >>> 1;
        iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
      }
      return low;
    };

    // Safely create a real, live array from anything iterable.
    _.toArray = function(obj) {
      if (!obj) return [];
      if (_.isArray(obj)) return slice.call(obj);
      if (obj.length === +obj.length) return _.map(obj, _.identity);
      return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = function(obj) {
      if (obj == null) return 0;
      return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
    };

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = function(array, n, guard) {
      if (array == null) return void 0;
      return (n == null) || guard ? array[0] : slice.call(array, 0, n);
    };

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N. The **guard** check allows it to work with
    // `_.map`.
    _.initial = function(array, n, guard) {
      return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
    };

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array. The **guard** check allows it to work with `_.map`.
    _.last = function(array, n, guard) {
      if (array == null) return void 0;
      if ((n == null) || guard) {
        return array[array.length - 1];
      } else {
        return slice.call(array, Math.max(array.length - n, 0));
      }
    };

    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
    // Especially useful on the arguments object. Passing an **n** will return
    // the rest N values in the array. The **guard**
    // check allows it to work with `_.map`.
    _.rest = _.tail = _.drop = function(array, n, guard) {
      return slice.call(array, (n == null) || guard ? 1 : n);
    };

    // Trim out all falsy values from an array.
    _.compact = function(array) {
      return _.filter(array, _.identity);
    };

    // Internal implementation of a recursive `flatten` function.
    var flatten = function(input, shallow, output) {
      if (shallow && _.every(input, _.isArray)) {
        return concat.apply(output, input);
      }
      each(input, function(value) {
        if (_.isArray(value) || _.isArguments(value)) {
          shallow ? push.apply(output, value) : flatten(value, shallow, output);
        } else {
          output.push(value);
        }
      });
      return output;
    };

    // Flatten out an array, either recursively (by default), or just one level.
    _.flatten = function(array, shallow) {
      return flatten(array, shallow, []);
    };

    // Return a version of the array that does not contain the specified value(s).
    _.without = function(array) {
      return _.difference(array, slice.call(arguments, 1));
    };

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = function(array, isSorted, iterator, context) {
      if (_.isFunction(isSorted)) {
        context = iterator;
        iterator = isSorted;
        isSorted = false;
      }
      var initial = iterator ? _.map(array, iterator, context) : array;
      var results = [];
      var seen = [];
      each(initial, function(value, index) {
        if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
          seen.push(value);
          results.push(array[index]);
        }
      });
      return results;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = function() {
      return _.uniq(_.flatten(arguments, true));
    };

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    _.intersection = function(array) {
      var rest = slice.call(arguments, 1);
      return _.filter(_.uniq(array), function(item) {
        return _.every(rest, function(other) {
          return _.indexOf(other, item) >= 0;
        });
      });
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = function(array) {
      var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
      return _.filter(array, function(value){ return !_.contains(rest, value); });
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = function() {
      var length = _.max(_.pluck(arguments, "length").concat(0));
      var results = new Array(length);
      for (var i = 0; i < length; i++) {
        results[i] = _.pluck(arguments, '' + i);
      }
      return results;
    };

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values.
    _.object = function(list, values) {
      if (list == null) return {};
      var result = {};
      for (var i = 0, length = list.length; i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    };

    // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
    // we need this function. Return the position of the first occurrence of an
    // item in an array, or -1 if the item is not included in the array.
    // Delegates to **ECMAScript 5**'s native `indexOf` if available.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = function(array, item, isSorted) {
      if (array == null) return -1;
      var i = 0, length = array.length;
      if (isSorted) {
        if (typeof isSorted == 'number') {
          i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
        } else {
          i = _.sortedIndex(array, item);
          return array[i] === item ? i : -1;
        }
      }
      if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
      for (; i < length; i++) if (array[i] === item) return i;
      return -1;
    };

    // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
    _.lastIndexOf = function(array, item, from) {
      if (array == null) return -1;
      var hasIndex = from != null;
      if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
        return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
      }
      var i = (hasIndex ? from : array.length);
      while (i--) if (array[i] === item) return i;
      return -1;
    };

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function(start, stop, step) {
      if (arguments.length <= 1) {
        stop = start || 0;
        start = 0;
      }
      step = arguments[2] || 1;

      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var idx = 0;
      var range = new Array(length);

      while(idx < length) {
        range[idx++] = start;
        start += step;
      }

      return range;
    };

    // Function (ahem) Functions
    // ------------------

    // Reusable constructor function for prototype setting.
    var ctor = function(){};

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
    // available.
    _.bind = function(func, context) {
      var args, bound;
      if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
      if (!_.isFunction(func)) throw new TypeError;
      args = slice.call(arguments, 2);
      return bound = function() {
        if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
        ctor.prototype = func.prototype;
        var self = new ctor;
        ctor.prototype = null;
        var result = func.apply(self, args.concat(slice.call(arguments)));
        if (Object(result) === result) return result;
        return self;
      };
    };

    // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context.
    _.partial = function(func) {
      var args = slice.call(arguments, 1);
      return function() {
        return func.apply(this, args.concat(slice.call(arguments)));
      };
    };

    // Bind all of an object's methods to that object. Useful for ensuring that
    // all callbacks defined on an object belong to it.
    _.bindAll = function(obj) {
      var funcs = slice.call(arguments, 1);
      if (funcs.length === 0) throw new Error("bindAll must be passed function names");
      each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
      return obj;
    };

    // Memoize an expensive function by storing its results.
    _.memoize = function(func, hasher) {
      var memo = {};
      hasher || (hasher = _.identity);
      return function() {
        var key = hasher.apply(this, arguments);
        return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
      };
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = function(func, wait) {
      var args = slice.call(arguments, 2);
      return setTimeout(function(){ return func.apply(null, args); }, wait);
    };

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = function(func) {
      return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
    };

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    _.throttle = function(func, wait, options) {
      var context, args, result;
      var timeout = null;
      var previous = 0;
      options || (options = {});
      var later = function() {
        previous = options.leading === false ? 0 : new Date;
        timeout = null;
        result = func.apply(context, args);
      };
      return function() {
        var now = new Date;
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0) {
          clearTimeout(timeout);
          timeout = null;
          previous = now;
          result = func.apply(context, args);
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = function(func, wait, immediate) {
      var timeout, args, context, timestamp, result;
      return function() {
        context = this;
        args = arguments;
        timestamp = new Date();
        var later = function() {
          var last = (new Date()) - timestamp;
          if (last < wait) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) result = func.apply(context, args);
          }
        };
        var callNow = immediate && !timeout;
        if (!timeout) {
          timeout = setTimeout(later, wait);
        }
        if (callNow) result = func.apply(context, args);
        return result;
      };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = function(func) {
      var ran = false, memo;
      return function() {
        if (ran) return memo;
        ran = true;
        memo = func.apply(this, arguments);
        func = null;
        return memo;
      };
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = function(func, wrapper) {
      return function() {
        var args = [func];
        push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function() {
      var funcs = arguments;
      return function() {
        var args = arguments;
        for (var i = funcs.length - 1; i >= 0; i--) {
          args = [funcs[i].apply(this, args)];
        }
        return args[0];
      };
    };

    // Returns a function that will only be executed after being called N times.
    _.after = function(times, func) {
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    };

    // Object Functions
    // ----------------

    // Retrieve the names of an object's properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`
    _.keys = nativeKeys || function(obj) {
      if (obj !== Object(obj)) throw new TypeError('Invalid object');
      var keys = [];
      for (var key in obj) if (_.has(obj, key)) keys.push(key);
      return keys;
    };

    // Retrieve the values of an object's properties.
    _.values = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var values = new Array(length);
      for (var i = 0; i < length; i++) {
        values[i] = obj[keys[i]];
      }
      return values;
    };

    // Convert an object into a list of `[key, value]` pairs.
    _.pairs = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var pairs = new Array(length);
      for (var i = 0; i < length; i++) {
        pairs[i] = [keys[i], obj[keys[i]]];
      }
      return pairs;
    };

    // Invert the keys and values of an object. The values must be serializable.
    _.invert = function(obj) {
      var result = {};
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        result[obj[keys[i]]] = keys[i];
      }
      return result;
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`
    _.functions = _.methods = function(obj) {
      var names = [];
      for (var key in obj) {
        if (_.isFunction(obj[key])) names.push(key);
      }
      return names.sort();
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = function(obj) {
      each(slice.call(arguments, 1), function(source) {
        if (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      });
      return obj;
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = function(obj) {
      var copy = {};
      var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
      each(keys, function(key) {
        if (key in obj) copy[key] = obj[key];
      });
      return copy;
    };

     // Return a copy of the object without the blacklisted properties.
    _.omit = function(obj) {
      var copy = {};
      var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
      for (var key in obj) {
        if (!_.contains(keys, key)) copy[key] = obj[key];
      }
      return copy;
    };

    // Fill in a given object with default properties.
    _.defaults = function(obj) {
      each(slice.call(arguments, 1), function(source) {
        if (source) {
          for (var prop in source) {
            if (obj[prop] === void 0) obj[prop] = source[prop];
          }
        }
      });
      return obj;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = function(obj) {
      if (!_.isObject(obj)) return obj;
      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = function(obj, interceptor) {
      interceptor(obj);
      return obj;
    };

    // Internal recursive comparison function for `isEqual`.
    var eq = function(a, b, aStack, bStack) {
      // Identical objects are equal. `0 === -0`, but they aren't identical.
      // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
      if (a === b) return a !== 0 || 1 / a == 1 / b;
      // A strict comparison is necessary because `null == undefined`.
      if (a == null || b == null) return a === b;
      // Unwrap any wrapped objects.
      if (a instanceof _) a = a._wrapped;
      if (b instanceof _) b = b._wrapped;
      // Compare `[[Class]]` names.
      var className = toString.call(a);
      if (className != toString.call(b)) return false;
      switch (className) {
        // Strings, numbers, dates, and booleans are compared by value.
        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return a == String(b);
        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
          // other numeric values.
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') return false;
      // Assume equality for cyclic structures. The algorithm for detecting cyclic
      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
      var length = aStack.length;
      while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] == a) return bStack[length] == b;
      }
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Add the first object to the stack of traversed objects.
      aStack.push(a);
      bStack.push(b);
      var size = 0, result = true;
      // Recursively compare objects and arrays.
      if (className == '[object Array]') {
        // Compare array lengths to determine if a deep comparison is necessary.
        size = a.length;
        result = size == b.length;
        if (result) {
          // Deep compare the contents, ignoring non-numeric properties.
          while (size--) {
            if (!(result = eq(a[size], b[size], aStack, bStack))) break;
          }
        }
      } else {
        // Deep compare objects.
        for (var key in a) {
          if (_.has(a, key)) {
            // Count the expected number of properties.
            size++;
            // Deep compare each member.
            if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
          }
        }
        // Ensure that both objects contain the same number of properties.
        if (result) {
          for (key in b) {
            if (_.has(b, key) && !(size--)) break;
          }
          result = !size;
        }
      }
      // Remove the first object from the stack of traversed objects.
      aStack.pop();
      bStack.pop();
      return result;
    };

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = function(a, b) {
      return eq(a, b, [], []);
    };

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = function(obj) {
      if (obj == null) return true;
      if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
      for (var key in obj) if (_.has(obj, key)) return false;
      return true;
    };

    // Is a given value a DOM element?
    _.isElement = function(obj) {
      return !!(obj && obj.nodeType === 1);
    };

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || function(obj) {
      return toString.call(obj) == '[object Array]';
    };

    // Is a given variable an object?
    _.isObject = function(obj) {
      return obj === Object(obj);
    };

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
    each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
      _['is' + name] = function(obj) {
        return toString.call(obj) == '[object ' + name + ']';
      };
    });

    // Define a fallback version of the method in browsers (ahem, IE), where
    // there isn't any inspectable "Arguments" type.
    if (!_.isArguments(arguments)) {
      _.isArguments = function(obj) {
        return !!(obj && _.has(obj, 'callee'));
      };
    }

    // Optimize `isFunction` if appropriate.
    if (typeof (/./) !== 'function') {
      _.isFunction = function(obj) {
        return typeof obj === 'function';
      };
    }

    // Is a given object a finite number?
    _.isFinite = function(obj) {
      return isFinite(obj) && !isNaN(parseFloat(obj));
    };

    // Is the given value `NaN`? (NaN is the only number which does not equal itself).
    _.isNaN = function(obj) {
      return _.isNumber(obj) && obj != +obj;
    };

    // Is a given value a boolean?
    _.isBoolean = function(obj) {
      return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
    };

    // Is a given value equal to null?
    _.isNull = function(obj) {
      return obj === null;
    };

    // Is a given variable undefined?
    _.isUndefined = function(obj) {
      return obj === void 0;
    };

    // Shortcut function for checking if an object has a given property directly
    // on itself (in other words, not on a prototype).
    _.has = function(obj, key) {
      return hasOwnProperty.call(obj, key);
    };

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function() {
      root._ = previousUnderscore;
      return this;
    };

    // Keep the identity function around for default iterators.
    _.identity = function(value) {
      return value;
    };

    // Run a function **n** times.
    _.times = function(n, iterator, context) {
      var accum = Array(Math.max(0, n));
      for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
      return accum;
    };

    // Return a random integer between min and max (inclusive).
    _.random = function(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    };

    // List of HTML entities for escaping.
    var entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      }
    };
    entityMap.unescape = _.invert(entityMap.escape);

    // Regexes containing the keys and values listed immediately above.
    var entityRegexes = {
      escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
      unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
    };

    // Functions for escaping and unescaping strings to/from HTML interpolation.
    _.each(['escape', 'unescape'], function(method) {
      _[method] = function(string) {
        if (string == null) return '';
        return ('' + string).replace(entityRegexes[method], function(match) {
          return entityMap[method][match];
        });
      };
    });

    // If the value of the named `property` is a function then invoke it with the
    // `object` as context; otherwise, return it.
    _.result = function(object, property) {
      if (object == null) return void 0;
      var value = object[property];
      return _.isFunction(value) ? value.call(object) : value;
    };

    // Add your own custom functions to the Underscore object.
    _.mixin = function(obj) {
      each(_.functions(obj), function(name) {
        var func = _[name] = obj[name];
        _.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return result.call(this, func.apply(_, args));
        };
      });
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = function(prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
      evaluate    : /<%([\s\S]+?)%>/g,
      interpolate : /<%=([\s\S]+?)%>/g,
      escape      : /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'":      "'",
      '\\':     '\\',
      '\r':     'r',
      '\n':     'n',
      '\t':     't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    _.template = function(text, data, settings) {
      var render;
      settings = _.defaults({}, settings, _.templateSettings);

      // Combine delimiters into one regular expression via alternation.
      var matcher = new RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');

      // Compile the template source, escaping string literals appropriately.
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset)
          .replace(escaper, function(match) { return '\\' + escapes[match]; });

        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        }
        if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        }
        if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }
        index = offset + match.length;
        return match;
      });
      source += "';\n";

      // If a variable is not specified, place data values in local scope.
      if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

      source = "var __t,__p='',__j=Array.prototype.join," +
        "print=function(){__p+=__j.call(arguments,'');};\n" +
        source + "return __p;\n";

      try {
        render = new Function(settings.variable || 'obj', '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }

      if (data) return render(data, _);
      var template = function(data) {
        return render.call(this, data, _);
      };

      // Provide the compiled function source as a convenience for precompilation.
      template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

      return template;
    };

    // Add a "chain" function, which will delegate to the wrapper.
    _.chain = function(obj) {
      return _(obj).chain();
    };

    // OOP
    // ---------------
    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.

    // Helper function to continue chaining intermediate results.
    var result = function(obj) {
      return this._chain ? _(obj).chain() : obj;
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        method.apply(obj, arguments);
        if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
        return result.call(this, obj);
      };
    });

    // Add all accessor Array functions to the wrapper.
    each(['concat', 'join', 'slice'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        return result.call(this, method.apply(this._wrapped, arguments));
      };
    });

    _.extend(_.prototype, {

      // Start chaining a wrapped Underscore object.
      chain: function() {
        this._chain = true;
        return this;
      },

      // Extracts the result from a wrapped and chained object.
      value: function() {
        return this._wrapped;
      }

    });

  }).call(this);

/////////// Modified by Atlassian ///////////
});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard-underscore', location = 'js/shims/underscore-shim.js' */
define('dashboard/shims/underscore', [
    'atlassian/libs/underscore-1.5.2'
], function(
    _
){
    return _;
});;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard-prod', location = 'js/components/dashboard.js' */
define('dashboard/components/dashboard-layout', [
    'dashboard/shims/skate'
], function(
    skate
){
    return skate('dashboard', {
        type: skate.types.TAG,

        attached: function(elem) {
            AG.DashboardManager.setup({
                layouts: JSON.parse(elem.getAttribute('layouts')).layouts,
                params: JSON.parse(elem.getAttribute('params'))
            });
        },

        events: {
            'click .dashboard-tab-link': function() {
                AJS.trigger('analyticsEvent', {
                    name: 'gadgets.dashboard.tab.link.click'
                });
            }
        }
    });
});;
;
/* module-key = 'com.atlassian.gadgets.dashboard:dashboard-prod', location = 'js/components-init.js' */
require([
    'dashboard/components/dashboard-layout'
]);;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/rpc.js' */
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Remote procedure call library for gadget-to-container,
 * container-to-gadget, and gadget-to-gadget (thru container) communication.
 *
 *
 */

var gadgets = gadgets || {};

/**
 * @static
 * @class Provides operations for making rpc calls.
 * @name gadgets.rpc
 */
gadgets.rpc = function() {
  // General constants.
  var CALLBACK_NAME = '__cb';
  var DEFAULT_NAME = '';

  // Consts for FrameElement.
  var FE_G2C_CHANNEL = '__g2c_rpc';
  var FE_C2G_CHANNEL = '__c2g_rpc';

  var services = {};
  var iframePool = [];
  var relayUrl = {};
  var useLegacyProtocol = {};
  var authToken = {};
  var callId = 0;
  var callbacks = {};
  var setup = {};
  var sameDomain = {};

  var params = {};

  // Load the authentication token for speaking to the container
  // from the gadget's parameters, or default to '0' if not found.
  if (gadgets.util) {
    params = gadgets.util.getUrlParameters();
  }

  authToken['..'] = params.rpctoken || params.ifpctok || 0;

  /*
   * Return a short code representing the best available cross-domain
   * message transport available to the browser.
   *
   * + For those browsers that support native messaging (various implementations
   *   of the HTML5 postMessage method), use that. Officially defined at
   *   http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html.
   *
   *   postMessage is a native implementation of XDC. A page registers that
   *   it would like to receive messages by listening the the "message" event
   *   on the window (document in DPM) object. In turn, another page can
   *   raise that event by calling window.postMessage (document.postMessage
   *   in DPM) with a string representing the message and a string
   *   indicating on which domain the receiving page must be to receive
   *   the message. The target page will then have its "message" event raised
   *   if the domain matches and can, in turn, check the origin of the message
   *   and process the data contained within.
   *
   *     wpm: postMessage on the window object.
   *        - Internet Explorer 8+
   *        - Safari (latest nightlies as of 26/6/2008)
   *        - Firefox 3+
   *        - Opera 9+
   *
   *     dpm: postMessage on the document object.
   *        - Opera 8+
   *
   * + For Gecko-based browsers, the security model allows a child to call a
   *   function on the frameElement of the iframe, even if the child is in
   *   a different domain. This method is dubbed "frameElement" (fe).
   *
   *   The ability to add and call such functions on the frameElement allows
   *   a bidirectional channel to be setup via the adding of simple function
   *   references on the frameElement object itself. In this implementation,
   *   when the container sets up the authentication information for that gadget
   *   (by calling setAuth(...)) it as well adds a special function on the
   *   gadget's iframe. This function can then be used by the gadget to send
   *   messages to the container. In turn, when the gadget tries to send a
   *   message, it checks to see if this function has its own function stored
   *   that can be used by the container to call the gadget. If not, the
   *   function is created and subsequently used by the container.
   *   Note that as a result, FE can only be used by a container to call a
   *   particular gadget *after* that gadget has called the container at
   *   least once via FE.
   *
   *     fe: Gecko-specific frameElement trick.
   *        - Firefox 1+
   *
   * + For all others, we have a fallback mechanism known as "ifpc". IFPC
   *   exploits the fact that while same-origin policy prohibits a frame from
   *   accessing members on a window not in the same domain, that frame can,
   *   however, navigate the window heirarchy (via parent). This is exploited by
   *   having a page on domain A that wants to talk to domain B create an iframe
   *   on domain B pointing to a special relay file and with a message encoded
   *   after the hash (#). This relay, in turn, finds the page on domain B, and
   *   can call a receipt function with the message given to it. The relay URL
   *   used by each caller is set via the gadgets.rpc.setRelayUrl(..) and
   *   *must* be called before the call method is used.
   *
   *     ifpc: Iframe-based method, utilizing a relay page, to send a message.
   */
  function getRelayChannel() {
    return typeof window.postMessage === 'function' ? 'wpm' :
        typeof document.postMessage === 'function' ? 'dpm' :
            navigator.product === 'Gecko' ? 'fe' :
                'ifpc';
  }

  /**
   * Conducts any initial global work necessary to setup the
   * channel type chosen.
   */
  function setupChannel() {
    // If the channel type is one of the native
    // postMessage based ones, setup the handler to receive
    // messages.
    if (relayChannel === 'dpm' || relayChannel === 'wpm') {
      window.addEventListener('message', function(packet) {
        // JRA-36335: Anyone could be publishing a 'message' so need to make sure
        // we handle errors more gracefully in case the packet doesn't contain what
        // was expected
        try {
          if (packet && packet.origin && packet.origin !== "null" && typeof packet.data === 'string' ) {
            AJS.$.get(AJS.contextPath() + '/rest/whitelist/1/check', {url: packet.origin})
                .done(function (result) {
                  if (result && result.inbound && result.inbound === true) {
                    process(gadgets.json.parse(packet.data));
                  }
                  else {
                    if(AJS.debug) {
                      AJS.log("RPC: request rejected (bad origin): " + (packet && packet.origin ? packet.origin : "undefined origin"));
                    }
                  }
                })
                .fail(function (jqXHR, textStatus, errorThrown) {
                  AJS.log('RPC: REST ' + textStatus, errorThrown);
                });
          } else {
            if(AJS.debug) {
              AJS.log("RPC: request rejected (bad origin): " + (packet && packet.origin ? packet.origin : "undefined origin"));
            }
          }
        } catch (e) {
          if (AJS.debug) {
            var origin = packet && packet.origin ? packet.origin : "undefined origin";
            AJS.log("Error processing gadget rpc message from '" + origin + "': " + e);
          }
        }
      }, false);
    }
  }

  // Pick the most efficient RPC relay mechanism
  var relayChannel = getRelayChannel();

  // Conduct any setup necessary for the chosen channel.
  setupChannel();

  // Create the Default RPC handler.
  services[DEFAULT_NAME] = function() {
    throw new Error('Unknown RPC service: ' + this.s);
  };

  // Create a Special RPC handler for callbacks.
  services[CALLBACK_NAME] = function(callbackId, result) {
    var callback = callbacks[callbackId];
    if (callback) {
      delete callbacks[callbackId];
      callback(result);
    }
  };

  /**
   * Conducts any frame-specific work necessary to setup
   * the channel type chosen. This method is called when
   * the container page first registers the gadget in the
   * RPC mechanism. Gadgets, in turn, will complete the setup
   * of the channel once they send their first messages.
   */
  function setupFrame(frameId) {
    if (setup[frameId]) {
      return;
    }

    if (relayChannel === 'fe') {
      try {
        var frame = document.getElementById(frameId);
        frame[FE_G2C_CHANNEL] = function(args) {
          process(gadgets.json.parse(args));
        };
      } catch (e) {
        // Something went wrong. System will fallback to
        // IFPC.
      }
    }

    setup[frameId] = true;
  }

  /**
   * Encodes arguments for the legacy IFPC wire format.
   *
   * @param {Object} args
   * @return {String} the encoded args
   */
  function encodeLegacyData(args) {
    var stringify = gadgets.json.stringify;
    var argsEscaped = [];
    for(var i = 0, j = args.length; i < j; ++i) {
      argsEscaped.push(encodeURIComponent(stringify(args[i])));
    }
    return argsEscaped.join('&');
  }

  /**
   * Helper function to process an RPC request
   * @param {Object} rpc RPC request object
   * @private
   */
  function process(rpc) {
    //
    // RPC object contents:
    //   s: Service Name
    //   f: From
    //   c: The callback ID or 0 if none.
    //   a: The arguments for this RPC call.
    //   t: The authentication token.
    //
    if (rpc && typeof rpc.s === 'string' && typeof rpc.f === 'string' &&
        rpc.a instanceof Array) {

      // Validate auth token.
      if (authToken[rpc.f]) {
        // We allow type coercion here because all the url params are strings.
        if (authToken[rpc.f] != rpc.t) {
          if (AJS.debug) {
            console.log('Invalid auth token received for operation: ' + rpc.s);
          }
          return;
        }
      }

      // If there is a callback for this service, attach a callback function
      // to the rpc context object for asynchronous rpc services.
      //
      // Synchronous rpc request handlers should simply ignore it and return a
      // value as usual.
      // Asynchronous rpc request handlers, on the other hand, should pass its
      // result to this callback function and not return a value on exit.
      //
      // For example, the following rpc handler passes the first parameter back
      // to its rpc client with a one-second delay.
      //
      // function asyncRpcHandler(param) {
      //   var me = this;
      //   setTimeout(function() {
      //     me.callback(param);
      //   }, 1000);
      // }
      if (rpc.c) {
        rpc.callback = function(result) {
          gadgets.rpc.call(rpc.f, CALLBACK_NAME, null, rpc.c, result);
        };
      }

      // Call the requested RPC service.
      var result = (services[rpc.s] ||
      services[DEFAULT_NAME]).apply(rpc, rpc.a);

      // If the rpc request handler returns a value, immediately pass it back
      // to the callback. Otherwise, do nothing, assuming that the rpc handler
      // will make an asynchronous call later.
      if (rpc.c && typeof result != 'undefined') {
        gadgets.rpc.call(rpc.f, CALLBACK_NAME, null, rpc.c, result);
      }
    }
  }

  /**
   * Attempts to conduct an RPC call to the specified
   * target with the specified data via the FrameElement
   * method. If this method fails, the system attempts again
   * using the known default of IFPC.
   *
   * @param {String} targetId Module Id of the RPC service provider.
   * @param {String} serviceName Service name to call.
   * @param {String} from Module Id of the calling provider.
   * @param {Object} rpcData The RPC data for this call.
   * @param {Array.<Object>} callArgs Original arguments to call()
   */
  function callFrameElement(targetId, serviceName, from, rpcData, callArgs) {
    try {
      if (from != '..') {
        // Call from gadget to the container.
        var fe = window.frameElement;

        if (typeof fe[FE_G2C_CHANNEL] === 'function') {
          // Complete the setup of the FE channel if need be.
          if (typeof fe[FE_G2C_CHANNEL][FE_C2G_CHANNEL] !== 'function') {
            fe[FE_G2C_CHANNEL][FE_C2G_CHANNEL] = function(args) {
              process(gadgets.json.parse(args));
            };
          }

          // Conduct the RPC call.
          fe[FE_G2C_CHANNEL](rpcData);
          return;
        }
      } else {
        // Call from container to gadget[targetId].
        var frame = document.getElementById(targetId);

        if (typeof frame[FE_G2C_CHANNEL] === 'function' &&
            typeof frame[FE_G2C_CHANNEL][FE_C2G_CHANNEL] === 'function') {

          // Conduct the RPC call.
          frame[FE_G2C_CHANNEL][FE_C2G_CHANNEL](rpcData);
          return;
        }
      }
    } catch (e) {
    }

    // If we have reached this point, something has failed
    // with the FrameElement method, so we default to using
    // IFPC for this call.
    callIfpc(targetId, serviceName, from, rpcData, callArgs);
  }

  /**
   * Conducts an RPC call to the specified
   * target with the specified data via the IFPC
   * method.
   *
   * @param {String} targetId Module Id of the RPC service provider.
   * @param {String} serviceName Service name to call.
   * @param {String} from Module Id of the calling provider.
   * @param {Object} rpcData The RPC data for this call.
   * @param {Array.<Object>} callArgs Original arguments to call()
   */
  function callIfpc(targetId, serviceName, from, rpcData, callArgs) {
    // Retrieve the relay file used by IFPC. Note that
    // this must be set before the call, and so we conduct
    // an extra check to ensure it is not blank.
    var relay = gadgets.rpc.getRelayUrl(targetId);

    if (!relay) {
      throw new Error('No relay file assigned for IFPC');
    }

    // The RPC mechanism supports two formats for IFPC (legacy and current).
    var src = null;
    if (useLegacyProtocol[targetId]) {
      // Format: #iframe_id&callId&num_packets&packet_num&block_of_data
      src = [relay, '#', encodeLegacyData([from, callId, 1, 0,
        encodeLegacyData([from, serviceName, '', '', from].concat(
            callArgs))])].join('');
    } else {
      // Format: #targetId & sourceId@callId & packetNum & packetId & packetData
      src = [relay, '#', targetId, '&', from, '@', callId,
        '&1&0&', encodeURIComponent(rpcData)].join('');
    }

    // Conduct the IFPC call by creating the Iframe with
    // the relay URL and appended message.
    emitInvisibleIframe(src);
  }


  /**
   * Helper function to emit an invisible IFrame.
   * @param {String} src SRC attribute of the IFrame to emit.
   * @private
   */
  function emitInvisibleIframe(src) {
    var iframe;
    // Recycle IFrames
    for (var i = iframePool.length - 1; i >=0; --i) {
      var ifr = iframePool[i];
      try {
        if (ifr && (ifr.recyclable || ifr.readyState === 'complete')) {
          ifr.parentNode.removeChild(ifr);
          if (window.ActiveXObject) {
            // For MSIE, delete any iframes that are no longer being used. MSIE
            // cannot reuse the IFRAME because a navigational click sound will
            // be triggered when we set the SRC attribute.
            // Other browsers scan the pool for a free iframe to reuse.
            iframePool[i] = ifr = null;
            iframePool.splice(i, 1);
          } else {
            ifr.recyclable = false;
            iframe = ifr;
            break;
          }
        }
      } catch (e) {
        // Ignore; IE7 throws an exception when trying to read readyState and
        // readyState isn't set.
      }
    }
    // Create IFrame if necessary
    if (!iframe) {
      iframe = document.createElement('iframe');
      iframe.style.border = iframe.style.width = iframe.style.height = '0px';
      iframe.style.visibility = 'hidden';
      iframe.style.position = 'absolute';
      iframe.onload = function() { this.recyclable = true; };
      iframePool.push(iframe);
    }
    iframe.src = src;
    setTimeout(function() { document.body.appendChild(iframe); }, 0);
  }

  /**
   * Attempts to make an rpc by calling the target's receive method directly.
   * This works when gadgets are rendered on the same domain as their container,
   * a potentially useful optimization for trusted content which keeps
   * RPC behind a consistent interface.
   * @param {String} target Module id of the rpc service provider
   * @param {String} from Module id of the caller (this)
   * @param {String} callbackId Id of the call
   * @param {String} rpcData JSON-encoded RPC payload
   * @return
   */
  function callSameDomain(target, rpc) {
    if (typeof sameDomain[target] === 'undefined') {
      // Seed with a negative, typed value to avoid
      // hitting this code path repeatedly
      sameDomain[target] = false;
      var targetEl = null;
      if (target === '..') {
        targetEl = parent;
      } else {
        targetEl = frames[target];
      }
      try {
        // If this succeeds, then same-domain policy applied
        sameDomain[target] = targetEl.gadgets.rpc.receiveSameDomain;
      } catch (e) {
        // Usual case: different domains
      }
    }

    if (typeof sameDomain[target] === 'function') {
      // Call target's receive method
      sameDomain[target](rpc);
      return true;
    }

    return false;
  }

  // gadgets.config might not be available, such as when serving container js.
  if (gadgets.config) {
    /**
     * Initializes RPC from the provided configuration.
     */
    function init(config) {
      // Allow for wild card parent relay files as long as it's from a
      // white listed domain. This is enforced by the rendering servlet.
      if (config.rpc.parentRelayUrl.substring(0, 7) === 'http://') {
        relayUrl['..'] = config.rpc.parentRelayUrl;
      } else {
        // It's a relative path, and we must append to the parent.
        // We're relying on the server validating the parent parameter in this
        // case. Because of this, parent may only be passed in the query, not
        // the fragment.
        var params = document.location.search.substring(0).split("&");
        var parentParam = "";
        for (var i = 0, param; param = params[i]; ++i) {
          // Only the first parent can be validated.
          if (param.indexOf("parent=") === 0) {
            parentParam = decodeURIComponent(param.substring(7));
            break;
          }
        }
        relayUrl['..'] = parentParam + config.rpc.parentRelayUrl;
      }
      useLegacyProtocol['..'] = !!config.rpc.useLegacyProtocol;
    }

    var requiredConfig = {
      parentRelayUrl : gadgets.config.NonEmptyStringValidator
    };
    gadgets.config.register("rpc", requiredConfig, init);
  }

  return /** @scope gadgets.rpc */ {
    /**
     * Registers an RPC service.
     * @param {String} serviceName Service name to register.
     * @param {Function} handler Service handler.
     *
     * @member gadgets.rpc
     */
    register: function(serviceName, handler) {
      if (serviceName == CALLBACK_NAME) {
        throw new Error("Cannot overwrite callback service");
      }

      if (serviceName == DEFAULT_NAME) {
        throw new Error("Cannot overwrite default service:"
            + " use registerDefault");
      }

      services[serviceName] = handler;
    },

    /**
     * Unregisters an RPC service.
     * @param {String} serviceName Service name to unregister.
     *
     * @member gadgets.rpc
     */
    unregister: function(serviceName) {
      if (serviceName == CALLBACK_NAME) {
        throw new Error("Cannot delete callback service");
      }

      if (serviceName == DEFAULT_NAME) {
        throw new Error("Cannot delete default service:"
            + " use unregisterDefault");
      }

      delete services[serviceName];
    },

    /**
     * Registers a default service handler to processes all unknown
     * RPC calls which raise an exception by default.
     * @param {Function} handler Service handler.
     *
     * @member gadgets.rpc
     */
    registerDefault: function(handler) {
      services[''] = handler;
    },

    /**
     * Unregisters the default service handler. Future unknown RPC
     * calls will fail silently.
     *
     * @member gadgets.rpc
     */
    unregisterDefault: function() {
      delete services[''];
    },

    /**
     * Calls an RPC service.
     * @param {String} targetId Module Id of the RPC service provider.
     *                          Empty if calling the parent container.
     * @param {String} serviceName Service name to call.
     * @param {Function|null} callback Callback function (if any) to process
     *                                 the return value of the RPC request.
     * @param {*} var_args Parameters for the RPC request.
     *
     * @member gadgets.rpc
     */
    call: function(targetId, serviceName, callback, var_args) {
      ++callId;
      targetId = targetId || '..';
      if (callback) {
        callbacks[callId] = callback;
      }

      // Default to the container calling.
      var from = '..';

      if (targetId === '..') {
        from = window.name;
      }

      // Not used by legacy, create it anyway...
      var rpc = {
        s: serviceName,
        f: from,
        c: callback ? callId : 0,
        a: Array.prototype.slice.call(arguments, 3),
        t: authToken[targetId]
      };

      // If target is on the same domain, call method directly
      if (callSameDomain(targetId, rpc)) {
        return;
      }

      var rpcData = gadgets.json.stringify(rpc);

      var channelType = relayChannel;

      // If we are told to use the legacy format, then we must
      // default to IFPC.
      if (useLegacyProtocol[targetId]) {
        channelType = 'ifpc';
      }

      switch (channelType) {
        case 'dpm': // use document.postMessage.
          var targetDoc = targetId === '..' ? parent.document :
              frames[targetId].document;
          targetDoc.postMessage(rpcData);
          break;

        case 'wpm': // use window.postMessage.
          var targetWin = targetId === '..' ? parent : frames[targetId];
          targetWin.postMessage(rpcData, relayUrl[targetId]);
          break;

        case 'fe': // use FrameElement.
          callFrameElement(targetId, serviceName, from, rpcData, rpc.a);
          break;

        default: // use 'ifpc' as a fallback mechanism.
          callIfpc(targetId, serviceName, from, rpcData, rpc.a);
          break;
      }
    },

    /**
     * Gets the relay URL of a target frame.
     * @param {String} targetId Name of the target frame.
     * @return {String|undefined} Relay URL of the target frame.
     *
     * @member gadgets.rpc
     */
    getRelayUrl: function(targetId) {
      return relayUrl[targetId];
    },

    /**
     * Sets the relay URL of a target frame.
     * @param {String} targetId Name of the target frame.
     * @param {String} url Full relay URL of the target frame.
     * @param {Boolean} opt_useLegacy True if this relay needs the legacy IFPC
     *     wire format.
     *
     * @member gadgets.rpc
     */
    setRelayUrl: function(targetId, url, opt_useLegacy) {
      relayUrl[targetId] = url;
      useLegacyProtocol[targetId] = !!opt_useLegacy;
    },

    /**
     * Sets the auth token of a target frame.
     * @param {String} targetId Name of the target frame.
     * @param {String} token The authentication token to use for all
     *     calls to or from this target id.
     *
     * @member gadgets.rpc
     */
    setAuthToken: function(targetId, token) {
      authToken[targetId] = token;
      setupFrame(targetId);
    },

    /**
     * Gets the RPC relay mechanism.
     * @return {String} RPC relay mechanism. See above for
     *   a list of supported types.
     *
     * @member gadgets.rpc
     */
    getRelayChannel: function() {
      return relayChannel;
    },

    /**
     * Receives and processes an RPC request. (Not to be used directly.)
     * @param {Array.<String>} fragment An RPC request fragment encoded as
     *        an array. The first 4 elements are target id, source id & call id,
     *        total packet number, packet id. The last element stores the actual
     *        JSON-encoded and URI escaped packet data.
     *
     * @member gadgets.rpc
     */
    receive: function(fragment) {
      if (fragment.length > 4) {
        // TODO parse fragment[1..3] to merge multi-fragment messages
        process(gadgets.json.parse(
            decodeURIComponent(fragment[fragment.length - 1])));
      }
    },

    /**
     * Receives and processes an RPC request sent via the same domain.
     * (Not to be used directly). Converts the inbound rpc object's
     * Array into a local Array to pass the process() Array test.
     * @param {Object} rpc RPC object containing all request params
     */
    receiveSameDomain: function(rpc) {
      // Pass through to local process method but converting to a local Array
      rpc.a = Array.prototype.slice.call(rpc.a);
      window.setTimeout(function() { process(rpc) }, 0);
    }
  };
}();

;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/util.js' */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Utility functions for the Open Gadget Container
 */

Function.prototype.inherits = function(parentCtor) {
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  this.superClass_ = parentCtor.prototype;
  this.prototype = new tempCtor();
  this.prototype.constructor = this;
};;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/json.js' */
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * @fileoverview
 * The global object gadgets.json contains two methods.
 *
 * gadgets.json.stringify(value) takes a JavaScript value and produces a JSON
 * text. The value must not be cyclical.
 *
 * gadgets.json.parse(text) takes a JSON text and produces a JavaScript value.
 * It will return false if there is an error.
*/

var gadgets = gadgets || {};

/**
 * @static
 * @class Provides operations for translating objects to and from JSON.
 * @name gadgets.json
 */

/**
 * Port of the public domain JSON library by Douglas Crockford.
 * See: http://www.json.org/json2.js
 */
gadgets.json = function () {

  /**
   * Formats integers to 2 digits.
   * @param {Number} n
   */
  function f(n) {
    return n < 10 ? '0' + n : n;
  }

  Date.prototype.toJSON = function () {
    return [this.getUTCFullYear(), '-',
           f(this.getUTCMonth() + 1), '-',
           f(this.getUTCDate()), 'T',
           f(this.getUTCHours()), ':',
           f(this.getUTCMinutes()), ':',
           f(this.getUTCSeconds()), 'Z'].join("");
  };

  // table of character substitutions
  var m = {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '"' : '\\"',
    '\\': '\\\\'
  };

  /**
   * Converts a json object into a string.
   */
  function stringify(value) {
    var a,          // The array holding the partial texts.
        i,          // The loop counter.
        k,          // The member key.
        l,          // Length.
        r = /["\\\x00-\x1f\x7f-\x9f]/g,
        v;          // The member value.

    switch (typeof value) {
    case 'string':
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe ones.
      return r.test(value) ?
          '"' + value.replace(r, function (a) {
            var c = m[a];
            if (c) {
              return c;
            }
            c = a.charCodeAt();
            return '\\u00' + Math.floor(c / 16).toString(16) +
                (c % 16).toString(16);
            }) + '"'
          : '"' + value + '"';
    case 'number':
    // JSON numbers must be finite. Encode non-finite numbers as null.
      return isFinite(value) ? String(value) : 'null';
    case 'boolean':
    case 'null':
      return String(value);
    case 'object':
    // Due to a specification blunder in ECMAScript,
    // typeof null is 'object', so watch out for that case.
      if (!value) {
        return 'null';
      }
      // toJSON check removed; re-implement when it doesn't break other libs.
      a = [];
      if (typeof value.length === 'number' &&
          !(value.propertyIsEnumerable('length'))) {
        // The object is an array. Stringify every element. Use null as a
        // placeholder for non-JSON values.
        l = value.length;
        for (i = 0; i < l; i += 1) {
          a.push(stringify(value[i]) || 'null');
        }
        // Join all of the elements together and wrap them in brackets.
        return '[' + a.join(',') + ']';
      }
      // Otherwise, iterate through all of the keys in the object.
      for (k in value) if (value.hasOwnProperty(k)) {
        if (typeof k === 'string') {
          v = stringify(value[k]);
          if (v) {
            a.push(stringify(k) + ':' + v);
          }
        }
      }
      // Join all of the member texts together and wrap them in braces.
      return '{' + a.join(',') + '}';
    }
  }

  return {
    stringify: stringify,
    parse: function (text) {
// Parsing happens in three stages. In the first stage, we run the text against
// regular expressions that look for non-JSON patterns. We are especially
// concerned with '()' and 'new' because they can cause invocation, and '='
// because it can cause mutation. But just to be safe, we want to reject all
// unexpected forms.

// We split the first stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace all backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

      if (/^[\],:{}\s]*$/.test(text.replace(/\\["\\\/b-u]/g, '@').
          replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
          replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
        return eval('(' + text + ')');
      }
      // If the text is not JSON parseable, then return false.

      return false;
    }
  };
}();

;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-core-resources', location = 'js/gadgets-core.js' */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

var gadgets = gadgets || {};

gadgets.error = {};
gadgets.error.SUBCLASS_RESPONSIBILITY = 'subclass responsibility';
gadgets.error.TO_BE_DONE = 'to be done';

gadgets.log = function(message) {
  if (window.console && console.log) {
    console.log(message);
  } else {
    var logEntry = document.createElement('div');
    logEntry.className = 'gadgets-log-entry';
    logEntry.innerHTML = message;
    document.body.appendChild(logEntry);
  }
};


//----------
//Extensible

gadgets.Extensible = function() {
};

/**
* Sets the dependencies.
* @param {Object} dependencies Object whose properties are set on this
*     container as dependencies
*/
gadgets.Extensible.prototype.setDependencies = function(dependencies) {
    for (var p in dependencies) {
        this[p] = dependencies[p];
    }
};

/**
* Returns a dependency given its name.
* @param {String} name Name of dependency
* @return {Object} Dependency with that name or undefined if not found
*/
gadgets.Extensible.prototype.getDependencies = function(name) {
    return this[name];
};


//-------------
//UserPrefStore

/**
* User preference store interface.
* @constructor
*/
gadgets.UserPrefStore = function() {
};

/**
* Gets all user preferences of a gadget.
* @param {Object} gadget Gadget object
* @return {Object} All user preference of given gadget
*/
gadgets.UserPrefStore.prototype.getPrefs = function(gadget) {
throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

/**
* Saves user preferences of a gadget in the store.
* @param {Object} gadget Gadget object
* @param {Object} prefs User preferences
*/
gadgets.UserPrefStore.prototype.savePrefs = function(gadget) {
throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};


//-------------
//DefaultUserPrefStore

/**
* User preference store implementation.
* TODO: Turn this into a real implementation that is production safe
* @constructor
*/
gadgets.DefaultUserPrefStore = function() {
gadgets.UserPrefStore.call(this);
};
gadgets.DefaultUserPrefStore.inherits(gadgets.UserPrefStore);

gadgets.DefaultUserPrefStore.prototype.getPrefs = function(gadget) { };

gadgets.DefaultUserPrefStore.prototype.savePrefs = function(gadget) { };


//-------------
//GadgetService

/**
* Interface of service provided to gadgets for resizing gadgets,
* setting title, etc.
* @constructor
*/
gadgets.GadgetService = function() {
};

gadgets.GadgetService.prototype.setHeight = function(elementId, height) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

gadgets.GadgetService.prototype.setTitle = function(gadget, title) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

gadgets.GadgetService.prototype.setUserPref = function(id) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

//----------------
//IfrGadgetService

/**
* Base implementation of GadgetService.  This implementation does not implement setting the title or user prefs as it
* is meant for gadgets that are standalone on a page.  
* @constructor
*/
gadgets.IfrGadgetService = function() {
    gadgets.GadgetService.call(this);
    
    /**
     * This is a bit funky looking but we need to be sure we always call the right method, even if the implementation
     * has been overridden after an IfrGadgetService is instantiated.
     */
    var service = this;
    gadgets.rpc.register('resize_iframe', function() { service.setHeight.apply(this, arguments); });
    gadgets.rpc.register('set_pref', function() { service.setUserPref.apply(this, arguments); });
    gadgets.rpc.register('set_title', function() { service.setTitle.apply(this, arguments); });
    gadgets.rpc.register('requestNavigateTo', function() { service.requestNavigateTo.apply(this, arguments); });
};

gadgets.IfrGadgetService.inherits(gadgets.GadgetService);

gadgets.IfrGadgetService.prototype.setHeight = function(height) {
    if (height > gadgets.container.maxheight_) {
        height = gadgets.container.maxheight_;
    }

    var element = document.getElementById(this.f);
    if (element) {
        element.style.height = height + 'px';
    }
};
    
/**
* Navigates the page to a new url based on a gadgets requested view and
* parameters.
*/
gadgets.IfrGadgetService.prototype.requestNavigateTo = function(view, opt_params) {
    var id = this.getGadgetIdFromModuleId(this.f);
    var url = this.getUrlForView(view);

    if (opt_params) {
        var paramStr = JSON.stringify(opt_params);
        if (paramStr.length > 0) {
            url += '&appParams=' + encodeURIComponent(paramStr);
        }
    }

    if (url && document.location.href.indexOf(url) == -1) {
        document.location.href = url;
    }
};

/**
* This is a silly implementation that will need to be overriden by almost all
* real containers.
* TODO: Find a better default for this function
*
* @param view The view name to get the url for
*/
gadgets.IfrGadgetService.prototype.getUrlForView = function(view) {
    if (view === 'canvas') {
        return '/canvas';
    } else if (view === 'profile') {
        return '/profile';
    } else {
        return null;
    }
};

gadgets.IfrGadgetService.prototype.getGadgetIdFromModuleId = function(moduleId) {
    // Quick hack to extract the gadget id from module id
    return parseInt(moduleId.match(/_([0-9]+)$/)[1], 10);
};

//-------------
//LayoutManager

/**
* Layout manager interface.
* @constructor
*/
gadgets.LayoutManager = function() {
};

/**
* Gets the HTML element that is the chrome of a gadget into which the content
* of the gadget can be rendered.
* @param {Object} gadget Gadget instance
* @return {Object} HTML element that is the chrome for the given gadget
*/
gadgets.LayoutManager.prototype.getGadgetChrome = function(gadget) {
    throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY);
};

//-------------------
//StaticLayoutManager

/**
* Static layout manager where gadget ids have a 1:1 mapping to chrome ids.
* @constructor
*/
gadgets.StaticLayoutManager = function() {
    gadgets.LayoutManager.call(this);
};

gadgets.StaticLayoutManager.inherits(gadgets.LayoutManager);

/**
* Sets chrome ids, whose indexes are gadget instance ids (starting from 0).
* @param {Array} gadgetIdToChromeIdMap Gadget id to chrome id map
*/
gadgets.StaticLayoutManager.prototype.setGadgetChromeIds = function(gadgetChromeIds) {
    this.gadgetChromeIds_ = gadgetChromeIds;
};

gadgets.StaticLayoutManager.prototype.getGadgetChrome = function(gadget) {
    var chromeId = this.gadgetChromeIds_[gadget.id];
    return chromeId ? document.getElementById(chromeId) : null;
};


//----------------------
//FloatLeftLayoutManager

/**
* FloatLeft layout manager where gadget ids have a 1:1 mapping to chrome ids.
* @constructor
* @param {String} layoutRootId Id of the element that is the parent of all
*     gadgets.
*/
gadgets.FloatLeftLayoutManager = function(layoutRootId) {
    gadgets.LayoutManager.call(this);
    this.layoutRootId_ = layoutRootId;
};

gadgets.FloatLeftLayoutManager.inherits(gadgets.LayoutManager);

gadgets.FloatLeftLayoutManager.prototype.getGadgetChrome = function(gadget) {
    var layoutRoot = document.getElementById(this.layoutRootId_);
    if (layoutRoot) {
        var chrome = document.createElement('div');
        chrome.className = 'gadgets-gadget-chrome';
        chrome.style.cssFloat = 'left';
        layoutRoot.appendChild(chrome);
        return chrome;
    } else {
        return null;
    }
};

;
;
/* module-key = 'com.atlassian.gadgets.embedded:gadget-container-resources', location = 'js/gadgets-container.js' */
// ---------
// Container

/**
 * Container interface.
 * @constructor
 */
gadgets.Container = function() {
  this.parentUrl_ = 'http://' + document.location.host;
  this.country_ = 'ALL';
  this.language_ = 'ALL';
  this.view_ = 'default';
  this.nocache_ = 1;

  // signed max int
  this.maxheight_ = 0x7FFFFFFF;
};

gadgets.Container.inherits(gadgets.Extensible);

/**
 * Known dependencies:
 *     userPrefStore: instance of a subclass of gadgets.UserPrefStore
 *     gadgetService: instance of a subclass of gadgets.GadgetService
 *     layoutManager: instance of a subclass of gadgets.LayoutManager
 */

gadgets.Container.prototype.userPrefStore = new gadgets.DefaultUserPrefStore();

gadgets.Container.prototype.gadgetService = new gadgets.GadgetService();

gadgets.Container.prototype.layoutManager =
    new gadgets.StaticLayoutManager();

gadgets.Container.prototype.setParentUrl = function(url) {
  this.parentUrl_ = url;
};

gadgets.Container.prototype.setCountry = function(country) {
  this.country_ = country;
};

gadgets.Container.prototype.setNoCache = function(nocache) {
  this.nocache_ = nocache;
};

gadgets.Container.prototype.setLanguage = function(language) {
  this.language_ = language;
};

gadgets.Container.prototype.setView = function(view) {
  this.view_ = view;
};

gadgets.Container.prototype.setMaxHeight = function(maxheight) {
  this.maxheight_ = maxheight;
};

gadgets.Container.prototype.getGadgetKey_ = function(instanceId) {
  return 'gadget_' + instanceId;
};


// ------------
// IfrContainer

/**
 * Container that renders gadget using ifr.
 * @constructor
 */
gadgets.IfrContainer = function() {
  gadgets.Container.call(this);
};

gadgets.IfrContainer.inherits(gadgets.Container);

gadgets.IfrContainer.prototype.gadgetService = new gadgets.IfrGadgetService();

gadgets.IfrContainer.prototype.setParentUrl = function(url) {
  if (!url.match(/^http[s]?:\/\//)) {
    url = document.location.href.match(/^[^?#]+\//)[0] + url;
  }

  this.parentUrl_ = url;
};

/**
 * Default container.
 */
gadgets.container = new gadgets.IfrContainer();
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:gadget-dashboard-resources', location = 'js/cookies.js' */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Functions for setting, getting and deleting cookies
 */

/**
 * Namespace for cookie functions
 */
// goog.provide('goog.net.cookies');
// TODO: find the official solution for a cookies library
var goog = goog || {};
goog.net = goog.net || {};
goog.net.cookies = goog.net.cookies || {};


goog.JsType_ = {
  UNDEFINED: 'undefined'
};

goog.isDef = function(val) {
  return typeof val != goog.JsType_.UNDEFINED;
};


/**
 * Sets a cookie.
 * The max_age can be -1 to set a session cookie. To remove and expire cookies,
 * use remove() instead.
 *
 * @param {string} name The cookie name.
 * @param {string} value The cookie value.
 * @param {number} opt_maxAge The max age in seconds (from now). Use -1 to set
 *                            a session cookie. If not provided, the default is
 *                            -1 (i.e. set a session cookie).
 * @param {string} opt_path The path of the cookie, or null to not specify a
 *                          path attribute (browser will use the full request
 *                          path). If not provided, the default is '/' (i.e.
 *                          path=/).
 * @param {string} opt_domain The domain of the cookie, or null to not specify
 *                            a domain attribute (browser will use the full
 *                            request host name). If not provided, the default
 *                            is null (i.e. let browser use full request host
 *                            name).
 */
goog.net.cookies.set = function(name, value, opt_maxAge, opt_path, opt_domain) {
  // we do not allow '=' or ';' in the name
  if (/;=/g.test(name)) {
    throw new Error('Invalid cookie name "' + name + '"');
  }
  // we do not allow ';' in value
  if (/;/g.test(value)) {
    throw new Error('Invalid cookie value "' + value + '"');
  }

  if (!goog.isDef(opt_maxAge)) {
    opt_maxAge = -1;
  }

  var domainStr = opt_domain ? ';domain=' + opt_domain : '';
  var pathStr = opt_path ? ';path=' + opt_path : '';

  var expiresStr;

  // Case 1: Set a session cookie.
  if (opt_maxAge < 0) {
    expiresStr = '';

  // Case 2: Expire the cookie.
  // Note: We don't tell people about this option in the function doc because
  // we prefer people to use ExpireCookie() to expire cookies.
  } else if (opt_maxAge == 0) {
    // Note: Don't use Jan 1, 1970 for date because NS 4.76 will try to convert
    // it to local time, and if the local time is before Jan 1, 1970, then the
    // browser will ignore the Expires attribute altogether.
    var pastDate = new Date(1970, 1 /*Feb*/, 1);  // Feb 1, 1970
    expiresStr = ';expires=' + pastDate.toUTCString();

  // Case 3: Set a persistent cookie.
  } else {
    var futureDate = new Date((new Date).getTime() + opt_maxAge * 1000);
    expiresStr = ';expires=' + futureDate.toUTCString();
  }

  document.cookie = name + '=' + value + domainStr + pathStr + expiresStr;
};


/**
 * Returns the value for the first cookie with the given name
 * @param {string} name The name of the cookie to get
 * @param {string} opt_default If not found this is returned instead.
 * @return {string|undefined} The value of the cookie. If no cookie is set this
 *                            returns opt_default or undefined if opt_default is
 *                            not provided.
 */
goog.net.cookies.get = function(name, opt_default) {
  var nameEq = name + "=";
  var cookie = String(document.cookie);
  for (var pos = -1; (pos = cookie.indexOf(nameEq, pos + 1)) >= 0;) {
    var i = pos;
    // walk back along string skipping whitespace and looking for a ; before
    // the name to make sure that we don't match cookies whose name contains
    // the given name as a suffix.
    while (--i >= 0) {
      var ch = cookie.charAt(i);
      if (ch == ';') {
        i = -1;  // indicate success
        break;
      }
    }
    if (i == -1) {  // first cookie in the string or we found a ;
      var end = cookie.indexOf(';', pos);
      if (end < 0) {
        end = cookie.length;
      }
      return cookie.substring(pos + nameEq.length, end);
    }
  }
  return opt_default;
};


/**
 * Removes and expires a cookie.
 *
 * @param {string} name The cookie name.
 * @param {string} opt_path The path of the cookie, or null to expire a cookie
 *                          set at the full request path. If not provided, the
 *                          default is '/' (i.e. path=/).
 * @param {string} opt_domain The domain of the cookie, or null to expire a
 *                            cookie set at the full request host name. If not
 *                            provided, the default is null (i.e. cookie at
 *                            full request host name).
 */
goog.net.cookies.remove = function(name, opt_path, opt_domain) {
  var rv = goog.net.cookies.containsKey(name);
  goog.net.cookies.set(name, '', 0, opt_path, opt_domain);
  return rv;
};


/**
 * Gets the names and values for all the cookies
 * @private
 * @return {Object} An object with keys and values
 */
goog.net.cookies.getKeyValues_ = function() {
  var cookie = String(document.cookie);
  var parts = cookie.split(/\s*;\s*/);
  var keys = [], values = [], index, part;
  for (var i = 0; part = parts[i]; i++) {
    index = part.indexOf('=');

    if (index == -1) { // empty name
      keys.push('');
      values.push(part);
    } else {
      keys.push(part.substring(0, index));
      values.push(part.substring(index + 1));
    }
  }
  return {keys: keys, values: values};
};


/**
 * Gets the names for all the cookies
 * @return {Array} An array with the names of the cookies
 */
goog.net.cookies.getKeys = function() {
  return goog.net.cookies.getKeyValues_().keys;
};


/**
 * Gets the values for all the cookies
 * @return {Array} An array with the values of the cookies
 */
goog.net.cookies.getValues = function() {
  return goog.net.cookies.getKeyValues_().values;
};


/**
 * Whether there are any cookies for this document
 * @return {boolean}
 */
goog.net.cookies.isEmpty = function() {
  return document.cookie == '';
};


/**
 * Returns the number of cookies for this document
 * @return {number}
 */
goog.net.cookies.getCount = function() {
  var cookie = String(document.cookie);
  if (cookie == '') {
    return 0;
  }
  var parts = cookie.split(/\s*;\s*/);
  return parts.length;
};


/**
 * Returns whether there is a cookie with the given name
 * @param {string} key The name of the cookie to test for
 * @return {boolean}
 */
goog.net.cookies.containsKey = function(key) {
  var sentinel = {};
  // if get does not find the key it returns the default value. We therefore
  // compare the result with an object to ensure we do not get any false
  // positives.
  return goog.net.cookies.get(key, sentinel) !== sentinel;
};


/**
 * Returns whether there is a cookie with the given value. (This is an O(n)
 * operation.)
 * @param {string} value The value to check for
 * @return {boolean}
 */
goog.net.cookies.containsValue = function(value) {
  // this O(n) in any case so lets do the trivial thing.
  var values = goog.net.cookies.getKeyValues_().values;
  for (var i = 0; i < values.length; i++) {
    if (values[i] == value) {
      return true;
    }
  }
  return false;
};


/**
 * Removes all cookies for this document
 */
goog.net.cookies.clear = function() {
  var keys = goog.net.cookies.getKeyValues_().keys;
  for (var i = keys.length - 1; i >= 0; i--) {
    goog.net.cookies.remove(keys[i]);
  }
};

/**
 * Static constant for the size of cookies. Per the spec, there's a 4K limit
 * to the size of a cookie. To make sure users can't break this limit, we
 * should truncate long cookies at 3950 bytes, to be extra careful with dumb
 * browsers/proxies that interpret 4K as 4000 rather than 4096
 * @type number
 */
goog.net.cookies.MAX_COOKIE_LENGTH = 3950;
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:gadget-dashboard-resources', location = 'js/gadgets-dashboard.js' */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

/**
 * Calls an array of asynchronous functions and calls the continuation
 * function when all are done.
 * @param {Array} functions Array of asynchronous functions, each taking
 *     one argument that is the continuation function that handles the result
 *     That is, each function is something like the following:
 *     function(continuation) {
 *       // compute result asynchronously
 *       continuation(result);
 *     }
 * @param {Function} continuation Function to call when all results are in.  It
 *     is pass an array of all results of all functions
 * @param {Object} opt_this Optional object used as "this" when calling each
 *     function
 */
gadgets.callAsyncAndJoin = function(functions, continuation, opt_this) {
  var pending = functions.length;
  var results = [];
  for (var i = 0; i < functions.length; i++) {
    // we need a wrapper here because i changes and we need one index
    // variable per closure
    var wrapper = function(index) {
      functions[index].call(opt_this, function(result) {
        results[index] = result;
        if (--pending == 0) {
          continuation(results);
        }
      });
    };
    wrapper(i);
  }
};

// ----------------
// IfrGadgetService

/**
 * Implementation of setTitle for IfrGadgetService.
 */
gadgets.IfrGadgetService.prototype.setTitle = function(title) {
    jQuery('#' + this.f + '-chrome .dashboard-item-title').text(title);
};

/**
 * Implementation of setHeight for IfrGadgetService.
 */
gadgets.IfrGadgetService.prototype.setHeight = function(height) {
    if (height > gadgets.container.maxheight_) {
        height = gadgets.container.maxheight_;
    }

    var element = document.getElementById(this.f);
    if (element) {
        element.style.height = height + 'px';
    }

    AG.Cookie.save(this.f + "-fh", height);

    // As gadgets are absolutely positioned we need to resize the dashboard chrome whenever a gadgets height is changed.
    // We do this by firing an event, see AG.DashboardManager for handling.
    jQuery(AG).trigger("AG.iframeResize", [element, height]);
};

/**
* Sets one or more user preferences
* @param {String} editToken
* @param {String} name Name of user preference
* @param {String} value Value of user preference
* More names and values may follow
*/
gadgets.IfrGadgetService.prototype.setUserPref = function(editToken, name, value) {
    var nameValues = Array.prototype.slice.call(arguments, 1);
    AJS.$("#" + this.f).trigger("setUserPref", nameValues);
};
;
;
/* module-key = 'com.atlassian.gadgets.dashboard:gadget-dashboard-resources', location = 'js/cookiebaseduserprefstore.js' */
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Implements the gadgets.UserPrefStore interface using a cookies
 * based implementation. Depends on cookies.js. This code should not be used in
 * a production environment.
 */

/**
 * Cookie-based user preference store.
 * @constructor
 */
gadgets.CookieBasedUserPrefStore = function() {
  gadgets.UserPrefStore.call(this);
};

gadgets.CookieBasedUserPrefStore.inherits(gadgets.UserPrefStore);

gadgets.CookieBasedUserPrefStore.prototype.USER_PREFS_PREFIX =
    'gadgetUserPrefs-';

gadgets.CookieBasedUserPrefStore.prototype.getPrefs = function(gadget) {
  var userPrefs = {};
  var cookieName = this.USER_PREFS_PREFIX + gadget.id;
  var cookie = goog.net.cookies.get(cookieName);
  if (cookie) {
    var pairs = cookie.split('&');
    for (var i = 0; i < pairs.length; i++) {
      var nameValue = pairs[i].split('=');
      var name = decodeURIComponent(nameValue[0]);
      var value = decodeURIComponent(nameValue[1]);
      userPrefs[name] = value;
    }
  }

  return userPrefs;
};

gadgets.CookieBasedUserPrefStore.prototype.savePrefs = function(gadget) {
  var pairs = [];
  for (var name in gadget.getUserPrefs()) {
    var value = gadget.getUserPref(name);
    var pair = encodeURIComponent(name) + '=' + encodeURIComponent(value);
    pairs.push(pair);
  }

  var cookieName = this.USER_PREFS_PREFIX + gadget.id;
  var cookieValue = pairs.join('&');
  goog.net.cookies.set(cookieName, cookieValue);
};

gadgets.Container.prototype.userPrefStore =
    new gadgets.CookieBasedUserPrefStore();;
;
/* module-key = 'jira.webresources:field-templates', location = '/includes/jira/field/templates/singleUserPicker.soy' */
// This file was automatically generated from singleUserPicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Fields.Pickers.User.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Fields == 'undefined') { JIRA.Templates.Fields = {}; }
if (typeof JIRA.Templates.Fields.Pickers == 'undefined') { JIRA.Templates.Fields.Pickers = {}; }
if (typeof JIRA.Templates.Fields.Pickers.User == 'undefined') { JIRA.Templates.Fields.Pickers.User = {}; }


JIRA.Templates.Fields.Pickers.User.single = function(opt_data, opt_ignored) {
  var output = '<select id="' + soy.$$escapeHtml(opt_data.field.id) + '" name="' + soy.$$escapeHtml(opt_data.field.name) + '" class="single-user-picker js-' + ((opt_data.type) ? soy.$$escapeHtml(opt_data.type) : 'default-user-picker') + '"' + ((opt_data.inputText) ? ' data-input-text="' + soy.$$escapeHtml(opt_data.inputText) + '"' : '') + ((opt_data.editValue) ? ' data-edit-value="' + soy.$$escapeHtml(opt_data.editValue) + '"' : '') + ((opt_data.showDropdownButton) ? ' data-show-dropdown-button="true"' : '') + ((opt_data.userType) ? ' data-user-type="' + soy.$$escapeHtml(opt_data.userType) + '"' : '') + ((opt_data.containerClass) ? ' data-container-class="' + soy.$$escapeHtml(opt_data.containerClass) + '"' : '') + '>';
  var optionList38 = opt_data.options;
  var optionListLen38 = optionList38.length;
  for (var optionIndex38 = 0; optionIndex38 < optionListLen38; optionIndex38++) {
    var optionData38 = optionList38[optionIndex38];
    if (optionData38.optionGroup) {
      output += '<optgroup id="' + soy.$$escapeHtml(opt_data.field.id) + '-group-' + soy.$$escapeHtml(optionData38.id) + '" label="' + soy.$$escapeHtml(optionData38.display) + '"' + ((optionData38.footer) ? ' data-footer-text="' + soy.$$escapeHtml(optionData38.footer) + '"' : '') + ((optionData38.weight != -1) ? ' data-weight="' + soy.$$escapeHtml(optionData38.weight) + '"' : '') + '>';
      var groupOptionList59 = optionData38.groupOptions;
      var groupOptionListLen59 = groupOptionList59.length;
      for (var groupOptionIndex59 = 0; groupOptionIndex59 < groupOptionListLen59; groupOptionIndex59++) {
        var groupOptionData59 = groupOptionList59[groupOptionIndex59];
        output += JIRA.Templates.Fields.Pickers.User.option(groupOptionData59);
      }
      output += '</optgroup>';
    } else {
      output += JIRA.Templates.Fields.Pickers.User.option(optionData38);
    }
  }
  output += '</select>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.Pickers.User.single.soyTemplateName = 'JIRA.Templates.Fields.Pickers.User.single';
}


JIRA.Templates.Fields.Pickers.User.option = function(opt_data, opt_ignored) {
  return '<option ' + ((opt_data.loggedInUser) ? 'class="current-user" ' : '') + ((opt_data.selected) ? 'selected="selected" ' : '') + 'value="' + soy.$$escapeHtml(opt_data.optionName) + '" data-field-text="' + soy.$$escapeHtml(opt_data.displayName) + '" data-field-label="' + soy.$$escapeHtml(opt_data.displayName) + ((opt_data.emailAddress) ? ' - ' + soy.$$escapeHtml(opt_data.emailAddress) : '') + ((opt_data.optionName && opt_data.optionName != '-1') ? ' (' + soy.$$escapeHtml(opt_data.optionName) + ')' : '') + '" data-icon="' + soy.$$escapeHtml(opt_data.avatarURL) + '" >' + soy.$$escapeHtml(opt_data.displayName) + '</option>';
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.Pickers.User.option.soyTemplateName = 'JIRA.Templates.Fields.Pickers.User.option';
}
;
;
/* module-key = 'jira.webresources:field-templates', location = '/includes/jira/field/templates/assigneeField.soy' */
// This file was automatically generated from assigneeField.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Fields.Pickers.User.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Fields == 'undefined') { JIRA.Templates.Fields = {}; }
if (typeof JIRA.Templates.Fields.Pickers == 'undefined') { JIRA.Templates.Fields.Pickers = {}; }
if (typeof JIRA.Templates.Fields.Pickers.User == 'undefined') { JIRA.Templates.Fields.Pickers.User = {}; }


JIRA.Templates.Fields.Pickers.User.assignee = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.Fields.Pickers.User.single(soy.$$augmentMap(opt_data, {options: opt_data.assigneeOptions.options, showDropdownButton: true, userType: 'assignee', type: 'assignee-picker', containerClass: 'long-field'})) + ((opt_data.isLoggedInUserAssignable) ? '<a href="#' + soy.$$escapeHtml(opt_data.field.id) + '" id="assign-to-me-trigger">' + soy.$$escapeHtml("Assign to me") + '</a>' : '') + '<fieldset class="hidden parameters"><input type="hidden" title="projectKeys" value="' + soy.$$escapeHtml(opt_data.projectKeys) + '"/>' + ((opt_data.issueKey) ? '<input type="hidden" title="assigneeEditIssueKey" value="' + soy.$$escapeHtml(opt_data.issueKey) + '"/>' : '') + ((opt_data.actionDescriptorId) ? '<input type="hidden" title="actionDescriptorId" value="' + soy.$$escapeHtml(opt_data.actionDescriptorId) + '"/>' : '') + '</fieldset>';
};
if (goog.DEBUG) {
  JIRA.Templates.Fields.Pickers.User.assignee.soyTemplateName = 'JIRA.Templates.Fields.Pickers.User.assignee';
}
;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/userPickerUtil.js' */
(function ($) {

    JIRA.UserPickerUtil = {

        formatResponse: function (data) {

            var ret = [];

            $(data).each(function(i, suggestions) {

                var groupDescriptor = new AJS.GroupDescriptor({
                    weight: i, // order or groups in suggestions dropdown
                    label: suggestions.footer
                });

                $(suggestions.users).each(function(){
                    groupDescriptor.addItem(new AJS.ItemDescriptor({
                        value: this.name, // value of item added to select
                        label: this.displayName, // title of lozenge
                        html: this.html,
                        icon: this.avatarUrl,
                        allowDuplicate: false,
                        highlighted: true
                    }));
                });
                ret.push(groupDescriptor);
            });
            return ret;
        }

    };

})(AJS.$);

;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/initSingleUserPickers.js' */
(function ($) {

    function createSingleUserPickers(ctx) {

        var restPath = "/rest/api/1.0/users/picker";

        $(".js-default-user-picker", ctx).each(function () {
            var $this = $(this);
            if ($this.data("aui-ss")) return;
            var data = {showAvatar: true},
                inputText = $this.data('inputValue');

            new AJS.SingleSelect({
                element: $this,
                submitInputVal: true,
                showDropdownButton: !!$this.data('show-dropdown-button'),
                errorMessage: AJS.format("There is no user \'\'{0}\'\'.", "'{0}'"),
                ajaxOptions: {
                    url: contextPath + restPath,
                    query: true, // keep going back to the sever for each keystroke
                    data: data,
                    formatResponse: JIRA.UserPickerUtil.formatResponse
                },
                inputText: inputText
            });
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            createSingleUserPickers(context);
        }
    });

})(AJS.$);



;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/NoBrowseUserNamePicker.js' */
    /**
     * Caters for addition of users in frotherized MultiSelect inputs when the user
     * does not have the Browse User permission.
     *
     * Whilst this control could potentially give away valid usernames it is not new in this behaviour.
     * The old-style user picker used in the Edit Issue form will reveal if a particular username is invalid or not.
     * @class
     * @extends MultiSelect
     */
    AJS.NoBrowseUserNamePicker = AJS.MultiSelect.extend({

        /**
         * Use the User REST interface to attempt to get a user by username.
         */
        _getDefaultOptions: function () {
            return AJS.$.extend(true, this._super(), {
                errorMessage: "The requested user does not exist.",
                showDropdownButton: false,
                removeOnUnSelect: true,
                itemAttrDisplayed: "label"
            });
        },

        /**
         * Override to prevent requesting per keypress.
         *
         * NoBrowseUserNamePicker does not send a request per keypress.
         * Instead it will request for validity when enter or space is pressed
         * or when the field is blurred.
         */
        _handleCharacterInput: function() {
            //this.hideErrorMessage();
        },

        /**
         * Prevents the display of Suggestions for this control.
         *
         * We don't want any suggestions for the NoBrowseUserNamePicker
         * as the user using doesn't have access to see a list of users.
         * Also, using this REST enpoint will not retrieve a list of users anyway.
         */
        _setSuggestions: function() {},

        /**
         * Handles an error from the REST endpoint.
         *
         * The REST endpoint used for this operation returns a 404 if the user requested
         * does not exist. This situation is handled here.
         *
         * If any other error is returned the parent's error handler will be used.
         *
         * @param smartAjaxResult The error.
         */
        _handleServerError: function(smartAjaxResult) {
            if (smartAjaxResult.status === 404) {
                this.showErrorMessage();
            } else {
                this._super();
            }
        },

        /**
         * Called when the field is blurred.
         *
         * When the field is deactivated (i.e. blurred) we want to issue a
         * request to check if the currently entered username (if any) is valid or not.
         */
        _deactivate: function() {
            this.validateAndAdd();
        },

        /**
         * Issues a request to the User REST endpoint with the current field value.
         *
         * Hides any existing error messages before issuing a request to the User endpoint
         * to determine the validity of the current input.
         */
        validateAndAdd: function() {
            var instance = this;
            if (AJS.$.trim(this.$field.val()) === "") {
                this.hideErrorMessage();
            } else {
                jQuery.ajax({
                    url: contextPath + "/rest/api/2/user",
                    data: {
                        username: AJS.$.trim(instance.getQueryVal())
                    },
                    success: function (user) {
                        instance.hideErrorMessage();
                        instance.$field.val("");
                        instance.addItem(new AJS.ItemDescriptor({
                            label: user.displayName,
                            value: user.name
                        }));
                    },
                    error: function () {
                        instance.showErrorMessage();
                    }
                });
            }
        },

        /**
         * Sends a request to the REST endpoint using the currently entered username (if any)
         * when space is pressed.
         *
         * This allows for quick entry of usernames.
         *
         * If the username is not valid the space keypress event is prevented and an error message
         * displayed.
         */
        _handleSpace: function() {
            this.validate();
        },

        /**
         * Transforms the successfully returned username into a Lozenge.
         *
         * @param data The successfully selected username.
         */
        _handleServerSuggestions: function() {
            this.hideErrorMessage();
            this.handleFreeInput();
        },

        /**
         * Adds the current user input as a lozenge.
         *
         * By this time the input has been validated as a username.
         * If the input is not a valid username the response comes back as a
         * 404 triggering _handleServerError.
         */
        handleFreeInput: function() {
            var value = AJS.$.trim(this.$field.val());

            if (value !== "") {
                this.addItem({ value: value, label: value });
                this.model.$element.trigger("change");
            }

            this.$field.val("");
        },

        keys: {
            /**
             * Issue a request for the currently entered username when Return is pressed.
             *
             * @param event The aui:keypress event.
             */
            "Return": function(event) {
                event.preventDefault();
                this.validateAndAdd();
            },

            /**
             * Issue a request for the currently entered username when the Spacebar is pressed.
             *
             * @param event The aui:keypress event.
             */
            "Spacebar": function(event) {
                event.preventDefault();
                this.validateAndAdd();
            }
        }
    });
;
;
/* module-key = 'jira.webresources:user-pickers', location = '/includes/jira/field/initMultiUserPickers.js' */
(function () {

    function initMultiUserPicker(ctx) {
        ctx.find(".js-default-multi-user-picker").each(function () {
            var $el = jQuery(this);
            if (AJS.params.currentUserCanBrowseUsers) {
                new AJS.MultiSelect({
                    element: this,
                    itemAttrDisplayed: "label",
                    showDropdownButton: false,
                    removeOnUnSelect: true,
                    submitInputVal: true,
                    ajaxOptions: {
                        url: contextPath + "/rest/api/1.0/users/picker",
                        query: true, // keep going back to the sever for each keystroke
                        data: function (query) {
                            return {
                                showAvatar: true,
                                query: query,
                                exclude: $el.val()
                            };
                        },
                        formatResponse: JIRA.UserPickerUtil.formatResponse
                    }
                });
            } else {
                new AJS.NoBrowseUserNamePicker({
                    element: this
                });
            }
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initMultiUserPicker(context);
        }
    });

})();
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/lib/jquery.dotdotdot-1.5.7.js' */
/*	
 *	jQuery dotdotdot 1.5.7
 *	
 *	Copyright (c) 2013 Fred Heusschen
 *	www.frebsite.nl
 *
 *	Plugin website:
 *	dotdotdot.frebsite.nl
 *
 *	Dual licensed under the MIT and GPL licenses.
 *	http://en.wikipedia.org/wiki/MIT_License
 *	http://en.wikipedia.org/wiki/GNU_General_Public_License
 */

(function( $ )
{
	if ( $.fn.dotdotdot )
	{
		return;
	}

	$.fn.dotdotdot = function( o )
	{
		if ( this.length == 0 )
		{
			if ( !o || o.debug !== false )
			{
				debug( true, 'No element found for "' + this.selector + '".' );				
			}
			return this;
		}
		if ( this.length > 1 )
		{
			return this.each(
				function()
				{
					$(this).dotdotdot( o );
				}
			);
		}


		var $dot = this;

		if ( $dot.data( 'dotdotdot' ) )
		{
			$dot.trigger( 'destroy.dot' );
		}

		$dot.bind_events = function()
		{
			$dot.bind(
				'update.dot',
				function( e, c )
				{
					e.preventDefault();
					e.stopPropagation();

					opts.maxHeight = ( typeof opts.height == 'number' ) 
						? opts.height 
						: getTrueInnerHeight( $dot );

					opts.maxHeight += opts.tolerance;

					if ( typeof c != 'undefined' )
					{
						if ( typeof c == 'string' || c instanceof HTMLElement )
						{
					 		c = $('<div />').append( c ).contents();
						}
						if ( c instanceof $ )
						{
							orgContent = c;
						}
					}

					$inr = $dot.wrapInner( '<div class="dotdotdot" />' ).children();
					$inr.empty()
						.append( orgContent.clone( true ) )
						.css({
							'height'	: 'auto',
							'width'		: 'auto',
							'border'	: 'none',
							'padding'	: 0,
							'margin'	: 0
						});

					var after = false,
						trunc = false;

					if ( conf.afterElement )
					{
						after = conf.afterElement.clone( true );
						conf.afterElement.remove();
					}
					if ( test( $inr, opts ) )
					{
						if ( opts.wrap == 'children' )
						{
							trunc = children( $inr, opts, after );
						}
						else
						{
							trunc = ellipsis( $inr, $dot, $inr, opts, after );
						}
					}
					$inr.replaceWith( $inr.contents() );
					$inr = null;
					
					if ( $.isFunction( opts.callback ) )
					{
						opts.callback.call( $dot[ 0 ], trunc, orgContent );
					}

					conf.isTruncated = trunc;
					return trunc;
				}

			).bind(
				'isTruncated.dot',
				function( e, fn )
				{
					e.preventDefault();
					e.stopPropagation();

					if ( typeof fn == 'function' )
					{
						fn.call( $dot[ 0 ], conf.isTruncated );
					}
					return conf.isTruncated;
				}

			).bind(
				'originalContent.dot',
				function( e, fn )
				{
					e.preventDefault();
					e.stopPropagation();

					if ( typeof fn == 'function' )
					{
						fn.call( $dot[ 0 ], orgContent );
					}
					return orgContent;
				}

			).bind(
				'destroy.dot',
				function( e )
				{
					e.preventDefault();
					e.stopPropagation();

					$dot.unwatch()
						.unbind_events()
						.empty()
						.append( orgContent )
						.data( 'dotdotdot', false );
				}
			);
			return $dot;
		};	//	/bind_events

		$dot.unbind_events = function()
		{
			$dot.unbind('.dot');
			return $dot;
		};	//	/unbind_events

		$dot.watch = function()
		{
			$dot.unwatch();
			if ( opts.watch == 'window' )
			{
				var $window = $(window),
					_wWidth = $window.width(),
					_wHeight = $window.height(); 

				$window.bind(
					'resize.dot' + conf.dotId,
					function()
					{
						if ( _wWidth != $window.width() || _wHeight != $window.height() || !opts.windowResizeFix )
						{
							_wWidth = $window.width();
							_wHeight = $window.height();
	
							if ( watchInt )
							{
								clearInterval( watchInt );
							}
							watchInt = setTimeout(
								function()
								{
									$dot.trigger( 'update.dot' );
								}, 10
							);
						}
					}
				);
			}
			else
			{
				watchOrg = getSizes( $dot );
				watchInt = setInterval(
					function()
					{
						var watchNew = getSizes( $dot );
						if ( watchOrg.width  != watchNew.width ||
							 watchOrg.height != watchNew.height )
						{
							$dot.trigger( 'update.dot' );
							watchOrg = getSizes( $dot );
						}
					}, 100
				);
			}
			return $dot;
		};
		$dot.unwatch = function()
		{
			$(window).unbind( 'resize.dot' + conf.dotId );
			if ( watchInt )
			{
				clearInterval( watchInt );
			}
			return $dot;
		};

		var	orgContent	= $dot.contents(),
			opts 		= $.extend( true, {}, $.fn.dotdotdot.defaults, o ),
			conf		= {},
			watchOrg	= {},
			watchInt	= null,
			$inr		= null;

		conf.afterElement	= getElement( opts.after, $dot );
		conf.isTruncated	= false;
		conf.dotId			= dotId++;


		$dot.data( 'dotdotdot', true )
			.bind_events()
			.trigger( 'update.dot' );

		if ( opts.watch )
		{
			$dot.watch();
		}

		return $dot;
	};


	//	public
	$.fn.dotdotdot.defaults = {
		'ellipsis'	: '... ',
		'wrap'		: 'word',
		'lastCharacter': {
			'remove'		: [ ' ', ',', ';', '.', '!', '?' ],
			'noEllipsis'	: []
		},
		'tolerance'	: 0,
		'callback'	: null,
		'after'		: null,
		'height'	: null,
		'watch'		: false,
		'windowResizeFix': true,
		'debug'		: false
	};
	

	//	private
	var dotId = 1;

	function children( $elem, o, after )
	{
		var $elements 	= $elem.children(),
			isTruncated	= false;

		$elem.empty();

		for ( var a = 0, l = $elements.length; a < l; a++ )
		{
			var $e = $elements.eq( a );
			$elem.append( $e );
			if ( after )
			{
				$elem.append( after );
			}
			if ( test( $elem, o ) )
			{
				$e.remove();
				isTruncated = true;
				break;
			}
			else
			{
				if ( after )
				{
					after.remove();
				}
			}
		}
		return isTruncated;
	}
	function ellipsis( $elem, $d, $i, o, after )
	{
		var $elements 	= $elem.contents(),
			isTruncated	= false;

		$elem.empty();

		var notx = 'table, thead, tbody, tfoot, tr, col, colgroup, object, embed, param, ol, ul, dl, select, optgroup, option, textarea, script, style';
		for ( var a = 0, l = $elements.length; a < l; a++ )
		{

			if ( isTruncated )
			{
				break;
			}

			var e	= $elements[ a ],
				$e	= $(e);

			if ( typeof e == 'undefined' )
			{
				continue;
			}

			$elem.append( $e );
			if ( after )
			{
				$elem[ ( $elem.is( notx ) ) ? 'after' : 'append' ]( after );
			}
			if ( e.nodeType == 3 )
			{
				if ( test( $i, o ) )
				{
					isTruncated = ellipsisElement( $e, $d, $i, o, after );
				}
			}
			else
			{
				isTruncated = ellipsis( $e, $d, $i, o, after );
			}

			if ( !isTruncated )
			{
				if ( after )
				{
					after.remove();
				}
			}
		}
		return isTruncated;
	}
	function ellipsisElement( $e, $d, $i, o, after )
	{
		var isTruncated	= false,
			e = $e[ 0 ];

		if ( typeof e == 'undefined' )
		{
			return false;
		}

		var seporator	= ( o.wrap == 'letter' ) ? '' : ' ',
			textArr		= getTextContent( e ).split( seporator ),
			position 	= -1,
			midPos		= -1,
			startPos	= 0,
			endPos		= textArr.length - 1;

		while ( startPos <= endPos )
		{
			var m = Math.floor( ( startPos + endPos ) / 2 );
			if ( m == midPos ) 
			{
				break;
			}
			midPos = m;

			setTextContent( e, textArr.slice( 0, midPos + 1 ).join( seporator ) + o.ellipsis );

			if ( !test( $i, o ) )
			{
				position = midPos;
				startPos = midPos; 
			}
			else
			{
				endPos = midPos;
			}				
		}	
	
		if ( position != -1 && !( textArr.length == 1 && textArr[ 0 ].length == 0 ) )
		{
			var txt = addEllipsis( textArr.slice( 0, position + 1 ).join( seporator ), o );
			isTruncated = true;
			setTextContent( e, txt );
		}
		else
		{
			var $w = $e.parent();
			$e.remove();

			var afterLength = ( after ) ? after.length : 0 ;

			if ( $w.contents().size() > afterLength )
			{
				var $n = $w.contents().eq( -1 - afterLength );
				isTruncated = ellipsisElement( $n, $d, $i, o, after );
			}
			else
			{
				var e = $w.prev().contents().eq( -1 )[ 0 ];

				if ( typeof e != 'undefined' )
				{
					var txt = addEllipsis( getTextContent( e ), o );
					setTextContent( e, txt );
					$w.remove();
					isTruncated = true;
				}

			}
		}

		return isTruncated;
	}
	function test( $i, o )
	{
		return $i.innerHeight() > o.maxHeight;
	}
	function addEllipsis( txt, o )
	{
		while( $.inArray( txt.slice( -1 ), o.lastCharacter.remove ) > -1 )
		{
			txt = txt.slice( 0, -1 );
		}
		if ( $.inArray( txt.slice( -1 ), o.lastCharacter.noEllipsis ) < 0 )
		{
			txt += o.ellipsis;
		}
		return txt;
	}
	function getSizes( $d )
	{
		return {
			'width'	: $d.innerWidth(),
			'height': $d.innerHeight()
		};
	}
	function setTextContent( e, content )
	{
		if ( e.innerText )
		{
			e.innerText = content;
		}
		else if ( e.nodeValue )
		{
			e.nodeValue = content;
		}
		else if (e.textContent)
		{
			e.textContent = content;
		}

	}
	function getTextContent( e )
	{
		if ( e.innerText )
		{
			return e.innerText;
		}
		else if ( e.nodeValue )
		{
			return e.nodeValue;
		}
		else if ( e.textContent )
		{
			return e.textContent;
		}
		else
		{
			return "";
		}
	}
	function getElement( e, $i )
	{
		if ( typeof e == 'undefined' )
		{
			return false;
		}
		if ( !e )
		{
			return false;
		}
		if ( typeof e == 'string' )
		{
			e = $(e, $i);
			return ( e.length )
				? e 
				: false;
		}
		if ( typeof e == 'object' )
		{
			return ( typeof e.jquery == 'undefined' )
				? false
				: e;
		}
		return false;
	}
	function getTrueInnerHeight( $el )
	{
		var h = $el.innerHeight(),
			a = [ 'paddingTop', 'paddingBottom' ];

		for ( var z = 0, l = a.length; z < l; z++ ) {
			var m = parseInt( $el.css( a[ z ] ), 10 );
			if ( isNaN( m ) )
			{
				m = 0;
			}
			h -= m;
		}
		return h;
	}
	function debug( d, m )
	{
		if ( !d )
		{
			return false;
		}
		if ( typeof m == 'string' )
		{
			m = 'dotdotdot: ' + m;
		}
		else
		{
			m = [ 'dotdotdot:', m ];
		}

		if ( typeof window.console != 'undefined' )
		{
			if ( typeof window.console.log != 'undefined' )
			{
				window.console.log( m );
			}
		}
		return false;
	}
	

	//	override jQuery.html
	var _orgHtml = $.fn.html;
    $.fn.html = function( str ) {
		if ( typeof str != 'undefined' )
		{
			if ( this.data( 'dotdotdot' ) )
			{
				if ( typeof str != 'function' )
				{
					return this.trigger( 'update', [ str ] );
				}
			}
			return _orgHtml.call( this, str );
		}
		return _orgHtml.call( this );
    };


	//	override jQuery.text
	var _orgText = $.fn.text;
    $.fn.text = function( str ) {
		if ( typeof str != 'undefined' )
		{
			if ( this.data( 'dotdotdot' ) )
			{
				var temp = $( '<div />' );
				temp.text( str );
				str = temp.html();
				temp.remove();
				return this.trigger( 'update', [ str ] );
			}
			return _orgText.call( this, str );
		}
        return _orgText.call( this );
    };


})( require('jquery') );
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/soy/ProjectTemplatesList.soy' */
// This file was automatically generated from ProjectTemplatesList.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }


JIRA.Templates.ProjectTemplates.renderProjectTemplates = function(opt_data, opt_ignored) {
  return '' + ((soy.$$getMapKeys(opt_data.projectTemplates).length == 0) ? JIRA.Templates.errorMsg({closeable: false, msg: "No project templates could be found."}) : JIRA.Templates.ProjectTemplates.renderTemplates(opt_data));
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderProjectTemplates.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderProjectTemplates';
}


JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.projectTemplatesByType.length == 0) {
    output += JIRA.Templates.errorMsg({closeable: false, msg: "No project templates could be found."});
  } else {
    var projectTypeTemplatesGroupList18 = opt_data.projectTemplatesByType;
    var projectTypeTemplatesGroupListLen18 = projectTypeTemplatesGroupList18.length;
    for (var projectTypeTemplatesGroupIndex18 = 0; projectTypeTemplatesGroupIndex18 < projectTypeTemplatesGroupListLen18; projectTypeTemplatesGroupIndex18++) {
      var projectTypeTemplatesGroupData18 = projectTypeTemplatesGroupList18[projectTypeTemplatesGroupIndex18];
      output += '<div class="template-group" id="project-template-group-' + soy.$$escapeHtml(projectTypeTemplatesGroupData18.projectTypeBean.projectTypeKey) + '"><div class="template-group-header"><h6><img class="project-type-icon" src="data:image/svg+xml;base64, ' + soy.$$escapeHtml(projectTypeTemplatesGroupData18.projectTypeBean.icon) + ' "/><span>' + soy.$$escapeHtml(projectTypeTemplatesGroupData18.projectTypeBean.projectTypeDisplayKey) + '</span></h6></div>' + JIRA.Templates.ProjectTemplates.renderTemplates({projectTemplates: projectTypeTemplatesGroupData18.projectTemplates}) + '</div>';
    }
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType';
}


JIRA.Templates.ProjectTemplates.renderTemplates = function(opt_data, opt_ignored) {
  return '<div class="pt-templates-list">' + JIRA.Templates.ProjectTemplates.renderItems(opt_data) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderTemplates.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderTemplates';
}


JIRA.Templates.ProjectTemplates.renderItems = function(opt_data, opt_ignored) {
  var output = '<ol class="templates" tabindex="100">';
  var templateList37 = opt_data.projectTemplates;
  var templateListLen37 = templateList37.length;
  for (var templateIndex37 = 0; templateIndex37 < templateListLen37; templateIndex37++) {
    var templateData37 = templateList37[templateIndex37];
    output += '<li class="template"' + ((templateData37.itemModuleCompleteKey) ? 'data-item-module-complete-key="' + soy.$$escapeHtml(templateData37.itemModuleCompleteKey) + '"' : '') + ((templateData37.projectTemplateModuleCompleteKey) ? 'data-project-template-module-complete-key="' + soy.$$escapeHtml(templateData37.projectTemplateModuleCompleteKey) + '"' : '') + ((templateData37.createProject) ? 'data-create-project="' + soy.$$escapeHtml(templateData37.createProject) + '"' : '') + ((templateData37.demoProject) ? 'data-demo-project="' + soy.$$escapeHtml(templateData37.demoProject) + '"' : '') + ((templateData37.backgroundIconUrl) ? 'data-background-icon-url="' + soy.$$escapeHtml(templateData37.backgroundIconUrl) + '"' : '') + ((templateData37.name) ? 'data-name="' + soy.$$escapeHtml(templateData37.name) + '"' : '') + ((templateData37.description) ? 'data-description="' + soy.$$escapeHtml(templateData37.description) + '"' : '') + ((templateData37.longDescriptionContent) ? 'data-long-description-content="' + soy.$$escapeHtml(templateData37.longDescriptionContent) + '"' : '') + ((templateData37.infoSoyPath) ? 'data-info-soy-path="' + soy.$$escapeHtml(templateData37.infoSoyPath) + '"' : '') + '><img class="template-preview" src="' + soy.$$escapeHtml(templateData37.iconUrl) + '" /><div class="template-meta"><div class="template-name" title="' + soy.$$escapeHtml(templateData37.name) + '">' + soy.$$escapeHtml(templateData37.name) + '</div><div class="template-description" title="' + soy.$$escapeHtml(templateData37.description) + '">' + soy.$$escapeHtml(templateData37.description) + '</div></div></li>';
  }
  output += '</ol>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.renderItems.soyTemplateName = 'JIRA.Templates.ProjectTemplates.renderItems';
}


JIRA.Templates.ProjectTemplates.loadingTemplatesList = function(opt_data, opt_ignored) {
  return '<div class="wait-container"><img class="wait-icon" src="' + soy.$$escapeHtml("/jira") + '/images/icons/wait.gif"><span class="wait-text">' + soy.$$escapeHtml("Loading project templates") + '&hellip;</span></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.loadingTemplatesList.soyTemplateName = 'JIRA.Templates.ProjectTemplates.loadingTemplatesList';
}


JIRA.Templates.ProjectTemplates.footerLinks = function(opt_data, opt_ignored) {
  return '<div class="footer-links"><a class="import-project-trigger button-panel-link" href="' + soy.$$escapeHtml("/jira") + '/secure/admin/views/ExternalImport1.jspa">' + soy.$$escapeHtml("Import a project") + '</a>|<a class="create-with-shared-config button-panel-link" href="#"><span class="aui-icon aui-icon-create-shared">' + soy.$$escapeHtml("Create with shared configuration") + '</span> ' + soy.$$escapeHtml("Create with shared configuration") + '</a>' + ((opt_data.showDemoLink) ? '| <a class="add-demo-project-trigger button-panel-link" href="#">' + soy.$$escapeHtml("Create sample data") + '</a>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.footerLinks.soyTemplateName = 'JIRA.Templates.ProjectTemplates.footerLinks';
}


JIRA.Templates.ProjectTemplates.addWorkflowsLink = function(opt_data, opt_ignored) {
  return '<a class="add-workflow-link" href="' + soy.$$escapeHtml(opt_data.baseUrl) + '/plugins/servlet/wfshare-import?src=projecttemplates" tabindex="-1">' + soy.$$escapeHtml("View Marketplace Workflows") + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.addWorkflowsLink.soyTemplateName = 'JIRA.Templates.ProjectTemplates.addWorkflowsLink';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/soy/AddProject.soy' */
// This file was automatically generated from AddProject.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }


JIRA.Templates.ProjectTemplates.addProjectForm = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.errors.errorMessages) {
    var errorList5 = opt_data.errors.errorMessages;
    var errorListLen5 = errorList5.length;
    for (var errorIndex5 = 0; errorIndex5 < errorListLen5; errorIndex5++) {
      var errorData5 = errorList5[errorIndex5];
      output += JIRA.Templates.errorMsg({closeable: false, msg: errorData5});
    }
  }
  output += '<div class="add-project-wrapper"><div class="add-project-form-wrapper">' + aui.form.form({content: '' + aui.form.fieldset({legendContent: '', content: '' + JIRA.Templates.ProjectTemplates.longTextField({id: 'name', name: 'name', isRequired: false, maxLength: opt_data.maxNameLength, labelContent: "Name", descriptionText: AJS.format("Max. {0} characters.",opt_data.maxNameLength), value: opt_data.currentName ? opt_data.currentName : '', errorTexts: opt_data.errors.errors.projectName ? [opt_data.errors.errors.projectName] : []}) + JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon({id: 'key', name: 'key', isRequired: false, maxLength: opt_data.maxKeyLength, labelContent: "Key", descriptionText: AJS.format("Max. {0} characters.",opt_data.maxKeyLength), helpTitle: "What\x27s a project key?", value: opt_data.currentKey ? opt_data.currentKey : '', errorTexts: opt_data.errors.errors.projectKey ? [opt_data.errors.errors.projectKey] : []}) + ((opt_data.shouldShowLead) ? JIRA.Templates.ProjectTemplates.projectLeadField({field: opt_data.projectLeadPickerField, isRequired: false, errorTexts: opt_data.errors.errors.projectLead ? [opt_data.errors.errors.projectLead] : [], options: opt_data.leadOptions}) : '') + ((opt_data.addUserToLicense.displayCheckbox) ? JIRA.Templates.ProjectTemplates.addUserToLicense({fieldId: opt_data.addUserToLicense.fieldId, fieldName: opt_data.addUserToLicense.fieldName, applicationName: opt_data.addUserToLicense.applicationName, usedSeats: opt_data.addUserToLicense.usedSeats, totalSeats: opt_data.addUserToLicense.totalSeats, disableCheckbox: opt_data.addUserToLicense.disableCheckbox, licensingUrl: opt_data.addUserToLicense.licensingUrl}) : '') + '<input type="hidden" name="keyEdited" id="keyEdited" value="false"><input type="hidden" name="projectTemplateWebItemKey" value="' + soy.$$escapeHtml(opt_data.projectTemplateWebItemKey) + '"><input type="hidden" name="projectTemplateModuleKey" value="' + soy.$$escapeHtml(opt_data.projectTemplateModuleKey) + '"><input type="submit" class="pt-hidden-submit offscreen-left">'}), id: 'add-project-form'}) + '</div>' + ((opt_data.projectTemplateDescriptionContent) ? '<div class="add-project-description-wrapper"><div class="project-template-title"><h3>' + soy.$$escapeHtml(opt_data.projectTemplateTitle) + '</h3></div><div class="project-template-description">' + soy.$$filterNoAutoescape(opt_data.projectTemplateDescriptionContent) + '</div></div>' : '') + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.addProjectForm.soyTemplateName = 'JIRA.Templates.ProjectTemplates.addProjectForm';
}


JIRA.Templates.ProjectTemplates.keyHelp = function(opt_data, opt_ignored) {
  return '<div class="project-key-help"><p><b>' + soy.$$escapeHtml("What\x27s a project key?") + '</b></p><ul><li>' + soy.$$escapeHtml("It prefixes each issue in the project") + '</li><li>' + soy.$$escapeHtml("It can be changed, but this is not a trivial task") + '</li></ul></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.keyHelp.soyTemplateName = 'JIRA.Templates.ProjectTemplates.keyHelp';
}


JIRA.Templates.ProjectTemplates.projectLeadField = function(opt_data, opt_ignored) {
  var param77 = '' + aui.form.label({forField: opt_data.field.name + '-field', isRequired: opt_data.isRequired, content: "Project Lead"}) + JIRA.Templates.Fields.Pickers.User.single({field: opt_data.field, options: opt_data.options, editValue: opt_data.value}) + aui.form.fieldDescription({message: "Enter the username of the Project Lead."});
  if (opt_data.errorTexts) {
    var errorList90 = opt_data.errorTexts;
    var errorListLen90 = errorList90.length;
    for (var errorIndex90 = 0; errorIndex90 < errorListLen90; errorIndex90++) {
      var errorData90 = errorList90[errorIndex90];
      param77 += aui.form.fieldError({message: errorData90});
    }
  }
  var output = '' + aui.form.fieldGroup({content: param77});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.projectLeadField.soyTemplateName = 'JIRA.Templates.ProjectTemplates.projectLeadField';
}


JIRA.Templates.ProjectTemplates.addUserToLicense = function(opt_data, opt_ignored) {
  var output = '';
  var labelMessage__soy96 = '' + soy.$$escapeHtml(AJS.format("Give me a {0} license so I can access this project.",opt_data.applicationName)) + ((opt_data.totalSeats > 0) ? '<br/>' + soy.$$escapeHtml(AJS.format("({0} of {1} licenses now used)",opt_data.usedSeats,opt_data.totalSeats)) : '');
  output += aui.form.fieldGroup({content: '' + aui.form.label({forField: opt_data.fieldName, content: 'License'}) + ((opt_data.disableCheckbox) ? aui.form.field({id: opt_data.fieldId, name: opt_data.fieldName, value: 'true', type: 'checkbox', isChecked: false, labelContent: labelMessage__soy96, isDisabled: true, descriptionContent: AJS.format("We can\x27\x27t give you access to {0} automatically. You can {1}manage application access{2} to work on {0} projects.",opt_data.applicationName,'<a href="' + "/jira" + opt_data.licensingUrl + '">','</a>')}) : aui.form.field({id: opt_data.fieldId, name: opt_data.fieldName, value: 'true', type: 'checkbox', isChecked: false, labelContent: labelMessage__soy96, isDisabled: false}))});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.addUserToLicense.soyTemplateName = 'JIRA.Templates.ProjectTemplates.addUserToLicense';
}


JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon = function(opt_data, opt_ignored) {
  var param128 = '' + aui.form.label({forField: opt_data.name, isRequired: opt_data.isRequired, content: opt_data.labelContent}) + aui.form.input({id: opt_data.id, name: opt_data.name, type: 'text', maxLength: opt_data.maxLength, value: opt_data.value}) + '<a class="help-lnk" title="' + soy.$$escapeHtml(opt_data.helpTitle) + '" id="' + soy.$$escapeHtml(opt_data.id) + '-help-icon"><span class="aui-icon aui-icon-help">' + soy.$$escapeHtml(opt_data.helpTitle) + '</span></a>' + ((opt_data.descriptionText) ? aui.form.fieldDescription({message: opt_data.descriptionText}) : '');
  if (opt_data.errorTexts) {
    var errorList152 = opt_data.errorTexts;
    var errorListLen152 = errorList152.length;
    for (var errorIndex152 = 0; errorIndex152 < errorListLen152; errorIndex152++) {
      var errorData152 = errorList152[errorIndex152];
      param128 += aui.form.fieldError({message: errorData152});
    }
  }
  var output = '' + aui.form.fieldGroup({content: param128});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon.soyTemplateName = 'JIRA.Templates.ProjectTemplates.textFieldWithHelpIcon';
}


JIRA.Templates.ProjectTemplates.longTextField = function(opt_data, opt_ignored) {
  var param158 = '' + aui.form.label({forField: opt_data.name, isRequired: opt_data.isRequired, content: opt_data.labelContent}) + aui.form.input({id: opt_data.id, name: opt_data.name, type: 'text', maxLength: opt_data.maxLength, value: opt_data.value, extraClasses: 'long-field'}) + ((opt_data.descriptionText) ? aui.form.fieldDescription({message: opt_data.descriptionText}) : '');
  if (opt_data.errorTexts) {
    var errorList176 = opt_data.errorTexts;
    var errorListLen176 = errorList176.length;
    for (var errorIndex176 = 0; errorIndex176 < errorListLen176; errorIndex176++) {
      var errorData176 = errorList176[errorIndex176];
      param158 += aui.form.fieldError({message: errorData176});
    }
  }
  var output = '' + aui.form.fieldGroup({content: param158});
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.longTextField.soyTemplateName = 'JIRA.Templates.ProjectTemplates.longTextField';
}


JIRA.Templates.ProjectTemplates.spinner = function(opt_data, opt_ignored) {
  return '<span id=\'' + soy.$$escapeHtml(opt_data.id) + '\' class=\'icon throbber loading\'/>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.spinner.soyTemplateName = 'JIRA.Templates.ProjectTemplates.spinner';
}


JIRA.Templates.ProjectTemplates.formatAnchor = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.href) + '"' + ((opt_data.title) ? ' title="' + soy.$$escapeHtml(opt_data.title) + '"' : '') + '>' + soy.$$escapeHtml(opt_data.body) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.formatAnchor.soyTemplateName = 'JIRA.Templates.ProjectTemplates.formatAnchor';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/soy/CreateSharedProject.soy' */
// This file was automatically generated from CreateSharedProject.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }


JIRA.Templates.ProjectTemplates.createSharedProjectForm = function(opt_data, opt_ignored) {
  return '<div class="create-shared-project-wrapper"><div class="create-shared-project-form-wrapper">' + aui.form.form({content: '' + aui.form.fieldset({content: '<p>' + soy.$$escapeHtml("Select the existing project that you\x27d like to share configurations with.") + '<a class="help-lnk" title="' + soy.$$escapeHtml("What will be shared?") + '" id="shared-help-icon"><span class="aui-icon aui-icon-help">' + soy.$$escapeHtml("What will be shared?") + '</span></a></p>' + aui.form.fieldGroup({extraClasses: 'project-picker-group', content: '' + aui.form.label({forField: 'project-picker', isRequired: false, content: "Choose a project"}) + aui.form.input({id: 'project-picker', name: 'project', type: 'text'}) + '<div id="project-picker-options" data-suggestions="' + soy.$$escapeHtml(opt_data.projectSuggestions) + '"></div>'}) + '<p class="create-shared-info">' + soy.$$escapeHtml("When a configuration is shared with several projects, it means that any changes made to the configuration will affect all the projects.") + '</p>'}), id: 'create-shared-project-form'}) + '</div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.createSharedProjectForm.soyTemplateName = 'JIRA.Templates.ProjectTemplates.createSharedProjectForm';
}


JIRA.Templates.ProjectTemplates.loading = function(opt_data, opt_ignored) {
  return '<div><div class="dialog-spinner"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.loading.soyTemplateName = 'JIRA.Templates.ProjectTemplates.loading';
}


JIRA.Templates.ProjectTemplates.noProjects = function(opt_data, opt_ignored) {
  return '<p>' + soy.$$escapeHtml("Looks like no other projects exist yet. Please create a brand new project first before trying to share an existing project\x27s configuration.") + '</p>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.noProjects.soyTemplateName = 'JIRA.Templates.ProjectTemplates.noProjects';
}


JIRA.Templates.ProjectTemplates.sharedHelp = function(opt_data, opt_ignored) {
  return '<div class="shared-help"><p><strong>' + soy.$$escapeHtml("What will be shared?") + '</strong></p><p>' + soy.$$escapeHtml("Configuration refers to the set of schemes used by a project") + '</p><ul><li>' + soy.$$escapeHtml("Permission Scheme") + '</li><li>' + soy.$$escapeHtml("Notification Scheme") + '</li><li>' + soy.$$escapeHtml("Issue Security Scheme") + '</li><li>' + soy.$$escapeHtml("Workflow Scheme") + '</li><li>' + soy.$$escapeHtml("Issue Type Scheme") + '</li><li>' + soy.$$escapeHtml("Issue Type Screen Scheme") + '</li><li>' + soy.$$escapeHtml("Field Configuration Scheme") + '</li></ul></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.sharedHelp.soyTemplateName = 'JIRA.Templates.ProjectTemplates.sharedHelp';
}
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/Config.js' */
define('jira/project-templates/config', {
    model: {}
});
AJS.namespace('JPT.ConfigModel', null, require('jira/project-templates/config'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/ProjectKeyGenerator.js' */
define('jira/project-templates/project-key-generator', [
    'jquery',
    'underscore'
], function(
    $,
    _
){
    var ProjectKeyGenerator = {};
    ProjectKeyGenerator.IGNORED_WORDS = ["THE", "A", "AN", "AS", "AND", "OF", "OR"];

    // The (non-ascii) characters used as keys will be replaced with their (ascii) value.
    ProjectKeyGenerator.CHARACTER_MAP = {};
    ProjectKeyGenerator.CHARACTER_MAP[199] = "C"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[231] = "c"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[252] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[251] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[250] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[249] = "u"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[233] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[234] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[235] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[232] = "e"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[226] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[228] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[224] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[229] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[225] = "a"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[239] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[238] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[236] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[237] = "i"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[196] = "A"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[197] = "A"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[201] = "E"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[230] = "ae"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[198] = "Ae"; // ®
    ProjectKeyGenerator.CHARACTER_MAP[244] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[246] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[242] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[243] = "o"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[220] = "U"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[255] = "Y"; // Ø
    ProjectKeyGenerator.CHARACTER_MAP[214] = "O"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[241] = "n"; // ?
    ProjectKeyGenerator.CHARACTER_MAP[209] = "N"; // ?

    ProjectKeyGenerator.desiredKeyLength = 4;
    ProjectKeyGenerator.maxKeyLength = 10;

    ProjectKeyGenerator.getTotalLength = function getTotalLength(words) {
        return words.join("").length;
    };

    ProjectKeyGenerator.removeIgnoredWords = function removeIgnoredWords(words) {
        return _.reject(words, function(word) {
            return $.inArray(word, ProjectKeyGenerator.IGNORED_WORDS) !== -1;
        });
    };

    ProjectKeyGenerator.createAcronym = function createAcronym(words) {
        var result = "";
        $.each(words, function(i, word) {
            result += word.charAt(0);
        });
        return result;
    };

    ProjectKeyGenerator.getFirstSyllable = function getFirstSyllable(word) {
        // Best guess at getting the first syllable
        // Returns the substring up to and including the first consonant to appear after a vowel
        var pastVowel = false;
        var i;
        for (i = 0; i < word.length; i++) {
            if (ProjectKeyGenerator.isVowelOrY(word[i])) {
                pastVowel = true;
            } else {
                if (pastVowel) {
                    return word.substring(0, i + 1);
                }
            }
        }
        return word;
    };

    ProjectKeyGenerator.isVowelOrY = function isVowelOrY(c) {
        return c && c.length === 1 && c.search("[AEIOUY]") !== -1;
    };

    ProjectKeyGenerator.init = function init(desiredKeyLength, maxKeyLength) {
        ProjectKeyGenerator.desiredKeyLength = desiredKeyLength;
        ProjectKeyGenerator.maxKeyLength = maxKeyLength;
    };

    ProjectKeyGenerator.generate = function generate(name) {
        name = $.trim(name);
        if (!name) {
            return "";
        }

        // Brute-force chunk-by-chunk substitution and filtering.
        var filtered = [];
        for(var i=0, ii=name.length; i<ii; i++) {
            var sub = ProjectKeyGenerator.CHARACTER_MAP[name.charCodeAt(i)];
            filtered.push(sub ? sub : name[i]);
        }
        name = filtered.join('');

        // Split into words
        var words = [];
        $.each(name.split(/\s+/), function(i, word) {
            if (word) {
                // Remove whitespace and punctuation characters (i.e. anything not A-Z)
                word = word.replace(/[^a-zA-Z]/g, "");
                // uppercase the word (NOTE: JavaScript attempts to convert characters like § in to SS)
                word = word.toUpperCase();
                // add the word, should it be worthy.
                word.length && words.push(word);
            }
        });

        // Remove ignored words
        if (ProjectKeyGenerator.desiredKeyLength && ProjectKeyGenerator.getTotalLength(words) > ProjectKeyGenerator.desiredKeyLength) {
            words = ProjectKeyGenerator.removeIgnoredWords(words);
        }

        var key;

        if (words.length == 0) {
            // No words were worthy!
            key = "";
        } else if (words.length == 1) {
            // If we have one word, and it is longer than a desired key, get the first syllable
            var word = words[0];
            if (ProjectKeyGenerator.desiredKeyLength && word.length > ProjectKeyGenerator.desiredKeyLength) {
                key = ProjectKeyGenerator.getFirstSyllable(word);
            } else {
                // The word is short enough to use as a key
                key = word;
            }
        } else {
            // If we have more than one word, just take the first letter from each
            key = ProjectKeyGenerator.createAcronym(words);
        }

        // Limit the length of the key
        if (ProjectKeyGenerator.maxKeyLength && key.length > ProjectKeyGenerator.maxKeyLength) {
            key = key.substr(0, ProjectKeyGenerator.maxKeyLength);
        }

        return key;
    };
    return ProjectKeyGenerator;
});
AJS.namespace('JPT.ProjectKeyGenerator', null, require('jira/project-templates/project-key-generator'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/DialogView.js' */
// Warning!
//This module has a hidden circular dependency -> jira/project-templates/dialog-controller
define('jira/project-templates/dialog-view-impl', [
    'require',
    'backbone',
    'underscore'
], function(
    require,
    Backbone,
    _
){
    var Dialog = AJS.Dialog;
    var Trigger = AJS.trigger;

    return Backbone.View.extend({
        events: {
            "click   .add-project-trigger": "_onClickAddProject",
            "click   .add-demo-project-trigger": "_onClickAddDemoProject",
            "click   .add-workflow-link": "_onClickViewMarketplaceWorkflows",
            "click   #add-project-dialog .add-demo-project-trigger": "_onCreateProjectAddDemoProjectClick",
            "click   #add-project-dialog .import-project-trigger": "_onClickImportProject",
            "click   #add-project-dialog .create-with-shared-config": "_onClickCreateShared",
            "keydown #add-project-dialog .pt-templates-list": "_onKeydownInTemplatesList"
        },

        draw: function() {
            var dialog = new Dialog({
                width: 840,
                height: 400,
                id: "add-project-dialog",
                closeOnOutsideClick: false,
                keypressListener: _.bind(this._onKeyPressed, this)
            });

            var $dialog = dialog.popup.element;

            dialog.addPage("project-templates-page");

            dialog.addHeader("Create project", "add-project-dialog-header");

            dialog.addPanel("ProjectTemplatesListPanel", JIRA.Templates.ProjectTemplates.loadingTemplatesList(), "pt-content");

            this._dialog = dialog;
            this._$dialogElement = $dialog;

            dialog.show();

            return dialog;
        },

        /**
         * Removes this DialogView.
         *
         * @return {*}
         */
        remove: function() {
            this._dialog && this._dialog.remove();
        },

        showErrorMessage: function(message) {
            this._dialog.getPanel(1, 0).html(JIRA.Templates.errorMsg({
                closable: false,
                msg: message
            }));
        },

        get$PTContent: function getPTContent() {
            return this.getDialogController().$dialogElement.find(".pt-content");
        },

        /**
         * Removes this dialog when ESC is pressed. Note that this is called on keydown anywhere within the dialog,
         * including all steps of the wizard, so you want to be careful about what you do in here.
         *
         * @param {jQuery.Event} e the keydown Event
         * @returns {boolean}
         * @private
         */
        _onKeyPressed: function(e) {
            var escapeKey = 27;
            if (this._dialog) {
                if (e.keyCode === escapeKey) {
                    this.getDialogController().hideDialogFromNewUser("dismissed");
                    this._dialog.remove();
                    return false; // preventDefault, don't propagate.
                }
            }

            return true;
        },

        /**
         * Proceeds to the next step of the wizard when the user presses ENTER in the project templates list.
         * Unfortunately in this case we can't rely on browser auto-submit of forms because the focus is not inside a
         * text input/
         *
         * @param {jQuery.Event} e
         * @returns {boolean}
         * @private
         */
        _onKeydownInTemplatesList: function(e) {
            var enterKey = 13;
            if (this._dialog) {
                if (e.keyCode === enterKey) {
                    this._$dialogElement.find(".pt-submit-button:visible").click();
                    return false;
                }
            }

            return true;
        },

        _onClickAddProject: function(event) {
            event.preventDefault();
            this.getDialogController().handleProjectTemplateTriggered();
        },

        _onCreateProjectAddDemoProjectClick: function() {
            Trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.demo.create.project.clicked'});
        },

        _onClickViewMarketplaceWorkflows: function () {
            Trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.viewmarketplaceworkflows.clicked'});
        },

        _onClickAddDemoProject: function(event) {
            event.preventDefault();
            var dialog = this.getDialogController().dialog;
            if (dialog && dialog.popup && dialog.popup.element) {
                dialog.remove();
            }
            this.getDialogController().handleDemoProjectTemplateTriggered();
        },

        _onClickImportProject: function(event) {
            this.getDialogController().hideDialogFromNewUser("importproject");
        },

        _onClickCreateShared: function(event) {
            this.getDialogController().handleCreateShared();
        },

        getDialogController: function() {
            return require('jira/project-templates/dialog-controller');
        }
    });
});

define('jira/project-templates/dialog-view', [
    'jira/project-templates/dialog-view-impl',
    'jquery'
], function(
    DialogViewImpl,
    $
){
    return new DialogViewImpl({ el: $(document) });
});
AJS.namespace('JPT.DialogView', null, require('jira/project-templates/dialog-view'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/DialogController.js' */
// Warning!
// This module has a hidden circular dependencies -> jira/project-templates/select-project-template-controller
//                                                -> jira/project-templates/create-shared-controller
define('jira/project-templates/dialog-controller', [
    'jira/project-templates/dialog-view',
    'jira/project-templates/config',
    'jira/ajs/ajax/smart-ajax',
    'jira/util/data/meta',
    'jira/lib/class',
    'jquery',
    'underscore',
    'wrm/data'
], function(
    DialogView,
    Config,
    SmartAjax,
    Meta,
    Class,
    $,
    _,
    wrmData
){
    var contextPath = AJS.contextPath();
    var isDevMode = AJS.isDevMode;
    var log = AJS.log;

    function triggerAnalytics(name, params) {
        AJS.trigger('analyticsEvent', {name: name, data: params});
    }

    var ptAnalyticsData;
    var getPtAnalyticsData = function () {
        if( !ptAnalyticsData ) {
            ptAnalyticsData = wrmData.claim('com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources.ptAnalyticsData') || {};
        }
        return ptAnalyticsData;
    };

    var DialogController = Class.extend({
        WELCOME_REST_URL: contextPath + "/rest/welcome/1.0/show/welcome",

        initialize: function() {
            _.bindAll(this, 'handleProjectTemplateTriggered', 'hideDialogFromNewUser');

            if (Meta.getBoolean('show-welcome-screen')) {
                this.handleProjectTemplateTriggered();
            }
        },

        handleProjectTemplateTriggered: function() {
            this.demoProject = false;
            triggerAnalytics('jira.project.templates.dialog.create.show');
            this.openWithFirstProjectTemplateOfTypePreSelected();
        },

        handleDemoProjectTemplateTriggered: function() {
            this.demoProject = true;
            var projectTemplatesDeferred = this.getTemplateController().loadDemoProjectTemplatesData();
            this.openWithFirstProjectTemplateOfTypePreSelected(null, projectTemplatesDeferred);
            this._addAnalyticsToCreateDemoShow(projectTemplatesDeferred);
        },

        _addAnalyticsToCreateDemoShow: function (projectTemplatesDeferred) {
            projectTemplatesDeferred.done(function (data) {
                var params = {};

                var getDemoSets = function (data) {
                    return data.projectTemplatesGroupedByType.map(
                        function (ptGroup) {
                            return ptGroup.projectTemplates.map(
                                function (pt) {
                                    return pt.itemModuleCompleteKey
                                }).join();
                        }).join();
                };

                params.demoSets = getDemoSets(data);
                params.instanceCreatedDate = getPtAnalyticsData().instanceCreatedDate;

                triggerAnalytics('jira.project.templates.dialog.create.demo.show', params);
            }.bind(this));
        },

        openWithFirstProjectTemplateOfTypePreSelected: function(projectTypeKey, projectTemplatesDeferred) {
            projectTemplatesDeferred = projectTemplatesDeferred || this.getTemplateController().loadProjectTemplatesData();
            //draw dialog with spinner
            this.dialog  = DialogView.draw();

            projectTemplatesDeferred.fail(_.bind(function (jqXHR) {
                this._handleUnknownErrorOfPTRetrieval();
            }, this));

            projectTemplatesDeferred.done(_.bind(function (data) {
                this.$dialogElement = this.dialog.popup.element;

                // Persist the selected template (e.g. after coming back from a GH installation)
                var selectedTemplate;
                if (!_.isUndefined(Config.model.selectedTemplate)) {
                    selectedTemplate = Config.model.selectedTemplate;
                }
                Config.model = data;
                Config.model.selectedTemplate = selectedTemplate;
                this.getTemplateController().init(data, projectTypeKey);
            }, this));
        },

        handleCreateShared: function() {
            triggerAnalytics('jira.project.templates.dialog.create.shared.clicked');
            this.demoProject = false;
            this.openWithCreateShared();
        },

        openWithCreateShared: function() {
            var CreateSharedController = require('jira/project-templates/create-shared-controller');
            CreateSharedController.initCreateShared();
        },

        callbackWithResize: function(callback) {
            return _.bind(_.wrap(callback, function(originalCallback) {
                originalCallback.call(this);
                this.dialog.updateHeight();
            }), this);
        },

        addPage: function(pageConfig) {
            var page = this.dialog.addPage(pageConfig.name).page[this.dialog.curpage];
            this.dialog.addHeader(pageConfig.title, "add-project-dialog-header");
            this.dialog.addPanel(pageConfig.panelName, "", "pt-content");

            if (pageConfig.backButton) {
                this._addBackButton(page);
            }

            this.dialog.addButton(
                pageConfig.submitButtonText,
                this.callbackWithResize(pageConfig.submitButtonCallback),
                pageConfig.submitButtonClass + " pt-submit-button"
            );
            var $submitButton = this.$dialogElement.find("." + pageConfig.submitButtonClass);
            $submitButton.removeClass("button-panel-button").addClass("aui-button aui-button-primary"); /* button-panel-button class doesn't have disabled styles, using .aui-button instead */
            $submitButton.focus();

            this.dialog.addCancel("Cancel", _.bind(function(event) {
                this.hideDialogFromNewUser("dismissed");

                this.dialog.remove();
            }, this));

            return page;
        },

        _backButtonOnClickCallback: function(page) {
            return _.bind(function() {
                if (this.demoProject) {
                    triggerAnalytics("jira.project.templates.dialog.demo.back");
                } else {
                    triggerAnalytics("jira.project.templates.dialog.create.back");
                }
                var $addProjectWrapper = DialogView.get$PTContent();
                $addProjectWrapper.css('background-image', 'none');

                this.dialog.prevPage();
                page.remove();
                this.dialog.page.pop();
            }, this);
        },

        _addBackButton: function(page) {
            this.dialog.addButton(
                "Back",
                this.callbackWithResize(this._backButtonOnClickCallback(page)),
                "add-project-back-button"
            );
            var $backButton = this.$dialogElement.find(".add-project-back-button");
            $backButton.removeClass("button-panel-button").addClass("aui-button");
        },

        _handleUnknownErrorOfPTRetrieval: function() {
            DialogView.showErrorMessage("An error occurred while trying to contact JIRA");
        },

        hideDialogFromNewUser: function(reason) {
            if (reason === "dismissed") {
                if (this.demoProject) {
                    triggerAnalytics("jira.project.templates.dialog.demo.dismissed");
                } else {
                    triggerAnalytics("jira.project.templates.dialog.create.dismissed");
                }
            } else if (reason === "importproject") {
                triggerAnalytics('jira.project.templates.dialog.import.clicked');
            } else if (reason === "templateselected") {
                if (this.demoProject) {
                    triggerAnalytics("jira.project.templates.dialog.demo.templateselected");
                } else {
                    triggerAnalytics("jira.project.templates.dialog.create.templateselected");
                }
            }

            if (Meta.getBoolean('show-welcome-screen')) {
                $.ajax({
                    url: this.WELCOME_REST_URL + "/" + reason,
                    type: "DELETE",
                    success: function () {
                        if (isDevMode && isDevMode()) {
                            log("don't show project template dialog anymore");
                        }
                    }
                });
            }
        },

        getTemplateController: function() {
            return require('jira/project-templates/select-project-template-controller');
        }
    });

    return new DialogController();
});
AJS.namespace('JPT.DialogController', null, require('jira/project-templates/dialog-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/AddProjectView.js' */
// WARNING
// This module has a hidden circular dependency -> jira/project-templates/add-project-controller
define('jira/project-templates/add-project-view-impl', [
    'jira/project-templates/dialog-controller',
    'jira/project-templates/config',
    'jira/util/events',
    'jira/util/events/types',
    'require',
    'backbone',
    'jquery',
    'underscore'
], function(
    DialogController,
    Config,
    Events,
    EventTypes,
    require,
    Backbone,
    $,
    _
){
    var InlineDialog = AJS.InlineDialog;

    return Backbone.View.extend({
        TIMEOUT_MS: 100,

        postDrawCallbacks: [],

        events: {
            "submit #add-project-form": "onSubmitForm"
        },

        page: undefined,
        isSubmitting: false,

        initialize: function(options) {
            _.bindAll(this, "bindHook");
        },

        addPostDrawCallback: function(callback) {
            this.postDrawCallbacks.push(callback);
        },

        /**
         * Prepare the Dialog to hold the Add Project form; this should only be called once for a selected Project Template.
         * The actual form could be rendered multiple times after unsuccessful validations.
         */
        prepareDialog: function(title) {
            this.page = DialogController.addPage({
                name: "add-project",
                title: title,
                panelName: "add-project",
                backButton: true,
                submitButtonText: "Submit",
                submitButtonCallback: this.onSubmitForm.bind(this),
                submitButtonClass: "add-project-dialog-create-button"
            });
        },

        /**
         * Draw the Add Project form into the passed dialog, as a new screen.
         *
         * This will be triggered on clicking "Next", so should render on the second page.
         */
        draw: function(params) {
            function fixErrorObject(errors) {
                if (!errors.errors) {
                    errors.errors = {}
                }
                return errors;
            }
            this.isSubmitting = false;

            DialogController.dialog.gotoPage(this.page.id);

            var projectTemplateModuleCompleteKey = params.webItemData.projectTemplateModuleCompleteKey;
            var templateGroup = _.find(Config.model.projectTemplatesGroupedByType, function(templateGroup){
                return _.any(templateGroup.projectTemplates, function(template) {
                    return template.itemModuleCompleteKey == projectTemplateModuleCompleteKey
                });
            });
            var applicationName = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.applicationName) || '';
            var usedSeats = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.licenseUsedSeats) || 0;
            var totalSeats = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.licenseTotalSeats) || 0;
            var canUserBeAddedToApplication = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.canUserBeAddedToApplication) || false;
            var canUserUseApplication = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.canUserUseApplication) || false;
            var isOnDemand = (templateGroup && templateGroup.applicationInfo && templateGroup.applicationInfo.ondemand) || false;
            var displayCheckbox;
            if (!templateGroup || !templateGroup.applicationInfo) {
                displayCheckbox = false;
            } else {
                displayCheckbox = !canUserUseApplication;
            }

            var soyParameters = {
                maxNameLength: Config.model.maxNameLength,
                maxKeyLength: Config.model.maxKeyLength,
                shouldShowLead: Config.model.shouldShowProjectLead,
                projectTemplateWebItemKey: Config.model.selectedTemplate || params.webItemData.itemModuleCompleteKey,
                projectTemplateModuleKey: projectTemplateModuleCompleteKey,
                projectTemplateTitle: params.webItemData.name,
                projectTemplateDescriptionContent: params.webItemData.longDescriptionContent,
                currentKey: params.currentKey || "",
                currentName: params.currentName || "",
                errors: fixErrorObject(params.errors),
                projectLeadPickerField: {
                    id: 'lead',
                    name: 'lead'
                },
                addUserToLicense: {
                    displayCheckbox: displayCheckbox,
                    disableCheckbox: !canUserBeAddedToApplication,
                    applicationName: applicationName,
                    usedSeats: usedSeats,
                    totalSeats: totalSeats,
                    fieldId: 'licenseUser',
                    fieldName: 'licenseUser',
                    licensingUrl: isOnDemand? '/admin/accessconfig' : '/plugins/servlet/applications/versions-licenses'
                },
                leadOptions: [
                    {
                        selected: true,
                        displayName: params.currentUserDisplayName,
                        optionName: params.currentUserName,
                        avatarURL: params.currentUserAvatarUrl
                    }
                ]
            };
            var addProjectForm = JIRA.Templates.ProjectTemplates.addProjectForm(soyParameters);

            DialogController.dialog.getPanel(this.page.id, 0).html(addProjectForm);

            if (params.webItemData && params.webItemData.backgroundIconUrl) {
                var $addProjectWrapper = DialogController.$dialogElement.find(".pt-content");
                $addProjectWrapper.css('background-image', 'url("' + params.webItemData.backgroundIconUrl + '")');
            }

            var $addProjectForm = $("#add-project-form");
            // fire event to create the Single User Picker
            Events.trigger(EventTypes.NEW_CONTENT_ADDED, [$addProjectForm]);

            this.nameElement = DialogController.$dialogElement.find("#name");
            this.keyElement = DialogController.$dialogElement.find("#key");
            this.keyEditedElement = DialogController.$dialogElement.find("#keyEdited");
            this.leadDisplayElement = DialogController.$dialogElement.find("#lead-field");
            this.leadValueElement = DialogController.$dialogElement.find("#lead");

            var $keyHelpElement = this.keyElement.parent().find(".aui-icon-help");
            if ($keyHelpElement.length) {
                new InlineDialog($keyHelpElement, "project-key-help-popup",
                    function(contents, trigger, show) {
                        contents.html(JIRA.Templates.ProjectTemplates.keyHelp());
                        show();
                    }, {
                        width: 330,
                        offsetX: -30
                    });
            }

            // Input restrictions
            this.keyElement.attr("style", "text-transform: uppercase");

            var AddProjectController = require('jira/project-templates/add-project-controller');

            this.nameElement.focus(_.bind(function(e) {
                this.bindHook(e, AddProjectController.nameTimeout);
            }, this));

            var self = this;
            this.nameElement.change(function (e){
                AddProjectController.validateName();
                self.unbindHook(e);
            });

            this.nameElement.focus();

            this.keyElement.focus(_.bind(function(e) {
                var el = $(e.target);
                el.data("lastValue", el.val());
                this.bindHook(e, AddProjectController.keyTimeout);
            }, this));

            this.keyElement.blur(_.bind(function(e) {
                this.unbindHook(e);
            }, this));

            this.keyElement.change(function() {
                AddProjectController.validateKey();
                AddProjectController.autofillKeyIfNeeded();
            });
            if (!_.isEmpty(this.postDrawCallbacks)) {
                _.each(this.postDrawCallbacks, function(callback) {
                    callback();
                });
            }
            DialogController.dialog.updateHeight();
        },

        /**
         * Submits the "Add Project" form.
         *
         * @param {jQuery.Event} e the submit event
         * @returns {boolean}
         */
        onSubmitForm: function(e) {
            var AddProjectController = require('jira/project-templates/add-project-controller');
            AddProjectController.submit();
            return false;
        },

        get$SubmitButton: function() {
            return DialogController.$dialogElement.find(".add-project-dialog-create-button");
        },

        get$BackButton: function() {
            return DialogController.$dialogElement.find(".add-project-back-button");
        },

        bindHook: function bindHook(e, func) {
            var el = $(e.target), hook;
            hook = _.bind(function() {
                this.unbindHook(e);
                func.apply();
                if (el.is(":visible")) {
                    el.data("checkHook", setTimeout(hook, this.TIMEOUT_MS));
                }
            }, this);
            if (!el.data("checkHook")) {
                el.data("checkHook", setTimeout(hook, 0));
            }
        },

        unbindHook: function(e) {
            var el = $(e.target);
            clearTimeout(el.data("checkHook"));
            el.removeData("checkHook");
        },

        /**
         * Show an error for an input element, in the place of its description.
         *
         * @param $element
         * @param msg
         */
        showInlineError: function($element, msg) {
            if (this.isSubmitting) {
                // while the form is being submitted, don't show any late validation errors
                return;
            }
            var $errorElement = $element.parent().find(".error");
            if (!$errorElement.length) {
                $errorElement = $("<div class='error'></div>");
                $element.parent().append($errorElement);
            }
            $errorElement.text(msg);
            $errorElement.show();
        },

        showInlineErrorForName: function showInlineErrorForName(msg) {
            this.showInlineError(this.nameElement, msg);
        },

        showInlineErrorForKey: function showInlineErrorForKey(msg) {
            this.showInlineError(this.keyElement, msg);
        },

        /**
         * Hide any errors for an input field shown by showInlineError, and its description.
         *
         * @param $element
         */
        hideInlineError: function hideInlineError($element) {
            $element.parent().find(".error").hide();
        },

        hideInlineErrorForName: function hideInlineErrorForName() {
            this.hideInlineError(this.nameElement);
        },

        hideInlineErrorForKey: function hideInlineErrorForKey() {
            this.hideInlineError(this.keyElement);
        },

        setName: function setName(value) {
            this.nameElement.val(value);
        },

        getName: function getName() {
            return this.nameElement.val();
        },

        setKey: function setKey(value) {
            this.keyElement.val(value);
        },

        getKey: function getKey() {
            return this.keyElement.val().toUpperCase();
        },

        getLeadDisplayName: function getLeadDisplayName() {
            return this.leadDisplayElement.val();
        },

        getLeadUserName: function getLeadUserName() {
            return this.leadValueElement.val();
        },

        getAvatarUrlOfSelectedLead: function getAvatarUrlOfSelectedLead() {
            var userAvatarBackGroundProperty = DialogController.$dialogElement.find("#lead-single-select .aui-ss-entity-icon").css('background-image');
            if (!_.isUndefined(userAvatarBackGroundProperty)) {
                var userAvatarUrl = userAvatarBackGroundProperty.match(/^url\((.+)\)$/);
                return (userAvatarUrl && userAvatarUrl[1]) ? userAvatarUrl[1] : "";
            } else {
                return "";
            }
        },

        setKeyEdited: function setKeyEdited(value) {
            this.keyEditedElement.val(value);
        },

        getKeyEdited: function getKeyEdited() {
            return this.keyEditedElement.val();
        },

        setKeyEdited: function setKeyEdited() {
            var key = this.getKey();
            // If the key is manually edited, do not suggest automatically generated keys anymore
            // If the key field is cleared, resume suggesting automatically generated keys
            if (this.keyElement.data("lastValue") !== key) {
                this.keyEditedElement.val((key) ? "true" : "false");
            }
            this.keyElement.data("lastValue", key);
        },

        hasNameErrors: function hasNameErrors() {
            return this.nameElement.parent().find(".error").size() > 0;
        },

        getAddProjectForm: function getAddProjectForm() {
            return $("#add-project-form");
        },

        get$FormFields: function getFormFields() {
            return DialogController.$dialogElement.find(":input");
        },

        enterLoadingState: function showLoadingState() {
            $submitButton = this.get$SubmitButton();
            if (!$submitButton.attr("disabled")) {
                $backButton = this.get$BackButton();
                $submitButton.attr("disabled", "disabled");
                $backButton.attr("disabled", "disabled");
                $backButton.before(
                    JIRA.Templates.ProjectTemplates.spinner({
                        id: "addproject-loading"
                    }));
                this.get$FormFields().attr('disabled', 'disabled');

                this.isSubmitting = true;

                return true;
            } else {
                return false;
            }
        },

        hideLoadingState: function hideLoadingState() {
            DialogController.$dialogElement.find("#addproject-loading").remove();
            this.get$SubmitButton().removeAttr('disabled');
            this.get$BackButton().removeAttr('disabled');
            this.get$FormFields().removeAttr('disabled');
        },

        avoidDirtyFormWarning: function avoidDirtyFormWarning() {
            if ($.fn.removeDirtyWarning) {
                this.getAddProjectForm().removeDirtyWarning();
            }
        },

        hasInlineErrors: function hasInlineErrors() {
            return DialogController.$dialogElement.find(".field-group .error:visible").length != 0;
        }

    });
});
define('jira/project-templates/add-project-view', [
    'jira/project-templates/add-project-view-impl',
    'jira/project-templates/dialog-view',
    'jquery'
], function(
    AddProjectViewImpl,
    DialogView,
    $
) {
    return new AddProjectViewImpl({
        el: $(document),
        dialogView: DialogView
    });
});

AJS.namespace('JPT.AddProjectView', null, require('jira/project-templates/add-project-view'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/AddProjectController.js' */
define('jira/project-templates/add-project-controller-impl', [
    'jira/project-templates/add-project-view',
    'jira/project-templates/project-key-generator',
    'jira/project-templates/dialog-controller',
    'jira/project-templates/config',
    'jira/lib/class',
    'jquery',
    'underscore'
], function (
    AddProjectView,
    ProjectKeyGenerator,
    DialogController,
    Config,    
    Class,
    $,
    _
){
    var contextPath = AJS.contextPath();
    var trigger = AJS.trigger;

    return Class.extend({
        postProjectCreationCallbacks: [],
        projectKeyValidationCallbacks: [],
        projectNamesUpperCased: [],

        init: function (options) {
            this._window = options.window || window; // used for mocking 'window' in QUnit
            _.bindAll(this, "projectCreatedHandler", "projectValidationFailedHandler", "nameTimeout", "keyTimeout", "submit");
        },

        initCreateShared: function (existingProjectData) {
            this.existingProjectData = existingProjectData;
            this._initAddProject("Create with shared configuration");
        },

        initProjectTemplate: function (webItemData) {
            this.existingProjectData = undefined;
            this.webItemData = webItemData;
            this._initAddProject(webItemData.name);
        },

        _initAddProject: function (title) {
            this.desiredKeyLength = 4;
            this.lastKeyValidated = "";

            this._getExistingProjects();
            ProjectKeyGenerator.init(this.desiredKeyLength, Config.model.maxKeyLength);

            AddProjectView.prepareDialog(title);
            AddProjectView.draw({
                webItemData: this.webItemData || {},
                maxKeyLength: Config.model.maxKeyLength,
                maxNameLength: Config.model.maxNameLength,
                currentUserName: Config.model.currentUserName,
                currentUserDisplayName: Config.model.currentUserDisplayName,
                currentUserAvatarUrl: Config.model.currentUserAvatarUrl,
                errors: {}
            });
        },

        _resetProjectLeadValues: function () {
            Config.model.currentUserDisplayName = "";
            Config.model.currentUserName = "";
            Config.model.currentUserAvatarUrl = "";
        },

        _hasFullyConfiguredProjectLead: function () {
            return AddProjectView.getLeadDisplayName() && AddProjectView.getAvatarUrlOfSelectedLead() != "";
        },

        submit: function (event) {
            // This data is retrieved before the input fields are disabled (in enterLoadingState()) to avoid null-pointer exceptions when the fields are empty.
            var formData;
            if (this.existingProjectData) {
                formData = {
                    "key": AddProjectView.getKey(),
                    "name": AddProjectView.getName(),
                    "lead": AddProjectView.getLeadUserName() && AddProjectView.getLeadUserName()[0]
                };
            } else {
                formData = jQuery.param(AddProjectView.getAddProjectForm().serializeArray().map(function(param) {
                    // upper case is "visually" enforced by text-transform: uppercase
                    if (param.name === "key") {
                        param.value = param.value.toUpperCase();
                    }
                    return param
                }));
            }

            if (AddProjectView.hasInlineErrors()) {
                return;
            }

            if (AddProjectView.enterLoadingState()) {
                // store lead so we can repopulate the user picker for when the submit fails
                if (this._hasFullyConfiguredProjectLead()) {
                    Config.model.currentUserDisplayName = AddProjectView.getLeadDisplayName();
                    Config.model.currentUserName = Config.model.currentUserDisplayName ? AddProjectView.getLeadUserName() : "";
                    Config.model.currentUserAvatarUrl = AddProjectView.getAvatarUrlOfSelectedLead();
                } else {
                    this._resetProjectLeadValues();
                }

                if (this.existingProjectData) {
                    $.ajax({
                        url: contextPath + "/rest/project-templates/1.0/createshared/" + this.existingProjectData.existingProjectId,
                        type: "POST",
                        contentType: "application/json",
                        data: JSON.stringify(formData)
                    }).then(this.projectCreatedHandler, this.projectValidationFailedHandler);
                } else {
                    $.ajax({
                        url: contextPath +
                            (this.webItemData.demoProject ?
                                "/rest/jira-importers-plugin/1.0/demo/create" :
                                "/rest/project-templates/1.0/templates"),
                        type: "POST",
                        data: formData,
                        headers: {
                            "X-Atlassian-Token": "nocheck"
                        }
                    }).then(this.projectCreatedHandler, this.projectValidationFailedHandler);
                }
            }
        },

        registerPostProjectCreationCallback: function (callback) {
            this.postProjectCreationCallbacks.push(callback);
        },

        registerProjectKeyValidationCallback: function (callback) {
            this.projectKeyValidationCallbacks.push(callback);
        },

        localStoragePrefix: "jira.projecttemplates.",

        projectCreatedHandler: function (data) {
            if (this.existingProjectData) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.shared.project.create.success'});
            } else if (this.webItemData.demoProject) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.demo.success'});
            } else {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.project.success'});
            }
            AddProjectView.avoidDirtyFormWarning();

            // Put the created projects into local storage
            var localStoragePrefix = this.localStoragePrefix;
            var remoteProjectTypes = ["confluenceProject", "fisheyeProject", "crucibleProject", "bambooProject"];
            _.map(remoteProjectTypes, function (remoteProject) {
                if (data.remoteProjectLinks && data.remoteProjectLinks[remoteProject]) {
                    localStorage.setItem(localStoragePrefix + remoteProject, data.remoteProjectLinks[remoteProject]);
                }
            });


            // If there are any post Project Created callbacks registered, call these. Otherwise redirect to the desired return URL.
            if (!_.isEmpty(this.postProjectCreationCallbacks)) {
                DialogController.dialog.addPage("post-project-created-page");
                _.each(this.postProjectCreationCallbacks, function (callback) {
                    callback(DialogController.dialog, data.returnUrl, data.projectId, data.projectKey, data.projectName);
                });
            } else {
                this._window.location = contextPath + data.returnUrl;
            }
        },

        projectValidationFailedHandler: function (jqXhr, textStatus) {
            if (this.existingProjectData) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.shared.project.create.failure'});
            } else if (this.webItemData.demoProject) {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.demo.failure'});
            } else {
                trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.project.failure'});
            }

            var errors = {};
            if (this.isBadRequest(jqXhr)) {
                errors = JSON.parse(jqXhr.responseText);
            } else if (this.isUnDefinedServerSideError(jqXhr)) {
                errors = {"errorMessages": ["Hmm... we couldn\'t create your project due to an unknown error. Try refreshing the page to start again."]}
            } else if (this.isDefinedServerSideError(jqXhr)) {
                var errorResponse = JSON.parse(jqXhr.responseText);
                // Project template configuration threw an exception: Project has been created but the template hasn't been configured
                JIRA.Messages.showReloadErrorMsg(errorResponse.message);
                AddProjectView.avoidDirtyFormWarning();
                this._window.location = contextPath + errorResponse.returnUrl;
                // Remain in loading state while refreshing.
                return;
            } else if (this.isTimeoutError(textStatus)) {
                errors = {"errorMessages": ["Request timeout when creating project"]}
            } else {
                // Different kind of error. Let's generate an errors object with a general error that contains the right information
                errors = {"errorMessages": [AJS.format("Error creating project, {0}", jqXhr.responseText)]}
            }

            AddProjectView.draw({
                webItemData: this.webItemData || {},
                errors: errors,
                currentName: AddProjectView.getName(),
                currentKey: AddProjectView.getKey(),
                currentUserDisplayName: Config.model.currentUserDisplayName,
                currentUserName: Config.model.currentUserName,
                currentUserAvatarUrl: Config.model.currentUserAvatarUrl
            });

            AddProjectView.hideLoadingState();
        },

        isBadRequest: function(jqXhr) {
            return (jqXhr.status === 400) ;
        },

        isUnDefinedServerSideError: function(jqXhr){
            if (jqXhr.status === 500) {
                try {
                    JSON.parse(jqXhr.responseText);
                } catch(e) {
                    return true;
                }
            }
            return false;
        },

        isDefinedServerSideError: function(jqXhr) {
            return jqXhr.status === 500 && !_.isUndefined(JSON.parse(jqXhr.responseText).message) ;
        },

        isTimeoutError: function(textStatus) {
            return textStatus === "timeout" ;
        },

        _updateAndValidateKey: function updateKey(key) {
            AddProjectView.setKey(key);
            this.validateKey();
        },

        _shouldUpdateKey: function _shouldUpdateKey() {
            return (AddProjectView.getKeyEdited() != "true");
        },

        autofillKeyIfNeeded: function autofillKeyIfNeeded() {
            if (this._shouldUpdateKey()) {
                var key = ProjectKeyGenerator.generate(AddProjectView.getName());
                // JRADEV-10797 - Rather than validate the key,
                // we'll pretend that a key is always invalid if it's less than 1 character long.
                if (key.length > 1) {
                    this._updateAndValidateKey(key);
                } else {
                    // Blank the key without validation.
                    AddProjectView.setKey("");
                }
            }
        },

        _doesProjectNameExists: function (name) {
            var x;
            for (x in this.projectNamesUpperCased) {
                if (name.toUpperCase() == this.projectNamesUpperCased[x]) {
                    return true;
                }
            }

            return false;
        },

        validateName: function () {
            var name = $.trim(AddProjectView.getName());

            if (!name) {
                return;
            }

            if (name.length < Config.model.minNameLength) {
                AddProjectView.showInlineErrorForName(AJS.format("The project name should be at least {0} characters in length.", Config.model.minNameLength));
                return;
            }

            if (name.length > Config.model.maxNameLength) {
                AddProjectView.showInlineErrorForName(AJS.format("The project name must not exceed {0} characters in length.", Config.model.maxNameLength));
                return;
            }

            if (this._doesProjectNameExists(name)) {
                AddProjectView.showInlineErrorForName("A project with that name already exists.");
                return;
            }

            AddProjectView.hideInlineErrorForName();
        },

        _performKeyValidationChecks: function (key) {
            var validationChecksDeferred = $.ajax({
                url: contextPath + "/rest/api/latest/projectvalidate/key?key=" + key.toUpperCase()
            });

            validationChecksDeferred.done(_.bind(function (errors) {
                if (errors.errors && errors.errors["projectKey"]) {
                    AddProjectView.showInlineErrorForKey(errors.errors["projectKey"]);
                } else {
                    var foundError = false;
                    _.each(this.projectKeyValidationCallbacks, function (callback) {
                        var errors = callback(key.toUpperCase());
                        if (errors.errors && errors.errors["projectKey"]) {
                            foundError = true;
                            AddProjectView.showInlineErrorForKey(errors.errors["projectKey"]);
                        }
                    });
                    if (!foundError) {
                        AddProjectView.hideInlineErrorForKey();
                    }
                }
            }, this));
        },

        validateKey: function validateKey() {
            var key = AddProjectView.getKey();

            // Only validate the key if it has changed since the last time we validated it
            if (this.lastKeyValidated === key) {
                return;
            }

            if (key) {
                this.lastKeyValidated = key;
                this._performKeyValidationChecks(key);
            } else {
                AddProjectView.hideInlineErrorForKey();
            }
        },

        nameTimeout: function nameTimeout() {
            this.autofillKeyIfNeeded();
        },

        keyTimeout: function keyTimeout() {
            AddProjectView.setKeyEdited();
        },

        _getExistingProjects: function () {
            // Avoid retrieving the list twice (e.g. after hitting the 'Back' button and selecting new template)
            if (this.projectNamesUpperCased.length > 0) {
                return this.projectNamesUpperCased;
            }

            var existingProjectsDeferred = $.ajax({
                url: contextPath + "/rest/api/latest/project"
            });

            existingProjectsDeferred.done(_.bind(function (projects) {
                this.projectNamesUpperCased = _.map(projects, function (project) {
                    return project.name.toUpperCase();
                });
            }, this));
        }
    });
});
define('jira/project-templates/add-project-controller', [
    'jira/project-templates/add-project-controller-impl',
    'jquery'
], function(
    AddProjectControllerImpl,
    $
){
    return new AddProjectControllerImpl({el: $(document)});
});
AJS.namespace('JPT.AddProjectController', null, require('jira/project-templates/add-project-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/TemplateInfoView.js' */
// Warning!
// This module has a hidden circular dependency -> jira/project-templates/template-info-controller
define('jira/project-templates/template-info-view', [
    'jira/project-templates/dialog-controller',
    'require',
    'backbone',
    'jquery',
    'underscore'
], function(
    DialogController,
    require,
    Backbone,
    $,
    _
){
    var trigger = AJS.trigger;

    return Backbone.View.extend({

        initialize: function(options) {
            _.bindAll(this, "draw", "onNext")
        },

        draw: function(templatePath, name) {
            var page = DialogController.addPage({
                name: "template-info",
                title: name,
                panelName: "template-info",
                backButton: true,
                submitButtonText: "Select",
                submitButtonCallback: this.onNext,
                submitButtonClass: "template-info-dialog-create-button"
            });

            var templateInfoPanel = this._nameToObj(templatePath)();
            DialogController.dialog.getPanel(page.id, 0).html(templateInfoPanel);

            DialogController.dialog.gotoPage(page.id);
        },

        _nameToObj: function(name) {
            return _.reduce(name.split('.'), function(obj, name) { if (obj) return obj[name]; }, window);
        },

        onNext: function(e) {
            trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.templateinfo.next'});
            // This is a workaround to resolve circular dependencies between these two modules.
            var TemplateInfoController = require('jira/project-templates/template-info-controller');
            TemplateInfoController.next();
            return false;
        }
    });
});
AJS.namespace('JPT.TemplateInfoView', null, require('jira/project-templates/template-info-view'));
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/TemplateInfoController.js' */

define('jira/project-templates/template-info-controller', [
    'jira/project-templates/template-info-view',
    'jira/lib/class',
    'require',
    'underscore'
], function(
    TemplateInfoView,
    Class,
    require,
    _
){
    var TemplateInfoController = Class.extend({

        init: function(options) {
            _.bindAll(this, "initTemplateInfo", "next");
        },

        initTemplateInfo: function(projectTemplateData) {
            this.projectTemplateData = projectTemplateData;

            var infoView = new TemplateInfoView();
            infoView.draw(projectTemplateData.infoSoyPath, projectTemplateData.name);
        },

        next: function() {
            var SelectProjectTemplateController = require('jira/project-templates/select-project-template-controller');
            SelectProjectTemplateController.openAddProjectPage(this.projectTemplateData);
        }
    });
    return new TemplateInfoController();
});
AJS.namespace('JPT.TemplateInfoControllerImpl', null, require('jira/project-templates/template-info-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/SelectProjectTemplateView.js' */
// Warning!
// This module has a hidden circular dependency -> jira/project-templates/select-project-template-controller
define('jira/project-templates/select-project-template-view', [
    'jira/project-templates/dialog-controller',
    'jira/project-templates/config',
    'jira/featureflags/feature-manager',
    'require',
    'backbone',
    'jquery',
    'underscore'
], function(
    DialogController,
    Config,
    featureManager,
    require,
    Backbone,
    $,
    _
){
    var contextPath = AJS.contextPath();
    var preventDefault = AJS.preventDefault;

    return {
        ROW_LENGTH: 2,
        DIALOG_BODY_CLASS: "select-project-templates-page",
        DIALOG_WIDTH: 800,

        draw: function(data, projectType) {
            var SelectProjectTemplateController = require('jira/project-templates/select-project-template-controller');
            this.page = DialogController.addPage({
                name: this.DIALOG_BODY_CLASS,
                title: data.demoProjects ? "Create project with sample data" : "Create project",
                panelName: "ProjectTemplatesListPanel",
                backButton: false,
                submitButtonText: "Next",
                submitButtonCallback: SelectProjectTemplateController.dialogSubmitted,
                submitButtonClass: "create-project-dialog-create-button"
            });

            function getHtml() {
                if (SelectProjectTemplateController.isProjectTypesEnabled(data)) {
                    return JIRA.Templates.ProjectTemplates.renderProjectTemplatesGroupedByType({
                        projectTemplatesByType: data.projectTemplatesGroupedByType
                    });
                }
                return JIRA.Templates.ProjectTemplates.renderProjectTemplates({
                    projectTemplates: data.projectTemplates
                });
            }

            DialogController.dialog.getPanel(this.page.id, 0).html(getHtml());

            if (Config.model.projectCount >= 2 && !data.demoProjects) {
                $(JIRA.Templates.ProjectTemplates.addWorkflowsLink({
                    baseUrl : contextPath
                })).appendTo(DialogController.$dialogElement.find(".dialog-title"));
            }

            var $nextButton = DialogController.$dialogElement.find(".create-project-dialog-create-button");
            var self = this;
            this.getTemplateItems().click(function() {
                var $this = $(this);
                $this.addClass("selected");
                self.getTemplateItems().not(this).removeClass("selected");
            }).dblclick(function() {
                $nextButton.click();
            }).focus(function () {
                $(this).click();
            });

            var $templatesContainer = this.get$TemplatesContainer();

            if (!data.demoProjects) {
                $(JIRA.Templates.ProjectTemplates.footerLinks({
                    showDemoLink: featureManager.isFeatureEnabled("jira.onboarding.cyoa")
                }))
                        .prependTo(DialogController.$dialogElement.find(".dialog-button-panel"));
            }

            this.bindKeyboardEvents($templatesContainer);

            if(SelectProjectTemplateController.isProjectTypesEnabled(data)) {
                if((data.projectTemplatesGroupedByType).length == 0) $nextButton.attr("disabled", "disabled");
            } else {
                if((data.projectTemplates).length == 0) $nextButton.attr("disabled", "disabled");
            }

            this.focusOnFirstTemplate($templatesContainer, projectType);

            DialogController.dialog.updateHeight();
            this.truncateTemplateDescriptions();
            this.resizeTemplateWidths();
        },

        get$TemplatesContainer: function() {
            return DialogController.$dialogElement.find('.templates');
        },

        focusOnFirstTemplate: function($templatesContainer, projectType) {
            if (projectType) {
                this.getFirstTemplateItemOfProjectType(projectType).click();
            } else {
                this.getFirstTemplateItem().click();
            }
            // Make sure me don't loose the focus because of any other interactions
            setTimeout(function (){
                $templatesContainer.focus();
            }, 0);
        },

        getSelectedTemplateData: function() {
            var $selectedTemplate = DialogController.$dialogElement.find(".template.selected");

            return $selectedTemplate.data();
        },

        /**
         * Converts arrow directions into sibling movement amounts in a grid.
         * @param which - the code of the key pressed
         * @return {Number} the amount to move, or 0 if no move should occur for this key code
         */
        getMoveDeltaForKey: function (which) {
            switch (which) {
                case 37: return -1; // left
                case 39: return +1; // right
                case 38: return -this.ROW_LENGTH; // up
                case 40: return +this.ROW_LENGTH; // down
            }
            return 0;
        },

        /**
         * Key-bindings on arrow-keys to change the selected template in the template container.
         */
        bindKeyboardEvents: function ($container) {
            $container.bind("keydown", _.bind(function (e) {
                var delta = this.getMoveDeltaForKey(e.which);
                if (delta) {
                    this.moveSelection($container, delta);
                    return preventDefault(e);
                }
            }, this));
        },

        /**
         * Move the selection in the template container forward or backward by a specified number of templates
         * @param container the template container jQuery object
         * @param delta - positive to move forward, negative to move backward
         */
        moveSelection: function (container, delta) {
            var $results = container.find('.template');
            var $selected = $results.filter('.selected');
            var index = $results.index($selected) + delta;
            if (index < $results.length && index >= 0) {
                var $next = $results.eq(index);
                $next.click().focus();

                this.scrollToSelectedElement($next);
            }
        },

        scrollToSelectedElement: function($selected) {
            var $itemContainer = $(".dialog-panel-body.pt-content");
            var itemContainerTopPosition = $itemContainer.offset().top;
            var nextTopPosition = $selected.offset().top;
            var nextBottomPosition = nextTopPosition + $selected.height();
            var itemContainerBottomPosition = itemContainerTopPosition + $itemContainer.height();

            if (nextTopPosition < itemContainerTopPosition) {
                $itemContainer.scrollTop($itemContainer.scrollTop() - (itemContainerTopPosition - nextTopPosition));
            } else if(nextBottomPosition > (itemContainerTopPosition + $itemContainer.height())) {
                $itemContainer.scrollTop($itemContainer.scrollTop() + nextBottomPosition - itemContainerBottomPosition);
            }
        },

        get$NextButton: function() {
            return DialogController.$dialogElement.find(".create-project-dialog-create-button");
        },

        disableNextButton: function() {
            this.get$NextButton().attr('disabled','disabled');
        },

        truncateTemplateDescriptions: function() {
            var locale = AJS.Meta.get("user-locale");
            var wrap = "word";
            if (locale === "ja_JP") {
                wrap = "letter";
            }
            DialogController.$dialogElement.find(".template-description").each(function() {
                $(this).dotdotdot({
                    'wrap': wrap,
                    'lastCharacter': {
                        'remove'		: [ ' ', ',', ';', '.', '!', '?', '。' ],
                        'noEllipsis'	: []
                    }
                });
            });
        },

        getTemplatesDialogContainer: function() {
            return DialogController.$dialogElement
                    .find("." + this.DIALOG_BODY_CLASS)
                    .find(".dialog-panel-body.pt-content")
                    .get(0);
        },

        getFirstTemplateItem: function() {
            return this.getTemplateItems().first();
        },

        getFirstTemplateItemOfProjectType: function(projectType) {
            return this.getTemplateItems().filter("#project-template-group-" + projectType + " *").first();
        },

        getTemplateItems: function() {
            return DialogController.$dialogElement.find(".template");
        },

        widthOfScrollbarForElement: function(el) {
            var visibleWidth = el.offsetWidth;
            var visibleWidthWithoutBorders = el.clientWidth;

            return visibleWidth - visibleWidthWithoutBorders;
        },

        widthOfDialogAvailableForTemplateList: function() {
            var dialogScrollbarWidth = this.widthOfScrollbarForElement(this.getTemplatesDialogContainer());

            return this.DIALOG_WIDTH - dialogScrollbarWidth;
        },

        widthOfTemplateItem: function() {
            var maxWidthForEachItem = this.widthOfDialogAvailableForTemplateList() / this.ROW_LENGTH;

            return maxWidthForEachItem - this.borderWidthOfTemplateItem();
        },

        borderWidthOfTemplateItem: function() {
            var templateItemBorderWidthString = this.getFirstTemplateItem().css("border-top-width");

            return parseInt(templateItemBorderWidthString, 10);
        },

        resizeTemplateWidths: function() {
            this.getTemplateItems().each(_.bind(function(index, el) {
                $(el).css("width", this.widthOfTemplateItem());
            }, this));
        }
    };
});
AJS.namespace('JPT.SelectProjectTemplateView', null, require('jira/project-templates/select-project-template-view'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/SelectProjectTemplateController.js' */
define('jira/project-templates/select-project-template-controller', [
    'jira/project-templates/select-project-template-view',
    'jira/project-templates/template-info-controller',
    'jira/project-templates/add-project-controller',
    'jira/project-templates/dialog-controller',
    'jira/project-templates/dialog-view',
    'jira/project-templates/config',
    'wrm/context-path',
    'jquery',
    'underscore'
], function(
    SelectProjectTemplateView,
    TemplateInfoController,
    AddProjectController,
    DialogController,
    DialogView,
    Config,
    ContextPath,
    $,
    _
){
    var contextPath = ContextPath();
    var SelectProjectTemplateController = {
        init: function init(data, projectTypeKey) {
            SelectProjectTemplateView.draw(data, projectTypeKey);
        },

        /**
         * Returns true if project types have been enabled on the server.
         * @param data the model returned by the server
         * @returns {boolean} true if project types have been enabled on the server.
         */
        isProjectTypesEnabled: function isProjectTypesEnabled(data) {
            return data.projectTemplatesGroupedByType != null;
        },

        /**
         * Return a Promise that others can hook into that returns the data required.
         */
        loadProjectTemplatesData: function loadProjectTemplatesData() {
            // Perform AJAX request for web items in the dialog and return them.
            return $.ajax({
                url: contextPath + "/rest/project-templates/1.0/templates",
                type: "GET"
            });
        },

        loadDemoProjectTemplatesData: function loadProjectTemplatesData() {
            // Perform AJAX request for web items in the dialog and return them.
            return $.ajax({
                url: contextPath + "/rest/project-templates/1.0/templates/demo-projects",
                type: "GET"
            }).then(function(result) {
                result.demoProjects = true;
                return result;
            });
        },

        dialogSubmitted: function dialogSubmitted() {
            var projectTemplateData = SelectProjectTemplateView.getSelectedTemplateData();

            DialogController.hideDialogFromNewUser("templateselected");

            SelectProjectTemplateController.raiseAtlassianEvent(projectTemplateData.itemModuleCompleteKey);

            if (!_.isUndefined(projectTemplateData.infoSoyPath)) {
                TemplateInfoController.initTemplateInfo(projectTemplateData);
            } else {
                SelectProjectTemplateController.openAddProjectPage(projectTemplateData);
            }
        },

        openAddProjectPage: function openAddProjectPage(projectTemplateData) {
            if (!projectTemplateData) {
                // Null data? How did you get here? It should be impossible to have no selected item.
                DialogView.showErrorMessage("An error occurred while trying to contact JIRA");
                return;
            }

            // Should the template key be missing, go to the project configuration step
            if (projectTemplateData.createProject) {
                AddProjectController.initProjectTemplate(projectTemplateData);
                // Otherwise, no template key provided: fire an event passing the dialog, so the plugin can choose what to do next
            } else {
                DialogController.dialog.addPage("blank-template-page");
                $("body").trigger(projectTemplateData.itemModuleCompleteKey, DialogController.dialog);
            }
        },

        raiseAtlassianEvent: function raiseAtlassianEvent(projectTemplateModuleKey) {
            Config.model.selectedTemplate = projectTemplateModuleKey;
            if (AJS.EventQueue) {
                AJS.EventQueue.push({
                    name: "projecttemplates.templateselected",
                    properties: {
                        selectedTemplate: projectTemplateModuleKey
                    }
                });
            }
        }
    };
    return SelectProjectTemplateController;
});
AJS.namespace('JPT.SelectProjectTemplateController', null, require('jira/project-templates/select-project-template-controller'));
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/CreateSharedView.js' */
// Warning!
// This module has a hidden circular dependency -> jira/project-templates/create-shared-controller
define('jira/project-templates/create-shared-view', [
    'jira/project-templates/dialog-controller',
    'jira/project-templates/dialog-view',
    'jira/ajs/select/scrollable-single-select',
    'jira/ajs/select/suggestion-collection-model',
    'require',
    'backbone',
    'jquery'
], function(
    DialogController,
    DialogView,
    ScrollableSingleSelect,
    SuggestionCollectionModel,
    require,
    Backbone,
    $
){
    "use strict";

    var InlineDialog = AJS.InlineDialog;
    var trigger = AJS.trigger;

    var CreateSharedView = Backbone.View.extend({
        events: {
            "submit #create-shared-project-form": "onSubmitForm"
        },

        page: undefined,

        /**
         * Prepare the Dialog to hold the Create Shared Project form; this should only be called once.
         */
        prepareDialog: function(title) {
            var CreateSharedController = require('jira/project-templates/create-shared-controller');
            this.page = DialogController.addPage({
                name: "create-shared-project",
                title: title,
                panelName: "create-shared-project",
                backButton: true,
                submitButtonText: "Next",
                submitButtonCallback: CreateSharedController.dialogSubmitted,
                submitButtonClass: "create-shared-dialog-button"
            });
        },

        /**
         * Draw the Add Project form into the passed dialog, as a new screen.
         *
         * This will be triggered on clicking "Next", so should render on the second page.
         */
        draw: function(params) {
            DialogController.dialog.gotoPage(this.page.id);

            var createSharedForm = JIRA.Templates.ProjectTemplates.createSharedProjectForm({
                "projectSuggestions": JSON.stringify(params.projectSuggestions)
            });

            DialogController.dialog.getPanel(this.page.id, 0).html(createSharedForm);

            this._createProjectPicker();

            var $sharedHelpElement = DialogController.$dialogElement.find("#shared-help-icon");
            if ($sharedHelpElement.length) {
                new InlineDialog($sharedHelpElement, "shared-project-help-popup",
                        function(contents, trigger, show) {
                            contents.html(JIRA.Templates.ProjectTemplates.sharedHelp());
                            show();
                        }, {
                            width: 330,
                            offsetX: -30
                        });
            }

            DialogController.$dialogElement.find(".dialog-button-panel button").removeAttr("disabled");
        },

        showProjectMissingError: function () {
            this._clearFormErrors();

            this._getProjectPickerInput().after(aui.form.fieldError({
                extraClasses: 'project-picker-missing-error',
                message: "Please select an existing project first."
            }));
        },

        drawEmptyInfo: function() {
            var noProjects = JIRA.Templates.ProjectTemplates.noProjects();
            DialogController.dialog.getPanel(this.page.id, 0).html(noProjects);

            DialogController.$dialogElement.find(".dialog-button-panel button").hide();
        },

        drawError: function(message) {
            DialogController.dialog.getPanel(this.page.id, 0).html(JIRA.Templates.errorMsg({
                closable: false,
                msg: message
            }));
        },

        drawLoading: function() {
            DialogController.dialog.gotoPage(this.page.id);

            var addProjectForm = JIRA.Templates.ProjectTemplates.loading();

            DialogController.dialog.getPanel(this.page.id, 0).html(addProjectForm);

            DialogController.$dialogElement.find(".dialog-spinner").spin();
            DialogController.$dialogElement.find(".dialog-button-panel button").attr("disabled", "disabled");
        },

        _clearFormErrors: function() {
            DialogController.$dialogElement.find(".project-picker-missing-error").remove();
        },

        _getProjectPickerInput: function() {
            return DialogController.$dialogElement.find("#project-picker");
        },

        onSubmitForm: function(e) {
            this._clearFormErrors();
            var CreateSharedController = require('jira/project-templates/create-shared-controller');
            CreateSharedController.dialogSubmitted();
            return false;
        },

        _getExtraInfoMessage: function() {
            return DialogController.$dialogElement.find(".create-shared-info");
        },

        _createProjectPicker: function() {
            this._getExtraInfoMessage().hide();
            this.projectSelect = new ScrollableSingleSelect({
                element: this._getProjectPickerInput(),
                revertOnInvalid: true,
                pageSize: 50,
                pagingThreshold: 100,
                model: SuggestionCollectionModel
            });

            this.projectSelect.$field.focus();

            var self = this;
            this._getProjectPickerInput().on("selected", function(e, selected) {
                if(selected.value()) {
                    trigger('analyticsEvent', {name: 'jira.project.templates.dialog.create.shared.project.selected'});
                    self._getExtraInfoMessage().show();
                }
            });
        },

        getSelectedProject: function() {
            return this.projectSelect.getSelectedDescriptor() && this.projectSelect.getSelectedDescriptor().value();
        }
    });

    return new CreateSharedView({
        el: $(document),
        dialogView: DialogView
    });
});
AJS.namespace('JPT.CreateSharedView', null, require('jira/project-templates/create-shared-view'));
;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/CreateSharedController.js' */
define('jira/project-templates/create-shared-controller-impl', [
    'jira/project-templates/add-project-controller',
    'jira/project-templates/create-shared-view',
    'jira/lib/class',
    'jquery',
    'underscore'
], function(
    AddProjectController,
    CreateSharedView,
    Class,
    $,
    _
) {
    "use strict";

    var contextPath = AJS.contextPath();

    return Class.extend({

        init: function (options) {
            this._window = options.window || window; // used for mocking 'window' in QUnit
            _.bindAll(this, "dialogSubmitted");
        },

        initCreateShared: function () {
            CreateSharedView.prepareDialog("Create with shared configuration");

            var self = this;
            this._getProjectSuggestions().done(function (resp) {
                if (self._hasSuggestions(resp)) {
                    CreateSharedView.draw({projectSuggestions: resp});
                } else {
                    CreateSharedView.drawEmptyInfo();
                }
            }).fail(function () {
                CreateSharedView.drawError("An error occurred while trying to contact JIRA");
            });

            CreateSharedView.drawLoading();
        },

        _hasSuggestions: function (projectSuggestions) {
            var hasSuggestions = false;
            $.each(projectSuggestions, function (i, group) {
                if (group && group.items && group.items.length > 0) {
                    hasSuggestions = true;
                }
            });
            return hasSuggestions;
        },

        _getProjectSuggestions: function () {
            return $.ajax({
                url: contextPath + "/rest/project-templates/1.0/createshared"
            });
        },

        dialogSubmitted: function () {
            var selectedProject = CreateSharedView.getSelectedProject();
            if (selectedProject) {
                AddProjectController.initCreateShared({existingProjectId: selectedProject});
            } else {
                CreateSharedView.showProjectMissingError();
            }
        }
    });
});
define('jira/project-templates/create-shared-controller', [
    'jira/project-templates/create-shared-controller-impl',
    'jquery'
], function(
    CreateSharedControllerImpl,
    $
){
    return new CreateSharedControllerImpl({el: $(document)});
});
AJS.namespace('JPT.CreateSharedController', null, require('jira/project-templates/create-shared-controller'));;
;
/* module-key = 'com.atlassian.jira.project-templates-plugin:project-templates-plugin-resources', location = '/js/RemoteProjectsCreatedMessage.js' */
var $ = require('jquery');
$(function () {

    var format = AJS.format;
    var AddProjectController = require('jira/project-templates/add-project-controller');

    var confluenceProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "confluenceProject");
    var fishEyeProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "fisheyeProject");
    var crucibleProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "crucibleProject");
    var bambooProjectLink = localStorage.getItem(AddProjectController.localStoragePrefix + "bambooProject");

    localStorage.removeItem(AddProjectController.localStoragePrefix + "confluenceProject");
    localStorage.removeItem(AddProjectController.localStoragePrefix + "fisheyeProject");
    localStorage.removeItem(AddProjectController.localStoragePrefix + "crucibleProject");
    localStorage.removeItem(AddProjectController.localStoragePrefix + "bambooProject");

    var message;
    function formatAnchor(link, label) {
        return JIRA.Templates.ProjectTemplates.formatAnchor({
            href: link,
            body: label,
            title: label
        });
    }
    function createProjectLinks(confluenceProjectLink, fecruProjectLink, crucibleProjectLink, bambooProjectLink) {
        var links = [];
        links.push("a JIRA project");
        if (confluenceProjectLink) {
            links.push(formatAnchor(confluenceProjectLink, "a Confluence space"));
        }
        if (fecruProjectLink) {
            links.push(formatAnchor(fecruProjectLink, "a FishEye repository"));
        }
        if (crucibleProjectLink) {
            links.push(formatAnchor(crucibleProjectLink, "a Crucible project"));
        }
        if (bambooProjectLink) {
            links.push(formatAnchor(bambooProjectLink, "a Bamboo project"));
        }
        return links;
    }
    function createMessage(confluenceProjectLink, fecruProjectLink, crucibleProjectLink, bambooProjectLink) {
        var title = "The following entities were created: {0} and {1}.";
        var projectLinks = createProjectLinks(confluenceProjectLink, fecruProjectLink, crucibleProjectLink, bambooProjectLink);
        var lastLink = projectLinks.pop();
        return (projectLinks.length > 0) ? format(title, projectLinks.join(", "), lastLink) : null;
    }
    function scrollTo(selector) {
        var settingsOffset = $(selector).offset();
        if (settingsOffset) {
            window.scrollTo(settingsOffset.left, settingsOffset.top);
        }
    }

    if (confluenceProjectLink || fishEyeProjectLink || crucibleProjectLink || bambooProjectLink) {
        message = createMessage(confluenceProjectLink, fishEyeProjectLink, crucibleProjectLink, bambooProjectLink);
        if (message) {
            JIRA.Messages.showSuccessMsg(message, {
                closeable:true
            });
        }
        scrollTo("#project-config-webpanel-summary-settings");
    }
});;
;
/* module-key = 'com.atlassian.plugins.jira-project-creation:project-creation-resources', location = '/js/lib/ajaxHooks/xdr.js' */
/**
 Copyright 2012 Julian Aubourg <j@ubourg.net>

 https://github.com/jaubourg/ajaxHooks

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
if ( window.XDomainRequest ) {
    jQuery.ajaxTransport(function( s ) {
        if ( s.crossDomain && s.async ) {
            if ( s.timeout ) {
                s.xdrTimeout = s.timeout;
                delete s.timeout;
            }
            var xdr;
            return {
                send: function( _, complete ) {
                    function callback( status, statusText, responses, responseHeaders ) {
                        xdr.onload = xdr.onerror = xdr.ontimeout = jQuery.noop;
                        xdr = undefined;
                        complete( status, statusText, responses, responseHeaders );
                    }
                    xdr = new XDomainRequest();
                    xdr.onload = function() {
                        callback( 200, "OK", { text: xdr.responseText }, "Content-Type: " + xdr.contentType );
                    };
                    xdr.onerror = function() {
                        callback( 404, "Not Found" );
                    };
                    xdr.onprogress = jQuery.noop;
                    xdr.ontimeout = function() {
                        callback( 0, "timeout" );
                    };
                    xdr.timeout = s.xdrTimeout || Number.MAX_VALUE;
                    xdr.open( s.type, s.url );
                    xdr.send( ( s.hasContent && s.data ) || null );
                },
                abort: function() {
                    if ( xdr ) {
                        xdr.onerror = jQuery.noop;
                        xdr.abort();
                    }
                }
            };
        }
    });
};
;
/* module-key = 'com.atlassian.plugins.jira-project-creation:project-creation-resources', location = '/js/project-creation.js' */
ATLAS_PROJECT_CREATE = {};

(function ($) {

    AJS.EventQueue = AJS.EventQueue || [];

    var JIRA_PROJECT_CAPABILITY_KEY = 'jira.project';

    //This will most likely be added to the SPI in future versions
    var CAPABILITY_WEIGHT = {
        "confluence.space" : 30,
        "bamboo.project" : 20,
        "ondemand.svn-repository" : 10
    };

    ATLAS_PROJECT_CREATE.getFilteredRootTypes = function getFilteredRootTypes(response) {
        var types = {};
        for (var key in response.types) {
            if (key !== JIRA_PROJECT_CAPABILITY_KEY) {
                types[key] = response.types[key];
            }
        }
        return types;
    };

    ATLAS_PROJECT_CREATE.loadRemoteRoots = function loadRemoteRoots(capabilities) {
        var deferred = jQuery.Deferred(),
            innerPromises = [],
            rootTypes = [];

        // map each capability to the promise of an ajax call, when they're all done innerpromises will contain an array of promises, one for each
        // inner ajax call made. Once this outer mega-promise is resolved, we can create a new mega-promise out of the contents of innerPromises.
        // Once that mega-promise is resolved we can resolve the outside visible promise (projectCreationPromise), passing in the gathered root types.
        mapToPromise(capabilities,function (capability) {
            var baseUrl = capability.capabilitiesUrl;
            return AJS.$.ajax(baseUrl + '/aggregate-root', {
                success: function (response) {
                    var types = ATLAS_PROJECT_CREATE.getFilteredRootTypes(response);
                    innerPromises = innerPromises.concat(_.map(types, function (type, key) {
                        return AJS.$.ajax(type.href, {
                            xhrFields: {
                                withCredentials: true
                            },
                            success: function (rootType) {
                                rootTypes.push(ATLAS_PROJECT_CREATE.constructFullRootType(rootType, type.label, key, baseUrl, capability.id));
                            },
                            error: function (xhr, status, errorThrown) {
                                AJS.log('Got ' + errorThrown + ' from aggregate root type ' + type.href);
                            }
                        }).promise();
                    }));
                }, error: function (xhr, status, errorThrown) {
                    // TODO ROTP-1146 ROTP-1147: handle 401, 403 better
                    AJS.log('Got ' + errorThrown + ' from aggregate roots capapbility for ' + baseUrl);
                }
            }).promise();
        }).done(function () {
                promiseFromPromiseList(innerPromises).done(function () {
                    deferred.resolve(rootTypes);
                });
            });
        return deferred.promise();
    };

    ATLAS_PROJECT_CREATE.constructFullRootType = function constructFullRootType(rootType, label, capabilityKey, baseUrl, instanceId) {
        return {
            keys: rootType.keys,
            url: rootType.links.self,
            label: label,
            capabilityKey: capabilityKey,
            baseUrl: baseUrl,
            instanceId: instanceId
        };
    };

    ATLAS_PROJECT_CREATE.createLink = function createLink(linkDetails, complete) {
        console.log("creating link from " + linkDetails.entityType + " to " + linkDetails.remoteEntityType);
        var linkRequest = JSON.stringify({
            "local": linkDetails.baseUrl + "/aggregate-root/" + linkDetails.entityType + "/" + linkDetails.entityKey,
            "target": linkDetails.remoteInstanceBaseUrl + "/aggregate-root/" + linkDetails.remoteEntityType + "/" + linkDetails.remoteEntityKey
        });
        AJS.$.ajax(linkDetails.baseUrl + "/aggregate-root-link", {
            type: "POST",
            contentType: "application/json",
            data: linkRequest,
            timeout: 8000,
            complete: complete
        });
    };


    ATLAS_PROJECT_CREATE.linkAllTheThings = function linkAllTheThings(dialog, createdThings, projectKey, projectCreationPage, acknowledgeButton) {

        var linksToCreate = [];
        $.each(createdThings, function createLinks(idx, entity) {
            linksToCreate.push({
                baseUrl: entity.type.baseUrl,
                entityType: entity.type.capabilityKey,
                entityKey: entity.data.key,
                remoteInstanceBaseUrl: getAppBaseUrl() + "/rest/capabilities",
                remoteEntityType: JIRA_PROJECT_CAPABILITY_KEY,
                remoteEntityKey: projectKey
            });

            linksToCreate.push({
                baseUrl: getAppBaseUrl() + "/rest/capabilities",
                entityType: JIRA_PROJECT_CAPABILITY_KEY,
                entityKey: projectKey,
                remoteInstanceBaseUrl: entity.type.baseUrl,
                remoteEntityType: entity.type.capabilityKey,
                remoteEntityKey: entity.data.key
            });

            AJS.$.each(createdThings, function createLinkBetweenRemoteEntities(targetIdx, targetEntity) {
                //first check we are not trying to link something to itself or something else in the same instance
                if (targetEntity !== entity) {
                    linksToCreate.push({
                        baseUrl: entity.type.baseUrl,
                        entityType: entity.type.capabilityKey,
                        entityKey: entity.data.key,
                        remoteInstanceBaseUrl: targetEntity.type.baseUrl,
                        remoteEntityType: targetEntity.type.capabilityKey,
                        remoteEntityKey: targetEntity.data.key
                    });
                }
            });
        });

        //TODO ROTP-992 : Doesn't need to be serialized once applinks fixes up race condition
        var numErrors = 0;

        function createNext(xhr, status) {
            if (status !== "success") {
                numErrors++;
                // render the error message
                var errorMessage = xhr.statusText;
                try {
                    var data = JSON.parse(xhr.responseText);
                    if (data && data.message) {
                        errorMessage = data.message;
                    }
                } catch (err) {

                }
                AJS.messages.error(".li-linking-status", {
                    title: "Could not create links between created projects",
                    body: errorMessage
                });
                dialog.updateHeight();
            }
            if (linksToCreate.length > 0) {
                ATLAS_PROJECT_CREATE.createLink(linksToCreate.pop(), createNext);
            } else {
                if (numErrors > 0) {
                    projectCreationPage.find(".linking-status").html('<span class="aui-icon aui-icon-small aui-iconfont-error">' + "Error" + '</span>');
                } else {
                    projectCreationPage.find(".linking-status").html('<span class="aui-icon aui-icon-small aui-iconfont-success">' + "Success" + '</span>');
                }
                acknowledgeButton.prop("disabled", false);
                acknowledgeButton.attr('aria-disabled', 'false');
            }
        }

        createNext(null, "success");
    };

    var remoteRootsPromise;

    function bindRemoteRootsPromise(promise, getDialog, onCheckboxChange) {
        var dialog = getDialog();
        $.when(promise).then(
            // success handler
            function (types) {
                dialog.getCurPanel().body.find('.field-group.loading').remove();

                types.sort(sortCapabilities);
                if (types.length !== 0) {
                    var projectCreateForm = dialog.getCurPanel().body.find('form');
                    projectCreateForm.append(project.creation.remoteRootsCheckboxes({rootTypes: types}));
                    if (onCheckboxChange) {
                        projectCreateForm.find('input[type="checkbox"]').filter('.remote-root').change(onCheckboxChange);
                    }

                    dialog.updateHeight();
                }

                enableSubmitBtn(dialog, true);
            },
            // fail handler
            function () {
                dialog.getCurPanel().body.find('.field-group.loading').remove();
                enableSubmitBtn(dialog, true);
                dialog.updateHeight();
                // the provided promise only ever resolves. This shouldn't happen, but if something explodes it should
                // be enough to just revert back to default JIRA behaviour.
            }
        );
    }

    var panel;

    function setupProjectCreationIntegration(getDialog, onCheckboxChange) {
        var dialog = getDialog();
        //Store a ref to the panel for use in some promises
        panel = dialog.getCurPanel();
        // Attach some info and a spinner below Project Create name & key entry
        panel.body.find('form').append(project.creation.remoteRootsLoading({}));

        enableSubmitBtn(dialog, false);
        dialog.updateHeight();

        //Make sure the height is good again when the user hits back
        panel.page.element.find(".add-project-back-button").click(function() {
            dialog.updateHeight();
        });


        initRemoteRoots(bindRemoteRootsPromise, getDialog, onCheckboxChange);
    }

    function getSelectedTypes(types) {
        var selectedCheckboxes = _.filter(panel.body.find("input.remote-root.checkbox"), function (checkbox) {
            return checkbox.checked === true;
        });
        var selectedTypeIds = _.map(selectedCheckboxes,
            function (input) {
                return input.id;
            });
        return _.filter(types, function (type) {
            return _.contains(selectedTypeIds, 'capability_' + type.capabilityKey);
        });
    }

    var userMetaTag = AJS.$('meta[name="ajs-remote-user"]');
    // if we neither got a user tag, or it had no content then bail out.
    if (!userMetaTag || !userMetaTag[0] || !userMetaTag[0].content) {
        console.log("Project create didn't get a user META tag, or it had no content.  Bailing out");
        return;
    }

    // if the dark feature is disabled, return here.
    if (!AJS.DarkFeatures.isEnabled("rotp.project.create")) {
        return;
    }

    var postProjectCreationCallback = function postProjectCreationCallback(dialog, redirectFn, projectId, projectKey, projectName) {
        var callRedirectFn = function callRedirectFn(redirectFn, acknowledgeButton) {
            acknowledgeButton.prop("disabled", true);
            acknowledgeButton.attr('aria-disabled', 'true');
            acknowledgeButton.before('<span class="aui-icon aui-icon-wait project-creation-acknowledge-spinner">' + "Loading, please wait" + '</span>');
            redirectFn();
        };

        $.when(remoteRootsPromise).then(
            function (types) {
                var selectedTypes = getSelectedTypes(types);
                sendAnalytics(selectedTypes);

                if (selectedTypes.length === 0) {
                    //Make sure we don't show empty next page which is the default of project templates
                    dialog.prevPage();
                    redirectFn();
                    return;
                }

                createProjectCreationResultPanel(dialog, callRedirectFn, redirectFn);

                var templateData = [];
                var createdThings = [];
                mapToPromise(selectedTypes, function (type) {
                    var statusId = "creation_status_" + type.capabilityKey.replace(".", "_") + "_" + type.instanceId;
                    templateData.push({
                        statusId: statusId,
                        label: type.label
                    });

                    return AJS.$.ajax(type.url + "/" + projectKey, {
                        type: "PUT",
                        data: JSON.stringify({
                            label: projectName
                        }),
                        xhrFields: {
                            withCredentials: true
                        },
                        success: function (data) {
                            createdThings = createdThings.concat(processCreatedRoots(data, type));
                            renderCreatedRoots(data, statusId);
                        },
                        error: function (xhr, textStatus, errorThrown) {
                            renderErrorDuringRootCreation(statusId, type, xhr, errorThrown);
                        },
                        contentType: "application/json",
                        dataType: "json"
                    }).promise();
                }).always(function () {
                    renderErrorHeaderInCaseOfErrors(dialog);
                    console.log("about to begin linking created objects");
                    ATLAS_PROJECT_CREATE.linkAllTheThings(dialog,
                                                            createdThings,
                                                            projectKey,
                                                            AJS.$(".post-project-created-page-content"),
                                                            AJS.$(".project-create-acknowledge-button"));
                });

                AJS.$(".post-project-created-page-content").append(project.creation.remoteRootsSuccess({rootTypes: templateData}));
            }
        );
    };


    var checkIfKeyExists = function checkIfKeyExists(projectKey) {
        var duplicateFound;
        $.when(remoteRootsPromise).then(
            function (types) {
                var selectedTypes = getSelectedTypes(types);
                _.each(selectedTypes, function (type) {
                    if (type.keys) {
                        for (var key in type.keys) {
                            if (type.keys.hasOwnProperty(key)) {
                                if (projectKey.toUpperCase() === key.toUpperCase()) {
                                    duplicateFound = type;
                                }
                            }
                        }
                    }
                });
            });
        var response = {errors: {}};
        if (duplicateFound) {
            response.errors.projectKey = AJS.format("{0} with that key already exists in the remote instance", duplicateFound.label);
        }
        return response;
    };


    function getOrigin() {
        return window.location.origin ? window.location.origin : (window.location.protocol + '//' + window.location.host);
    }

    function getAppBaseUrl() {
        var baseUrl = getOrigin();
        return baseUrl + AJS.contextPath();
    }

    /**
     * Parse and return some components of a URL.
     * @param {string} url A URL, e.g. "http://google.com:80/a/b/c"
     * @returns {{host: string, protocol: string, port: string}}
     */
    function parseUrl(url) {
        var a = document.createElement('a');
        a.href = url;
        return {
            host: a.hostname,
            port: a.port,
            protocol: a.protocol.replace(':', '')
        };
    }

    /**
     * Determine if making a request from one URL to another would represent a security downgrade, and
     * as such be blocked by the browser.
     *
     * @param {string} origin The URL from which a request to *destination* is to be made.
     * @param {string} destination The destination URL.
     * @returns {boolean} true if origin uses https: and destination uses http:
     */
    function isSecurityDowngrade(origin, destination) {
        var aParts = parseUrl(origin);
        var bParts = parseUrl(destination);
        return aParts.protocol === "https" && bParts.protocol === "http";
    }

    function initRemoteRoots(fn, getDialog, onCheckboxChange) {
        AJS.$.ajax(getAppBaseUrl() + '/rest/capabilities/awareness', {
            type: "GET",

            /**
             * @param {{applications: object, links: {selfInstanceId: string} }} data
             */
            success: function parseAwarenessResponse(data) {
                // We need to be careful with what requests we make. Making a request from a HTTPS page to a HTTP
                // page will be blocked by the browser and will only fail after the timeout period has elapsed.
                var willTimeout = _.partial(isSecurityDowngrade, getOrigin());
                var capabilities = _
                    .chain(data.applications)
                    .map(function (details, url) {
                        return _.extend(details, {capabilitiesUrl: url});
                    })
                    .filter(function (details) {
                        return willTimeout(details.capabilitiesUrl) === false;
                    })
                    .value();

                //push an object in to gather any local capabilities
                capabilities.push({
                    id: data.links.selfInstanceId,
                    capabilitiesUrl: data.links.collection
                });

                remoteRootsPromise = ATLAS_PROJECT_CREATE.loadRemoteRoots(capabilities);
                selfInstanceId = data.links.selfInstanceId;
                if (typeof fn === 'function') {
                    fn(remoteRootsPromise, getDialog, onCheckboxChange);
                }
            },
            error: function (xhr, status, errorThrown) {
                // log & revert to vanilla JIRA behaviour.
                console.log("Project create error - error gathering roots from awareness capability");
                if (getDialog) {
                    $(getDialog().getCurPanel().page.element).find(".pt-submit-button").attr('aria-disabled', 'false');
                }
            }
        });
    }


    var selfInstanceId;
    var odFecruAwareness = null;

    // given a list<X> and a function fn : X -> promise returns a promise composed
    // of all the promises returned by applying fn to members of list
    function mapToPromise(list, fn) {
        var promises = _.map(list, fn);
        return promiseFromPromiseList(promises);
    }

    // given a list of promises, construct a new promise which fires done when all proivded promises have either been resolved or rejected.
    // NOTE: can not just be return $.when.apply(promises).promise() because that would reject when the first internal promise is rejected,
    // whereas we want the promise to fire after all are completed.
    // Again, NOTE: resolution of the returned promise will be empty. This should only be used when you want flow control,
    // data access should be by other means (or wrapped around one of these).
    function promiseFromPromiseList(promises) {
        var deferred = $.Deferred();
        var resolutionCount = 0;
        if (promises.length === 0) {
            deferred.resolve();
        } else {
            _.each(promises, function (promise) {
                promise.always(function () {
                    resolutionCount++;
                    if (resolutionCount === promises.length) {
                        deferred.resolve();
                    }
                });
            });
        }
        return deferred.promise();
    }

    function createProjectCreationResultPanel(dialog, callRedirectFn, redirectFn) {
        dialog.addPanel("title", "", "post-project-created-page-content");
        dialog.addHeader("Creating and linking companions for your JIRA project");
        dialog.addButton("All done!", function () {
            callRedirectFn(redirectFn, AJS.$(this));
        }, "project-create-acknowledge-button");

        AJS.$(".project-create-acknowledge-button").removeClass("button-panel-button")
            .addClass("aui-button aui-button-primary")
            .attr('aria-disabled', 'true')
            .prop('disabled', true);
    }

    function processCreatedRoots(data, type) {
        var createdThings = [];
        if (type.capabilityKey === "ondemand.svn-repository") {
            // TODO: Remove this special case when FeCru is removed from OnDemand
            // this is a hack to handle the fact that SVN repositories
            // are being created in JIRA.
            console.log("got back created SVN repository");
            createdThings.push({
                type: {
                    capabilityKey: "fecru.repository",
                    instanceId: odFecruAwareness.id,
                    baseUrl: odFecruAwareness.capabilitiesUrl
                },
                data: {
                    key: data.key
                }
            });
            createdThings.push({
                type: {
                    capabilityKey: "fecru.project",
                    instanceId: odFecruAwareness.id,
                    baseUrl: odFecruAwareness.capabilitiesUrl
                },
                data: {
                    key: "CR-" + data.key
                }
            });
        } else {
            console.log("got back created thing " + type.capabilityKey);
            var createdThing = {
                type: type,
                data: data
            };
            createdThings.push(createdThing);
        }

        return createdThings;
    }

    function renderCreatedRoots(data, statusId) {
        var statusBlock = AJS.$("." + statusId);
        statusBlock.empty(); //remove spinner
        statusBlock.append('<span class="aui-icon aui-icon-small aui-iconfont-success">' + "Success" + '</span>');
        if (data.links.resource) {
            var link = AJS.$("<a target='_blank'></a>");
            link.text(data.label);
            link.attr("href",data.links.resource);
            link.attr("title",data.label);
            statusBlock.closest('li').append(link);
        }
    }

    function renderErrorDuringRootCreation(statusId, type, xhr, errorThrown) {
        var statusBlock = AJS.$("." + statusId);
        statusBlock.empty(); //remove spinner
        statusBlock.append('<span class="aui-icon aui-icon-small aui-iconfont-error">' + "Error" + '</span>');
        var errorMessage = errorThrown;
        if (xhr && xhr.responseText) {
            try {
                var data = JSON.parse(xhr.responseText);
                if (data && data.message) {
                    errorMessage = data.message;
                }
            } catch (err) {
                // swallow syntax error if response is not valid JSON and display the response text as error
                errorMessage = xhr.responseText;
            }
        }

        AJS.messages.error(".li-" + statusId, {
            title: AJS.format("Could not create {0}", type.label),
            body: errorMessage
        });
    }

    function renderErrorHeaderInCaseOfErrors(dialog) {
        // if we have any errors, add a helpful message
        var currentPanel = dialog.getCurrentPanel();
        if (currentPanel.body.find('.aui-message.error').size() !== 0) {
            AJS.messages.warning('.project-creation-success', {
                title: "We were unable to create everything you requested",
                body: '<p>' + "However, you can create them yourself and manually set up links." + '</p>'
            });

            dialog.updateHeight();
        }
    }

    function sendAnalytics(selectedTypes) {
        var capabilityKeys = _.map(selectedTypes, function (type) { return type.capabilityKey;});
        var analyticsValue = (capabilityKeys.length == 0) ? "none" : capabilityKeys.sort().join('_');

        AJS.EventQueue.push({name: 'project.create.aggregateroots.selected', properties: {capabilitykeys: analyticsValue}});
    }

    function enableSubmitBtn(dialog, enabled) {
        $(dialog.getCurPanel().page.element).find(".pt-submit-button").attr('aria-disabled', !enabled);
    }

    function sortCapabilities(capabilityA, capabilityB) {
        return getCapabilityWeight(capabilityB.capabilityKey) - getCapabilityWeight(capabilityA.capabilityKey);
    }

    function getCapabilityWeight(capabilityKey) {
        return _.has(CAPABILITY_WEIGHT, capabilityKey) ? CAPABILITY_WEIGHT[capabilityKey] : 0;
    }



    JPT.AddProjectController.registerProjectKeyValidationCallback(checkIfKeyExists);

    var getJptDialog = function getJptDialog() {
        return JPT.DialogView.dialog || JPT.DialogView._dialog;
    };
    var onJptCheckboxChange = function onJptCheckboxChange() {
        if (JPT.AddProjectView.getKey().length >= 2) {
            JPT.AddProjectController._performKeyValidationChecks(JPT.AddProjectView.getKey());
        }
    };

    JPT.AddProjectView.addPostDrawCallback(function () {
        setupProjectCreationIntegration(getJptDialog, onJptCheckboxChange);
    });

    JPT.AddProjectController.registerPostProjectCreationCallback(function (dialog, returnUrl, projectId, projectKey, projectName) {
        var redirectFn = function() {
            window.location = AJS.contextPath() + returnUrl;
        };
        postProjectCreationCallback(dialog, redirectFn, projectId, projectKey, projectName);
    });

    // Embed project create in Greenhopper project create flow
    // (But only in flow creating a JIRA project at the same time)
    var registerGhCallbacks = function registerGhCallbacks() {
        var GH_PROJECT_CREATION_STEP = "projectCreation";
        GH.StartWizardView.registerWizardStepPreRenderCallback(function ghProjectCreateSetup(stepName) {
            if (stepName == GH_PROJECT_CREATION_STEP) {
                initRemoteRoots();

                GH.StartWizardView.registerWizardStepOnCreateCallbacks(function ghProjectCreageCallback(dialog, executeNextCallback, model) {
                    console.log("creating external entities");
                    dialog.addPage("post-project-created-page");
                    postProjectCreationCallback(dialog, executeNextCallback, null, model.project.key, model.project.name);
                });
            }
        });
        GH.StartWizardView.registerWizardStepPostRenderCallback(function renderGhProjectCheckboxes(stepName, dialog) {
            if (stepName == GH_PROJECT_CREATION_STEP) {
                setupProjectCreationIntegration(function getGhDialog() {
                    return dialog;
                });
                dialog.updateHeight();
            }
        });
        GH.StartWizardView.registerWizardStepOnValidateCallback(function validateProjectKey(stepName, dialog) {
            if (stepName == GH_PROJECT_CREATION_STEP) {
                var $keyInput = dialog.getCurPanel().body.find("#ghx-wizard-project-projectkey");
                var keyExistsResponse = checkIfKeyExists($keyInput.val());
                if (keyExistsResponse.errors.projectKey) {
                    var $errorElement = AJS.$("<div class='error project-creation-error'></div>");
                    var parent = $keyInput.parent();
                    parent.find(".project-creation-error").remove();
                    parent.append($errorElement);
                    $errorElement.text(keyExistsResponse.errors.projectKey);
                    $errorElement.show();
                    return false;
                }
            }
            return true;
        });
    };

    $(function() {

        // Embed project create in JIRA project templates dialog
        // on clicking the project create link, we want to start gathering our capabilities
        AJS.$('.add-project-trigger').live('click', initRemoteRoots);

        // check if Greenhopper is available and that it is a version which has support for the required
        // callbacks.  If so, register greenhopper callbacks
        if (typeof GH !== 'undefined') {
            if (GH.StartWizardView && GH.StartWizardView.registerWizardStepPreRenderCallback) {
                // GH has support for the required callbacks....
                registerGhCallbacks();
            }
        }
    });

    // Embed project create in JIRA project templates dialog
    // on clicking the project create link, we want to start gathering our capabilities
    $(function () {
        AJS.$('.add-project-trigger').live('click', initRemoteRoots);
    });


})(jQuery);
;
;
/* module-key = 'com.atlassian.plugins.jira-project-creation:project-creation-resources', location = '/templates/project-creation.soy' */
// This file was automatically generated from project-creation.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace project.creation.
 */

if (typeof project == 'undefined') { var project = {}; }
if (typeof project.creation == 'undefined') { project.creation = {}; }


project.creation.remoteRootsLoading = function(opt_data, opt_ignored) {
  return '<div class="field-group loading"><span class="aui-icon aui-icon-wait"/>' + soy.$$escapeHtml("Retrieving additional project types you might want to create") + '</div>';
};
if (goog.DEBUG) {
  project.creation.remoteRootsLoading.soyTemplateName = 'project.creation.remoteRootsLoading';
}


project.creation.remoteRootsCheckboxes = function(opt_data, opt_ignored) {
  var output = '<fieldset class="group remote-root-checkboxes"><h4>' + soy.$$escapeHtml("Create a linked:") + '</h4><div class=\'field-group\'>';
  var rootTypeList10 = opt_data.rootTypes;
  var rootTypeListLen10 = rootTypeList10.length;
  for (var rootTypeIndex10 = 0; rootTypeIndex10 < rootTypeListLen10; rootTypeIndex10++) {
    var rootTypeData10 = rootTypeList10[rootTypeIndex10];
    output += '<div class="checkbox"><input class="checkbox remote-root" type="checkbox" id="capability_' + soy.$$escapeHtml(rootTypeData10.capabilityKey) + '" checked="true" data-url="' + soy.$$escapeHtml(rootTypeData10.url) + '"></input><label for="capability_' + soy.$$escapeHtml(rootTypeData10.capabilityKey) + '">' + soy.$$escapeHtml(rootTypeData10.label) + '</label></div>';
  }
  output += '</div></fieldset>';
  return output;
};
if (goog.DEBUG) {
  project.creation.remoteRootsCheckboxes.soyTemplateName = 'project.creation.remoteRootsCheckboxes';
}


project.creation.remoteRootsSuccess = function(opt_data, opt_ignored) {
  var output = '<div class="project-creation-success"><ul>';
  var rootTypeList24 = opt_data.rootTypes;
  var rootTypeListLen24 = rootTypeList24.length;
  for (var rootTypeIndex24 = 0; rootTypeIndex24 < rootTypeListLen24; rootTypeIndex24++) {
    var rootTypeData24 = rootTypeList24[rootTypeIndex24];
    output += '<li class="li-' + soy.$$escapeHtml(rootTypeData24.statusId) + '"><div class="' + soy.$$escapeHtml(rootTypeData24.statusId) + ' created-entity-status"><span class="aui-icon aui-icon-wait">' + soy.$$escapeHtml("Loading, please wait") + '</span></div><div class="created-entity-status">' + soy.$$escapeHtml(rootTypeData24.label) + '</div></li>';
  }
  output += '<li class="li-linking-status"><div class="linking-status created-entity-status"><span class="aui-icon aui-icon-wait">' + soy.$$escapeHtml("Loading, please wait") + '</span></div><div class="created-entity-status">' + soy.$$escapeHtml("Creating links") + '</div></li></ul></div>';
  return output;
};
if (goog.DEBUG) {
  project.creation.remoteRootsSuccess.soyTemplateName = 'project.creation.remoteRootsSuccess';
}
;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/store-1.3.1.js' */
/* Copyright (c) 2010-2012 Marcus Westin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function(){
	var store = {},
		win = window,
		doc = win.document,
		localStorageName = 'localStorage',
		globalStorageName = 'globalStorage',
		namespace = '__storejs__',
		storage;

	store.disabled = false;
	store.set = function(key, value) {};
	store.get = function(key) {};
	store.remove = function(key) {};
	store.clear = function() {};
	store.transact = function(key, transactionFn) {
		var val = store.get(key);
		if (typeof val == 'undefined') { val = {} }
		transactionFn(val);
		store.set(key, val);
	};

	store.serialize = function(value) {
		return JSON.stringify(value);
	};
	store.deserialize = function(value) {
		if (typeof value != 'string') { return undefined }
		return JSON.parse(value);
	};

	// Functions to encapsulate questionable FireFox 3.6.13 behavior 
	// when about.config::dom.storage.enabled === false
	// See https://github.com/marcuswestin/store.js/issues#issue/13
	function isLocalStorageNameSupported() {
		try { return (localStorageName in win && win[localStorageName]); }
		catch(err) { return false; }
	}
	
	function isGlobalStorageNameSupported() {
		try { return (globalStorageName in win && win[globalStorageName] && win[globalStorageName][win.location.hostname]); }
		catch(err) { return false; }
	}	

	if (isLocalStorageNameSupported()) {
		storage = win[localStorageName];
		store.set = function(key, val) {
			if (val === undefined) { return store.remove(key); }
			storage.setItem(key, store.serialize(val));
		};
		store.get = function(key) { return store.deserialize(storage.getItem(key)); };
		store.remove = function(key) { storage.removeItem(key); };
		store.clear = function() { storage.clear(); };

	} else if (isGlobalStorageNameSupported()) {
		storage = win[globalStorageName][win.location.hostname];
		store.set = function(key, val) {
			if (val === undefined) { return store.remove(key); }
			storage[key] = store.serialize(val);
		};
		store.get = function(key) { return store.deserialize(storage[key] && storage[key].value); };
		store.remove = function(key) { delete storage[key]; };
		store.clear = function() { for (var key in storage ) { delete storage[key]; } };

	} else if (doc.documentElement.addBehavior) {
		var storageOwner,
			storageContainer;
		// Since #userData storage applies only to specific paths, we need to
		// somehow link our data to a specific path.  We choose /favicon.ico
		// as a pretty safe option, since all browsers already make a request to
		// this URL anyway and being a 404 will not hurt us here.  We wrap an
		// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
		// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
		// since the iframe access rules appear to allow direct access and
		// manipulation of the document element, even for a 404 page.  This
		// document can be used instead of the current document (which would
		// have been limited to the current path) to perform #userData storage.
		try {
			storageContainer = new ActiveXObject('htmlfile');
			storageContainer.open();
			storageContainer.write('<s' + 'cript>document.w=window</s' + 'cript><iframe src="/favicon.ico"></frame>');
			storageContainer.close();
			storageOwner = storageContainer.w.frames[0].document;
			storage = storageOwner.createElement('div');
		} catch(e) {
			// somehow ActiveXObject instantiation failed (perhaps some special
			// security settings or otherwse), fall back to per-path storage
			storage = doc.createElement('div');
			storageOwner = doc.body;
		}
		function withIEStorage(storeFunction) {
			return function() {
				var args = Array.prototype.slice.call(arguments, 0);
				args.unshift(storage);
				// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
				// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
				storageOwner.appendChild(storage);
				storage.addBehavior('#default#userData');
				storage.load(localStorageName);
				var result = storeFunction.apply(store, args);
				storageOwner.removeChild(storage);
				return result;
			}
		}
		store.set = withIEStorage(function(storage, key, val) {
			if (val === undefined) { return store.remove(key) }
			storage.setAttribute(key, store.serialize(val));
			storage.save(localStorageName);
		});
		store.get = withIEStorage(function(storage, key) {
			return store.deserialize(storage.getAttribute(key));
		});
		store.remove = withIEStorage(function(storage, key) {
			storage.removeAttribute(key);
			storage.save(localStorageName);
		});
		store.clear = withIEStorage(function(storage) {
			var attributes = storage.XMLDocument.documentElement.attributes;
			storage.load(localStorageName);
			for (var i=0, attr; attr = attributes[i]; i++) {
				storage.removeAttribute(attr.name);
			}
			storage.save(localStorageName);
		});
	}
	
	try {
		store.set(namespace, namespace);
		if (store.get(namespace) != namespace) { store.disabled = true; }
		store.remove(namespace);
	} catch(e) {
		store.disabled = true;
	}
	
	if (typeof module != 'undefined') { module.exports = store; }
	else if (typeof define === 'function' && define.amd) { define(store); }
	else { this.store = store; }
})();;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/page-visibility.js' */
define('atlassian/analytics/page-visibility', function () {
    var hasBrowserSupport = (document.hidden !== undefined);

    /**
     * A partial wrapper for the Page Visibility API
     * @exports atlassian/analytics/page-visibility
     */
    var wrapper = {

        /** Is the API supported by the browser? */
        supported: hasBrowserSupport,

        /**
         * A proxy for `document.hidden`.
         * Defaults to false if the API is not supported by the browser
         * @returns {boolean}
         */
        isHidden: function () {
            return hasBrowserSupport ? document.hidden : false;
        }
    };

    return wrapper;
});;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/user-activity-xhr-header.js' */
/**
 * Provides overrides that add a custom HTTP header to XHR and fetch requests
 * to make MAU User Activity event tracking easier by identifying requests
 * from inactive tabs/windows
 *
 * @module atlassian/analytics/user-activity-xhr-header
 *
 * @see module:atlassian/analytics/page-visibility
 */
define('atlassian/analytics/user-activity-xhr-header', ['atlassian/analytics/page-visibility'], function (pageVisibility) {

    var ACTIVITY_IGNORE_HEADER = 'x-atlassian-mau-ignore';

    // Store native xhr and fetch methods
    var oldSend = XMLHttpRequest.prototype.send;
    var oldFetch = window.fetch;

    var _installed = false;

    return /** @alias module:atlassian/analytics/user-activity-xhr-header */ {
        /**
         * Install global overrides to XHR send and fetch methods to add a
         * custom HTTP header that makes MAU User Activity event tracking
         * easier by identifying requests from inactive tabs/windows
         */
        install: function () {
            // Only install if the override is not already installed
            // and if the browser supports the Page Visibility API
            if (!_installed && pageVisibility.supported) {

                // Override the native send()
                XMLHttpRequest.prototype.send = function () {
                    if (pageVisibility.isHidden()) {
                        this.setRequestHeader(ACTIVITY_IGNORE_HEADER, pageVisibility.isHidden());
                    }
                    oldSend.apply(this, arguments);
                };

                // Override the native fetch() if it exists
                if (oldFetch) {
                    window.fetch = function (input, init) {
                        var augmentedInit = init || {};
                        var headers = augmentedInit.headers;

                        if (pageVisibility.isHidden()) {
                            augmentedInit.headers = (headers) ? new Headers(headers) : new Headers();
                            augmentedInit.headers.append(ACTIVITY_IGNORE_HEADER, pageVisibility.isHidden());
                        }

                        return oldFetch.call(this, input, augmentedInit);
                    };
                }

                _installed = true;
            }
        },

        /**
         * Restore native XHR send and fetch methods
         */
        uninstall: function () {
            if (_installed) {
                XMLHttpRequest.prototype.send = oldSend;
                if (oldFetch) {
                    window.fetch = oldFetch;
                }
            }
            _installed = false;
        }
    };

});

require('atlassian/analytics/user-activity-xhr-header').install();;
;
/* module-key = 'com.atlassian.analytics.analytics-client:js-events', location = 'js/atlassian-analytics.js' */
(function ($) {
    // Make sure we are getting the jQuery.ajax method, even if it has been overridden elsewhere.
    // This will only work if this code is executed before any code which overrides the ajax method.
    var $ajax = AJS.$.ajax;
    var baseStorageKey = 'atlassian-analytics';
    var contextPath =
        typeof AJS.contextPath == "function" ? AJS.contextPath() :
        typeof AJS.Confluence != "undefined" ? AJS.Confluence.getContextPath() :
        window.contextPath != null ? window.contextPath : "";

    var publish = null;
    var storageKey = null;
    var lockKey = null;

    // A unique identifier for this browser tab
    // Source: http://stackoverflow.com/a/2117523
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
    });

    var determineStorageKey = function(){
        // We need to give each product it's own key for events because in ondemand multiple product live
        // at the same url.
        var product = 'unknown';
        if (document.body.id == 'jira'){
            product = 'jira';
        }
        else if (document.body.id == 'com-atlassian-confluence'){
            product = 'confluence';
        }
        storageKey = baseStorageKey + '.' + product;
        lockKey = storageKey + '.lock';
    };

    var getLock = function() {
        if (store.get(lockKey)) {
            return false;
        }

        store.set(lockKey, uuid);

        // Reduce chance of race condition - read back lock to make sure we still have it
        return (store.get(lockKey) === uuid);
    };

    var releaseLock = function() {
        store.set(lockKey, null);
    };

    /**
     * Persists the events that have been generated until such time that they can be sent.
     */
    var saveForLater = function() {
        var events = [],
            event,
            e, i, ii;
        if (AJS.EventQueue.length == 0)
            return;
        // Prime our events array with anything that's already saved.
        events = store.get(storageKey) || events;
        // Suck the events out of the event queue and in to our events array.
        for (i = 0, ii = AJS.EventQueue.length; i < ii; ++i) {
            e = AJS.EventQueue[i];
            if (e.name) {
                // the queue could contain anything - shear unusable properties
                event = { name: e.name, properties: e.properties, time: e.time || 0};
                events.push(event);
            }
        }
        // Empty the event queue
        AJS.EventQueue.length = 0;
        // Save our events for later
        store.set(storageKey, events);
    };

    // Variable to track the number of retries to publish
    var bulkPublishRetryCount = 0;

    /**
     * Gets the amount of time that should be waited until the next publish attempt.
     * @param retryCount How many requests failed since the last successful publish.
     * @returns {number} how many ms that should be waited.
     */
    var getBulkPublishBackoff = function (retryCount) {
        return Math.min(5000 * Math.pow(2, retryCount), 5*60*1000);
    };

    /**
     * Publishes every event that's ready for publishing.
     */
    var bulkPublish = function() {
        var events;

        function reschedule() {
            setTimeout(bulkPublish, getBulkPublishBackoff(bulkPublishRetryCount = 0));
        }

        function rescheduleFailed() {
            setTimeout(bulkPublish, getBulkPublishBackoff(++bulkPublishRetryCount));
        }

        // Avoid multiple browser tabs hitting this all at once
        if (!getLock()) {
            return reschedule();
        }

        // Make sure every event we might have is stored.
        saveForLater();
        // Pull the stored events out and get 'em ready for transmission.
        events = store.get(storageKey);

        if (!events || !events.length) {
            releaseLock();
            return reschedule();
        }

        // Wipe the stored events.
        store.remove(storageKey);

        releaseLock();

        // Validate events and remove any dodgy ones
        if (!validateEvents(events)) {
            return reschedule();
        }

        // try to present a rough timing of events that the server can interpret relative to it's own time.
        var currentTime = new Date().getTime();
        for (var i = 0; i < events.length; i++){
            if (events[i].time > 0){
                events[i].timeDelta = events[i].time - currentTime;
            }
            else{
                // just fake it. This corresponds to a millisecond for each place behind last in the array.
                // This should be rare. Basically, events added to EventQueue before this script was loaded.
                events[i].timeDelta = i - events.length;
            }
            delete events[i].time;
        }

        // AJS.safe.post appears to corrupt a JSON data object, so we send it as a context param instead.
        // Failing to JSON encode the data results in jQuery not attempting to send, and silently swallowing our attempt
        publish = $ajax({
            type: "POST",
            url: contextPath + "/rest/analytics/1.0/publish/bulk",
            data: JSON.stringify(events),
            contentType: "application/json",
            dataType: "json"
        });
        // In case the transmission fails, let's keep the events we just attempted to send.
        publish.fail(function() {
            // This actually drops events, but the alternative is to use something like:
            //   $.merge(AJS.EventQueue, events);
            // Unfortunately using that will cause some fairly nasty issues where duplicate events continually
            // get sent - see https://jira.atlassian.com/browse/AA-179 for more details.
            // TODO: investigate why the above happens and fix this functionality for good
            AJS.EventQueue.concat(events);

            saveForLater();
            rescheduleFailed();
        });
        publish.done(function () {
            reschedule();
        });
    };

    /**
     * Check for any invalid events and remove/sanitise them.
     * @param events - the list of events to be published
     * @returns the number of valid events remaining
     */
    var validateEvents = function(events) {
        for (var i = events.length - 1; i >= 0; i--) {
            var validMsg = "";
            var event = events[i];
            var properties = event.properties;
            if (typeof event.name === "undefined") {
                validMsg = "you must provide a name for the event.";
            } else if (typeof properties !== "undefined" && properties !== null) {
                if (properties.constructor !== Object) {
                    validMsg = "properties must be an object with key value pairs.";
                } else {
                    sanitiseProperties(properties);
                }
            }
            if (validMsg !== "") {
                AJS.log("WARN: Invalid analytics event detected and ignored, " + validMsg + "\nEvent: "+JSON.stringify(event));
                events.splice(i, 1);
            }
        }
        return events.length;
    };

    var sanitiseProperties = function(properties) {
        for (var propertyName in properties) {
            if (properties.hasOwnProperty(propertyName)) {
                var propertyValue = properties[propertyName];
                if (typeof propertyValue !== "undefined" && propertyValue !== null && propertyValue.toString) {
                    // Sanitise the property value by invoking its "toString"
                    properties[propertyName] = propertyValue.toString();
                } else {
                    // If it's an undefined, null or invalid value - blank it out
                    properties[propertyName] = "";
                }
            }
        }
    };

    var cancelPublish = function() {
        if (publish && !(publish.state() === "resolved" || publish.state() === "rejected")) {
            publish.abort(); // This will cancel the request to the server, and cause the events to be saved for later.
        }
    };

    /**
     * Provides a way to publish events asynchronously, without requiring AJS.Events to have loaded.
     * Users of this property must conditionally initialise it to an empty array. Objects pushed
     * must have a name property, and optionally a properties property of other data to send.
     * @example
     * AJS.EventQueue = AJS.EventQueue || [];
     * AJS.EventQueue.push({name: 'eventName', properties: {some: 'data', more: true, hits: 20}});
     */
    AJS.EventQueue = AJS.EventQueue || [];

    var arrayPush = Array.prototype.push;
    AJS.EventQueue.push = function(obj) {
    	obj.time = new Date().getTime();
    	arrayPush.call(AJS.EventQueue, obj);
    };

    AJS.toInit(function() {
    	determineStorageKey();
        setTimeout(bulkPublish, 500);
        removeOldAnalytics();
    });
    $(window).unload(function() {
        cancelPublish();
        saveForLater();
    });

    /**
     * @deprecated since v3.39, please trigger as normal and use whitelisting to denote privacy policy safe events
     */
    AJS.Analytics = {
        triggerPrivacyPolicySafeEvent: function(name, properties) {
            AJS.log("WARN: 'triggerPrivacyPolicySafeEvent' has been deprecated");
            AJS.EventQueue.push({name: name, properties: properties});
        }
    };

    /**
     * Binds to an event that developers can trigger without having to do any feature check.
     * If this code is available then the event will get published and if it's not the event
     * will go unnoticed.
     * @example
     * AJS.trigger('analytics', {name: 'pageSaved', data: {pageName: page.name, space: page.spaceKey}});
     */
    AJS.bind('analytics', function(event, data) {
    	AJS.EventQueue.push({name: data.name, properties: data.data});
    });

    // legacy binding until Confluence page layout JS is updated
    AJS.bind('analyticsEvent', function(event, data) {
    	AJS.EventQueue.push({name: data.name, properties: data.data});
    });

    /**
     * As part of bundling this plugin in BTF now, we need to remove the existing JIRA analytics setting if we see it.
     */
    var removeOldAnalytics = function () {
        if (window.location.pathname.indexOf("/secure/admin/ViewApplicationProperties") > -1) {
            AJS.$("[data-property-id='analytics-enabled']").remove();
        } else if (window.location.pathname.indexOf("/secure/admin/EditApplicationProperties") > -1) {
            var $analytics = AJS.$(":contains(Enable Atlassian analytics)");
            if ($analytics.size() > 0) {
                var parentElement = $analytics[$analytics.size() - 2];
                if (parentElement) {
                    parentElement.remove();
                }
            }
        }
    }

}(AJS.$));
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:application-header-administration-cog-resource', location = 'header/cog.js' */
var NavLinks = (function (NavLinks) {

    NavLinks.ApplicationHeader = function (ApplicationHeader) {

        ApplicationHeader.Cog = (function () {

            var _get = function () {

                var jiraSection = AJS.$("#system-admin-menu-content");
                if (jiraSection.length > 0) {
                    return jiraSection;
                }

                var confluenceSection = AJS.$("#admin-menu-link-content");
                if (confluenceSection.length > 0) {
                    return confluenceSection;
                }

                // Bamboo
                return AJS.$("#bamboo\\.global\\.header-admin\\.menu");
            };

            return {
                getDropdown: _get
            };
        }());
        return ApplicationHeader;
    }(NavLinks.ApplicationHeader || {});

    return NavLinks;
}(NavLinks || {}));;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:administration-shortcuts-resources', location = 'adminshortcuts/adminshortcuts.soy' */
// This file was automatically generated from adminshortcuts.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.adminshortcuts.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.adminshortcuts == 'undefined') { navlinks.templates.adminshortcuts = {}; }


navlinks.templates.adminshortcuts.section = function(opt_data, opt_ignored) {
  var param5 = '<ul class="aui-list-truncate">';
  var linkList7 = opt_data.links;
  var linkListLen7 = linkList7.length;
  for (var linkIndex7 = 0; linkIndex7 < linkListLen7; linkIndex7++) {
    var linkData7 = linkList7[linkIndex7];
    param5 += '<li><a href="' + soy.$$escapeHtml(linkData7.link) + '">' + soy.$$escapeHtml(linkData7.label) + '</a></li>';
  }
  param5 += '</ul>';
  var output = '' + aui.dropdown2.section({id: 'nl-remote-admin-section', label: "Other applications", content: param5});
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.adminshortcuts.section.soyTemplateName = 'navlinks.templates.adminshortcuts.section';
}
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:administration-shortcuts-resources', location = 'adminshortcuts/adminnavlinks.js' */
var NavLinks = (function (NavLinks) {

    NavLinks.AdminShortcuts = (function () {

        var _requestLinks = function () {
            return AJS.$.ajax({
                url:AJS.contextPath() + '/rest/menu/latest/admin',
                cache:false,
                dataType:'json'
            });
        };

        var trackAnalytics = function () {
            AJS.$("#nl-remote-admin-section").on('click', 'a', function () {
                NL.trackEvent('remoteAdminItemSelected', NL.getCurrentApplication(), $(this).attr('href'));
            });
        };

        return {
            render: function () {

                _requestLinks().done(function (linkData) {

                    // filter links to exclude the local admin link
                    linkData = _.reject(linkData,  function (link) {
                        return link['local'] === true;
                    });

                    if (linkData.length) {
                        // if we have remote admin links, render them in a new dropdown section
                        var renderedTemplate = navlinks.templates.adminshortcuts.section({links: linkData});
                        NavLinks.ApplicationHeader.Cog.getDropdown().append(renderedTemplate);

                        trackAnalytics();
                    }
                })
            }
        };
    }());

    return NavLinks;
}(NavLinks || {}));;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:administration-shortcuts', location = 'adminshortcuts/adminshortcuts-cdn.js' */
AJS.toInit(function () {
    if (AJS.DarkFeatures && AJS.DarkFeatures.isEnabled('rotp.admin.shortcuts')) {
        NavLinks.AdminShortcuts.render();
    }
});;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-projectshortcuts', location = 'projectshortcuts/projectshortcuts.soy' */
// This file was automatically generated from projectshortcuts.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.projectshortcuts.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.projectshortcuts == 'undefined') { navlinks.templates.projectshortcuts = {}; }


navlinks.templates.projectshortcuts.dialogContent = function(opt_data, opt_ignored) {
  return '' + ((opt_data.localShortcuts && opt_data.localShortcuts.length > 0) ? navlinks.templates.projectshortcuts.dialogContentShortcuts({shortcuts: opt_data.localShortcuts, listClass: 'projectshortcut-links'}) : '') + ((opt_data.remoteShortcuts != null) ? (opt_data.remoteShortcuts.length > 0) ? '<h2 class="projectshortcuts-heading">Related Links</h2>' + navlinks.templates.projectshortcuts.dialogContentShortcuts(soy.$$augmentMap(opt_data.remoteShortcuts, {shortcuts: opt_data.remoteShortcuts, listClass: 'projectshortcut-links'})) : '' : navlinks.templates.projectshortcuts.dialogLoading(null));
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogContent.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogContent';
}


navlinks.templates.projectshortcuts.headingWrapper = function(opt_data, opt_ignored) {
  return '<div class="project-dialog-header-wrapper"><div class="project-header"><img class="project-img" src="' + soy.$$escapeHtml(opt_data.logoUrl) + '"><h2 class="dialog-title">' + soy.$$escapeHtml(opt_data.title) + '</h2></div><div class="project-content-wrapper">' + soy.$$filterNoAutoescape(opt_data.contentHtml) + '</div></div>';
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.headingWrapper.soyTemplateName = 'navlinks.templates.projectshortcuts.headingWrapper';
}


navlinks.templates.projectshortcuts.dialogContentShortcuts = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  var output = '<ul' + ((opt_data.listClass) ? ' class="' + soy.$$escapeHtml(opt_data.listClass) + '"' : '') + '>';
  var shortcutList35 = opt_data.shortcuts;
  var shortcutListLen35 = shortcutList35.length;
  for (var shortcutIndex35 = 0; shortcutIndex35 < shortcutListLen35; shortcutIndex35++) {
    var shortcutData35 = shortcutList35[shortcutIndex35];
    output += '<li' + ((shortcutIndex35 == shortcutListLen35 - 1) ? ' class="last"' : '') + '>' + navlinks.templates.projectshortcuts.dialogContentShortcut(shortcutData35) + '</li>';
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogContentShortcuts.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogContentShortcuts';
}


navlinks.templates.projectshortcuts.dialogContentShortcut = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.link) + '"' + ((opt_data.tooltip) ? ' title="' + soy.$$escapeHtml(opt_data.tooltip) + '"' : '') + '>' + soy.$$escapeHtml(opt_data.label) + '</a>';
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogContentShortcut.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogContentShortcut';
}


navlinks.templates.projectshortcuts.dialogLoading = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div class="projectshortcuts-loading">' + ((opt_data.text) ? soy.$$escapeHtml(opt_data.text) : '') + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.projectshortcuts.dialogLoading.soyTemplateName = 'navlinks.templates.projectshortcuts.dialogLoading';
}
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-projectshortcuts', location = 'projectshortcuts/projectshortcuts.js' */
(function ($, NL) {
    var dialog,
        dialogDataCache = {},
        triggerDataEntityKey = 'key',
        triggerDataEntityName = 'name',
        triggerDataEntityType = 'entity-type';

    function showShortcutsDialog(e) {
        var $trigger = $(this),
            projectKey = $trigger.data(triggerDataEntityKey),
            projectName = $trigger.data(triggerDataEntityName),
            projectEntityType = $trigger.data(triggerDataEntityType);

        if (typeof projectKey === 'undefined') {
            return;
        }

        e.preventDefault();

        dialog = new AJS.Dialog({
            width: 600,
            keypressListener: function (e) {
                if (e.which == jQuery.ui.keyCode.ESCAPE) {
                    dialog.remove();
                }
            },
            id: "project-shortcuts-dialog"
        })
            .addCancel('Close', function () {
                dialog.remove();
            })
            .addPanel('',
                    navlinks.templates.projectshortcuts.headingWrapper({
                            title: projectName,
                            logoUrl: getLogoUrl(),
                            contentHtml : navlinks.templates.projectshortcuts.dialogLoading({ text: 'Retrieving links…' })
                        }))
            .show();

        updateDialogHeight(dialog);

        if (!dialogDataCache[projectKey]) {
            dialogDataCache[projectKey] = {
                entity: {
                    title: projectName
                },
                localShortcuts: null,
                remoteShortcuts: null
            };
            getData(AJS.contextPath() + '/rest/project-shortcuts/1.0/local/' + projectKey, { entityType: projectEntityType }).done(updateLocal);
            getData(AJS.contextPath() + '/rest/project-shortcuts/1.0/remote/' + projectKey, { entityType: projectEntityType }).done(updateRemote).fail(function () {
                var $wrapper = dialog.getCurrentPanel().body.find('.project-content-wrapper');
                $wrapper.find('.projectshortcuts-loading').remove();
                AJS.messages.error($wrapper, {
                    body: "Could not retrieve remote project shortcuts",
                    closeable: false
                });
                updateDialogHeight(dialog);
            });
        } else {
            updateShortcutsDialog(dialogDataCache[projectKey]);
        }

        function updateLocal(data) {
            dialogDataCache[projectKey].localShortcuts = data.shortcuts;
            updateShortcutsDialog(dialogDataCache[projectKey]);
        }
        function updateRemote(data) {
            dialogDataCache[projectKey].remoteShortcuts = data.shortcuts;
            updateShortcutsDialog(dialogDataCache[projectKey]);
        }
    }

    function getLogoUrl() { 
        return $(".project-shortcut-dialog-trigger img").attr("src");
    }

    function updateShortcutsDialog(data) {
        if (data.localShortcuts) { // Don't update the dialog until we have entity data and local links (stops the dialog from displaying remote links only if remote links has returned first)
            dialog.getCurrentPanel().html(
                    navlinks.templates.projectshortcuts.headingWrapper({
                        title: data.entity.title,
                        logoUrl: getLogoUrl(),
                        contentHtml: navlinks.templates.projectshortcuts.dialogContent(data)
                    }));

            updateDialogHeight(dialog);
        }
    }
    
    function truncateDesc(desc) {

        var trunc = 210;
        if(!desc || desc.length <= trunc)
            return desc;

        var i = trunc;
        while(i > 0 && desc.charAt(i) != " ") {
            i--;
        }
        if(i == 0) {
            i = trunc;
        }

        desc = desc.substring(0, i);
        if(desc.length >= i)
            desc = desc + "...";
        return desc;
    }

    /**
     * Since AJS.Dialog's height updating is completely broken we need to do it custom for our dialog
     * @param dialog
     */
    function updateDialogHeight(dialog) {
        var $dialog = dialog.popup.element,
            $body = $dialog.find('.dialog-panel-body'),
            $components = $dialog.find('.dialog-components');

        $body.height('auto');
        $dialog.height($components.outerHeight() - 1);
        $('.aui-shadow').remove();
    }

    function getData(url, data) {
        return $.ajax({
            url: url,
            cache: false,
            data: data,
            dataType: 'json'
        });
    }

    $(document).on('click', '.project-shortcut-dialog-trigger', showShortcutsDialog);
}(jQuery, window.NL = (window.NL || {})));
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:atlassian-ui-popup-display-controller', location = 'popups/DisplayController.js' */
AJS.Popups = AJS.Popups || {};

/**
 * Coordinate the display of popup dialogs requested from other functions in the application.
 *
 * Its responsibility is to organise the display of these popups so that that they do not come into conflict with
 * each other.
 */
AJS.Popups.DisplayController = function () {

    var _popupDialogRegistry = [];
    var _renderPerformed = false;
    var _dialogShown = false;

    AJS.toInit(function () {
        setTimeout(function () {
            AJS.Popups.DisplayController.render();
        }, 0);
    });

    return {

        /**
         * Request the display of a popup dialog to this controller.
         *
         * @param popupDialog An {Object} containing a request to display a popup dialog.
         */
        request:function (popupDialog) {
            _popupDialogRegistry.push(popupDialog);
            if (_renderPerformed && _dialogShown === false) {
                this.render();
            }
        },

        /**
         * Renders a popup dialog on screen.
         *
         * If more than one popup has been requested, it will render the one that has the lowest "weight",
         * if no popups have been requested, no dialog will be displayed.
         *
         */
        render:function () {
            _popupDialogRegistry.sort(function (first, second) {
                return first.weight - second.weight;
            });

            _renderPerformed = true;

            if (_popupDialogRegistry.length !== 0) {
                _dialogShown = true;
                _popupDialogRegistry[0].show();
            }
        }
    };
}();;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-web-plugin:issue-link-web-link', location = 'js/issuelink-weblink.js' */
(function () {
    var $hiddenImg = AJS.$("<img>"),
        $iconUrlInput,
        $urlInput,
        faviconUrl,
        throbberTimeoutId;

    $hiddenImg.load(function() {
        $iconUrlInput.val(faviconUrl);
        $urlInput.css("background-image", 'url("' + faviconUrl + '")');

        clearTimeout(throbberTimeoutId);
        $urlInput.removeClass("loading");
    });
    $hiddenImg.error(function() {
        clearTimeout(throbberTimeoutId);
        $urlInput.removeClass("loading");
    });

    function init(context) {
        $iconUrlInput = AJS.$("#web-link-icon-url", context);
        $urlInput = AJS.$("#web-link-url", context).bind("change", fetchFavicon);

        if ($iconUrlInput.val()) {
            $urlInput.css("background-image", "url(" + $iconUrlInput.val() + ")");
        }
    }

    function fetchFavicon() {
        // Initialise state
        $hiddenImg.attr("src", '');
        $iconUrlInput.val('');
        $urlInput.css("background-image", '');
        faviconUrl = parseFaviconUrl($urlInput.val());

        if (!faviconUrl) {
            return;
        }

        /**
         * IE specific hack: For some reason I cannot change the class inside event handler for the event source.
         */
        setTimeout(function() { $urlInput.addClass("loading"); }, 0);
        throbberTimeoutId = setTimeout(function() { $urlInput.removeClass("loading"); }, 3000);

        $hiddenImg.attr("src", faviconUrl);
    }

    function parseFaviconUrl(url) {
        var hostUrl = url.match(/^([^/]*\/\/[^/]+)/)[1];

        if (!hostUrl) {
            return;
        }

        return hostUrl + "/favicon.ico";
    }

    JIRA.bind(JIRA.Events.NEW_PAGE_ADDED, function (e, context) {
        init(context);
    });
})();;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:shared-utility', location = 'js/ctrlv/time.js' */
define("dndattachment/ctrlv/time", [], function () {
  "use strict";
  return moment;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:shared-utility', location = 'js/ctrlv/base64decode.js' */
// Modified by Atlassian
// Copyright (c) 2013 ethertank, fusionchess
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
define("dndattachment/ctrlv/base64decode", [
    "exports"
], function (
  exports
) {
    "use strict";

    /**
     * Array of bytes to base64 string decoding
     * @param nChr
     * @returns {number}
     */
    function b64ToUint6(nChr) {
        return nChr > 64 && nChr < 91 ?
            nChr - 65
            : nChr > 96 && nChr < 123 ?
            nChr - 71
            : nChr > 47 && nChr < 58 ?
            nChr + 4
            : nChr === 43 ?
            62
            : nChr === 47 ?
            63
            :
            0;
    }

    var base64decode = function (encoded) {
        var sB64Enc = encoded.replace(/[^A-Za-z0-9\+\/]/g, ""),
            nInLen = sB64Enc.length,
            nOutLen = nInLen * 3 + 1 >> 2,
            taBytes = new Uint8Array(nOutLen);

        for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
            nMod4 = nInIdx & 3;
            nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
            if (nMod4 === 3 || nInLen - nInIdx === 1) {
                for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
                    taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
                }
                nUint24 = 0;
            }
        }

        return taBytes;
    };
    /**
     * Decoder of base64 encoded string to a byte array
     * @param encoded
     * @returns {Uint8Array}
     */
    exports.base64decode = base64decode;


    exports.decodeBase64DataUri = function (uri) {
        var separator = ";base64,",
            prefix = uri.slice(0, uri.indexOf(separator)) + separator,
            base64encoded = uri.substring(prefix.length);
        return base64decode(base64encoded);
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:shared-utility', location = 'js/ctrlv/utility.js' */
define("dndattachment/ctrlv/utility", [
    "jquery",
    "underscore",
    "dndattachment/ctrlv/base64decode",
    "dndattachment/ctrlv/time",
    "jira/flag",
    "jira/util/navigator",
    "featureflags/feature-manager",
    "exports"
], function (
  $,
  _,
  base64decode,
  time,
  JIRAFlag,
  Navigator,
  FeatureManager,
  exports
) {
    "use strict";

    /**
     * Determine if a keypress event is a "paste" (the keys differ between platform).
     * @param {Event} event
     * @param {string} [platform] If provided, overrides the value of navigator.platform.
     * @returns {boolean}
     */
    exports.isKeyPasteEvent = function (event, platform) {
        var V_KEY = 86;
        var IS_MAC = ((platform || "").indexOf("Mac") !== -1) || Navigator.isMac();

        return event.which === V_KEY && (IS_MAC ? event.metaKey : event.ctrlKey);
    };

    /**
     * Feature detection, check whether given parameter is a valid clipboard event
     *
     * @param event JQuery Event object
     * @returns {boolean}
     */
    exports.isImagePasteEvent = function (event) {
        if (event && event.clipboardData) {
            // Get the items from the clipboard, scan items and files properties
            var items = _.union(_.toArray(event.clipboardData.items), _.toArray(event.clipboardData.files));
            var hasImage = items.some(function (item) {
                return item.type.indexOf("image") !== -1;
            });
            var hasRtf = items.some(function (item) {
                return item.type.indexOf("rtf") !== -1;
            });
            return hasImage && !hasRtf;
        }
    };

    var getHtmlImagePaste = function (event) {
        if (!event.clipboardData || !event.clipboardData.types || !_.contains(event.clipboardData.types, "text/html")) {
            return;
        }

        var $data = $(event.clipboardData.getData("text/html"));
        if($data.length === 1 && $data.children().length === 0 && $data[0].nodeName.toLowerCase() === "img"){
            return $data[0].src;
        }
        return null;
    };

    exports.getHtmlImagePaste = getHtmlImagePaste;

    /**
     * Detect whether given event comes with html content in its ClipboardData, that contains single image tag
     * @param {Event} event
     * @returns {Boolean}
     */
    exports.isHtmlImagePasteEvent = function(event) {
        return getHtmlImagePaste(event) != null;
    };

    /**
     * Detect whether given event comes with text content in its ClipboardData
     * @param {Event} event
     * @returns {Boolean}
     */
    exports.isTextPasteEvent = function(event) {
        return event.clipboardData.types && (_.contains(event.clipboardData.types, "text/plain") || _.contains(event.clipboardData.types, "text/html"));
    };

    /**
     * Detect whether this element is an/withing contentEditable
     * @param {HTMLElement} element
     * @returns {Boolean}
     */
    exports.isContentEditable = function(element) {
        return  element.contentEditable == "true" || element.contentEditable == "" ||
                (element.contentEditable == "inherit" && $(element).parents().is('[contenteditable=true]'));
    };

    /**
     * Check if provided file name does not contain any of forbidden characters
     * @param {String} fileName
     * @returns {boolean}
     */
    exports.isValidFileName = function(fileName) {
        return !_([
            // characters forbidden by various file systems
            '\\', '/', '\"', ':', '?', '*', '<', '|', '>',
            // wiki markup
            '!'
        ]).any(function(character) {
            return fileName.indexOf(character) > -1;
        });
    };

    /**
     * Get text content from paste event
     * @param {Event} event
     * @returns {String}
     */
    exports.getTextPasteContent = function(event) {
        return event.clipboardData.types && _.contains(event.clipboardData.types, "text/plain") && event.clipboardData.getData("text/plain") || '';
    };

    /**
     * Get text contet from node, pick property which preserves new lines.
     * @param node
     * @returns {String}
     */
    exports.getTextContent = function(node) {
        if (!node) {
            return '';
        } else if (Navigator.isIE() && typeof node.innerText !== "undefined") {
            return node.innerText;
        } else  {
            return $(node).text();
        }
    };

    /**
     * Copy clipboardData from pasteEvent.originalEvent into pasteEvent or create and adapter
     * @param {Event} pasteEvent
     * @returns {Event}
     */
    exports.normalizePasteEvent = function(pasteEvent) {
        if(pasteEvent && pasteEvent.originalEvent && pasteEvent.originalEvent.clipboardData) {
            pasteEvent.clipboardData = pasteEvent.originalEvent.clipboardData;
        }

        // IE case, create small adapter for IE window.clipboardData
        if(pasteEvent && !pasteEvent.clipboardData && window.clipboardData) {
            pasteEvent.clipboardData = {
                files: window.clipboardData.files,
                types: {
                    contains: function(mimeType) {
                        if(mimeType == "text/plain") {
                            return !!window.clipboardData.getData("Text");
                        }
                    }
                },
                getData: function(mimeType) {
                    if(mimeType == "text/plain") {
                        return window.clipboardData.getData("Text");
                    }
                }
            };
        }

        return pasteEvent;
    };

    /**
     * Determine if the current browser is supported.
     * @param {string} [platform] If provided, overrides the value of navigator.platform.
     * @returns {boolean}
     */
    exports.browserIsSupported = function (platform) {
        var isMac = ((platform || "").indexOf("Mac") !== -1) || Navigator.isMac();
        var isSafari = Navigator.isSafari();

        // Safari isn't supported because it supports neither the HTML5 approach nor the Java applet approach.
        return !(isMac && isSafari);
    };

    /**
     * Determine wheter the current browser supports paste natively.
     * @returns {boolean}
     */
    exports.browserIsNativePaste = function () {
        return Navigator.isChrome() || Navigator.isSafari();
    };

    /**
     * Determine whether the unified attachments dark feature is enabled.
     * @returns {boolean}
     */
    exports.isUnifiedAttachmentsEnabled = function() {
        return FeatureManager.isFeatureEnabled("jira.unified.attachments");
    };

    /**
     * Determine whether the issuePasteDisabled dark feature is enabled.
     * @returns {boolean}
     */
    exports.isIssuePasteDisabledEnabled = function() {
        return FeatureManager.isFeatureEnabled("com.atlassian.plugins.jira.screenshot.issuePasteDisabled");
    };

    /**
     * Determine whether $pasteTarget is an input element and that it is a wiki textfield
     * @returns {boolean}
     */
    exports.isWikiTextfield = function ($pasteTarget) {
        return $pasteTarget.is(':input') && $pasteTarget.hasClass("wiki-textfield")
    };

    /**
     * Determine whether the element is the summary input field
     * @returns {boolean}
     */
    var _isSummaryField = function ($pasteTarget) {
        return $pasteTarget.is('input#summary');
    };

    /**
     * Append the given text content (if not null) to either the summary field or to a wiki textfield
     * @param content to be appended
     * @param pasteTarget element that will have the value updated
     * @param selectionStart
     * @param selectionEnd
     */
    var insertToInput = function (content, pasteTarget, selectionStart, selectionEnd) {
        var $pasteTarget = $(pasteTarget);

        // bail if pasteTarget is not a valid field or if no content was passed in
        if( !(exports.isWikiTextfield($pasteTarget) || _isSummaryField($pasteTarget)) || !content) {
            return;
        }

        if(!$pasteTarget.is(':focus')) {
            // This is a workaround for the case where the textfield is not focused (only needed for some browsers).
            // This ensures the cursor moves to the end of the text.
            $pasteTarget.one('focus', function() {
                var pasteTarget = $pasteTarget[0];
                pasteTarget.selectionStart = pasteTarget.selectionEnd = selectionStart + content.length;
            });
        }

        var value = $pasteTarget.val();
        var prefix = value.substring(0, selectionStart);
        var suffix = value.substring(selectionEnd, value.length);

        // wiki editor maintains its own history buffer, it helps us in some browser(Safari, IE)
        var wikiEditor = $pasteTarget.data("wikiEditor");
        if(wikiEditor && wikiEditor.undoRedoEl && _.isFunction(wikiEditor.undoRedoEl.recordHistoryItem)) {
            wikiEditor.undoRedoEl.recordHistoryItem();
        }

        $pasteTarget.val(prefix + content + suffix);

        // trigger input for dirty form handlers if there are any
        $pasteTarget.trigger("input");

        pasteTarget.selectionStart = pasteTarget.selectionEnd = selectionStart + content.length;

        if(wikiEditor && wikiEditor.undoRedoEl && _.isFunction(wikiEditor.undoRedoEl.updateCurrent)) {
            wikiEditor.undoRedoEl.updateCurrent();
        }
    };

    /**
     * Insert content into textfield at its current selection
     * @param {String} content
     * @param {HTMLElement} textfield
     * @param {Number} selectionStart current selection start
     * @param {Number} selectionEnd current selection end
     */
    exports.insertToInput = insertToInput;

    exports.getMarkup = function(fileName) {
        var animatedImageFileTypes = [
            'gif'
        ];
        var regularImageFileTypes = [
            'bmp',
            'jpeg',
            'jpg',
            'png'
        ];
        var nameParts = fileName.split('.');
        var fileType = nameParts[nameParts.length - 1].toLowerCase();
        if (_.contains(animatedImageFileTypes, fileType)) {
            return '!' + fileName + '!';
        } else if (_.contains(regularImageFileTypes, fileType)) {
            return '!' + fileName + '|thumbnail!';
        } else {
            return '[^' + fileName + ']';
        }
    };

    /**
     * Wrap fileName into wiki markup and insert it into textfield at its current selection
     * @param {String} fileName
     * @param {HTMLElement} pasteTarget
     * @param {Number} selectionStart current selection start
     * @param {Number} selectionEnd current selection end
     */
    exports.insertWikiMarkup = function (fileName, pasteTarget, selectionStart, selectionEnd) {
        var markup = exports.getMarkup(fileName);
        if (markup) {
            // Add a space before and after so that it will display properly if the user forgets to add spaces
            markup = " " + markup + " ";
            insertToInput(markup, pasteTarget, selectionStart, selectionEnd);
        }
    };

    /**
     * Load image from given source
     * @param imageSrc
     * @returns {$.Deferred}
     */
    exports.loadImage = function (imageSrc) {
        var deferred = new $.Deferred();

        var image = new Image();
        image.setAttribute("crossOrigin", "anonymous");
        image.onload = function() {
            deferred.resolve(image);
        };
        image.onerror = deferred.reject.bind(deferred);
        image.src = imageSrc;

        // maybe it was already loaded (from cache)
        if(image.width > 0 && image.height > 0) {
            deferred.resolve(image);
        }

        return deferred;
    };

    /**
     * Convert image to blob or return null when it is not possible
     * @param image
     * @returns {Blob}
     */
    exports.convertImageToBlob = function(image) {
        // off screen canvas and try feature detection
        var canvas = $('<canvas>').attr("width", image.width).attr("height", image.height)[0];
        canvas.getContext('2d').drawImage(image, 0, 0);
        try {
            if(canvas.mozGetAsFile) {
                return canvas.mozGetAsFile("image/png");
            }

            if(canvas.toDataURL) {
                return new Blob([base64decode.decodeBase64DataUri(canvas.toDataURL("image/png"))], { type: "image/png" });
            }
        } catch(e) {
            // in case of any exceptions (security, malformed uri etc)
            return null;
        }
    };

    /**
     * Convert a blob into an image
     * @param blob
     * @param imageName
     * @return {File}
     */
    exports.convertBlobToImage = function(blob, imageName) {
        var file = new Blob([blob.slice()], { type: blob.type });
        file.lastModifiedDate = new Date();
        file.name = imageName;
        return file;
    };

    /**
     * Try to drop image file to element and return true if the event was actually consumed
     * @param {Blob} file
     * @param {jQuery} element
     * @returns {Boolean} Returns true if drop was actually consumed
     */
    exports.dropFileToElement = function(file, $element) {
        var fileName = file.name;
        if(!fileName) {
            fileName = this.generateFileName();
            file.name = fileName + ".png";
        }
        var event = $.Event("drop", {dataTransfer: {files: [file]}});

        var result = false;
        $(document).on('dropHandled.dropFileToElement', function() {
            result = true;
        });
        $element.trigger(event);
        $(document).off('.dropFileToElement');
        return result;
    };

    exports.generateFileName = function() {
        return "image-" + time().format("YYYY-MM-DD-HH-mm-ss-SSS");
    };

    exports.getCurrentIssueId = function() {
        return JIRA.Issues.Api.getSelectedIssueId();
    };

    exports.showErrorMsg = function(title, message){
        JIRAFlag.showErrorMsg(title, message);
    };

    /**
     * Create Blob from file with same mime type and copied file.name.
     * This is required, because we want to pass file with modified name in drop event and name property of File is read only
     * @param {File} file
     * @returns {Blob}
     */
    exports.createBlobFromFile = function(file) {
        var fileBlob = new Blob([file.slice()], { type: file.type });
        fileBlob.name = file.name;
        return fileBlob;
    };

    /**
     * Check whether a drag event contains files. To be used during dragover/dragenter events to determine whether
     * we should show the dropzone or not. If dataTransfer.types is not supported (only IE) just returns true.
     * This doesn't work completely on Firefox, since they count dragging an image element from within the browser
     * as a 'file'.
     * @param event
     * @returns {boolean}
     */
    exports.dragEventContainsFiles = function (event) {
        // If we can't check the types, assume it does contain files.
        if (!event.dataTransfer || !event.dataTransfer.types) {
            return true;
        }

        // Behaviour
        // Mozilla: types = DOMStringList and contains "Files" even when a file is not dragging. It contains "application/x-moz-file" when a file is actually dragging
        // IE: types = DOMStringList and contains "Files" when dragging  a file
        // Chrome + Safari: types = Array and contains "Files" when dragging a file

        var types = event.dataTransfer.types;

        if (Navigator.isMozilla()) {
            return types.contains("application/x-moz-file");
        }

        // using a standard iterator as it works for both Array and DOMStringList
        for (var i = 0; i < types.length; i++) {
            if (types[i] === "Files") {
                return true;
            }
        }

        return false;
    };
});
;
;
/* module-key = 'com.atlassian.pocketknife.featureflags-plugin:pocketknife-feature-flags', location = '/featureflags/feature-manager.js' */
define("featureflags/feature-manager", [
    "exports"
], function(
    exports
    ){

    var json = WRM.data.claim("com.atlassian.pocketknife.featureflags-plugin:pocketknife-feature-flags.feature-flag-data");
    var systemEnabledFeatures = (json && json["enabled-feature-keys"]) || [];
    var featureFlagStates = (json && json["feature-flag-states"]) || {};

    var contains = function (arr, target) {
        return arr.indexOf(target) !== -1;
    };

    /**
     * Checks if the given feature is enabled. If no feature flag is defined with
     * the given feature key, this will fall-back to the default feature manager behaviour (like AJS.DarkFeatures.isEnabled(..))
     * @param featureKey a String, usually of the form "my.feature.key" (NOT "my.feature.key.enabled" or "my.feature.key.disabled")
     * @returns {boolean}
     */
    exports.isFeatureEnabled = function(featureKey){
        var flagState = featureFlagStates[featureKey];

        if(flagState === true){
            // Feature flag is in enabled state, check for (featureKey + ".disabled") to tell us otherwise
            var isSystemNegated = contains(systemEnabledFeatures, featureKey + ".disabled");
            return !isSystemNegated;
        }
        else if(flagState === false){
            // Disabled state, remain disabled unless (featureKey + ".enabled") is present
            var isSystemEnabled = contains(systemEnabledFeatures, featureKey + ".enabled");
            return isSystemEnabled;
        }
        else {
            // There is no flag defined with the given key, fall-back to what the system features say
            return contains(systemEnabledFeatures, featureKey);
        }
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/Configuration.js' */
define("dndattachment/util/Configuration", function() {
    var dataKey = "com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-issue-drop-zone.";

    function getWRMData(key) {
        return _.isFunction(WRM.data) ? WRM.data(key) : WRM.data.claim(key);
    }

    return {
        getWRM: function(key) {
            return getWRMData(dataKey + key);
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/DataTransfer.js' */
define("dndattachment/util/DataTransfer", ['jquery'], function ($) {
    return Class.extend({
        init: function(_dataTransfer) {
            this._dataTransfer = _dataTransfer;
        },

        getFiles: function() {
            var files = this._dataTransfer.files;
            var items = this._dataTransfer.items;

            if(items && items.length > 0) {
                if(_.any(items, function(item) { return !!item.webkitGetAsEntry; })) {
                    return this.readEntries(items);
                }
            }

            if(files && files.length > 0) {
                return this.readFiles(this._dataTransfer.files)
            } else {
                return new $.Deferred().reject();
            }
        },

        readFiles: function(files) {
            var result = new $.Deferred();

            $.when.apply(window, _.map(files, function(file) {
                var deferred = new $.Deferred();

                var noExtension = !file.name.match(/\.([a-z0-9]+)$/i);

                // if there is no extension, we rely on a fact that underlying implementation
                // will throw permission denied on fopen call for directory path
                // typical candidates for directory are paths without extension at the end
                // and also file.size 8192, 4096 and below 1024(Mac OS X)
                if(noExtension && (file.size <= 8192) || file.size == 8192 || file.size == 4096 || file.size <= 1024) {
                    this.readFileAsText(file).fail(function() {
                        files = _(files).without(file);
                    }).always(deferred.resolve.bind(deferred));
                } else {
                    deferred.resolve();
                }

                return deferred;
            }.bind(this))).always(function() {
                result.resolve(files);
            });

            return result;
        },

        readFileAsText: function(file) {
            var result = new $.Deferred();

            var reader = new FileReader();
            reader.onload = function() {
                result.resolve(this.result);
            };
            reader.onerror = function() {
                result.reject(this.error);
            };

            reader.readAsText(file);

            return result;
        },

        readEntries: function(items) {
            var result = new $.Deferred();

            // if dropped item is a file or a directory, item.kind === "file"
            items = _.filter(items, function(item){
                return item.kind === "file";
            });

            $.when.apply(window, _.map(items, function (item) {
                return this.readEntry(item.webkitGetAsEntry(), item);
            }.bind(this))).then(function() {
                result.resolve(_.union.apply(_, arguments));
            }, result.reject.bind(result));

            return result;
        },

        readEntry: function(entry, item) {
            var result = new $.Deferred();

            if(entry.isFile) {
                if(item && item.getAsFile) {
                    result.resolve([item.getAsFile()]);
                } else {
                    entry.file(function(file) {
                        result.resolve([file]);
                    });
                }
            } else if(entry.isDirectory) {
                entry.createReader().readEntries(function(entries) {
                    var files = [];

                    $.when.apply(window, _.map(entries, function(entry) {
                        return this.readEntry(entry).then(function(entryFiles) {
                            return files.push.apply(files, entryFiles);
                        });
                    }.bind(this))).always(function() {
                        result.resolve(files);
                    });
                }.bind(this));
            }

            return result;
        }
    })
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/FileSizeUtil.js' */
/**
 * Ported from com.atlassian.core.util.FileSize
 */

define('dndattachment/util/FileSizeUtil',
function() {
    var KB_SIZE = 1024;
    var MB_SIZE = KB_SIZE * KB_SIZE;

    var KB = " kB";
    var MB = " MB";

    /**
     * Format the size of a file in human readable form.  Anything less than a kilobyte
     * is presented in kilobytes to one decimal place.  Anything between a kilobyte and a megabyte is
     * presented in kilobytes to zero decimal places.  Anything greater than one megabyte is
     * presented in megabytes to two decimal places.
     * <p>
     * eg.
     * <ul>
     *  <li>format(512) -> 0.5 kb
     *  <li>format(1024) -> 1.0 kb
     *  <li>format(2048) -> 2 kb
     *  <li>format(1024 * 400) -> 400 kb
     *  <li>format(1024 * 1024) -> 1024 kb
     *  <li>format(1024 * 1024 * 1.2) -> 1.20 Mb
     *  <li>format(1024 * 1024 * 20) -> 20.00 Mb
     * </ul>
     *
     * @param   filesize  The size of the file in bytes.
     * @return  The size in human readable form.
     */
    function format(filesize) {
        // TODO: filesize = 1024 gives "1.0 kB", but filesize = 1025 gives "1 kB", this is kinda inconsistent.

        if (filesize > MB_SIZE)
        {
            return formatMB(filesize);
        }
        else if (filesize > KB_SIZE)
        {
            return formatKB(filesize);
        }
        else
        {
            return formatBytes(filesize);
        }

    }

    function formatMB(filesize) {
        var mbsize = filesize / MB_SIZE;
        return mbsize.toFixed(2) + MB;
    }

    function formatKB(filesize) {
        var kbsize = Math.round(filesize / KB_SIZE); //format 0 decimal places
        return kbsize + KB;
    }

    function formatBytes(filesize) {
        var mbsize = filesize / KB_SIZE;
        return mbsize.toFixed(1) + KB;
    }

    return {
        format: format
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-utility', location = 'js/util/AttachmentEvents.js' */
/**
 * A dictionary of attachment related event types that JIRA will fire from time to time.
 * @module jira/util/events/types
 */
define('dndattachment/util/events/types', {
    // Export the event name so listeners don't have to
    ATTACHMENT_FOR_PAGE_RECEIVED: "attachmentForPageReceived"
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-upload', location = 'js/upload/UploadHandler.js' */
/**
 * An executor is what the handler calls to actually execute the upload
 * @typedef {Object} Executor
 *  @function {boolean} isValid(event, args) - returns true if the executor wants to be invoked.
 *  @function {deferred} processFiles(files, attachmentDropZone) - handles the actual processing of the file.
 *  Should return a deferred that properly communicates the outcome
 *  @property {number} weight - the weight of the executor when we loop through them. Higher the number, the earier we check it
 *  @property {string} name - name of the executor. This is used as the 'key' when we register and remove executors.
 */

/**
 * This listens for EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED and handles the uploading of the files.
 * This does not do the actual uploading, just collects the events and pass them along.
 */
define('dndattachment/upload/handler', [
    'jira/util/events',
    'dndattachment/util/events/types',
    'underscore',
    'jquery',
    'dndattachment/ctrlv/utility',
    'exports'
], function(
    Events,
    EventTypes,
    _,
    $,
    Utility,
    exports
) {
    // The list of registered upload executors
    var executorList = [];

    // The current attachmentDropZone that is relevant to us
    var attachmentDropZone;

    /**
     * This method is called to handle the ATTACHMENT_FOR_PAGE_RECEIVED event once it has been triggered by something.
     *
     * @param event - This will be ATTACHMENT_FOR_PAGE_RECEIVED
     * @param args - These are all the arguments that are passed in when the event is thrown. Typically they will
     * contain files, successCallback, failureCallback and alwaysCallback but may contain more things depending on the code
     * that receives the file.
     */
    var handleAttachmentReceived = function(event, args) {
        var uploadResult = $.Deferred();

        //if there's a dialog open, we simulate a drop and let the dialog handle it.
        var JIRADialog = JIRA.Dialog.current;
        if (JIRADialog) {
            AJS.trigger('analytics', { name : 'attach.screenshot.html5.dialogPaste', data : {}});

            var fileBlob = Utility.createBlobFromFile(args.files[0]);
            if(Utility.dropFileToElement(fileBlob, JIRADialog.$form)) {
                uploadResult.resolve([args.files[0].name]);
            }
        }
        else {
            var validExecutor = _.find(executorList, function(executor) {
                return executor.isValid(event, args);
            });
            if(validExecutor) {
                uploadResult = validExecutor.processFiles(args.files, attachmentDropZone);
                if(args.successCallback) {
                    uploadResult.done(args.successCallback);
                }
                if(args.failureCallback) {
                    uploadResult.fail(args.failureCallback);
                }
                if(args.alwaysCallback) {
                    uploadResult.always(args.alwaysCallback);
                }
            }
        }

        uploadResult.done(function(fileNames, noInsertMarkup) {
            if (!noInsertMarkup && args.isWikiTextfieldFocused) {
                var wikiTextfield = args.wikiTextfield;
                _.each(fileNames, function(fileName) {
                    Utility.insertWikiMarkup(fileName, wikiTextfield, wikiTextfield.selectionStart, wikiTextfield.selectionStart);
                });
                if (JIRADialog && args.isPaste) {
                    AJS.trigger('analytics', { name : 'attach.screenshot.html5.dialogPaste.insertWikiMarkup', data : {}});
                }
                // Focus back on the textfield if the executor caused it to lose focus.
                if (!$(args.wikiTextfield).is(":focus")) {
                    setTimeout(function () {
                        args.wikiTextfield.focus();
                    }, 0);
                }
            }
        });
    };

    var isExecutorValid = function(executor) {
        // Check that the executor exists
        if(executor) {
            // Check that the valid methods are defined
            var hasIsValidMethod = typeof executor.isValid !== 'undefined';
            var hasProcessFiles = typeof executor.processFiles !== 'undefined';
            var hasWeight = typeof executor.weight !== 'undefined';
            var hasName = typeof executor.name !== 'undefined';

            return hasIsValidMethod && hasProcessFiles && hasWeight && hasName;
        }
        return false;
    };

    /**
     * This registers an executor for handling the uploads.
     *
     * @param {Executor} executor - The executor to register
     * @returns {Boolean} - true if the registration was successful
     */
    exports.registerExecutor = function(executor) {
        var isValid = isExecutorValid(executor);
        if(isValid) {
            // Prevent duplicate executors
            var list = _.reject(executorList, function (ex) {
                return ex.name === executor.name;
            });

            // Add in the executor
            list.push(executor);

            // Sort by weight
            executorList = _.sortBy(list, function (ex) {
                // Negative weight so that highest numbers are sorted first
                return -ex.weight;
            });
        }
        return isValid;
    };

    /**
     * This unregisters an executor
     *
     * @param {Executor} executor - The executor to register
     */
    exports.unregisterExecutor = function(executor) {
        executorList = _.reject(executorList, function(ex) {
            return ex.name === executor.name;
        });
    };

    /**
     * Initialised the upload handler
     */
    exports.initialize = function() {
        // Handle any attachments that need to be uploaded directly onto the page through the main attachment zone
        Events.bind(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, handleAttachmentReceived);
    };

    /**
     * Remove the upload handler
     */
    exports.disable = function() {
        // Cleanup everything that was done in the initialize method
        Events.unbind(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, handleAttachmentReceived);
    };

    /**
     * Set the attachmentDropZone that should handle incoming attachments
     */
    exports.setAttachmentDropZone = function(dropZone) {
        attachmentDropZone = dropZone;
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-upload', location = 'js/upload/DefaultUploadExecutor.js' */
/**
 * This is the default executor that uploads the files when none of the other registered executors hit
 */
define('dndattachment/upload/default/executor', [
    'jquery',
    'underscore',
    'dndattachment/ctrlv/utility',
    'exports'
], function(
    $,
    _,
    Utility,
    exports
) {
    exports.name = 'Default attachment executor';

    /**
     * The default executor's weight is always 0. As in it is always the lowest thing
     */
    exports.weight = 0;

    /**
     * This executor is always valid
     */
    exports.isValid = function(event, args) {
        return true;
    };

    exports.processFiles = function(files, attachmentDropZone) {
        return attachmentDropZone.uploadFiles(files);
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/path.js' */
define("dndattachment/ctrlv/path", [
    "exports"
], function (
  exports
) {
    "use strict";

    /**
     * Get the basename of a URI (i.e. the last path component).
     * @param {String} uri
     * @returns {String}
     */
    var basename = function basename(uri) {
        return uri.split(/\//).pop();
    };

    exports.basename = basename;

    /**
     * Get everything *except* the basename of a URI.
     * @param {String} uri
     * @returns {String}
     */
    exports.dirname = function (uri) {
        var basenameResult = basename(uri);
        return uri.substring(0, uri.length - basenameResult.length);
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/ie_version.js' */
define("dndattachment/ctrlv/version", [
    "jquery",
    "underscore",
    "jira/util/navigator",
    "exports"
  ],
  function(
    $,
    _,
    Navigator,
    exports
  ){
    "use strict";


    // It's a sad state of affairs that we need this browser detection, but unfortunately there's no reliable feature
    // detection for image pasting from clipboard support, so we're left with browser detection.
    //
    // JIRA politely puts classes on <html> to identify the browser for us, so let's treat that as our browser detection
    // API. We only care about IE for special casing clipboard behaviour, for all other browsers we'll assume they
    // support the HTML5 clipboard API,
    var classes = document.documentElement.className.split(/\s+/);
    var isIE = Navigator.isIE();
    var gt7 = $.inArray("msie-gt-7", classes) > -1;
    var gt8 = $.inArray("msie-gt-8", classes) > -1;
    var gt9 = $.inArray("msie-gt-9", classes) > -1;
    var gt10 = $.inArray("msie-gt-10", classes) > -1;

    var isIE8  = isIE && gt7 && !gt8;
    var isIE9  = isIE && gt8 && !gt9;
    var isIE10 = isIE && gt9 && !gt10;

    exports.isIE8 = _.once(function(){
      return isIE8;
    });

    exports.isIE9 = _.once(function(){
      return isIE9;
    });

    exports.isIE10 = _.once(function(){
      return isIE10;
    });

});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/resource-uris.js' */
define("dndattachment/ctrlv/resource-uris", [
    "jquery",
    "exports"
], function (
  $,
  exports
) {
    "use strict";

    var dataKey = "com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources.resource-uris";
    var data = WRM.data.claim(dataKey) || {};

    exports.get = function(name) {
        return data[name];
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'templates/soy/attach-screenshot-form.soy' */
// This file was automatically generated from attach-screenshot-form.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Html5Screenshot.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Html5Screenshot == 'undefined') { JIRA.Templates.Html5Screenshot = {}; }


JIRA.Templates.Html5Screenshot.attachScreenshotForm = function(opt_data, opt_ignored) {
  return '<h2 class="dialog-title">' + soy.$$escapeHtml("Attach Screenshot") + '</h2><form action="ShowAttachScreenshotFormAction.jspa" class="aui" method="post" id="attach-screenshot-form" data-attach-secure-token="' + soy.$$escapeHtml(opt_data.attachUserToken) + '" data-submit-secure-token="' + soy.$$escapeHtml(opt_data.submitUserToken) + '"><input type="hidden" name="id" value="' + soy.$$escapeHtml(opt_data.id) + '"/><input type="hidden" name="atl_token" value="' + soy.$$escapeHtml(opt_data.atlToken) + '"><input type="hidden" name="formToken" value="' + soy.$$escapeHtml(opt_data.formToken) + '"><input type="hidden" name="filetoconvert" value=""><div class="attach-screenshot-padding"><div class="attach-screenshot-container"><div id="attach-screenshot-inner-container"><div class="mod-content"><ul class="item-details"><li><dl><dt>' + soy.$$escapeHtml("Take a screenshot:") + '</dt>' + ((opt_data.userPlatform == 'pc') ? '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3ePrtScn\x3c/kbd\x3e") + '</dd>' : '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3e\x26#8963; Ctrl\x3c/kbd\x3e + \x3ckbd\x3e\x26#8984; Cmd\x3c/kbd\x3e + \x3ckbd\x3e\x26#8679; Shift\x3c/kbd\x3e + \x3ckbd\x3e3\x3c/kbd\x3e") + '</dd>') + '</dl></li><li><dl><dt>' + soy.$$escapeHtml("Paste the image:") + '</dt>' + ((opt_data.userPlatform == 'pc') ? '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3eCtrl\x3c/kbd\x3e + \x3ckbd\x3ev\x3c/kbd\x3e") + '</dd>' : '<dd>' + soy.$$filterNoAutoescape("\x3ckbd\x3e\x26#8984; Cmd\x3c/kbd\x3e + \x3ckbd\x3ev\x3c/kbd\x3e") + '</dd>') + '</dl></li></ul></div><input type="text" id="attach-screenshot-fake-input"><div class="attach-screenshot-padding attach-screenshot-padding-inner"><div id="attach-screenshot-image-container" class="attach-screenshot-image-container"><div class="attach-screenshot-placeholder"><div class="mod-content"><ul class="item-details"><li><dl><dt id="attach-screenshot-placeholder-message">' + soy.$$escapeHtml("Your image will be pasted here") + '</dt></dl></li></ul></div></div></div></div><div id=\'attach-max-size\' class="hidden">' + soy.$$escapeHtml(opt_data.maxSize) + '</div></div></div></div><fieldset><div><legend><span>' + soy.$$escapeHtml("Attach Screenshot") + '</span></legend><div id="attach-screenshot-filename-group" class="field-group"><div id="attach-screenshot-progress-container"></div><label for="attachscreenshotname">' + soy.$$escapeHtml("File name") + ' <span class="aui-icon icon-required">' + soy.$$escapeHtml("Required") + '</span></label><input class="text" type="text" id="attachscreenshotname" name="attachscreenshotname" title="File Name" value="' + soy.$$escapeHtml(opt_data.nextScreenshotName) + '"><div class="description">' + soy.$$escapeHtml("A file name to be used as attached image name") + '</div></div></div></fieldset><div class="buttons-container form-footer"><div class="buttons"><button class="aui-button aui-button-primary" id="attach-screenshot-html5-upload">' + soy.$$escapeHtml("Upload") + '</button><a href="#" class="cancel">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form>';
};
if (goog.DEBUG) {
  JIRA.Templates.Html5Screenshot.attachScreenshotForm.soyTemplateName = 'JIRA.Templates.Html5Screenshot.attachScreenshotForm';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/requireDeployJava.js' */
define("dndattachment/ctrlv/requireDeployJava", [
    "jquery",
    "dndattachment/ctrlv/resource-uris",
    "exports"
], function (
  $,
  resourceUris,
  exports
) {
    "use strict";

    var deployJavaPromise = null;

    /**
     * AMD-ish pattern akin to require('deployJava').
     *
     * Oracle provides a JavaScript function -- deployJava -- that makes it easy to install Java in the browser.
     * @returns a jQuery promise that's resolved with two arguments:
     *     - {Function} `deployJava`
     *     - {WindowProxy} the contentWindow where `deployJava` exists.
     */
    exports.requireDeployJava = function () {
        var deferred;

        if (deployJavaPromise !== null) {
            return deployJavaPromise;
        }

        deferred = $.Deferred();
        deployJavaPromise = deferred.promise();

        $('<iframe style="display: none !important; visibility: hidden !important; opacity: 0"/>')
            .attr('src', resourceUris.get("deployJava.html"))
            .one('load', function () {
                deferred.resolve(this.contentWindow.deployJava, this.contentWindow);
            })
            .one('error', deferred.reject.bind(deferred))
            .appendTo('body');

        return deployJavaPromise;
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/polyfill.js' */
define("dndattachment/ctrlv/polyfill", [
    "jquery",
    "underscore",
    "dndattachment/ctrlv/utility",
    "dndattachment/ctrlv/requireDeployJava",
    "dndattachment/ctrlv/resource-uris",
    "dndattachment/ctrlv/path",
    "dndattachment/ctrlv/version",
    "jira/ajs/ajax/smart-ajax",
    "exports"
], function (
  $,
  _,
  utility,
  requireDeployJava,
  resourceUris,
  path,
  version,
  SmartAjax,
  exports
) {
    "use strict";

    var appletNode;

    var pasteImageWidth = 510;
    var pasteImageHeight = 280;
    var dataURILimit = version.isIE8() ? 32000 : Number.MAX_VALUE;

    exports.pasteImageWidth = pasteImageWidth;
    exports.pasteImageHeight = pasteImageHeight;
    exports.dataURILimit = dataURILimit;

    /**
     * Create a rejected jQuery deferred. All arguments are passed to .reject().
     * @returns a jQuery deferred.
     */
    function fail() {
        var deferred = $.Deferred();
        return deferred.reject.apply(deferred, arguments);
    }

    var $node;

    // paste polyfill
    var handleKeydown = function (event) {
        if (utility.isKeyPasteEvent(event)) {
            appletNode.reload();
            var imageUri = appletNode.getClipboardData();
            if (imageUri) {
                var previewImageUri = appletNode.getClipboardData(pasteImageWidth, pasteImageHeight);
                if (previewImageUri.length > dataURILimit) {
                    var f = dataURILimit / previewImageUri.length;
                    previewImageUri = appletNode.getClipboardData(pasteImageWidth * f, pasteImageHeight * f);
                }
                $node.trigger('polyPaste', [imageUri, previewImageUri]);
            }
        }
    };

    /**
     * Use the Java applet to make a HTTP request.
     * @param data
     * @param requestUrl
     * @returns a jQuery deferred that pretends to be a jqXHR. The only addition is a '.abort()' method to try to
     *   conform closer to jqXHR API.
     */
    function executeAjaxUpload(data, requestUrl) {
        var cookies = document.cookies,
          deferred = $.Deferred();

        var xhr = {
            getResponseHeader: function (name) {
                return responseHeaders[name];
            }
        };

        var requestDeferred = new $.Deferred()
          .progress(_.bind(deferred.notify, deferred))
          .done(_.bind(deferred.resolve, deferred))
          .fail(function(error, responseJson) {
              var errorMessage = responseJson || JSON.stringify({ errorMessage: errorMessage });
              deferred.reject(null, null, null, new SmartAjax.SmartAjaxResult(xhr, 0, "error", errorMessage, true));
          });

        appletNode.doMultipartRequest(requestUrl, "UTF-8", window.navigator.userAgent, requestDeferred);
        // Java applets use the browser's cookie storage for URLConnection for non-http-only cookies. This means
        // xsrftoken and other cookies can pollute the browser's.
        deferred.always(function () {
            document.cookies = cookies;
        });
        return deferred;
    }

    /**
     * Install the polyfill to provide clipboard access to non-HTML5 browsers.
     *
     * @param {Element} node Where the 'keydown' event handler should be added.
     * @returns a jQuery promise that's resolved with [deployJava, contentWindow], or rejected
     *   with a [reason, message].
     *
     * Reasons include:
     * - "java-absent" -- Java isn't installed.
     * - "java-version" -- The version Java is not supported.
     * - "java-security" -- Java security settings are blocking the applet. Typically this can be overcome by
     *   lowering the 'Security Level' in Java's 'Control Panel' (e.g. from High to Medium).
     * - "unknown" -- Every other case.
     */
    exports.install = _.once(function (node) {
        $node = $(node);

        return requireDeployJava.requireDeployJava()
            .pipe(function (deployJava, contentWindow) {
                // Unfortunately using deployJava.versionCheck() isn't guaranteed to be accurate. Depending on the
                // platform and JRE. For example Java 1.7.0_06 on IE9 only reports the JRE as 1.7.0 (i.e. no update
                // information).
                // Given that the specific rules/cases/etc are ambiguous, we'll opt for doing a 'best effort' here
                // rather than hard coding a bunch of special case rules that aren't guaranteed to be reliable.
                var attributes,
                    parameters,
                    requiresLegacyApplet,
                    minimumVersion = '1.7.0_06',
                    uri;

                if (deployJava.getJREs().length === 0) {
                    return fail("java-absent");
                } else if (!deployJava.versionCheck(minimumVersion + '+')) {
                    return fail("java-version");
                }

                // Java 1.7.0_45 changed the manifest attributes that are required to allow JavaScript to invoke
                // applet methods. Java 1.7.0_40 and earlier requires the 'Trusted-Library' attribute, but later
                // versions require the 'Caller-Allowable-Codebase' attribute.
                //
                // See https://blogs.oracle.com/java-platform-group/entry/7u45_caller_allowable_codebase_and for more
                // details.
                requiresLegacyApplet = !deployJava.versionCheck('1.7.0_45+');
                uri = resourceUris.get(requiresLegacyApplet ? "clipboard-legacy.jar" : "clipboard.jar");

                attributes = {
                    id: 'JIRA HTML5 Images Applet',
                    codebase: path.dirname(uri),
                    code: "com.atlassian.plugins.jira.screenshot.applet.ScreenshotApplet.class",
                    archive: path.basename(uri),
                    width: 0,
                    height: 0
                };
                parameters = {
                    permissions: "all-permissions"
                };

                deployJava.runApplet(attributes, parameters, minimumVersion);
                appletNode = contentWindow.document.getElementById(attributes.id);

                try {
                    // We need a try/catch here because...
                    // A 'appletNode.isSecurity' doesn't work, because it's falsey on IE. We can use .hasOwnProperty
                    // but it doesn't tell us if it's a function, and 'typeof appletNode.isSecurity' returns
                    // "unknown".
                    if (!appletNode || !appletNode.isSecurityOk()) {
                        return fail("java-security");
                    }
                } catch (e) {
                    return fail("java-security");
                }

                if(! utility.isUnifiedAttachmentsEnabled()){
                    $node.on('keydown', handleKeydown);
                }
                return executeAjaxUpload;
            }, function () {
                return fail("unknown");
            })
            // Add a message to the error.
            .pipe(null, function (reason) {
                var messages;
                if(utility.isUnifiedAttachmentsEnabled()){
                    messages = {
                        "unknown": "A problem occurred while attempting to attach screenshot via Ctrl+V.",
                        "java-version": AJS.format("You need to {0}upgrade Java{1} to be able to attach screenshots via Ctrl+V.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-absent": AJS.format("You need to install {0}Java{1} to be able to attach screenshots via Ctrl+V.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-security": AJS.format("Your Java security settings are blocking the ability to attach screenshots via Ctrl+V. Please upgrade to the latest {0}Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>")
                    }
                } else {
                    messages = {
                        "unknown": "A problem occurred while running Java.",
                        "java-version": AJS.format("You need to {0}upgrade Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-absent": AJS.format("You need to install {0}Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>"),
                        "java-security": AJS.format("Your Java security settings are blocking this feature. Please upgrade to the latest {0}Java{1}.", "<a target=\"_blank\" href=\"//java.com\">", "</a>")
                    }
                }

                return fail(reason, messages[reason]);
            });
    });

    exports.getClipboardData = function(){
        var deferred = new $.Deferred();
        exports.install(document).done(function(){
            try {
                appletNode.reload();
                deferred.resolve(appletNode.getClipboardData());
            } catch(e){
                deferred.reject("A problem occurred while attempting to attach screenshot via Ctrl+V.");
            }
        }).fail(function(reason, message){
            deferred.reject(message);
        });
        return deferred;
    };

    exports.isRequired = function () {
        // Enable the Java applet for IE 8/9/10, assume all other browsers are compatible, since we
        // support latest IE, Chrome, Firefox, and all of these support HTML5 clipboard.
        return version.isIE8() || version.isIE9() || version.isIE10();
    };

    exports.isRequiredForBinaryAjax = function () {
        // The applet has security restrictions on Windows 8 + IE10, so we can't use it there. Luckily IE10 supports
        // AJAX requests with binary data anyway, so we can use that. IE8 and IE9 don't support binary data.
        return version.isIE8() || version.isIE9();
    };

    // proxy ajax request, because session with temporary attachments is in applet
    exports.proxyAjaxRequest = function (fn, userTokenFn) {
        return function () {
            var _smartAjaxMakeRequest = SmartAjax.makeRequest;

            SmartAjax.makeRequest = function (requestOptions) {
                var requestParams = _.reduce(_.keys(requestOptions.data), function (r, name) {
                    r.push(name, requestOptions.data[name]);
                    return r;
                }, []);

                requestParams.push("secureToken", userTokenFn());

                var requestResult = appletNode.doAjaxRequest(requestOptions.url, "UTF-8", window.navigator.userAgent, $.Deferred(), requestParams);
                requestResult.abort = $.noop;
                requestResult.then(function (data) {
                    var responseHeaders = _.filter(arguments, function (el, idx) {
                        return idx > 0;
                    });
                    responseHeaders[0] = "Status";
                    responseHeaders = _.reduce(_.reduce(responseHeaders, function (r, el, idx) {
                        var pdx = (idx / 2) << 0;
                        (r[pdx] || (r[pdx] = [])).push(el);
                        return r;
                    }, []), function (r, el) {
                        r[el[0]] = el[1];
                        return r;
                    }, {});

                    var xhr = {
                        getResponseHeader: function (name) {
                            return responseHeaders[name];
                        }
                    };
                    var textStatus = 'success';
                    var smartAjaxResult = new SmartAjax.SmartAjaxResult(xhr, 0, "success", data, true);
                    requestOptions.complete(xhr, textStatus, smartAjaxResult);
                });

                return requestResult;
            };

            fn.apply(this, arguments);

            SmartAjax.makeRequest = _smartAjaxMakeRequest;
        };
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/html5.js' */
define("dndattachment/ctrlv/html5", [
    "jquery",
    "underscore",
    "dndattachment/ctrlv/polyfill",
    "dndattachment/ctrlv/base64decode",
    "dndattachment/ctrlv/utility",
    "jira/dialog/dialog",
    "jira/dialog/dialog-register",
    "jira/ajs/ajax/smart-ajax",
    "jira/attachment/inline-attach",
    "exports"
], function (
  $,
  _,
  polyfill,
  base64decode,
  utility,
  Dialog,
  DialogRegister,
  SmartAjax,
  InlineAttach,
  exports
) {
    "use strict";

    /**
     * Try to get File Blob from event object, function is asynchronous since on some browsers we may want to
     * implement an workaround for clipboardData.items/files absence
     *
     * @param event JQuery Event object
     * @returns {$.Deferred}
     */
    exports.getFileFromEvent = function (event) {
        var deferred = new $.Deferred();

        if (utility.isImagePasteEvent(event)) {
            // look for image content in items and files, check mimetype and return the first one
            deferred.resolve(
                _(event.clipboardData.items)
                    .filter(function (item) {
                        return item.type.indexOf("image") !== -1;
                    }).map(function (item) {
                        return item.getAsFile();
                    })[0] ||
                    // according to bugzilla in future Mozilla will support this via files:
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=891247
                _(event.clipboardData.files)
                    .filter(function (item) {
                        return item.type.indexOf("image") !== -1;
                    })[0]);
        } else {
            deferred.reject();
        }

        return deferred.promise();
    };

    //exports.screenshotPasteHandler = {
    exports.REQUEST_TIMEOUT_MILLIS = 5 * 60 * 1000;

    exports.screenshotFileUpload = {};
    exports.screenshotFileUploadUri = null;

    exports.$document = undefined;
    exports.$window = undefined;
    exports.$container = undefined;
    exports.$fakeInput = undefined;

    exports.uploadError = false;
    exports.uploadErrorMsg = "";

    exports.progressView = {
        hidden: false,
        progress: 0,
        old: 0,
        progressBarContainer: undefined,
        progressEl: undefined,
        container: undefined,
        options: undefined,
        staticProgress: undefined,

        initProgress: function () {
            this.container = this.buildContainer();
            this.progressEl = this.buildProgress();
            this.container.append(this.progressEl);

            this.options = {showPercentage: false, height: "5px"};

            this.progressBarContainer = $("#attach-screenshot-progress-container");
            this.progressBarContainer.empty();
            this.progressBarContainer.append(this.container);

            this.staticProgress = this.container;
            this.hidden = true;
        },

        finish: function () {
            this.value(100);
        },

        progressHandler: function (event) {
            var percentage = Math.round(event.loaded * 100 / event.total);
            this.value(percentage);
        },

        value: function (value) {
            if (value > 100) {
                value = 100;
            } else if (value < 0) {
                value = 0;
            }

            if (this.hidden) {
                this.progressEl.show();
                this.hidden = false;
            }

            if (this.old !== value) {
                this.progressEl.progressBar(value, this.options);
                if (value >= 100) {
                    this.progressEl.fadeOut();
                }
                this.old = value;
            }
        },

        buildContainer: function () {
            return $("<div>").addClass("file-progress");
        },

        buildProgress: function () {
            return $("<div>").attr("id", "attach-screenshot-upload-progress");
        }
    };

    exports.dialogView = {
        pasteCatcher: {},
        presenter: undefined,

        getMaxSize: function () {
            return $("#attach-max-size").text();
        },

        getFileSize: function () {
            if ($.isPlainObject(this.presenter.screenshotFileUpload) && _.isEmpty(this.presenter.screenshotFileUpload)) {
                return 0;
            }
            return this.presenter.screenshotFileUpload.size || this.presenter.screenshotFileUpload.byteLength || this.presenter.screenshotFileUpload.length;
        },

        cleanGeneralErrors: function () {
            $("#error-attach-screenshot-image").closest(".field-group").remove();
        },

        cleanFileErrors: function () {
            $("#error-attach-screenshot-filename").remove();
        },

        displayErrors: function (errors) {
            if(utility.isUnifiedAttachmentsEnabled()){
                if ("compatibility" in errors) {
                    utility.showErrorMsg("", errors["compatibility"]);
                }
                if ("fileName" in errors) {
                    utility.showErrorMsg("", errors["fileName"]);
                }
                if ("fileUpload" in errors) {
                    utility.showErrorMsg("", errors["fileUpload"]);
                }
            }
            else{
                // cleanup old error messages
                exports.dialogView.cleanFileErrors();
                exports.dialogView.cleanGeneralErrors();

                if ("compatibility" in errors) {
                    $("#attach-screenshot-inner-container").before(aui.message.error({
                        content: errors["compatibility"]
                    }));
                }
                if ("fileName" in errors) {
                    $("#attach-screenshot-filename-group").append("<div class=\"error\" id=\"error-attach-screenshot-filename\" data-field=\"attachscreenshotname\"></div>").find('.error').text(errors["fileName"]);
                }
                if ("fileUpload" in errors) {
                    $("#attach-screenshot-inner-container").append("<div class=\"field-group attach-screenshot-image-error\"><div class=\"error\" id=\"error-attach-screenshot-image\"></div></div>").find('.error').text(errors["fileUpload"]);
                }
            }
        },

        appendBlobImage: function (blob) {
            // and use a URL or webkitURL (whichever is available to the browser)
            // to create a temporary URL to the object
            var URLObj = window.URL || window.webkitURL;
            var source = URLObj.createObjectURL(blob);
            this.presenter.screenshotFileUpload = blob;
            this.createImage(source);
        },

        /**
         * Creates and shows image
         * Supports:
         *  Chrome binary data from Webkit
         *  base64 encoded data from FireFox
         * @param uri image data
         */
        createImage: function (uri) {
            var pastedImage = new Image();
            pastedImage.onload = function () {
                // You now have the image!
            };
            pastedImage.src = uri;

            this.presenter.screenshotToUpload = pastedImage;

            // Appending image to document
            var jqueryImage = $(pastedImage);
            jqueryImage.addClass("attach-screenshot-pasted-image");
            var screenshotContainer = $("#attach-screenshot-image-container");
            screenshotContainer.empty();
            screenshotContainer.append(jqueryImage);

            this.presenter.$fakeInput.focus();

            // handle async upload
            // IE11 quirk: if this is called within onPaste handler, browser will throw "Access denied" on any XHR
            _.defer(function () {
                exports.imageCreatedHandler();
            });

        },

        /**
         * Parse the input in the paste catcher element
         */
        checkInput: function () {
            var image,
              node = exports.dialogView.pasteCatcher.childNodes[0];

            if (node) {
                // If the user pastes an image, the src attribute
                // will represent the image as a base64 encoded string.
                if ("IMG" === node.tagName) {
                    // does not start with data, try to get contents via canvas
                    if (node.src.indexOf("data:") === 0) {
                        image = node.src;
                    } else {
                        // we could use canvas and toDataURL here, but it is not allowed by browser:
                        // https://html.spec.whatwg.org/multipage/scripting.html#dom-canvas-todataurl
                    }
                }

                // Clear the inner html to make sure we're always getting the latest inserted content.
                exports.dialogView.pasteCatcher.innerHTML = "";
            }

            if (!image) {
                exports.$fakeInput.focus();
            }

            return image;
        },

        /**
         * onPaste handler, Either uses webkits clipboardData object on the paste event, or interprets
         * the data uri that has been embedded in the page by firefox.
         */
        onPaste: function (event) {
            exports.dialogView.cleanFileErrors();
            exports.dialogView.cleanGeneralErrors();

            // TODO: ensure target is not text fields - this prevents pasting text in text fields

            // We need to check if event contains image content we can use
            if (utility.isImagePasteEvent(event)) {
                // Get the items from the clipboard
                exports.getFileFromEvent(event).then(function (file) {
                    this.appendBlobImage(file);
                }.bind(this));
                // If we can't handle clipboard data directly (Firefox),
                // we need to read what was pasted from the contenteditable element
            } else {
                setTimeout(function () {
                    var image = this.checkInput();

                    if (image) {
                        // Firefox image is base64 encoded - decoding while setting up the data
                        exports.screenshotFileUpload = base64decode.decodeBase64DataUri(image);
                        exports.dialogView.createImage(image);
                    }

                }.bind(this), 0);
            }
        },

        getFakeInput: function () {
            return $("#attach-screenshot-fake-input");
        },

        getContainer: function () {
            return $("#attach-screenshot-image-container");
        },

        getIssueKey: function () {
            return $("input[name='id']").val();
        },

        getDocument: function () {
            return $(document);
        },

        getWindow: function () {
            return $(window);
        },

        getFileNameInput: function () {
            return $("#attachscreenshotname");
        },

        hasPngExtension: function (str) {
            var pattern = /\.png$/i; // REGEX: Ends with ".png". Case insensitive
            return pattern.test(str);
        },

        setFileToConvert: function (value) {
            $("input[name='filetoconvert']").val(value);
        },

        /**
         * Pasting into a content-editable element is the most cross-browser HTML5 approach.
         */
        buildPasteCatcher: function () {
            if (!document.getElementById("attach-screenshot-form")) return;
            var catcher = document.createElement("div");
            catcher.setAttribute("contenteditable", "true");
            catcher.style.width = 0;
            catcher.style.height = 0;
            /* make sure the catcher is rendered outside the browser view to prevent vertical scrollbars */
            catcher.style.position = 'absolute';
            catcher.style.top = '-5000px';
            document.getElementById("attach-screenshot-form").appendChild(catcher);
            return catcher;
        },

        _getFormSubmits: function () {
            return $("#attach-screenshot-form").find("button.aui-button");
        },

        disable: function () {
            this._getFormSubmits().attr("disabled", "disabled");
            return this;
        },
        enable: function () {
            this._getFormSubmits().removeAttr("disabled");
            return this;
        },
        isEnabled: function () {
            return this.isVisible() && !this._getFormSubmits().attr("disabled");
        },

        isVisible: function () {
            return $("#attach-screenshot-form").length > 0;
        },

        initDialog: function (presenter) {
            this.pasteCatcher = {};
            this.presenter = presenter;

            if (!polyfill.isRequired()) {
                this.pasteCatcher = this.buildPasteCatcher();
            }
        }
    };

    exports.initScreenshotPasteHandler = function () {
        var dialogView = exports.dialogView;

        exports.screenshotFileUpload = {};
        exports.resetUploadErrors();

        exports.dialogView.initDialog(exports);

        // Caching elements needed to fix tabbing
        exports.$document = dialogView.getDocument();
        exports.$window = dialogView.getWindow();
        exports.$container = dialogView.getContainer();
        exports.$fakeInput = dialogView.getFakeInput();

        // Event Handlers
        exports.bindOnce(exports.$container, "click", exports.setFocusOnClickHandler);
        exports.bindOnce(exports.$fakeInput, "focus", exports.showFocusOnFieldHandler);
        exports.bindOnce(exports.$fakeInput, "blur", exports.hideFocusOnFieldHandler);
        exports.bindOnce(exports.$fakeInput, "keydown", exports.keyDownHandler);

        if (!utility.browserIsSupported()) {
            dialogView.displayErrors({"compatibility": AJS.format("Your browser is not supported. Consider using an alternative supported browser such as {0}Google Chrome{1} or {2}Firefox{3}.", "<a href=\"//www.google.com/chrome/browser/\">", "</a>", "<a href=\"//www.mozilla.org/firefox/\">", "</a>")});
        } else if (polyfill.isRequired()) {
            polyfill.install(document)
              .done(function (executeAjaxUploadFromApplet) {
                  exports.bindOnce(exports.$document, "polyPaste", exports.polyPasteHandler);
                  if (polyfill.isRequiredForBinaryAjax()) {
                      exports.executeAjaxUpload = executeAjaxUploadFromApplet;
                  }
              })
              .fail(function (reason, message) {
                  dialogView.displayErrors({"compatibility": message});
              });
        } else {
            exports.bindOnce(exports.$window, "paste", exports.pasteHandler);
        }
    };

    exports.resetUploadErrors = function () {
        exports.uploadError = false;
        exports.uploadErrorMsg = undefined;
    };

    exports.setUploadError = function (errorMsg) {
        exports.uploadError = true;
        exports.uploadErrorMsg = errorMsg;
    };

    /**
     * Ensures only one event is bound to the element
     * @param jqueryEl
     * @param eventName
     * @param handler
     */
    exports.bindOnce = function (jqueryEl, eventName, handler) {
        jqueryEl.unbind(eventName, handler);
        jqueryEl.bind(eventName, handler);
    };

    exports.showFocusOnFieldHandler = function () {
        exports.$container.addClass("focus");
    };

    exports.hideFocusOnFieldHandler = function () {
        exports.$container.addClass("focus");
    };

    exports.setFocusOnClickHandler = function () {
        exports.$fakeInput.focus();
    };

    exports.pasteHandler = function (event) {
        if (!exports.dialogView.isEnabled()) {
            return;
        }
        event = utility.normalizePasteEvent(event);

        exports.dialogView.onPaste(event);
    };

    exports.polyPasteHandler = function (event, imageUri, imagePreviewUri) {
        if (!exports.dialogView.isEnabled()) {
            return;
        }

        exports.screenshotFileUpload = {length: -1};
        exports.screenshotFileUploadUri = imageUri;
        exports.dialogView.createImage(imagePreviewUri);
    };

    exports.keyDownHandler = function (event) {
        if (utility.isKeyPasteEvent(event)) {
            if (exports.dialogView.pasteCatcher.focus) {
                exports.dialogView.pasteCatcher.focus();
            }
        }
    };

    exports.imageCreatedHandler = function () {
        exports.doAjaxUpload(this.dialogView.getIssueKey(), this.dialogView.getFileNameInput().val());
    };

    exports.getMimeType = function () {
        if (polyfill.isRequired()) {
            return "image/jpeg";
        }
        return "image/png";
    };

    exports.createData = function () {
        if (polyfill.isRequired() && !polyfill.isRequiredForBinaryAjax() && !utility.isUnifiedAttachmentsEnabled()) {
            return base64decode.decodeBase64DataUri(exports.screenshotFileUploadUri);
        }
        return exports.screenshotFileUpload;
    };

    // TODO function is not called delete?
    exports.clipboardDataIsEmpty = function (event) {
        // Internet Explorer will fire paste event for anything but image content, therefore we can assume that such event is not empty
        if (window.clipboardData != null) {
            return false;
        }

        return !(event && event.clipboardData && event.clipboardData.types && event.clipboardData.types.length > 0);
    };

    exports.validateFileSize = function (errors, fileSize, maxSize) {
        var fileSize = fileSize || exports.dialogView.getFileSize();
        var maxSize = maxSize || exports.dialogView.getMaxSize();
        if (fileSize > maxSize) {
            //TODO: hack, using IninleAttach module, check if this a blessed way to go
            var sizes = InlineAttach.Text.fileSize(maxSize, fileSize);
            errors["fileUpload"] = AJS.format("Screenshot is too large to attach. Attachment is {0} but the largest allowed attachment is {1}.", sizes[1], sizes[0]);
        }
    };

    exports.validateFormData = function (fileUpload, fileName) {
        var errors = {};

        if ($.isPlainObject(fileUpload) && _.isEmpty(fileUpload)) {
            errors["fileUpload"] = "Please paste the image you wish to upload";
        }
        exports.validateFileSize(errors);
        if (exports.uploadError) {
            errors["fileUpload"] = "The error occurred during image upload - you will need to try the pasting image again. Sorry for the inconvenience.";
        }

        if ("" == fileName) {
            errors["fileName"] = "You must specify a filename of the image.";
        }

        if (!utility.isValidFileName(fileName)) {
            errors["fileName"] = "Filename must not contain the characters \'\\\', \'/\', \'\"\', \':\', \'?\', \'*\', \'\u003c\', \'|\', \'\u003e\', \'!\'";
        }
        return errors;
    };

    exports.doAjaxUpload = function (issueKey, fileName) {
        exports.dialogView.disable();

        var errors = {};
        exports.validateFileSize(errors);
        if (!_.isEmpty(errors)) {
            exports.dialogView.displayErrors(errors);
            exports.dialogView.enable();

            // Prevent form from uploading
            return;
        }

        var data = exports.createData(),
          mimeType = exports.getMimeType(),
          secureToken = $("#attach-screenshot-form").data("attach-secure-token"),
          formToken = $("#attach-screenshot-form").find("input[name='formToken']").attr('value');

        var requestUrl = AJS.contextPath() + "/rest/internal/1.0/AttachTemporaryFile" +
          (polyfill.isRequired() ? "/secure?" : "?") +
          "size=" + exports.dialogView.getFileSize() + "&" +
          "filename=" + encodeURIComponent(fileName) + "&" +
          "atl_token=" + encodeURIComponent(atl_token()) + "&" +
          "issueId=" + encodeURIComponent(this.dialogView.getIssueKey()) +
          (secureToken ? ("&secureToken=" + encodeURIComponent(secureToken)) : "") +
          (formToken ? ("&formToken=" + encodeURIComponent(formToken)) : "");

        exports.resetUploadErrors();
        exports.executeAjaxUpload(data, requestUrl, mimeType).progress(function (val) {
            if (val == 'init') {
                exports.progressView.initProgress();
            }
        }).done(function (val) {
            if (typeof val == "string") {
                val = JSON.parse(val);
            }

            exports.dialogView.setFileToConvert(val.id);
        }).fail(function (jqXHR, textStatus, msg, smartAjaxResult) {
            var errMsg;
            if (smartAjaxResult.statusText == "abort") {
                errMsg = "The call to the JIRA server did not complete within the timeout period.  We are unsure of the result of this operation.";
            } else if (smartAjaxResult.hasData) {
                var data = JSON.parse(smartAjaxResult.data);

                if (data.errorMessage) {
                    errMsg = data.errorMessage;
                } else {
                    errMsg = SmartAjax.buildSimpleErrorContent(smartAjaxResult, {alert: false});
                }
            }
            exports.setUploadError(errMsg);
            exports.dialogView.displayErrors({"fileUpload": errMsg});
        }).always(function () {
            var deferred = $.Deferred();

            // polyfill is required so we need a new secureToken
            if (polyfill.isRequired()) {
                exports.reloadSecureToken(deferred);
            } else {
                deferred.resolve();
            }

            deferred.then(function () {
                exports.dialogView.enable();
                // Progress Listener cleanup
                exports.progressView.finish();
            });
        }).progress(function (val) {
            if (val != 'init') {
                exports.progressView.progressHandler(val);
            }
        });
    };

    exports.executeAjaxUpload = function (data, requestUrl, mimeType) {
        var deferred = $.Deferred();

        var xhr = SmartAjax.makeRequest({
            type: 'POST',
            url: requestUrl,
            contentType: mimeType,
            processData: false,
            data: data,
            timeout: exports.REQUEST_TIMEOUT_MILLIS,
            success: deferred.resolve.bind(deferred),
            error: deferred.reject.bind(deferred),
            xhr: function () {
                var xhr = $.ajaxSettings.xhr();

                deferred.notify('init');
                xhr.upload.addEventListener("progress", deferred.notify.bind(deferred));
                return xhr;
            }
        });

        deferred.always(function () {
            $.ajaxSettings.xhr().removeEventListener("progress", exports.progressView.progressHandler);
            $(DialogRegister.attachScreenshotDialog).off("Dialog.hide", xhr.abort);
        });

        // cancel upload on dialog hide
        $(DialogRegister.attachScreenshotDialog).one("Dialog.hide", xhr.abort);

        return deferred.promise();
    };

    exports.reloadSecureToken = function (deferred) {
        var formUrl = AJS.contextPath() + "/secure/ShowAttachScreenshotFormAction!default.jspa?" +
          "id=" + encodeURIComponent(this.dialogView.getIssueKey()) +
          "&inline=true&decorator=dialog&_=" + (new Date().getTime());

        $.get(formUrl).then(function (response) {
            var newToken = $(response).find("#attach-screenshot-form").data("attach-secure-token");
            if (newToken) {
                $("#attach-screenshot-form").data("attach-secure-token", newToken);
                deferred.resolve(newToken);
            } else {
                deferred.reject();
            }
        }, _.bind(deferred.reject, deferred));
    };

    /**
     * Trigger Attach Screenshot dialog and resolve deferred once it is open
     *
     * @returns {$.Deferred}
     */
    exports.show = function () {
        var deferred = new $.Deferred();
        var $dialogTrigger = $(".issueaction-attach-screenshot-html5.aui-list-item-link");

        // Such situation is not supported yet
        // TODO remove once we add support for textfields in create issue dialog (temporary attachments problem)
        if (Dialog.current != null) {
            return deferred.reject().promise();
        }

        // trigger is not available
        // TODO refactor when we start supporting create issue dialog
        if ($dialogTrigger.length == 0) {
            return deferred.reject().promise();
        }

        // IE11 quirk: if this is called within onPaste handler, browser will throw "Access denied" on any XHR
        _.defer(function () {
            $dialogTrigger.trigger("click");
        });

        $(document).on("dialogContentReady", function (event, dialog) {
            if (dialog === DialogRegister.attachScreenshotDialog &&
              exports.dialogView.isEnabled()) {
                deferred.resolve(dialog);
            } else {
                deferred.reject();
            }
        });

        // each impression of dialog causes ajax request, reject deferred if there was request for dialog content, but after some brief time deferred was still not resolved
        $(document).on("ajaxComplete.jira.screenshot.dialog", function (event, jqXhr, options) {
            if (options.url.indexOf($dialogTrigger.attr("href")) > -1) {
                setTimeout(function () {
                    if (!deferred.isResolved()) {
                        deferred.reject();
                    }
                }, 1000);
            }
        });

        // unbind from ajaxComplete
        deferred.always(function () {
            $(document).off("ajaxComplete.jira.screenshot.dialog");
        });

        return deferred.promise();
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/issue-paste.js' */
define("dndattachment/ctrlv/issue-paste", [
    "jquery",
    "dndattachment/ctrlv/trace",
    "dndattachment/ctrlv/tracking",
    "dndattachment/ctrlv/utility",
    "dndattachment/ctrlv/html5",
    "dndattachment/ctrlv/polyfill",
    "dndattachment/ctrlv/base64decode",
    "jira/dialog/dialog",
    "jira/util/events",
    'dndattachment/util/events/types',
    "exports"
], function (
  $,
  trace,
  tracker,
  utility,
  html5,
  polyfill,
  base64decode,
  Dialog,
  Events,
  EventTypes,
  exports
) {
    "use strict";

    /** Ze State Machine **/

    // Event types
    var EVENT_WINDOW_KEYDOWN = 0;
    var EVENT_WINDOW_PASTE = 1;

    var EVENT_FILE_LOADED = 2;
    var EVENT_FILE_LOAD_ERROR = 3;

    var EVENT_IMAGE_LOADED = 4;
    var EVENT_IMAGE_LOAD_ERROR = 5;

    var EVENT_DIALOG_LOADED = 6;
    var EVENT_DIALOG_CLOSED = 7;
    var EVENT_DIALOG_CANCELED = 8;

    var EVENT_TIMEOUT = 9;
    /**
     * Stub function, does nothing, in future may wrap states in some default behavior
     * @param {Function} state
     * @returns {State}
     * @constructor
     */
    function State(stateName, state) {
        state.stateName = stateName;
        var result = function() {
            var handler = state.apply(null, arguments);
            handler.stateName = stateName;
            return handler;
        };
        result.stateName = stateName;

        return result;
    }

    /**
     * Wraps given state, so that it will receive EVENT_TIMEOUT event after given timeout
     * @param {Function} state
     * @param {Number} timeout in milliseconds
     * @returns {WeakState}
     * @constructor
     */
    function WeakState(stateName, state, timeoutDelay) {
        return State(stateName, function() {
            var timeout = setTimeout(function() {
                triggerEvent(EVENT_TIMEOUT);
            }, timeoutDelay);

            var handler = state.apply(null, arguments);
            var result = function(eventType, eventObject) {
                var result = handler(eventType, eventObject);
                // we will change state, so clear timeout
                if(result) {
                    clearTimeout(timeout);
                    return result;
                }
            };
            result.stateName = stateName;

            return result;
        });
    }

    /**
     * Idle state, initial
     */
    var StateIdle = State("idle", function() {

        function isValidTarget(event) {
            // - don't play with catching paste events on any input elements other than wiki-textfield
            // - ignore content editable, because it will rather handle paste on its own
            // - summary field is an exception, because it is focused by default in create issue dialog
            if($(event.target).is(':input:not(.wiki-textfield, #summary)') || utility.isContentEditable(event.target)) {
                return;
            }

            return true;
        }


        return function(eventType, eventObject) {
            // We have this just in case something goes wrong after OD deployment
            if(utility.isIssuePasteDisabledEnabled()) {
                trace("jira/attach-images-plugin/issuePasteDisabled");
                return;
            }

            if(eventType == EVENT_WINDOW_KEYDOWN && utility.isKeyPasteEvent(eventObject)) {
                // in chrome we rely 100% on onPaste event, in Safari we don't want to make any attempts on catching clipboard data
                if (utility.browserIsNativePaste() || !isValidTarget(eventObject) || !utility.browserIsSupported()) {
                    return;
                }

                tracker.trigger("attach.screenshot.html5.catchClipboard");

                return new StateCatchClipboard(eventObject);
            }

            if(eventType == EVENT_WINDOW_PASTE) {
                if(utility.isImagePasteEvent(eventObject)) {
                    tracker.trigger("attach.screenshot.html5.handlePaste");

                    if(!isValidTarget(eventObject)) {
                        trace("jira/attach-images-plugin/pasteIgnored");
                        return;
                    }

                    /** Prevent paste now so after pressing cancel in dialog selected fragment in textarea won't be removed */
                    if($(eventObject.target).is(':input.wiki-textfield')) {
                        eventObject.preventDefault();
                    }

                    return new StateFileLoading(eventObject);
                } else {
                    trace("jira/attach-images-plugin/pasteIgnoredNotImage");
                }
            }
        }
    });

    /**
     * Catch clipboard contents after CTRL+V
     * @param {Event} keyPasteEvent
     */
    var StateCatchClipboard = WeakState("catchClipboard", function(keyPasteEvent) {
        // we will switch focus from currently active element, but we want to restore it once we are done with this state
        var activeElement = document.activeElement;

        // preserve initial selection information for later use
        keyPasteEvent.selectionStart = keyPasteEvent.target.selectionStart;
        keyPasteEvent.selectionEnd = keyPasteEvent.target.selectionEnd;

        var $contentEditable = $('<div contenteditable="true" class="attach-screenshot-paste-catcher"></div>').appendTo('body');

        // focus on content editable, so the paste event will go into this element and we will get content from it (possible an image)
        $contentEditable.focus();

        // we rely on :focusable or :aui-focusable selector from AUI, we don't want to refocus on non focusable elements, because
        // it may cause unnecessary scroll
        // also focus only on input input elements
        if($(activeElement).is(':focusable:input,:aui-focusable:input')) {
            // this quirk is required for FF, otherwise it will bug cursor
            setTimeout(function() {
                activeElement.focus();
            });
        }

        // TODO refactor this, so we won't need to call this each time we want to leave this state
        function cleanUp() {
            $contentEditable.remove();
        }

        return function(eventType, eventObject) {
            if(eventType == EVENT_WINDOW_PASTE) {
                if(utility.isImagePasteEvent(eventObject)) {
                    cleanUp();

                    eventObject.target = activeElement;
                    return new StateFileLoading(eventObject);
                }

                if(utility.isHtmlImagePasteEvent(eventObject)) {
                    cleanUp();

                    eventObject.target = activeElement;
                    return new StateImageLoading(eventObject);
                }

                if(utility.isTextPasteEvent(eventObject)) {
                    cleanUp();

                    var text1 = utility.getTextPasteContent(eventObject);
                    utility.insertToInput(text1, keyPasteEvent.target, keyPasteEvent.selectionStart, keyPasteEvent.selectionEnd);

                    // This is required for consistent behavior, IE requires preventDefault, while others don't
                    eventObject.preventDefault();

                    return new StateIdle();
                }
            }

            if(eventType == EVENT_TIMEOUT) {
                cleanUp();

                var $img = $contentEditable.find('>img');
                if($img.is(':only-child')) {
                    var imgSrc = $img.attr("src");
                    if (imgSrc.toLowerCase().indexOf("http") === 0) {
                        // we could use canvas and toDataURL here, but it is not allowed by browser:
                        // https://html.spec.whatwg.org/multipage/scripting.html#dom-canvas-todataurl
                        return StateIdle();
                    }
                    else {
                        var array = base64decode.decodeBase64DataUri(imgSrc);
                        var blob = new Blob([array], {type: "image/png"});

                        return new StateAttachImage(blob, keyPasteEvent);
                    }
                } else {
                    // special handling for IE10
                    if(polyfill.isRequired() && !$contentEditable.text()){
                        // if we are here, we know:
                        // - user pressed Ctrl+v while not in a text field
                        // - the clipboard does not contain text (if it did it would have been handled elsewhere)
                        // this is a good place to attempt to load the java applet.
                        // We are not certain the user is trying to paste an image,
                        // but if not they can just choose not to load the applet.
                        return new StateAppletLoading(keyPasteEvent);
                    }
                    else {
                        // there was no image paste, so we need to reinsert pasted text into text input
                        var text2 = utility.getTextContent($contentEditable[0]);
                        utility.insertToInput(text2, keyPasteEvent.target, keyPasteEvent.selectionStart, keyPasteEvent.selectionEnd);

                        return StateIdle();
                    }
                }
            }
        }
    });

    var StateAppletLoading = State("appletLoading", function(keyPasteEvent) {
        polyfill.getClipboardData().done(function(imgUri){
            var array = base64decode.decodeBase64DataUri(imgUri);
            var blob = new Blob([array], {type: "image/jpeg"});
            triggerEvent(EVENT_IMAGE_LOADED, blob);
        }).fail(function(message){
            utility.showErrorMsg("", message);
            triggerEvent(EVENT_IMAGE_LOAD_ERROR);
        });

        return function(eventType, blob){
            if(eventType == EVENT_IMAGE_LOADED){
                return new StateAttachImage(blob, keyPasteEvent);
            }
            if(eventType == EVENT_IMAGE_LOAD_ERROR) {
                return new StateIdle();
            }
        }
    });

    /**
     * Load File from image, this state is not weak, because we expect file loading to take some time
     * @param {Event} pasteEvent that contains text/html in clipboardData
     */
    var StateImageLoading = State("imageLoading", function(pasteEvent) {
        var imageSrc = utility.getHtmlImagePaste(pasteEvent);
        if(!imageSrc) {
            triggerEvent(EVENT_IMAGE_LOAD_ERROR);
        } else {
            utility.loadImage(imageSrc).then(function(image) {
                triggerEvent(EVENT_IMAGE_LOADED, image);
            }, triggerEvent.bind(null, EVENT_IMAGE_LOAD_ERROR));
        }

        return function(eventType, eventObject) {
            if(eventType == EVENT_IMAGE_LOADED) {
                var file = utility.convertImageToBlob(eventObject);

                if(file) {
                    return new StateAttachImage(file, pasteEvent);
                } else {
                    return new StateIdle();
                }
            }

            if(eventType == EVENT_TIMEOUT || eventType == EVENT_IMAGE_LOAD_ERROR) {
                return new StateIdle();
            }
        }
    });

    /**
     * Handle paste event, get file open attach screenshot dialog
     * @param {Event} pasteEvent
     */
    var StateFileLoading = WeakState("fileLoading", function(pasteEvent) {
        html5.getFileFromEvent(pasteEvent).done(function (file) {
            triggerEvent(EVENT_FILE_LOADED, file);
        }).fail(function () {
            triggerEvent(EVENT_FILE_LOAD_ERROR);
        });

        return function(eventType, eventObject) {
            if (eventType == EVENT_FILE_LOADED) {
                return new StateAttachImage(eventObject, pasteEvent);
            } else if (eventType == EVENT_FILE_LOAD_ERROR || eventType == EVENT_TIMEOUT) {
                return new StateIdle();
            }
        }
    }, 1000);

    var StateAttachImage = State("attachImage", function(file, pasteEvent) {
        var pasteTarget =  pasteEvent.target;
        var screenshotName = utility.generateFileName() + (polyfill.isRequired() ? ".jpg" : ".png");

        var pastedImage = utility.convertBlobToImage(file, screenshotName);

        Events.trigger(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, {
            files: [pastedImage],
            // We want the attachment executor to know if a wiki textfield is in focus
            // so that the executor can then decide whether it wants to perform its action.
            isWikiTextfieldFocused: utility.isWikiTextfield($(pasteTarget)),
            wikiTextfield: pasteTarget,
            // Tell the dropzone whether the files came from a paste or from an actual drag and drop
            isPaste: true,
            successCallback: function() {
                triggerEvent(EVENT_DIALOG_LOADED)
            }
        });

        return function(eventType, eventObject) {
            return new StateIdle();
        };
    });

    /**
     * Current state, which will receive next event, initilized with {StateIdle}
     * @type {State}
     */
    var currentState = new StateIdle();

    /**
     * Trigger current state with given parameters
     * @param {Number} eventType
     * @param {Object} eventObject
     */
    function triggerEvent(eventType, eventObject) {
        // some states may call this function during initialization, therefore there is a need to queue such events
        // in order to avoid nested executions
        if(triggerEvent.eventQueue) {
            triggerEvent.eventQueue.push({ type: eventType, object: eventObject });
            return;
        }

        triggerEvent.eventQueue = [{ type: eventType, object: eventObject }];

        while(triggerEvent.eventQueue.length > 0) {
            var event = triggerEvent.eventQueue.splice(0, 1)[0];
            var newState = currentState(event.type, event.object);
            if(newState) {
                currentState = newState;
            }
        }

        delete triggerEvent.eventQueue;
    }

    /**
     * Required for tests
     */
    exports._getStateMap = function() {
        return {
            events: {
                EVENT_WINDOW_KEYDOWN: EVENT_WINDOW_KEYDOWN,
                EVENT_WINDOW_PASTE: EVENT_WINDOW_PASTE,

                EVENT_FILE_LOADED: EVENT_FILE_LOADED,
                EVENT_FILE_LOAD_ERROR: EVENT_FILE_LOAD_ERROR,

                EVENT_IMAGE_LOADED: EVENT_IMAGE_LOADED,
                EVENT_IMAGE_LOAD_ERROR: EVENT_IMAGE_LOAD_ERROR,

                EVENT_DIALOG_LOADED: EVENT_DIALOG_LOADED,
                EVENT_DIALOG_CLOSED: EVENT_DIALOG_CLOSED,
                EVENT_DIALOG_CANCELED: EVENT_DIALOG_CANCELED,

                EVENT_TIMEOUT: EVENT_TIMEOUT
            },
            states: {
                StateIdle: StateIdle,
                StateCatchClipboard: StateCatchClipboard,
                StateAppletLoading: StateAppletLoading,
                StateImageLoading: StateImageLoading,
                StateFileLoading: StateFileLoading,
                StateAttachImage: StateAttachImage
            }
        }
    };

    exports.initIssuePaste = function () {
        // handle CTRL+V on wiki textfields
        $(window).on('keydown', function (event) {
            triggerEvent(EVENT_WINDOW_KEYDOWN, event);
        });
        $(window).on("paste", function (event) {
            triggerEvent(EVENT_WINDOW_PASTE, utility.normalizePasteEvent(event));
        });
        Events.bind("Dialog.hide", function (event, $popup, reason) {
            if (reason) {
                triggerEvent(EVENT_DIALOG_CANCELED, $popup);
            } else {
                triggerEvent(EVENT_DIALOG_CLOSED, $popup);
            }
        });
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/trace.js' */
define("dndattachment/ctrlv/trace", [], function () {
  "use strict";
  // tests often redefine JIRA.trace this avoid grabbing a stale version
  return function amdJiraTrace() {
    return JIRA.trace.apply(undefined, arguments);
  };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/tracking.js' */
define("dndattachment/ctrlv/tracking", [
  "exports"
], function (
  exports
) {
  "use strict";
  exports.trigger = function (analyticKey, payload) {
    AJS.trigger("analytics", {name: analyticKey, data: payload || {}});
  };
});

;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/executor.js' */
define("dndattachment/ctrlv/executor", [
    "jquery",
    "jira/util/events",
    "dndattachment/ctrlv/html5",
    "dndattachment/upload/handler",
    "exports"
], function (
    $,
    Events,
    html5,
    DnDUploadHandler,
    exports
) {

    exports.register = function () {
        /*
         * This executor spawns the attach screenshot dialog and is only valid if user pastes an attachment via ctrlv.
         */
        var ctrlvExecutor = {
            name: 'JIRA Ctrl+V attachment executor',
            // This weight is higher than the default executor (weight 0) and lower than the ServiceDesk executor (weight 50)
            weight: 5,
            isValid: function (event, args) {
                return !!args.isPaste;
            },
            processFiles: function (files, attachmentDropZone) {
                var deferred = $.Deferred();
                html5.show().done(function (dialog) {
                    var $el = $("#attach-screenshot-placeholder-message");
                    var evt = $.Event("paste");
                    evt.clipboardData = {files: files};
                    $el.focus();
                    setTimeout(function() {
                        $el.trigger(evt)
                    });

                    Events.bind("Dialog.hide", function (event, $popup, reason) {
                        if (reason) {
                            deferred.reject();
                        }
                        else {
                            // If there is no reason, then we know the file was uploaded successfully.
                            deferred.resolve([$popup.find('#attachscreenshotname').val() + '.png']);
                        }
                    });
                });

                return deferred;
            }
        };

        DnDUploadHandler.registerExecutor(ctrlvExecutor);
    }

});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'js/ctrlv/initialize.js' */
define("dndattachment/ctrlv/initialize", [
  "jquery",
  "underscore",
  "dndattachment/ctrlv/polyfill",
  "dndattachment/ctrlv/utility",
  "dndattachment/ctrlv/html5",
  "dndattachment/ctrlv/issue-paste",
  "dndattachment/ctrlv/tracking",
  "dndattachment/ctrlv/executor",
  "jira/dialog/dialog-register",
  "jira/dialog/form-dialog",
  "exports"
], function (
  $,
  _,
  polyfill,
  utility,
  html5,
  issue_paste,
  tracker,
  executor,
  DialogRegister,
  FormDialog,
  exports
) {
  "use strict";

  // Initialization of HTML5 paste handler
  exports.init = function() {
    var AttachImageDialog = FormDialog.extend({
      options: {}
    });

    /**
     * SW-306 js errors are present when this reference isn't available in global scope
     * @deprecated
     */
    JIRA.ScreenshotDialog = AttachImageDialog;

    issue_paste.initIssuePaste();

    // Upload and Cancel Button Handlers
    $(document).ready(function () {
      "use strict";

      var delayShowUntil = $.Deferred();

      if (!utility.browserIsSupported() || !polyfill.isRequired()) {
        delayShowUntil.resolve();
      }

      // Shows the Attach Screenshot in a Popup
      DialogRegister.attachScreenshotDialog = new AttachImageDialog({
        id: "attach-screenshot-dialog",
        trigger: "a.issueaction-attach-screenshot-html5",
        isIssueDialog: true,
        onContentRefresh: function attachScreenshotContentRefresh() {

          this.$form.bind("before-submit", function attachScreenshotContentRefreshBeforeSubmit(e) {
            var errors = html5.validateFormData(html5.screenshotFileUpload, $.trim(html5.dialogView.getFileNameInput().val()));
            if (html5.dialogView.getFileSize() == 0) {
              e.preventDefault();
              return false;
            } else if (!_.isEmpty(errors)) {
              html5.dialogView.displayErrors(errors);
              e.preventDefault();
              return false;
            }
            return true;
          });

        },
        delayShowUntil: function () {
          if (polyfill.isRequired()) {
            polyfill.install(document)
              .done(function () {
                AttachImageDialog.prototype._submitForm = polyfill.proxyAjaxRequest(AttachImageDialog.prototype._submitForm, function () {
                  return $("#attach-screenshot-form").data("submit-secure-token");
                });
              })
              .always(function () {
                delayShowUntil.resolve();
              });
          }
          return delayShowUntil;
        }
      });

      $(document).bind("dialogContentReady", function (event, dialog) {
        // Ensure that the dialog is *ours*, and that it's showing the Attach screen shot form. It's possible that
        // it's populated with an error from the server, in which case we wouldn't want to "init" it.
        if (dialog === DialogRegister.attachScreenshotDialog && document.getElementById("attach-screenshot-form") !== null) {
          tracker.trigger("attach.screenshot.html5.contentReady");
          html5.initScreenshotPasteHandler();
        }
      });

      $(document).ready(function () {
        // Atlassian Analytics - Capture click events
        $(document).on("click", "#attach-screenshot-html5", function () {
          tracker.trigger("attach.screenshot.html5.display");
        });
      });
    });

    executor.register();
  };
});

require([
  "dndattachment/ctrlv/initialize",
  "jquery"
], function(
  jhtml5,
  $
) {
  "use strict";
  $(function() { jhtml5.init(); });
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:jira-html5-attach-images-resources', location = 'applet/deployJava.js' */
/*
 * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * deployJava.js
 *
 * This file is part of the Deployment Toolkit.  It provides functions for web
 * pages to detect the presence of a JRE, install the latest JRE, and easily run
 * applets or Web Start programs.  More Information on usage of the
 * Deployment Toolkit can be found in the Deployment Guide at:
 * http://docs.oracle.com/javase/6/docs/technotes/guides/jweb/index.html
 *
 * The "live" copy of this file may be found at :
 * http://java.com/js/deployJava.js.
 * For web pages provisioned using https, you may want to access the copy at:
 * https://java.com/js/deployJava.js.
 *
 * You are encouraged to link directly to the live copies.
 * The above files are stripped of comments and whitespace for performance,
 * You can access this file w/o the whitespace and comments removed at:
 * http://java.com/js/deployJava.txt.
 *
 */

var deployJava = function() {
    /** HTML attribute filter implementation */
    var hattrs = {
        core: [ 'id', 'class', 'title', 'style' ],
        i18n: [ 'lang', 'dir' ],
        events: [ 'onclick', 'ondblclick', 'onmousedown', 'onmouseup',
            'onmouseover', 'onmousemove', 'onmouseout', 'onkeypress',
            'onkeydown', 'onkeyup' ],
        applet: [ 'codebase', 'code', 'name', 'archive', 'object',
            'width', 'height', 'alt', 'align', 'hspace', 'vspace' ],
        object: [ 'classid', 'codebase', 'codetype', 'data', 'type',
            'archive', 'declare', 'standby', 'height', 'width', 'usemap',
            'name', 'tabindex', 'align', 'border', 'hspace', 'vspace' ]
    };

    var object_valid_attrs = hattrs.object.concat(hattrs.core, hattrs.i18n,
        hattrs.events);
    var applet_valid_attrs = hattrs.applet.concat(hattrs.core);

    // generic log function, use console.log unless it isn't available
    // then revert to alert()
    function log(message) {
        if ( ! rv.debug ) {return};

        if (console.log) {
            console.log(message);
        } else {
            alert(message);
        }
    }

    //checks where given version string matches query
    //
    //NB: assume format is correct. Can add format check later if needed
    // from dtjava.js
    function versionCheckEx(query, version) {
        if (query == null || query.length == 0) return true;

        var c = query.charAt(query.length - 1);

        //if it is not explicit pattern but does not have update version then need to append *
        if (c != '+' && c != '*' && (query.indexOf('_') != -1 && c != '_')) {
            query = query + "*";
            c = '*';
        }

        query = query.substring(0, query.length - 1);
        //if query ends with ".", "_" then we want to strip it to allow match of "1.6.*" to shorter form such as "1.6"
        //TODO: add support for match of "1.7.0*" to "1.7"?
        if (query.length > 0) {
            var z = query.charAt(query.length - 1);
            if (z == '.' || z == '_') {
                query = query.substring(0, query.length - 1);
            }
        }
        if (c == '*') {
            //it is match if version starts from it
            return (version.indexOf(query) == 0);
        } else if (c == '+') {
            //match if query string is lexicographically smaller
            return query <= version;
        }
        return false;
    }

    function getWebStartLaunchIconURL() {
        var imageUrl = '//java.com/js/webstart.png';
        try {
            // for http/https; use protocol less url; use http for all other protocol
            return document.location.protocol.indexOf('http') != -1 ?
                imageUrl : 'http:' + imageUrl;
        } catch (err) {
            return 'http:' + imageUrl;
        }
    }

    // GetJava page
    function constructGetJavaURL(query) {

        var getJavaURL = 'http://java.com/dt-redirect';

        if (query == null || query.length == 0) return getJavaURL;
        if(query.charAt(0) == '&')
        {
            query = query.substring(1, query.length);
        }
        return getJavaURL + '?'+  query;
    }

    function arHas(ar, attr) {
        var len = ar.length;
        for (var i = 0; i < len; i++) {
            if (ar[i] === attr) return true;
        }
        return false;
    }

    function isValidAppletAttr(attr) {
        return arHas(applet_valid_attrs, attr.toLowerCase());
    }

    function isValidObjectAttr(attr) {
        return arHas(object_valid_attrs, attr.toLowerCase());
    }

    /**
     * returns true if we can enable DT plugin auto-install without chance of
     * deadlock on cert mismatch dialog
     *
     * requestedJREVersion param is optional - if null, it will be
     * treated as installing any JRE version
     *
     * DT plugin for 6uX only knows about JRE installer signed by SUN cert.
     * If it encounter Oracle signed JRE installer, it will have chance of
     * deadlock when running with IE.  This function is to guard against this.
     */
    function enableWithoutCertMisMatchWorkaround(requestedJREVersion) {

        // Non-IE browser are okay
        if ('MSIE' != deployJava.browserName) return true;

        // if DT plugin is 10.0.0 or above, return true
        // This is because they are aware of both SUN and Oracle signature and
        // will not show cert mismatch dialog that might cause deadlock
        if (deployJava.compareVersionToPattern(deployJava.getPlugin().version,
            ["10", "0", "0"], false, true)) {
            return true;
        }

        // If we got there, DT plugin is 6uX

        if (requestedJREVersion  == null) {
            // if requestedJREVersion is not defined - it means ANY.
            // can not guarantee it is safe to install ANY version because 6uX
            // DT does not know about Oracle certificates and may deadlock
            return false;
        }

        // 6u32 or earlier JRE installer used Sun certificate
        // 6u33+ uses Oracle's certificate
        // DT in JRE6 does not know about Oracle certificate => can only
        // install 6u32 or earlier without risk of deadlock
        return !versionCheckEx("1.6.0_33+", requestedJREVersion);
    }

    /* HTML attribute filters */

    var rv = {

        debug: null,

        /* version of deployJava.js */
        version: "20120801",

        firefoxJavaVersion: null,

        myInterval: null,
        preInstallJREList: null,
        returnPage: null,
        brand: null,
        locale: null,
        installType: null,

        EAInstallEnabled: false,
        EarlyAccessURL: null,


        // mime-type of the DeployToolkit plugin object
        oldMimeType: 'application/npruntime-scriptable-plugin;DeploymentToolkit',
        mimeType: 'application/java-deployment-toolkit',

        /* location of the Java Web Start launch button graphic is right next to
         * deployJava.js at:
         *    http://java.com/js/webstart.png
         *
         * Use protocol less url here for http/https support
         */
        launchButtonPNG: getWebStartLaunchIconURL(),

        browserName: null,
        browserName2: null,

        /**
         * Returns an array of currently-installed JRE version strings.
         * Version strings are of the form #.#[.#[_#]], with the function returning
         * as much version information as it can determine, from just family
         * versions ("1.4.2", "1.5") through the full version ("1.5.0_06").
         *
         * Detection is done on a best-effort basis.  Under some circumstances
         * only the highest installed JRE version will be detected, and
         * JREs older than 1.4.2 will not always be detected.
         */
        getJREs: function() {
            var list = new Array();
            if (this.isPluginInstalled()) {
                var plugin =  this.getPlugin();
                var VMs = plugin.jvms;
                for (var i = 0; i < VMs.getLength(); i++) {
                    list[i] = VMs.get(i).version;
                }
            } else {
                var browser = this.getBrowser();

                if (browser == 'MSIE') {
                    if (this.testUsingActiveX('1.7.0')) {
                        list[0] = '1.7.0';
                    } else if (this.testUsingActiveX('1.6.0')) {
                        list[0] = '1.6.0';
                    } else if (this.testUsingActiveX('1.5.0')) {
                        list[0] = '1.5.0';
                    } else if (this.testUsingActiveX('1.4.2')) {
                        list[0] = '1.4.2';
                    } else if (this.testForMSVM()) {
                        list[0] = '1.1';
                    }
                } else if (browser == 'Netscape Family') {
                    this.getJPIVersionUsingMimeType();
                    if (this.firefoxJavaVersion != null) {
                        list[0] = this.firefoxJavaVersion;
                    } else if (this.testUsingMimeTypes('1.7')) {
                        list[0] = '1.7.0';
                    } else if (this.testUsingMimeTypes('1.6')) {
                        list[0] = '1.6.0';
                    } else if (this.testUsingMimeTypes('1.5')) {
                        list[0] = '1.5.0';
                    } else if (this.testUsingMimeTypes('1.4.2')) {
                        list[0] = '1.4.2';
                    } else if (this.browserName2 == 'Safari') {
                        if (this.testUsingPluginsArray('1.7.0')) {
                            list[0] = '1.7.0';
                        } else if (this.testUsingPluginsArray('1.6')) {
                            list[0] = '1.6.0';
                        } else if (this.testUsingPluginsArray('1.5')) {
                            list[0] = '1.5.0';
                        } else if (this.testUsingPluginsArray('1.4.2')) {
                            list[0] = '1.4.2';
                        }
                    }
                }
            }

            if (this.debug) {
                for (var i = 0; i < list.length; ++i) {
                    log('[getJREs()] We claim to have detected Java SE ' + list[i]);
                }
            }

            return list;
        },

        /**
         * Triggers a JRE installation.  The exact effect of triggering an
         * installation varies based on platform, browser, and if the
         * Deployment Toolkit plugin is installed.
         *
         * The requestVersion string is of the form #[.#[.#[_#]]][+|*],
         * which includes strings such as "1.4", "1.5.0*", and "1.6.0_02+".
         * A star (*) means "any version starting within this family" and
         * a plus (+) means "any version greater or equal to this".
         * "1.5.0*" * matches 1.5.0_06 but not 1.6.0_01, whereas
         * "1.5.0+" matches both.
         *
         * installCallback is an optional argument which holds a reference
         * to a javascript callback function for reporting install status.
         *
         * If the Deployment Toolkit plugin is not present, this will just call
         * this.installLatestJRE().
         */
        installJRE: function(requestVersion, installCallback) {
            var ret = false;
            if (this.isPluginInstalled() &&
                this.isAutoInstallEnabled(requestVersion)) {
                var installSucceeded = false;
                if (this.isCallbackSupported()) {
                    installSucceeded =
                        this.getPlugin().installJRE(requestVersion, installCallback);
                } else {
                    installSucceeded = this.getPlugin().installJRE(requestVersion);
                }

                if (installSucceeded) {
                    this.refresh();
                    if (this.returnPage != null) {
                        document.location = this.returnPage;
                    }
                }
                return installSucceeded;
            } else {
                return this.installLatestJRE();
            }
        },

        /**
         * returns true if jre auto install for the requestedJREVersion is enabled
         * for the local system; false otherwise
         *
         * requestedJREVersion param is optional - if not specified, it will be
         * treated as installing any JRE version
         *
         * DT plugin for 6uX only knows about JRE installer signed by SUN cert.
         * If it encounter Oracle signed JRE installer, it will have chance of
         * deadlock when running with IE.  This function is to guard against this.
         */
        isAutoInstallEnabled: function(requestedJREVersion) {
            // if no DT plugin, return false
            if (!this.isPluginInstalled()) return false;

            if (typeof requestedJREVersion  == 'undefined') {
                requestedJREVersion = null;
            }

            return enableWithoutCertMisMatchWorkaround(requestedJREVersion);

        },

        /**
         * returns true if jre install callback is supported
         * callback support is added since dt plugin version 10.2.0 or above
         */
        isCallbackSupported: function() {
            return this.isPluginInstalled() &&
                this.compareVersionToPattern(this.getPlugin().version,
                    ["10", "2", "0"], false, true);
        },

        /**
         * Triggers a JRE installation.  The exact effect of triggering an
         * installation varies based on platform, browser, and if the
         * Deployment Toolkit plugin is installed.
         *
         * In the simplest case, the browser window will be redirected to the
         * java.com JRE installation page, and (if possible) a redirect back to
         * the current URL upon successful installation.  The return redirect is
         * not always possible, as the JRE installation may require the browser to
         * be restarted.
         *
         * installCallback is an optional argument which holds a reference
         * to a javascript callback function for reporting install status.
         *
         * In the best case (when the Deployment Toolkit plugin is present), this
         * function will immediately cause a progress dialog to be displayed
         * as the JRE is downloaded and installed.
         */
        installLatestJRE: function(installCallback) {
            if (this.isPluginInstalled() && this.isAutoInstallEnabled()) {
                var installSucceeded = false;
                if (this.isCallbackSupported()) {
                    installSucceeded = this.getPlugin().installLatestJRE(installCallback);
                } else {
                    installSucceeded = this.getPlugin().installLatestJRE();
                }
                if (installSucceeded) {
                    this.refresh();
                    if (this.returnPage != null) {
                        document.location = this.returnPage;
                    }
                }
                return installSucceeded;
            } else {
                var browser = this.getBrowser();
                var platform = navigator.platform.toLowerCase();
                if ((this.EAInstallEnabled == 'true') &&
                    (platform.indexOf('win') != -1) &&
                    (this.EarlyAccessURL != null)) {

                    this.preInstallJREList = this.getJREs();
                    if (this.returnPage != null) {
                        this.myInterval =
                            setInterval("deployJava.poll()", 3000);
                    }

                    location.href = this.EarlyAccessURL;

                    // we have to return false although there may be an install
                    // in progress now, when complete it may go to return page
                    return false;
                } else {
                    if (browser == 'MSIE') {
                        return this.IEInstall();
                    } else if ((browser == 'Netscape Family') &&
                        (platform.indexOf('win32') != -1)) {
                        return this.FFInstall();
                    } else {
                        location.href = constructGetJavaURL(
                            ((this.returnPage != null) ?
                                ('&returnPage=' + this.returnPage) : '') +
                                ((this.locale != null) ?
                                    ('&locale=' + this.locale) : '') +
                                ((this.brand != null) ?
                                    ('&brand=' + this.brand) : ''));
                    }
                    // we have to return false although there may be an install
                    // in progress now, when complete it may go to return page
                    return false;
                }
            }
        },


        /**
         * Ensures that an appropriate JRE is installed and then runs an applet.
         * minimumVersion is of the form #[.#[.#[_#]]], and is the minimum
         * JRE version necessary to run this applet.  minimumVersion is optional,
         * defaulting to the value "1.1" (which matches any JRE).
         * If an equal or greater JRE is detected, runApplet() will call
         * writeAppletTag(attributes, parameters) to output the applet tag,
         * otherwise it will call installJRE(minimumVersion + '+').
         *
         * After installJRE() is called, the script will attempt to detect that the
         * JRE installation has completed and begin running the applet, but there
         * are circumstances (such as when the JRE installation requires a browser
         * restart) when this cannot be fulfilled.
         *
         * As with writeAppletTag(), this function should only be called prior to
         * the web page being completely rendered.  Note that version wildcards
         * (star (*) and plus (+)) are not supported, and including them in the
         * minimumVersion will result in an error message.
         */
        runApplet: function(attributes, parameters, minimumVersion) {
            if (minimumVersion == 'undefined' || minimumVersion == null) {
                minimumVersion = '1.1';
            }

            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";

            var matchData = minimumVersion.match(regex);

            if (this.returnPage == null) {
                // if there is an install, come back here and run the applet
                this.returnPage = document.location;
            }

            if (matchData != null) {
                var browser = this.getBrowser();
                if (browser != '?') {
                    if (this.versionCheck(minimumVersion + '+')) {
                        this.writeAppletTag(attributes, parameters);
                    } else if (this.installJRE(minimumVersion + '+')) {
                        // after successful install we need to refresh page to pick
                        // pick up new plugin
                        this.refresh();
                        location.href = document.location;
                        this.writeAppletTag(attributes, parameters);
                    }
                } else {
                    // for unknown or Safari - just try to show applet
                    this.writeAppletTag(attributes, parameters);
                }
            } else {
                log('[runApplet()] Invalid minimumVersion argument to runApplet():' +
                    minimumVersion);
            }
        },


        /**
         * Outputs an applet tag with the specified attributes and parameters, where
         * both attributes and parameters are associative arrays.  Each key/value
         * pair in attributes becomes an attribute of the applet tag itself, while
         * key/value pairs in parameters become <PARAM> tags.  No version checking
         * or other special behaviors are performed; the tag is simply written to
         * the page using document.writeln().
         *
         * As document.writeln() is generally only safe to use while the page is
         * being rendered, you should never call this function after the page
         * has been completed.
         */
        writeAppletTag: function(attributes, parameters) {
            var startApplet = '<' + 'applet ';
            var params = '';
            var endApplet = '<' + '/' + 'applet' + '>';
            var addCodeAttribute = true;

            if (null == parameters || typeof parameters != 'object') {
                parameters = new Object();
            }

            for (var attribute in attributes) {
                if (! isValidAppletAttr(attribute)) {
                    parameters[attribute] = attributes[attribute];
                } else {
                    startApplet += (' ' +attribute+ '="' +attributes[attribute] + '"');
                    if (attribute == 'code') {
                        addCodeAttribute = false;
                    }
                }
            }

            var codebaseParam = false;
            for (var parameter in parameters) {
                if (parameter == 'codebase_lookup') {
                    codebaseParam = true;
                }
                // Originally, parameter 'object' was used for serialized
                // applets, later, to avoid confusion with object tag in IE
                // the 'java_object' was added.  Plugin supports both.
                if (parameter == 'object' || parameter == 'java_object' ||
                    parameter == 'java_code' ) {
                    addCodeAttribute = false;
                }
                params += '<param name="' + parameter + '" value="' +
                    parameters[parameter] + '"/>';
            }
            if (!codebaseParam) {
                params += '<param name="codebase_lookup" value="false"/>';
            }

            if (addCodeAttribute) {
                startApplet += (' code="dummy"');
            }
            startApplet += '>';

            document.write(startApplet + '\n' + params + '\n' + endApplet);
        },


        /**
         * Returns true if there is a matching JRE version currently installed
         * (among those detected by getJREs()).  The versionPattern string is
         * of the form #[.#[.#[_#]]][+|*], which includes strings such as "1.4",
         * "1.5.0*", and "1.6.0_02+".
         * A star (*) means "any version within this family" and a plus (+) means
         * "any version greater or equal to the specified version".  "1.5.0*"
         * matches 1.5.0_06 but not 1.6.0_01, whereas "1.5.0+" matches both.
         *
         * If the versionPattern does not include all four version components
         * but does not end with a star or plus, it will be treated as if it
         * ended with a star.  "1.5" is exactly equivalent to "1.5*", and will
         * match any version number beginning with "1.5".
         *
         * If getJREs() is unable to detect the precise version number, a match
         * could be ambiguous.  For example if getJREs() detects "1.5", there is
         * no way to know whether the JRE matches "1.5.0_06+".  versionCheck()
         * compares only as much of the version information as could be detected,
         * so versionCheck("1.5.0_06+") would return true in in this case.
         *
         * Invalid versionPattern will result in a JavaScript error alert.
         * versionPatterns which are valid but do not match any existing JRE
         * release (e.g. "32.65+") will always return false.
         */
        versionCheck: function(versionPattern)
        {
            var index = 0;
            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?(\\*|\\+)?$";

            var matchData = versionPattern.match(regex);

            if (matchData != null) {
                // default is exact version match
                // examples:
                //    local machine has 1.7.0_04 only installed
                //    exact match request is "1.7.0_05":  return false
                //    family match request is "1.7.0*":   return true
                //    minimum match request is "1.6+":    return true
                var familyMatch = false;
                var minMatch = false;

                var patternArray = new Array();

                for (var i = 1; i < matchData.length; ++i) {
                    // browser dependency here.
                    // Fx sets 'undefined', IE sets '' string for unmatched groups
                    if ((typeof matchData[i] == 'string') && (matchData[i] != '')) {
                        patternArray[index] = matchData[i];
                        index++;
                    }
                }

                if (patternArray[patternArray.length-1] == '+') {
                    // + specified in request - doing a minimum match
                    minMatch = true;
                    familyMatch = false;
                    patternArray.length--;
                } else if (patternArray[patternArray.length-1] == '*') {
                    // * specified in request - doing a family match
                    minMatch = false;
                    familyMatch = true;
                    patternArray.length--;
                } else if (patternArray.length < 4) {
                    // versionPattern does not include all four version components
                    // and does not end with a star or plus, it will be treated as
                    // if it ended with a star. (family match)
                    minMatch = false;
                    familyMatch = true;
                }

                var list = this.getJREs();
                for (var i = 0; i < list.length; ++i) {
                    if (this.compareVersionToPattern(list[i], patternArray,
                        familyMatch, minMatch)) {
                        return true;
                    }
                }

                return false;
            } else {
                var msg = 'Invalid versionPattern passed to versionCheck: ' +
                    versionPattern;
                log('[versionCheck()] ' + msg);
                alert(msg);
                return false;
            }
        },


        /**
         * Returns true if an installation of Java Web Start of the specified
         * minimumVersion can be detected.  minimumVersion is optional, and
         * if not specified, '1.4.2' will be used.
         * (Versions earlier than 1.4.2 may not be detected.)
         */
        isWebStartInstalled: function(minimumVersion) {

            var browser = this.getBrowser();
            if (browser == '?') {
                // we really don't know - better to try to use it than reinstall
                return true;
            }

            if (minimumVersion == 'undefined' || minimumVersion == null) {
                minimumVersion = '1.4.2';
            }

            var retval = false;
            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";
            var matchData = minimumVersion.match(regex);

            if (matchData != null) {
                retval = this.versionCheck(minimumVersion + '+');
            } else {
                log('[isWebStartInstaller()] Invalid minimumVersion argument to isWebStartInstalled(): ' + minimumVersion);
                retval = this.versionCheck('1.4.2+');
            }
            return retval;
        },

        // obtain JPI version using navigator.mimeTypes array
        // if found, set the version to this.firefoxJavaVersion
        getJPIVersionUsingMimeType: function() {
            // Walk through the full list of mime types.
            for (var i = 0; i < navigator.mimeTypes.length; ++i) {
                var s = navigator.mimeTypes[i].type;
                // The jpi-version is the plug-in version.  This is the best
                // version to use.
                var m = s.match(/^application\/x-java-applet;jpi-version=(.*)$/);
                if (m != null) {
                    this.firefoxJavaVersion = m[1];
                    // Opera puts the latest sun JRE last not first
                    if ('Opera' != this.browserName2) {
                        break;
                    }
                }
            }
        },

        // launch the specified JNLP application using the passed in jnlp file
        // the jnlp file does not need to have a codebase
        // this requires JRE 7 or above to work
        // if machine has no JRE 7 or above, we will try to auto-install and then launch
        // (function will return false if JRE auto-install failed)
        launchWebStartApplication: function(jnlp) {
            var uaString = navigator.userAgent.toLowerCase();

            this.getJPIVersionUsingMimeType();

            // make sure we are JRE 7 or above
            if (this.isWebStartInstalled('1.7.0') == false) {

                // perform latest JRE auto-install
                if ((this.installJRE('1.7.0+') == false) ||
                    ((this.isWebStartInstalled('1.7.0') == false))) {
                    return false;
                }
            }

            var jnlpDocbase = null;

            // use document.documentURI for docbase
            if (document.documentURI) {
                jnlpDocbase = document.documentURI;
            }

            // fallback to document.URL if documentURI not available
            if (jnlpDocbase == null) {
                jnlpDocbase = document.URL;
            }

            var browser = this.getBrowser();

            var launchTag;

            if (browser == 'MSIE') {

                launchTag = '<' +
                    'object classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93" ' +
                    'width="0" height="0">' +
                    '<' + 'PARAM name="launchjnlp" value="' + jnlp + '"' + '>' +
                    '<' + 'PARAM name="docbase" value="' + jnlpDocbase + '"' + '>' +
                    '<' + '/' + 'object' + '>';
            } else if (browser == 'Netscape Family') {

                launchTag = '<' +
                    'embed type="application/x-java-applet;jpi-version=' +
                    this.firefoxJavaVersion + '" ' +
                    'width="0" height="0" ' +
                    'launchjnlp="' +  jnlp + '"' +
                    'docbase="' +  jnlpDocbase + '"' +
                    ' />';
            }

            if (document.body == 'undefined' || document.body == null) {
                document.write(launchTag);
                // go back to original page, otherwise current page becomes blank
                document.location = jnlpDocbase;
            } else {
                var divTag = document.createElement("div");
                divTag.id = "div1";
                divTag.style.position = "relative";
                divTag.style.left = "-10000px";
                divTag.style.margin = "0px auto";
                divTag.className ="dynamicDiv";
                divTag.innerHTML = launchTag;
                document.body.appendChild(divTag);
            }
        },

        createWebStartLaunchButtonEx: function(jnlp, minimumVersion) {

            if (this.returnPage == null) {
                // if there is an install, come back and run the jnlp file
                this.returnPage = jnlp;
            }

            var url = 'javascript:deployJava.launchWebStartApplication(\'' + jnlp +
                '\');';

            document.write('<' + 'a href="' + url +
                '" onMouseOver="window.status=\'\'; ' +
                'return true;"><' + 'img ' +
                'src="' + this.launchButtonPNG + '" ' +
                'border="0" /><' + '/' + 'a' + '>');
        },


        /**
         * Outputs a launch button for the specified JNLP URL.  When clicked, the
         * button will ensure that an appropriate JRE is installed and then launch
         * the JNLP application.  minimumVersion is of the form #[.#[.#[_#]]], and
         * is the minimum JRE version necessary to run this JNLP application.
         * minimumVersion is optional, and if it is not specified, '1.4.2'
         * will be used.
         * If an appropriate JRE or Web Start installation is detected,
         * the JNLP application will be launched, otherwise installLatestJRE()
         * will be called.
         *
         * After installLatestJRE() is called, the script will attempt to detect
         * that the JRE installation has completed and launch the JNLP application,
         * but there are circumstances (such as when the JRE installation
         * requires a browser restart) when this cannot be fulfilled.
         */
        createWebStartLaunchButton: function(jnlp, minimumVersion) {

            if (this.returnPage == null) {
                // if there is an install, come back and run the jnlp file
                this.returnPage = jnlp;
            }

            var url = 'javascript:' +
                'if (!deployJava.isWebStartInstalled(&quot;' +
                minimumVersion + '&quot;)) {' +
                'if (deployJava.installLatestJRE()) {' +
                'if (deployJava.launch(&quot;' + jnlp + '&quot;)) {}' +
                '}' +
                '} else {' +
                'if (deployJava.launch(&quot;' + jnlp + '&quot;)) {}' +
                '}';

            document.write('<' + 'a href="' + url +
                '" onMouseOver="window.status=\'\'; ' +
                'return true;"><' + 'img ' +
                'src="' + this.launchButtonPNG + '" ' +
                'border="0" /><' + '/' + 'a' + '>');
        },


        /**
         * Launch a JNLP application, (using the plugin if available)
         */
        launch: function(jnlp) {
            /*
             * Using the plugin to launch Java Web Start is disabled for the time being
             */
            document.location=jnlp;
            return true;
        },


        /*
         * returns true if the ActiveX or XPI plugin is installed
         */
        isPluginInstalled: function() {
            var plugin = this.getPlugin();
            if (plugin && plugin.jvms) {
                return true;
            } else {
                return false;
            }
        },

        /*
         * returns true if the plugin is installed and AutoUpdate is enabled
         */
        isAutoUpdateEnabled: function() {
            if (this.isPluginInstalled()) {
                return this.getPlugin().isAutoUpdateEnabled();
            }
            return false;
        },

        /*
         * sets AutoUpdate on if plugin is installed
         */
        setAutoUpdateEnabled: function() {
            if (this.isPluginInstalled()) {
                return this.getPlugin().setAutoUpdateEnabled();
            }
            return false;
        },

        /*
         * sets the preferred install type : null, online, kernel
         */
        setInstallerType: function(type) {
            this.installType = type;
            if (this.isPluginInstalled()) {
                return this.getPlugin().setInstallerType(type);
            }
            return false;
        },

        /*
         * sets additional package list - to be used by kernel installer
         */
        setAdditionalPackages: function(packageList) {
            if (this.isPluginInstalled()) {
                return this.getPlugin().setAdditionalPackages(
                    packageList);
            }
            return false;
        },

        /*
         * sets preference to install Early Access versions if available
         */
        setEarlyAccess: function(enabled) {
            this.EAInstallEnabled = enabled;
        },

        /*
         * Determines if the next generation plugin (Plugin II) is default
         */
        isPlugin2: function() {
            if (this.isPluginInstalled()) {
                if (this.versionCheck('1.6.0_10+')) {
                    try {
                        return this.getPlugin().isPlugin2();
                    } catch (err) {
                        // older plugin w/o isPlugin2() function -
                    }
                }
            }
            return false;
        },

        //support native DT plugin?
        allowPlugin: function() {
            this.getBrowser();

            // Safari and Opera browsers find the plugin but it
            // doesn't work, so until we can get it to work - don't use it.
            var ret = ('Safari' != this.browserName2 &&
                'Opera' != this.browserName2);

            return ret;
        },

        getPlugin: function() {
            this.refresh();

            var ret = null;
            if (this.allowPlugin()) {
                ret = document.getElementById('deployJavaPlugin');
            }
            return ret;
        },

        compareVersionToPattern: function(version, patternArray,
                                          familyMatch, minMatch) {
            if (version == undefined || patternArray == undefined) {
                return false;
            }
            var regex = "^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";
            var matchData = version.match(regex);

            if (matchData != null) {
                var index = 0;
                var result = new Array();

                for (var i = 1; i < matchData.length; ++i) {
                    if ((typeof matchData[i] == 'string') && (matchData[i] != ''))
                    {
                        result[index] = matchData[i];
                        index++;
                    }
                }

                var l = Math.min(result.length, patternArray.length);

                // result contains what is installed in local machine
                // patternArray is what is being requested by application
                if (minMatch) {
                    // minimum version match, return true if what we have (installed)
                    // is greater or equal to what is requested.  false otherwise.
                    for (var i = 0; i < l; ++i) {
                        if (result[i] < patternArray[i]) {
                            return false;
                        } else if (result[i] > patternArray[i]) {
                            return true;
                        }
                    }
                    return true;
                } else {
                    for (var i = 0; i < l; ++i) {
                        if (result[i] != patternArray[i]) return false;
                    }
                    if (familyMatch) {
                        // family match - return true as long as what we have
                        // (installed) matches up to the request pattern
                        return true;
                    } else {
                        // exact match
                        // result and patternArray needs to have exact same content
                        return (result.length == patternArray.length);
                    }
                }
            } else {
                return false;
            }
        },

        getBrowser: function() {

            if (this.browserName == null) {
                var browser = navigator.userAgent.toLowerCase();

                log('[getBrowser()] navigator.userAgent.toLowerCase() -> ' + browser);


                // order is important here.  Safari userAgent contains mozilla,
                // IE 11 userAgent contains mozilla and netscape,
                // and Chrome userAgent contains both mozilla and safari.
                if ((browser.indexOf('msie') != -1) && (browser.indexOf('opera') == -1)) {
                    this.browserName = 'MSIE';
                    this.browserName2 = 'MSIE';
                } else if (browser.indexOf('trident') != -1 || browser.indexOf('Trident') != -1) {
                    this.browserName = 'MSIE';
                    this.browserName2 = 'MSIE';
                } else if (browser.indexOf('iphone') != -1) {
                    // this included both iPhone and iPad
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'iPhone';
                } else if ((browser.indexOf('firefox') != -1) && (browser.indexOf('opera') == -1)) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Firefox';
                } else if (browser.indexOf('chrome') != -1) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Chrome';
                } else if (browser.indexOf('safari') != -1) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Safari';
                } else if ((browser.indexOf('mozilla') != -1) && (browser.indexOf('opera') == -1)) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Other';
                } else if (browser.indexOf('opera') != -1) {
                    this.browserName = 'Netscape Family';
                    this.browserName2 = 'Opera';
                } else {
                    this.browserName = '?';
                    this.browserName2 = 'unknown';
                }

                log('[getBrowser()] Detected browser name:'+ this.browserName +
                    ', ' + this.browserName2);
            }
            return this.browserName;
        },


        testUsingActiveX: function(version) {
            var objectName = 'JavaWebStart.isInstalled.' + version + '.0';

            // we need the typeof check here for this to run on FF/Chrome
            // the check needs to be in place here - cannot even pass ActiveXObject
            // as arg to another function
            if (typeof ActiveXObject == 'undefined' || !ActiveXObject) {
                log('[testUsingActiveX()] Browser claims to be IE, but no ActiveXObject object?');
                return false;
            }

            try {
                return (new ActiveXObject(objectName) != null);
            } catch (exception) {
                return false;
            }
        },


        testForMSVM: function() {
            var clsid = '{08B0E5C0-4FCB-11CF-AAA5-00401C608500}';

            if (typeof oClientCaps != 'undefined') {
                var v = oClientCaps.getComponentVersion(clsid, "ComponentID");
                if ((v == '') || (v == '5,0,5000,0')) {
                    return false;
                } else {
                    return true;
                }
            } else {
                return false;
            }
        },


        testUsingMimeTypes: function(version) {
            if (!navigator.mimeTypes) {
                log ('[testUsingMimeTypes()] Browser claims to be Netscape family, but no mimeTypes[] array?');
                return false;
            }

            for (var i = 0; i < navigator.mimeTypes.length; ++i) {
                s = navigator.mimeTypes[i].type;
                var m = s.match(/^application\/x-java-applet\x3Bversion=(1\.8|1\.7|1\.6|1\.5|1\.4\.2)$/);
                if (m != null) {
                    if (this.compareVersions(m[1], version)) {
                        return true;
                    }
                }
            }
            return false;
        },

        testUsingPluginsArray: function(version) {
            if ((!navigator.plugins) || (!navigator.plugins.length)) {
                return false;
            }
            var platform = navigator.platform.toLowerCase();

            for (var i = 0; i < navigator.plugins.length; ++i) {
                s = navigator.plugins[i].description;
                if (s.search(/^Java Switchable Plug-in (Cocoa)/) != -1) {
                    // Safari on MAC
                    if (this.compareVersions("1.5.0", version)) {
                        return true;
                    }
                } else if (s.search(/^Java/) != -1) {
                    if (platform.indexOf('win') != -1) {
                        // still can't tell - opera, safari on windows
                        // return true for 1.5.0 and 1.6.0
                        if (this.compareVersions("1.5.0", version) ||
                            this.compareVersions("1.6.0", version)) {
                            return true;
                        }
                    }
                }
            }
            // if above dosn't work on Apple or Windows, just allow 1.5.0
            if (this.compareVersions("1.5.0", version)) {
                return true;
            }
            return false;



        },

        IEInstall: function() {

            location.href = constructGetJavaURL(
                ((this.returnPage != null) ?
                    ('&returnPage=' + this.returnPage) : '') +
                    ((this.locale != null) ?
                        ('&locale=' + this.locale) : '') +
                    ((this.brand != null) ? ('&brand=' + this.brand) : ''));

            // should not actually get here
            return false;
        },

        done: function (name, result) {
        },

        FFInstall: function() {

            location.href = constructGetJavaURL(
                ((this.returnPage != null) ?
                    ('&returnPage=' + this.returnPage) : '') +
                    ((this.locale != null) ?
                        ('&locale=' + this.locale) : '') +
                    ((this.brand != null) ? ('&brand=' + this.brand) : '') +
                    ((this.installType != null) ?
                        ('&type=' + this.installType) : ''));

            // should not actually get here
            return false;
        },

        // return true if 'installed' (considered as a JRE version string) is
        // greater than or equal to 'required' (again, a JRE version string).
        compareVersions: function(installed, required) {

            var a = installed.split('.');
            var b = required.split('.');

            for (var i = 0; i < a.length; ++i) {
                a[i] = Number(a[i]);
            }
            for (var i = 0; i < b.length; ++i) {
                b[i] = Number(b[i]);
            }
            if (a.length == 2) {
                a[2] = 0;
            }

            if (a[0] > b[0]) return true;
            if (a[0] < b[0]) return false;

            if (a[1] > b[1]) return true;
            if (a[1] < b[1]) return false;

            if (a[2] > b[2]) return true;
            if (a[2] < b[2]) return false;

            return true;
        },

        enableAlerts: function() {
            // reset this so we can show the browser detection
            this.browserName = null;
            this.debug = true;
        },

        poll: function() {

            this.refresh();
            var postInstallJREList = this.getJREs();

            if ((this.preInstallJREList.length == 0) &&
                (postInstallJREList.length != 0)) {
                clearInterval(this.myInterval);
                if (this.returnPage != null) {
                    location.href = this.returnPage;
                };
            }

            if ((this.preInstallJREList.length != 0) &&
                (postInstallJREList.length != 0) &&
                (this.preInstallJREList[0] != postInstallJREList[0])) {
                clearInterval(this.myInterval);
                if (this.returnPage != null) {
                    location.href = this.returnPage;
                }
            }

        },

        writePluginTag: function() {
            var browser = this.getBrowser();

            if (browser == 'MSIE') {
                // width=0 and height=0 don't seem to be enough to hide the object element on all IE versions
                // so position: absolute + top were added to ensure the expected behaviour
                document.write('<' +
                    'object classid="clsid:CAFEEFAC-DEC7-0000-0001-ABCDEFFEDCBA" ' +
                    'id="deployJavaPlugin" width="0" height="0" style="position: absolute; top: -5000px;">' +
                    '<' + '/' + 'object' + '>');
            } else if (browser == 'Netscape Family' && this.allowPlugin()) {
                this.writeEmbedTag();
            }
        },

        refresh: function() {
            navigator.plugins.refresh(false);

            var browser = this.getBrowser();
            if (browser == 'Netscape Family' && this.allowPlugin()) {
                var plugin = document.getElementById('deployJavaPlugin');
                // only do this again if no plugin
                if (plugin == null) {
                    this.writeEmbedTag();
                }
            }
        },

        writeEmbedTag: function() {
            var written = false;
            if (navigator.mimeTypes != null) {
                for (var i=0; i < navigator.mimeTypes.length; i++) {
                    if (navigator.mimeTypes[i].type == this.mimeType) {
                        if (navigator.mimeTypes[i].enabledPlugin) {
                            document.write('<' +
                                'embed id="deployJavaPlugin" type="' +
                                this.mimeType + '" hidden="true" />');
                            written = true;
                        }
                    }
                }
                // if we ddn't find new mimeType, look for old mimeType
                if (!written) for (var i=0; i < navigator.mimeTypes.length; i++) {
                    if (navigator.mimeTypes[i].type == this.oldMimeType) {
                        if (navigator.mimeTypes[i].enabledPlugin) {
                            document.write('<' +
                                'embed id="deployJavaPlugin" type="' +
                                this.oldMimeType + '" hidden="true" />');
                        }
                    }
                }
            }
        }
    }; // deployJava object

    rv.writePluginTag();
    if (rv.locale == null) {
        var loc = null;

        if (loc == null) try {
            loc = navigator.userLanguage;
        } catch (err) { }

        if (loc == null) try {
            loc = navigator.systemLanguage;
        } catch (err) { }

        if (loc == null) try {
            loc = navigator.language;
        } catch (err) { }

        if (loc != null) {
            loc.replace("-","_")
            rv.locale = loc;
        }
    }

    return rv;
}();;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-amd', location = 'js/jira-amd.js' */
/**
 * AMD wrapper for JIRA object
 */

define('dndattachment/JIRA',  function() {
    return JIRA;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:dnd-amd', location = 'js/aui-amd.js' */
// amd shim required for JIRA 6.1

define('dndattachment/aui', function() { return AJS; });;
;
/* module-key = 'com.atlassian.jira.plugins.jira-dnd-attachment-plugin:attachment-menu-link-init', location = 'js/menu/initAttachmentMenuLink.js' */
require([
        'jquery',
        'dndattachment/aui',
        'jira/util/events',
        'dndattachment/util/events/types'
    ], function ($,
                 AJS,
                 Events,
                 EventTypes) {

        var ISSUEACTION_ATTACH_FILES_CLASS = "issueaction-attach-file";

        var addDialogClassAndInvoke = function($el) {
            $el.addClass(ISSUEACTION_ATTACH_FILES_CLASS);
            $el.click();
        };

        var openFilePickerForPage = function() {
            var $tempFileInput = $("<input type=\"file\" multiple />");
            $tempFileInput.change(function (event) {
                Events.trigger(EventTypes.ATTACHMENT_FOR_PAGE_RECEIVED, {
                    files: $tempFileInput[0].files
                });
            });
            $tempFileInput.click();
        };

        var isSubtaskLink = function($link) {
            return !! $link.data("issuekey");
        };

        // This should use skate once skate is a thing in jira-core
        var initialiseMenuAttachmentLink = function () {
            $(document).on('click', '.unified-attach-file', function (e) {
                AJS.trigger('analytics', { name : 'issue.dnd.attachment.opsbar.attachFiles.linkClick', data : {}});

                var $target = $(e.target);

                // If we have the old issueaction class, then do nothing
                if($target.hasClass(ISSUEACTION_ATTACH_FILES_CLASS)) {
                    return;
                }

                e.preventDefault();

                // Check if we have a Drop Zone present
                var isDropZonePresent = $(".issue-drop-zone").length;
                if(isDropZonePresent && !isSubtaskLink($target)) {
                    // If we have a drop zone available then we  create a dummy file input and open it
                    openFilePickerForPage();
                } else {
                    // If we do not, then add the class to make it behave the old way then click the target again to open the dialog
                    // This is mainly for JIRA Agile, who won't have a drop zone available to listen accept the files.
                    addDialogClassAndInvoke($target);
                }
            });
        };

        var onReady = function () {
            initialiseMenuAttachmentLink();
        };

        if ($.isReady) {
            onReady();
        } else {
            AJS.$(onReady);
        }
    }
);;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-public', location = 'js/applinks.public.js' */
/**
 * Support code to provide appropriate behavior for HTML elements created by
 * ApplicationLinkUIService; also, public functions that can be used from JS code
 * in other plugins to create the same kinds of HTML elements, in case it's not
 * convenient to do so on the back end.
 */
var ApplinksUtils = ApplinksUtils || (function($) {

    var pendingRequests = {},
        pendingConfirmations = {};
    
    // Provide a well-defined name for the authentication window/tab we create with
    // window.open() - may be useful in debugging, and is used by integration tests.
    // Note, IE8 does not allow this name to contain hyphens or periods.
    var authWindowName = "com_atlassian_applinks_authentication";

    /**
     * This function is basically duplicated from messages.js in AJS, because some products
     * only provide a stub version of messages.js within gadgets.
     */
    function makeCloseable(message) {
        var $icon = $('<span class="aui-icon icon-close"></span>').click(function () {
            message.trigger("messageClose", [this]).remove();
        });
        message.append($icon);
    }

    /**
     * Helper function to get the DOM object of the current iframe.
     * @return {Object} a DOM object, or null if we are not in an iframe
     */
    function getCurrentIframe() {
        if (window === parent.window) {
            return null;
        }
        var ret = null,
            myFrameWindow = window;
        $('iframe', parent.document.body).each(function(index) {
            if (this.contentWindow.window === myFrameWindow) {
                ret = this;
            }
        });
        return ret;
    }

    /**
     * Event handler that is called by the applinks authorization completion servlet.  It triggers
     * the completion function for any pending authorization request that matches the given applink
     * ID, and also redispatches the event to any other iframes in the current window.
     * @param {Object} eventObject  JQuery event object
     * @param {string} applinkId  application link ID
     * @param {boolean} success  true if the request was approved
     * @param {string} authAdminUri  URI of the "OAuth Access Tokens" page (will be displayed in the
     *   confirmation message)
     * @param {boolean} wasRedispatched  true if the event has been retriggered from another frame
     * @param {Object} [messages]
     *      'userError': an error message relevant to a non-admin user,
     *      'adminError': an error message relevant to an admin user,
     *      'adminErrorDetails': a list of details related to the admin message if there is one 
     */
    function onAuthCompletion(eventObject, applinkId, success, authAdminUri, wasRedispatched, messages) {
        if (applinkId in pendingRequests) {
            var request = pendingRequests[applinkId];
            if (success) {
                request.authAdminUri = authAdminUri;
                delete pendingRequests[applinkId];
            }
            completeAuthRequest(request, success, messages);
        }
        if (!wasRedispatched && parent && (parent !== window)) {
            var myWindow = window;
            $('iframe', parent.document.body).each(function(index, frame) {
                var scope = frame.contentWindow;
                if (scope !== myWindow) {
                    if (scope.AJS && scope.AJS.$) {
                        scope.AJS.$(scope.document).trigger('applinks.auth.completion',
                            [applinkId, success, authAdminUri, true, messages]);
                    }
                }
            });
        }
    }
      
    /**
     * Fires the appropriate event when the authorization flow has completed.  On approval, reloads
     * the window/frame unless an event handler calls {@code preventDefault()} on the event.
     * @param {Object} applinkProperties  has the same properties passed to {@link createAuthRequestBanner}
     * @param {boolean} approved  true if the request was approved
     * @param {Object} [messages]
     *      'userError': an error message relevant to a non-admin user,
     *      'adminError': an error message relevant to an admin user,
     *      'adminErrorDetails': a list of details related to the admin message if there is one
     */
    function completeAuthRequest(applinkProperties, approved, messages) {
        var $scope = $(document);
        if (approved) {
            // Temporarily bind an event handler so our handler runs after any other handlers that
            // may exist.
            var defaultApprovalHandler = function (eventObject) {
                if (eventObject.isDefaultPrevented()) {
                    // Don't reload, just show the confirmation message
                    showAuthConfirmationBanner(applinkProperties);
                } else {
                    // Reload, but first save a reminder to make us show a confirmation message
                    // after we've reloaded.
                    registerPendingConfirmation(applinkProperties);
                    document.location.reload(true);
                }
            };
            $scope.bind('applinks.auth.approved', defaultApprovalHandler);
            $scope.trigger('applinks.auth.approved', applinkProperties);
            $scope.unbind('applinks.auth.approved', defaultApprovalHandler);
        } else {
            // There's no default behavior for a request that was denied, but fire an event in case
            // anyone is interested.
            $scope.trigger('applinks.auth.denied', [applinkProperties, messages]);
        }
    }

    /**
     * Used internally to make the applink support code aware of a "please authenticate" message
     * element that has been displayed, by wiring the appropriate event handlers and adding the
     * applink's properties to an internal list of authentication requests.
     * @param $element {Object}  a JQuery object
     * @param applinkProperties {Object}  has the same properties passed to {@link createAuthRequestBanner}
     */
    function initAuthRequest($element, applinkProperties) {
        var $authLink = $element.find("a.applink-authenticate");
        
        if ($element.hasClass('aui-message')) {
            // Workaround for incomplete AJS availability in some products
            makeCloseable($element);
        }
        
        $authLink.click(function(e) {
            window.open(applinkProperties.authUri, authWindowName);
            e.preventDefault();
        });
        
        pendingRequests[applinkProperties.id] = applinkProperties;
        
        return $element;
    }
    
    /**
     * Used internally to ensure that {@link initAuthRequest} is called for every
     * authorisation request element that was generated as HTML from the back end,
     * rather than by calling {@link createAuthRequestBanner} or
     * {@link createAuthRequestInline}.  The parameters of the request are passed
     * from the back end in hidden input elements.
     */
    function initAuthRequestElements() {
        $('.applinks-auth-request').each(function(index) {
            var $e = $(this),
                applinkId = $e.find(".applinkId").val(),
                appName = $e.find(".appName").val(),
                appUri = $e.find(".appUri").val(),
                authUri = $e.find(".authUri").val();
            // Ignore request banners that have already been created (by {@link createAuthRequestBanner} or
            // {@link createAuthRequestInline})
            if (applinkId && authUri) {
                initAuthRequest($e, {
                    id: applinkId,
                    appName: appName,
                    appUri: appUri,
                    authUri: authUri});
            }
        });
    }

    /**
     * Builds a "please authenticate" banner (in a standard AUI message box) containing a link that
     * that will start authorization for an application link that needs credentials.
     * <p>
     * On completion of the authorization flow, a JQuery event will be triggered on the document,
     * with the event type "applinks.auth.approved" or "applinks.auth.denied", and an additional
     * parameter equal to the {@code applinkProperties} parameter that was passed here.
     * <p>
     * If authorization is granted (event "applinks.auth.approved"), the default behavior is for the
     * window or frame to be reloaded; also, a confirmation banner will be displayed either within
     * a &lt;div&gt; element of class "applinks-auth-confirmation-container" if one exists, or at the top of
     * the document otherwise.  Reloading of the window/frame can be disabled by having an event
     * handler call {@code preventDefault()} on the event.
     *
     * @param {Object} applinkProperties contains the following application link properties:
     *   {@code id}: the application link identifier;
     *   {@code appName}: the name of the remote application;
     *   {@code appUri}: the base URI of the remote application;
     *   {@code authUri}: the URI for starting the authorization flow
     * @return {Object} a JQuery object referring to a {@code <div>} element, which has not yet
     *   been inserted anywhere on the page; its class is "applinks-auth-request"
     */
    function createAuthRequestBanner(applinkProperties) {
        var $banner = $('<div class="aui-message warning closeable applinks-auth-request"><p><span class="aui-icon icon-applinks-key"></span></p></div>');
        // Note that we can't just use the AJS.messages.warning() function, because it will put a
        // standard warning icon in the message box and we want a custom icon.
        $banner.append(AJS.format("Additional information may be available, please \u003ca class=\"applink-authenticate\" href=\"{0}\"\u003eauthenticate\u003c/a\u003e with \u003ca href=\"{1}\"\u003e{2}\u003c/a\u003e.",
                                        AJS.escapeHtml(applinkProperties.authUri),
                                        AJS.escapeHtml(applinkProperties.appUri),
                                        AJS.escapeHtml(applinkProperties.appName)));
        initAuthRequest($banner, applinkProperties);
        return $banner;
    }

    /**
     * Builds a "please authenticate" message suitable for displaying inline (in a span
     * with the class "applinks-auth-request"), containing a link that will start authorization.
     * This behaves identically to {@link createAuthRequestBanner}, except it creates a {@code <span>}
     * element instead of a {@code div} and also allows additional text to be displayed.
     * 
     * @param {string} content  optional HTML content to be displayed within the inline
     *   element (e.g. a description of the entity for which authorization is required);
     *   will not be escaped; may be null
     * @param {Object} applinkProperties  see {@link createAuthRequestBanner}
     * @return {Object} a JQuery object referring to a {@code <span>} element, which has not yet
     *   been inserted anywhere on the page; its class is "applinks-auth-request"
     */
    function createAuthRequestInline(content, applinkProperties) {
        var $lozenge = $('<span class="applinks-auth-request"></span>'),
            $contentSpan = $('<span class="applinks-request-description"></span>'),
            message = AJS.format("\u003ca class=\"applink-authenticate\" href=\"{0}\"\u003eAuthenticate\u003c/a\u003e to see additional information.", AJS.escapeHtml(applinkProperties.authUri));
        if (content) {
            $contentSpan.append(content);
            $contentSpan.append(" - ");
        }
        $contentSpan.append(message);
        $lozenge.append($contentSpan);
        initAuthRequest($lozenge, applinkProperties);
        return $lozenge;
    }

    /**
     * Used internally to remember the fact that we have just completed authorizing an
     * applink and are about to refresh the iframe associated with it, so that we can
     * display a confirmation message after the iframe is refreshed.
     */
    function registerPendingConfirmation(applinkProperties) {
        var frame = getCurrentIframe();
        if ((!frame) || (!frame.id)) {
            return;
        }
        if (! parent.ApplinksUtils.pendingConfirmations) {
            parent.ApplinksUtils.pendingConfirmations = { };
        }
        if (!(frame.id in parent.ApplinksUtils.pendingConfirmations)) {
            parent.ApplinksUtils.pendingConfirmations[frame.id] = [];
        }
        parent.ApplinksUtils.pendingConfirmations[frame.id].push(applinkProperties);
        return;
    }

    /**
     * Called after a page load, to see if we've been refreshed due to a successful authorization.
     * If we're in an iframe, a variable will have been set on the parent window to tell us that
     * this happened.  If so, insert a confirmation banner at the top of the iframe.
     */
    function checkForPendingConfirmations() {
        if (parent && parent.ApplinksUtils && parent.ApplinksUtils.pendingConfirmations) {
            var myFrame = getCurrentIframe();
            if (myFrame) {
                if (myFrame.id in parent.ApplinksUtils.pendingConfirmations) {
                    var pendingConfirmations = parent.ApplinksUtils.pendingConfirmations[myFrame.id];
                    delete parent.ApplinksUtils.pendingConfirmations[myFrame.id];
                    for (var i = 0, n = pendingConfirmations.length; i < n; i++) {
                        showAuthConfirmationBanner(pendingConfirmations[i]);
                    }
                }
            }
        }
    }

    /**
     * Displays a confirmation banner.  If an element exists with the class
     * "applinks-auth-confirmation-contianer", it is inserted there, otherwise at the top of the
     * document.
     */
    function showAuthConfirmationBanner(applinkProperties) {
        var scope = $(document),
            banner = $('<div class="aui-message success closeable applinks-auth-confirmation"><p><span class="aui-icon icon-applinks-key-success"></span></p></div>'),
            container = scope.find('div.applinks-auth-confirmation-container');
        if (!container.length) {
            container = scope.find('body');
        }
        banner.append(AJS.format("This application is now using \u003ca href=\"{0}\"\u003e{1}\u003c/a\u003e\'\'s credentials. Revoke access at any time by going to \u003ca href=\"{2}\"\u003eOAuth access tokens\u003c/a\u003e.",
                                        AJS.escapeHtml(applinkProperties.appUri),
                                        AJS.escapeHtml(applinkProperties.appName),
                                        AJS.escapeHtml(applinkProperties.authAdminUri)));
        makeCloseable(banner);
        container.prepend(banner);
        setTimeout(function() {
            banner.fadeOut(1000, function() {
                $(this).remove();
            });
        }, 5000);
    }
    
    /**
     * Initialization function to be called once at document ready time.
     */
    function setup() {
        // If we're in an iframe, set up an object in the parent window that we can use to
        // keep track of state even if the iframe is refreshed.
        if (parent && !(parent === window)) {
            if (! parent.ApplinksUtils) {
                parent.ApplinksUtils = { };
            }
        }
        
        $(document).bind('applinks.auth.completion', onAuthCompletion);

        initAuthRequestElements();
        checkForPendingConfirmations();
    }

    $(document).ready(setup);
    
    return {      
        createAuthRequestBanner: createAuthRequestBanner,
        createAuthRequestInline: createAuthRequestInline
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:lodash-amd', location = 'applinks/internal/lib/lodash-jslibs.js' */
define('applinks/lib/lodash', ['atlassian/libs/underscore-1.5.2'], function(lodash) {
        return lodash;
    });;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/console-amd.js' */
define('applinks/lib/console', function() {
    return window.console;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/jquery-amd.js' */
define('applinks/lib/jquery', function() {
   return window.jQuery;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/aui-amd.js' */
define('applinks/lib/aui', function() {
   var aui = window.AJS;
   if (!aui) {
      throw "window.AJS not defined, cannot load AUI";
   }
   var auiVersion = aui.version.split(".");
   aui.versionDetails = {
      major: parseInt(auiVersion[0]),
      minor: parseInt(auiVersion[1]),
      bugfix: parseInt(auiVersion[2])
   };
   return aui;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/wrm-amd.js' */
/**
 * Define Web resource manager as an AMD dependency. This should also be present in apps using Atlassian Plugins Web
 * Resources framework.
 */
define('applinks/lib/wrm', function() {
   return window.WRM;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/skate-amd.js' */
define('applinks/lib/skate', function() {
   return window.skate;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-lib', location = 'applinks/internal/lib/window-amd.js' */
/**
 * Define window as AMD module to facilitate unit testing of some modules
 */
define('applinks/lib/window', function() {
    return window;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/preconditions.js' */
define('applinks/common/preconditions', [
    'applinks/lib/lodash'
], function(
    _
) {
    function nonEmptyString(value, varName, customMessage) {
        _checkArgument(
            _.isString(value) && !_.isEmpty(value),
            customMessage,
            _withVarName(varName, ': expected a non-empty string')
        );
    }

    function isFunction(value, varName, customMessage) {
        _checkArgument(
            _.isFunction(value),
            customMessage,
            _withVarName(varName, ': expected a function, was: ' + value)
        );
    }

    function hasValue(value, varName, customMessage) {
        _checkArgument(
            value,
            customMessage,
            _withVarName(varName, ': expected a value')
        );
    }

    function _checkArgument(value, message, defaultMessage) {
        var actualMessage = message ? message : defaultMessage;
        if (!value) {
            throw new Error(actualMessage)
        }
    }

    function _withVarName(varName, msg) {
        return (varName || '[unspecified]') + msg;
    }

    return {
        checkArgument: _.partial(_checkArgument, _, _, ''),
        nonEmptyString: nonEmptyString,
        isFunction: isFunction,
        hasValue: hasValue
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/context.js' */
define('applinks/common/context', [
    'applinks/lib/console',
    'applinks/lib/window',
    'applinks/lib/wrm',
    'applinks/common/modules'
], function(
    console,
    window,
    WRM,
    ApplinksModules
) {
    var context = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-context'));

    return {
        currentUser: function() {
            return context.currentUser
        },

        /**
         * @returns {object} host application containing `id` and `type` properties
         */
        hostApplication: function() {
            return context.hostApplication
        },

        validateCurrentUser: function() {
            if (!this.currentUser()) {
                console.log('No user context, reloading the page to trigger redirect to the login screen');
                window.location.reload();
            }
        }
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/help-paths.js' */
define('applinks/common/help-paths', [
    'applinks/lib/console',
    'applinks/lib/wrm',
    'applinks/lib/lodash',
    'applinks/common/modules',
    'applinks/common/preconditions'
], function(
    console,
    WRM,
    _,
    ApplinksModules,
    Preconditions
) {
    // lazy-load help paths, facilitates unit-testing
    var allHelpPaths = _.memoize(function() {
        var helpPaths = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-help-paths'));
        if (!helpPaths.entries) {
            console.warn('Help paths not found, all help links are likely to be broken.');
        }
        return helpPaths.entries || {};
    });

    var getPath = function(key, sectionKey) {
        Preconditions.nonEmptyString(key, 'key');
        var path = allHelpPaths()[key] || key;
        if (sectionKey) {
            Preconditions.nonEmptyString(sectionKey, 'sectionKey');
            var prefix = path.replace(/\+/g, ''); // "g" flag to remove _all_ '+' signs
            path += '#' +prefix + '-' + sectionKey;
        }
        return path;
    };

    function endsWith(string, suffix) {
        return string.indexOf(suffix, string.length - suffix.length) !== -1;
    }

    function addSuffixIfRequired(string, suffix) {
        return endsWith(string, suffix) ? string : string + suffix;
    }

    return {
        /**
         * @param key {string} key to get the path for
         * @returns {string} relative help path that can be appended to any relevant docs base URL
         */
        getPath: getPath,

        /**
         * @param key {string} key to get the path for
         * @param sectionKey {string} optional key of the anchor on the target page
         * @returns {string} full help path including the base URL
         */
        getFullPath: function(key, sectionKey) {
            var baseUrl = this.baseUrl();
            return addSuffixIfRequired(baseUrl, '/') + this.getPath(key, sectionKey);
        },

        /**
         * @returns {string} configured base URL for the help paths
         */
        baseUrl: _.partial(getPath, 'applinks.docs.root')
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/events.js' */
define('applinks/common/events', function() {

    var PREFIX = 'applinks.event.';

    return {
        PREREADY: PREFIX + 'preready',
        READY: PREFIX + 'ready',

        /**
         * Raised when applinks list is first loaded
         */
        APPLINKS_LOADED: PREFIX + 'loaded',
        /**
         * Raised when applinks list is updated
         */
        APPLINKS_UPDATED: PREFIX + 'updated',

        /**
         * This event is only raised when linking to Atlassian applications
         * Can be consumed by other plugins
         */
        NEW_APPLINK_CREATED: PREFIX + 'created',

        // legacy events
        Legacy: {
            MESSAGE_BOX_DISPLAYED: PREFIX + 'message-box-displayed'
        }
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/initializer.js' */
define('applinks/common/initializer', [
    'applinks/lib/jquery',
    'applinks/lib/lodash'
], function(
    $,
    _
) {
    function _callInitCallback(module) {
        if (module && _.isFunction(module.init)) {
            module.init();
        }
        if (module && _.isFunction(module.initialize)) {
            module.initialize();
        }
    }

    return {

        /**
         * Init `module`. If the module contains an `init` or `initialize` function, it will be called immediately
         * If both functions are present, both will be called.
         *
         * @param module {object} module to initialize
         */
        init: function(module) {
            _callInitCallback(module);
        },

        /**
         * Init `module` on DOM ready. If the module contains an `init` or `initialize` function, it will be called
         * on DOM ready event. Those functions should contain code that performs UI initialization dependent on the
         * state of the DOM. If both functions are present, both will be called.
         *
         * @param module {object} module to initialize
         */
        initOnDomReady: function(module) {
            $(document).ready(function() {
                _callInitCallback(module);
            });
        }
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/modules.js' */
/**
 * Applinks plugin modules core constants and definitions.
 */
define('applinks/common/modules', function() {
    return {
        /**
         * Applinks plugin key
         */
        PLUGIN_KEY: 'com.atlassian.applinks.applinks-plugin',

        /**
         * Fully qualifies a module name using the plugin key.
         *
         * @param {string} moduleName module name to qualify
         * @returns {string} fully qualified name
         */
        fqn: function(moduleName) {
            return this.PLUGIN_KEY + ':' + moduleName;
        },

        /**
         * Fully qualifies web-resource data using module name and data key.
         *
         * @param {string} moduleName module name
         * @param {string} dataKey key of the data element
         * @returns {string} fully qualified name
         */
        dataFqn: function(moduleName, dataKey) {
            return this.fqn(moduleName) + '.' + dataKey;
        }
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/features.js' */
define('applinks/common/features', [
    'applinks/lib/wrm',
    'applinks/lib/lodash',
    'applinks/common/modules',
    'applinks/common/context',
    'applinks/common/rest'
], function(
    WRM,
    _,
    ApplinksModules,
    ApplinksContext,
    ApplinksRest
) {
    var enabledFeatures, discoveredFeatures;

    function _getEnabledFeatures() {
        if (_.isUndefined(enabledFeatures)) {
            enabledFeatures = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-features'));
        }
        return enabledFeatures;
    }

    function _getDiscoveredFeatures() {
        if (_.isUndefined(discoveredFeatures)) {
            discoveredFeatures = WRM.data.claim(ApplinksModules.dataFqn('applinks-common', 'applinks-discovered-features'));
        }
        return discoveredFeatures;
    }

    function isDiscovered(featureKey) {
        return _.contains(_getDiscoveredFeatures(), featureKey.toLowerCase());
    }

    function addEnabledFeatures(features) {
        _.extend(_getEnabledFeatures(), features);
    }

    function addDiscoveredFeatures(featureKeys) {
        featureKeys.forEach(function(featureKey){
            if (!isDiscovered(featureKey)) {
                _getDiscoveredFeatures().push(featureKey.toLowerCase());
            }
        });
    }

    /**
     * Allows to query for, enable and discover Applinks features.
     */
    return {

        BITBUCKET_REBRAND: 'BITBUCKET_REBRAND',
        V3_UI_OPT_IN: 'V3_UI_OPT_IN',
        V3_UI: 'V3_UI',

        /**
         * @returns {Object.<string, Object>} all enabled features mapped by key
         */
        getEnabledFeatures: function() {
            return _getEnabledFeatures();
        },

        isEnabled: function(featureName) {
            return this.getEnabledFeatures()[featureName];
        },

        /**
         * Disable `featureName`, requires user context and admin permissions.
         *
         * @param featureName {string} feature name to enable
         * @return the request promise to hook callbacks to
         */
        disable: function(featureName) {
            ApplinksContext.validateCurrentUser();
            return ApplinksRest.V3.features(featureName).del()
                .done(function() {
                    _getEnabledFeatures()[featureName] = false;
                });
        },

        /**
         * Enable `featureName`, requires user context and admin permissions.
         *
         * @param featureName {string} feature name to enable
         * @return the request promise to hook callbacks to
         */
        enable: function(featureName) {
            ApplinksContext.validateCurrentUser();
            return ApplinksRest.V3.features(featureName).put()
                .done(function(feature) {
                    addEnabledFeatures(feature);
                });
        },

        /**
         * @returns {string[]} an array of discovered feature keys
         */
        getDiscoveredFeatures: function() {
            return _getDiscoveredFeatures();
        },

        isDiscovered: isDiscovered,

        /**
         * Discover `featureKey`, requires user context.
         *
         * @param featureKey {string} key to discover
         */
        discover: function(featureKey) {
            ApplinksContext.validateCurrentUser();
            ApplinksRest.V3.featureDiscovery(featureKey).put()
                .fail(function(req) {
                    throw 'Feature discovery request failed: ' + req.status + ': ' + req.responseText;
                }).done(function(featureKey) {
                    addDiscoveredFeatures(featureKey);
                });
        }
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/products.js' */
define('applinks/common/products', [
    'applinks/lib/window'
], function(Window) {

    function getTypeName(typeId) {
        // Note: window.appLinksI18n.entries is injected into the page by common_header.vm
        return Window.appLinksI18n.entries['applinks.application.type.'+typeId];
    }

    /**
     * Map of Atlassian product keys to application type IDs
     */
    return {
        BAMBOO: 'bamboo',
        BITBUCKET: 'stash', // special case, see java class com.atlassian.applinks.application.bitbucket.BitbucketApplicationTypeImpl.TYPE_ID
        CONFLUENCE: 'confluence',
        FECRU: 'fecru',
        JIRA: 'jira',
        REFAPP: 'refapp',
        STASH: 'stash',
        getTypeName: getTypeName
    };
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/response-status.js' */
define('applinks/common/response-status', [
    'applinks/lib/lodash'
], function(
    _
) {

    function StatusFamily(familyCode) {
        this.familyCode = familyCode;
    }

    StatusFamily.prototype.matches = function(code) {
        return Math.floor(_getStatusCode(code) / 100) == this.familyCode;
    };

    var StatusFamilies = {
        INFORMATIONAL: new StatusFamily(1),
        SUCCESSFUL: new StatusFamily(2),
        REDIRECTION: new StatusFamily(3),
        CLIENT_ERROR: new StatusFamily(4),
        SERVER_ERROR: new StatusFamily(5),

        forCode: function(code) {
            return _.find(StatusFamilies.all(), function(family) {
                return family.matches(code);
            });
        },

        all: function() {
            return [
                StatusFamilies.INFORMATIONAL,
                StatusFamilies.SUCCESSFUL,
                StatusFamilies.REDIRECTION,
                StatusFamilies.CLIENT_ERROR,
                StatusFamilies.SERVER_ERROR
            ];
        }
    };

    function ResponseStatus(code) {
        this.code = code;
        this.family = StatusFamilies.forCode(code);
    }

    ResponseStatus.prototype.matches = function(code) {
        return _getStatusCode(code) == this.code;
    };

    function _getStatusCode(object) {
        if (object && object.status && _.isNumber(object.status)) {
            return object.status;
        } else if (_.isNumber(object)) {
            return object;
        } else {
            return 0;
        }
    }

    return {
        OK: new ResponseStatus(200),
        CREATED: new ResponseStatus(201),

        BAD_REQUEST: new ResponseStatus(400),
        UNAUTHORIZED: new ResponseStatus(401),
        FORBIDDEN: new ResponseStatus(403),
        NOT_FOUND: new ResponseStatus(404),
        CONFLICT: new ResponseStatus(409),

        Family: StatusFamilies
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/rest-request.js' */
define('applinks/common/rest-request', [
    'applinks/lib/console',
    'applinks/lib/window',
    'applinks/lib/jquery',
    'applinks/lib/lodash',
    'applinks/common/preconditions',
    'applinks/common/response-status'
], function(
    console,
    window,
    $,
    _,
    Preconditions,
    ResponseStatus
) {
    var defaultRequestSettings = {
        dataType: 'json',
        contentType: 'application/json'
    };

    // construct the target URL by adding query params
    function _toUrl(url, queryParams) {
        if (_.isEmpty(queryParams)) {
            return url;
        }
        var separator = url.indexOf('?') > -1 ? '&' : '?';
        return url + separator + $.param(queryParams);
    }

    // create default success and error handlers to ensure we got an expected status
    function _defaultSuccessHandler(statuses) {
        return function(data, textStatus, request) {
            if (!_.some(statuses, function(status) { return status.matches(request) })) {
                console.error('Unexpected response status: ' + request.status + ': ' + request.responseText);
            }
        }
    }

    function _defaultErrorHandler(statuses) {
        return function(request, textStatus, error) {
            if (!_.some(statuses, function(status) { return status.matches(request) })) {
                console.error('Unexpected response status: ' + request.status + ': ' + request.responseText);
                // force re-login if UNAUTHORIZED
                if (ResponseStatus.UNAUTHORIZED.matches(request)) {
                    window.location.reload();
                }
            }
        }
    }

    /**
     * Creates a new instance of `ApplinksRestRequest`.
     *
     * @param url URL to request to. NOTE: URLs with fragments (`#`) are not supported
     * @param params query parameters to add to the request URL
     * @constructor
     */
    function ApplinksRestRequest(url, params) {
        Preconditions.nonEmptyString(url, 'url');
        Preconditions.checkArgument(url.indexOf('#') == -1, 'url: "#" fragments not supported');
        this._url = url;
        this._queryParams = _.extend({}, params);
        this._expectedStatus = [ResponseStatus.Family.SUCCESSFUL];
    }

    ApplinksRestRequest.GET = 'GET';
    ApplinksRestRequest.PUT = 'PUT';
    ApplinksRestRequest.POST = 'POST';
    ApplinksRestRequest.DELETE = 'DELETE';

    ApplinksRestRequest.prototype.get = function() {
        return this._execute(this._requestSettings(ApplinksRestRequest.GET));
    };

    ApplinksRestRequest.prototype.del = function() {
        return this._execute(this._requestSettings(ApplinksRestRequest.DELETE));
    };

    ApplinksRestRequest.prototype.put = function(data) {
        var settings = this._requestSettings(ApplinksRestRequest.PUT);
        if (data) {
            settings.data = data;
        }
        return this._execute(settings);
    };

    ApplinksRestRequest.prototype.post = function(data) {
        var settings = this._requestSettings(ApplinksRestRequest.POST);
        if (data) {
            settings.data = data;
        }
        return this._execute(settings);
    };

    /**
     * Add query param to this request.
     *
     * @param {string} name param name
     * @param {string} value param value
     * @return {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.queryParam = function(name, value) {
        this._queryParams[name] = value;
        return this;
    };

    /**
     * Add query params to this request.
     *
     * @param {Object} params params map to add
     * @returns {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.queryParams = function(params) {
        this._queryParams = _.extend(this._queryParams, params);
        return this;
    };

    /**
     * Add `authorisationCallback` query parameter to this request, this is useful for resources that are expected to
     * respond with `authorisationUri`
     *
     * @param {string} callback URI to call back once authorisation is done
     * @return {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.authorisationCallback = function(callback) {
        this.queryParam('authorisationCallback', callback);
        return this;
    };

    /**
     * Expect a specific status (or status family). Use a specific number or one of the members defined in
     * `applinks/common/response-status`. By default a successful 20x response is expected. If the response does not
     * meet this expectation, a default error handler will be invoked.
     *
     * Invoke this method with any number of of statuses expressed as an object that contains `matches` method (using
     * the ones in `applinks/lib/response-status` is highly recommended).
     * @returns {ApplinksRestRequest} this request
     */
    ApplinksRestRequest.prototype.expectStatus = function() {
        this._expectedStatus = _.isArray(arguments[0]) ? arguments[0] : _.toArray(arguments);
        return this;
    };

    ApplinksRestRequest.prototype._requestSettings = function(requestType) {
        var that = this;
        return _.defaults({
            url: _toUrl(that._url, that._queryParams),
            type: requestType
        }, defaultRequestSettings);
    };

    ApplinksRestRequest.prototype._execute = function(settings) {
        return $.ajax(settings)
            .done(_defaultSuccessHandler(this._expectedStatus))
            .fail(_defaultErrorHandler(this._expectedStatus));
    };

    return ApplinksRestRequest;
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/rest.js' */
define('applinks/common/rest', [
    'applinks/lib/aui',
    'applinks/common/preconditions',
    'applinks/common/rest-request',
    'applinks/common/rest-oauth'
], function(
    AJS,
    Preconditions,
    ApplinksRestRequest,
    ApplinksOAuthRest
) {
    function ApplinksRestModule(version) {
        Preconditions.hasValue(version, 'version');
        this._version = version;
    }

    ApplinksRestModule.prototype.baseUrl = function() {
        return AJS.contextPath() + '/rest/applinks/' + this._version;
    };

    ApplinksRestModule.prototype.withPath = function(path) {
        return this.baseUrl() + '/' + path;
    };

    function ApplinksV1RestModule() {
        this.module = new ApplinksRestModule('1.0');
    }

    function ApplinksV2RestModule() {
        this.module = new ApplinksRestModule('2.0');
    }

    function ApplinksV3RestModule() {
        this.module = new ApplinksRestModule('3.0');
    }

    ApplinksV3RestModule.prototype.featureDiscovery = function(featureKey) {
        if (!featureKey) {
            throw 'feature key not defined';
        }
        return new ApplinksRestRequest(this.module.withPath('feature-discovery/' + featureKey));
    };

    ApplinksV3RestModule.prototype.features = function(featureName) {
        if (!featureName) {
            throw 'feature name not defined';
        }
        return new ApplinksRestRequest(this.module.withPath('features/' + featureName));
    };

    ApplinksV3RestModule.prototype.status = function(applinkId) {
        if (!applinkId) {
            throw 'applinkId not defined';
        }
        return new ApplinksRestRequest(this.module.withPath('status/' + applinkId));
    };

    return {
        V1: new ApplinksV1RestModule(),
        V2: new ApplinksV2RestModule(),
        V3: new ApplinksV3RestModule(),
        OAuth: ApplinksOAuthRest
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/rest-oauth.js' */
define('applinks/common/rest-oauth', [
    'applinks/lib/aui',
    'applinks/common/rest-request',
    'applinks/common/preconditions'
], function(
    AJS,
    ApplinksRestRequest,
    Preconditions
) {
    function ApplinksOAuthRestModule(version) {
        Preconditions.hasValue(version, 'version');
        this.baseUrl =  AJS.contextPath() + '/rest/applinks-oauth/' + version + '/';
    }

    ApplinksOAuthRestModule.prototype._withPath = function(path) {
        return this.baseUrl + path;
    };

    function ApplinksOAuthV1RestModule() {
        this.module = new ApplinksOAuthRestModule('1.0');
    }

    ApplinksOAuthV1RestModule.prototype.consumerToken = function(applinkId) {
        Preconditions.hasValue(applinkId, 'applinkId');
        return new ApplinksRestRequest(this.module._withPath('consumer-token/' + applinkId));
    };

    return {
        V1: new ApplinksOAuthV1RestModule()
    }
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-common', location = 'applinks/internal/common/i18n.js' */
define('applinks/common/i18n', [
    'applinks/lib/jquery',
    'applinks/lib/aui'
], function(
    $,
    AJS
) {
    function init() {
        // set up I18n for dynamical calls on client side, remember to use " for AJS.I18n.getText
        // Please make sure that AbstractApplinksServlet.java has put the appLinksI18n.entries correctly on the page
        AJS.I18n.keys = AJS.I18n.keys || {};
        $.extend(AJS.I18n.keys, appLinksI18n.entries);
    }

    return {
        init: init
    }
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'js/fecru-compatibility.js' */
if (jQuery != undefined && AJS != undefined) jQuery = AJS.$; // make sure we're extending the correct jQuery;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/common/rest-service.js' */
/**
 * The triggering of AppLinks initialisation can be customised by setting a function on
 * AJS.AppLinksInitialisationBinder. The binder function should take a single argument which is a zero-arg function to
 * run and should execute this function when appropriate.
 */
AppLinks = AJS.$.extend(window.AppLinks || {}, {
    Event: {
        NAMESPACE: "applinks"
    }
});
var ApplinksEvents = require('applinks/common/events');
AppLinks.Event = AJS.$.extend(window.AppLinks.Event, ApplinksEvents);

// Is there an overridden initialisation binder?
if (AJS.AppLinksInitialisationBinder) {
    AppLinks.initialisationBinder = AJS.AppLinksInitialisationBinder;
} else {
    // The default bind if no specific binder is specified
    AppLinks.initialisationBinder = function(f) {
        AJS.toInit(f);
    }
}

AppLinks.initialisationBinder(function() {
    //$ is passed in by AJS.toInit but initilizationBinder can be over loaded by products so that $ is unsafe.
    var $ = AJS.$;
    AppLinks = $.extend(window.AppLinks || {}, {
        failure: function(data) {
            if (data.status == 401) {
                window.location.reload();
            } else {
                var message = AppLinks.parseError(data);
                var errorDivs = $('.page-error');

                if (errorDivs.length > 0) {
                    errorDivs.html(message).fadeIn('slow');
                }
                else {
                    alert("REST request failed: " + message);
                }
            }
        },
        jsonRequest: function(url, type, data, success, error) {
            if (data) {
                data = JSON.stringify(data);
            }
            $(".page-error").fadeOut('fast');
            if (!error) error = AppLinks.failure;
            return jQuery.ajax({
                url: url,
                type: type,
                data: data,
                dataType: 'json',
                contentType: "application/json; charset=utf-8",
                cache: false,
                success: success,
                error: error
            });
        },
        xmlRequest: function(url, type, data, success, error) {
            if (data) {
                data = JSON.stringify(data);
            }
            $(".page-error").fadeOut('fast');
            if (!error) error = AppLinks.failure;
            return jQuery.ajax({
                url: url,
                type: type,
                data: data,
                dataType: 'xml',
                contentType: "application/xml; charset=utf-8",
                cache: false,
                success: success,
                error: error
            });
        },
        parseError: function(errorData) {
            var error;
            try {
                error = JSON.parse(errorData.responseText);
            } catch (e) {
                if (errorData.statusText) {
                    return error = errorData.statusText;
                } else {
                    return errorData;
                }
            }
            if (error.message) {
                if ($.isArray(error.message)) {
                    return error.message.join(' ');
                }
                return error.message;
            }
            else {
                return errorData.statusText;
            }
        },
        put: function(url, data, success, error) {
            return AppLinks.jsonRequest(url, 'PUT', data, success, error);
        },
        post: function(url, data, success, error) {
            return AppLinks.jsonRequest(url, 'POST', data, success, error);
        },
        update: function(data, success, error) {
            AppLinks.put(AppLinks.self_link(data), data, success, error);
        },
        get: function(url, success, error) {
            return AppLinks.jsonRequest(url, 'GET', null, success, error);
        },
        getXml: function(url, success, error) {
            return AppLinks.xmlRequest(url, 'GET', null, success, error);
        },
        self_link: function(item) {
            for (var i = 0, _i = item.link.length; i < _i; i++) {
                var link = item.link[i];
                if (link.rel == "self") return link.href;
            }

            throw "No self-link found";
        },
        del: function(urlOrObject, success, error) {
            var url;
            if (typeof(urlOrObject) == 'string') url = urlOrObject;
            else url = AppLinks.self_link(urlOrObject);
            return AppLinks.jsonRequest(url, 'DELETE', null, success, error);
        },
        SPI: $.extend({}, {
            API_VERSION: "1.0",
            REST_RESOURCE_URL: AJS.contextPath() + "/rest/applinks/",
            BASE_URL: AJS.contextPath() + "/rest/applinks/1.0",
            OAUTH_REST_RESOURCE_URL: AJS.contextPath() + "/rest/applinks-oauth/",
            OAUTH_BASE_URL: AJS.contextPath() + "/rest/applinks-oauth/1.0",

            /**
             * Update the API version and associated urls.
             * @param version
             */
            setApiVersion: function(version){
                AppLinks.SPI.API_VERSION = version;
                AppLinks.SPI.setBaseUrl(AppLinks.SPI.REST_RESOURCE_URL + AppLinks.SPI.API_VERSION);
            },
            setBaseUrl: function(url){
                AppLinks.SPI.BASE_URL = url;
            },
            setOAuthBaseUrl: function(url){
                AppLinks.SPI.OAUTH_BASE_URL = url;
            },
            /**
             * Build a base URL for rest calls using the specified baseUrl.
             * @param baseUrl
             * @returns {string}
             */
            getRemoteRestBaseUrl: function(baseUrl) {
                return baseUrl + "/rest/applinks/" + AppLinks.SPI.API_VERSION;
            },
            /**
             * Build a base URL for plugin servlet calls using the specified baseUrl.
             * @param baseUrl
             * @returns {string}
             */
            getRemotePluginServletBaseUrl: function(baseUrl) {
                return baseUrl + "/plugins/servlet";
            },
            getAllLinks: function(success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink";
                return AppLinks.get(url, success, failure);
            },
            getAllLinksWithAuthInfo: function(success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/listApplicationlinks";
                return AppLinks.get(url, success, failure);
            },
            getApplicationLinkState: function(id, success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/listApplicationlinkstates/id/" + id;
                return AppLinks.get(url, success, failure);
            },
            getLinksOfType: function(typeId, success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink/type/" + typeId;
                return AppLinks.get(url, success, failure);
            },
            tryToFetchManifest: function(url, success, failure) {
                var restUrl = AppLinks.SPI.BASE_URL + '/applicationlinkForm/manifest.json?url=' + encodeURIComponent(url);
                return AppLinks.get(restUrl, success, failure);
            },
            getManifestFor: function(id, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/manifest/' + id + ".json";
                return AppLinks.get(url, success, failure);
            },
            getLocalManifest: function(success, failure){
                var url = AppLinks.SPI.BASE_URL + '/manifest.json';
                return AppLinks.get(url, success, failure);
            },
            /**
             * Attempt to get the Manifest of the remote application, via a direct REST call.
             * Requires CORS enabled on the REST resource.
             * @param url
             * @param success
             * @param failure
             * @returns {*}
             */
            getRemoteManifest: function(remoteBaseUrl, success, failure){
                var remoteManifestUrl = AppLinks.SPI.getRemoteRestBaseUrl(remoteBaseUrl) + '/manifest.json';
                return AppLinks.get(remoteManifestUrl, success, failure);
            },
            /**
             * Attempt to get the OAuth Consumer Info of the remote application, via a direct call.
             * Requires CORS enabled on the REST resource.
             * @param url
             * @param success
             * @param failure
             * @returns {*}
             */
            getRemoteOAuthConsumerInfo: function(remoteBaseUrl, success, failure){
                var remoteManifestUrl = AppLinks.SPI.getRemotePluginServletBaseUrl(remoteBaseUrl) + '/oauth/consumer-info';
                return AppLinks.getXml(remoteManifestUrl, success, failure);
            },
            getApplinkStatus: function (applinkId, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/status/' + applinkId;
                return AppLinks.get(url, success, failure);
            },
            createStaticUrlAppLink: function(applicationType, success, failure) {
                var restUrl = AppLinks.SPI.BASE_URL + '/applicationlinkForm/createStaticUrlAppLink?typeId=' + applicationType;
                return AppLinks.post(restUrl, null, success, failure);
            },
            createLink: function(applicationLink, username, password, createTwoWayLink, customRpcUrl, rpcUrl, configFormValues, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlinkForm/createAppLink';
                var data = {
                    applicationLink: applicationLink,
                    username: username,
                    password: password,
                    createTwoWayLink: createTwoWayLink,
                    customRpcURL: customRpcUrl,
                    rpcUrl: rpcUrl,
                    configFormValues: configFormValues
                };
                return AppLinks.post(url, data, success, failure);
            },
            createLinkWithOrphanedTrust : function(applicationLink, username, password, createTwoWayLink, customRpcUrl, rpcUrl, configFormValues, orphanedTrust, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlinkForm/createAppLink';
                var data = {
                    applicationLink: applicationLink,
                    username: username,
                    password: password,
                    createTwoWayLink: createTwoWayLink,
                    customRpcURL: customRpcUrl,
                    rpcUrl: rpcUrl,
                    configFormValues: configFormValues,
                    orphanedTrust: orphanedTrust
                };
                return AppLinks.post(url, data, success, failure);
            },
            verifyTwoWayLinkDetails : function (remoteUrl, rpcUrl, username, password, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlinkForm/details';
                var data = {
                    username: username,
                    password: password,
                    remoteUrl: remoteUrl,
                    rpcUrl: rpcUrl
                };
                return AppLinks.post(url, data, success, failure);
            },
            getApplicationLinkInfo: function (appId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlinkInfo/id/" + appId;
                return AppLinks.get(url, success, error);
            },
            deleteLink: function(applicationLink, reciprocate, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink/" + applicationLink.id;
                if (reciprocate) url += "?reciprocate=true";
                return AppLinks.del(url, success, error);
            },
            makePrimary: function(applicationLink, success) {
                var url = AppLinks.SPI.BASE_URL + "/applicationlink/primary/" + applicationLink.id;
                return AppLinks.post(url, null, success);
            },
            relocate: function(applicationLink, newUrl, suppressWarnings, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/relocateApplicationlink/" + applicationLink.id + "?newUrl=" + encodeURIComponent(newUrl) +
                        "&nowarning=" + (suppressWarnings ? "true" : "false");
                return AppLinks.post(url, null, success, error);
            },
            legacyUpgrade: function(applicationLink, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/upgrade/legacy/" + applicationLink.id;
                return AppLinks.post(url, null, success, error);
            },
            ualUpgrade: function(applicationLink, body, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/upgrade/ual/" + applicationLink.id;
                return AppLinks.post(url, body, success, error);
            },
            getEntityTypesForApplicationType: function(applicationType, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/type/entity/" + applicationType;
                return AppLinks.get(url, success, error);
            },
            getLocalEntitiesWithLinksToApplication: function(applicationLinkId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/localEntitiesWithLinksTo/" + applicationLinkId + ".json";
                return AppLinks.get(url, success, error);
            },
            getEntityLinksForApplication: function(applicationLinkId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entities/" + applicationLinkId + ".json";
                AppLinks.get(url, success, error);
            },
            getEntityLinksForApplicationUsingAnonymousAccess: function(applicationLinkId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entities/anonymous/" + applicationLinkId + ".json";
                return AppLinks.get(url, success, error);
            },
            createNonUalEntityLink: function(localType, localKey, applicationId, remoteTypeId, remoteKey, name, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/" + localType + "/" + localKey + "?reciprocate=false";
                var data = {
                    applicationId: applicationId,
                    typeId: remoteTypeId,
                    key: remoteKey,
                    name: name,
                    isPrimary: false
                };
                return AppLinks.put(url, data, success, error);
            },
            createEntityLink: function(localType, localKey, entity, reciprocate, success, failure) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/" + localType + "/" + localKey + "?reciprocate=";
                url += (reciprocate ? "true" : "false");
                return AppLinks.put(url, entity, success, failure);
            },
            getConfiguredEntityLinks: function(localType, localKey, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/primaryLinks/" + localType + "/" + localKey + ".json";
                return AppLinks.get(url, success, error);
            },
            deleteEntityLink: function(localTypeId, localKey, entity, reciprocate, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/" + localTypeId + "/" + localKey + "?typeId=" + entity.typeId + "&key=" + entity.key + "&applicationId=" + entity.applicationId + "&reciprocate=" + reciprocate;
                return AppLinks.del(url, success, error);
            },
            makePrimaryEntityLink: function(localTypeID, localKey, entity, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/entitylink/primary/" + localTypeID + "/" + localKey + "?typeId=" + entity.typeId + "&key=" + entity.key + "&applicationId=" + entity.applicationId;
                return AppLinks.post(url, null, success, error);
            },
            canDeleteAppLink: function(applicationId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/permission/reciprocate-application-delete/" + applicationId;
                return AppLinks.get(url, success, error);
            },
            canDeleteEntityLink: function(localTypeId, localKey, entity, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/permission/reciprocate-entity-delete/" + entity.applicationId + "/" + localTypeId + "/" + localKey + "/" + entity.typeId + "/" + entity.key;
                return AppLinks.get(url, success, error);
            },
            canCreateReciprocateEntityLink: function(applicationId, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/permission/reciprocate-entity-create/" + applicationId;
                return AppLinks.get(url, success, error);
            },
            processPermissionCode: function(settings) {
                var config = {
                    noPermission: function() {},
                    missing: function() {},
                    credentialsRequired: function(authUrl) {},
                    authenticationFailed: function(authUrl) {},
                    noAuthentication: function(authUrl) {},
                    noAuthenticationConfigured: function() {},
                    noConnection: function() {},
                    allowed: function() {},
                    unrecognisedCode: function(code) {},
                    updateView: function(message, icon, button) {}
                };

                if (!settings) settings = {};

                settings = $.extend(config, settings);

                return function(data) {
                    var code = data.code;
                    if (code == "NO_PERMISSION") {
                        settings.noPermission();
                    } else if (code == "MISSING") {
                        settings.missing();
                    } else if (code == "CREDENTIALS_REQUIRED") {
                        settings.credentialsRequired(data.url);
                    } else if (code == "AUTHENTICATION_FAILED") {
                        settings.authenticationFailed(data.url);
                    } else if (code == "NO_AUTHENTICATION") {
                        settings.noAuthentication(data.url);
                    } else if (code == "NO_AUTHENTICATION_CONFIGURED") {
                        settings.noAuthenticationConfigured();
                    } else if (code == "NO_CONNECTION") {
                        settings.noConnection();
                    } else if (code == "ALLOWED") {
                        settings.allowed();
                    } else {
                        settings.unrecognisedCode(data.code);
                    }
                };
            },
            addAuthenticationTrigger: function(target, authUrl, callbacks) {
                if (!callbacks) {
                    callbacks = {};
                }

                if (typeof callbacks.onSuccess == "undefined") {
                    callbacks.onSuccess = function() {
                        location.reload();
                    }
                }

                if (typeof callbacks.onFailure == "undefined") {
                    callbacks.onFailure = function() {
                        return true;
                    }
                }
                //Unbind previous click listener, otherwise we might end up opening multiple windows.
                $(target).unbind('click');
                $(target).click(function() {
                    if (callbacks.before) {
                        callbacks.before();
                    }
                    AppLinks.authenticateRemoteCredentials(authUrl, callbacks.onSuccess, callbacks.onFailure);
                });
            },
            deleteOrphanedTrust: function(id, type, success, error) {
                var url = AppLinks.SPI.BASE_URL + "/orphaned-trust/" + type + "/" + id;
                return AppLinks.del(url, success, error);
            },
            getOrphanedTrust: function(success, error) {
                var url = AppLinks.SPI.BASE_URL + "/orphaned-trust/";
                return AppLinks.get(url, success, error);
            },
            showCreateEntityLinkSuggestion: function() {
                return true;
            },
            getApplicationLink: function(id, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlink/' + id;
                return AppLinks.get(url, success, failure);
            },
            createApplicationLink: function(id, name, rpcUrl, displayUrl, typeId, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlink';
                var data = {
                    id: id,
                    name: name,
                    rpcUrl: rpcUrl,
                    displayUrl: displayUrl,
                    typeId: typeId
                };
                return AppLinks.put(url, data, success, failure);
            },
// TODO APLDEV-3 extract OAuth creation code into OAuth specific js files in the Oauth plugin.
            createConsumer: function(id, key, name, description, sharedSecret, publicKey, twoLOAllowed, executingTwoLOUser, twoLOImpersonationAllowed, outgoing, success, failure) {
                var url = AppLinks.SPI.OAUTH_BASE_URL + '/applicationlink/' + id + '/authentication/consumer';
                var data = {
                    key: key,
                    name: name,
                    description: description,
                    sharedSecret: sharedSecret,
                    publicKey: publicKey,
                    outgoing: outgoing,
                    twoLOAllowed: twoLOAllowed,
                    executingTwoLOUser: executingTwoLOUser,
                    twoLOImpersonationAllowed: twoLOImpersonationAllowed
                };
                return AppLinks.put(url, data, success, failure);
            },
            createConsumerAutoConfigure: function(id, twoLOAllowed, executingTwoLOUser, twoLOImpersonationAllowed, success, failure) {
                var url = AppLinks.SPI.OAUTH_BASE_URL + '/applicationlink/' + id + '/authentication/consumer?autoConfigure=true';
                var data = {
                    twoLOAllowed: twoLOAllowed,
                    executingTwoLOUser: executingTwoLOUser,
                    twoLOImpersonationAllowed: twoLOImpersonationAllowed
                };
                return AppLinks.put(url, data, success, failure);
            },
            registerProvider: function(id, provider, config, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/applicationlink/' + id + '/authentication/provider';
                var data = {
                    config : config,
                    provider : provider
                };
                return AppLinks.put(url, data, success, failure);
            },
            enableFeature: function(featureName, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/features/' + featureName;
                return AppLinks.put(url, {}, success, failure);
            },
            disableFeature: function(featureName, success, failure) {
                var url = AppLinks.SPI.BASE_URL + '/features/' + featureName;
                return AppLinks.del(url, success, failure);
            }
        }, (window.AppLinks && window.AppLinks.SPI) || {})
    });

    var i18nRootKey = 'applinks';

    AppLinks.UI = {
        showInfoBox: function(message) {
            $('.aui-message.success').remove();
            AppLinks.UI.createMessage('success', message, 'page-info');
        },
        hideInfoBox: function() {
            $('.aui-message.success').remove();
        },
        showErrorBox: function(message) {
            AppLinks.UI.createMessage('error', message, 'page-error');
        },
        hideErrorBox: function() {
            $('.aui-message.error').remove();
        },
        showWarningBox: function(messages) {
            if ($.isArray(messages) && messages.length > 0) {
                var ulEl = $("<ul></ul>");
                $(messages).each(function(index) {
                    ulEl.append($("<li/>", {
                        text: messages[index]
                    }));
                });
                var messageEl = $('<div class="page-warning"></div>').append(ulEl);
                AppLinks.UI.createMessage('warning', messageEl.html(), 'page-warning');
            } else {
                AppLinks.UI.createMessage('warning', messages, 'page-warning');
            }
        },
        hideWarningBox: function() {
            $('.aui-message.warning').remove();
        },
        shortenString: function(message, maxLength) {
            if (message.length  > maxLength) {
               message = message.substring(0, maxLength) + "...";
            }
            return message;
        },
        createMessage: function(type, message, cssClass) {
            var messageEl = $('<div class="' + cssClass + '">');
            messageEl.html(message);
            AJS.messages[type](".applinks-message-bar", {
                title: "",
                body: messageEl.wrap('<div></div>').parent().html(),
                closeable: true
            });
            $(document).trigger(AppLinks.Event.Legacy.MESSAGE_BOX_DISPLAYED);
        },
        displayValidationErrorMessages: function (errorClass, rootEl, messages) {
            if ($.isArray(messages)) {
                $(messages).each(function(i,v) {
                   var d = $('<div class="error applinks-error">');
                   d.text(v);
                   $(rootEl).find("." + errorClass).append(d);
                });
            } else if(typeof messages != 'undefined'){
                var d = $('<div class="error applinks-error">');
                d.text(messages.toString());
                $(rootEl).find("." + errorClass).append(d);
            }
        },
        displayValidationError: function(errorClass, rootEl, errorFn) {
            return function(xhr) {
                if (xhr.status == 401) {
                    window.location.reload();
                    return;
                }

                $('.applinks-error').remove();
                $('.loading').remove();
                var respJSON = xhr.responseText;
                var respObj = $.parseJSON(respJSON);
                var messages = respObj.message;
                if (typeof respObj.fields == "undefined") {
                    AppLinks.UI.displayValidationErrorMessages(errorClass, rootEl, messages);
                } else {
                    var fields = respObj.fields;
                    $(fields).each(function(index) {
                        var d = $('<div class="error applinks-error" id="' + fields[index] + '-error">');
                        d.text(messages[index]);
                        if ($(rootEl).find('.' + fields[index]).length > 0) {
                          d.insertAfter($(rootEl).find('.' + fields[index]));
                        } else {
                          d.insertAfter($(rootEl).find('.' + errorClass).append(d));
                        }
                    });
                }
                $(rootEl).find('.' + errorClass).addClass("fully-populated-errors");
                if (errorFn) {
                 errorFn();
                }
            }
        },
        addProtocolToURL : function(url) {
            var newUrl = $.trim(url);
            var tempURL = newUrl.toLowerCase();
            var hasProtocol = false;
            if (tempURL.length >= 7) {
                if (tempURL.substring(0,7).indexOf('http') != -1) {
                    hasProtocol = true;
                }
            }
            //default protocol is http
            if (!hasProtocol) {
                newUrl = 'http://' + newUrl;
            }
            return newUrl;
        },
        /**
         * Similar to the standard Javascript join() method, but nicer in that
         * it uses a different delimiter for the last node (by default "and"),
         * so that:
         * {code}
         * "1, 2 and 3" == prettyJoin(['1', '2', '3'], function(value) {return value;});
         * {code}
         *
         * @param inputArray
         * @param resolveFn
         * @param finalDelimiter
         */
        prettyJoin : function(inputArray, resolveFn, finalDelimiter) {
            if (!finalDelimiter) {
                finalDelimiter = AppLinks.I18n.getText('applinks.and');
            }
            var maxLength = inputArray.length;
            var message = "";
            $.each(inputArray, function(index, value) {
                if (index == (maxLength - 1) && maxLength > 1) {
                  message += " " + finalDelimiter + "  " + resolveFn(value);
                } else {
                  message += resolveFn(value);
                  if (index + 2 < maxLength) {
                      message += ", ";
                  }
                }
            });
            return message;
        },
        showLoadingIcon: function(element) {
            $('<span class="loading">&nbsp;</span>').insertAfter(element);
        },
        hideLoadingIcon: function(element) {
            $(element).next('.loading').remove();
        },
        findUrl: function(text) {
            var url = undefined;
            var lcText = text.toLowerCase();
            var startOfUrl = lcText.indexOf('http:');
            if (startOfUrl == -1) {
                startOfUrl = lcText.indexOf('https:');
            }
            if (startOfUrl > -1) {
                var endOfUrl = lcText.indexOf(' ', startOfUrl);
                if (endOfUrl == -1) {
                    endOfUrl = lcText.length;
                }
                url = text.substring(startOfUrl, endOfUrl); // use _case-sensitive_ version to retrieve the actual URL
            }
            return url;
        },
        findApplicationType : function(id) {
            id = id.toLowerCase();
            if (id.indexOf("jira") != -1) {
                return "jira";
            } else if (id.indexOf("fisheye") != -1) {
                return "fecru";
            } else if (id.indexOf("confluence") != -1) {
                return "confluence";
            } else if (id.indexOf("refapp") != -1) {
                return "refapp";
            } else {
                return undefined;
            }
        },
        escapeSelector: function(selector) {
            // based on http://samuelsjoberg.com/archive/2009/09/escape-jquery-selectors
            return selector.replace(/([#;&,\.\+\*\~':"\!\^$\[\]\(\)=>\|])/g, "\\$1");
        },
        sanitiseHTML: function(input) {
            var replacements = {
                "<": "&lt;",
                '"': "&quot;",
                "&": "&amp;"
            };
            return input.replace(/[<"&]/g, function(match) {
                return replacements[match];
            });
        },
        refreshOrphanedTrust: function() {
            // post dialog -- check whether we need to remove any orphaned-trust entries
            var updateOrphanedTrust = function(data) {
                $("tr.orphaned-trust-row").each(function() {
                    var $this = $(this);
                    var id = $this.attr("data-id");
                    var type = $this.attr("data-type");
                    var stillExists = false;
                    for (var i = 0; i < data.orphanedTrust.length; i++) {
                        var ot = data.orphanedTrust[i];
                        if (id == ot.id && type == ot.type) {
                            stillExists = true;
                            break;
                        }
                    }
                    if (!stillExists) {
                        $this.remove();
                        if (data.orphanedTrust.length == 0) {
                            // we just removed the last orphaned trust cert, hide warning!
                            $(".orphaned-trust-warning").hide();
                        }
                    }
                });
            };

            AppLinks.SPI.getOrphanedTrust(updateOrphanedTrust);
        },
        removeCssClass: function(element, prefix) {
            $(element).removeClass( function(index, className) {
                   var classes = className.split(' ');
                   var classToRemove = "";
                   $.each(classes, function(index, value) {
                       if (value.indexOf(prefix) != -1) {
                           classToRemove = value;
                       }
                   });
                   return classToRemove;
            } );
        }
    };

    /**
     * Add jQuery event system to AppLinks.UI namespace.
     */
    (function(){
        var eventBus = $({});
        $.each(['bind', 'unbind', 'trigger'], function(i, current){
            AppLinks.UI[current] = function(){
                return eventBus[current].apply(eventBus, arguments);
            }
        });
    })();

    AppLinks.I18n = {
        // very simple i18n param interpolation, doesn't attempt to respect escaping
        //Deferrs to AJS.format for for legacy reason the array conversion needs to stick around.
        interpolate: function(text, params) {
            if (params) {
                if (!$.isArray(params)) {
                    // single arg
                    params = [new String(params)];
                }
                params.unshift(text);
                text = AJS.format.apply(AJS, params);
            }
            return text;
        },
        getTextWithPrefix: function(key, params) {
            return AppLinks.I18n.interpolate(appLinksI18n.entries[i18nRootKey + "." + key], params);
        },
        getText: function(key, params) {
            return AppLinks.I18n.interpolate(AppLinks.I18n.resolveValue(key), params);
        },
        getApplicationTypeName: function(typeId) {
            return appLinksI18n.entries["applinks.application.type." + typeId];
        },
        getEntityTypeName: function(typeId) {
            return appLinksI18n.entries["applinks.entity.type." + typeId];
        },
        getPluralizedEntityTypeName: function(typeId) {
            return appLinksI18n.entries["applinks.entity.type.plural." + typeId];
        },
        getAuthenticationTypeName: function(type) {
            return appLinksI18n.entries["applinks.auth.provider." + type];
        },
        resolveValue: function(key) {
            var value = appLinksI18n.entries[key];
            return typeof value == "undefined" ? key : value;
        }
    };

    var ApplinksHelpPaths = require('applinks/common/help-paths');
    AppLinks.Docs = {

        /**
         * NOTE: this is a dynamically generated version of the link build in _help_link.vm, any update here should be
         * applied there.
         * @method createDocLink
         * @param pageKey a key that maps to a page in ual-help-paths.properties
         * @param sectionKey (Optional) a key that maps to an anchor section id in ual-help-paths.properties
         * @return an html &lt;a&gt; element targeting the specified page & section
         * @deprecated use
         */
        createDocLink: function(pageKey, sectionKey, css) {
            if (!css) {
                css = "";
            } else {
                css = " " + css;
            }
            return $("<a/>", {
                "class": "ual-help-link help-link" + css,
                href: AppLinks.Docs.getDocHref(pageKey, sectionKey),
                target: "_blank",
                "data-help-link-key": pageKey,
                text: AppLinks.I18n.getText("applinks.help"),
                title: AppLinks.I18n.getText("applinks.help")
            });
        },
        /**
         * @method getDocHref
         * @param pageKey a key that maps to a page in ual-help-paths.properties
         * @param sectionKey (Optional) a key that maps to an anchor section id in ual-help-paths.properties
         * @return the url of the given page and section (if specified)
         */
        getDocHref: function(pageKey, sectionKey) {
            var link = ApplinksHelpPaths.getFullPath(pageKey);
            if (sectionKey) {
                link += '#' + ApplinksHelpPaths.getPath(pageKey);
            }
            return link;
        }
    };

    $(document).trigger(AppLinks.Event.PREREADY);
    $(document).trigger(AppLinks.Event.READY);
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/component/autocomplete.js' */
AJS.$(document).bind(AppLinks.Event.READY, function() {
/**
 * TODO: THIS CODE IS COPIED FROM CONFLUENCE and should be part of AUI/AJS.
 * IF AUI comes with the InputDrivenDropDown when can remove this file.
 * https://studio.atlassian.com/browse/AJS-471
 *
 * A simple cache manager that supports a
 * FIFO cache invalidation strategy.
 *
 * @class cacheManager
 * @namespace AJS.Confluence
 * @constructor
 * @param cacheSize the size of the cache before keys are invalidated
 */
AppLinks.autoComplete = {
        cacheManager : function (cacheSize) {
    var cache = {},
        cacheStack = [],
        cacheSize = cacheSize || 30;

    return {
        /**
         * Return the value stored in the cache for the given key
         * @method get
         * @param key {String}
         */
        get: function(key) {
            return cache[key];
        },
        /**
         * Put the given key, value in the cache
         * @method put
         * @param key {String}
         * @param value {Object}
         */
        put: function(key, value) {
            cache[key] = value;
            cacheStack.push(key);
            if (cacheStack.length > cacheSize) {
                delete cache[cacheStack.shift()];
            }
        },
        /**
         * Clear the cache.
         */
        clear : function() {
            cache = {};
            cacheStack = [];
        }
    };
}};


(function($){
    /**
     * Check that all items in the drop down can be displayed - show ellipses at the end of any that
     * are too long. Also remove any unused properties that the dropDown may have stored for each
     * item in the list.
     *
     * @method truncateText
     * @private
     */
    var truncateText = function (dd) {
        AJS.log("InputDrivenDropDown: truncating text");
        var width = dd.$.closest(".aui-dropdown").width(),
            rightPadding = 20; // add some padding so the ellipsis doesn't run over the edge of the box

        $("a span:not(.icon)", dd.$).each(function () {
            var $a = $(this),
                elpss = AJS("var", "&#8230;"),
                elwidth = elpss.width(),
                isLong = false;

            $a.wrapInner($("<em>"));
            $("em", $a).each(function () {
                var $label = $(this);

                $label.show();
                if (this.offsetLeft + this.offsetWidth > width) {
                    var childNodes = this.childNodes,
                        success = false;

                    for (var j = childNodes.length - 1; j >= 0; j--) {
                        var childNode = childNodes[j],
                            truncatedChars = 1,
                            valueAttr = (childNode.nodeType == 3) ? "nodeValue" : "innerHTML",
                            nodeText = childNode[valueAttr];

                        do {
                            if (truncatedChars <= nodeText.length) {
                                childNode[valueAttr] = nodeText.substr(0, nodeText.length - truncatedChars++);
                            } else { // if we cannot fit even one character of the next word, then try truncating the node just previous to this
                                break;
                            }
                        } while (this.offsetLeft + this.offsetWidth + elwidth > width - rightPadding);

                        if (truncatedChars <= nodeText.length) {
                            // we've managed truncate part of the word and fit it in
                            success = true;
                            break;
                        }
                    }

                    if (success) {
                        isLong = true;
                    } else {
                        $label.hide();
                    }
                }
            });
            if (isLong) {
                $a.append(elpss);
                this.elpss = elpss;
            }
        });
    };

    var highlightTokens = function(dd, tokens) {
        if (!tokens.length || !tokens[0]) return;

        AJS.log("InputDrivenDropDown: highlighting tokens");

        // escape regex chars .*+?|()[]{}\ first
        for (var i = 0, ii = tokens.length; i < ii; i++) {
            var token = tokens[i];
            tokens[i] = token ? token.replace(/[\.\*\+\?\|\(\)\[\]{}\\]/g, "\\$") : "";
        }

        var regex = new RegExp("(" + tokens.join("|") + ")", "gi");

        $("li a:not(.dropdown-prevent-highlight) span", dd.$).each(function() {
            var span = $(this),
                html = span.html().replace(regex, "<strong>$1</strong>");
            span.html(html);
        });
    };

    /**
     * Builds and shows the dropdown.
     *
     * @param idd the InputDrivenDropdown
     * @param dropdownData in the form { matrix, query, queryTokens }
     * @private
     */
    var makeDropdown = function (idd, dropdownData) {
        var options = idd.options,
            old_dd = idd.dd;

        if (old_dd) {
            old_dd.hide();
            old_dd.$.remove();
        }

        options.ajsDropDownOptions = options.ajsDropDownOptions || {};
        if (options.ajsDropDownOptions && !options.ajsDropDownOptions.alignment) { // default to left alignment
            options.ajsDropDownOptions.alignment = "left";
        }
        //this needs to be moved into aui
        options.ajsDropDownOptions.selectionHandler = options.ajsDropDownOptions.selectionHandler || function(e, element) {
            if(e.type != "click") {
                e.preventDefault();
                $("a",element).click();
                document.location = $("a",element).attr("href");
            }
        };

        /* Fixing an AUI bug in here:  AJS.dropdown puts the raw 'matrix[i].name' as html, without escaping it !
           The solution is to override their displayHandler
         */
        /**
         * Escape obj.name and return it
         */
        options.ajsDropDownOptions.displayHandler = function (obj) {
            return AJS.escapeHtml(obj.name);
        }

        var dd = idd.dd = new AJS.dropDown(dropdownData.matrix, options.ajsDropDownOptions)[0];

        // could move into dropdown.js in AUI
        if (options.ajsDropDownOptions && options.ajsDropDownOptions.className) {
            dd.$.addClass(options.ajsDropDownOptions.className);
        }

        // place the created drop down using the configured dropdownPlacement function
        // if there is none then use a default behaviour
        if (options.dropdownPlacement) {
            options.dropdownPlacement(dd.$);
        } else {
            AJS.log("No dropdownPlacement function specified. Appending dropdown to the body.");
            $("body").append(dd.$);
        }

        highlightTokens(dd, dropdownData.queryTokens || [dropdownData.query]);
        truncateText(dd);

        if (options.dropdownPostprocess) {
            options.dropdownPostprocess(dd.$);
        }
        dd.show(idd._effect);

        if (typeof options.onShow == "function") {
            options.onShow.call(dd, dd.$);
        }

        return dd;
    };

    /**
     * Provides a controller-agnostic object that listens for controller changes and populates a dropdown
     * via a callback. Most aspects can be customized via the options object parameter.
     * <br>
     * Options are:
     * <li>
     *   getDataAndRunCallback - (required) callback method used to provide data for the dropdown. It must take
     *                          two parameters, user input value and the callback function to execute.
     * </li>
     * <li>
     *   onShow - function to call when the drop-down is displayed
     * </li>
     * <li>
     *   dropdownPlacement - a function that will be called with the drop down and which should place it in the
     *                          correct place on the page. The supplied arguments are 1) the input that issued the
     *                          search, 2) the dropDown to be placed.
     * </li>
     * <li>
     *   ajsDropDownOptions - any options the underlying dropDown component can handle expects
     * </li>
     * <li>
     *   onDeath - callback to run when dropdown dies
     * </li>
     * @class InputDrivenDropDown
     * @namespace AJS
     */
    function InputDrivenDropDown(id, options) {
        this._effect = "appear";
        this._timer = null;

        this.id = id;
        this.options = options;
        this.inactive = false;
        this.busy = false;
        this.cacheManager = AppLinks.autoComplete.cacheManager();
    }

    /**
     * Clears the cache.
     */
    InputDrivenDropDown.prototype.clearCache = function () {
        this.cacheManager.clear();
    };

    /**
     * This method should be called when the user input for this dropdown has changed.
     * It will check the cache before fetching data (via options.getDataAndRunCallback)
     * and displaying the dropdown.
     *
     * @param value {String} the new value of the user input
     * @param force {Boolean} force a change to occur regardless of user input
     */
    InputDrivenDropDown.prototype.change = function (value, force) {
        var t = this;
        if (value != t._value || force) {
            t._value = value;
            t.busy = false;

            clearTimeout(t._timer);

            if (force || (/\S{0,}/).test(value)) {
                var cachedVal = t.cacheManager.get(value);
                if (cachedVal) {
                    makeDropdown(t, cachedVal);
                } else {
                    t.busy = true;
                    t._timer = setTimeout(function () { // delay sending a request to give the user a chance to finish typing their search term(s)
                        t.options.getDataAndRunCallback.call(t, value, t.show);
                    }, 200);
                }
            } else {
                t.dd && t.dd.hide();
            }
        }
    };

    /**
     * Gets the number of visible options in the dropdown.
     */
    InputDrivenDropDown.prototype.dropDownLength = function () {
        return this.dd.links ? this.dd.links.length : 0;
    };
    
    /**
     * Gets the specified menu item from the dropdown list.
     * 
     * @param index {Integer} the 0-based index of the dropdown option list
     */
    InputDrivenDropDown.prototype.dropDownItem = function (index) {
        return this.dropDownLength() > index ? this.dd.links[index] : null;
    };
    
    /**
     * Hides the drop down
     */
    InputDrivenDropDown.prototype.hide = function () {
        this.dd && this.dd.hide();
    };

    /**
     * Hides and removes the drop down from the DOM.
     */
    InputDrivenDropDown.prototype.remove = function () {
        var dd = this.dd;
        if (dd) {
            this.hide();
            dd.$.remove();
        }
        this.inactive = true;
        this.options.onDeath && this.options.onDeath();
    };

    /**
     * Shows the drop down with the given matrix data and query.
     * <br>
     * Matrix property should be an array of arrays, where the sub-arrays represent the different
     * search categories.
     *
     * Expected properties of category sub-array objects are:
     *  - href
     *  - name
     *  - className
     *  - html (optional, replaces href and name)
     *  - icon (optional)
     *
     *
     * @param matrix {Array} matrix to populate the drop down from
     * @param query {String} the user input string that triggered this show
     * @param queryTokens {Array} an array of strings of the query tokens. Use for highlighting search terms.
     */
    InputDrivenDropDown.prototype.show = function (matrix, query, queryTokens) {
        if (this.inactive) {
            AJS.log("Quick search abandoned before server response received, ignoring. " + this);
            return;
        }

        var dropdownData = {
            matrix: matrix,
            query: query,
            queryTokens: queryTokens
        };
        this.cacheManager.put(query, dropdownData);

        makeDropdown(this, dropdownData);
        this.busy = false;
    };

    /**
     * Returns an InputDrivenDropDown. See InputDrivenDropDown for more documentation.
     * @param options {Object} options for the InputDrivenDropDown
     * @constructor
     */
    AppLinks.inputDrivenDropdown = function (options) {
        return new InputDrivenDropDown("inputdriven-dropdown", options);
    };

})(jQuery);
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/component/wizard.js' */
AJS.$(document).bind(AppLinks.Event.PREREADY, function() {

    (function($) {

        $.fn.wizard = function(settings) {
            var config = {
                width: 500,
                height: 350,
                onshow: function(popup, configuration) {
                    return true;
                },
                aftershow: function() {
                    return true;
                },
                oncancel: function() {
                    return true;
                },
                onsubmit: function() {
                    return true;
                },
                aftersubmit: function() {
                    return true;
                },
                onnext: function() {
                    return true;
                },
                onprevious: function() {
                    return true;
                },
                cancelLabel: AppLinks.I18n.getText("applinks.cancel"),
                submitLabel: AppLinks.I18n.getText("applinks.create"),
                nextLabel: AppLinks.I18n.getText("applinks.next"),
                previousLabel: AppLinks.I18n.getText("applinks.previous"),
                id: ""
            };

            if (!settings) settings = {};

            settings = $.extend(config, settings);

            var result = this;

            this.each(function() {
                var obj = $(this);
                var popup = new AJS.Dialog(settings.width, settings.height, settings.id);
                var showFn = show(popup, settings.onshow, settings.aftershow);
                var cancelFn = cancel(popup, settings.oncancel);
                var submitFn = submit(popup, settings.onsubmit, settings.aftersubmit);
                var previousFn = previous(popup, settings.onprevious)
                var nextFn = next(popup, settings.onnext);

                var disableNextFn = disableNext(popup);
                var enableNextFn  = enableNext(popup);

                var disableSubmitFn = disableSubmit(popup);
                var enableSubmitFn  = enableSubmit(popup);

                var disablePreviousFn = disablePrevious(popup);
                var enablePreviousFn  = enablePrevious(popup);

                if (settings.showButtonId) {
                    $('#' + settings.showButtonId).click(showFn);
                }

                var pages = findPages(obj);


                for (var pageIndex = 0; pageIndex < pages.length; pageIndex++) {
                    var page = pages[pageIndex];
                    createPage(popup, page);
                    if (page.className) {
                        popup.addHeader(page.title, page.className + "-header");
                    } else {
                        popup.addHeader(page.title);
                    }

                    if (pageIndex != 0 && $(page.div).attr("previous") != "false") {
                        popup.addButton(settings.previousLabel, previousFn, "applinks-previous-button");
                    }

                    if (pageIndex < pages.length - 1 && $(page.div).attr("submit") != "true" && $(page.div).attr("next") != "false") {
                        popup.addButton(settings.nextLabel, nextFn, "applinks-next-button");
                    }

                    if ($(page.div).attr("submit") == "true") {
                        popup.addButton(settings.submitLabel, submitFn, "wizard-submit");
                    }

                    if (!popup.getPage(pageIndex).buttonpanel) {
                        //THIS IS A DUMMY BUTTON, which gets remove afterwards
                        //THE DUMMY BUTTON will cause the cancel text link to appear on the correct position.
                        //IT IS A WORKAROUND so I don't have to change the dialog.js code
                        popup.addButton("", null);
                        $(popup.getPage(pageIndex).buttonpanel).empty();
                        var cancelLink = $('<button class="aui-button aui-button-link button-panel-button applinks-cancel-link">' + settings.cancelLabel + '</button>');
                        popup.getPage(pageIndex).buttonpanel.append(cancelLink);
                        cancelLink.click(cancelFn);
                    } else {
                        var cancelLink = $('<button class="aui-button aui-button-link button-panel-link button-panel-cancel-link applinks-cancel-link">' + settings.cancelLabel + '</button>');
                        $(popup.getPage(pageIndex).buttonpanel).append(cancelLink);
                        cancelLink.click(cancelFn);
                    }

                    if (pageIndex < pages.length - 1) {
                        popup.addPage();
                    }
                }

                result = {
                    dialog: popup,
                    nextPage: nextFn,
                    prevPage: previousFn,
                    submit: submitFn,
                    cancel: cancelFn,
                    show: showFn,
                    disableNextBtn     : disableNextFn,
                    enableNextBtn      : enableNextFn,
                    disableSubmitBtn   : disableSubmitFn,
                    enableSubmitBtn    : enableSubmitFn,
                    disablePreviousBtn : disablePreviousFn,
                    enablePreviousBtn  : enablePreviousFn
                };
                popup.gotoPage(0);
                popup.gotoPanel(0);
            });

            return result;
        };

        function disablePrevious(popup) {
            return function() {
                disable(getButton(popup, 'applinks-previous-button'));
            }
        }

        function enablePrevious(popup) {
            return function() {
                enable(getButton(popup, 'applinks-previous-button'));
            }
        }

        function disableNext(popup) {
            return function() {
                disable(getButton(popup, 'applinks-next-button'));
            }
        }

        function enableNext(popup) {
            return function() {
                enable(getButton(popup, 'applinks-next-button'));
            }
        }

        function disableSubmit(popup) {
            return function(showLoading) {
                var buttonEl = getButton(popup, 'wizard-submit');
                disable(buttonEl);
                if (typeof(showLoading) == 'undefined' || showLoading) {
                    $('<span class="loading">&nbsp;</span>').insertBefore(buttonEl);
                } else {
                    buttonEl.parent().find('.loading').remove();
                }
            }
        }

        function enableSubmit(popup) {
            return function() {
                var buttonEl = getButton(popup, 'wizard-submit');
                enable(buttonEl);
                buttonEl.parent().find('.loading').remove();
            }
        }

        function getButton(popup, cssClass) {
            return $(popup.getPage(popup.curpage).buttonpanel).find('.' + cssClass);
        }

        function resetForms(popup) {
             $(popup.popup.element).find('form').each( function() {
                  this.reset();
             });
        }

        function enable(element) {
            element.attr('disabled', false);
        }

        function disable(element) {
            element.attr('disabled', true);
        }
		
        function show(popup, onshow, aftershow) {
            return function(configuration) {
				if (onshow(popup, configuration) !== false) {
                    popup.gotoPage(0);
                    popup.gotoPanel(0);
                    $(document).unbind('keydown.ual.dialog');
                    $(document).bind('keydown.ual.dialog', attachKeypressListener(popup));
					popup.show();
                    aftershow();
                }
            }
        }

        function cancel(popup, oncancel) {
            return function() {
                if (oncancel(popup) !== false) {
                    popup.hide();
                    resetForms(popup);
                }
            }
        }

        function previous(popup, onprevious) {
            return function() {
                if (onprevious(popup) !== false) {
                    popup.prevPage();
                }
            }
        }

        function next(popup, onnext) {
            return function() {
                if (onnext(popup) !== false) {
                    popup.nextPage();
                }
            }
        }

        function attachKeypressListener(popup) {
            return function(e) {
                if (e.keyCode === 27) {
                    resetForms(popup);
                    $(document).unbind('keydown.ual.dialog');
                }
            }
        }

        function submit(popup, onSubmit, afterSubmit) {
            return function() {
                if (onSubmit(popup) !== false) {
                    afterSubmit(popup);
                    resetForms(popup);
                }
            }
        }

        function createPage(popup, page) {
            var panelDivs = $("> div[panel]", page.div);
            if (panelDivs.length > 0) {
                panelDivs.each(function(index, panelDiv) {
                    var popupPage = popup.addPanel(panelDiv.title, null, panelDiv.className, 'menu-' + panelDiv.id);
                    popupPage.getCurrentPanel().body.append(panelDivs[index]);
                });
            }
            else {
                var popupPage = popup.addPanel(page.title);
                popupPage.getCurrentPanel().body.append(page.div);
            }
        }


        function findPages(containerDiv) {
            var pagesDivs = $(" > div", containerDiv);
            var pages = [];
            pagesDivs.each(function(index) {
                var pageDiv = $(this);
                pages[index] = {
                    title: pageDiv.attr('title') || null,
                    className: pageDiv.attr('class'),
                    div: pageDiv
                };
            });
            return pages;
        }
    })(jQuery)
});
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/feature/applinks-wizard/applinkwizard.js' */
(function($) {
    AppLinks.Wizard = {
        getWizard: function(){
            return $("#create-application-link-container").data('wizard');
        },
        initAuthenticationUI: function(element) {
            var root = $(element);
            var createTwoWayLinkCheckbox = root.find('.create-reciprocal-link');
            var ualArrow = root.find('.ual-arrow');
            var linkDetails = root.find('.two-way-link-details');
            var linkDescription = root.find('.reciprocal-link-description');
            var noLinkDescription = root.find('.no-reciprocal-link-description');
            createTwoWayLinkCheckbox.click(function() {
                if (createTwoWayLinkCheckbox.is(':checked')) {
                    ualArrow.removeClass('no-background');
                    linkDetails.show();
                    linkDescription.show();
                    noLinkDescription.hide();
                } else {
                    ualArrow.addClass('no-background');
                    linkDetails.hide();
                    linkDescription.hide();
                    noLinkDescription.show();
                }
            });
            var sameUserBtn = root.find('.same-user-radio-btn');
            var differentUserBtn = root.find('.different-user-radio-btn');
            var differentUserBaseImage = root.find('.different-userbase-image');
            var sameUserBaseImage = root.find('.same-userbase-image');

            sameUserBtn.click(function() {
                differentUserBaseImage.addClass('different-userbase-image-grey');
                sameUserBaseImage.removeClass('same-userbase-image-grey');
            });

            differentUserBtn.click(function() {
                sameUserBaseImage.addClass('same-userbase-image-grey');
                differentUserBaseImage.removeClass('different-userbase-image-grey');
            });
        },

        initNonUALUI : function(element) {
            var root = $(element);
            var applicationTypesEl = root.find('.application-types');
            for (var i = 0; i < nonAppLinksApplicationTypes.length; i++) {
                $('<option value=\"' + nonAppLinksApplicationTypes[i].typeId + '\">' + nonAppLinksApplicationTypes[i].label + '</option>').appendTo(applicationTypesEl);
            }
        },
        fetchManifest : function(wizard, dialogRootEl, ualAppCallbackFn, nonUALAppCallbackFn) {
            var applicationURLEl = dialogRootEl.find('#application-url');
            if (applicationURLEl.val() == '') {
                var applicationTypeEl = dialogRootEl.find('#application-types');
                if (applicationTypeEl.val() == '') {
                    $('<div class="error applinks-error">' + AppLinks.I18n.getText('applinks.error.url.field.empty') + '</div>').insertAfter(applicationURLEl);
                    return false;
                }
                var success = function(data) {
                    wizard.enableSubmitBtn();
                    wizard.enablePreviousBtn();
                    wizard.cancel();
                    AppLinks.UI.listApplicationLinks(data.applicationLink.id, 'new', data);
                };
                AppLinks.SPI.createStaticUrlAppLink(applicationTypeEl.val(), success, null);
                return true;
            }
            var appUrl = AppLinks.UI.addProtocolToURL(applicationURLEl.val());

            AppLinks.UI.showLoadingIcon(applicationURLEl);
            var success = function(data) {
                var manifest = data;
                wizard.enableNextBtn();
                dialogRootEl.find('.loading').remove();
                dialogRootEl.find('.reciprocal-rpc-url').val($('#baseUrl').val());
                if (typeof data.typeId != "undefined") {
                    AppLinks.Wizard.handleUALManifest(manifest, dialogRootEl);
                    wizard.dialog.gotoPage(2);
                    dialogRootEl.find('.reciprocal-link-username').focus();
                    if (ualAppCallbackFn) {
                      ualAppCallbackFn(manifest);
                    }
                }
                else {
                    if (data.code == 'applinks.warning.redirected.host' && !applicationURLEl.data('hasWarnedAboutRedirection')) {
                        // The host requires a redirection. Stay on the same page, ask for a confirmation.
                        AppLinks.UI.displayValidationErrorMessages('manifest-validation-errors', dialogRootEl, data.warning);
                        applicationURLEl.data('hasWarnedAboutRedirection', 'true');
                        var unsetRedirectionWarning = function () {
                            $(applicationURLEl).removeData('hasWarnedAboutRedirection');
                            $(applicationURLEl).unbind('change', unsetRedirectionWarning);
                        };
                        applicationURLEl.bind('change', unsetRedirectionWarning);
                    }
                	else if (data.code == 'applinks.warning.unknown.host' && !applicationURLEl.data('forceWhenHostIsOffline')) {
                	    // The host doesn't ping. Stay on the same page, ask for a confirmation.
                	    AppLinks.UI.displayValidationErrorMessages('manifest-validation-errors', dialogRootEl, data.warning);
                	    applicationURLEl.data('forceWhenHostIsOffline', 'true');
                	    var unsetForceWhenHostIsOffline = function () {
                	        $(applicationURLEl).removeData('forceWhenHostIsOffline');
                	        $(applicationURLEl).unbind('change', unsetForceWhenHostIsOffline);
                	    };
                	    applicationURLEl.bind('change', unsetForceWhenHostIsOffline);
            		}
                	else {
                        if (manifest.code == 'applinks.warning.unknown.host' || manifest.code == "applinks.warning.redirected.host") {
                	        // The user has already been notified of this warning.
                	        delete manifest.warning;
                	        delete manifest.code;
                	    }
                	    AppLinks.Wizard.handleNonUALManifest(manifest, appUrl, dialogRootEl);
                        wizard.dialog.gotoPage(1);
                        dialogRootEl.find('.application-name').focus();
                        if (nonUALAppCallbackFn) {
                          nonUALAppCallbackFn(manifest);
                        }
                	}
                }
            };
            wizard.disableNextBtn();
            AppLinks.SPI.tryToFetchManifest(appUrl, success, AppLinks.UI.displayValidationError('manifest-validation-errors', dialogRootEl, function() {
                wizard.enableNextBtn();
            }));
            return appUrl;
        },
        handleUALManifest : function(manifest, element) {
            var root = $(element);
            root.find('.remote-app-image').removeClass( function(index, className) {
            var classes = className.split(' ');
            var classToRemove = "";
                $.each(classes, function(index, value) {
                    if (value.indexOf('application-type-image-') != -1) {
                        classToRemove = value;
                    }
                });
                return classToRemove;
            });
            root.find('.remote-app-image').addClass('application-type-image-' + manifest.typeId);
            root.find('.link-to-app-type').html(AppLinks.I18n.getText('applinks.create.title.link.to', AppLinks.I18n.getApplicationTypeName(manifest.typeId)));
            root.find('.remote-app-name').text(AppLinks.UI.shortenString(manifest.name, 20));
            root.find('.create-reciprocal-link').attr('checked', true);
            root.find('#reciprocal-link-back-to-server').html(AppLinks.I18n.getText('applinks.create.link.back.to.server', AJS.escapeHtml(manifest.name)));
            // For the two way link text, we need to specify different roles for the credentials depending on the remote app
            // For JIRA and Confluence version < 3.10, it is system administrator
            // For everything else, it is administrator
            var twoWayLinkParams = ["administrator", AJS.escapeHtml(manifest.name),
                             '<a target="_blank" href="' + AppLinks.Docs.getDocHref("applinks.docs.adding.application.link") + '">', '</a>'];
            if(manifest.applinksVersion != undefined) {
                var remoteVersion = manifest.applinksVersion.split(".");
                var majorVersion = parseInt(remoteVersion[0]);
                var minorVersion = parseInt(remoteVersion[1]);
                // we don't have to check for versions < 3 since those won't have the manifest.
                if ((manifest.typeId == "jira" || manifest.typeId == "confluence") && (majorVersion == 3 && minorVersion < 10)) {
                    twoWayLinkParams[0] = "system administrator";
                }
            }
            root.find('.reciprocal-link-description').html(AppLinks.I18n.getText('applinks.create.two.way.link', twoWayLinkParams));
            root.find('.no-reciprocal-link-description').hide();
            root.find('.no-reciprocal-link-description').html(AppLinks.I18n.getText('applinks.create.two.way.no.link', AJS.escapeHtml(manifest.name)));
            root.find('.reciprocal-link-username').val('');
            root.find('.reciprocal-link-password').val('');
            root.find('.ual-arrow').removeClass('no-background');
            root.find('.two-way-link-details').show();
            root.find('.reciprocal-link-description').show();
            root.find('.no-reciprocal-link-description').hide();
        },
        handleNonUALManifest : function(data, appUrl, element) {
            var root = $(element);
            root.find('.application-name').val('');
            root.find(".application-types option:first-child").attr("selected", "selected");
            root.find('.non-ual-application-url').text(appUrl);
            if (data.warning) {
                root.find('.create-non-ual-warning').show();
                root.find('.create-non-ual-warning').html(data.warning);
            } else {
                root.find('.create-non-ual-warning').hide();
            }
        },
        checkReciprocalLinkFormThreeStepMode : function(element, handleOneWayLinkFn, handleTwoWayLinkDetailsSuccess, appUrl, errorFn) {
            var root = $(element);
            if (root.find('.create-reciprocal-link').is(':checked')) {
                var reciprocalRPCURL = $.trim(root.find('.reciprocal-rpc-url').val());
                if (reciprocalRPCURL == '') {
                    $("<div class='error applinks-error'>" + AppLinks.I18n.getText('applinks.error.url.field.empty') + "</div>").insertAfter(root.find('.reciprocal-rpc-url'))
                    if (errorFn) {
                        errorFn();
                    }
                    return;
                }
                var reciprocalLinkUsername = root.find('.reciprocal-link-username');
                var reciprocalLinkPwd = root.find('.reciprocal-link-password');
                if (reciprocalLinkUsername.val() == '') {
                    $('<div class="error applinks-error">'+ AppLinks.I18n.getText('applinks.error.username.empty') +'</div>').insertAfter(reciprocalLinkUsername);
                    if (errorFn) {
                        errorFn();
                    }
                    return false;
                }

                //verify user has admin rights.
                var successFn = function(data) {
                    root.find('.same-user-description').find('input').attr('checked', true);
                    root.find(".trust-radio-btn").attr('checked', true);
                    root.find('.same-user-radio-btn').click();
                    handleTwoWayLinkDetailsSuccess(data);
                };
                reciprocalRPCURL = AppLinks.UI.addProtocolToURL(reciprocalRPCURL);
                AppLinks.SPI.verifyTwoWayLinkDetails(appUrl, reciprocalRPCURL, reciprocalLinkUsername.val(), reciprocalLinkPwd.val(), successFn, AppLinks.UI.displayValidationError('two-way-link-errors', element, errorFn));
                return false;
            } else {
                handleOneWayLinkFn();
                return false;
            }
        },
        checkReciprocalLinkFormTwoStepMode : function(element, appUrl, successFn, errorFn) {
            var root = $(element);
            var reciprocalRPCURL = $.trim(root.find('.reciprocal-rpc-url').val());
            if (reciprocalRPCURL == '') {
                $("<div class='error applinks-error'>" + AppLinks.I18n.getText('applinks.error.url.field.empty') + "</div>").insertAfter(root.find('.reciprocal-rpc-url'))
                if (errorFn) {
                    errorFn();
                }
                return;
            }
            var reciprocalLinkUsername = root.find('.reciprocal-link-username');
            var reciprocalLinkPwd = root.find('.reciprocal-link-password');
            if (reciprocalLinkUsername.val() == '') {
                $('<div class="error applinks-error">'+ AppLinks.I18n.getText('applinks.error.username.empty') +'</div>').insertAfter(reciprocalLinkUsername);
                if (errorFn) {
                    errorFn();
                }
                return false;
            }

            reciprocalRPCURL = AppLinks.UI.addProtocolToURL(reciprocalRPCURL);
            AppLinks.SPI.verifyTwoWayLinkDetails(appUrl, reciprocalRPCURL, reciprocalLinkUsername.val(), reciprocalLinkPwd.val(), successFn, AppLinks.UI.displayValidationError('two-way-link-errors', element, errorFn));
            return false;
        }
    }
})(AJS.$);
;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'applinks/internal/common/urls.js' */
define('applinks/common/urls', [
    'applinks/lib/aui',
    'applinks/lib/lodash',
    'applinks/common/products'
], function(
    AJS,
    _,
    Products
) {
    /**
     * Utility functions for generating URLs in JS, including a link to applinks admin screen.
     */
    var ApplinksUrls = {

        /**
         * Generate a URL from the base and parameters.
         * @param baseUrl the baseUrl
         * @param parametersMap a map of parameters to add, in the form of { parameterName :  parameterValue }
         * @return {String}
         */
        generateUrl: function(baseUrl, parametersMap) {
            var redirectUrl = baseUrl;

            if(_.isUndefined(parametersMap)) {
                return redirectUrl;
            } else {
                _.each(parametersMap, function(value, key) {
                    if(redirectUrl.indexOf('?') < 0) {
                        redirectUrl = redirectUrl + '?';
                    } else {
                        redirectUrl = redirectUrl + '&';
                    }
                    redirectUrl = redirectUrl + key + "=" + encodeURIComponent(JSON.stringify(value))
                });

                return redirectUrl;
            }
        }
    };

    ApplinksUrls.Local = {

        admin: function(params) {
            var url = AJS.contextPath() + "/plugins/servlet/applinks/listApplicationLinks";
            return ApplinksUrls.generateUrl(url, params);
        }
    };

    ApplinksUrls.Remote = {

        /**
         * Generate a URL to remote Applinks Admin screen. For compatibility it needs to accept `applicationTypeId`.
         *
         * @param remoteBaseUrl
         * @param applicationTypeId
         * @param params extra URL params
         * @returns {String}
         */
        admin: function(remoteBaseUrl, applicationTypeId, params) {
            var suffix = applicationTypeId === Products.CONFLUENCE ?
                '/admin/listapplicationlinks.action' :
                '/plugins/servlet/applinks/listApplicationLinks';
            var url = remoteBaseUrl + suffix;

            return ApplinksUrls.generateUrl(url, params);
        }
    };

    return ApplinksUrls;
});;
;
/* module-key = 'com.atlassian.applinks.applinks-plugin:applinks-util-js', location = 'js/help-link-analytics.js' */
(function ($) {
    $(function () {
        AJS.$('body').on('click', '.help-link', function () {
            AJS.trigger('analyticsEvent', {
                name: 'applinks.view.documentation',
                data: {linkKey: $(this).attr('data-help-link-key')}
            });
        });
    })
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-applinks-common-plugin:issue-link-applinks', location = 'js/issuelink-applinks.js' */
/**
 * Initialises anything requiring OAuth authentication. Requires the following elements:
 * <div class="issue-link-applinks-authentication-message"></div>
 */
var IssueLinkAppLinks = IssueLinkAppLinks || (function($) {
    function createHelper(servers, context, settings) {
        var helper = {};
        var selectedServer = null;

        function selectServer(appId) {
            selectedServer = getServer(servers, appId);

            var authenticationRequired = selectedServer && selectedServer.requireCredentials;
            doAuthenticationRequired(authenticationRequired, context);

            return {"authenticationRequired": authenticationRequired};
        }

        function setAuthenticationRequired(appId, authenticationRequired) {
            var server = getServer(servers, appId);
            if (server) {
                server.requireCredentials = authenticationRequired;

                // Refresh the authenication message if we have updated the selected server
                if (selectedServer && selectedServer.id === appId) {
                    doAuthenticationRequired(authenticationRequired, context);
                }
            }
        }

        function doAuthenticationRequired(required, context) {
            $(".issue-link-applinks-authentication-message", context).empty();
            if (required) {
                createAuthRequiredBanner($(".issue-link-applinks-authentication-message", context), context);
                $(".issue-link-oauth-toggle").hide();
                $(".buttons-container input[type=submit]", context).attr("disabled", "disabled");
            } else {
                $(".issue-link-oauth-toggle").show();
                $(".buttons-container input[type=submit]", context).removeAttr("disabled");
            }
        }

        function createAuthRequiredBanner($container, context) {
            var oauthCallbacks = {
                onSuccess: function () {
                    selectedServer.requireCredentials = false;
                    doAuthenticationRequired(false, context);
                    if (settings.onAuthenticationSuccessCallback) {
                        settings.onAuthenticationSuccessCallback(context, selectedServer.id, helper);
                    }
                },
                onFailure: function () {
                    if (settings.onAuthenticationFailedCallback) {
                        settings.onAuthenticationFailedCallback(context, selectedServer.id, helper);
                    }
                }
            };

            var encodedServerName = AJS.escapeHtml(selectedServer.name);
            if (selectedServer.authUrl) {
                var $banner = $('<div class="aui-message warning closeable shadowed applinks-auth-request"><p><span class="aui-icon icon-applinks-key"></span></p></div>');
                $banner.append(AJS.format("Authorization required to create issue link. Please \u003ca href=\"{0}\" class=\"applink-authenticate\"\u003eauthenticate\u003c/a\u003e with \u003ca href=\"{1}\"\u003e{2}\u003c/a\u003e.", selectedServer.authUrl, selectedServer.url, encodedServerName));
                $("a", $banner).addClass("applink-authenticate");
                $('.applink-authenticate', $banner).click(function (e) {
                    authenticateRemoteCredentials(selectedServer.authUrl, oauthCallbacks.onSuccess, oauthCallbacks.onFailure);
                    e.preventDefault();
                });
                $container.append($banner);
            } else {
                var warningMessage = AJS.format("Unable to create a link to \u003ca href=\"{0}\"\u003e{1}\u003c/a\u003e as the application does not have any authentication configured.", selectedServer.url, encodedServerName);
                AJS.messages.warning($container, {body: warningMessage});
            }
        }

        function createOAuthCallback() {
            if (!AppLinks.OAuthCallback && typeof(oauthCallback) === "undefined") {
                AppLinks.OAuthCallback = function() {

                };

                AppLinks.OAuthCallback.prototype.success = function() {
                    this.aouthWindow.close();
                    this.onSuccess();
                    delete oauthCallback;
                    delete AppLinks.OAuthCallback;
                };

                AppLinks.OAuthCallback.prototype.failure = function() {
                    this.aouthWindow.close();
                    this.onFailure();
                    delete oauthCallback;
                    delete AppLinks.OAuthCallback;
                };

                AppLinks.OAuthCallback.prototype.show = function(url, onSuccess, onFailure) {
                    this.onSuccess = onSuccess;
                    this.onFailure = onFailure;
                    this.aouthWindow = window.open(url, "com_atlassian_applinks_authentication");
                };
                // set the global oAuthCallback variable required by AppLinks
                oauthCallback = new AppLinks.OAuthCallback();
            }
        }

        function authenticateRemoteCredentials(url, onSuccess, onFailure) {
            createOAuthCallback();

            $('.applinks-error').remove();
            oauthCallback.show(url, onSuccess, onFailure);
        }

        return $.extend(helper, {
            selectServer: selectServer,
            setAuthenticationRequired: setAuthenticationRequired
        });
    }

    function getServer(servers, appId) {
        var i;
        if (servers.length) {
            for (i = 0; i < servers.length; i++) {
                if (servers[i].id === appId) {
                    return servers[i];
                }
            }
        }
        return null;
    }

    /**
     * Called only once during the initialisation to retrieve the list of servers.
     *
     * @param context the context to perform the initialisation. This is either the inline dialog or the entire document
     *                body.
     */
    function initApplinkServers(settings, context, deferred) {
        var currentAppId = settings.getCurrentAppId(context);
        var applicationType = $(".issue-link-applinks-application-type", context).val();
        var issueId = settings.getIssueId(context);
        $.get(AJS.contextPath() + '/rest/issueLinkAppLink/1/appLink/info', { type: applicationType, issueIdOrKey: issueId }, function (servers) {
            var helper = createHelper(servers, context, settings);
            var currentRequiresCredentials;
            if (servers && servers.length) {
                var currentServer = getServer(servers, currentAppId);
                if (currentServer) {
                    currentRequiresCredentials = $(".issue-link-applinks-authentication-message", context).hasClass("required");
                    if (currentRequiresCredentials) {
                        currentServer.requireCredentials = true;
                    }
                    helper.selectServer(currentAppId);
                }
                deferred.resolve(context, helper);
            } else {
                deferred.reject(context);
            }
        });
    }

    /**
     * @return jQuery.Promise<String>
     */
    function init(settings, context) {
        var deferred = $.Deferred();

        var isIssueLinkAppLinkContent = $(".issue-link-applinks-authentication-message", context).length !== 0;
        if (isIssueLinkAppLinkContent && settings.shouldExecute(context)) {
            initApplinkServers(settings, context, deferred);
        }

        return deferred.promise();
    }

    return {
        init: init
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-remote-jira-js', location = 'js/issuelink-jira.js' */
/**
 * Initialises OAuth authentication for JIRA Application Links. Requires the following elements:
 * <div class="issue-link-applinks-authentication-message"></div>
 */
(function ($) {

    var settings = {
        getCurrentAppId: function (context) {
            return $("#jira-app-link", context).val();
        },
        shouldExecute: function (context) {
            return $("#jira-app-link", context).length !== 0;
        },
        getIssueId: function (context) {
            return $("input[name=id]", context).val();
        }
    };

    var updateIssuePicker = function($select, appId) {
        if ($select.length) {
            // Update the appId param
            $select.attr("data-ajax-options.data.app-id", appId);
            if (appId && appId !== "") {
                // Set the url for remote JIRA queries
                $select.attr("data-ajax-options.url", contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/picker");
            }
            else {
                // Set the url for local JIRA queries
                $select.attr("data-ajax-options.url", contextPath + "/rest/api/2/issue/picker");
            }

            $select.trigger("updateOptions");

            // Now that we have changed server, our current issue selection is no longer relevant
            $select.trigger("clearSelection");
        }
    };

    var updateCreateReciprocalCheckbox = function(appId, context) {
        var $reciprocalCheckbox = $("#create-reciprocal", context);
        if ($reciprocalCheckbox.length) {
            if (appId && appId !== "") {
                // Get default choice for creating a remote reciprocal link
                var defaultChoice = ($("#create-reciprocal-default", context).val() == "true");
                if (defaultChoice) {
                    $reciprocalCheckbox.attr("checked", "checked");
                } else {
                    $reciprocalCheckbox.removeAttr("checked");
                }
                $reciprocalCheckbox.removeAttr("disabled");
                $("#create-reciprocal-fieldset", context).removeClass("disabled");
            } else {
                // Set to checked for local links, as they always create a reciprocal link
                $reciprocalCheckbox.attr("checked", "checked");
                $reciprocalCheckbox.attr("disabled", "disabled");
                $("#create-reciprocal-fieldset", context).addClass("disabled");
            }
        }
    };

    JIRA.bind(JIRA.Events.NEW_PAGE_ADDED, function (e, context) {

        var $select = $("#jira-issue-keys", context);
        if ($select.length) {
            var appId = $("#jira-app-link", context).val();
            updateIssuePicker($select, appId);
            updateCreateReciprocalCheckbox(appId, context);
        }

        IssueLinkAppLinks.init(settings, context).done(function (context, helper) {
            $("#jira-app-link", context).change(function () {
                var appId = $(this).val();
                helper.selectServer(appId);
                updateIssuePicker($select, appId);
                updateCreateReciprocalCheckbox(appId, context);
            });
        });
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-jira-search-js', location = 'js/issuelink-jira-jqlautocomplete.js' */
/**
 * Instantiates jql autocomplete functionality on request instead of on page load.
 */
var IssueLinkJQLAutoComplete = IssueLinkJQLAutoComplete || (function($) {

    /**
     * Initializes an auto complete field
     */
    function initialize(options) {

        var fieldID = options.fieldID;
        var errorID = options.errorID;
        var autoCompleteUrl = options.autoCompleteUrl;
        var autoCompleteData = options.autoCompleteData;
        var formSubmitFunction = options.formSubmitFunction;

        var $field = $('#'+fieldID);
        var hasFocus = $field.length > 0 && $field[0] == document.activeElement;

        var jqlFieldNames = autoCompleteData.visibleFieldNames || [];
        var jqlFunctionNames = autoCompleteData.visibleFunctionNames || [];
        var jqlReservedWords = autoCompleteData.jqlReservedWords || [];

        var jqlAutoComplete = JIRA.JQLAutoComplete({
            fieldID: fieldID,
            parser: JIRA.JQLAutoComplete.MyParser(jqlReservedWords),
            queryDelay: .65,
            jqlFieldNames: jqlFieldNames,
            jqlFunctionNames: jqlFunctionNames,
            minQueryLength: 0,
            allowArrowCarousel: true,
            autoSelectFirst: false,
            errorID: errorID,
            autoCompleteUrl: autoCompleteUrl
        });

        $field.unbind("keypress", submitOnEnter);

        if (formSubmitFunction) {
            $field.keypress(function (e) {
                if (jqlAutoComplete.dropdownController === null || !jqlAutoComplete.dropdownController.displayed || jqlAutoComplete.selectedIndex < 0) {
                    if (e.keyCode === 13 && !e.ctrlKey && ! e.shiftKey)
                    {
                        formSubmitFunction();
                        return false;
                    }
                    else
                    {
                        return true;
                    }
                }
            });
        }

        jqlAutoComplete.buildResponseContainer();
        jqlAutoComplete.parse($field.text());
        jqlAutoComplete.updateColumnLineCount();

        $field.click(function(){
            jqlAutoComplete.dropdownController.hideDropdown();
        });

        if (hasFocus) {
            $field.select();
        }
    }

    return {
        initialize: initialize
    };
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-jira-search-js', location = 'js/issuelink-jira-search.js' */
AJS.$(function ($) {
    var remoteJiraSearchDialog =  new JIRA.FormDialog({
        id: "remote-jira-search-dialog",
        trigger: "#link-jira-issue .remote-jira-search-trigger",
        widthClass: "large",
        content: function (render) {
            render(JIRA.Templates.RemoteJiraIssueSearch.dialog());
            initSearchDialog(this.$popup);
        },
        submitHandler: function(e, callback){
            e.preventDefault();
            $("#simple-search-panel-button").removeAttr("disabled");
            $("#advanced-search-panel-button").removeAttr("disabled");
            if($(e.target).attr("id") === "remote-jira-simple-search-form"){
                $("#simple-search-panel-button").click();
            } else {
                $("#advanced-search-panel-button").click();
            }
            callback();
        }
    });

    function initSearchDialog($dialog) {
        // Gather the JQL auto complete data
        var appId = $("#jira-app-link").val();
        var autoCompletePromise = getJqlAutoCompleteData(appId);

        // Bind the simple search button
        $("#simple-search-panel-button", $dialog).click(function () {
            $("#search-results-table", $dialog).empty();
            var searchText = $("#link-search-text", $dialog).val();
            searchText = $.trim(searchText);
            if (searchText) {
                doSimpleSearch(searchText, $dialog);
            } else {
                AJS.messages.info("#search-results-table", {
                    body: "Please enter search value.",
                    closeable: false
                });
            }

            return false;
        });

        // Bind the advanced search button
        $("#advanced-search-panel-button", $dialog).click(function() {
            advancedSearchButtonClick($dialog);
            return false;
        });

        $("#simple-search-toggle", $dialog).click(function() {
            $("#remote-jira-simple-search-form", $dialog).show();
            $("#remote-jira-advanced-search-form", $dialog).hide();
            return false;
        });

        $("#linkjiraissue-add-selected", $dialog).click(function(){
            //select selected checkboxes of only *visible* rows
            //filtering to visible is necessary due to tabbed layout
            $("table tbody tr:visible  td.selection input:checked", $dialog).each(function(){
                var issueKey = $(this).parent().data("key");
                $("#jira-issue-keys").trigger("selectOption", [{
                    value: issueKey
                }]);
            });


            // Clear all error messages on the parent dialog, as we now have a newly selected issue
            $("#link-issue-dialog .error").hide();

            remoteJiraSearchDialog.hide();

            $("#link-issue-dialog")
                    .show()
                    .trigger("multiSelectRevealed");

            $("#jira-issue-keys-textarea").focus().select();
        });


        $("#advanced-search-toggle", $dialog).click(function() {
            $("#remote-jira-advanced-search-form", $dialog).show();
            $("#remote-jira-simple-search-form", $dialog).hide();

            // Initialise the JQL auto complete once we have the data
            // Ensure that we only initialise it once only
            var $jqlSearchText = $("#jql-search-text");
            if (!$jqlSearchText.attr("jql-initialized")) {
                setAutoCompleteLoadingIconVisible(true, $dialog);
                WRM.require("wr!jira.webresources:jqlautocomplete", function(){
                    autoCompletePromise.done(function (smartAjaxResult) {
                        if (smartAjaxResult.successful) {
                            // Enable JQL AutoComplete
                            IssueLinkJQLAutoComplete.initialize({
                                fieldID: "jql-search-text",
                                errorID: "jql-search-error",
                                autoCompleteUrl: getAutoCompleteUrl(appId),
                                autoCompleteData: smartAjaxResult.data,
                                formSubmitFunction: function() {
                                    advancedSearchButtonClick($dialog);
                                }
                            });
                        }
                        else {
                            setJQLErrorVisible(false, $dialog);
                            setAutoCompleteFailedIconVisible(true, $dialog);
                        }
                        setAutoCompleteLoadingIconVisible(false, $dialog);
                        $jqlSearchText.attr("jql-initialized", 1);
                    });
                });

            }
            $jqlSearchText.focus();

            return false;
        });

        $("#simple-search-toggle", $dialog).trigger("click");
    }

    function getAutoCompleteUrl(appId) {
        if (appId && appId !== "") {
            // Remote JIRA instance
            return contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/autocomplete?appId=" + appId;
        }
        // Local JIRA instance - will use the default URL in JQLAutoComplete
        return "";
    }

    function advancedSearchButtonClick($dialog) {
        $("#search-results-table", $dialog).empty();
        var searchText = $("#jql-search-text", $dialog).val();
        searchText = $.trim(searchText);
        if (searchText) {
            doAdvancedSearch(searchText, $dialog);
        } else {
            AJS.messages.info("#search-results-table", {
                body: "Please enter search value.",
                closeable: false
            });
        }
    }

    function setLoadingIconVisible(visible, $context) {
        $("#link-search-loading", $context).toggleClass("hidden", !visible);
    }

    function setAutoCompleteLoadingIconVisible(visible, $context) {
        $("#autocomplete-loading", $context).toggleClass("hidden", !visible);
    }

    function setAutoCompleteFailedIconVisible(visible, $context) {
        $("#autocomplete-failed", $context).toggleClass("hidden", !visible);
    }

    function setJQLErrorVisible(visible, $context) {
        $("#jql-search-error", $context).toggleClass("hidden", !visible);
    }

    function doSimpleSearch(searchText, $context) {
        setLoadingIconVisible(true, $context);
        var appId = $("#jira-app-link").val();
        var issueKeyJql = 'key = "' + searchText + '"';
        var projectJql = 'project = "' + searchText + '"';
        var plainTextJql = 'summary ~ "' + searchText + '" OR description ~ "' + searchText + '" OR comment ~ "' + searchText + '"';

        // First, check if search text is an issue key
        // We need to do this because the search will fail if it is not an issue key,
        // even if it is OR'd with a condition that returns results!
        jqlSearch(issueKeyJql, appId).done(function (smartAjaxResult) {
            if (smartAjaxResult.successful && smartAjaxResult.data.issues.length > 0) {
                setLoadingIconVisible(false, $context);
                showResults(smartAjaxResult, $context);
            } else {

                // Then check if search text is a project
                jqlSearch(projectJql, appId).done(function (smartAjaxResult) {
                    if (smartAjaxResult.successful && smartAjaxResult.data.issues.length > 0) {
                        // The search text is a project name or key
                        setLoadingIconVisible(false, $context);
                        showResults(smartAjaxResult, $context);
                    } else {

                        // Finally, a plain text search
                        jqlSearch(plainTextJql, appId).done(function (smartAjaxResult) {
                            setLoadingIconVisible(false, $context);
                            if (smartAjaxResult.successful) {
                                showResults(smartAjaxResult, $context);
                            } else {
                                showResultsError(smartAjaxResult);
                            }
                        });
                    }
                });
            }
        });
    }

    function doAdvancedSearch(jql, $context) {
        setLoadingIconVisible(true, $context);
        var appId = $("#jira-app-link").val();
        jqlSearch(jql, appId).done(function (smartAjaxResult) {
            setLoadingIconVisible(false, $context);
            if (smartAjaxResult.successful) {
                showResults(smartAjaxResult, $context);
            } else {
                if (smartAjaxResult.status === 400) {
                    AJS.messages.warning("#search-results-table", {
                        body: "Invalid JQL query.",
                        closeable: false
                    });
                } else {
                    showResultsError(smartAjaxResult);
                }
            }
        });
    }

    function jqlSearch(jql, appId) {
        var deferred = $.Deferred();
        var url;
        if (appId && appId !== "") {
            // Remote JIRA instance
            url = contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/search?jql=" + jql + "&appId=" + appId + "&maxResults=10";
        } else {
            // Local JIRA instance
            // Filter out current issue from results
            var currentIssueKey = $("#current-issue-key").val();
            jql = "(" + jql + ") and key != " + currentIssueKey;
            url = contextPath + "/rest/api/2/search?jql=" + jql + "&maxResults=10";
        }
        JIRA.SmartAjax.makeRequest({
            url: url,
            complete: function (xhr, textStatus, smartAjaxResult) {
                deferred.resolve(smartAjaxResult);
            }
        });
        return deferred.promise();
    }

    function getJqlAutoCompleteData(appId) {
        var deferred = $.Deferred();
        var remote;
        var url;
        if (appId && appId !== "") {
            // Remote JIRA instance
            url = contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/autocompletedata?appId=" + appId;
            remote = true;
        } else {
            // Local JIRA instance
            url = contextPath + "/rest/api/2/jql/autocompletedata";
            remote = false;
        }
        JIRA.SmartAjax.makeRequest({
            url: url,
            complete: function (xhr, textStatus, smartAjaxResult) {
                if (!smartAjaxResult.successful && remote) {
                    // If a remote JIRA request fails, it probably doesn't have the autocompletedata REST endpoint (added in JIRA v5.1)
                    // Get the auto complete data by parsing the issue navigator page
                    JIRA.SmartAjax.makeRequest({
                        url: contextPath + "/rest/remoteJiraIssueLink/1/remoteJira/autocompletedata/legacy?appId=" + appId,
                        complete: function (xhr, textStatus, smartAjaxResult) {
                            deferred.resolve(smartAjaxResult);
                        }
                    });
                } else {
                    deferred.resolve(smartAjaxResult);
                }
            }
        });
        return deferred.promise();
    }

    function showResults(smartAjaxResult, $context) {
        var resultHtml = JIRA.Templates.RemoteJiraIssueSearch.resultsTable({result: smartAjaxResult.data});
        $("#search-results-table", $context).html(resultHtml);

        $("#linkjiraissue-select-all", $context).click(function(){
            var $masterStatus = $(this).prop("checked");
            $("tbody tr td.selection input", $context).prop("checked", $masterStatus);
        });

        $("tbody tr", $context).click(function (e) {

            //if we click on checkbox directly we don't want to change its value
            if($(e.target).is(":checkbox")){
                return;
            }
            var checkbox = $(this).find("td.selection input");
            checkbox.prop("checked", !checkbox.prop("checked"));


        });
    }

    function showResultsError(smartAjaxResult) {
        AJS.messages.error("#search-results-table", {
            body: JIRA.SmartAjax.buildSimpleErrorContent(smartAjaxResult),
            closeable: false
        });
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-remote-jira-plugin:issue-link-jira-search-js', location = 'templates/dialog/linkjiraissue-search.soy' */
// This file was automatically generated from linkjiraissue-search.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.RemoteJiraIssueSearch.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.RemoteJiraIssueSearch == 'undefined') { JIRA.Templates.RemoteJiraIssueSearch = {}; }


JIRA.Templates.RemoteJiraIssueSearch.dialog = function(opt_data, opt_ignored) {
  return '<h2>' + soy.$$escapeHtml("Find JIRA issues") + '</h2><form class="aui search-form" id="remote-jira-simple-search-form" action="#" method="post"><div class="field-group"><label for="link-search-text">' + soy.$$escapeHtml("Search") + ':</label><input id="link-search-text" type="text" tabindex="0" class="text" size="50"> <input type="submit" tabindex="0" class="button" id="simple-search-panel-button" value="' + soy.$$escapeHtml("Search") + '"> <a id="advanced-search-toggle" href="#" title="' + soy.$$escapeHtml("Perform a JQL search") + '">' + soy.$$escapeHtml("Advanced Search") + '</a><span id="link-search-loading" class="icon loading throbber hidden"/></div></form><form class="aui search-form" id="remote-jira-advanced-search-form" action="#" method="post"><div class="field-group"><label for="jql-search-text">' + soy.$$escapeHtml("JQL Search") + '<span id="autocomplete-loading" class="hidden"><span class="icon loading throbber"/>' + soy.$$escapeHtml("Loading auto-complete") + '</span><span id="autocomplete-failed" class="hidden">' + soy.$$escapeHtml("(auto-complete unavailable)") + '</span></label><div id="jql-search-container"><span id="jql-search-error" class="icon jqlgood" /><div class="atlassian-autocomplete"><textarea id="jql-search-text" class="text full-width-field" tabindex="0" /></div></div><button class="aui-button aui-button-subtle search-button" id="advanced-search-panel-button" type="submit"><span class="aui-icon aui-icon-small aui-iconfont-search" title="' + soy.$$escapeHtml("Search") + '"></span></button> <a id="simple-search-toggle" href="#" title="' + soy.$$escapeHtml("Perform a plain text search") + '">' + soy.$$escapeHtml("Simple Search") + '</a><span id="link-search-loading" class="icon loading throbber hidden"/></div></form><div class="message-panel hidden"></div><div id="search-results-table" class="data-table"></div><div class="buttons-container form-footer"><div class="buttons"><button type="button" class="aui-button" id="linkjiraissue-add-selected">' + soy.$$escapeHtml("Add") + '</button><button class="aui-button aui-button-link cancel" href="#" id="remote-jira-link-cancel" title="' + soy.$$escapeHtml("Press Esc to close") + '">' + soy.$$escapeHtml("Close") + '</button></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.dialog.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.dialog';
}


JIRA.Templates.RemoteJiraIssueSearch.resultsTable = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.result.issues.length > 0) {
    output += '<table id="remote-jira-searchresult" class="aui"><thead><tr><th class="selection" ><input id="linkjiraissue-select-all" type="checkbox"/></th><th class="type">' + soy.$$escapeHtml("Type") + '</th><th class="key">' + soy.$$escapeHtml("Key") + '</th><th class="summary">' + soy.$$escapeHtml("Summary") + '</th><th class="status">' + soy.$$escapeHtml("Status") + '</th></tr></thead><tbody>';
    var issueList44 = opt_data.result.issues;
    var issueListLen44 = issueList44.length;
    for (var issueIndex44 = 0; issueIndex44 < issueListLen44; issueIndex44++) {
      var issueData44 = issueList44[issueIndex44];
      output += '<tr title="' + soy.$$escapeHtml(issueData44.key) + '"><td class="selection" data-key="' + soy.$$escapeHtml(issueData44.key) + '"><input type="checkbox"/></td><td class="type">' + JIRA.Templates.RemoteJiraIssueSearch.issueType({issueType: issueData44.fields.issuetype}) + '</td><td class="key" title="' + soy.$$escapeHtml(issueData44.key) + '">' + soy.$$escapeHtml(issueData44.key) + '</td><td class="summary" title="' + soy.$$escapeHtml(issueData44.fields.summary) + '">' + soy.$$escapeHtml(issueData44.fields.summary) + '</td><td class="status">' + JIRA.Templates.RemoteJiraIssueSearch.status({status: issueData44.fields.status}) + '</td></tr>';
    }
    output += '</tbody></table>';
  } else {
    output += '<div class="aui-message info"><span class="aui-icon icon-info"></span><p>' + soy.$$escapeHtml("Search returned no results.") + '</p></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.resultsTable.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.resultsTable';
}


JIRA.Templates.RemoteJiraIssueSearch.issueType = function(opt_data, opt_ignored) {
  return '<img src="' + soy.$$escapeHtml(opt_data.issueType.iconUrl) + '" alt="' + soy.$$escapeHtml(opt_data.issueType.name) + '" title="' + soy.$$escapeHtml(opt_data.issueType.name) + ' - ' + soy.$$escapeHtml(opt_data.issueType.description) + '"/>';
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.issueType.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.issueType';
}


JIRA.Templates.RemoteJiraIssueSearch.status = function(opt_data, opt_ignored) {
  return '' + JIRA.Template.Util.Issue.Status.issueStatusResolver({issueStatus: opt_data.status});
};
if (goog.DEBUG) {
  JIRA.Templates.RemoteJiraIssueSearch.status.soyTemplateName = 'JIRA.Templates.RemoteJiraIssueSearch.status';
}
;
;
/* module-key = 'jira.webresources:jira-analytics', location = '/includes/jira/analytics/analytics.js' */
/**
 * Capture analytics events in the JIRA general context.
 */
AJS.toInit(function($) {
    /**
     * Returns the currently selected tab on the Browse Project page
     */
    function getBrowseProjectTab() {
        return $("li.active a.browse-tab").attr("id");
    }

    // Need to defer for debugging support (see analytics-debug.js).
    _.defer(function() {
        if (AJS.EventQueue) {
            // Capture clicks on 'Administer Project' button on Browse Project page
            $(document).delegate("#project-admin-link", "click", function() {
                var selectedTab = getBrowseProjectTab();
                AJS.EventQueue.push({
                    name: "browseproject.administerproject",
                    properties: {
                        selectedtab: selectedTab
                    }
                });
            });

            // Capture clicks on 'Create New Project' button on Browse Projects page
            $(document).delegate("#browse-projects-create-project", "click", function() {
                AJS.EventQueue.push({
                    name: "browseprojects.createproject",
                    properties: {}
                });
            });

            // Capture clicks on the 'create an issue' link on the Issues tab when no issues exist in the project
            $(document).delegate("#no-issues-create-issue", "click", function() {
                AJS.EventQueue.push({
                    name: "browseproject.issuesblankslate.createissue",
                    properties: {}
                });
            });

            // Capture clicks on the issue filter links on the Issues tab
            $(document).delegate("a.issue-filter-link", "click", function() {
                var $el = $(this);
                var id = $el.attr("id").replace("filter_", "");
                var type = $el.attr("data-type");
                AJS.EventQueue.push({
                    name: "browse" + type + ".issuefilter." + id,
                    properties: {}
                });
            });

            $(document).on("click", "#project_import_link_lnk", function() {
                AJS.EventQueue.push({
                    name: "topnav.jim",
                    properties: {}
                });
            });

            $(document).on("click", ".issueaction-viewworkflow", function() {
                var classes = $(this).attr("class");
                var isNew = classes.indexOf("new-workflow-designer") > -1 || classes.indexOf("jira-workflow-designer-link") > -1;
                var version = isNew ? "new" : "old";

                var newEnabled = AJS.DarkFeatures.isEnabled("casper.VIEW_ISSUE");

                AJS.EventQueue.push({
                    name: "issue.viewworkflow",
                    properties: {
                        version: version,
                        newEnabled: newEnabled
                    }
                });
            });
        } // if (AJS.EventQueue)
    });
});
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/jquery/plugins/avataror/avataror.js' */

jQuery.fn.avataror = function (options) {
    var $ = jQuery,
        $document = $(document);
    this.each(function () {
        var $this = $(this);

        var imgsrc = $this.find("img").attr("src");
        $this.css({"-moz-border-radius": "10px", "-webkit-border-radius": "10px"});
        $this.html("<p>Loading?</p>");
        var avataror = {previewSize: 48};
        avataror.preview = $("<div/>").addClass("avataror-preview").css({border: "solid 1px #000", "float": "left", height: avataror.previewSize +"px", overflow: "hidden", width: avataror.previewSize +"px", position: "relative", top: "-9999em", left: "-9999em"});
        avataror.preview.prependTo(options.previewElement);
        avataror.img = $('<img src="' + imgsrc + '" alt="Avatar Source"/>');
        avataror.img.load(function () {
            avataror.image = $("<div/>").css({background: "url('" + imgsrc + "') no-repeat", clear: "left", position: "relative"});
            avataror.marker = $("<div/>").css({cursor: "move", position: "relative" });
            avataror.dash = $("<div/>");
            avataror.shadow = $("<div/>");
            avataror.dash.add(avataror.shadow).css({cursor: "move", opacity: .5, left: 0, top: 0, position: "absolute"});
            avataror.image.append(avataror.shadow).append(avataror.dash).append(avataror.marker);
            $this.append(avataror.image);
            avataror.marker.html('<div></div><div></div><div></div><div></div>');
            $("div", avataror.marker).each(function (i) {
                var $this = $(this);
                $this.css({background: "#000", border: "solid 1px #fff", width: "10px", height: "10px", position: "absolute", "font-size": "1px"});
                $this.css(["left", "right", "right", "left"][i], "-6px");
                $this.css(["top", "top", "bottom", "bottom"][i], "-6px");
                $this.css("cursor", ["nw-resize", "ne-resize", "se-resize", "sw-resize"][i]);
                $this.mousedown(function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    avataror.dragging = {x: e.pageX, y: e.pageY, ax: avataror.x, ay: avataror.y, w: avataror.width, h: avataror.height, i: i + 1};
                    avataror.shadow.hide();
                });
            });
            avataror.marker.add(avataror.image).mousedown(function (e) {
                e.preventDefault();
                avataror.dragging = {
                    x: e.pageX,
                    y: e.pageY,
                    ax: avataror.x,
                    ay: avataror.y,
                    w: avataror.width,
                    h: avataror.height};
                avataror.shadow.hide();
            });

            $document.mouseup(function (e) {
                avataror.handleMouseUp(e);
            });
            $document.mousemove(function (e) {
                if (avataror.dragging) {
                    avataror.handleMouseMove(e.pageX, e.pageY);
                    e.preventDefault();
                }
            });


            avataror.imgwidth = avataror.img.width();
            avataror.imgheight = avataror.img.height();
            avataror.x = parseInt($("#avatar-offsetX").val());
            avataror.y = parseInt($("#avatar-offsetY").val());
            avataror.width = parseInt($("#avatar-width").val());
            avataror.height = avataror.width;
            avataror.image.css({width: avataror.imgwidth + "px", height: avataror.imgheight + "px"});
            avataror.setMarker();

            $this.css({width: avataror.imgwidth + "px"});
            avataror.preview.css({position: "static"});
            $("p", $this).remove();
            $this.trigger("AvatarImageLoaded");
        });
        avataror.preview.append(avataror.img);

        avataror.setMarker = function () {
            avataror.marker.css("border", "dashed 1px #fff");
            avataror.dash.css("border", "solid 1px #000");
            avataror.shadow.css("border", "solid 1px #000");
            avataror.marker.add(this.dash).css("left", this.x - 1 + "px");
            avataror.marker.add(avataror.dash).css("top", avataror.y - 1 + "px");
            avataror.shadow.css("border-left-width", avataror.x + "px");
            avataror.shadow.css("border-right-width", avataror.imgwidth - avataror.x - avataror.width + "px");
            avataror.shadow.css("border-top-width", avataror.y + "px");
            avataror.shadow.css("border-bottom-width", avataror.imgheight - avataror.y - avataror.height + "px");
            avataror.shadow.css("width", avataror.width + "px");
            avataror.shadow.css("height", avataror.height + "px");
            avataror.marker.add(avataror.dash).css("width", avataror.width + "px");
            avataror.marker.add(avataror.dash).css("height", avataror.height + "px");
        };

        avataror.adjustPreview = function() {
            avataror.img.attr("width", avataror.imgwidth * avataror.previewSize / avataror.width);
            avataror.img.attr("height", avataror.imgheight * avataror.previewSize / avataror.height);
            avataror.img.css("margin-left", "-" + avataror.x * avataror.previewSize / avataror.width + "px");
            avataror.img.css("margin-top", "-" + avataror.y * avataror.previewSize / avataror.height + "px");
            avataror.preview.select();
        };

        avataror.handleMouseMove = function(newX, newY) {
            avataror.dragging.nextExec = avataror.dragging.nextExec || 0;
            if (avataror.dragging.nextExec == 0) {
                avataror.dragging.nextExec = 3;
            } else {
                avataror.dragging.nextExec--;
                return;
            }
            var dx = newX - avataror.dragging.x;
            var dy = newY - avataror.dragging.y;
            if (this.dragging.i) {
                var handler = avataror.resizeHandlers[this.dragging.i-1];
                handler(dx,dy);
            } else {
                avataror.x = avataror.dragging.ax + dx;
                avataror.y = avataror.dragging.ay + dy;
                if (avataror.x + avataror.width > avataror.imgwidth) {
                    avataror.x = avataror.imgwidth - avataror.width;
                }
                if (avataror.y + avataror.height > avataror.imgheight) {
                    avataror.y = avataror.imgheight - avataror.height;
                }
                if (avataror.x < 0) {
                    avataror.x = 0;
                }
                if (avataror.y < 0) {
                    avataror.y = 0;
                }
            }
            avataror.setMarker();
            avataror.adjustPreview();
        };

        avataror.handleMouseUp = function(e) {
//            avataror.adjustPreview();
            $("#avatar-offsetX").val(avataror.x);
            $("#avatar-offsetY").val(avataror.y);
            $("#avatar-width").val(avataror.width);
            avataror.dragging = null;
            avataror.shadow.show();
        };

        avataror.originX = function() {
            return avataror.dragging.ax;
        };
        avataror.originY = function() {
            return avataror.dragging.ay;
        };
        avataror.originBottomX = function() {
            return avataror.dragging.ax + avataror.dragging.w;
        };
        avataror.originBottomY = function() {
            return avataror.dragging.ay + avataror.dragging.h;
        };

        avataror.originNw = function() {
            return {x: avataror.originX(), y: avataror.originY()};
        };
        avataror.originNe = function() {
            return {x: avataror.originBottomX(), y: avataror.originY()};
        };
        avataror.originSe = function() {
            return {x: avataror.originBottomX(), y: avataror.originBottomY()};
        };
        avataror.originSw = function() {
            return {x: avataror.originX(), y: avataror.originBottomY()};
        };

        avataror.nwHandler = function(dx, dy) {
            var anchor = avataror.originSe();
            var tmpBase = {x: avataror.originX() + dx, y: avataror.originY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);
            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x - newSize < 0) {
                newSize = anchor.x;
            }
            if (anchor.y - newSize < 0) {
                newSize = anchor.y;
            }
            avataror.x = anchor.x - newSize;
            avataror.y = anchor.y - newSize;
            avataror.width = avataror.height = newSize;
        };

        avataror.neHandler = function(dx, dy) {
            var anchor = avataror.originSw();
            var tmpBase = {x: avataror.originBottomX() + dx, y: avataror.originY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);

            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x + newSize > avataror.imgwidth) {
                newSize = avataror.imgwidth - anchor.x;
            }
            if (anchor.y - newSize < 0) {
                newSize = anchor.y;
            }

            avataror.y = anchor.y - newSize;
            avataror.width = avataror.height = newSize;
        };

        avataror.seHandler = function(dx, dy) {
            var anchor = avataror.originNw();
            var tmpBase = {x: avataror.originBottomX() + dx, y: avataror.originBottomY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);

            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x + newSize > avataror.imgwidth) {
                newSize = avataror.imgwidth - anchor.x;
            }
            if (anchor.y + newSize > avataror.imgheight) {
                newSize = avataror.imgheight - anchor.y;
            }
            avataror.width = avataror.height = newSize;
        };

        avataror.swHandler = function(dx, dy) {
            var anchor = avataror.originNe();
            var tmpBase = {x: avataror.originX() + dx, y: avataror.originBottomY() + dy};
            var diffX = Math.abs(tmpBase.x - anchor.x), diffY = Math.abs(tmpBase.y - anchor.y);
            var newSize = Math.min(diffX, diffY);

            if (newSize < 20) {
                newSize = 20;
            }
            if (anchor.x - newSize < 0) {
                newSize = anchor.x;
            }
            if (anchor.y + newSize > avataror.imgheight) {
                newSize = avataror.imgheight - anchor.y;
            }
            avataror.x = anchor.x - newSize;
            avataror.width = avataror.height = newSize;
        };

        avataror.resizeHandlers = [avataror.nwHandler, avataror.neHandler, avataror.seHandler, avataror.swHandler];

        // implementation
    });
};
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/Avatar.js' */
/**
 * Represents an icon for a project or some other entity in JIRA.
 *
 * @Class JIRA.Avatar
 *
 */
JIRA.Avatar = Class.extend({

    /**
     * @constructor
     * @param {object} options
     * @param {Number} options.id
     * @param {Boolean} options.isSystemAvatar
     * @param {object} [options.urls] an optional hash of avatar URLs
     */
    init: function (options) {
        this._id = options.id;
        this._isSystemAvatar = options.isSystemAvatar;
        this._isSelected = options.isSelected;
        this._urls = options.urls;
    },

    /**
     * Sets as unselected
     */
    setUnSelected: function () {
        this._isSelected = false;
    },

    /**
     * Sets as selected
     */
    setSelected: function () {
        this._isSelected = true;
    },

    /**
     * Gets selected state
     */
    isSelected: function () {
        return !!this._isSelected;
    },

    /**
     * Indicates whether the Avatar is a system-provided one or if users have defined it.
     *
     * @return {Boolean} true only if the Avatar is a system-provided one.
     */
    isSystemAvatar: function () {
        return this._isSystemAvatar;
    },

    /**
     * The database identifier for the Avatar, may be null if it hasn't yet been stored.
     *
     * @return the database id or null.
     */
    getId: function () {
        return this._id;
    },

    /**
     * Returns the URL of this avatar in the given size.
     *
     * @param {string} size an avatar size
     * @return {string} the avatar URL
     */
    getUrl: function(size) {
        return this._urls[size];
    },

    /**
     * Serilaizes the object into a JSON object
     *
     * @return {Object}
     */
    toJSON: function () {
        return {
            id: this._id,
            isSystemAvatar: this._isSystemAvatar,
            isSelected: this._isSelected,
            urls: this._urls
        };
    }
});


// Factories

/**
 * Creates custom avatar
 *
 * @param descriptor
 * ... {String} id
 */
JIRA.Avatar.createCustomAvatar = function (descriptor) {
    descriptor.isSystemAvatar = false;
    return new JIRA.Avatar(descriptor);
};

/**
 * Creates system avatar
 *
 * @param descriptor
 * ... {String} id
 */
JIRA.Avatar.createSystemAvatar = function (descriptor) {
    descriptor.isSystemAvatar = true;
    return new JIRA.Avatar(descriptor);
};

/**
 * Converts avatar size name to size object. If passed parameters is object is
 * returned unmodified.
 * @param name
 * @returns {JIRA.Avatar}
 */
JIRA.Avatar.getSizeObjectFromName = function (name) {
    if ( "object" === typeof name ) {
        return name;
    }
    var nameTrimmed = "string" === typeof name ? jQuery.trim(name) : "";
    if ( JIRA.Avatar.LARGE.param===name ) {
        return JIRA.Avatar.LARGE;
    } else if ( JIRA.Avatar.MEDIUM.param===name ) {
        return JIRA.Avatar.MEDIUM;
    } else if ( JIRA.Avatar.SMALL.param===name ) {
        return JIRA.Avatar.SMALL;
    } else if ( "xsmall"===name ) { // Java uses xmall name!#@$
        return JIRA.Avatar.SMALL;
    } else {
        return JIRA.Avatar.LARGE;
    }
};


// Sizes

/**
 * Large avatar settings
 */
JIRA.Avatar.LARGE = {
    param: "large",
    height: 48,
    width: 48
};

/**
 * Medium avatar settings
 */
JIRA.Avatar.MEDIUM = {
    param: "medium",
    width: 32,
    height: 32
};

/**
 * Small avatar settings
 */
JIRA.Avatar.SMALL = {
    param: "small",
    width: 16,
    height: 16
};

;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarManager.js' */
/**
 * Manager interface for JIRA.Avatar objects.
 *
 * You should use this for creating, manipulating and deleteing of avatars. Helper methods such as getting avatar
 * urls are also contained within this class.
 *
 * Please use the factory methods for construction
 *
 * @Class JIRA.AvatarManager
 */
JIRA.AvatarManager = Class.extend({

    /**
     * @param options
     * @param {JIRA.AvatarStore} options.store
     * @param {Number|String} options.defaultAvatarId - This is the avatar that is currently in use if no other have been selected
     * @param {Number|String} options.anonymousAvatarId - In the case of user avatar, this is the one used for logged out/or annonymous users
     * @param {String} options.avatarSrcBaseUrl - The base url used to load the avatar image
     */
    init: function (options) {
        this.store = options.store;
        this.ownerId = options.ownerId;
        this.username = options.username;
        this.anonymousAvatarId = options.anonymousAvatarId;
        this.avatarSrcBaseUrl = options.avatarSrcBaseUrl;
    },

    /**
     * Selects avatar, this will become the displayed avatar for the given type (ie project)
     *
     * @param avatar
     * @param options
     */
    selectAvatar: function (avatar, options) {
        return this.store.selectAvatar(avatar, options);
    },

    /**
     * Retrieve the avatar with the given id.
     *
     * @param avatarId must not be null.
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    getById: function (id) {
        return this.store.getById(id);
    },

    /**
     * Delete the avatar
     *
     * @param {String} avatar must not be null.
     */
    destroy: function (avatar, options) {
        this.store.destroy(avatar, options);
    },

    /**
     * Saves the avatar as an updated version of the avatar with the same id that is already in the store.
     *
     * @param {JIRA.Avatar} avatar must not be null.
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    update: function (avatar, options) {
        this.store.update(avatar, options);
    },

    /**
     * Creates a database record for the given avatar. Use the return value as the persistent avatar, not the one you
     * passed in.
     *
     * @param {JIRA.Avatar} avatar must not be null, must have a null id.
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    add: function (avatar, options) {
        this.store._add(avatar, options);
    },

    /**
     * Provides a list of all system avatars.
     *
     * Note: You will need to call refreshStore first
     *
     * @return {Array<JIRA.Avatar>} the system avatars.
     */
    getAllSystemAvatars: function () {
        return this.store.getAllSystemAvatars();
    },

    /**
     * Provides an array of all system avatars.
     *
     * Note: You will need to call refreshStore first
     *
     * @return {Array<JIRA.Avatar>} the custom avatars.
     */
    getAllCustomAvatars: function () {
        return this.store.getAllCustomAvatars();
    },

    /**
     * Gets selected avatar
     *
     * @return JIRA.Avatar
     */
    getSelectedAvatar: function () {
        return this.store.getSelectedAvatar();
    },

    /**
     *
     * Gets all avatars
     *
     * Note: You will need to call refreshStore first
     *
     * @return {Object}
     * ... {Array<JIRA.Avatar>} system
     * ... {Array<JIRA.Avatar>} custom
     */
    getAllAvatars: function () {
        return this.store.getAllAvatars();
    },

    /**
     * Gets a JSON blob, that contains the img src of each avatar based on the supplied size
     *
     * @param {JIRA.Avatar.LARGE | JIRA.Avatar.MEDIUM | JIRA.Avatar.SMALL} size
     * @return {Object}
     * ... {Array[{id, src, isSystemAvatar}]} system
     * ... {Array[{id, src, isSystemAvatar}] custom
     */
    getAllAvatarsRenderData: function (size) {

        var i,
                instance = this,
                avatars = this.getAllAvatars(),
                renderData = {
                    system: [],
                    custom: []
                };

        for (i = 0; i < avatars.system.length; i++) {
            renderData.system.push(instance.getAvatarRenderData(avatars.system[i], size));
        }

        for (i = 0; i < avatars.custom.length; i++) {
            renderData.custom.push(instance.getAvatarRenderData(avatars.custom[i], size));
        }

        return renderData;
    },

    /**
     * Gets json descriptor of given avatar that contains the img src based on the supplied size
     * @param avatar
     * @param size
     */
    getAvatarRenderData: function (avatar, size) {
        var data = avatar.toJSON();

        data.src = this.getAvatarSrc(avatar, size);
        data.width = size.width;
        data.height = size.height;


        return data;
    },

    /**
     * Refreshes avatar store
     *
     * @param options
     * ... {function} success
     * ... {function} error
     */
    refreshStore: function (options) {
        this.store.refresh(options);
    },

    /**
     *
     * @param {JIRA.Avatar} avatar
     * @param {JIRA.Avatar.LARGE | JIRA.Avatar.MEDIUM | JIRA.Avatar.SMALL} size
     * @return String
     */
    getAvatarSrc: function(avatar, size) {

        if (this.store.isTempAvatar(avatar)) {
            // if the user chooses a new temporary avatar we need to keep making this url unique so that the image is kept fresh
            return contextPath + "/secure/temporaryavatar?" + jQuery.param({
                cropped: true,
                magic: new Date().getTime(),
                size: size.param
            });
        }

        return avatar.getUrl(AJS.format('{0}x{1}', size.height, size.width));
    },

    /**
     * Creates temporary avatar from the value in the supplied file input field
     *
     * @param {HTMLElement} field
     * @param {Object} options
     * ... {function} success
     * ... {function} error
     */
    createTemporaryAvatar: function (field, options) {
        this.store.createTemporaryAvatar(field, options);
    },

    /**
     * Creates an avatar with the properties of the given avatar.
     *
     * @param {Object} instructions
     * ... {Number} cropperOffsetX
     * ... {Number} cropperOffsetY
     * ... {Number} cropperWidth
     *
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    createAvatarFromTemporary: function (instructions, options) {
        this.store.createAvatarFromTemporary(instructions, options);
    },

    /**
     * Gets the avatar id to use to represent an unknown or anonymous user
     * @return {Number} the avatar id for an anonymous user
     */
    getAnonymousAvatarId: function () {
        return this.anonymousAvatarId;
    }

});


// Factories


/**
 *
 * Creates a project avatar manager
 *
 * @param options
 * ... {String} projectKey
 * ... {String} projectId
 * ... {String} defaultAvatarId
 */
JIRA.AvatarManager.createUniversalAvatarManager = function (options) {

    // Cater for the projectKey being empty
    var restQueryUrl,
            restUpdateUrl = "",
            restCreateTempUrl = "",
            restUpdateTempUrl = "",
            restSingleAvatarUrl = "";

    if (options.projectId) {
        var urlAvatarOwnerPrefix = contextPath + "/rest/api/latest/universal_avatar/type/"+options.avatarType+"/owner/" + options.projectId;

        restQueryUrl = urlAvatarOwnerPrefix;

        var avatarCreateUrl = urlAvatarOwnerPrefix + "/avatar";

        restUpdateUrl = null;
        restCreateTempUrl = urlAvatarOwnerPrefix + "/temp";
        restUpdateTempUrl = avatarCreateUrl;
        restSingleAvatarUrl = avatarCreateUrl;
    } else {
        restQueryUrl = contextPath + "/rest/api/latest/avatar/project/system";
        restCreateTempUrl = contextPath + "/rest/api/latest/avatar/project/temporary";
        restUpdateTempUrl = contextPath + "/rest/api/latest/avatar/project/temporaryCrop";
    }

    var store = new JIRA.AvatarStore({
        restQueryUrl: restQueryUrl,
        restUpdateUrl: restUpdateUrl,
        restCreateTempUrl: restCreateTempUrl,
        restUpdateTempUrl: restUpdateTempUrl,
        restSingleAvatarUrl: restSingleAvatarUrl,
        defaultAvatarId: options.defaultAvatarId
    });

    return new JIRA.AvatarManager({
        store: store,
        ownerId: options.projectId,
        avatarSrcBaseUrl: contextPath + "/secure/projectavatar"
    });
};

/**
 *
 * Creates a project avatar manager
 *
 * @param options
 * ... {String} projectKey
 * ... {String} projectId
 * ... {String} defaultAvatarId
 */
JIRA.AvatarManager.createProjectAvatarManager = function (options) {
    options.avatarType = "project";

    return JIRA.AvatarManager.createUniversalAvatarManager(options);
};

/**
 * Creates a user avatar manager
 *
 * @param options
 * ... {String} username
 * ... {String} defaultAvatarId
 */
JIRA.AvatarManager.createUserAvatarManager = function (options) {

    var userRestUrl = contextPath + "/rest/api/latest/user";
    var store = new JIRA.AvatarStore({
        restQueryUrl: userRestUrl + "/avatars",
        restUpdateUrl: userRestUrl + "/avatar",
        restCreateTempUrl: userRestUrl + "/avatar/temporary",
        restUpdateTempUrl: userRestUrl + "/avatar",
        restSingleAvatarUrl: userRestUrl + "/avatar",
        restParams: { 'username': options.username },
        defaultAvatarId: options.defaultAvatarId
    });

    return new JIRA.AvatarManager({
        store: store,
        username: options.username,
        avatarSrcBaseUrl: contextPath + "/secure/useravatar"
    });
};
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarStore.js' */
/**
 * Persistent storage mechanism for JIRA.Avatar
 *
 * This default store uses a CRUD rest interface. There are several parameters to provide. Any optional rest URL
 * parameters are simply not invoked.
 *
 * @param restQueryUrl
 *      Mandatory. Retrieves the list of available avatars to pick from.
 *      Type: GET
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatars
 *      Response: {"system":[{"id":10001,"isSystemAvatar":true,"selected":false}], "custom": [{"id":10002,"isSystemAvatar":false,"selected":false}]}
 *
 * @param restUpdateUrl
 *      Optional. Sets the avatar as the selection for the owner.
 *      Type: PUT
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar
 *      Request: {"id":10001,"isSystemAvatar":true,"selected":false}
 *
 * @param restCreateTempUrl
 *      Mandatory. Uploads a file and stores it as the session's temporary avatar
 *      Type: Wildcard
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar/temporary
 *      Request: io stream (for supporting browsers) or multipart
 *
 * @param restUpdateTempUrl
 *      Mandatory. Crops the temporary avatar. This may also be a good time to convert it into a real avatar, but that
 *      will not always be the case, e.g. when an owner (project, user, etc) is still in the process of being created.
 *      Type: POST
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar
 *      Request: {"cropperOffsetX":"90","cropperOffsetY":"57","cropperWidth":"143"}
 *
 * @param restSingleAvatarUrl
 *      Optional. Deletes avatar.
 *      Type: DELETE
 * e.g. URL: http://jira.com/rest/api/latest/project/HSP/avatar
 *      Request: {"id":10001,"isSystemAvatar":true,"selected":false}
 *
 * @param restParams
 *      Optional. e.g. {username: "admin"}
 *
 * @param defaultAvatarId
 *      Mandatory. Used if the currently selected avatar is deleted.
 *
 * Note: If you want to use a different storage mechanism, you can implement the same interface as here and pass it to the
 * constructor of your JIRA.AvatarManager
 */
JIRA.AvatarStore = Class.extend({

    TEMP_ID: "TEMP",

    /**
     * @constructor
     * @param options
     * ... {String} restQueryUrl - Retrieves the list of available avatars to pick from (see class description)
     * ... {String} restUpdateUrl - Sets the avatar as the selection for the owner (see class description)
     * ... {String} restCreateTempUrl - Uploads a file and stores it as the session's temporary avatar (see class description)
     * ... {String} restUpdateTempUrl - Crops the temporary avatar (see class description)
     * ... {String} restSingleAvatarUrl - Deletes avatar (see class description)
     * ... {String} restParams - The optional query parameters to append to the base URL for rest requests (see class description)
     * ... {Number} defaultAvatarId - The id of default avatar. The selected avatar if user has not selected one yet.
     */
    init: function (options) {

        if (!options.restQueryUrl) {
            throw new Error("JIRA.AvatarStore.init: You must specify [restQueryUrl], The rest url for querying avatars (see class description)");
        }

        if (!options.restCreateTempUrl) {
            throw new Error("JIRA.AvatarStore.init: You must specify [restCreateTempUrl], The rest url for creating a temporary avatar (see class description)");
        }

        if (!options.restUpdateTempUrl) {
            throw new Error("JIRA.AvatarStore.init: You must specify [restUpdateTempUrl], The rest url for updating a temporary avatar (see class description)");
        }

        if (!options.defaultAvatarId) {
            throw new Error("JIRA.AvatarStore.init: You must specify [defaultAvatarId] to the contructor so the store " +
                "knows what to select if you delete the selected one");
        }

        this.restQueryUrl = options.restQueryUrl;
        this.restUpdateUrl = options.restUpdateUrl;
        this.restCreateTempUrl = options.restCreateTempUrl;
        this.restUpdateTempUrl = options.restUpdateTempUrl;
        this.restSingleAvatarUrl = options.restSingleAvatarUrl;
        this.restParams = options.restParams || {};
        this.restParams.atl_token = atl_token();
        this.defaultAvatarId = options.defaultAvatarId;
        this.avatars = {system: [], custom: []};
    },

    /**
     * Builds the REST URL using the given url and optional restParams options.
     */
    _buildCompleteUrl: function (url) {
        var completeUrl = url;

        if (this.restParams) {
            var queryParams = '';
            for (var name in this.restParams) {
                queryParams += AJS.format('&{0}={1}', encodeURIComponent(name), encodeURIComponent(this.restParams[name]));
            }

            completeUrl += ('?' + queryParams.substr(1));
        }

        return completeUrl;
    },

    /**
     * Retrieves the Avatar by id.
     *
     * @param avatarId the avatar's id, must not be null.
     * @return the avatar with the given id or null if it doesn't exist.
     */
    getById: function (avatarId) {

        var match;

        jQuery.each(this.avatars.system, function (i, avatar) {
            if (this.getId() === avatarId) {
                match = avatar;
                return false;
            }
        });

        if (!match) {
            jQuery.each(this.avatars.custom, function (i, avatar) {
                if (this.getId() === avatarId) {
                    match = avatar;
                    return false;
                }
            });
        }

        return match;
    },

    /**
     * Checks if the given avatar is the temporarty avatar.
     *
     * @param avatar
     * @return true if it is the temporary avatar, false if otherwise.
     */
    isTempAvatar: function(avatar) {
        return (avatar.getId() === this.TEMP_ID);
    },

    /**
     * Update client side storage
     *
     * @param avatar
     */
    _selectAvatar: function (avatar) {

        var selected = this.getSelectedAvatar();

        if (selected) {
            selected.setUnSelected();
        }
        avatar.setSelected();
    },

    /**
     * Selects avatar, this will become the displayed avatar for the given type (ie project)
     *
     * @param {JIRA.Avatar} avatar
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    selectAvatar: function (avatar, options) {

        var instance = this;

        if (!avatar) {
            throw new Error("JIRA.AvatarStore.selectAvatar: Cannot select Avatar that does not exist");
        }

        if (this.restUpdateUrl) {
            JIRA.SmartAjax.makeRequest({
                type: "PUT",
                contentType: "application/json",
                dataType: "json",
                url: this._buildCompleteUrl(this.restUpdateUrl),
                data: JSON.stringify(avatar.toJSON()),
                success: function () {
                    instance._selectAvatar(avatar);
                    if (options.success) {
                        options.success.call(this, avatar);
                    }
                },
                error: options.error
            });
        } else {
            instance._selectAvatar(avatar);
            if (options.success) {
                options.success.call(this, avatar);
            }
        }
    },

    /**
     * Removes avatar in client side store
     *
     * @param {JIRA.Avatar} avatar
     */
    _destory: function (avatar) {

        var index = jQuery.inArray(avatar, this.avatars.custom);

        if (index !== -1) {
            this.avatars.custom.splice(index, 1);
        } else {
            throw new Error("JIRA.AvatarStore._destroy: Cannot remove avatar [" + avatar.getId() + "], "
                    + "it might be a system avatar (readonly) or does not exist.");
        }
    },

    /**
     * Permanently removes the avatar from the system.
     *
     * @param {JIRA.Avatar} avatar - must not be null.
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    destroy: function (avatar, options) {

        var instance = this;

        options = options || {};

        if (!avatar) {
            throw new Error("JIRA.AvatarStore.destroy: Cannot delete Avatar that does not exist");
        }

        JIRA.SmartAjax.makeRequest({
            type: "DELETE",
            url: this.getRestUrlForAvatar(avatar),
            success: function () {
                instance._destory(avatar);
                if (avatar.isSelected()) {
                    instance.selectAvatar(instance.getById(instance.defaultAvatarId), options);
                } else if (options.success) {
                    options.success.apply(this, arguments);
                }
            },
            error: options.error
        });
    },

    /**
     * Gets selected avatar, the displayed avatar for the given type (ie project)
     *
     * @return {JIRA.Avatar}
     */
    getSelectedAvatar: function () {

        for (var i = 0; i < this.avatars.custom.length; i++) {
            if (this.avatars.custom[i].isSelected()) {
                return this.avatars.custom[i];
            }
        }

        for (i = 0; i < this.avatars.system.length; i++) {
            if (this.avatars.system[i].isSelected()) {
                return this.avatars.system[i];
            }
        }
    },

    /**
     * Updates avatar in our client side store
     *
     * @param {JIRA.Avatar} avatar
     */
    _update: function (avatar) {

        var instance = this;

        if (this.getById(avatar.getId())) {
            jQuery.each(this.avatars.custom, function (i) {
                if (this.getId() === avatar.getId()) {
                    instance.avatars.custom[i] = avatar;
                }
            });
        }
        else {
            throw new Error("JIRA.AvatarStore._update: Cannot update avatar [" + avatar.getId() + "], "
                    + "it might be a system avatar (readonly) or does not exist.");
        }
    },

    /**
     * Updates an avatar's properties to match those in the given avatar. The avatar
     * to change is identified by the id of the given avatar.
     *
     * @param {JIRA.Avatar} avatar - the avatar to update, must not be null.
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    update: function (avatar, options) {

        var instance = this;

        options = options || {};

        JIRA.SmartAjax.makeRequest({
                    type: "PUT",
                    url: this.getRestUrlForAvatar(avatar),
                    error: options.error,
                    success: function () {
                        instance._update(avatar);
                        if (options.success) {
                            options.success.apply(this, arguments);
                        }
                    }
                });
    },

    /**
     * Adds avatar to our client side store
     *
     * @param avatar
     */
    _add: function (avatar) {
        if (avatar.isSystemAvatar()) {
            this.avatars.system.push(avatar);
        }
        else {
            this.avatars.custom.push(avatar);
        }
    },

    /**
     * Creates an avatar with the properties of the given avatar.
     *
     * @param {Object} instructions
     * ... {Number} cropperOffsetX
     * ... {Number} cropperOffsetY
     * ... {Number} cropperWidth
     *
     * @param {Object} options
     * ... {Function(JIRA.Avatar)} success - ajax callback
     * ... {Function(XHR, testStatus, JIRA.SmartAjax.smartAjaxResult)} error - ajax callback
     */
    createAvatarFromTemporary: function (instructions, options) {

        var instance = this;

        options = options || {};

        if (this.restUpdateTempUrl) {
            JIRA.SmartAjax.makeRequest({
                type: "POST",
                url: this._buildCompleteUrl(this.restUpdateTempUrl),
                data: JSON.stringify(instructions),
                contentType: "application/json",
                dataType: "json",
                success: function (data) {

                    // If no data is returned, no real avatar was created and the temporary avatar has just been updated with the cropping instructions
                    if (!data) {
                        data = {
                            id: instance.TEMP_ID,
                            isSelected: true
                        };
                    }
                    var avatar = JIRA.Avatar.createCustomAvatar(data);
                    instance._add(avatar);

                    if (options.success) {
                        options.success.call(this, data);
                    }
                },
                error: options.error
            });
        }
    },

    /**
     *
     * Creates temporary avatar on server
     *
     * @param {HTMLElement} fileInput
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    createTemporaryAvatar: function (fileInput, options) {
        // add the restParams as option
        options = AJS.$.extend(true, {}, options, { params: this.restParams });

        JIRA.AvatarUtil.uploadTemporaryAvatar(this.restCreateTempUrl, fileInput, options);
    },

    /**
     * Resets store with the Avatars created from the supplied JSON
     *
     * @param JSON avatar descriptors
     */
    _refresh: function (avatars) {

        var instance = this;

        instance.avatars.system = [];
        instance.avatars.custom = [];

        if (avatars.system) {
            jQuery.each(avatars.system, function (i, descriptor) {
                instance.avatars.system.push(JIRA.Avatar.createSystemAvatar(descriptor));
            });
        }

        if (avatars.custom) {
            jQuery.each(avatars.custom, function (i, descriptor) {
                instance.avatars.custom.push(JIRA.Avatar.createCustomAvatar(descriptor));
            });
        }
    },

    /**
     * Goes back to the server and retrievs all avatars
     *
     * @param {Object} options
     * ... {Function} success
     * ... {Function} error
     */
    refresh: function (options) {

        var instance = this;

        // Remember the temporary avatar if we have one
        var tempAvatar = this.getById(instance.TEMP_ID);

        options = options || {};

        JIRA.SmartAjax.makeRequest({
            url: this._buildCompleteUrl(this.restQueryUrl),
            error: options.error,
            success: function (avatars) {
                instance._refresh(avatars);
                if (tempAvatar) {
                    instance._add(tempAvatar);
                }
                if (options.success) {
                    options.success.apply(this, arguments);
                }
            }
        });
    },

    /**
     * Gets all avatars, custom and system
     *
     * @return {Object}
     * ... {Array<JIRA.Avatar>} system
     * ... {Array<JIRA.Avatar>} custom
     */
    getAllAvatars: function () {
        return this.avatars;
    },

    /**
     * Provides an array of all system avatars.
     *
     * @return the system avatars, never null.
     */
    getAllSystemAvatars: function () {
        return this.avatars.system;
    },

    /**
     * Provides an array of all system avatars.
     *
     * @return the custom avatars.
     */
    getAllCustomAvatars: function () {
        return this.avatars.custom;
    },

    /**
     * Gets rest url to update a single avatar
     *
     * @param avatar
     */
    getRestUrlForAvatar: function (avatar) {
        return this._buildCompleteUrl(this.restSingleAvatarUrl + "/" + avatar.getId());
    }
});
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarUtil.js' */
JIRA.AvatarUtil = {

    uploadUsingIframeRemoting: function (url, field, options) {
        options = options || {};

        var fileName = field.val(),
            form = new AJS.InlineAttach.Form(new AJS.InlineAttach.FileInput(field, false)),
            progress = form.addStaticProgress(fileName);

        //Add a new "File Input" to the form. We use the old input as part of a hidden form that we can submit to the
        //server in the background.
        var $oldInput = form.cloneFileInput();

        form.fileSelector.clear();

        //We only show progress after we are sure the upload will take longer than AJS.InlineAttach.DISPLAY_WAIT.
        var timer = new AJS.InlineAttach.Timer(function() {
            !this.cancelled && progress.show();
        }, this);

        var upload = new AJS.InlineAttach.FormUpload({
            $input: $oldInput,
            url: url,
            params: AJS.$.extend({}, options.params, {
                filename: fileName,
                atl_token: atl_token()
            }),
            scope: this,
            before: function() {
                !this.cancelled && progress.start();
            },
            success: function(val, status) {
                if (val.errorMessages && val.errorMessages.length) {
                    form.addErrorWithFileName(val.errorMessages[0], fileName, JIRA.AvatarUtil.getErrorTarget(form));
                } else if (options.success) {
                    options.success(val, status);
                }
            },
            error: function(text) {

                console.log(text);

                if (this.cancelled) {
                    return;
                }

                if (text.indexOf("SecurityTokenMissing") >= 0) {
                    form.addError(AJS.InlineAttach.Text.tr("upload.xsrf.timeout", fileName), JIRA.AvatarUtil.getErrorTarget(form));
                } else {
                    form.addError(AJS.InlineAttach.Text.tr("upload.error.unknown", fileName), JIRA.AvatarUtil.getErrorTarget(form));
                }
            },
            after: function() {

                timer.cancel();
                progress.remove();

                if (!this.cancelled) {
                    form.enable();
                }
            }
        });

        progress.onCancel(function() {
            upload.abort();
        });

        upload.upload();
    },

    uploadUsingFileApi: function (url, field, options) {

        var timer,
            upload,
            cancelled,
            file = field[0].files[0],
            form = new AJS.InlineAttach.Form(new AJS.InlineAttach.FileInput(field, false)),
            progress = form.addProgress(file);

        options = options || {};

        //We only show progress after we are sure the upload will take longer than AJS.InlineAttach.DISPLAY_WAIT.
        timer = new AJS.InlineAttach.Timer(function() {
            if (!cancelled) {
                progress.show();
            }
        });

        upload = new AJS.InlineAttach.AjaxUpload({
            file: file,
            params: AJS.$.extend({}, options.params, {
                filename: file.name,
                size: file.size,
                atl_token: atl_token()
            }),
            scope: this,
            url: url,
            before: function() {
                field.hide();
                !cancelled && progress.start();
            },
            progress: function(val) {
                progress.progress.$progress.parent().parent().show();
                !cancelled && progress.update(val);
            },
            success: function(val, status) {

                if (cancelled) {
                    return;
                }

                if (val.errorMessages && val.errorMessages.length) {
                    form.addErrorWithFileName(val.errorMessages[0], file.name, JIRA.AvatarUtil.getErrorTarget(form));
                } else if (status === 201) {
                    options.success(val, status);
                }
            },
            error: function(text, status) {


                if (status < 0) {
                    //This is a client error so just render it.
                    form.addError(text, JIRA.AvatarUtil.getErrorTarget(form));
                } else {
                    form.addError(AJS.InlineAttach.Text.tr("upload.error.unknown", file.name), JIRA.AvatarUtil.getErrorTarget(form));
                }

                if (options.error) {
                    options.error(text, status);
                }
            },
            after: function() {
                timer.cancel();
                progress.finish().remove();
                field.val("").show();
            }
        });

        upload.upload();

        progress.onCancel(function () {
            upload.abort();
        });
    },

    getErrorTarget: function (form) {
        return {
            $element: form.$form.find(".error")
        };
    },

    /**
     * Uploads temporary avatar using progress bars (if file API supported)
     *
     * @param {String} url - url to upload to, must accept any type, multipart etc
     * @param {HTMLElement} field - file input field containing file path
     * @param options
     * ... {Function} success
     * ... {Function} error
     * ... {Object} params additional query params to use in the upload request
     */
    uploadTemporaryAvatar: function (url, field, options) {
        if (AJS.InlineAttach.AjaxPresenter.isSupported(field)) {
            this.uploadUsingFileApi(url, field, options);
        } else {
            this.uploadUsingIframeRemoting(url, field, options);
        }
    }
};
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarPicker.js' */
;(function($) {

    /**
     * Creates/Renders avatar picker
     *
     * @class JIRA.AvatarPicker
     */
    JIRA.AvatarPicker = AJS.Control.extend({

        /**
         * @constructor
         * @param {Object} options
         * ... {JIRA.AvatarManager or something that implements same interface} avatarManager
         * ... {JIRA.AvatarPicker.Avatar or something that implements same interface} avatarRenderer
         * ... {JIRA.Avatar.LARGE | JIRA.Avatar.MEDIUM | JIRA.Avatar.SMALL} size
         */
        init: function (options) {
            this.avatarManager = options.avatarManager;
            this.avatarRenderer = options.avatarRenderer;
            this.imageEditor = options.imageEditor;
            this.size = options.size;
            this.selectCallback = options.select;
            this.cropperDialog = null;
            this.initialSelection = options.initialSelection;
        },

        /**
         * Renders avatar picker
         *
         * @param {Function} ready - a callback function that will be called when rendering is complete, the first
         * argument of this function will be the contents of the avatar picker. You can then append this element to wherever you
         * want the picker displayed
         */
        render: function (ready) {

            var instance = this;

            // we need to go to the server and get all the avatars first
            this.avatarManager.refreshStore({

                success: function () {
                    if (instance.cropperDialog instanceof JIRA.Dialog) {
                        instance.cropperDialog.hide();
                        delete instance.cropperDialog;
                    }
                    instance.element = $('<div id="jira-avatar-picker" />');

                    instance.element.html(JIRA.Templates.AvatarPicker.picker({
                        avatars: instance.avatarManager.getAllAvatarsRenderData(instance.size)
                    }));

                    instance._assignEvents("selectAvatar", instance.element.find(".jira-avatar button"));
                    instance._assignEvents("deleteAvatar", instance.element.find(".jira-delete-avatar"));
                    instance._assignEvents("uploader", instance.element.find("#jira-avatar-uploader"));

                    if (undefined !== instance.initialSelection) {
                        instance.getAvatarElById(instance.initialSelection).addClass("jira-selected-avatar");
                    }

                    // we are finished, call with picker contents
                    ready(instance.element);
                },
                error: function (xhr, error, textStatus, smartAjaxResult) {
                    instance.appendErrorContent(instance.element, smartAjaxResult);
                    ready(instance.element);
                }
            });
        },

        /**
         *
         * Gets the most useful error response from a smartAjaxResponse and appends it to the picker
         *
         * @param el
         * @param smartAjaxResult
         */
        appendErrorContent: function (el, smartAjaxResult) {
            try {
                var errors = JSON.parse(smartAjaxResult.data);

                if (errors && errors.errorMessages) {
                    $.each(errors.errorMessages, function (i, message) {
                        AJS.messages.error(el, {
                            body: AJS.escapeHTML(message),
                            closeable: false,
                            shadowed: false
                        });
                    });
                } else {
                    el.append(JIRA.SmartAjax.buildDialogErrorContent(smartAjaxResult, true));
                }
            } catch (e) {
                el.append(JIRA.SmartAjax.buildDialogErrorContent(smartAjaxResult, true));
            }
        },

        /**
         * Saves temporary avatar and invokes cropper
         *
         * @param {HTMLElement} field
         */
        uploadTempAvatar: function (field) {

            var instance = this;

            this.avatarManager.createTemporaryAvatar(field, {

                success: function (data) {

                    if (data.id) {
                        // We have an avatar and don't need to crop
                        instance.render(function () {
                            instance.selectAvatar(data.id);
                        });
                    } else {
                        field.val("");

                        instance.cropperDialog = new JIRA.Dialog({
                            id: "project-avatar-cropper",
                            width: 560,
                            content: function(ready) {
                                var $el = instance.imageEditor.render(data);
                                function disableSubmitButton() {
                                    var $button = $el.find("input[type=submit]");
                                    var $loader = $("<span class='icon throbber loading'></span>");
                                    $button.attr("aria-disabled", "true").attr("disabled", "");
                                    $button.before($loader);
                                    return function() {
                                        $loader.remove();
                                        $button.removeAttr("aria-disabled").removeAttr("disabled");
                                    };
                                }

                                instance.imageEditor.edit({
                                    confirm: function (instructions) {
                                        var reEnableSubmit = disableSubmitButton();
                                        instance.avatarManager.createAvatarFromTemporary(instructions, {
                                            success: function (data) {
                                                instance.render(function () {
                                                    instance.selectAvatar(data.id);
                                                });
                                            },
                                            error: reEnableSubmit
                                        });
                                    }
                                });
                                $el.find(".cancel").click(function() {
                                    instance.cropperDialog.hide();
                                });
                                ready($el);
                            }
                        });
                        instance.cropperDialog.bind("dialogContentReady", function() {
                            $(instance).trigger(JIRA.AvatarPicker.ImageEditor.LOADED);
                        });
                        instance.cropperDialog.bind("Dialog.hide", function() {
                            $(instance).trigger(JIRA.AvatarPicker.ImageEditor.DISMISSED);
                        });

                        instance.cropperDialog.show();
                    }
                },
                error: function () {
                    console.log(arguments);
                }
            });
        },

        /**
         * Gets avatar HTML element based on it's database id
         *
         * @param {String} id
         * @return {$}
         */
        getAvatarElById: function (id) {
            return this.element.find(".jira-avatar[data-id='" + id + "']");
        },

        /**
         * Selects avatar
         *
         * @param {String} id - avatar id
         */
        selectAvatar: function (id) {
            var avatar = this.avatarManager.getById(id);
            var instance = this;

            this.avatarManager.selectAvatar(this.avatarManager.getById(id), {
                error: function () {
                },
                success: function () {

                    instance.getAvatarElById(id).remove();

                    if (instance.selectCallback) {
                        instance.selectCallback.call(instance, avatar,
                                instance.avatarManager.getAvatarSrc(avatar, instance.size));
                    }
                }
            });
        },

        /**
         * Deletes avatar, shows confirmation before hand
         *
         * @param {String} id - avatar id
         */
        deleteAvatar: function (id) {

            var instance = this;

            if (confirm("Are you sure you want to delete avatar?")) {
                this.avatarManager.destroy(this.avatarManager.getById(id), {
                    error: function () {

                    },
                    success: function () {

                        var selectedAvatar = instance.avatarManager.getSelectedAvatar(),
                            $avatar = instance.getAvatarElById(id);

                        $avatar.fadeOut(function () {
                            $avatar.remove();
                        });

                        // if the avatar we have deleted is the selected avatar, then we want to set the selected avatar to be
                        // the default. This is done automagically in AvatarStore.
                        if (selectedAvatar.getId() !== id) {

                            instance.getAvatarElById(selectedAvatar.getId()).addClass("jira-selected-avatar");

                            instance.selectCallback.call(instance, selectedAvatar,
                                    instance.avatarManager.getAvatarSrc(selectedAvatar, instance.size), true);
                        }
                    }
                });
            }
        },

        _events: {
            uploader: {
                change: function (e, el) {
                    this.uploadTempAvatar(el);
                }
            },
            deleteAvatar: {
                click: function (e, el) {
                    this.deleteAvatar(el.attr("data-id"));
                }
            },
            selectAvatar: {
                click: function (e, el) {
                    // Don't select avatar if we click an overlay, such as delete icon
                    if (el[0].id === "select-avatar-button") {
                        this.selectAvatar(el.attr("data-id"));
                    }
                }
            }
        }
    });

    /**
     * Handles cropping of avatar
     *
     * @class JIRA.AvatarPicker.ImageEditor
     *
     */
    JIRA.AvatarPicker.ImageEditor = AJS.Control.extend({
        /**
         * Renders cropper
         *
         * @param {Object} data
         * ... {Number} cropperOffsetX
         * ... {Number} cropperOffsetY
         * ... {Number} cropperWidth
         */
        render: function (data) {
            this.element = $('<div id="avatar-picker-image-editor"/>').html(JIRA.Templates.AvatarPicker.imageEditor(data));
            return this.element;
        },

        /**
         * Initializes cropper
         *
         * @param {Object} options
         * ... {Function} confirm
         * ... {Function} cancel
         * ... {Function} ready
         */
        edit: function (options) {

            var instance = this,
                    avator = this.element.find(".avataror");

            options = options || {};

            avator.unbind();
            avator.bind("AvatarImageLoaded", function () {
                if (options.ready) {
                    options.ready();
                }
            });

            avator.find("img").load(function () {
                avator.avataror({
                    previewElement: instance.element.find(".jira-avatar-cropper-header"),
                    parent: instance.element
                });
            });

            this.element.find("#avataror").submit(function (e) {

                e.preventDefault();

                if (options.confirm) {
                    options.confirm({
                        cropperOffsetX: $("#avatar-offsetX").val(),
                        cropperOffsetY: $("#avatar-offsetY").val(),
                        cropperWidth: $("#avatar-width").val()
                    });
                }
            })
            .find(".cancel").click(function (e) {
                e.preventDefault();
                if (options.cancel) {
                    options.cancel();
                }
            });
        }

    });

    /**
     * Name of event fired when the image editor dialog is loaded and ready.
     */
    JIRA.AvatarPicker.ImageEditor.LOADED = "imageEditorLoaded";

    /**
     * Name of event fired when the image editor dialog is dismissed/actioned and unloaded.
     */
    JIRA.AvatarPicker.ImageEditor.DISMISSED = "imageEditorDismissed";


    /**
     * Creates project avatar picker
     *
     * @param options
     * ... {String} projectKey
     *
     * @return JIRA.AvatarPicker
     */
    JIRA.AvatarPicker.createUniversalAvatarPicker = function (options) {
        return new JIRA.AvatarPicker({
            avatarManager: JIRA.AvatarManager.createUniversalAvatarManager({
                projectKey: options.projectKey,
                projectId: options.projectId,
                defaultAvatarId: options.defaultAvatarId,
                avatarType: options.avatarType
            }),
            initialSelection: options.initialSelection,
            imageEditor: new JIRA.AvatarPicker.ImageEditor(),
            size: options.hasOwnProperty('avatarSize') ? options.avatarSize : JIRA.Avatar.LARGE,
            select: options.select
        });
    };

    /**
     * Creates project avatar picker
     *
     * @param options
     * ... {String} projectKey
     *
     * @return JIRA.AvatarPicker
     */
    JIRA.AvatarPicker.createProjectAvatarPicker = function (options) {
        return new JIRA.AvatarPicker({
            avatarManager: JIRA.AvatarManager.createProjectAvatarManager({
                projectKey: options.projectKey,
                projectId: options.projectId,
                defaultAvatarId: options.defaultAvatarId
            }),
            imageEditor: new JIRA.AvatarPicker.ImageEditor(),
            size: JIRA.Avatar.LARGE,
            select: options.select
        });
    };

    /**
     * Creates user avatar picker
     *
     * @param {Object} options
     * @param {String} options.username
     *
     * @return JIRA.AvatarPicker
     */
    JIRA.AvatarPicker.createUserAvatarPicker = function (options) {
        return new JIRA.AvatarPicker({
            avatarManager: JIRA.AvatarManager.createUserAvatarManager({
                username: options.username,
                defaultAvatarId: options.defaultAvatarId
            }),
            imageEditor: new JIRA.AvatarPicker.ImageEditor(),
            size: JIRA.Avatar.LARGE,
            select: options.select
        });
    };

    /**
     * Creates a project avatar picker dialog
     *
     * @param {Object} options
     * @param {HTMLElement | String} options.trigger - element that when clicked will bring up dialog
     * @param {String} options.projectKey
     * @param {String} options.projectId
     */
    JIRA.createUniversalAvatarPickerDialog = function (options) {
        var lastSelection = options.initialSelection || options.defaultAvatarId;

        var projectAvatarDialog = new JIRA.FormDialog({
            trigger: options.trigger,
            id: "project-avatar-picker",
            width: 600,
            stacked: true,
            content: function (ready) {

                var avatarPicker,
                        $dialogWrapper;

                $dialogWrapper = $('<div id="projectavatar-content-wrapper"/>');

                $("<h2 />").text( options.title || "Select a Project Avatar")
                        .appendTo($dialogWrapper);


                avatarPicker = JIRA.AvatarPicker.createUniversalAvatarPicker({
                    projectKey: options.projectKey,
                    projectId: options.projectId,
                    defaultAvatarId: options.defaultAvatarId,
                    initialSelection: lastSelection,
                    avatarType: options.avatarType,
                    avatarSize: options.avatarSize,
                    select: function (avatar, src, implicit) {
                        lastSelection = String(avatar.getId());

                        if (options.select) {
                            options.select.apply(this, arguments);
                        }
                        if (!implicit) {
                            projectAvatarDialog.hide();
                        }
                    }
                });

                avatarPicker.render(function (content) {
                    $dialogWrapper.append(content);
                    ready($dialogWrapper);
                });
            }
        });

        projectAvatarDialog._focusFirstField = function () {};
    };

    /**
     * Creates a project avatar picker dialog
     *
     * @param {Object} options
     * @param {HTMLElement | String} options.trigger - element that when clicked will bring up dialog
     * @param {String} options.projectKey
     * @param {String} options.projectId
     */
    JIRA.createProjectAvatarPickerDialog = function (options) {
        var projectAvatarDialog = new JIRA.FormDialog({
            trigger: options.trigger,
            id: "project-avatar-picker",
            width: 600,
            stacked: true,
            content: function (ready) {

                var avatarPicker,
                    $dialogWrapper;

                $dialogWrapper = $('<div id="projectavatar-content-wrapper"/>');

                $("<h2 />").text("Select a Project Avatar")
                        .appendTo($dialogWrapper);


                avatarPicker = JIRA.AvatarPicker.createProjectAvatarPicker({
                    projectKey: options.projectKey,
                    projectId: options.projectId,
                    defaultAvatarId: options.defaultAvatarId,
                    select: function (avatar, src, implicit) {
                        if (options.select) {
                            options.select.apply(this, arguments);
                        }
                        if (!implicit) {
                            projectAvatarDialog.hide();
                        }
                    }
                });

                avatarPicker.render(function (content) {
                    $dialogWrapper.append(content);
                    ready($dialogWrapper);
                });
            }
        });

        projectAvatarDialog._focusFirstField = function () {};
    };

    var avatarPickerData = WRM.data.claim("jira.webresources:avatar-picker.data");

    /**
     * Creates a project avatar picker dialog
     *
     * @param {Object} options
     * @param {HTMLElement | String} options.trigger - element that when clicked will bring up dialog
     * @param {String} options.projectKey
     * @param {String} options.projectId
     */
    JIRA.createUserAvatarPickerDialog = function (options) {

        if (avatarPickerData && avatarPickerData.isEnabled) {
            // SW-1977 - Defer and redirect to the Atlassian ID version.
            $(options.trigger).click(function(e) {
                var href = AJS.contextPath() + avatarPickerData.url;
                var separator = href.indexOf("?") > -1 ? "&" : "?";
                href += separator + "continue=" + encodeURIComponent(window.location.href);
                e.preventDefault();
                e.stopPropagation();
                AJS.reloadViaWindowLocation(href);
            });
            return;
        }

        var userAvatarDialog = new JIRA.FormDialog({
            trigger: options.trigger,
            id: "user-avatar-picker",
            width: 600,
            stacked: true,
            content: function (ready) {

                var avatarPicker,
                    $dialogWrapper;

                $dialogWrapper = $('<div id="useravatar-content-wrapper"/>');

                $("<h2 />").text("Select a User Avatar")
                        .appendTo($dialogWrapper);


                avatarPicker = JIRA.AvatarPicker.createUserAvatarPicker({
                    username: options.username,
                    defaultAvatarId: options.defaultAvatarId,
                    select: function (avatar, src, implicit) {

                        if (options.select) {
                            options.select.apply(this, arguments);
                        }

                        $(".avatar-image").attr("src", src);

                        if (!implicit) {
                            userAvatarDialog.hide();
                        }
                    }
                });

                avatarPicker.render(function (content) {
                    $dialogWrapper.append(content);
                    ready($dialogWrapper);
                });
            }
        });
    };

    // initialize user picker dialog
    $(function () {
        JIRA.createUserAvatarPickerDialog({
            trigger: "#user_avatar_image",
            username: $("#avatar-owner-id").text(),
            defaultAvatarId: $("#default-avatar-id").text()
        });
    });

})(window.jQuery);
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/GravatarUtil.js' */
/**
 * Helper methods for showing Gravatar-related help text.
 */
;(function() {
    AJS.namespace('JIRA.GravatarUtil');
    JIRA.GravatarUtil.showGravatarHelp = function(data) {
        // response is in the form of  { entry: [] }
        if (typeof(data) !== 'undefined' && typeof(data.entry) !== 'undefined') {
            // hide the "sign up" text and show the "log in" text
            AJS.$('.gravatar-signup-text').addClass('hidden');
            AJS.$('.gravatar-login-text').removeClass('hidden');
        }
    };

    var displayGravatarHelp = function() {
        var gravatarJsonUrl = AJS.$('#gravatar_json_url');
        if (gravatarJsonUrl.length) {
            // use JSONP to determine whether the user has a Gravatar
            AJS.$.ajax(gravatarJsonUrl.val(), {
                dataType: 'jsonp',
                success: JIRA.GravatarUtil.showGravatarHelp
            });
        }
    };

    AJS.$(document).ready(function() {
        if (AJS.$('#gravatar_help_params')) {
            displayGravatarHelp();
        }
    });
}());
;
;
/* module-key = 'jira.webresources:avatar-picker', location = '/includes/ajs/avatarpicker/AvatarPicker.soy' */
// This file was automatically generated from AvatarPicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.AvatarPicker.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.AvatarPicker == 'undefined') { JIRA.Templates.AvatarPicker = {}; }


JIRA.Templates.AvatarPicker.picker = function(opt_data, opt_ignored) {
  var output = '<form class="jira-avatar-upload-form aui top-label" action="#"><input name="id" value="10000" type="hidden" ><input name="pid" value="10000" type="hidden" ><div class="field-group"><label for="jira-avatar-uploader">' + soy.$$escapeHtml("Upload a new avatar") + '</label><input type="file" class="ignore-inline-attach" name="avatar" id="jira-avatar-uploader"/><div class="error"></div></div></form><div class="form-body"><ul class="jira-avatars">';
  var avatarList6 = opt_data.avatars.system;
  var avatarListLen6 = avatarList6.length;
  for (var avatarIndex6 = 0; avatarIndex6 < avatarListLen6; avatarIndex6++) {
    var avatarData6 = avatarList6[avatarIndex6];
    output += '<li class="jira-avatar jira-system-avatar ' + ((avatarData6.isSelected) ? 'jira-selected-avatar' : '') + '" title="Select this Avatar" data-id="' + soy.$$escapeHtml(avatarData6.id) + '"><button id="select-avatar-button" data-id="' + soy.$$escapeHtml(avatarData6.id) + '" class="jira-icon-button" title="' + soy.$$escapeHtml("Select this Avatar") + '"><img id="avatar-' + soy.$$escapeHtml(avatarData6.id) + '" src="' + soy.$$escapeHtml(avatarData6.src) + '" width="' + soy.$$escapeHtml(avatarData6.width) + '" height="' + soy.$$escapeHtml(avatarData6.height) + '" alt="' + soy.$$escapeHtml("Select this Avatar") + '"/></button></li>';
  }
  var avatarList29 = opt_data.avatars.custom;
  var avatarListLen29 = avatarList29.length;
  for (var avatarIndex29 = 0; avatarIndex29 < avatarListLen29; avatarIndex29++) {
    var avatarData29 = avatarList29[avatarIndex29];
    output += '<li class="jira-avatar jira-custom-avatar ' + ((avatarData29.isSelected) ? 'jira-selected-avatar' : '') + '" title="Select this avatar" data-id="' + soy.$$escapeHtml(avatarData29.id) + '"><button id="select-avatar-button" data-id="' + soy.$$escapeHtml(avatarData29.id) + '" class="jira-icon-button" title="' + soy.$$escapeHtml("Select this Avatar") + '"><img id="avatar-' + soy.$$escapeHtml(avatarData29.id) + '" src="' + soy.$$escapeHtml(avatarData29.src) + '" width="' + soy.$$escapeHtml(avatarData29.width) + '" height="' + soy.$$escapeHtml(avatarData29.height) + '" alt="' + soy.$$escapeHtml("Select this Avatar") + '" /></span><button class="jira-delete-avatar jira-icon-button" data-id="' + soy.$$escapeHtml(avatarData29.id) + '" title="' + soy.$$escapeHtml("Delete this Avatar") + '">' + soy.$$escapeHtml("Delete this Avatar") + '</button></li>';
  }
  output += '</ul></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.AvatarPicker.picker.soyTemplateName = 'JIRA.Templates.AvatarPicker.picker';
}


JIRA.Templates.AvatarPicker.imageEditor = function(opt_data, opt_ignored) {
  return '<form id="avataror" class="jira-avatar-cropper-form aui" action="/jira/secure/project/AvatarPicker.jspa"><input type="hidden" name="cropperOffsetX" id="avatar-offsetX" value="' + soy.$$escapeHtml(opt_data.cropperOffsetX) + '"><input type="hidden" name="cropperOffsetY" id="avatar-offsetY" value="' + soy.$$escapeHtml(opt_data.cropperOffsetY) + '"><input type="hidden" name="cropperWidth" id="avatar-width"  value="' + soy.$$escapeHtml(opt_data.cropperWidth) + '"><div class="jira-avatar-cropper-header"><p>' + soy.$$escapeHtml("Please select which part of the uploaded image you wish to use as the avatar.") + '</p></div><div class="form-body"><div class="avataror"><img src="' + soy.$$escapeHtml(opt_data.url) + '" height="300" /></div></div><div class="form-footer buttons-container"><div class="buttons"><input type="submit" class="aui-button aui-button-primary" value="' + soy.$$escapeHtml("Confirm") + '"><a class="aui-button aui-button-link cancel" href="#">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form>';
};
if (goog.DEBUG) {
  JIRA.Templates.AvatarPicker.imageEditor.soyTemplateName = 'JIRA.Templates.AvatarPicker.imageEditor';
}
;
;
/* module-key = 'jira.webresources:avatar-picker-trigger', location = '/includes/jira/admin/initAvatarPickerTrigger.js' */
(function () {


    var AvatarPickerContentRetriever = AJS.ContentRetriever.extend({

        init: function (avatarPicker) {
            this.avatarPicker = avatarPicker;
        },

        content: function (finished) {
            this.avatarPicker.render(function (el) {
                finished(jQuery("<div />").html(el));
            });
        },
        cache: function () {
            return false;
        },
        isLocked: function () {},
        startingRequest: function () {},
        finishedRequest: function () {}

    });


    var InlineAvatarPicker = AJS.InlineLayer.extend({

        init: function (options) {
            var instance = this;
            this.avatarPicker = JIRA.AvatarPicker.createProjectAvatarPicker({
                projectId: options.projectId,
                projectKey: options.projectKey,
                defaultAvatarId: options.defaultAvatarId,
                select: function (avatar, src, implicit) {
                    if (options.select) {
                        options.select.apply(this, arguments);
                    }
                    if (!implicit) {
                        instance.hide();
                    }

                    instance.offsetTarget().attr("src", src);
                    instance.offsetTarget().trigger("AvatarSelected");
                }
            });

            options.contentRetriever = new AvatarPickerContentRetriever(this.avatarPicker);

            jQuery(this.avatarPicker.imageEditor).bind(JIRA.AvatarPicker.ImageEditor.LOADED, function () {
                // todo: need to use prop() instead of attr() in master
                instance.setWidth(instance.layer().attr("scrollWidth"));
            });

            this._super(options);

            // Wrap the image in a little box to manage its appearance.
            var $triggerImg = this.offsetTarget();
            var $triggerContainer = jQuery("<span class='jira-avatar-picker-trigger'></span>");
            $triggerContainer.insertBefore($triggerImg).append($triggerImg);

            this._assignEvents("offsetTarget", $triggerContainer);

        },
        _events: {
            offsetTarget: {
                click: function (e) {
                    this.show();
                }
            }
        }
    });


    function initProjectAvatarPicker(ctx) {
        var trigger = jQuery(".jira-avatar-picker-trigger");
        var triggerImg = jQuery(".jira-avatar-picker-trigger img, img.jira-avatar-picker-trigger", ctx);
        var avatarIdField = jQuery(ctx).find("#avatar-picker-avatar-id");
        var avatarIconurlField = jQuery(ctx).find("#avatar-picker-iconurl");
        var avatarTypeElement = jQuery(ctx).find("#avatar-type");
        if ("" === avatarTypeElement.text()) return;
        JIRA.createUniversalAvatarPickerDialog({
            trigger: trigger,
            title: jQuery(ctx).find("#avatar-dialog-title").text(),
            projectId: jQuery(ctx).find("#avatar-owner-id").text(),
            projectKey: jQuery(ctx).find("#avatar-owner-key").text(),
            defaultAvatarId: jQuery(ctx).find("#default-avatar-id").text(),
            initialSelection: avatarIdField.val(),
            avatarSize: JIRA.Avatar.getSizeObjectFromName(jQuery(ctx).find("#avatar-size").text()),
            avatarType: avatarTypeElement.text(),
            select: function (avatar, src) {
                triggerImg.attr("src", src);
                avatarIconurlField.val(src);
                avatarIdField.val(avatar.getId());
            }
        });
    }

    function initProjectInlineAvatarPicker(ctx) {
        var $triggerImg = jQuery(".jira-inline-avatar-picker-trigger", ctx);

        if ($triggerImg.length) {
            new InlineAvatarPicker({
                offsetTarget: $triggerImg,
                projectId: jQuery(ctx).find("#avatar-owner-id").text(),
                projectKey: jQuery(ctx).find("#avatar-owner-key").text(),
                defaultAvatarId: jQuery(ctx).find("#default-avatar-id").text(),
                alignment: AJS.LEFT,
                width: 420, // Fits 7 avatars + the OSX choose file dialog min width.
                allowDownsize: true
            });
        }

    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason !== JIRA.CONTENT_ADDED_REASON.panelRefreshed) {
            initProjectAvatarPicker(context);
            initProjectInlineAvatarPicker(context);
        }
    });

})();;
;
/* module-key = 'jira.webresources:croneditor', location = '/includes/js/cron/croneditor.js' */
/*
Renders an element visible to the user
*/
function hideCronEdit(elementid)
{
    document.getElementById(elementid).style.display = 'none';
}

/*
Renders an element invisible to the user
*/
function showCronEdit(elementid)
{
    document.getElementById(elementid).style.display = '';
}

function toggleFrequencyControl(paramPrefix, setOriginal)
{
    var select = document.getElementById(paramPrefix + "interval");
    if(select.value == 0)
    {
        switchToOnce(paramPrefix, setOriginal);
    }
    else
    {
        switchToMany(paramPrefix, setOriginal);
    }
}

/*
Toggles the frequency controls to match 'once per day' mode
*/
function switchToOnce(paramPrefix, setOriginal)
{
    //make sure the frequency select is set correctly
    //set state
    hideCronEdit(paramPrefix + "runMany");
    showCronEdit(paramPrefix + "runOnce");
    if (setOriginal)
    {
        timesOnce[paramPrefix] = true;
    }
}

/*
Toggles the frequency controls to match 'many per day' mode
*/
function switchToMany(paramPrefix, setOriginal)
{
    //set state
    hideCronEdit(paramPrefix + "runOnce");
    showCronEdit(paramPrefix + "runMany");
    if (setOriginal)
    {
        timesOnce[paramPrefix] = false;
    }
}

function switchToDaysOfMonth(paramPrefix)
{
    hideCronEdit(paramPrefix + 'daysOfWeek');
    showCronEdit(paramPrefix + 'daysOfMonth');
    showCronEdit(paramPrefix + 'freqDiv');
    hideCronEdit(paramPrefix + 'innerFreqDiv');
    hideCronEdit(paramPrefix + 'advanced');
    switchToOnce(paramPrefix, false);
}

function switchToDaysOfWeek(paramPrefix)
{
    showCronEdit(paramPrefix + 'daysOfWeek');
    hideCronEdit(paramPrefix + 'daysOfMonth');
    showCronEdit(paramPrefix + 'freqDiv');
    showCronEdit(paramPrefix + 'innerFreqDiv');
    hideCronEdit(paramPrefix + 'advanced');
    switchToOriginal(paramPrefix);
}

function switchToDaily(paramPrefix)
{
    hideCronEdit(paramPrefix + 'daysOfWeek');
    hideCronEdit(paramPrefix + 'daysOfMonth');
    showCronEdit(paramPrefix + 'freqDiv');
    showCronEdit(paramPrefix + 'innerFreqDiv');
    hideCronEdit(paramPrefix + 'advanced');
    switchToOriginal(paramPrefix);
}

function switchToAdvanced(paramPrefix)
{
    hideCronEdit(paramPrefix + 'daysOfWeek');
    hideCronEdit(paramPrefix + 'daysOfMonth');
    hideCronEdit(paramPrefix + "runOnce");
    hideCronEdit(paramPrefix + "runMany");
    hideCronEdit(paramPrefix + 'freqDiv');
    showCronEdit(paramPrefix + 'advanced');

}

function switchToOriginal(paramPrefix)
{
    if (timesOnce[paramPrefix])
    {
        switchToOnce(paramPrefix, false);
    }
    else
    {
        switchToMany(paramPrefix, false);
    }
}
;
;
/* module-key = 'com.atlassian.jira.jira-quick-edit-plugin:loading-indicator', location = 'js/util/loading-indicator.js' */
define('quick-edit/util/loading-indicator',[
    'jira/loading/loading',
    'jira/flag'
], function (
    Loading,
    Flag
) {
    var dim = AJS.dim;
    var undim = AJS.undim;

    return {
        showLoadingIndicator: function () {
            dim();
            Loading.showLoadingIndicator();
        },

        hideLoadingIndicator: function (showErrorFlag) {
            undim();
            Loading.hideLoadingIndicator();
            if (showErrorFlag) {
                Flag.showErrorMsg(null, "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.");
            }
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue-bootstrap', location = 'js/init/create-bootstrap-wrm.js' */
require([
    'jquery',
    'underscore',
    'wrm/require',
    'quick-edit/util/loading-indicator',
    'jira/ajs/keyboardshortcut/keyboard-shortcut-toggle'
], function (
    jQuery,
    _,
    wrmRequire,
    LoadingIndicator,
    KeyboardShortcutToggle
) {
    var showLoadingIndicator = function () {
        KeyboardShortcutToggle.disable();
        LoadingIndicator.showLoadingIndicator();
    };
    var hideLoadingIndicator = function () {
        LoadingIndicator.hideLoadingIndicator(true);
        KeyboardShortcutToggle.enable();
    };

    var subtaskTrigger;

    var createIssueDialogLoading = false;
    jQuery(document).on("simpleClick", ".create-issue, .create-issue-type", function(e) {
        e.preventDefault();
        if( !createIssueDialogLoading ) {
            createIssueDialogLoading = true;
            showLoadingIndicator();
            var resourceKey = 'wr!com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue';
            var wrmRequireDeferred = wrmRequire([resourceKey]);
            wrmRequireDeferred.then(onDone.bind(undefined, e), function onFail() {
                hideLoadingIndicator();
                createIssueDialogLoading = false;
            });
        }
    });
    var onDone = function (e) {
        var InitCreateDialogs = require('quick-edit/init/create');
        InitCreateDialogs.initIssueDialog(e);

        KeyboardShortcutToggle.enable();
        createIssueDialogLoading = false;
    };

jQuery(function () {
    subtaskTrigger = document.getElementById("stqc_show");

    // remove old subtask form
    if (subtaskTrigger) {
        subtaskTrigger.onclick = null;
    }
});

    var createSubtaskDialogLoading = false;
    jQuery(document).on("simpleClick", ".issueaction-create-subtask", function(e) {
        e.preventDefault();
        if (!createSubtaskDialogLoading) {
            createSubtaskDialogLoading = true;
            showLoadingIndicator();
            var resourceKey = 'wr!com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue';
            var wrmRequireDeferred = wrmRequire([resourceKey]);
            wrmRequireDeferred.then(onDoneSubtask, function onFail() {
                hideLoadingIndicator();
                createSubtaskDialogLoading = false;
            });
        }
    });
    var onDoneSubtask = function (e) {
        var InitCreateDialogs = require('quick-edit/init/create');
        InitCreateDialogs.initSubtaskDialog(e);

        KeyboardShortcutToggle.enable();
        createSubtaskDialogLoading = false;
    }
});
;
;
/* module-key = 'jira.webresources:jira-page-atl-prefetch', location = '/includes/jira/page/prefetch.js' */
define('jira/page/atl/prefetch', [
    'jira/util/data/meta',
    'jira/data/local-storage',
    'jira/ajs/dark-features',
    'jquery'
], function definePrefetchResource(meta,
    storage,
    darkFeatures,
    jQuery
) {
    /**
     * A module for pre-fetching resources for given page before it is really visited.
     * <link rel="prefetch" /> is used to instruct browser which resources to pre download.
     * Currently used to prefetch view issue resources.
     * @exports jira/issue/resources-prefetch
     */
    'use strict';

    var SESSION_KEY = 'jira.issue.prefetch.last.superbatch';
    var stateToken = _getStateToken();

    //
    // Private functions
    //
    function _getStateToken() {
        //lets use last super batch url as token with date as browser most probably removed entries from cache
        var now = new Date();
        var dateStr = now.getFullYear().toString() + now.getMonth().toString() + now.getDate().toString();
        var superbatch = jQuery('head > script').filter(function findSuperbatch(a, b) {return b.src.indexOf('/_super') > 0;});
        return (superbatch.length > 0 ? superbatch[0].src : 'empty') + dateStr;

    }

    function _addPrefetchTag(url) {
        jQuery('<link />', {
            rel: 'prefetch',
            href: url
        }).appendTo('head');
    }

    /**
     * @param {Object} issueMenuData - data for view issue menu.
     * @param {Object} [issueMenuData.sections] - optional section in view issue menu.
     */
    function _getLastIssueFromMenu(issueMenuData) {
        var sections = issueMenuData.sections;
        if (!sections) {
            return;
        }
        var recentIssues = sections.filter(function filterMenu(menuItem) {return menuItem.id === 'issues_history_main';});
        if (recentIssues.length && recentIssues[0].items.length !== 0) {
            var lastIssue = recentIssues[0].items[0];
            return lastIssue.url;
        }
    }

    function _addPrefetchForRegex(response, regex) {
        var matchResult;
        while (matchResult = regex.exec(response)) {
            var url = matchResult[1].replace(/&amp;/g, '&');
            _addPrefetchTag(url);
        }
    }

    function _rememberFetchState() {
        storage.setItem(SESSION_KEY, stateToken);

    }

    function _parsePageAndInsertLinks(data) {
        _addPrefetchForRegex(data, /<script.+?src="(.+?)".+?<\/script>/g);
        _addPrefetchForRegex(data, /<link.+?rel="stylesheet".+?href="(.+?)".+?>/g);
        _rememberFetchState();
    }

    function _shouldFetchResources() {
        if (!darkFeatures.isEnabled('jira.issue.prefetch')) {
            //don't fetch if dark feature is not enabled
            return false;
        }
        if (jQuery('#isNavigator').length === 1) {
            //don't fetch on navigator as this has the same resources as issue
            _rememberFetchState();
            return false;
        }
        else if (meta.get('issue-key')) {
            //don't fetch on issue page
            _rememberFetchState();
            return false;
        }
        else {
            //fetch if current state token is different for stored in local storage
            return stateToken !== storage.getItem(SESSION_KEY);
        }
    }
    function _prefetchResourcesForLastIssue(data) {
        var issueUrl = _getLastIssueFromMenu(data);
        if (issueUrl) {
            prefetchResourcesForUrl(issueUrl);
        }
    }
    //
    // Public API functions
    //

    function prefetchResourcesForUrl(url) {
        jQuery.get(url, _parsePageAndInsertLinks);
    }


    function prefetchViewIssueResources() {
        if (_shouldFetchResources()) {
            //only execute if we are on view issue context and
            jQuery.ajax(
                {
                    url: AJS.contextPath() + '/rest/api/1.0/menus/find_link?inAdminMode=false',
                    dataType: 'json'
                }).done(_prefetchResourcesForLastIssue);
        }
    }

    return {
        /**
         * Adds prefetch tags for resources included by page at given URL
         * @param {String} url
         */
        prefetchResourcesForUrl: prefetchResourcesForUrl,
        /**
         * Adds prefetch tags for view issue resources.
         * It will work only if user has visited any issue in the past so it is accessible from latest issues menu.
         */
        prefetchViewIssueResources: prefetchViewIssueResources
    };
});
;
;
/* module-key = 'jira.webresources:init-jira-page-atl-prefetch', location = '/includes/jira/page/initPrefetch.js' */
require(['jira/page/atl/prefetch', 'jquery'], function executePrefetch(resourcePrefetch, $) {
    $(window).on('load', resourcePrefetch.prefetchViewIssueResources.bind(resourcePrefetch));
});
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:update-plugin-banner-resources', location = 'js/banner/update-hipchat-link-banner.js' */
(function ($) {
    AJS.toInit(function () {

        var HIPCHAT_ADMIN_BANNER_COOKIE_KEY = "HIPCHAT_ADMIN_BANNER_DISMISS_2";
        var warningMsg;

        if (!isHipChatConfigurationPage() && AJS.Meta.get("is-admin") && !isAlreadyDismissed()) {

            $.ajax({
                url: AJS.contextPath() + '/rest/hipchat/integrations/1.0/configuration/status',
                dataType: 'json',
                cache: false
            }).done(function (data) {

                if (data.requiresManualInstallation || data.v1) {
                    warningMsg = showWarningMsg(data);
                }
            });

        }

        function showWarningMsg(data) {
            var html = JIRA.Templates.HipChat.Banner.updateHipChatLink({removeV1link: !data.v2 && data.v1});
            var warningMsg = JIRA.Messages.showWarningMsg(html);
            $(document).on("click", "#remove-hipchat-v1-link", removeHipChatLink);
            $(document).on("aui-flag-close", ".aui-flag", dismissPopUp);
            return warningMsg;
        }

        function isHipChatConfigurationPage() {
            return window.location.toString().indexOf("/plugins/servlet/hipchat/configure") > 0;
        }

        function dismissPopUp(e) {

            // The aui flag sends all the close events, that is why we need to filter
            // to the flag that has my container
            if ($(e.target).find(".hipchat-update-banner").length > 0) {
                AJS.Cookie.save(HIPCHAT_ADMIN_BANNER_COOKIE_KEY, true);
            }
        }

        function isAlreadyDismissed() {
            return AJS.Cookie.read(HIPCHAT_ADMIN_BANNER_COOKIE_KEY) == "true";
        }


        function removeHipChatLink(e) {
            e.preventDefault();

            $.ajax({
                url: AJS.contextPath() + '/rest/hipchat/integrations/1.0/configuration/v1',
                cache: false,
                type: "DELETE"
            }).error(function (error) {

                if(warningMsg){
                    warningMsg.hide();
                }

                JIRA.Messages.showErrorMsg(AJS.format("We couldn\'\'t find your integration. If the problem persists, contact Atlassian Support.\u003cbr/\u003e Error Status [{0}]", error.status));

            }).done(function (data) {

                if(warningMsg){
                    warningMsg.hide();
                }

                JIRA.Messages.showSuccessMsg("Integration has been removed successfully");
            });
        }
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.labs.hipchat.hipchat-for-jira-plugin:update-plugin-banner-resources', location = 'soy/banner/update-hipchat-link-banner.soy' */
// This file was automatically generated from update-hipchat-link-banner.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.HipChat.Banner.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.HipChat == 'undefined') { JIRA.Templates.HipChat = {}; }
if (typeof JIRA.Templates.HipChat.Banner == 'undefined') { JIRA.Templates.HipChat.Banner = {}; }


JIRA.Templates.HipChat.Banner.updateHipChatLink = function(opt_data, opt_ignored) {
  return '<div class="hipchat-update-banner"><b>' + soy.$$escapeHtml("HipChat Integration is out of date") + '</b><p>' + soy.$$escapeHtml("Update to take full advantage of the latest features.") + '</p><p/><a href="' + soy.$$escapeHtml("/jira" + '/plugins/servlet/hipchat/configure') + '">' + soy.$$escapeHtml("Update Now!") + '</a>' + ((opt_data.removeV1link) ? '<a id="remove-hipchat-v1-link">' + soy.$$escapeHtml("Remove Integration") + '</a>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.HipChat.Banner.updateHipChatLink.soyTemplateName = 'JIRA.Templates.HipChat.Banner.updateHipChatLink';
}
;
;
/* module-key = 'com.atlassian.labs.plugins.quickreload.reloader:qr-batched-mode-twizzler', location = 'batchedmode/quickreload-batchedmode-switcher.js' */
;(function($, AJS) {
    if(!$) {
        console.warn("Could not find jQuery, QuickReload batch mode switcher not enabled");
        return;
    }
    if(!AJS) {
        console.warn("Could not find AJS, QuickReload batch mode switcher not enabled");
        return;
    }
    if(!$.isFunction(AJS.whenIType)) {
        console.warn("Could not find AJS.whenIType, QuickReload batch mode switcher not enabled");
        return;
    }

    //From underscore
    var debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;

        var later = function() {
            var last = Date.now() - timestamp;

            if (last < wait && last >= 0) {
                timeout = setTimeout(later, wait - last);
            } else {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                    if (!timeout) context = args = null;
                }
            }
        };

        return function() {
            context = this;
            args = arguments;
            timestamp = Date.now();
            var callNow = immediate && !timeout;
            if (!timeout) timeout = setTimeout(later, wait);
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }

            return result;
        };
    };

    var searchForContextPath = function() {
        if($.isFunction(AJS.contextPath)) {
            return AJS.contextPath();
        } else if (AJS.Meta && $.isFunction(AJS.Meta.get)) {
            try {
                return AJS.Meta.get("context-path");
            } catch(ignored) {}
        }

        return null;
    };

    var getCurrentBatchModeStateUrl = function(contextPath) {
        return contextPath + "/rest/qr/1.0/batching";
    };

    var getUpdateBatchModeUrl = function(contextPath, enableBatching) {
        return contextPath + "/rest/qr/1.0/batching/setState?enabled=" + !!enableBatching;
    };

    var tryGrabAuiFlag = function() {
        try {
            if($.isFunction(require)) {
                return require("aui/flag");
            }
        } catch(notFoundException) {}

        return null;
    };

    var getToastSuccessTitle = function(newBatchedModeState) {
        if(!!newBatchedModeState) {
            return "Production mode";
        } else {
            return "Dev mode";
        }
    };

    var getToastSuccessMessageHtml = function(newBatchedModeState) {
        if(!!newBatchedModeState) {
            return "Web resource batching and caching enabled";
        } else {
            return "Disabled web resource batching and caching";
        }
    };

    var toastSuccess = function(title, messageHtml) {
        toastMessage(title, messageHtml, true);
    };

    var toastError = function(title, messageHtml) {
        toastMessage(title, messageHtml, false);
    };

    var messageId = "quickreload-flag";
    var toastMessage = function(title, messageHtml, isSuccess) {
        var auiFlag = tryGrabAuiFlag();
        if(auiFlag) {
            auiFlag({
                type: !!isSuccess ? "success" : "error",
                title: title,
                body: messageHtml,
                persistent: false,
                close: "auto"
            });
        } else if(AJS.messages && $.isFunction(AJS.messages.success)) {
            var messageFunc;
            if(!!isSuccess) {
                messageFunc = AJS.messages.success;
            } else {
                messageFunc = AJS.messages.error;
            }

            var $message = $(messageFunc.call(AJS.messages, {
                title: title,
                body: messageHtml,
                id: messageId,
                fadeout: true,
                delay: 3000
            }));

            $("#" + messageId).remove();
            $("body").append($message);
        } else {
            alert(title);
        }
    };

    $(function() {
        var contextPath = searchForContextPath();
        if(!contextPath) {
            console.warn("Failed to determine context path, QuickReload batch mode switcher not enabled");
            return;
        }

        var batchingEnabledState = false;
        //Fetch initial state
        $.get(getCurrentBatchModeStateUrl(contextPath)).done(function(data) {
            batchingEnabledState = data.batchingEnabled;
        });

        var debouncedToggleBatchingCallback = debounce(function() {
            $.get(getUpdateBatchModeUrl(contextPath, !batchingEnabledState))
                .done(function(data) {
                    batchingEnabledState = data.batchingEnabled;
                    var successTitle = getToastSuccessTitle(batchingEnabledState);
                    var successMessageHtml = getToastSuccessMessageHtml(batchingEnabledState);
                    toastSuccess(successTitle, successMessageHtml);
                })
                .fail(function(xhr, textStatus) {
                    if(textStatus !== "abort") {
                        var batchingStateStr = batchingEnabledState ? "enabled" : "disabled";
                        toastError("Failed to update batch mode state (current state: " + batchingStateStr + ")");
                    }

                });
        }, 2000, true);

        AJS.whenIType("b").execute(debouncedToggleBatchingCallback);
    });
})((AJS && AJS.$) || $, AJS);;
;
/* module-key = 'com.atlassian.plugins.helptips.jira-help-tips:common', location = 'js/HelpTip.js' */
(function($) {
    function nope() { return false; }
    function yep() { return true; }

    var HELP_TIP_CLASSNAMES = 'jira-help-tip aui-help';

    var cidCounter = 0, seed = new Date().getTime();

    // to un-fuck graphite event names
    function cleanAnalyticsName(name) {
        name = "" + (name || "");
        return name.replace(/\./g, "-");
    }

    function analytics(eventId, model) {
        if (AJS.EventQueue && model && model.attributes.id) {
            var event = {};
            var cleanId = cleanAnalyticsName(model.attributes.id);
            var eventPrefix = "";

            if (model.attributes.eventPrefix) {
                eventPrefix = model.attributes.eventPrefix;
                // Ensure a dot at the end of the event prefix
                if (eventPrefix.charAt(eventPrefix.length - 1) !== ".") {
                    eventPrefix += ".";
                }
            }

            event.name = eventPrefix + "helptips." + cleanId + "." + eventId;
            event.properties = {};
            AJS.EventQueue.push(event);
        }
    }

    function getCid() {
        return "jira-help-tip-" + seed + (cidCounter++);
    }

    /**
     * @param attributes
     * @param attributes.id
     * @param attributes.callbacks callbacks used by helptip and passed into AJS.InlineDialog
     * @param attributes.callbacks.beforeShow {jQuery.Deferred() | Function} called before rendering the helptip
     * @param attributes.callbacks.init {Function} passed into AJS.InlineDialog as initCallback param
     * @param attributes.callbacks.hide {Function} passed into AJS.InlineDialog as hideCallback param
     * @param attributes.isSequence {Boolean} to indicate whether this helptip should be shown in sequence
     *        see https://developer.atlassian.com/design/latest/feature-discovery.html
     * @param attributes.weight {Integer} the weight of the helptip determining the order to be shown in sequence
     * @param attributes.body {String} the HTML body content of the helptip
     * @param attributes.bodyHtml {String} same as attributes.body
     * @param attributes.inlineDialogOpts {Map} passed into AJS.InlineDialog as options, This will replace all the defaults specified by HelpTip
     * @param attributes.eventPrefix {String} The prefix to use for all analytics events
     * @param attributes.nextButtonText {String} The text to be displayed on the 'next' button
     * @param attributes.closeButtonText {String} The text to be displayed on the 'close' button
     * @param attributes.showCloseButton {Boolean} Whether the 'close' button should be displayed on the helptip
     *
     * @type {Function}
     */
    var HelpTip = AJS.HelpTip = function(attributes) {
        var anchor;
        this.attributes = $.extend({}, attributes);
        this.attributes.id || (this.attributes.id = false);
        this.attributes.callbacks || (this.attributes.callbacks = {});

        //Allows the helptip to be shown in sequence via next button
        if (this.attributes.isSequence) {
            if(!this.attributes.weight) {
                this.attributes.weight = Number.MAX_VALUE;
            }
            AJS.HelpTip.Manager.sequences.push(this);
        }

        // Map renamed attribute body to bodyHtml
        if (this.attributes.body) {
            this.attributes.bodyHtml = this.attributes.body;
            delete this.attributes.body;
        }
        this.cid = getCid();
        anchor = this.attributes['anchor'];
        delete this.attributes['anchor'];

        this.view = (anchor) ? new AnchoredView(this, anchor) : new UnanchoredView(this);
    };

    $.extend(HelpTip.prototype, {
        /**
         * @param options.force render the helptip regardless of the display controller
         */
        show: function(options) {
            options = options || {};

            var self = this;
            var showDeferred = $.Deferred();
            if (this.attributes.callbacks.beforeShow) {
                var beforeShowDeferred = this.attributes.callbacks.beforeShow();
                if (beforeShowDeferred && _.isFunction(beforeShowDeferred.done)) {
                    beforeShowDeferred.done(showDeferred.resolve)
                } else {
                    showDeferred.resolve();
                }
            } else {
                showDeferred.resolve();
            }

            showDeferred.done(function() {
                AJS.HelpTip.Manager.show(function() {
                    if (!self.isDismissed()) {
                        if (!options.force && AJS.Popups && AJS.Popups.DisplayController) {
                            AJS.Popups.DisplayController.request({
                                name:self.id,
                                weight:1000,
                                show:function () {
                                    self.view.show();
                                }})
                        } else {
                            self.view.show();
                        }
                        analytics("shown", self);
                    }
                });
            });
        },
        dismiss: function() {
            var reason = cleanAnalyticsName(arguments[0] || "programmatically");
            this.view.dismiss();
            //Clicking close should stop other helptip in sequence from showing
            if (reason === "close-button" && this.attributes.isSequence) {
                AJS.HelpTip.Manager.clearSequences();
            }
            if (!this.isDismissed()) {
                AJS.HelpTip.Manager.dismiss(this);
                analytics("dismissed." + reason, this);
            }
        },
        isVisible: function() {
            return this.view.$el.is(":visible");
        },
        isDismissed: function() {
            return AJS.HelpTip.Manager.isDismissed(this);
        },

        /**
         * Redraws the help tip.
         *  - If a selector was passed as the anchor, it will check if the actual element has changed and reanchor
         *    if necessary
         *  - If the anchor is not visible, it will hide the help tip
         *  - If the anchor has moved, it will re-position the help tip
         */
        refresh: function() {
            if (!this.isDismissed()) {
                this.view.refresh();
            }
        },

        /**
         * Hide the help tip without dismissing it
         */
        hide: function() {
            if (!this.isDismissed()) {
                this.view.dismiss();
            }
        },

        /**
         * Advance to the next help tip if this help tip
         * is part of a sequence and is not the last help
         * tip in the sequence. Useful in the situation where
         * user can progress by performing some action in addition to
         * clicking the next button.
         */
        showNextHelpTipInSequence: function() {
            this.view.clickNext();
        }
    });

    var AnchoredView = function(model, anchor) {
        this.initialize(model, anchor);
    };

    $.extend(AnchoredView.prototype, {
        initialize: function(model, anchor) {
            this.model = model;
            this.anchorSelector = anchor;
            this.anchor = AJS.$(anchor);
            this._initDialog(anchor);
            AJS.$(document).bind("showLayer",function(e,type,layer) {
                if (type === "inlineDialog" && layer.id === model.cid) {
                    AJS.InlineDialog.current = null; // Tips shouldn't be considered InlineDialogs.
                    AJS.$(document.body).unbind("click."+model.cid+".inline-dialog-check");
                    layer._validateClickToClose = nope;
                    layer.hide = nope;
                }
            });
        },
        show: function() {
            this.beforeHide = nope;
            this.popup.show();
        },
        refresh: function() {
            var maybeNewAnchor = AJS.$(this.anchorSelector);
            if (!maybeNewAnchor.is(':visible')) {
                this.dismiss(); // hide
            } else if (maybeNewAnchor.get(0) !== this.anchor.get(0)) {
                this.changeAnchor(maybeNewAnchor);
            } else if (!this.isVisible()) {
                this.show();
            } else {
                this.popup.refresh();
            }
        },
        changeAnchor: function(anchor) {
            var wasVisible = this.isVisible();
            this.dismiss();
            this.$el.remove();
            this.anchor = anchor;
            this._initDialog(anchor);
            if (wasVisible) {
                this.show();
            }
        },
        dismiss: function() {
            this.beforeHide = yep;
            this._popupHide();
        },
        clickNext: function() {
            var nextButton = AJS.$(this.$el).find(".helptip-next");
            if (nextButton.length > 0) {
                nextButton.click();
            }
        },
        isVisible: function() {
            return this.$el.is(':visible');
        },
        _initDialog: function(anchor) {
            var self = this;
            var model = this.model;
            this.popup = AJS.InlineDialog($(anchor), model.cid, _.bind(this._createDialog, this), _.extend({
                // Use a container other than body, so that the positioning works when there are client-rendered banner messages
                container: "#content",
                noBind: true,
                preHideCallback: function() { return self.beforeHide() },
                calculatePositions: function(popup, targetPosition, mousePosition, opts) {
                    // Adjust positions relative to the container
                    var cssData = AJS.InlineDialog.opts.calculatePositions(popup, targetPosition, mousePosition, opts);
                    var $container = $(this.container);
                    var offset = $container.offset();
                    if (cssData.popupCss.left !== 'auto') {
                        cssData.popupCss.left -= offset.left;
                        // Inline dialog has a bug where in some scenarios both left and right pos of the popup is set.
                        cssData.popupCss.right = 'auto';
                    }
                    cssData.popupCss.top -= offset.top;
                    return cssData;
                },
                addActiveClass: false,
                initCallback: model.attributes.callbacks.init,
                hideCallback: model.attributes.callbacks.hide,
                persistent: true
            }, model.attributes.inlineDialogOpts));
            this._popupHide = this.popup.hide;
            this.popup.hide = nope;
            this.$el = $(this.popup[0]);
            this.$el.addClass(HELP_TIP_CLASSNAMES);
        },
        _createDialog: function(content, trigger, show) {
            var instance = this;
            var sequenceDialogs = AJS.HelpTip.Manager.sequences;
            var position = this.model.attributes.position;
            var isSequence = this.model.attributes.isSequence;

            content.removeClass('contents');

            content.html($(AJS.Templates.HelpTip.tipContent(_.extend({
                showNextButton: isSequence && (sequenceDialogs.length > 1 && (position+1 < sequenceDialogs.length)),
                length: sequenceDialogs.length,
                position: position,
                showCloseButton: true
            }, this.model.attributes))));

            content.unbind('mouseover mouseout');
            content.find(".helptip-link").click(function() {
                analytics("learn-more.clicked", instance.model);
            });
            content.find(".helptip-close").click(function(e) {
                e.preventDefault();
                instance.model.dismiss("close-button");
            });
            content.find(".helptip-next").click(function(e) {
                e.preventDefault();
                instance.model.dismiss("next-button");
                var next = position + 1;
                sequenceDialogs[next] && (sequenceDialogs[next].show({force: true}));
            });
            show();
        }
    });

    var UnanchoredView = function(model) {
        this.initialize(model);
    };

    $.extend(UnanchoredView.prototype, {
        initialize: function() {
            this.$el = $("<div></div>");
            this.$el.addClass(HELP_TIP_CLASSNAMES);
        },
        show: function() { },
        dismiss: function() { }
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.plugins.helptips.jira-help-tips:common', location = 'js/HelpTipManager.js' */
(function($) {
    var restUrl = AJS.contextPath() + "/rest/helptips/1.0/tips";
    var tipWRMData = undefined;
    if (WRM && WRM.data) {
        tipWRMData = WRM.data.claim("com.atlassian.plugins.helptips.jira-help-tips:common.JiraHelpTipData");
    }

    var Manager = {
        dismissedTipIds: [],
        sequences: [],
        loaded: $.Deferred(),
        url: function() { return restUrl; },
        sync: function(verb, data) {
            var result = $.Deferred();
            verb || (verb = "get");
            data || (data = null);
            if (verb === "get" && tipWRMData && tipWRMData.dismissed) {
                result.resolve(tipWRMData.dismissed);
            } else {
                $.ajax(this.url(), {
                    type: verb,
                    dataType: "json",
                    contentType: "application/json",
                    data: data && JSON.stringify(data),
                    processData: false
                })
                    .done(function(data) {
                        result.resolve(data);
                    })
                    .fail(function() {
                        result.reject();
                    });
            }
            return result.promise();
        },
        fetch: function() {
            var result = this.sync();
            result.done($.proxy(function(response) {
                $.merge(this.dismissedTipIds, response);
                this.loaded.resolve();
            }, this));
            return result.promise();
        },
        show: function(showFunction) {
            this.loaded.done(showFunction);
        },
        dismiss: function(tip) {
            var id = tip.attributes.id;
            if (!id) {
                tip._dismissed = true;
            } else {
                this.dismissedTipIds.push(id);
                this.sync("post", {id:id});
            }
        },
        undismiss: function(tip) {
            var id = tip.attributes.id;
            if (!id) {
                tip._dismissed = false;
            } else {
                this.dismissedTipIds.splice($.inArray(id, this.dismissedTipIds), 1);
                this.sync("delete", {id:id});
            }
        },
        isDismissed: function(tip) {
            var id = tip.attributes.id;
            return (id) ? $.inArray(id, this.dismissedTipIds) >= 0 : tip._dismissed;
        },
        /**
         * Clear the list of helptips that would be shown in sequence
         */
        clearSequences: function() {
            this.sequences = [];
        },
        /**
         * Hide all the helptips that would be shown in sequence
         */
        hideSequences: function() {
            _.each(this.sequences, function(helptip) {
                helptip.view.dismiss();
            });
        },
        /**
         * Initiate the rendering of helptips in sequence starting from the first one
         */
        showSequences: function() {
            if (!this._showStarted) {
                var instance = this;
                var index = 0;
                this._showStarted = true;
                $.when(this.loaded).done(function() {
                    //Sort by weight
                    instance.sequences.sort(function(a, b) {
                        return a.attributes.weight - b.attributes.weight;
                    });
                    //Remove any helptips that have already been dismissed
                    instance.sequences = _.filter(instance.sequences, function(dialog) {
                        var shouldShow = _.indexOf(instance.dismissedTipIds, dialog.attributes.id) === -1;
                        if (shouldShow) {
                            dialog.attributes.position = index++;
                        }
                        return shouldShow;
                    });
                    if (instance.sequences.length > 0) {
                        //SW-1740: Ensure the last tip part of a sequence always shows the close button. Filtering out already dismissed
                        // tips above may have changed the original last tip.
                        _.last(instance.sequences).attributes.showCloseButton = true;

                        instance.sequences[0].show({force: true});
                    }
                    instance._showStarted = false;
                });
            }
        }
    };

    // Check if the user is logged in, otherwise the REST resource will return a status of 401 (Unauthorized)
    if (!JIRA.Users.LoggedInUser.isAnonymous()) {
        AJS.HelpTip.Manager = Manager;
        // Load up the user's dismissed tips.
        Manager.fetch();
    }
})(AJS.$);;
;
/* module-key = 'com.atlassian.plugins.helptips.jira-help-tips:common', location = 'templates/HelpTip.soy' */
// This file was automatically generated from HelpTip.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace AJS.Templates.HelpTip.
 */

if (typeof AJS == 'undefined') { var AJS = {}; }
if (typeof AJS.Templates == 'undefined') { AJS.Templates = {}; }
if (typeof AJS.Templates.HelpTip == 'undefined') { AJS.Templates.HelpTip = {}; }


AJS.Templates.HelpTip.tipContent = function(opt_data, opt_ignored) {
  return ((opt_data.title) ? '<h2 class="helptip-title">' + soy.$$escapeHtml(opt_data.title) + '</h2>' : '') + '<p class="helptip-body">' + soy.$$filterNoAutoescape(opt_data.bodyHtml) + '</p>' + ((opt_data.url) ? '<p><a class="helptip-link" href="' + soy.$$escapeHtml(opt_data.url) + '" target="_blank">' + ((opt_data.linkText) ? soy.$$escapeHtml(opt_data.linkText) : soy.$$escapeHtml("Learn more")) + '</a></p>' : '') + AJS.Templates.HelpTip.tipFooter(opt_data);
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.tipContent.soyTemplateName = 'AJS.Templates.HelpTip.tipContent';
}


AJS.Templates.HelpTip.tipFooter = function(opt_data, opt_ignored) {
  return '<form class="tip-footer">' + AJS.Templates.HelpTip.nextButton(opt_data) + AJS.Templates.HelpTip.closeButton(opt_data) + AJS.Templates.HelpTip.sequencePaging(opt_data) + '</form>';
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.tipFooter.soyTemplateName = 'AJS.Templates.HelpTip.tipFooter';
}


AJS.Templates.HelpTip.nextButton = function(opt_data, opt_ignored) {
  return '' + ((opt_data.showNextButton) ? '<button class="aui-button helptip-next" type="button">' + ((opt_data.nextButtonText) ? soy.$$escapeHtml(opt_data.nextButtonText) : soy.$$escapeHtml("Next")) + '</button>' : '');
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.nextButton.soyTemplateName = 'AJS.Templates.HelpTip.nextButton';
}


AJS.Templates.HelpTip.closeButton = function(opt_data, opt_ignored) {
  return '' + ((opt_data.showCloseButton) ? '<button class="aui-button ' + ((opt_data.showNextButton) ? ' aui-button-link ' : '') + ' helptip-close" type="button">' + ((opt_data.closeButtonText) ? soy.$$escapeHtml(opt_data.closeButtonText) : soy.$$escapeHtml("Close")) + '</button>' : '');
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.closeButton.soyTemplateName = 'AJS.Templates.HelpTip.closeButton';
}


AJS.Templates.HelpTip.sequencePaging = function(opt_data, opt_ignored) {
  return '' + ((opt_data.isSequence && opt_data.length > 1) ? '<span class="helptip-sequence-paging">' + soy.$$escapeHtml(opt_data.position + 1) + '/' + soy.$$escapeHtml(opt_data.length) + '</span>' : '');
};
if (goog.DEBUG) {
  AJS.Templates.HelpTip.sequencePaging.soyTemplateName = 'AJS.Templates.HelpTip.sequencePaging';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:newsletter-signup-tip', location = 'static/components/newsletter/NewsletterSignup.soy' */
// This file was automatically generated from NewsletterSignup.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }


JIRA.Templates.newsletterSignupTip = function(opt_data, opt_ignored) {
  return '<div><p>' + soy.$$escapeHtml(opt_data.description) + '</p>' + aui.form.form({action: '#', isTopLabels: true, extraClasses: 'insiders-signup-form', content: '' + aui.form.textField({id: 'jira-newsletter-user-email', placeholderText: '' + soy.$$escapeHtml("Email address"), value: opt_data.userEmail}) + aui.form.buttons({content: '' + aui.form.submit({type: 'primary', text: '' + soy.$$filterNoAutoescape("Sign me up")}) + aui.form.linkButton({text: '' + soy.$$escapeHtml("No thanks")})})}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.newsletterSignupTip.soyTemplateName = 'JIRA.Templates.newsletterSignupTip';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:newsletter-signup-tip', location = 'static/components/newsletter/NewsletterSignup.js' */
define('jira/newsletter/signuptip', [
    'jquery'
], function(
    $
) {

    // taken from setup-mac-util.js
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address without &
    var emailRegex = /^[a-zA-Z0-9.!#$%'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

    function validateEmail(email) {
        if (email.length > 255) {
            return false;
        }
        return emailRegex.test(email);
    }

    return {
        render : function (newsletterFormDetails, helpTipOptions) {
            var defaults = {
                anchor: "#user-options",
                isSequence: false,
                showCloseButton: false
            };

            if (newsletterFormDetails.isBusinessOnly) {
                defaults.id = "business-newsletter-signup-tip";
                defaults.title = "Atlassian for Business Teams";
                defaults.bodyHtml = JIRA.Templates.newsletterSignupTip({
                    userEmail: newsletterFormDetails.userEmail,
                    description: "Atlassian gets down to business. Get our view on productivity for business teams. You\'ll get business-related content, best practices and product announcements to unleash the potential in your marketing, HR, finance, legal and sales teams."
                });
            } else {
                defaults.id = "newsletter-signup-tip";
                defaults.title = "JIRA Insiders";
                defaults.bodyHtml = JIRA.Templates.newsletterSignupTip({
                    userEmail: newsletterFormDetails.userEmail,
                    description: "Stay up-to-date with the latest JIRA tips, tricks, and exclusive inside jokes. All this and more in JIRA Insiders, delivered every month from our inbox to yours."
                });
            }
            var tip = new AJS.HelpTip($.extend(defaults, helpTipOptions));
            if(tip.isDismissed()) {
                return;
            }

            tip.show();

            AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.shown" });

            var $body = $("body");
            $body.on("submit", "form.aui.insiders-signup-form", function (e) {
                e.preventDefault();

                var $form = $(this);
                $form.find(".error").remove();

                var $emailInput = $form.find("#jira-newsletter-user-email");
                var email = $emailInput.val();
                if (validateEmail(email)) {
                    $.ajax({
                        type: 'POST',
                        url: AJS.format(newsletterFormDetails.formUrl, encodeURI(email)),
                        dataType: 'json'
                    }).success(function() {
                        AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.submitted" });
                    }).error(function(xhr) {
                        AJS.trigger('analyticsEvent', {
                            name: "jira.newsletter.signuptip.error",
                            data: {
                                statusCode: xhr.status
                            }
                        });
                    });

                    if(newsletterFormDetails.userEmail !== email) {
                        AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.email.changed" });
                    }

                    tip.dismiss("newslettersubscribed");
                }
                else {
                    AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.email.validationerror" });
                    $emailInput.after(aui.form.fieldError({message: "Please enter a valid e-mail address."}));
                }
            });

            $body.on("click", "form.aui.insiders-signup-form a.cancel", function (e) {
                e.preventDefault();
                AJS.trigger('analyticsEvent', { name: "jira.newsletter.signuptip.dismissed" });
                tip.dismiss("newslettercancelled");
            });
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:newsletter-signup-tip', location = 'static/components/newsletter/initNewsletterSignup.js' */
define('jira/newsletter/init-signup', [
    'jira/newsletter/signuptip'
], function (NewsletterSignup) {
    return function () {
        var newsletterSignupData = WRM.data.claim("com.atlassian.jira.jira-header-plugin:newsletter-signup-tip.newsletterSignup");

        if (newsletterSignupData && newsletterSignupData.showNewsletterTip) {
            NewsletterSignup.render({
                userEmail: newsletterSignupData.userEmail,
                formUrl: newsletterSignupData.formUrl,
                isBusinessOnly: newsletterSignupData.isBusinessOnly
            });
        }
    };
});

require([
    'jquery',
    'jira/newsletter/init-signup'
], function ($,
    InitNewsletterSignup) {
    $(InitNewsletterSignup);
});

;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/dialog.js' */
define('jira/admin-helper/dialog', [
    'jquery',
    'jira/dialog/dialog',
    'jira/focus/set-focus'
], function (
    $,
    Dialog,
    setFocus
) {

    return Dialog.extend({

        _getDefaultOptions: function () {
            return $.extend(this._super(), {
                cached: false,
                widthClass: "large",
                stacked: true
            });
        },

        defineResources: function() {
            this._super();
            this.requireResource("com.atlassian.jira.plugins.jira-admin-helper-plugin:whereismycf-resources");
        },

        decorateContent: function () {

            var instance = this;

            // init the close link
            this.get$popupContent().find(".cancel").click(function (e) {
                instance.hide();
                e.preventDefault();
            });
        },

        _onShowContent: function () {
            this._super();
            if (Dialog.current === this) {
                var triggerConfig = new setFocus.FocusConfiguration();
                triggerConfig.context = this.get$popup()[0];
                triggerConfig.parentElementSelectors = ['.form-body'];
                setFocus.pushConfiguration(triggerConfig);
                setFocus.triggerFocus();
            }
        },

        hide: function (undim) {

            if (this._super(undim) === false) {
                return false;
            }
            setFocus.popConfiguration();
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/notification-helper-init.js' */
require([
    'jquery',
    'jira/admin-helper/dialog',
    'jira/util/data/meta'
], function (
    $,
    Dialog,
    Meta
) {
    if (Meta.get("is-admin")) {

        $(document).delegate(".notificationhelper-trigger", "click", function (event) {
            event.preventDefault();
            new Dialog({
                id: "notification-helper-dialog",
                content: function content(callback) {
                    var dialog = this;
                    require(['jira/admin-helper/notification-helper/content-loader'],
                        function (ContentLoader) {
                            ContentLoader.loadContent(dialog, callback);
                        });
                }
            }).show();
        });
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/permission-helper-init.js' */
require([
    'jquery',
    'jira/admin-helper/dialog',
    'jira/util/data/meta'
], function (
    $,
    Dialog,
    Meta
) {
    if (Meta.get("is-admin")) {

        $(document).delegate(".permissionhelper-trigger", "click", function (event) {
            event.preventDefault();

            new Dialog({
                id: "permission-helper-dialog",
                content: function content(callback) {
                    var dialog = this;
                    require(['jira/admin-helper/permission-helper/content-loader'],
                        function (ContentLoader) {
                            ContentLoader.loadContent(dialog, callback);
                        });
                }
            }).show();
        });
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-admin-helper-plugin:dialog-resources', location = 'js/whereismycf-init.js' */
require([
    'jquery',
    'jira/admin-helper/dialog',
    'jira/util/data/meta',
    'jira/dialog/dialog'
], function (
    $,
    Dialog,
    Meta,
    JiraDialog
) {
    if (Meta.get("is-admin")) {
        var LABEL = "Where is my field?";

        $(document).delegate(".whereismycf-trigger", "click", function (event) {
            event.preventDefault();
            new Dialog({
                id: "whereismycf-dialog",
                content: function content(callback) {
                    var dialog = this;
                    require(['jira/admin-helper/whereismycf/content-loader'],
                        function (ContentLoader) {
                            ContentLoader.loadContentForView(dialog, callback);
                        });
                }
            }).show();

        });
        // hook into the quick-edit
        $(document).bind("showLayer", function (event, control, hash) {
            if (control == "inlineDialog" && hash.popup.attr("id") == "inline-dialog-field_picker_popup") {
                if (hash.popup.find(".whereismycf-qfpicker-link").length == 0) {
                    var thelink = $("<a href='#' class='whereismycf-qfpicker-link'>" + LABEL + "</a>").appendTo(hash.popup.find(".qf-picker-header dl"));
                    thelink.click(function (event) {
                        event.preventDefault();
                        hash.hide();
                        eventsAndDecouplingInJavaScriptAreSoooAwesome();
                        var currentDialog = JiraDialog.current;
                        new Dialog({
                            id: "whereismycf-dialog",
                            content: function content(callback) {
                                var dialog = this;
                                require(['jira/admin-helper/whereismycf/content-loader'],
                                    function (ContentLoader) {
                                        ContentLoader.loadContentForEditAndCreate(dialog, currentDialog, callback);
                                    });
                            }
                        }).show();

                    });
                }
            }
        });

        function eventsAndDecouplingInJavaScriptAreSoooAwesome() {
            // we're doing this because LayerManager wants to outsmart the world by deciding what to hide and what not...
            // and InlineDialog (and everything else in AUI) wants to outsmart the world by applying stupid timeouts to everything...
            // but ultimately you can outsmart every smartass in the JS land just by setting global variables to null! BUAHAHAHAHAHAHA
            AJS.InlineDialog.current = null;
        }
    }
});;
;
/* module-key = 'com.atlassian.jira-core-project-templates:jira-core-project-templates-resources', location = '/soy/CoreProjectTemplates.soy' */
// This file was automatically generated from CoreProjectTemplates.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ProjectTemplates.CoreTemplates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ProjectTemplates == 'undefined') { JIRA.Templates.ProjectTemplates = {}; }
if (typeof JIRA.Templates.ProjectTemplates.CoreTemplates == 'undefined') { JIRA.Templates.ProjectTemplates.CoreTemplates = {}; }


JIRA.Templates.ProjectTemplates.CoreTemplates.taskManagementInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Create simple tasks, organize them and get them done. You can use this project to manage your tasks or assign them to someone else.", projectTemplate: 'taskManagement'});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.taskManagementInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.taskManagementInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.projectManagementInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Create your tasks, organize and track their progress, and deliver your work on time. Estimations and time tracking allow you to report on where your project is at any stage.", projectTemplate: 'projectManagement'});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.projectManagementInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.projectManagementInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.processManagementInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Create your tasks and track them at every step, from start to finish. You can use this project to review documentation, approve expenses, or other processes.", projectTemplate: 'processManagement'});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.processManagementInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.processManagementInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.boardBetaInfoDialog = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog({description: "Visualize work across your team with a board.", projectTemplate: 'projectManagement', issueTypesHtml: '' + JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType(null)});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.boardBetaInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.boardBetaInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog = function(opt_data, opt_ignored) {
  return '<div><div class="top-panel"><p>' + soy.$$escapeHtml(opt_data.description) + '</p></div><div class="left-panel"><h6>' + soy.$$escapeHtml("Issue Types") + '</h6><ul class="project-template-issuetype-list">' + ((opt_data.issueTypesHtml != null) ? soy.$$filterNoAutoescape(opt_data.issueTypesHtml) : JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType(null) + JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType(null)) + '</ul></div><div class="right-panel"><h6>' + soy.$$escapeHtml("Workflow") + '</h6><div class="workflow ' + soy.$$escapeHtml(opt_data.projectTemplate) + '"></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.templateInfoDialog';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.issueType = function(opt_data, opt_ignored) {
  return '<li><span class="issuetype-list-label"><span class="issuetype-icon ' + soy.$$escapeHtml(opt_data.iconKey) + '"></span><span class="issuetype-name">' + soy.$$escapeHtml(opt_data.label) + '</span></span></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.issueType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.issueType';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.issueType({iconKey: 'task', label: "Task"});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.taskIssueType';
}


JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.ProjectTemplates.CoreTemplates.issueType({iconKey: 'subtask', label: "Sub-task"});
};
if (goog.DEBUG) {
  JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType.soyTemplateName = 'JIRA.Templates.ProjectTemplates.CoreTemplates.subtaskIssueType';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-confluence-plugin:issue-link-confluence-js', location = 'js/issuelink-confluence.js' */
/**
 * Initialises OAuth authentication for Confluence Application Links. Requires the following elements:
 * <div class="issue-link-applinks-authentication-message"></div>
 */
(function ($) {

    var settings = {
        getCurrentAppId: function (context) {
            return $("#issue-link-confluence-app-id", context).val();
        },
        shouldExecute: function (context) {
            return $("#confluence-page-link", context).length !== 0;
        },
        getIssueId: function (context) {
            return $("input[name=id]", context).val();
        }
    };

    JIRA.bind(JIRA.Events.NEW_PAGE_ADDED, function (e, context) {
        IssueLinkAppLinks.init(settings, context);
    });

})(AJS.$);;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-confluence-plugin:confluence-page-resource', location = 'js/ConfluencePageSearch.js' */
AJS.$(function ($) {
    var confluenceSearchDialog =  new JIRA.FormDialog({
        id: "confluence-page-search-dialog",
        trigger: "#confluence-page-link .confluence-search-trigger",
        widthClass: "large",
        height: "565px",
        content: function (render) {
            var dialog = this;
            JIRA.SmartAjax.makeRequest({
                url: contextPath + "/rest/confluenceIssueLink/1/confluence/applink",
                complete: function (xhr, textStatus, smartAjaxResult) {
                    if (smartAjaxResult.successful) {
                        var appLinks = smartAjaxResult.data.applicationLinks;
                        render(JIRA.Templates.ConfluencePageSearch.result({appLinks: appLinks}));

                        initAppLinks(dialog).done(function (context, helper) {
                            initSearchDialog(context, helper);
                            $("#link-search-text", context).focus();
                        });
                    } else {
                        AJS.messages.error("#search-results-table", {
                            body: "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.",
                            closeable: false
                        });
                        render();
                    }
                }
            });
        },
        submitHandler: function(e, callback){
            e.preventDefault();
            $("#search-panel-button").click().removeAttr("disabled");
            callback();
        }
    });

    function initSearchDialog($dialog, helper) {
        // Bind the select drop-down
        $("#confluence-app-link", $dialog).change(function () {
            var authenticationRequired = helper.selectServer($(this).val()).authenticationRequired;
            if (!authenticationRequired) {
                populateSpaces($dialog, $(this).val(), helper);
            }
            $("#search-results-table", $dialog).empty();

            // Any previous errors are not relevant to our new selection
            setSearchControlsEnabled(true, $dialog);
        });

        // Bind the search button
        $("#search-panel-button", $dialog).click(function () {
            $("#search-results-table", $dialog).empty();
            var searchText = $("#link-search-text", $dialog).val();
            searchText = $.trim(searchText);
            if (searchText) {
                doSearch(searchText, $dialog);
            } else {
                AJS.messages.info("#search-results-table", {
                    body: "Please enter search value.",
                    closeable: false
                });
            }

            return false;
        });
    }

    var spaceAjaxId = 0;
    function populateSpaces($context, appId, helper) {
        $("select#search-panel-space", $context).html(JIRA.Templates.ConfluencePageSearch.allSpacesOption());
        var myAjaxId = ++spaceAjaxId;
        JIRA.SmartAjax.makeRequest({
            url: contextPath + "/rest/confluenceIssueLink/1/confluence/space?appId=" + appId,
            complete: function (xhr, textStatus, smartAjaxResult) {
                if (myAjaxId !== spaceAjaxId) {
                    return;
                }
                if (smartAjaxResult.successful) {
                    var spaces = smartAjaxResult.data.spaces;
                    $("select#search-panel-space", $context).html(JIRA.Templates.ConfluencePageSearch.spaceOptions({spaces: spaces}));
                } else {
                    if (smartAjaxResult.status === 401) {
                        helper.setAuthenticationRequired(appId, true);
                    } else {
                        // Since we have an error, prevent the user from submitting a search
                        setSearchControlsEnabled(false, $context);

                        var msg;
                        if (smartAjaxResult.status === 403) {
                            msg = "Content on the Confluence site could not be accessed because the Confluence server\'s \'Remote API\' feature is disabled. The Confluence system administrator must enable this \'Remote API\' feature for JIRA to successfully access this content.";
                        } else {
                            msg = "Unable to gather information from the selected Confluence instance.";
                        }
                        AJS.messages.error("#search-results-table", {
                            body: msg,
                            closeable: false
                        });
                    }
                }
            }
        });
    }

    function setSearchControlsEnabled(enabled, $context) {
        if (enabled) {
            $("#link-search-text", $context).removeAttr("disabled");
            $("#search-panel-space", $context).removeAttr("disabled");
            $("#search-panel-button", $context).removeAttr("disabled");
        } else {
            $("#link-search-text", $context).attr("disabled", "disabled");
            $("#search-panel-space", $context).attr("disabled", "disabled");
            $("#search-panel-button", $context).attr("disabled", "disabled");
        }
    }

    function setLoadingIconVisible(visible, $context) {
        $("#link-search-loading", $context).toggleClass("hidden", !visible);
    }

    function doSearch(searchText, $context) {
        setLoadingIconVisible(true, $context);
        var appLinkId = $("#confluence-app-link", $context).val();
        var spaceKey = $("#search-panel-space option:selected", $context).val();
        JIRA.SmartAjax.makeRequest({
            url: contextPath + "/rest/confluenceIssueLink/1/confluence/search?query=" + searchText + "&appId=" + appLinkId + "&spaceKey=" + spaceKey + "&maxResults=10",
            complete: function (xhr, textStatus, smartAjaxResult) {
                setLoadingIconVisible(false, $context);
                if (smartAjaxResult.successful) {
                    var results = smartAjaxResult.data.result;
                    var resultHtml = JIRA.Templates.ConfluencePageSearch.resultsTable({results: results});
                    $("#search-results-table", $context).html(resultHtml);
                } else {
                    // This replicates the JIRA.SmartAjax.buildSimpleErrorContent method, but we can't use that because
                    // it mentions a JIRA instance.
                    var msg;
                    if (smartAjaxResult.hasData) {
                        msg = "The JIRA server was contacted but has returned an error response. We are unsure of the result of this operation.";
                    } else {
                        msg = "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.";
                    }
                    AJS.messages.error("#search-results-table", {
                        body: msg,
                        closeable: false
                    });
                }

                $("#confluence-searchresult tbody tr", $context).click(function () {
                    var linkUrl = $(this).children().first().data("url");
                    $("#confluence-page-url").val(linkUrl);

        ////        If we want to display the title in the 'description' area on the main dialog
        ////        var linkTitle = $(this).children().first().text();
        ////        $("#confluence-page-url").siblings(".description").text(linkTitle);

                    // Clear all error messages on the parent dialog, as we now have a newly selected URL
                    $("#link-issue-dialog .error").hide();

                    confluenceSearchDialog.hide();
                    $("#link-issue-dialog").show();
                    $("#confluence-page-url").focus().select();
                });
            }
        });
    }

    function initAppLinks(dialog) {
        var settings = {
            getCurrentAppId: function (context) {
                return $("#confluence-app-link", context).val();
            },
            shouldExecute: function (context) {
                return $("#confluence-app-link", context).length !== 0;
            },
            onAuthenticationSuccessCallback: function (context, currentAppId, helper) {
                populateSpaces(context, currentAppId, helper);
            },
            getIssueId: function (context) {
                return $("#confluence-page-link input[name=id]").val();
            }
        };

        return IssueLinkAppLinks.init(settings, dialog.$popup).done(function (context, helper) {
            populateSpaces(context, settings.getCurrentAppId(context), helper);
        });
    }
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-link-confluence-plugin:confluence-page-resource', location = 'templates/dialog/searchresult.soy' */
// This file was automatically generated from searchresult.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.ConfluencePageSearch.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.ConfluencePageSearch == 'undefined') { JIRA.Templates.ConfluencePageSearch = {}; }


JIRA.Templates.ConfluencePageSearch.result = function(opt_data, opt_ignored) {
  var output = '<h2>' + soy.$$escapeHtml("Find a Confluence page") + '</h2><form class="aui search-form" id="confluence-page-search-form" action="#" method="post"><div class="field-group"><label for="confluence-app-link">' + soy.$$escapeHtml("Server") + ':</label>';
  if (opt_data.appLinks.length == 1) {
    output += '<span class="field-value">' + soy.$$escapeHtml(opt_data.appLinks[0].name) + '</span><input id="confluence-app-link" class="hidden" type="hidden" name="appId" value="' + soy.$$escapeHtml(opt_data.appLinks[0].id) + '"/>';
  } else {
    output += '<select id="confluence-app-link" class="select medium-field" name="appId">';
    var appLinkList17 = opt_data.appLinks;
    var appLinkListLen17 = appLinkList17.length;
    for (var appLinkIndex17 = 0; appLinkIndex17 < appLinkListLen17; appLinkIndex17++) {
      var appLinkData17 = appLinkList17[appLinkIndex17];
      output += '<option value="' + soy.$$escapeHtml(appLinkData17.id) + '">' + soy.$$escapeHtml(appLinkData17.name) + '</option>';
    }
    output += '</select>';
  }
  output += '</div><div class="issue-link-applinks-authentication-message applinks-message-bar"></div><div class="hidden"><input class="issue-link-applinks-application-type" type="hidden" value="com.atlassian.applinks.api.application.confluence.ConfluenceApplicationType"/></div><div class="issue-link-oauth-toggle field-group"><label for="link-search-text" id="linkSearch-label">' + soy.$$escapeHtml("Search") + ':</label><input id="link-search-text" type="text" tabindex="0" class="text" name="linkSearch" size="50" /> <select tabindex="0" class="search-space select" id="search-panel-space"><option value="">' + soy.$$escapeHtml("All Spaces") + '</option></select> <input type="submit" tabindex="0" class="aui-button" id="search-panel-button" value="' + soy.$$escapeHtml("Search") + '"/><span id="link-search-loading" class="icon loading throbber hidden"/></div><div class="message-panel hidden"></div><div id="search-results-table" class="data-table"></div><div class="buttons-container form-footer"><div class="buttons"><button class="aui-button aui-button-link cancel" id="confluence-link-cancel" title="' + soy.$$escapeHtml("Press Esc to close") + '">' + soy.$$escapeHtml("Close") + '</button></div></div></form>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.result.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.result';
}


JIRA.Templates.ConfluencePageSearch.resultsTable = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.results.length > 0) {
    output += '<table id="confluence-searchresult" class="aui"><thead><tr><th width="180px">' + soy.$$escapeHtml("Title") + '</th><th width="550px">' + soy.$$escapeHtml("Excerpt") + '</th></tr></thead><tbody>';
    var resultList44 = opt_data.results;
    var resultListLen44 = resultList44.length;
    for (var resultIndex44 = 0; resultIndex44 < resultListLen44; resultIndex44++) {
      var resultData44 = resultList44[resultIndex44];
      output += '<tr title="' + soy.$$escapeHtml(resultData44.title) + '"><td class="title" data-url="' + soy.$$escapeHtml(resultData44.url) + '">' + soy.$$escapeHtml(resultData44.title) + '</td><td class="excerpt">' + soy.$$escapeHtml(resultData44.excerpt) + '</td></tr>';
    }
    output += '</tbody></table>';
  } else {
    output += '<div class="aui-message info"><span class="aui-icon icon-info"></span><p>' + soy.$$escapeHtml("Search returned no results.") + '</p></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.resultsTable.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.resultsTable';
}


JIRA.Templates.ConfluencePageSearch.spaceOptions = function(opt_data, opt_ignored) {
  var output = '<option value="">' + soy.$$escapeHtml("All Spaces") + '</option>';
  var spaceList64 = opt_data.spaces;
  var spaceListLen64 = spaceList64.length;
  for (var spaceIndex64 = 0; spaceIndex64 < spaceListLen64; spaceIndex64++) {
    var spaceData64 = spaceList64[spaceIndex64];
    output += '<option value="' + soy.$$escapeHtml(spaceData64.key) + '">' + soy.$$escapeHtml(spaceData64.name) + '</option>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.spaceOptions.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.spaceOptions';
}


JIRA.Templates.ConfluencePageSearch.allSpacesOption = function(opt_data, opt_ignored) {
  return '<option value="">' + soy.$$escapeHtml("All Spaces") + '</option><option value="" disabled="disabled">' + soy.$$escapeHtml("Loading...") + '</option>';
};
if (goog.DEBUG) {
  JIRA.Templates.ConfluencePageSearch.allSpacesOption.soyTemplateName = 'JIRA.Templates.ConfluencePageSearch.allSpacesOption';
}
;
;
/* module-key = 'com.atlassian.administration.atlassian-admin-quicksearch-jira:admin-quicksearch-webresources', location = 'com/atlassian/administration/quicksearch/jira/js/adminQuickNav.js' */
/**
 * Shifter group for admin search
 */
require([
    'jquery',
    'underscore',
    'jira/ajs/ajax/smart-ajax',
    'jira/shifter',
    'wrm/context-path'
], function (jQuery,
             _,
             SmartAjax,
             Shifter,
             contextPath) {
    Shifter.register(function () {
        var suggestionsDeferred = jQuery.Deferred();

        function formatItem(item) {
            return {
                label: item.label,
                value: item.linkUrl,
                keywords: item.aliases
            };
        }

        function getItemsInSection(section) {
            return _.map(section.items, formatItem).concat(_.map(section.sections, getItemsInSection));
        }

        function formatResponse(data) {
            return _.flatten(getItemsInSection(data));
        }

        SmartAjax.makeRequest({
            dataType: 'json',
            url: contextPath() + '/rest/adminquicksearch/latest/links/default'
        })
            .pipe(formatResponse)
            .done(function (suggestions) {
                suggestionsDeferred.resolve(suggestions);
            })
            .fail(function () {
                suggestionsDeferred.reject();
            });

        return {
            id: 'admin',
            name: "Administration",
            weight: 500,
            getSuggestions: function () {
                return suggestionsDeferred;
            },
            onSelection: function (value) {
                window.location = value;
                return jQuery.Deferred();
            }
        };
    });
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-browser-metrics:sensors', location = 'sensors.js' */
require(["internal/browser-metrics", "jira/util/events"], function (internal_browser_metrics, jira_util_events) {
var sensors_application_menus = {}, sensors_util_safe_dialog_id = {}, sensors_dialogs = {}, sensors = {};
sensors_application_menus = function (exports, Events, metrics) {
  function init() {
    var KEYS = {
      'bonfire_top_menu_dropdown-content': 'jira.header.menu.capture',
      'browse_link-content': 'jira.header.menu.projects',
      'find_link-content': 'jira.header.menu.issues',
      'greenhopper_menu-content': 'jira.header.menu.agile',
      'home_link-content': 'jira.header.menu.dashboards',
      'plugins-jira-webitem-main-content': 'jira.header.menu.portfolio',
      'servicedesk-section-content': 'jira.header.menu.service-desk',
      'system-admin-menu-content': 'jira.header.menu.admin',
      'system-help-menu-content': 'jira.header.menu.help',
      'user-options-content': 'jira.header.menu.profile'
    };
    function getKey(dropdownId) {
      return KEYS.hasOwnProperty(dropdownId) ? KEYS[dropdownId] : null;
    }
    Events.bind('aui-dropdown2-show-before', function (event) {
      var target = event.target;
      var key = getKey(target && target.id);
      if (key) {
        metrics.start({
          key: key,
          isInitial: false,
          threshold: 250
        });
      }
    });
    Events.bind('aui-dropdown2-show-after', function (event) {
      var target = event.target;
      var key = getKey(target && target.id);
      if (key) {
        metrics.end({ key: key });
      }
    });
  }
  exports.init = init;
  return exports;
}(sensors_application_menus, jira_util_events, internal_browser_metrics);
sensors_util_safe_dialog_id = function (exports) {
  var SAFE_DIALOG_IDS = [
    'about-dialog',
    'add-basicuser-dialog',
    'add-developer-dialog',
    'add-field-configuration-dialog',
    'add-field-configuration-scheme-dialog',
    'add-field-dialog',
    'add-field-screen-dialog',
    'add-field-screen-scheme-dialog',
    'add-incoming-mail-handler-dialog',
    'add-issue-type-dialog',
    'add-issue-type-field-configuration-association-dialog',
    'add-issue-type-screen-scheme-configuration-association-dialog',
    'add-issue-type-screen-scheme-dialog',
    'add-new-issue-type-to-scheme-dialog',
    'add-screen-scheme-item-dialog',
    'add-subtask-type-dialog',
    'add-workflow-dialog',
    'add_workflowscheme-dialog',
    'assign-dialog',
    'assign-issue-types-dialog',
    'assign-to-me-link-handler',
    'attach-file-dialog',
    'attach-screenshot-dialog',
    'auditing-settings-dialog',
    'clone-issue-dialog',
    'comment-add-dialog',
    'configure_wallboard_dialog',
    'confluence-page-search-dialog',
    'copy_classic default workflow-dialog',
    'copy-filter-dialog',
    'copy_jira-dialog',
    'create-issue-dialog',
    'create-issue-dialog.issueType',
    'create-issue-dialog.projectId',
    'create-request-dialog',
    'create-service-desk-dialog',
    'create-status-dialog',
    'create-story-dialog',
    'create-story-dialog.issueType',
    'create-story-dialog.projectId',
    'create-subtask-dialog',
    'create-subtask-dialog.issueType',
    'create-team-dialog',
    'create_user-dialog',
    'credits-dialog',
    'delete-attachment-dialog',
    'delete-comment-dialog',
    'delete-dshboard',
    'delete-filter-dialog',
    'delete-issue-dialog',
    'delete-issue-link-dialog',
    'delete-log-work-dialog',
    'delete-metric',
    'delete-queue',
    'delete-status-dialog',
    'deleteuser_link-dialog',
    'devstatus-branch-detail-dialog',
    'devstatus-build-detail-dialog',
    'devstatus-commit-detail-dialog',
    'devstatus-cta-dialog',
    'devstatus-deployment-detail-dialog',
    'devstatus-pullrequest-detail-dialog',
    'devstatus-review-detail-dialog',
    'discard-draft-dialog',
    'discard_draft_workflow-dialog',
    'edit-attachments-dialog',
    'edit-comment',
    'editgroups_admin-dialog',
    'editgroups_link-dialog',
    'editgroups_sysadmin-dialog',
    'edit-issue-dialog',
    'edit-labels-dialog',
    'edit-log-work-dialog',
    'edit-status-dialog',
    'edituser_link_admin-dialog',
    'edit-workflow-dialog',
    'gh-rapidboard-dialog',
    'inline-issue-create-dialog',
    'invite_user-dialog',
    'issue-actions-dialog',
    'issue-tab-error-dialog',
    'jim-create-project-dialog',
    'keyboard-shortcuts-dialog',
    'link-issue-dialog',
    'log-work-dialog',
    'manage-attachment-dialog',
    'metric-pre-save-dialog',
    'modal-field-view',
    'permission-helper-dialog',
    'project-avatar-cropper',
    'project-avatar-picker',
    'project-config-details-project-category-dialog',
    'project-config-project-edit-dialog',
    'project-config-project-edit-lead-and-default-assignee-dialog',
    'project-email-dialog',
    'publish_draft_workflow-dialog',
    'queue-dirty-edits',
    'QuickCreateIssue.error',
    'QuickCreateIssue.success',
    'QuickCreateSubtask.error',
    'QuickCreateSubtask.success',
    'QuickEdit.error',
    'QuickEdit.success',
    'remote-jira-search-dialog',
    'rename-filter-dialog',
    'report-dirty-edits',
    'save-filter-dialog',
    'sd-add-default-value',
    'sd-add-remove-agent-dialog',
    'sd-remove-field-dialog',
    'server-error-dialog',
    'report-delete-confirm',
    'tempo-add-hours-issue-dialog',
    'tempo-add-internal-activity-form',
    'tempo-core-medium-form',
    'tempo-delete-form-dialog',
    'tempo-grace-form',
    'tempo-large-form',
    'tempo-medium-form',
    'tempo-move-form-dialog',
    'tempo-pdf-form',
    'tempo-small-form',
    'tempo-split-form-dialog',
    'tempo-user-settings-dialog',
    'user-avatar-picker',
    'user-defaults-edit-dialog',
    'versionsMergeDialog',
    'view-workflow-dialog',
    'view-workflow-dialog-project-admin',
    'view-workflow-dialog-workflow-schemes',
    'wait-migrate-dialog',
    'whereismycf-dialog',
    'workflow-text-view'
  ].reduce(function (previousValue, currentValue) {
    previousValue[currentValue] = true;
    return previousValue;
  }, {});
  var DIALOG_ID_NORMALISATIONS = [
    {
      dialogId: 'component-delete-dialog',
      pattern: /^component-\d+-delete-dialog$/i
    },
    {
      dialogId: 'version-delete-dialog',
      pattern: /^version-\d+-delete-dialog$/i
    },
    {
      dialogId: 'workflow-transition-dialog',
      pattern: /^workflow-transition-\d+-dialog$/i
    }
  ];
  function safeDialogId(dialogId) {
    var i;
    if (SAFE_DIALOG_IDS.hasOwnProperty(dialogId)) {
      return dialogId;
    }
    for (i = 0; i < DIALOG_ID_NORMALISATIONS.length; i++) {
      if (dialogId.match(DIALOG_ID_NORMALISATIONS[i].pattern)) {
        return DIALOG_ID_NORMALISATIONS[i].dialogId;
      }
    }
    return null;
  }
  return safeDialogId;
}(sensors_util_safe_dialog_id);
sensors_dialogs = function (exports, Events, metrics, safeDialogId) {
  function init() {
    Events.bind('beforeShow', function (event, dialogId) {
      if (typeof dialogId !== 'string') {
        return;
      }
      var key = safeDialogId(dialogId);
      if (key) {
        metrics.start({
          key: 'jira.dialog.open.' + key,
          isInitial: false,
          threshold: 1000
        });
      }
    });
    Events.bind('dialogContentReady', function (event, dialog) {
      if (typeof dialog.options.id !== 'string') {
        return;
      }
      var key = safeDialogId(dialog.options.id);
      if (key) {
        metrics.end({ key: 'jira.dialog.open.' + key });
      }
    });
  }
  exports.init = init;
  return exports;
}(sensors_dialogs, jira_util_events, internal_browser_metrics, sensors_util_safe_dialog_id);
sensors = function (exports, applicationMenusSensor, dialogsSensor) {
  applicationMenusSensor.init();
  dialogsSensor.init();
  return exports;
}(sensors, sensors_application_menus, sensors_dialogs);});
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher.soy' */
// This file was automatically generated from appswitcher.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.appswitcher.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.appswitcher == 'undefined') { navlinks.templates.appswitcher = {}; }


navlinks.templates.appswitcher.linkSection = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.list.length > 0) {
    output += '<div class="aui-nav-heading sidebar-section-header">' + soy.$$escapeHtml(opt_data.title) + '</div><ul class="aui-nav nav-links">';
    var linkList8 = opt_data.list;
    var linkListLen8 = linkList8.length;
    for (var linkIndex8 = 0; linkIndex8 < linkListLen8; linkIndex8++) {
      var linkData8 = linkList8[linkIndex8];
      output += navlinks.templates.appswitcher.applicationsItem(linkData8);
    }
    output += '</ul>';
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.linkSection.soyTemplateName = 'navlinks.templates.appswitcher.linkSection';
}


navlinks.templates.appswitcher.applicationsItem = function(opt_data, opt_ignored) {
  return '<li class="nav-link"><a href="' + soy.$$escapeHtml(opt_data.link) + '" ' + ((opt_data.self) ? 'class="checked"' : '') + ' title="' + soy.$$escapeHtml(opt_data.link) + '"><span class="nav-link-label">' + soy.$$escapeHtml(opt_data.label) + '</span></a></li>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.applicationsItem.soyTemplateName = 'navlinks.templates.appswitcher.applicationsItem';
}


navlinks.templates.appswitcher.shortcutsItem = function(opt_data, opt_ignored) {
  return '<li class="nav-link"><a href="' + soy.$$escapeHtml(opt_data.link) + '" ' + ((opt_data.self) ? 'class="checked"' : '') + ' title="' + soy.$$escapeHtml(opt_data.link) + '"><span class="nav-link-label">' + soy.$$escapeHtml(opt_data.label) + '</span>' + ((opt_data.showDescription && opt_data.description) ? '<span class="nav-link-description">' + soy.$$escapeHtml(opt_data.description) + '</span>' : '') + '</a></li>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.shortcutsItem.soyTemplateName = 'navlinks.templates.appswitcher.shortcutsItem';
}


navlinks.templates.appswitcher.error = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-error">' + soy.$$filterNoAutoescape("Something went wrong, please \x3cspan class\x3d\x22app-switcher-retry\x22\x3etry again\x3c/span\x3e.") + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.error.soyTemplateName = 'navlinks.templates.appswitcher.error';
}


navlinks.templates.appswitcher.sidebarContents = function(opt_data, opt_ignored) {
  return '<div class="aui-page-panel-nav"><nav class="aui-navgroup aui-navgroup-vertical"><div class="app-switcher-section app-switcher-applications"><div class="aui-nav-heading">' + soy.$$escapeHtml("Application Links") + '</div><div class="app-switcher-loading">' + soy.$$filterNoAutoescape("Loading\x26hellip;") + '</div></div><div class="app-switcher-section app-switcher-shortcuts"><div class="aui-nav-heading">' + soy.$$escapeHtml("Shortcuts") + '</div><div class="app-switcher-loading">' + soy.$$filterNoAutoescape("Loading\x26hellip;") + '</div></div></nav></div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.sidebarContents.soyTemplateName = 'navlinks.templates.appswitcher.sidebarContents';
}


navlinks.templates.appswitcher.trigger = function(opt_data, opt_ignored) {
  return '<span class="aui-icon aui-icon-small aui-iconfont-appswitcher">' + soy.$$escapeHtml("Linked Applications") + '</span>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.trigger.soyTemplateName = 'navlinks.templates.appswitcher.trigger';
}


navlinks.templates.appswitcher.projectHeaderSection = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-title">' + aui.avatar.avatar({size: 'large', avatarImageUrl: opt_data.avatarUrl, isProject: true, title: opt_data.name}) + '<div class="sidebar-project-name">' + soy.$$escapeHtml(opt_data.name) + '</div></div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.projectHeaderSection.soyTemplateName = 'navlinks.templates.appswitcher.projectHeaderSection';
}


navlinks.templates.appswitcher.cogDropdown = function(opt_data, opt_ignored) {
  var output = '';
  var dropdownList__soy74 = '' + navlinks.templates.appswitcher.dropdownList({list: opt_data.links});
  output += aui.dropdown2.dropdown2({menu: {id: opt_data.id, content: dropdownList__soy74, extraClasses: 'aui-style-default sidebar-customize-section'}, trigger: {showIcon: false, content: '<span class="aui-icon aui-icon-small aui-iconfont-configure"></span>', container: '#app-switcher'}});
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.cogDropdown.soyTemplateName = 'navlinks.templates.appswitcher.cogDropdown';
}


navlinks.templates.appswitcher.dropdownList = function(opt_data, opt_ignored) {
  var output = '<ul class="sidebar-admin-links">';
  var linkList82 = opt_data.list;
  var linkListLen82 = linkList82.length;
  for (var linkIndex82 = 0; linkIndex82 < linkListLen82; linkIndex82++) {
    var linkData82 = linkList82[linkIndex82];
    output += '<li class="nav-link"><a href="' + soy.$$escapeHtml(linkData82.href) + '" title="' + soy.$$escapeHtml(linkData82.title) + '"><span class="nav-link-label">' + soy.$$escapeHtml(linkData82.label) + '</span></a></li>';
  }
  output += '</ul>';
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.dropdownList.soyTemplateName = 'navlinks.templates.appswitcher.dropdownList';
}


navlinks.templates.appswitcher.switcher = function(opt_data, opt_ignored) {
  var output = '';
  if (true) {
    if (AJS.DarkFeatures.isEnabled('rotp.sidebar')) {
      var sidebarContents__soy97 = '' + navlinks.templates.appswitcher.sidebarContents(null);
      var triggerContent__soy99 = '' + navlinks.templates.appswitcher.trigger(null);
      output += navlinks.templates.appswitcher.sidebar({sidebar: {id: 'app-switcher', content: sidebarContents__soy97}, trigger: {showIcon: false, content: triggerContent__soy99}}) + '<script>\n                (function (NL) {\n                    var initialise = function () {\n                        new NL.SideBar({\n                            sidebarContents: \'#app-switcher\'\n                        });\n                    };\n                    if (NL.SideBar) {\n                        initialise();\n                    } else {\n                        NL.onInit = initialise;\n                    }\n                }(window.NL = (window.NL || {})));\n                window.NL.isUserAdmin = ' + soy.$$escapeHtml(false) + '<\/script>';
    } else {
      output += navlinks.templates.appswitcher_old.switcher(null);
    }
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.switcher.soyTemplateName = 'navlinks.templates.appswitcher.switcher';
}


navlinks.templates.appswitcher.sidebar = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtml(opt_data.sidebar.id) + '" class="sidebar-trigger app-switcher-trigger" aria-owns="' + soy.$$escapeHtml(opt_data.sidebar.id) + '" aria-haspopup="true">' + soy.$$filterNoAutoescape(opt_data.trigger.content) + '</a><div id=' + soy.$$escapeHtml(opt_data.sidebar.id) + ' class="app-switcher-sidebar aui-style-default sidebar-offscreen">' + soy.$$filterNoAutoescape(opt_data.sidebar.content) + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher.sidebar.soyTemplateName = 'navlinks.templates.appswitcher.sidebar';
}
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher.js' */
(function ($, NL) {
    NL.SideBar = function (options) {
        var that = this;
        this.$sidebar = null;

        options = $.extend({
            sidebarContents: null
        }, options);

        this.getLinks = function () {
            return $.ajax({
                url: AJS.contextPath() + '/rest/menu/latest/appswitcher',
                cache: false,
                dataType: 'json'
            }).done(this.updateAppLinks).fail(this.showAppSwitcherError);
        };

        this.populateProjectHeader = function(name, avatarUrl) {
            that.getSidebar().find('.app-switcher-shortcuts .aui-nav-heading').after(navlinks.templates.appswitcher.projectHeaderSection({
                avatarUrl: avatarUrl,
                name: name
            }));
        };

        this.getProjectData = function(){
            var $projectData = $('.project-shortcut-dialog-trigger'),
                projectKey = $projectData.data('key'),
                projectEntityType = $projectData.data('entity-type');
            // if we have no project data, we are not in a project context, so delete the shortcuts section and return.
            if ($projectData.size() == 0 || !projectKey || !projectEntityType)
            {
                $('.app-switcher-shortcuts').remove();
                return;
            }

            var remote, local;

            local = $.ajax({
                url: AJS.contextPath() + '/rest/project-shortcuts/1.0/local/' + projectKey,
                cache: false,
                data: { entityType: projectEntityType },
                dataType: 'json'
            });

            remote = $.ajax({
                url: AJS.contextPath() + '/rest/project-shortcuts/1.0/remote/' + projectKey,
                cache: false,
                data: { entityType: projectEntityType },
                dataType: 'json'
            });

            // wrap a closure around updateProjectShortcuts so we can bind projectKey
            $.when(local, remote).then(function(localData, remoteData){
                that.updateProjectShortcuts(localData, remoteData, {
                    key: projectKey,
                    entityType: projectEntityType,
                    name: $projectData.data('name'),
                    avatarUrl: $projectData.find('img').prop('src')
                });
            }, that.showProjectShortcutsError);
        }

        this.getSidebar = function () {
            if (!this.$sidebar) {
                this.$sidebar = $(options.sidebarContents);
            }
            return this.$sidebar;
        };

        this.addApplicationsCog = function ()
        {
            $('.app-switcher-applications .aui-nav-heading').before(navlinks.templates.appswitcher.cogDropdown({
                id: 'sidebar-applications-admin-dropdown',
                links: [{
                    href: AJS.contextPath() + '/plugins/servlet/customize-application-navigator',
                    label: "Customize navigator",
                    title: "Add new entries, hide existing or restrict who sees what"
                }, {
                    href: AJS.contextPath() + '/plugins/servlet/applinks/listApplicationLinks',
                    label: "Manage application links",
                    title: "Link to more Atlassian applications"
                }]
            }));
        };

        this.addProjectShortcutsCog = function (projectKey, entityType)
        {
            var links = [{
                href: AJS.contextPath() + '/plugins/servlet/custom-content-links-admin?entityKey=' + projectKey,
                label: "Customize shortcuts",
                title: ""
            }];

            if (that.entityMappings[entityType]) {
                links.push({
                    href: that.generateEntityLinksUrl(projectKey, that.entityMappings[entityType]),
                    label: "Manage product links",
                    title: ""
                });
            }

            that.getSidebar().find('.app-switcher-shortcuts .aui-nav-heading').before(navlinks.templates.appswitcher.cogDropdown({
                id: 'sidebar-project-shortcuts-admin-dropdown',
                links: links
            }));
        };

        this.updateAppLinks = function (data) {
            $(function () {
                that.getSidebar().find('.app-switcher-applications').html(navlinks.templates.appswitcher.linkSection({
                    title: "Application Links",
                    list: data
                }));

                if(NL.isUserAdmin)
                {
                    that.addApplicationsCog();
                }

                that.bindAnalyticsHandlers(that.getSidebar(), data);
            });
        };

        this.updateProjectShortcuts = function (localData, remoteData, projectData) {
            var localLinks = localData[0].shortcuts,
                remoteLinks = remoteData[0].shortcuts

            that.getSidebar().find('.app-switcher-shortcuts').html(navlinks.templates.appswitcher.linkSection({
                title: "Shortcuts",
                list: localLinks.concat(remoteLinks)
            }));

            // if we're an admin, put some project admin links in too
            if(NL.isUserAdmin)
            {
                that.addProjectShortcutsCog(projectData.key, projectData.entityType);
            }

            that.populateProjectHeader(projectData.name, projectData.avatarUrl);

            that.bindAnalyticsHandlers(that.getSidebar(), data);
        };

        // Warning: ick.
        this.entityMappings = {
            'confluence.space': 'com.atlassian.applinks.api.application.confluence.ConfluenceSpaceEntityType',
            'jira.project': 'com.atlassian.applinks.api.application.jira.JiraProjectEntityType',
            'bamboo.project': 'com.atlassian.applinks.api.application.bamboo.BambooProjectEntityType',
            'stash.project': 'com.atlassian.applinks.api.application.stash.StashProjectEntityType'
        }
        this.generateEntityLinksUrl = function(projectKey, entityType) {
            // special case for confluence which has a much nicer entity links page
            if (entityType === that.entityMappings['confluence.space']) {
                return AJS.contextPath() + '/spaces/listentitylinks.action?typeId=' + entityType + '&key=' + projectKey;
            } else {
                return AJS.contextPath() + '/plugins/servlet/applinks/listEntityLinks/' + entityType + '/' + projectKey;
            }
        }

        this.showAppSwitcherError = function () {
            $(function () {
                var $sidebar = that.getSidebar();
                $sidebar.find('.app-switcher-applications .app-switcher-loading')
                        .replaceWith(navlinks.templates.appswitcher.error())
                $sidebar.off('.appswitcher')
                        .on('click.appswitcher', '.app-switcher-retry', $.proxy(that.retryLoading, that));
            });
        };

        this.showProjectShortcutsError = function () {
            $(function () {
                var $sidebar = that.getSidebar();
                $sidebar.find('.app-switcher-shortcuts .app-switcher-loading')
                    .replaceWith(navlinks.templates.appswitcher.error());
                $sidebar.off('.appswitcher')
                    .on('click.appswitcher', '.app-switcher-retry', $.proxy(that.retryLoading, that));
            });
        };

        this.retryLoading = function (e) {
            this.getSidebar().html(navlinks.templates.appswitcher.sidebarContents());
            this.getLinks();
            this.getProjectData();
            e && e.stopPropagation();
        };

        this.bindAnalyticsHandlers = function ($sidebar, apps) {
            // TODO: reconsider what we want to capture
        };

        this.getLinks();
        $(this.getProjectData);

        this.toggleSidebar = function(event){
            var sidebar = that.getSidebar(),
                body = $('body'), document = $(window.document);

            if (!body.hasClass('app-switcher-open')) {
                var header = $('#header');

                //append the sidebar to the body if this is the first toggle call.
                sidebar.css('left', -sidebar.width());
                sidebar.parent('body').length || sidebar.appendTo('body');
                sidebarStalk({data: sidebar});
                //Animation can be kicked off now that things are in position
                sidebar.animate({'left': 0}, 300);

                function closeSidebar(closeEvent){
                    var target = closeEvent.target && $(closeEvent.target),
                        keyCode = closeEvent.keyCode;

                    //shortcut out if this is the same even which bound the event to begin with
                    if( closeEvent.originalEvent === event.originalEvent ) {
                        return;
                    }

                    if (target && !keyCode && !(target.closest(sidebar).length || target.closest(header).length)
                            && event.which == 1 && !(closeEvent.shiftKey || closeEvent.ctrlKey || closeEvent.metaKey)){
                        //event is a click outside of the toolbar or header
                        that.toggleSidebar();
                    } else if (keyCode === 27) {
                        //event is the escape key
                        that.toggleSidebar();
                    }
                }
                document.on('click.appSwitcher', closeSidebar);
                document.on('keydown.appSwitcher', closeSidebar);
                document.on('scroll.appSwitcher', sidebar, sidebarStalk);
            } else {
                document.off('.appSwitcher');
            }
            body.toggleClass('app-switcher-open');
        }

        $('#header').on('click', '.app-switcher-trigger', this.toggleSidebar);
    };

    function sidebarStalk(event){
        var scrollPosition = $(document).scrollTop(),
            header = $('#header'),
            topOffset = (header.height() + header.offset().top) - scrollPosition;

        if ( topOffset >= 0 ) {
            event.data.css({top: topOffset, position: 'fixed'});
        } else {
            event.data.css({top: 0, left: 0, position: 'fixed'});
        }
    }

    if (NL.onInit) {
        NL.onInit();
    }
}(jQuery, window.NL = (window.NL || {})));
;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher_old.js' */
var APPSWITCHER_TRIGGER_CLICK = "appswitcher.trigger.click";
var APPSWITCHER_DROPDOWN_SHOW = "appswitcher.dropdown.show";
var APPSWITCHER_DROPDOWN_DISPLAY_ERROR = "appswitcher.dropdown.display.error";
var APPSWITCHER_APP_LINK_CLICK = "appswitcher.app.link.click";
var APPSWITCHER_CONFIGURE_LINK_CLICK = "appswitcher.configure.link.click";

(function ($, NL) {
    NL.AppSwitcher = function (options) {
        var ADMIN_EDIT_PATH = AJS.contextPath() + "/plugins/servlet/customize-application-navigator";
        var GLOBAL_BILLING_SYSTEM_DARK_FEATURE_KEY = "unified.usermanagement";
        var that = this;
        this.$dropdown = null;

        options = $.extend({
            dropdownContents: null
        }, options);

        this.getLinks = function () {
            return $.ajax({
                url: AJS.contextPath() + '/rest/menu/latest/appswitcher',
                cache: false,
                dataType: 'json'
            }).done(this.updateDropdown).fail(this.showError);
        };

        this.getDropdown = function () {
            if (!this.$dropdown) {
                this.$dropdown = $(options.dropdownContents);
            }
            return this.$dropdown;
        };

        this.updateDropdown = function (data) {
            $(function () {
                that.getDropdown().html(navlinks.templates.appswitcher_old.applications({
                    apps: data,
                    showAdminLink: NL.environment.isUserAdmin,
                    adminLink: ADMIN_EDIT_PATH
                }));

                that.bindAnalyticsHandlers();
                if (NL.environment.isAppSuggestionAvailable === true) {
                    that.handleSuggestionApps(data);
                }
            });
        };

        this.bindAnalyticsHandlers = function () {
            $(".app-switcher-trigger").on("click", function() {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_TRIGGER_CLICK});
            });

            $("#app-switcher").on("aui-dropdown2-show", function() {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_DROPDOWN_SHOW});
            });

            $('#app-switcher .nav-link').on('click', function() {
                var product = "custom";
                var productLink = $(this).find("a");
                var url = productLink.attr("href");
                var hostname = window.location.hostname;

                if (url.indexOf(hostname + "/wiki") > -1) {
                    product = "confluence";
                } else if (url.indexOf(hostname + "/build") > -1) {
                    product = "bamboo";
                } else if (url.indexOf(hostname) > -1) {
                    product = "jira";
                }

                AJS.trigger("analyticsEvent", {
                    name: APPSWITCHER_APP_LINK_CLICK,
                    data: { product: product }
                });
            });

            $('.nav-link-edit-wrapper').on('click', function() {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_CONFIGURE_LINK_CLICK});
            })
        };

        this.isBillingSystemEnabled = function() {
            return (NL.environment.isSiteAdminUser === true) && AJS.DarkFeatures.isEnabled(GLOBAL_BILLING_SYSTEM_DARK_FEATURE_KEY);
        };

        this.handleSuggestionApps = function(data) {

            var installedApps = _.map(data, function (app) {
                return app.applicationType.toLowerCase();
            });

            var $suggestionApps = $("<div id='app-switcher-suggestion-apps' class='aui-dropdown2-section'/>");
            $suggestionApps.html(navlinks.templates.appswitcher_old.suggestionApps);

            var apps = $suggestionApps.find('.suggestion-apps');
            var hasSuggestionApps = false;
            _.each(suggestions, function(value) {
                if (!_.contains(installedApps, value.appName)) {
                    hasSuggestionApps = true;
                    apps.append(navlinks.templates.appswitcher_old.suggestionApp({
                        suggestionApp: value,
                        isBillingSystemEnabled:  that.isBillingSystemEnabled()
                    }));
                }
            });

            if (!hasSuggestionApps) return;

            $("#app-switcher").append($suggestionApps);

            $('.app-discovery-suggestion-app').click(function () {
                var $suggestionAppLink = $(this).find("a");
                var eventName;
                if (NL.environment.isSiteAdminUser) {
                    eventName = 'appswitcher.discovery.siteadmin.select.inproduct.';
                } else {
                    eventName = 'appswitcher.discovery.user.select.';
                }
                eventName = eventName + $suggestionAppLink.attr("id").toLowerCase();
                AJS.trigger("analytics", {name: eventName});
            });

            $('.app-discovery-suggestion-app').hover(function () {
                $(this).find("a").removeClass("active").removeClass("aui-dropdown2-active");
            });

            $('.app-discovery-cancel-button').click(function () {
                AJS.trigger("analytics", {name: "appswitcher.discovery.nothanks.button.click"});
                storeUserStorageData(KEY_NO_THANKS, "true");
                $suggestionApps.remove();
            });
        };

        this.showError = function () {
            $(function () {
                AJS.trigger("analyticsEvent", {name: APPSWITCHER_DROPDOWN_DISPLAY_ERROR});
                that.getDropdown()
                    .html(navlinks.templates.appswitcher_old.error())
                    .off('.appswitcher')
                    .on('click.appswitcher', '.app-switcher-retry', $.proxy(that.retryLoading, that));
            });
        };

        this.retryLoading = function (e) {
            this.getDropdown().html(navlinks.templates.appswitcher_old.loading());
            this.getLinks();
            e && e.stopPropagation();
        };

        this.getLinks();
    };

    var KEY_NO_THANKS = "key-no-thanks";
    var suggestions = [
        {
            appName: "jira",
            appDesc: "Issue & Project Tracking Software",
            discoveryUrl: 'https://www.atlassian.com/software/jira',
            billingSystemDiscoveryUrl: '/admin/billing/addapplication'
        },
        {
            appName: "confluence",
            appDesc: "Collaboration and content sharing",
            discoveryUrl: 'https://www.atlassian.com/software/confluence',
            billingSystemDiscoveryUrl: '/admin/billing/addapplication?product=confluence.ondemand'
        },
        {
            appName: "bamboo",
            appDesc: "Continuous integration",
            discoveryUrl: 'https://www.atlassian.com/software/bamboo',
            billingSystemDiscoveryUrl: '/admin/billing/addapplication?product=bamboo.ondemand'
        }];

    var storeUserStorageData = function (key, value) {
        $.ajax({
            url: AJS.contextPath() + '/rest/menu/latest/userdata/',
            type: "PUT",
            contentType: "application/json",
            data: JSON.stringify({
                key: key,
                value:value
            })
        });
    };

    if (NL.onInit) {
        NL.onInit();
    }


}(jQuery, window.NL = (window.NL || {})));;
;
/* module-key = 'com.atlassian.plugins.atlassian-nav-links-plugin:rotp-menu', location = 'appswitcher/appswitcher_old.soy' */
// This file was automatically generated from appswitcher_old.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace navlinks.templates.appswitcher_old.
 */

if (typeof navlinks == 'undefined') { var navlinks = {}; }
if (typeof navlinks.templates == 'undefined') { navlinks.templates = {}; }
if (typeof navlinks.templates.appswitcher_old == 'undefined') { navlinks.templates.appswitcher_old = {}; }


navlinks.templates.appswitcher_old.applications = function(opt_data, opt_ignored) {
  return '' + navlinks.templates.appswitcher_old.applicationsSection({list: opt_data.apps, listClass: 'nav-links', showDescription: opt_data.showDescription}) + ((opt_data.custom) ? navlinks.templates.appswitcher_old.applicationsSection({list: opt_data.custom, showDescription: opt_data.showDescription}) : '') + ((opt_data.showAdminLink) ? navlinks.templates.appswitcher_old.adminSection(opt_data) : '');
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.applications.soyTemplateName = 'navlinks.templates.appswitcher_old.applications';
}


navlinks.templates.appswitcher_old.applicationsSection = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.list.length > 0) {
    var param19 = '<ul' + ((opt_data.listClass) ? ' class="' + soy.$$escapeHtml(opt_data.listClass) + '"' : '') + '>';
    var linkList27 = opt_data.list;
    var linkListLen27 = linkList27.length;
    for (var linkIndex27 = 0; linkIndex27 < linkListLen27; linkIndex27++) {
      var linkData27 = linkList27[linkIndex27];
      param19 += navlinks.templates.appswitcher_old.applicationsItem(soy.$$augmentMap(linkData27, {showDescription: opt_data.showDescription}));
    }
    param19 += '</ul>';
    output += aui.dropdown2.section({content: param19});
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.applicationsSection.soyTemplateName = 'navlinks.templates.appswitcher_old.applicationsSection';
}


navlinks.templates.appswitcher_old.applicationsItem = function(opt_data, opt_ignored) {
  return '<li class="nav-link' + ((opt_data.self) ? ' nav-link-local' : '') + '"><a href="' + soy.$$escapeHtml(opt_data.link) + '" class="aui-dropdown2-radio ' + ((opt_data.self) ? 'aui-dropdown2-checked' : '') + '" title="' + soy.$$escapeHtml(opt_data.link) + '"><span class="nav-link-label">' + soy.$$escapeHtml(opt_data.label) + '</span>' + ((opt_data.showDescription && opt_data.description) ? '<span class="nav-link-description">' + soy.$$escapeHtml(opt_data.description) + '</span>' : '') + '</a></li>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.applicationsItem.soyTemplateName = 'navlinks.templates.appswitcher_old.applicationsItem';
}


navlinks.templates.appswitcher_old.adminSection = function(opt_data, opt_ignored) {
  return '' + aui.dropdown2.section({content: '<ul class="nav-links"><li><a class="nav-link-edit-wrapper" href="' + soy.$$escapeHtml(opt_data.adminLink) + '"><span class="nav-link-edit">' + soy.$$filterNoAutoescape("Configure\x26hellip;") + '</span></a></li></ul>'});
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.adminSection.soyTemplateName = 'navlinks.templates.appswitcher_old.adminSection';
}


navlinks.templates.appswitcher_old.error = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-error">' + soy.$$filterNoAutoescape("Something went wrong, please \x3cspan class\x3d\x22app-switcher-retry\x22\x3etry again\x3c/span\x3e.") + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.error.soyTemplateName = 'navlinks.templates.appswitcher_old.error';
}


navlinks.templates.appswitcher_old.loading = function(opt_data, opt_ignored) {
  return '<div class="app-switcher-loading">' + soy.$$filterNoAutoescape("Loading\x26hellip;") + '</div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.loading.soyTemplateName = 'navlinks.templates.appswitcher_old.loading';
}


navlinks.templates.appswitcher_old.trigger = function(opt_data, opt_ignored) {
  return '<span class="aui-icon aui-icon-small aui-iconfont-appswitcher">' + soy.$$escapeHtml("Linked Applications") + '</span>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.trigger.soyTemplateName = 'navlinks.templates.appswitcher_old.trigger';
}


navlinks.templates.appswitcher_old.switcher = function(opt_data, opt_ignored) {
  var output = '';
  if (true) {
    var loadingContent__soy81 = '' + navlinks.templates.appswitcher_old.loading(null);
    var triggerContent__soy83 = '' + navlinks.templates.appswitcher_old.trigger(null);
    output += aui.dropdown2.dropdown2({menu: {id: 'app-switcher', content: loadingContent__soy81, extraClasses: 'aui-style-default'}, trigger: {showIcon: false, content: triggerContent__soy83, extraClasses: 'app-switcher-trigger', extraAttributes: {href: '#app-switcher'}}}) + '<script>\n            (function (NL) {\n                var initialise = function () {\n                    // For some milestones of AUI, the atlassian soy namespace was renamed to aui. Handle that here by ensuring that window.atlassian is defined.\n                    window.atlassian = window.atlassian || window.aui;\n                    new NL.AppSwitcher({\n                        dropdownContents: \'#app-switcher\'\n                    });\n                };\n                if (NL.AppSwitcher) {\n                    initialise();\n                } else {\n                    NL.onInit = initialise;\n                }\n            }(window.NL = (window.NL || {})));\n            window.NL.environment = ' + soy.$$escapeHtml({}) + ';<\/script>';
  }
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.switcher.soyTemplateName = 'navlinks.templates.appswitcher_old.switcher';
}


navlinks.templates.appswitcher_old.suggestionApp = function(opt_data, opt_ignored) {
  var output = '';
  var href__soy92 = opt_data.isBillingSystemEnabled == true ? opt_data.suggestionApp.billingSystemDiscoveryUrl : opt_data.suggestionApp.discoveryUrl;
  output += '<li class="app-discovery-suggestion-app"><a id="' + soy.$$escapeHtml(opt_data.suggestionApp.appName) + '" href="' + soy.$$escapeHtml(href__soy92) + '" class="app-discovery-link aui-icon-container app-discovery-' + soy.$$escapeHtml(opt_data.suggestionApp.appName) + '-product-icon" title="' + soy.$$escapeHtml(href__soy92) + '" target="_blank"/><div class="app-discovery-small">' + soy.$$escapeHtml(opt_data.suggestionApp.appDesc) + '</div></li>';
  return output;
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.suggestionApp.soyTemplateName = 'navlinks.templates.appswitcher_old.suggestionApp';
}


navlinks.templates.appswitcher_old.suggestionApps = function(opt_data, opt_ignored) {
  return '<ul class=\'nav-links suggestion-apps\'><li><span class=\'app-discovery-suggest-title nav-link-label\'><h6>' + soy.$$escapeHtml("Try other Atlassian apps") + '</h6></span></li></ul><div class=\'buttons-container app-discovery-suggest-apps-buttons\'><div class=\'buttons\'><button class=\'aui-button aui-button-link app-discovery-cancel-button\' name=\'cancel\' accesskey=\'c\' href=\'#\'>' + soy.$$escapeHtml("Don\x27t show this again") + '</button></div></div>';
};
if (goog.DEBUG) {
  navlinks.templates.appswitcher_old.suggestionApps.soyTemplateName = 'navlinks.templates.appswitcher_old.suggestionApps';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:jira-header', location = 'soy/headerDropdown.soy' */
// This file was automatically generated from headerDropdown.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Menu.Dropdowns.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Menu == 'undefined') { JIRA.Templates.Menu = {}; }
if (typeof JIRA.Templates.Menu.Dropdowns == 'undefined') { JIRA.Templates.Menu.Dropdowns = {}; }


JIRA.Templates.Menu.Dropdowns.dropdown2Fragment = function(opt_data, opt_ignored) {
  var output = '';
  var sectionList3 = opt_data.sections;
  var sectionListLen3 = sectionList3.length;
  for (var sectionIndex3 = 0; sectionIndex3 < sectionListLen3; sectionIndex3++) {
    var sectionData3 = sectionList3[sectionIndex3];
    var hasItems__soy4 = sectionData3.items && sectionData3.items.length > 0;
    output += '<div class="aui-dropdown2-section">' + ((hasItems__soy4 && sectionData3.label) ? '<strong>' + soy.$$escapeHtml(sectionData3.label) + '</strong>' : '') + '<ul class=\'aui-list-truncate\'' + ((sectionData3.id) ? ' id="' + soy.$$escapeHtml(sectionData3.id) + '"' : '') + ((sectionData3.style) ? ' class="' + soy.$$escapeHtml(sectionData3.style) + '"' : '') + '>';
    if (hasItems__soy4) {
      var itemList25 = sectionData3.items;
      var itemListLen25 = itemList25.length;
      for (var itemIndex25 = 0; itemIndex25 < itemListLen25; itemIndex25++) {
        var itemData25 = itemList25[itemIndex25];
        output += JIRA.Templates.Menu.Dropdowns.dropdown2Item(itemData25);
      }
    }
    output += '</ul></div>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Menu.Dropdowns.dropdown2Fragment.soyTemplateName = 'JIRA.Templates.Menu.Dropdowns.dropdown2Fragment';
}


JIRA.Templates.Menu.Dropdowns.dropdown2Item = function(opt_data, opt_ignored) {
  var output = '<li' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '"' : '') + ((opt_data.style) ? ' class="' + soy.$$escapeHtml(opt_data.style) + '"' : '') + '><a href="' + soy.$$escapeHtml(opt_data.url) + '"' + ((opt_data.id) ? ' id="' + soy.$$escapeHtml(opt_data.id) + '_lnk"' : '') + ((opt_data.title) ? ' title="' + soy.$$escapeHtml(opt_data.title) + '"' : '') + ' class="' + ((opt_data.iconUrl) ? 'aui-icon-container' : '') + ((opt_data.parameters && opt_data.parameters['class']) ? ' ' + soy.$$escapeHtml(opt_data.parameters['class']) : '') + '"';
  if (opt_data.parameters) {
    var keyList66 = soy.$$getMapKeys(opt_data.parameters);
    var keyListLen66 = keyList66.length;
    for (var keyIndex66 = 0; keyIndex66 < keyListLen66; keyIndex66++) {
      var keyData66 = keyList66[keyIndex66];
      output += (keyData66 != 'class') ? ' ' + soy.$$escapeHtml(keyData66) + '="' + soy.$$escapeHtml(opt_data.parameters[keyData66]) + '"' : '';
    }
  }
  output += '>' + ((opt_data.iconUrl) ? '<img class="icon" src="' + soy.$$escapeHtml(opt_data.iconUrl) + '" />' : '') + soy.$$escapeHtml(opt_data.label) + '</a></li>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Menu.Dropdowns.dropdown2Item.soyTemplateName = 'JIRA.Templates.Menu.Dropdowns.dropdown2Item';
}
;
;
/* module-key = 'com.atlassian.jira.jira-header-plugin:jira-header', location = 'js/init-dropdown2.js' */
/**
 * JIRA's implementation of AUI Dropdown2 remote API (https://extranet.atlassian.com/display/AUI/Dropdown2+remote+API).
 *
 * This predates AUI Dropdown2, and allows the application header menus to be dynamic and populated via AJAX. This is
 * required for menus that are dynamic (e.g. Issues or Projects).
 *
 * In addition to the normal `aui-dropdown2-show` event that is triggered on the dropdown, two extra events are
 * triggered to expose the asynchronous nature of the menus:
 *
 * - `aui-dropdown2-show-before` is triggered _before_ a dropdown is shown (due to implementation details, this is
 *    unfortunately triggered after `aui-dropdown2-show`).
 * - `aui-dropdown2-show-after` is triggered when the dropdown is populated and visible to the user. It is triggered for
 *    both remote dropdowns and normal dropdowns.
 *
 * The class `aui-dropdown2-loading` is added to the dropdown between `aui-dropdown2-show-before` and
 * `aui-dropdown2-show-after`.
 */
require(['jira/ajs/ajax/smart-ajax', 'jquery'], function (SmartAjax, $) {
    $(function () {
        $("nav.aui-header a.aui-dropdown2-trigger").each(function() {
            var $trigger = $(this);
            var $dropdown = $("#" + $trigger.attr("aria-owns"));
            var ajaxKey = $dropdown.data("aui-dropdown2-ajax-key");

            $dropdown.bind("aui-dropdown2-show", function (event, options) {
                $dropdown.trigger('aui-dropdown2-show-before');

                if (ajaxKey) {
                    // JIRA's own implementation of Dropdown2 remote API. This predates Dropdown2 remote, and should be
                    // removed when Dropdown2 remote API lands in AUI.
                    $dropdown.empty();
                    $dropdown.addClass("aui-dropdown2-loading");
                    SmartAjax.makeRequest({
                        url: AJS.contextPath() + "/rest/api/1.0/menus/" + ajaxKey,
                        data: {
                            inAdminMode: AJS.Meta.getBoolean("in-admin-mode")
                        },
                        dataType: "json",
                        cache: false,
                        success: function (data) {
                            $dropdown.removeClass("aui-dropdown2-loading");
                            $dropdown.html(JIRA.Templates.Menu.Dropdowns.dropdown2Fragment(data));

                            if (options && options.selectFirst) {
                                $dropdown.find("a:not(.disabled)").filter(":first").addClass("active");
                            }
                            $dropdown.trigger('aui-dropdown2-show-after');
                        }
                    });
                } else {
                    $dropdown.trigger('aui-dropdown2-show-after');
                }
            });
        });
    });
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/keymaster.js' */
//     keymaster.js
//     (c) 2011-2013 Thomas Fuchs
//     keymaster.js may be freely distributed under the MIT license.

;(function(global){
    var k,
            _handlers = {},
            _mods = { 16: false, 18: false, 17: false, 91: false },
            _scope = 'all',
    // modifier keys
            _MODIFIERS = {
                '⇧': 16, shift: 16,
                '⌥': 18, alt: 18, option: 18,
                '⌃': 17, ctrl: 17, control: 17,
                '⌘': 91, command: 91
            },
    // special keys
            _MAP = {
                backspace: 8, tab: 9, clear: 12,
                enter: 13, 'return': 13,
                esc: 27, escape: 27, space: 32,
                left: 37, up: 38,
                right: 39, down: 40,
                del: 46, 'delete': 46,
                home: 36, end: 35,
                pageup: 33, pagedown: 34,
                ',': 188, '.': 190, '/': 191,
                '`': 192, '-': 189, '=': 187,
                ';': 186, '\'': 222,
                '[': 219, ']': 221, '\\': 220
            },
            code = function(x){
                return _MAP[x] || x.toUpperCase().charCodeAt(0);
            },
            _downKeys = [];

    for(k=1;k<20;k++) _MAP['f'+k] = 111+k;

    // IE doesn't support Array#indexOf, so have a simple replacement
    function index(array, item){
        var i = array.length;
        while(i--) if(array[i]===item) return i;
        return -1;
    }

    // for comparing mods before unassignment
    function compareArray(a1, a2) {
        if (a1.length != a2.length) return false;
        for (var i = 0; i < a1.length; i++) {
            if (a1[i] !== a2[i]) return false;
        }
        return true;
    }

    var modifierMap = {
        16:'shiftKey',
        18:'altKey',
        17:'ctrlKey',
        91:'metaKey'
    };
    function updateModifierKey(event) {
        for(k in _mods) _mods[k] = event[modifierMap[k]];
    };

    // handle keydown event
    function dispatch(event) {
        var key, handler, k, i, modifiersMatch, scope;
        key = event.keyCode;

        if (index(_downKeys, key) == -1) {
            _downKeys.push(key);
        }

        // if a modifier key, set the key.<modifierkeyname> property to true and return
        if(key == 93 || key == 224) key = 91; // right command on webkit, command on Gecko
        if(key in _mods) {
            _mods[key] = true;
            // 'assignKey' from inside this closure is exported to window.key
            for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = true;
            return;
        }
        updateModifierKey(event);

        // see if we need to ignore the keypress (filter() can can be overridden)
        // by default ignore key presses if a select, textarea, or input is focused
        if(!assignKey.filter.call(this, event)) return;

        // abort if no potentially matching shortcuts found
        if (!(key in _handlers)) return;

        scope = getScope();

        // for each potential shortcut
        for (i = 0; i < _handlers[key].length; i++) {
            handler = _handlers[key][i];

            // see if it's in the current scope
            if(handler.scope == scope || handler.scope == 'all'){
                // check if modifiers match if any
                modifiersMatch = handler.mods.length > 0;
                for(k in _mods)
                    if((!_mods[k] && index(handler.mods, +k) > -1) ||
                            (_mods[k] && index(handler.mods, +k) == -1)) modifiersMatch = false;
                // call the handler and stop the event if neccessary
                if((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch){
                    if(handler.method(event, handler)===false){
                        if(event.preventDefault) event.preventDefault();
                        else event.returnValue = false;
                        if(event.stopPropagation) event.stopPropagation();
                        if(event.cancelBubble) event.cancelBubble = true;
                    }
                }
            }
        }
    };

    // unset modifier keys on keyup
    function clearModifier(event){
        var key = event.keyCode, k,
                i = index(_downKeys, key);

        // remove key from _downKeys
        if (i >= 0) {
            _downKeys.splice(i, 1);
        }

        if(key == 93 || key == 224) key = 91;
        if(key in _mods) {
            _mods[key] = false;
            for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = false;
        }
    };

    function resetModifiers() {
        for(k in _mods) _mods[k] = false;
        for(k in _MODIFIERS) assignKey[k] = false;
    };

    // parse and assign shortcut
    function assignKey(key, scope, method){
        var keys, mods;
        keys = getKeys(key);
        if (method === undefined) {
            method = scope;
            scope = 'all';
        }

        // for each shortcut
        for (var i = 0; i < keys.length; i++) {
            // set modifier keys if any
            mods = [];
            key = keys[i].split('+');
            if (key.length > 1){
                mods = getMods(key);
                key = [key[key.length-1]];
            }
            // convert to keycode and...
            key = key[0]
            key = code(key);
            // ...store handler
            if (!(key in _handlers)) _handlers[key] = [];
            _handlers[key].push({ shortcut: keys[i], scope: scope, method: method, key: keys[i], mods: mods });
        }
    };

    // unbind all handlers for given key in current scope
    function unbindKey(key, scope) {
        var multipleKeys, keys,
                mods = [],
                i, j, obj;

        multipleKeys = getKeys(key);

        for (j = 0; j < multipleKeys.length; j++) {
            keys = multipleKeys[j].split('+');

            if (keys.length > 1) {
                mods = getMods(keys);
                key = keys[keys.length - 1];
            }

            key = code(key);

            if (scope === undefined) {
                scope = getScope();
            }
            if (!_handlers[key]) {
                return;
            }
            for (i in _handlers[key]) {
                obj = _handlers[key][i];
                // only clear handlers if correct scope and mods match
                if (obj.scope === scope && compareArray(obj.mods, mods)) {
                    _handlers[key][i] = {};
                }
            }
        }
    };

    // Returns true if the key with code 'keyCode' is currently down
    // Converts strings into key codes.
    function isPressed(keyCode) {
        if (typeof(keyCode)=='string') {
            keyCode = code(keyCode);
        }
        return index(_downKeys, keyCode) != -1;
    }

    function getPressedKeyCodes() {
        return _downKeys.slice(0);
    }

    function filter(event){
        var tagName = (event.target || event.srcElement).tagName;
        // ignore keypressed in any elements that support keyboard data input
        return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');
    }

    // initialize key.<modifier> to false
    for(k in _MODIFIERS) assignKey[k] = false;

    // set current scope (default 'all')
    function setScope(scope){ _scope = scope || 'all' };
    function getScope(){ return _scope || 'all' };

    // delete all handlers for a given scope
    function deleteScope(scope){
        var key, handlers, i;

        for (key in _handlers) {
            handlers = _handlers[key];
            for (i = 0; i < handlers.length; ) {
                if (handlers[i].scope === scope) handlers.splice(i, 1);
                else i++;
            }
        }
    };

    // abstract key logic for assign and unassign
    function getKeys(key) {
        var keys;
        key = key.replace(/\s/g, '');
        keys = key.split(',');
        if ((keys[keys.length - 1]) == '') {
            keys[keys.length - 2] += ',';
        }
        return keys;
    }

    // abstract mods logic for assign and unassign
    function getMods(key) {
        var mods = key.slice(0, key.length - 1);
        for (var mi = 0; mi < mods.length; mi++)
            mods[mi] = _MODIFIERS[mods[mi]];
        return mods;
    }

    // cross-browser events
    function addEvent(object, event, method) {
        if (object.addEventListener)
            object.addEventListener(event, method, false);
        else if(object.attachEvent)
            object.attachEvent('on'+event, function(){ method(window.event) });
    };

    // set the handlers globally on document
    addEvent(document, 'keydown', function(event) { dispatch(event) }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48
    addEvent(document, 'keyup', clearModifier);

    // reset modifiers to false whenever the window is (re)focused.
    addEvent(window, 'focus', resetModifiers);

    // store previously defined key
    var previousKey = global.key;

    // restore previously defined key and return reference to our key object
    function noConflict() {
        var k = global.key;
        global.key = previousKey;
        return k;
    }

    // set window.key and window.key.set/get/deleteScope, and the default filter
    global.key = assignKey;
    global.key.setScope = setScope;
    global.key.getScope = getScope;
    global.key.deleteScope = deleteScope;
    global.key.filter = filter;
    global.key.isPressed = isPressed;
    global.key.getPressedKeyCodes = getPressedKeyCodes;
    global.key.noConflict = noConflict;
    global.key.unbind = unbindKey;

    if(typeof module !== 'undefined') module.exports = key;

})(this);;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/amd-wrappers.js' */
/* AMD wrappers for commonly used objects */

define('wiki-edit/aui', function() { return AJS; });
define('wiki-edit/JIRA', function() { return JIRA; });
define('wiki-edit/keymaster', ["wiki-edit/aui"], function(AJS) {
    if (AJS.Meta.get("keyboard-shortcuts-enabled") === false) {
        return function keyMasterNoop() {};
    }
    return key.noConflict();
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/templates/wiki-editor.soy' */
// This file was automatically generated from wiki-editor.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Plugins.WikiEditor.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Plugins == 'undefined') { JIRA.Templates.Plugins = {}; }
if (typeof JIRA.Templates.Plugins.WikiEditor == 'undefined') { JIRA.Templates.Plugins.WikiEditor = {}; }


JIRA.Templates.Plugins.WikiEditor.renderEditor = function(opt_data, opt_ignored) {
  var output = '<div id="wiki-edit-dropdown2-text-style-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="paragraph" title="' + soy.$$escapeHtml("Paragraph") + '">' + soy.$$escapeHtml("Paragraph") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h1" data-operation="h1" title="' + soy.$$escapeHtml("Heading 1") + '">' + soy.$$escapeHtml("Heading 1") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h2" data-operation="h2" title="' + soy.$$escapeHtml("Heading 2") + '">' + soy.$$escapeHtml("Heading 2") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h3" data-operation="h3" title="' + soy.$$escapeHtml("Heading 3") + '">' + soy.$$escapeHtml("Heading 3") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h4" data-operation="h4" title="' + soy.$$escapeHtml("Heading 4") + '">' + soy.$$escapeHtml("Heading 4") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h5" data-operation="h5" title="' + soy.$$escapeHtml("Heading 5") + '">' + soy.$$escapeHtml("Heading 5") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-h6" data-operation="h6" title="' + soy.$$escapeHtml("Heading 6") + '">' + soy.$$escapeHtml("Heading 6") + '</a></li><li><a href="#" class="wiki-edit-operation wiki-edit-operation-monospace" data-operation="monospace" title="' + soy.$$escapeHtml("Preformatted") + '">' + soy.$$escapeHtml("Preformatted") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="paragraph-quote" title="' + soy.$$escapeHtml("Paragraph quote") + '">' + soy.$$escapeHtml("Paragraph quote") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="block-quote" title="' + soy.$$escapeHtml("Block quote") + '">' + soy.$$escapeHtml("Block quote") + '</a></li></ul></div></div><div id="wiki-edit-dropdown2-more-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="delete" data-shortcut="ctrl+shift+s, command+shift+s" title="' + soy.$$escapeHtml("Strikethrough") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+Shift+S)">' + soy.$$escapeHtml("Strikethrough") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="superscript">' + soy.$$escapeHtml("Superscript") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="subscript">' + soy.$$escapeHtml("Subscript") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="cite">' + soy.$$escapeHtml("Citation") + '</a></li></ul></div></div><div id="wiki-edit-dropdown2-link-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown wiki-edit-dropdown-link"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="link" data-shortcut="ctrl+k, command+k" title="' + soy.$$escapeHtml("External link") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+K)">' + soy.$$escapeHtml("External link") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="link-mail">' + soy.$$escapeHtml("Mail link") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="link-anchor">' + soy.$$escapeHtml("Anchor link") + '</a></li>' + ((! opt_data.attachmentM2FeatureFlag) ? '<li><a href="#" class="wiki-edit-operation" data-operation="link-attachment">' + soy.$$escapeHtml("Attachment link") + '</a></li>' : '') + '</ul></div>' + ((! opt_data.attachmentM2FeatureFlag) ? '<div class="aui-dropdown2-section wiki-edit-insert-link"><strong>' + soy.$$escapeHtml("Attachment link") + '</strong><ul class="aui-list-truncate"><li><a href="#"></a></li></ul></div>' : '') + '</div>' + ((! opt_data.attachmentM2FeatureFlag) ? '<div id="wiki-edit-dropdown2-image-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown wiki-edit-dropdown-image"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="image" title="' + soy.$$escapeHtml("External image") + '">' + soy.$$escapeHtml("External image") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="image-attachment">' + soy.$$escapeHtml("Attached image") + '</a></li></ul></div><div class="aui-dropdown2-section wiki-edit-insert-image"><strong>' + soy.$$escapeHtml("Attached image") + '</strong><ul class="aui-list-truncate"><li><a href="#"></a></li></ul></div></div>' : '<div id="wiki-edit-dropdown2-attachment-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown wiki-edit-dropdown-attachment"><div class="aui-dropdown2-section wiki-edit-insert-attachment"><ul class="aui-list-truncate"><li><a href="#"></a></li></ul></div><div class="aui-dropdown2-section wiki-edit-browse-image"><ul class="aui-list-truncate"><li><a href="#" class="wiki-attachment-browse"><span class="aui-icon aui-icon-small aui-iconfont-add"></span>&nbsp;&nbsp;' + soy.$$escapeHtml("Browse") + '</a></li></ul></div></div>') + '<div id="wiki-edit-color-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-picker wiki-edit-color-picker" data-container="wiki-edit-color-picker-buttons-' + soy.$$escapeHtml(opt_data.editorId) + '">';
  var colors__soy108 = ['333333', '707070', 'cccccc', '205081', '59afe1', '14892c', '8eb021', 'd04437', 'f79232', 'f6c342', '654982', 'f691b2'];
  output += '<div class="aui-dropdown2-section"><ul>';
  var colorList110 = colors__soy108;
  var colorListLen110 = colorList110.length;
  for (var colorIndex110 = 0; colorIndex110 < colorListLen110; colorIndex110++) {
    var colorData110 = colorList110[colorIndex110];
    output += '<li><a href="#" style="background-color: #' + soy.$$escapeHtml(colorData110) + '" data-operation="color" data-color="#' + soy.$$escapeHtml(colorData110) + '">&nbsp;</a></li>';
  }
  output += '</ul></div></div><div id="wiki-edit-dropdown2-icon-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-picker wiki-edit-icon-picker" data-container="wiki-edit-icon-picker-buttons-' + soy.$$escapeHtml(opt_data.editorId) + '"><div class="aui-dropdown2-section"><ul><li><a href="#" class="wiki-edit-operation" title=":)" data-operation=":)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/smile.gif" alt="' + soy.$$escapeHtml("smile") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=":(" data-operation=":("><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/sad.gif" alt="' + soy.$$escapeHtml("sad") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=":P" data-operation=":P"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/tongue.gif" alt="' + soy.$$escapeHtml("tongue") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=":D" data-operation=":D"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/biggrin.gif" alt="' + soy.$$escapeHtml("biggrin") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title=";)" data-operation=";)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/wink.gif" alt="' + soy.$$escapeHtml("wink") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(y)" data-operation="(y)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/thumbs_up.gif" alt="' + soy.$$escapeHtml("thumbs up") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(n)" data-operation="(n)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/thumbs_down.gif" alt="' + soy.$$escapeHtml("thumbs down") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(i)" data-operation="(i)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/information.gif" alt="' + soy.$$escapeHtml("information") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(/)" data-operation="(/)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/check.gif" alt="' + soy.$$escapeHtml("check") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(x)" data-operation="(x)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/error.gif" alt="' + soy.$$escapeHtml("error") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(!)" data-operation="(!)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/warning.gif" alt="' + soy.$$escapeHtml("warning") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(+)" data-operation="(+)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/add.gif" alt="' + soy.$$escapeHtml("add") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(-)" data-operation="(-)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/forbidden.gif" alt="' + soy.$$escapeHtml("forbidden") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(?)" data-operation="(?)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/help_16.gif" alt="' + soy.$$escapeHtml("help") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(on)" data-operation="(on)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/lightbulb_on.gif" alt="' + soy.$$escapeHtml("lightbulb on") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(off)" data-operation="(off)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/lightbulb.gif" alt="' + soy.$$escapeHtml("lightbulb") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*)" data-operation="(*)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_yellow.gif" alt="' + soy.$$escapeHtml("star yellow") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*r)" data-operation="(*r)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_red.gif" alt="' + soy.$$escapeHtml("star red") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*g)" data-operation="(*g)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_green.gif" alt="' + soy.$$escapeHtml("star green") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*b)" data-operation="(*b)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_blue.gif" alt="' + soy.$$escapeHtml("star blue") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(*y)" data-operation="(*y)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/star_yellow.gif" alt="' + soy.$$escapeHtml("star yellow") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(flag)" data-operation="(flag)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/flag.gif" alt="' + soy.$$escapeHtml("flag") + '" /></a></li><li><a href="#" class="wiki-edit-operation" title="(flagoff)" data-operation="(flagoff)"><img src="' + soy.$$escapeHtml("/jira") + '/images/icons/emoticons/flag_grey.gif" alt="' + soy.$$escapeHtml("flag off") + '" /></a></li></ul></div></div><div id="wiki-edit-dropdown2-other-' + soy.$$escapeHtml(opt_data.editorId) + '" class="aui-dropdown2 aui-style-default wiki-edit-dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"><li><a href="#" class="wiki-edit-operation" data-operation="mention">' + soy.$$escapeHtml("User mention") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="table">' + soy.$$escapeHtml("Table") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="code">' + soy.$$escapeHtml("Code") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="noformat">' + soy.$$escapeHtml("Preformatted") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="panel">' + soy.$$escapeHtml("Panel") + '</a></li><li><a href="#" class="wiki-edit-operation" data-operation="hr">' + soy.$$escapeHtml("Horizontal ruler") + '</a></li><li class="wiki-edit-speech-item hidden"><a href="#" class="wiki-edit-operation" data-operation="speech">' + soy.$$escapeHtml("Speech recognition") + '</a></li></ul></div></div><div class="wiki-edit-toolbar" id="wiki-edit-' + soy.$$escapeHtml(opt_data.editorId) + '"><div class="aui-toolbar2"><div class="aui-toolbar2-inner"><div class="aui-toolbar2-primary"><div class="aui-buttons"><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-style-picker-trigger" aria-owns="wiki-edit-dropdown2-text-style-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-text-style-' + soy.$$escapeHtml(opt_data.editorId) + '">' + soy.$$escapeHtml("Style") + '</a></div><div class="aui-buttons wiki-edit-toolbar-section"><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="bold" data-shortcut="ctrl+b, command+b" title="' + soy.$$escapeHtml("Bold") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+B)"><span class="aui-icon aui-icon-small aui-iconfont-editor-bold">' + soy.$$escapeHtml("Bold") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="italic" data-shortcut="ctrl+i, command+i" title="' + soy.$$escapeHtml("Italic") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+I)"><span class="aui-icon aui-icon-small aui-iconfont-editor-italic">' + soy.$$escapeHtml("Italic") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="underline" data-shortcut="ctrl+u, command+u" title="' + soy.$$escapeHtml("Underline") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+U)"><span class="aui-icon aui-icon-small aui-iconfont-editor-underline">' + soy.$$escapeHtml("Underline") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation wiki-edit-operation-color" data-operation="color" data-color="red" title="' + soy.$$escapeHtml("Text color") + '"><span class="aui-icon aui-icon-small aui-iconfont-editor-color">' + soy.$$escapeHtml("Text color") + '</span><span class="wiki-edit-color-indicator"></span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-color-picker-trigger" data-operation="color-parameter" aria-owns="wiki-edit-color-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" title="' + soy.$$escapeHtml("More colors") + '"><span>' + soy.$$escapeHtml("More colors") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-more-picker-trigger" aria-owns="wiki-edit-dropdown2-more-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-more-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("More") + '"><span class="aui-icon aui-icon-small aui-iconfont-editor-styles">' + soy.$$escapeHtml("More") + '</span></a></div><div class="aui-buttons"><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-link-picker-trigger" aria-owns="wiki-edit-dropdown2-link-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-link-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Link") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+K)"><span class="aui-icon aui-icon-small aui-iconfont-link">' + soy.$$escapeHtml("Link") + '</span></a>' + ((! opt_data.attachmentM2FeatureFlag) ? '<a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-image-picker-trigger" aria-owns="wiki-edit-dropdown2-image-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-image-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Image") + '"><span class="aui-icon aui-icon-small aui-iconfont-image">' + soy.$$escapeHtml("Image") + '</span></a>' : '<a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-attachment-picker-trigger" aria-owns="wiki-edit-dropdown2-attachment-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-attachment-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Attachment") + '"><span class="aui-icon aui-icon-small aui-iconfont-file-generic">' + soy.$$escapeHtml("Attachment") + '</span></a>') + '</div><div class="aui-buttons wiki-edit-toolbar-section"><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="bullet-list" data-shortcut="ctrl+shift+b, command+shift+b" title="' + soy.$$escapeHtml("Bullet list") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+Shift+B)"><span class="aui-icon aui-icon-small aui-iconfont-editor-list-bullet">' + soy.$$escapeHtml("Bullet list") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-operation" data-operation="numbered-list" data-shortcut="ctrl+shift+n, command+shift+n" title="' + soy.$$escapeHtml("Numbered list") + ' (' + soy.$$escapeHtml(opt_data.controlKey) + '+Shift+N)"><span class="aui-icon aui-icon-small aui-iconfont-editor-list-number">' + soy.$$escapeHtml("Numbered list") + '</span></a></div><div class="aui-buttons"><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-icon-picker-trigger wiki-edit-tooltip" aria-owns="wiki-edit-dropdown2-icon-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-icon-picker-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Icons") + '"><span class="aui-icon aui-icon-small aui-iconfont-editor-emoticon">' + soy.$$escapeHtml("Icons") + '</span></a><a href="#" tabindex="-1" class="aui-button aui-button-subtle aui-dropdown2-trigger wiki-edit-other-picker-trigger wiki-edit-tooltip" aria-owns="wiki-edit-dropdown2-other-' + soy.$$escapeHtml(opt_data.editorId) + '" aria-haspopup="true" aria-controls="wiki-edit-dropdown2-other-' + soy.$$escapeHtml(opt_data.editorId) + '" title="' + soy.$$escapeHtml("Other") + '"><span class="aui-icon aui-icon-small aui-iconfont-add">' + soy.$$escapeHtml("Other") + '</span></a></div><div class="aui-buttons wiki-edit-toolbar-last"><a href="#" tabindex="-1" class="aui-button aui-button-subtle wiki-edit-visible-toggle wiki-edit-tooltip" title="' + soy.$$escapeHtml("Toggle visibility") + '"><span class="aui-icon icon-toolbartoggle">Lock / Unlock</span></a></div></div></div><!-- .aui-toolbar-inner --></div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Plugins.WikiEditor.renderEditor.soyTemplateName = 'JIRA.Templates.Plugins.WikiEditor.renderEditor';
}


JIRA.Templates.Plugins.WikiEditor.renderListItem = function(opt_data, opt_ignored) {
  return '<li><a href="#" ' + soy.$$escapeHtml(opt_data.attachmentType ? 'data-attachment-type=' + opt_data.attachmentType : '') + '>' + ((opt_data.attachmentM2FeatureFlagEnabled) ? '<span class="wiki-edit-attachment-type-icon aui-icon aui-icon-small ' + soy.$$escapeHtml(((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.cssClass) != null ? ((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.cssClass) : 'aui-iconfont-file-txt') + '" title="' + soy.$$escapeHtml(((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.title) != null ? ((opt_data.attachmentTypeIcon == null) ? null : opt_data.attachmentTypeIcon.title) : 'File') + '"></span>&nbsp;&nbsp;' : '') + '<span class="wiki-edit-attachment-name">' + soy.$$escapeHtml(opt_data.text) + '</span></a></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.Plugins.WikiEditor.renderListItem.soyTemplateName = 'JIRA.Templates.Plugins.WikiEditor.renderListItem';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/Analytics.js' */
define('wiki-edit/analytics',[
    'wiki-edit/aui'
], function(AJS) {

    var triggerEvent = (AJS.Analytics && AJS.Analytics.triggerPrivacyPolicySafeEvent) ?
        (function triggerEvent(name, props) {
            AJS.Analytics.triggerPrivacyPolicySafeEvent('jira.wikieditor.' + name, props || {});
        }) :
        (function triggerEvent(name, props) {
            AJS.trigger("analytics", { name: 'jira.wikieditor.'+name, data: props || {} });
        });

    function hashCode (string) {
        var charCode;
        var hash = 0;
        if (!string) {
            return "";
        }

        for (var i = 0; i < string.length; i += 1) {
            charCode = string.charCodeAt(i);
            hash = ((hash * 32) - hash) + charCode;
            hash |= 0; // force 32-bit representation
        }

        return hash;
    }

    return {
        trigger: triggerEvent,
        hashCode: hashCode
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/KeyTester.js' */
define('wiki-edit/KeyTester', function() {

    return {
        getActionType: function(keyCode) {
            if (this.isNavigation(keyCode)) {
                return "navigating";
            } else if (this.isDeleting(keyCode)) {
                return "deleting";
            } else if (this.isReturn(keyCode)) {
                return "newline";
            } else if (this.isEscape(keyCode)) {
                return "escape";
            } else if (this.isTyping(keyCode)) {
                return "typing";
            }
        },
        isNavigation: function(keyCode) {
            // 33 - 40: page up/dn and arrow keys
            // 63232 - 63235: page up/dn and arrow keys on safari
            return (keyCode >= 33 && keyCode <= 40) || (keyCode >= 63232 && keyCode <= 63235);
        },
        isDeleting: function(keyCode) {
            // 8 - backspace
            // 46 - delete
            // 127 - delete
            return (keyCode == 8 || keyCode == 46 || keyCode == 127);
        },
        isReturn: function(keyCode) {
            return (keyCode == 13);
        },
        isEscape: function(keyCode) {
            return (keyCode == 27);
        },
// not needed at this stage but left for possible later use
//        isSpacebar: function(keyCode) {
//            return keyCode == 32; // spacebar
//        },
        isTyping: function(keyCode) {
            return (keyCode > 47 && keyCode < 58)   || // numbers
                   (keyCode > 95 && keyCode < 112)  || // numpad
                   (keyCode > 64 && keyCode < 91)   || // letters
                   (keyCode > 185 && keyCode < 193) || // ;=,-./`
                   (keyCode > 218 && keyCode < 223) || // [\]'
                    keyCode == 32                   || // spacebar
                    keyCode == 13;                     // return

        }
    };

});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/UndoManager.js' */
define('wiki-edit/UndoManager', function() {

    /**
     * Simple undo/redo manager.
     * Basically the structure is like [---undoList---][CURRENT][---redoList---].
     * All operations move the current element on that "concatenated" list.
     */
    var UndoManager =  function() {
        this._undoStack = [];
        this._redoStack = [];
        this._current = undefined;
    };

    UndoManager.prototype.MAX_STACK = 1000;
    /**
     * Sets the current state of the manager
     * @param {Anything} current - state
     * @param {Boolean} preserveRedo - if set to true existing redo entries will be preserved
     */
    UndoManager.prototype.updateCurrent = function(current, preserveRedo) {
        if (current != this._current) {
            this._current = current;
            if(!preserveRedo) {
                this._redoStack.length = 0; // reset the redo stack
            }
        }
    };

    /**
     * Add val to the undo stack and make it undoable
     * @param {Anything} val - state to be made undoable
     */
    UndoManager.prototype.push = function(val) {
        this._redoStack.length = 0; // reset the redo stack
        if (!this._undoStack.length || !_.isEqual(val, this._undoStack[this._undoStack.length - 1])) {
            this._undoStack.push(val);
            this._current = val;
        }
        if (this._undoStack.length > this.MAX_STACK) {
            this._undoStack.splice(0, this._undoStack.length - this.MAX_STACK)
        }
    };

    /**
     * Undo a value. Set it to be the current element and push the current element to the redo stack
     * @return {Anything} current value after the undo operation
     */
    UndoManager.prototype.undo = function() {
        if (!this.canUndo()) { return; }
        var val;
        do {
            val = this._undoStack.pop();
        } while (_.isEqual(val, this._current) && this.canUndo());
        this._redoStack.push(this._current);
        this._current = val;
        return val;
    };

    /**
     * Redo a value. Set it to be the current element and push the current element to the undo stack
     * @return {Anything} current value after the redo operation
     */
    UndoManager.prototype.redo = function() {
        if (!this.canRedo()) { return; }
    
        var val = this._redoStack.pop();
        this._undoStack.push(this._current);
        this._current = val;
        return val;
    };

    /**
     * Check if it is possible to undo
     * @return {Boolean}
     */
    UndoManager.prototype.canUndo = function() {
        return !!this._undoStack.length;
    };

    /**
     * Check if it is possible to redo
     * @return {Boolean}
     */
    UndoManager.prototype.canRedo = function() {
        return !!this._redoStack.length;
    };

    return UndoManager;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/UndoableTextarea.js' */
define('wiki-edit/UndoableTextarea', [
        'wiki-edit/UndoManager',
        'wiki-edit/KeyTester',
        'jquery'
], function(
    UndoManager,
    KeyTester,
    $
) {

    var CUT_PASTE_MODE = "cut-paste";
    var _lastEditMode = "";

    function _setEditMode(context, newMode) {
        if (newMode === CUT_PASTE_MODE || _lastEditMode != newMode) {
            if (_lastEditMode != "newline") {
                context.recordHistoryItem();
            }
            _lastEditMode = newMode;
        }
    }

    function _manipulateHistory(context, stateName) {
        if (context.undoManager["can" + stateName[0].toUpperCase() + stateName.substring(1)]()) {
            var state = context.undoManager[stateName]();
            context.element.value = state.value;
            context.element.selectionStart = state.selectionStart;
            context.element.selectionEnd = state.selectionEnd;
        }
    }

    var UndoableTextarea = function UndoableTextarea(element) {
        this.element = element;
        this.$el = $(element);
        this.undoManager = new UndoManager();
        this.undoManager.updateCurrent(this.getValue());
        this.undoManager.push(this.getValue());

        var handleKeyboardInput = (function handleChange(e) {
            var keyCode = e.keyCode;
            var keyCodeChar = String.fromCharCode(keyCode);

            if (keyCode) {
                if (!e.ctrlKey && !e.metaKey) {
                    this.undoManager.updateCurrent(this.getValue());
                    _setEditMode(this, KeyTester.getActionType(keyCode));
                } else if ((e.ctrlKey || e.metaKey) && !e.altKey) {
                    switch (keyCodeChar.toLowerCase()) {
                        case "y":
                            this.undoManager.updateCurrent(this.getValue(), true);
                            this.redo();
                            e.preventDefault();
                            break;

                        case "z":
                            this.undoManager.updateCurrent(this.getValue(), true);
                            if (!e.shiftKey) {
                                this.undo();
                            } else {
                                this.redo();
                            }
                            e.preventDefault();
                            break;
                    }
                }
            } else {
                this.undoManager.updateCurrent(this.getValue());
                _setEditMode(this, "other");
            }
        }).bind(this);

        this.$el.on("keydown", handleKeyboardInput);

        this.$el.on("paste cut", function handleCutAndPaste() {
            this.undoManager.updateCurrent(this.getValue());
            _setEditMode(this, CUT_PASTE_MODE);
        }.bind(this));
    };

    UndoableTextarea.prototype.getValue = function() {
        return {
            value: this.element.value,
            selectionStart: this.element.selectionStart,
            selectionEnd: this.element.selectionEnd
        };
    };

    UndoableTextarea.prototype.updateCurrent = function() {
        this.undoManager.updateCurrent(this.getValue());
    };

    UndoableTextarea.prototype.recordHistoryItem = function() {
        this.undoManager.push(this.getValue());
    };

    UndoableTextarea.prototype.undo = function() {
        _setEditMode(this, "undo");
        _manipulateHistory(this, "undo");
        this.element.scrollTop = this.element.scrollHeight;
    };

    UndoableTextarea.prototype.redo = function() {
        _manipulateHistory(this, "redo");
        this.element.scrollTop = this.element.scrollHeight;
    };

    return UndoableTextarea;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/TextareaManipulator.js' */
define('wiki-edit/TextareaManipulator', function() {

    var TextareaManipulator = function(element) {
        this.el = element;
    };
    
    TextareaManipulator.prototype.NEW_LINE_TOKEN = "\n";
    
    /**
     * Gets object containing selection info
     * @returns {{position: number, start: number, end: number, length: number, text: string}}
     */
    TextareaManipulator.prototype.getSelection = function() {
        return {
            start: this.el.selectionStart,
            end: this.el.selectionEnd,
            length: this.el.selectionEnd - this.el.selectionStart,
            text: this.el.value.substring(this.el.selectionStart, this.el.selectionEnd)
        };
    };
    
    /**
     * Sets selection
     * @param start {number} index in the string, start of the selection
     * @param end {number} index in the string, end of the selection
     */
    TextareaManipulator.prototype.setSelection = function(start, end) {
        if (arguments.length === 1) {
            end = start;
        }
        this.el.selectionStart = start;
        this.el.selectionEnd = end;
    };
    
    /**
     * Replaces selected text with a parameter, if no text is selected
     * it's inserted where the cursor is
     * @param text {string} text to replace selection with
     * @param selectReplaced {Boolean} indicates if inserted text should be selected
     */
    TextareaManipulator.prototype.replaceSelectionWith = function(text, selectReplaced) {
        var start = this.el.selectionStart;
        var val = this.el.value;
        this.el.value = val.substring(0, this.el.selectionStart) + text + val.substring(this.el.selectionEnd, val.length);
    
        this.el.selectionEnd = start + text.length;
        this.el.selectionStart = (selectReplaced) ? start : this.el.selectionEnd;
    };
    
    /**
     * Wraps selection with a prefix and a suffix but only if it isn't already wrapped
     * @param prefix {string}
     * @param suffix {string}
     * @param placeholder {string} text to put between prefix and suffix if no selection was made
     */
    TextareaManipulator.prototype.wrapSelectionWith = function(prefix, suffix, placeholder) {
        if (arguments.length < 3) {
            placeholder = "";
        }
        if (arguments.length === 1) {
            suffix = prefix;
        }
        var selection = this.getSelection();
        var val = this.el.value;
    
        if (val.substring(selection.start - prefix.length, selection.start) === prefix &&
            val.substring(selection.end, selection.end + suffix.length) === suffix) {
            return;
        }
    
        var middle = val.substring(selection.start, selection.end);
        if (middle.length == 0) {
            middle = placeholder;
        }
        this.el.value = val.substring(0, selection.start) + prefix + middle + suffix + val.substring(selection.end, val.length);
        var newSelectionStart = selection.start + prefix.length;
        this.setSelection(newSelectionStart, newSelectionStart + middle.length);
    };
    
    /**
     * Finds selected lines within the textarea and returns an object containing full contents of the object
     * as an array of lines and start and end indexes of the selected lines
     * @returns {{lines: Array, start: number, end: number}}
     * @private
     */
    TextareaManipulator.prototype._getSelectedLines = function() {
        var val = this.el.value;
        var selection = this.getSelection();
        var startLine = val.substring(0, selection.start).split(this.NEW_LINE_TOKEN).length - 1; // 0-based index
        var endLine = startLine + val.substring(selection.start, selection.end).split(this.NEW_LINE_TOKEN).length - 1; // 0-based index
        var lines = val.split(this.NEW_LINE_TOKEN);
        return {
            lines: lines,
            start: startLine,
            end: endLine
        }
    };
    
    /**
     * Returns line at which cursor is (or end of the selection)
     * @returns {string}
     */
    TextareaManipulator.prototype.getLineAtCursor = function() {
        var linesSelection = this._getSelectedLines();
        return linesSelection.lines[linesSelection.end];
    };

    /**
     * Return regexp match of the fist line in the selection
     * @param pattern {regexp} prefix to check against
     * @returns {string} matched string or {undefined}
     */
    TextareaManipulator.prototype.getFirstLineMatch = function(pattern) {
        var linesSelection = this._getSelectedLines();
        var match = linesSelection.lines[linesSelection.start].match(pattern);
        if (match) {
            return match[0];
        }
    };
    
    /**
     * Checks if any of the selected lines is prefixed with a given string
     * @param prefix {string} prefix to check against
     * @returns {boolean}
     */
    TextareaManipulator.prototype.areSelectedLinesPrefixed = function(prefix) {
        var linesSelection = this._getSelectedLines();
        var currentLine;
    
        for (currentLine = linesSelection.start; currentLine <= linesSelection.end; currentLine++) {
            if (linesSelection.lines[currentLine].indexOf(prefix) == 0) {
                return true;
            }
        }
        return false;
    };
    
    /**
     * Prefixes selected lines with a given parameter. Lines already containing the prefix remain unchanged
     * @param prefix {string}
     */
    TextareaManipulator.prototype.prefixSelectedLines = function(prefix) {
        var selection = this.getSelection();
        var linesSelection = this._getSelectedLines();
        var currentLine;
        var prefixedLines = 0;
        var firstLinePrefixed = true;
        for (currentLine = linesSelection.start; currentLine <= linesSelection.end; currentLine++) {
            if (linesSelection.lines[currentLine].indexOf(prefix) == 0) {
                if (currentLine == linesSelection.start) {
                    firstLinePrefixed = false;
                }
                continue; //don't prefix lines which already have ie
            }
            prefixedLines += 1;
            linesSelection.lines[currentLine] = prefix + linesSelection.lines[currentLine];
        }
        this.el.value = linesSelection.lines.join(this.NEW_LINE_TOKEN);
    
        var prefixesLength = prefix.length * prefixedLines;
        this.setSelection(selection.start + ((firstLinePrefixed) ? prefix.length : 0), selection.end + prefixesLength);
    };
    
    /**
     * Removes prefix from selected lines
     * @param prefix {string}
     */
    TextareaManipulator.prototype.unprefixSelectedLines = function(prefix) {
        var selection = this.getSelection();
        var linesSelection = this._getSelectedLines();
        var currentLine;
        var firstLinePrefix = false;
        var prefixedLines = 0;
    
        for (currentLine = linesSelection.start; currentLine <= linesSelection.end; currentLine++) {
            if (linesSelection.lines[currentLine].indexOf(prefix) == 0) {
                prefixedLines += 1;
                linesSelection.lines[currentLine] = linesSelection.lines[currentLine].substring(prefix.length);
                if (currentLine == linesSelection.start) {
                    firstLinePrefix = true;
                }
            }
        }
        this.el.value = linesSelection.lines.join(this.NEW_LINE_TOKEN);

        var prefixesLength = prefix.length * prefixedLines;
        this.setSelection(selection.start - ((firstLinePrefix) ? prefix.length : 0), selection.end - prefixesLength);
    };

    return TextareaManipulator;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/keymaster-setup.js' */
define('wiki-edit/keymaster-setup', [
    'jquery',
    'wiki-edit/keymaster'
], function($, key) {
    return {
        init: function () {
            // Set-up library handling key bindings to correctly set scopes for wiki editor
            key.filter = function(event) {
                var element = event.target || event.srcElement || false;
                var editor;
                if (element && (' ' + element.className + ' ').indexOf(' wiki-textfield ') > -1) {
                    editor = $(element).data("wikiEditor");
                    if (editor) {
                        key.setScope(editor.id);
                        return true;
                    }
                }
                return false;
            };
        }
    }
});


;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/WikiEnabledTextarea.js' */
define('wiki-edit/WikiEnabledTextarea', [
        'wiki-edit/TextareaManipulator',
        'wiki-edit/UndoableTextarea',
        'wiki-edit/keymaster',
        'wiki-edit/keymaster-setup',
        'featureflags/feature-manager',
        'wiki-edit/SpeechRecognition',
        'jquery'
], function(TextareaManipulator, UndoableTextarea, onKey, keymasterSetup, FeatureManager, speechRecognition, $) {
    keymasterSetup.init();

    var editorCount = 0;
    // matches any combination of "*" and "#" followed by space which is any list, no matter how deeply nested
    var autocontinuingPrefixMarkupRegexp = /^[#\*]+ /;

    var WikiEnabledTextarea = function(element) {
        this.el = element;
        this.$el = $(element);
        if (this.$el.data("wikiEditor")) {
            // this will be very rare so defensive caching of this value doesn't seem to make much sense
            return this.$el.data("wikiEditor");
        }

        this.id = "wikiEdit" + editorCount;
        editorCount += 1;
        this.manipulationEngine = new TextareaManipulator(this.el);
        this.undoRedoEl = new UndoableTextarea(element);

        var wikiEditor = this;
        // on enter, continue list if possible or discontinue it if current list item is empty
        onKey("enter", wikiEditor.id, function onEnterKey(e) {
            var selection = wikiEditor.manipulationEngine.getSelection();
            var prefix = wikiEditor.manipulationEngine.getFirstLineMatch(autocontinuingPrefixMarkupRegexp);
            if (prefix) {
                if (selection.length == 0 && wikiEditor.manipulationEngine.getLineAtCursor() === prefix) {
                    wikiEditor.manipulationEngine.unprefixSelectedLines(prefix);
                } else {
                    wikiEditor.manipulationEngine.replaceSelectionWith("\n" + prefix);
                }
                e.preventDefault();
            }
        });

        this.$el.data("wikiEditor", this);
    };

    /**
     * Standard wiki markup in the form of <prefix>text<suffix> like *bold*, _italic_ or [mailto:someone@example.com].
     * Every time such markup is inserted:
     *     - if user didn't select any text, the placeholder text will be inserted and selected,
     *     - if user selected some text, this text will be wrapped with prefix and suffix.
     *
     * Each of this properties gets a function on the prototype with the same name
     * that changes value of textarea to apply the markup.
     */
    var wrapperMarkup = {
        'bold': ["*", "*", "strong text"],
        'italic': ["_", "_", "emphasized text"],
        'underline': ["+", "+", "underlined text"],
        'delete': ["-", "-", "deleted text"],
        'superscript': ["^", "^", "superscript text"],
        'subscript': ["~", "~", "subscript text"],
        'monospace': ["{{", "}}", "monospaced text"],
        'cite': ["??", "??", "citation"],
        'block-quote': ["{quote}", "{quote}", "quoted text"],
        'color': ["{color:$1}", "{color}", "colored text", "red"], // 4th parameter is a default value to replace $
        'link': ["[", "]", "link title"+"|http://example.com"],
        'link-anchor': ["[#", "]", "anchor"],
        'link-mail': ["[mailto:", "]", "mail@example.com"],
        'image': ["!", "!", "http://example.com/image.png"],
        'mention': ["@", "", "Mention someone by typing their name..."],
        'code': ["\n{code:java}\n","\n{code}\n", "// Some comments here\npublic String getFoo()\n{\n    return foo;\n}"],
        'noformat': ["\n{noformat}\n", "\n{noformat}\n", "*no* further _formatting_ is done here"],
        'panel': ["\n{panel:title="+"My title"+"}\n", "\n{panel}\n", "Some text with a title"],
        'table': ["\n||"+"Heading"+" 1||"+"Heading"+" 2||\n|", "|"+"Col"+" A2|\n", "Col"+" A1"]
    };

    for(var key in wrapperMarkup) {
        WikiEnabledTextarea.prototype[key] = (function(args, operationKey) {
            var paramsNumber = 0;
            if (args.length > 3) {
                paramsNumber = args.length - 3;
            }
            return function() {

                var prefix = args[0];
                var suffix = args[1];
                var placeholder = args[2];

                var i;
                for (i = 1; i <= paramsNumber; i++) {
                    prefix = prefix.replace("$"+i, arguments[i-1] || args[2 + i]);
                    suffix = suffix.replace("$"+i, arguments[i-1] || args[2 + i]);
                }

                var value = this.el.value;
                var selection = this.manipulationEngine.getSelection();

                this.undoRedoEl.recordHistoryItem();

                // unwrap selection if needed
                if (value.substring(selection.start - prefix.length, selection.start) === prefix &&
                    value.substring(selection.end, selection.end + suffix.length) === suffix) {

                    this.el.value = value.substring(0,selection.start - prefix.length) +
                    value.substring(selection.start, selection.end) +
                    value.substring(selection.end + suffix.length, value.length);

                    this.manipulationEngine.setSelection(selection.start - prefix.length, selection.end - prefix.length);

                    // wrap selection with markup
                } else {
                    this.manipulationEngine.wrapSelectionWith.call(this.manipulationEngine, prefix, suffix, placeholder);
                }
                this.undoRedoEl.recordHistoryItem();
                this.$el.trigger("input");
            };
        })(wrapperMarkup[key], key);
    }

    /**
     * Markup that is always a prefix for entire line, like h1. or bullet lists "* ".
     * Those prefixes are mutually exclusive, which means each line can be only prefixed with one of them
     * and applying one of them will remove any other.
     *
     * Each of this properties gets a function on the prototype with the same name
     * that changes value of textarea to apply the markup.
     */
    var excludingLinePrefixMarkup = {
        'paragraph': "",
        'bullet-list': "* ",
        'numbered-list': "# ",
        'h1': 'h1. ',
        'h2': 'h2. ',
        'h3': 'h3. ',
        'h4': 'h4. ',
        'h5': 'h5. ',
        'h6': 'h6. ',
        'paragraph-quote': 'bq. '
    };

    for(var key in excludingLinePrefixMarkup) {
        WikiEnabledTextarea.prototype[key] = (function(prefix) {
            return function() {
                this.undoRedoEl.recordHistoryItem();
                // check if line is already prefixed with one of the prefixes there
                for(var prefixToRemove in excludingLinePrefixMarkup) {
                    if (this.manipulationEngine.areSelectedLinesPrefixed(excludingLinePrefixMarkup[prefixToRemove])) {
                        this.manipulationEngine.unprefixSelectedLines(excludingLinePrefixMarkup[prefixToRemove]);
                    }
                }

                this.manipulationEngine.prefixSelectedLines.call(this.manipulationEngine, prefix);
                this.undoRedoEl.recordHistoryItem();
                this.$el.trigger("input");
            };
        })(excludingLinePrefixMarkup[key]);
    }

    /**
     * Markup that is just inserted in place of cursor or selection. The cursor is then placed at the end of inserted text.
     *
     * Each of this properties gets a function on the prototype with the same name
     * that changes value of textarea to apply the markup.
     */
    var insertMarkupWithoutSelecting = {
        'hr': "\n----\n",
        ':)': ':)',
        ':(': ':(',
        ':P': ':P',
        ':D': ':D',
        ';)': ';)',
        '(y)': '(y)',
        '(n)': '(n)',
        '(i)': '(i)',
        '(/)': '(/)',
        '(x)': '(x)',
        '(!)': '(!)',
        '(+)': '(+)',
        '(-)': '(-)',
        '(?)': '(?)',
        '(on)': '(on)',
        '(off)': '(off)',
        '(*)': '(*)',
        '(*r)': '(*r)',
        '(*g)': '(*g)',
        '(*b)': '(*b)',
        '(*y)': '(*y)',
        '(flag)': '(flag)',
        '(flagoff)': '(flagoff)',
        'image-attachment': [" !$1|thumbnail! ", "attachment-name.jpg"],
        'image-attachment-full': [" !$1! ", "attachment-name.gif"],
        'link-attachment': [" [^$1] ", "attachment-name.zip"]
    };

    for(var key in insertMarkupWithoutSelecting) {
        WikiEnabledTextarea.prototype[key] = (function(toInsert) {
            var paramsNumber = 0;
            var defaultValues;
            if (_.isArray(toInsert)) {
                paramsNumber = toInsert.length - 1;
                defaultValues = toInsert.slice(1);
                toInsert = toInsert[0];
            }
            return function() {
                var i;
                var result = toInsert;
                for (i = 1; i <= paramsNumber; i++) {
                    result = toInsert.replace("$"+i, arguments[i-1] || defaultValues[i-1]);
                }
                this.undoRedoEl.recordHistoryItem();
                this.manipulationEngine.replaceSelectionWith.call(this.manipulationEngine, result, false);
                this.undoRedoEl.recordHistoryItem();
                this.$el.trigger("input");
            };
        })(insertMarkupWithoutSelecting[key]);
    }

    WikiEnabledTextarea.prototype.speech = function()
    {
        speechRecognition.start(this);
    };

    return WikiEnabledTextarea;
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/WikiEditor.js' */
define('wiki-edit/WikiEditor', [
    'wiki-edit/WikiEnabledTextarea',
    'jquery',
    'underscore',
    'wiki-edit/JIRA',
    'wiki-edit/keymaster',
    'wiki-edit/analytics',
    'wiki-edit/WikiEditorUtil',
    'jira/util/events',
    'featureflags/feature-manager'
], function (
    WikiEnabledTextarea,
    $,
    _,
    JIRA,
    key,
    analytics,
    WikiEditorUtil,
    JIRAEvents,
    FeatureManager
) {

    var controlKey = 'Ctrl';
    if (navigator.platform.indexOf('Mac') != -1) {
        controlKey = '⌘';
    }

    // Check jira.unified.attachments.m2 dark feature toggle
    var unifiedAttachmentsM2IsEnabled = function() {
        return FeatureManager.isFeatureEnabled("jira.unified.attachments.m2");
    };

    var determineFileType = function (fileName) {
        return fileName.match(/\.(bmp|gif|jpg|jpeg|png|tiff|webp)$/i) ? 'image' : 'file';
    };

    var insertMarkup = function (wikiEditor, fileName, fileType) {
        // Gif attachments are rendered without thumbnail (eg: !lolcat.gif!) so they can animate properly
        if (unifiedAttachmentsM2IsEnabled()) {
            if (fileType == "image") {
                if (fileName.match(/\.gif$/i)) {
                    wikiEditor["image-attachment-full"](fileName);
                } else {
                    wikiEditor["image-attachment"](fileName);
                }

                analytics.trigger("operation.attachment.image");
            } else {
                wikiEditor["link-attachment"](fileName);
                analytics.trigger("operation.attachment.link");
            }
        } else {
            wikiEditor["image-attachment"](fileName);
            analytics.trigger("operation.attachment.image");
        }
    };

    return {
        create: function (element) {
            // disable plugin in IE <=8
            if (typeof element.selectionStart == "undefined") {
                return;
            }

            var $editorElement = $(element);

            if ($editorElement.data("wikiEditor")) {
                return;
            }

            // todo editor should initialize all html and events by itself
            var wikiEditor = new WikiEnabledTextarea(element);
            this.wikiEditor = wikiEditor;

            var $editorHtml = $(JIRA.Templates.Plugins.WikiEditor.renderEditor({
                editorId: wikiEditor.id,
                controlKey: controlKey,
                attachmentM2FeatureFlag: unifiedAttachmentsM2IsEnabled()
            }));
            var $editorToolbar = $editorHtml.filter(".wiki-edit-toolbar");

            // speech-capable browser?
            if ("webkitSpeechRecognition" in window) {
                $editorHtml.find(".wiki-edit-speech-item").removeClass("hidden");
            }

            $editorElement.parent().before($editorHtml);

            // detect if we are dealing with dialog
            var isDialog = $editorElement.closest(".jira-dialog").length > 0 || $editorElement.closest("form#issue-create").length > 0;
            var isCreateDialog = $editorElement.closest("#create-issue-dialog").length > 0;
            // detect if we are on view issue page
            var isViewIssue = $("#issue-content").length > 0;
            var isComment = $editorElement.closest("#addcomment").length > 0;

            var elementsWithTooltips = $editorHtml.find(".wiki-edit-operation[title], .aui-dropdown2-trigger, .wiki-edit-tooltip");
            var onWikiEditorHideEventName;
            if (isDialog) {
                onWikiEditorHideEventName = 'Dialog.beforeHide';
            } else {
                onWikiEditorHideEventName = JIRA.Events.BEFORE_INLINE_EDIT_CANCEL;
            }
            elementsWithTooltips.each(function () {
                var $this = $(this);
                var config = {
                    aria: true,
                    hideOnClick: true,
                    hoverable: false
                };
                if ($this.parent().is('li')) {
                    config.gravity = 'w';
                }
                $this.tooltip(config);
            });
            var hideAllTooltips = function (){
                elementsWithTooltips.each(function(){
                    $(this).tooltip('hide');
                });
            };
            JIRA.bind(onWikiEditorHideEventName, hideAllTooltips);

            var isDropdownEnabled = false;
            var $wikiDropdown = $editorHtml.filter(".aui-dropdown2");
            $wikiDropdown.on({
                'aui-dropdown2-show': function () {
                    isDropdownEnabled = true;

                    // focus on editorElement when dropdown opens so
                    // it can handle keyboard event (especially in dialogs)
                    $editorElement.focus();
                },
                'aui-dropdown2-hide': function () {
                    isDropdownEnabled = false;

                    hideAllTooltips();
                }
            });
            $editorElement.on('keydown', function checkEscapePressWhenDropdownIsEnabled(e) {
                if (isDropdownEnabled && e.keyCode === AJS.keyCode.ESCAPE) {
                    if (isDialog) {
                        JIRA.one("Dialog.beforeHide", function (e) {
                            e.preventDefault();
                        });
                    } else if (isViewIssue && !isComment) {
                        JIRA.one(JIRA.Events.BEFORE_INLINE_EDIT_CANCEL, function preventInlineEditCloseIfAnyDropdownIsEnabled(e) {
                            e.preventDefault();
                        });
                    }
                }
            });


            var $attachmentDropdown = $editorHtml.filter(
                ".wiki-edit-dropdown-image, " +
                ".wiki-edit-dropdown-attachment"
            );

            var $attachmentListContainer = $attachmentDropdown.find(
                ".wiki-edit-insert-image, " +
                ".wiki-edit-insert-attachment"
            );

            var $attachmentList = $attachmentDropdown.find(
                ".wiki-edit-insert-image ul, " +
                ".wiki-edit-insert-attachment ul"
            );

            // Attachment dropdown link click handler
            $attachmentList.on("click", "a", function (e) {
                e.preventDefault();

                var fileType = $(this).attr("data-attachment-type");
                if (typeof fileType === "undefined") {
                    fileType = "file";
                }

                var fileName = $(this).find('.wiki-edit-attachment-name').text();

                insertMarkup(wikiEditor, fileName, fileType);
            });

            // Build attachment links when attachment button is pressed
            $attachmentDropdown.on("aui-dropdown2-show", function () {
                var genericAttachments = [];

                // Add temporary attachments (those added before dialog is saved such as in create/edit dialog)
                if (isDialog) {
                    $(".upload-progress-bar:not(.upload-progress-bar__upload-error) span.upload-progress-bar__file-name").each(function(i,v){
                        genericAttachments.push(v);
                    });
                }

                // Add permanent attachments
                if (!isCreateDialog && isViewIssue) {
                    $("#attachment_thumbnails li.attachment-content, " +
                      "#file_attachments li.attachment-content").each(function(i,v){
                        genericAttachments.push(v);
                    });
                }

                $attachmentList.empty();
                $attachmentListContainer.addClass("hidden");

                if ((isDialog || isViewIssue) && genericAttachments.length) {
                    $attachmentListContainer.removeClass("hidden");

                    /**
                     * Contents of $genericAttachments (ie: "this") could be:
                     * - A thumbnails (gallery) view item
                     * - A list view item
                     * - Create / edit dialog entry
                     */
                    $(genericAttachments).each(function () {
                        // Handle various form of DOM structure a file name can appear in (create issue dialog,
                        // edit issue - list view, edit issue - thumbnail view
                        var fileName = $(this).is('span.upload-progress-bar__file-name') ?
                            $(this).text() :
                            $(this).find('a.attachment-title, .attachment-title a').first().text();

                        // Determine file type by 'data-attachment-type' attribute, or fall back by checking
                        // popular image file extension
                        var fileType = $(this).attr('data-attachment-type');
                        if (fileType === undefined) {
                            fileType = determineFileType(fileName);
                        }

                        // Try to figure out the attachment type icon using mime type. On thumbnail / list view mime-type
                        // can be looked up using data-downloadurl attribute. If mime-type not available let's fall back
                        // using file extension. And if that still doesn't work use aui-iconfont-file-txt.
                        var typeIcon = WikiEditorUtil.defaultAttachmentTypeIcon;
                        var dataDownloadUrl = $(this).attr('data-downloadurl');
                        if (dataDownloadUrl === undefined) {
                            dataDownloadUrl = $(this).find('[data-downloadurl]').attr('data-downloadurl');
                        }
                        if (dataDownloadUrl !== undefined && typeof dataDownloadUrl === 'string') {
                            var attrs = dataDownloadUrl.split(':');
                            if (attrs.length > 0) {
                                var mimeType = attrs[0];
                                typeIcon = WikiEditorUtil.translateMimeTypeToAttachmentTypeIcon(mimeType);
                            }
                        } else if (fileName !== undefined && typeof fileName === 'string') {
                            var matches = fileName.match(/\.(\w{1,5})$/i); // regex match exts such as .gz,.jpg,.docx,.3gp and discard the dot prefix
                            if (matches && matches.length > 1) {
                                var fileExtension = matches[1];
                                typeIcon = WikiEditorUtil.translateFileExtensionToAttachmentTypeIcon(fileExtension);
                            }
                        }

                        // If feature is disabled do not list non-image attachments
                        if (!unifiedAttachmentsM2IsEnabled() && fileType !== "image") {
                            return;
                        }

                        $attachmentList.append(
                            $(JIRA.Templates.Plugins.WikiEditor.renderListItem({
                                text: fileName,
                                attachmentType: fileType,
                                attachmentTypeIcon: typeIcon,
                                attachmentM2FeatureFlagEnabled: unifiedAttachmentsM2IsEnabled()
                            }))
                        );
                    });
                }
            });

            // dropdown2 fix so when item is selected using keyboard the container div scrolls
            // properly. This bug was fixed on AUI 5.8+ so only do this for older AUI versions
            if (WikiEditorUtil.compareVersion(AJS.version, '5.8.0') < 0) {
                $attachmentDropdown.on('aui-dropdown2-item-selected', function scrollContainerDivIfActiveItemIsOutOfView() {
                    var $active = $(this).find('.aui-dropdown2-active');
                    if (typeof $active !== 'object') {
                        return;
                    }
                    var $container = $active.closest('div');
                    if (typeof $container !== 'object') {
                        return;
                    }

                    // top/bottom limits are extreme points above/below which element will not / only be partially visible
                    var containerTopLimit = $container.offset().top;
                    var containerBottomLimit = containerTopLimit + $container.height();

                    var elementTop = $active.offset().top;
                    var elementBottom = elementTop + $active.height();

                    // Active element is (partially) above the container viewport, scroll up
                    if (elementTop < containerTopLimit) {
                        $container.scrollTop($container.scrollTop() - (containerTopLimit - elementTop));
                    }

                    // Active element is (partially) below the container viewport, scroll down
                    if (elementBottom > containerBottomLimit) {
                        $container.scrollTop($container.scrollTop() + (elementBottom - containerBottomLimit));
                    }
                });
            }

            // SUCCESS-198: Prevent attachments from being listed on links drop down
            if (!unifiedAttachmentsM2IsEnabled()) {
                var $linkDropdown = $editorHtml.filter(".wiki-edit-dropdown-link");
                var $linksList = $linkDropdown.find(".wiki-edit-insert-link");
                var $linkLinkDefault = $linkDropdown.find(".wiki-edit-operation[data-operation=link-attachment]");
                var $linkLinks = $linkDropdown.find(".wiki-edit-insert-link ul");
                $linkLinks.on("click", "a", function (e) {
                    e.preventDefault();
                    wikiEditor["link-attachment"]($(this).text());
                    analytics.trigger("operation.attachment.link");
                });

                $linkDropdown.on("aui-dropdown2-show", function () {
                    var $linkAttachments = $();
                    if (!isCreateDialog && isViewIssue) {
                        $linkAttachments = $linkAttachments.add("#attachment_thumbnails .attachment-title, #file_attachments .attachment-title a");
                    }
                    if (isDialog) {
                        $linkAttachments = $linkAttachments.add(".upload-progress-bar:not(.upload-progress-bar__upload-error) .upload-progress-bar__thumbnail + .upload-progress-bar__file-name");
                    }

                    var attachments = _.uniq($linkAttachments, false, function getValue(item) {
                        return $(item).text().trim();
                    });

                    $linkLinks.empty();
                    $linksList.addClass("hidden");
                    $linkLinkDefault.removeClass("hidden");

                    if ((isDialog || isViewIssue) && attachments.length) {
                        $linksList.removeClass("hidden");
                        $linkLinkDefault.addClass("hidden");
                        attachments.forEach(function (element) {
                            $linkLinks.append(
                                $(JIRA.Templates.Plugins.WikiEditor.renderListItem({
                                    text: $(element).text().trim(),
                                    attachmentM2FeatureFlagEnabled: unifiedAttachmentsM2IsEnabled()
                                }))
                            );
                        });
                    }
                });
            }

            $editorHtml.filter(".wiki-edit-dropdown, .wiki-edit-picker").on("mousedown", function (e) {
                e.preventDefault(); // prevent blurring textarea, needed for inline mode
            });

            // attach keyboard shortcuts
            $editorHtml.find(".wiki-edit-operation:not(.wiki-edit-operation-color)").each(function () {
                var $this = $(this);
                var handler = function (e) {
                    if (!e) {
                        return;
                    }
                    e.preventDefault && e.preventDefault();
                    $editorElement.focus();
                    wikiEditor[$this.data("operation")]();
                    analytics.trigger("operation", {
                        name: $this.data("operation"),
                        nameHash: analytics.hashCode($this.data("operation")),
                        trigger: e.type
                    });
                    analytics.trigger("operation." + $this.data("operation"), {trigger: e.type});
                };

                // todo event delegation, fool!
                $this.click(handler);
                if ($this.data("shortcut")) {
                    // todo shortcuts should be binded once, globally
                    key($this.data("shortcut"), wikiEditor.id, handler);
                }
            });

            // text color
            $editorHtml.find(".wiki-edit-operation-color").each(function () {
                var $this = $(this);
                var handler = function (e) {
                    if (!e) {
                        return;
                    }
                    e.preventDefault && e.preventDefault();
                    $editorElement.focus();
                    wikiEditor[$this.data("operation")]($this.data("color"));
                    analytics.trigger("operation", {
                        name: $this.data("operation"),
                        nameHash: analytics.hashCode($this.data("operation")),
                        trigger: e.type
                    });
                    analytics.trigger("operation." + $this.data("operation"), {trigger: e.type});
                };

                // todo event delegation, fool!
                $this.click(handler);
                if ($this.data("shortcut")) {
                    // todo shortcuts should be binded once, globally
                    key($this.data("shortcut"), wikiEditor.id, handler);
                }

            });

            var defaultColor = (window.localStorage.getItem("jira.wikieditor.last.color")) ? window.localStorage.getItem("jira.wikieditor.last.color") : "red";
            var $colorOperation = $editorHtml.find(".wiki-edit-operation-color");
            $colorOperation.data("color", defaultColor);
            var $colorIndicator = $editorToolbar.find(".wiki-edit-color-indicator");
            $colorIndicator.css("background-color", defaultColor);

            $editorHtml.filter(".wiki-edit-color-picker").on("click", "a", function (e) {
                e.preventDefault();
                $editorElement.focus();
                var color = $(this).data("color");
                wikiEditor.color(color);
                analytics.trigger("operation", {name: "color"});
                analytics.trigger("operation.color.picked", {color: color});
                $colorOperation.data("color", color);
                $colorIndicator.css("background-color", color);
                window.localStorage.setItem("jira.wikieditor.last.color", color);
            });

            var $visibilityToggle = $editorHtml.find('.wiki-edit-visible-toggle');
            var hideToolbar = (localStorage.getItem("jira.wikieditor.visibility" + element.name + '.' + element.id) === "true") ? true : false;
            if (hideToolbar) {
                $visibilityToggle.addClass("active");
                $editorToolbar.addClass("wiki-edit-toolbar-compact");
            }

            function toggleEditor(e) {
                e.preventDefault();
                e.stopPropagation();
                hideToolbar = !hideToolbar;
                $visibilityToggle.toggleClass("active", hideToolbar);
                $editorToolbar.toggleClass("wiki-edit-toolbar-compact", hideToolbar);
                localStorage.setItem("jira.wikieditor.visibility" + element.name + '.' + element.id, (hideToolbar) ? "true" : "false");
                analytics.trigger((hideToolbar) ? "hide" : "show")
            }

            $visibilityToggle.on("click", toggleEditor);
            $editorToolbar.parent().on("click", ".wiki-edit-toolbar-compact", toggleEditor);

            $(document).on("showWikiPreview", function (e, el) {
                if ($(el).find(element).length) {
                    $editorToolbar.addClass("hidden");
                }
            });
            $(document).on("showWikiInput", function (e, el) {
                if ($(el).find(element).length) {
                    $editorToolbar.removeClass("hidden");
                }
            });
        },

        initBrowseLink: function (element) {
            var wikiEditor = this.wikiEditor;

            if (unifiedAttachmentsM2IsEnabled()) {
                var $editorElement = $(element);

                var $browseButton = $editorElement.parent().siblings().find(".wiki-attachment-browse");
                var canAttach = $("#dnd-metadata-webpanel").data("can-attach");

                var isDialog = $editorElement.closest(".jira-dialog").length > 0 || $editorElement.closest("form#issue-create").length > 0;

                if (isDialog) {
                    // These are the dialogs we want to show the browse link in.
                    // The dialogs have an attachment dropzone that we can use to simulate a drop.
                    var supportedDialogSelectors = ['#create-issue-dialog:visible', '#create-subtask-dialog:visible', '#edit-issue-dialog:visible', '#create-linked-issue-dialog:visible'];
                    var supportedDialog = $(supportedDialogSelectors.join(","));
                    var isSupportedDialog = supportedDialog.length > 0;
                    canAttach = $(".jira-dialog fieldset span:contains('Attachment')").length > 0;

                    // If we did not find a dialog that we know can receive files, we search
                    // for other dialogs that explicitly state that they can receive files.
                    if (!isSupportedDialog) {
                        supportedDialog = $editorElement.closest(".dialog-can-receive-files:visible");
                        isSupportedDialog = supportedDialog.length > 0;
                        // If we do find such a dialog, we consume its can-attach (boolean) data attribute.
                        // If the dialog does not have that attribute, canAttach will be undefined and the
                        // browse link will not be shown.
                        canAttach = supportedDialog.data("can-attach");
                    }
                    var insertMarkupInDialog = supportedDialog.data("insert-markup-on-browse");
                }

                var $attachmentsDropdown = $editorElement.parent().siblings().find(".wiki-edit-attachment-picker-trigger");

                if (canAttach && (isDialog ? isSupportedDialog : true)) {
                    $browseButton.closest("div").removeClass("hidden");
                    $attachmentsDropdown.removeClass("hidden");
                    if (!$browseButton.data("initialised")) {
                        $browseButton.on('click', function (e) {
                            e.preventDefault();

                            var $tempFileInput = $("<input type=\"file\" multiple />");
                            $tempFileInput.change(function (event) {
                                var files = $tempFileInput[0].files;
                                if (isDialog) {
                                    var dropEvent = $.Event("drop");
                                    dropEvent.dataTransfer = {files: files};
                                    supportedDialog.find('.issue-drop-zone__target').trigger(dropEvent);
                                }
                                else {
                                    // This event comes from the JIRA Drag and Drop Plugin.
                                    JIRAEvents.trigger("attachmentForPageReceived", {
                                        files: files,
                                        isWikiTextfieldFocused: true
                                    });
                                }
                                if (isDialog ? insertMarkupInDialog : true) {
                                    for (var i = 0; i < files.length; i++) {
                                        var fileName = files[i].name;
                                        insertMarkup(wikiEditor, fileName, determineFileType(fileName));
                                    }
                                }
                            });
                            $tempFileInput.click();

                            analytics.trigger("attachment.dropdown.button.clicked.browse");
                        });
                        $browseButton.data("initialised", true);
                    }
                }
                else {
                    $browseButton.closest("div").addClass("hidden");

                    // Here we know the browse button will be hidden. If we will
                    // not show an attachments list, the attachment dropdown will be empty
                    // so we want to hide the attachment dropdown altogether.
                    var $genericAttachments = $("#attachment_thumbnails li.attachment-content, #file_attachments li.attachment-content");
                    var currentIssueHasAttachments = $genericAttachments.length > 0;

                    // Create issue/Create subtask dialogs are special because even if the current issue has attachments,
                    // we are not supposed to show these attachments in those two dialogs (because attachments are per issue).
                    var isCreateIssueOrSubtaskDialog = isDialog && isSupportedDialog &&
                        (supportedDialog.attr("id") === "create-issue-dialog" || supportedDialog.attr("id") === "create-subtask-dialog");

                    var willShowAttachmentsList = currentIssueHasAttachments &&  !isCreateIssueOrSubtaskDialog;

                    if (!willShowAttachmentsList) {
                        $attachmentsDropdown.addClass("hidden");
                    }
                }
            }
        }
    }
});

;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/WikiEditorUtil.js' */
define('wiki-edit/WikiEditorUtil', [
    'jquery',
    'underscore'
], function (
    $,
    _
) {

    var _defaultAttachmentTypeIcon = {
        cssClass : 'aui-iconfont-devtools-file',
        title : ''
    };

    var _fileExtToAttachmentTypeIconCssClass = {
        'pdf'   : 'aui-iconfont-file-pdf',

        'gif'   : 'aui-iconfont-image',
        'png'   : 'aui-iconfont-image',
        'jpeg'  : 'aui-iconfont-image',
        'jpg'   : 'aui-iconfont-image',

        'xml'   : 'aui-iconfont-file-code',
        'html'  : 'aui-iconfont-file-code',
        'htm'   : 'aui-iconfont-file-code',
        'txt'   : 'aui-iconfont-file-txt',

        'zip'   : 'aui-iconfont-file-zip',
        'gz'    : 'aui-iconfont-file-zip',
        'tar'   : 'aui-iconfont-file-zip',
        'rar'   : 'aui-iconfont-file-zip',
        '7z'    : 'aui-iconfont-file-zip',

        'doc'   : 'aui-iconfont-file-doc',
        'docx'  : 'aui-iconfont-file-doc',
        'xls'   : 'aui-iconfont-file-xls',
        'xlsx'  : 'aui-iconfont-file-xls',
        'xlsm'  : 'aui-iconfont-file-xls',
        'ppt'   : 'aui-iconfont-file-ppt',
        'pptx'  : 'aui-iconfont-file-ppt',

        'java'  : 'aui-iconfont-file-code',
        'c'     : 'aui-iconfont-file-code',
        'h'     : 'aui-iconfont-file-code',
        'cpp'   : 'aui-iconfont-file-code',
        'hpp'   : 'aui-iconfont-file-code',
        'scala' : 'aui-iconfont-file-code',
        'php'   : 'aui-iconfont-file-code',
        'css'   : 'aui-iconfont-file-code',
        'less'  : 'aui-iconfont-file-code',
        'soy'   : 'aui-iconfont-file-code',
        'js'    : 'aui-iconfont-file-code',
        'jar'   : 'aui-iconfont-file-zip',
        'war'   : 'aui-iconfont-file-zip',
        'obr'   : 'aui-iconfont-file-zip'
    };

    var _fileExtToAttachmentTypeIconTitle = {
        'pdf'   : "PDF File",

        'gif'   : "GIF File",
        'png'   : "PNG File",
        'jpeg'  : "JPEG File",
        'jpg'   : "JPEG File",

        'xml'   : "XML File",
        'html'  : "HTML File",
        'htm'   : "HTML File",
        'txt'   : "Text File",

        'zip'   : "Zip Archive",
        'gz'    : "GZip Archive",

        'doc'   : "Microsoft Word",
        'docx'  : "Microsoft Word",
        'xls'   : "Microsoft Excel",
        'xlsx'  : "Microsoft Excel",
        'xlsm'  : "Microsoft Excel",
        'ppt'   : "Microsoft PowerPoint",
        'pptx'  : "Microsoft PowerPoint",

        'java'  : "Java Source File",
        'jar'   : "Java Archive File",
        'war'   : "Java Archive File"
    };

    return {

        /**
         * Default attachment type icon, used as a fallback if type couldn't be determined
         */
        defaultAttachmentTypeIcon : _defaultAttachmentTypeIcon,

        /**
         * Used by attachments dropdown to determine what icon to put to the left of attachment name
         * Icon is decided by attachment mime type
         *
         * @param {string} mimeType attachment mime type (eg: image/jpg)
         *
         * @returns Object with cssClass and title attributes.
         *  If translation fails cssClass is aui-iconfont-devtools-file and title is empty string.
         */
        translateMimeTypeToAttachmentTypeIcon : function (mimeType) {
            return {
              cssClass : JIRA.Templates.ViewIssue.matchFileClass( { mimetype : mimeType } ),
              title : JIRA.Templates.ViewIssue.matchFileIconAlt( { mimetype : mimeType } )
            };
        },

        /**
         * Used by attachments dropdown to determine what icon to put to the left of attachment name
         * Icon is decided by file extension
         *
         * @param extension extension name, with or without dot prefix (eg: .pdf, doc)
         *
         * @returns Object with cssClass and title attributes.
         *  If translation fails cssClass is aui-iconfont-devtools-file and title is empty string.
         */
        translateFileExtensionToAttachmentTypeIcon : function (extension) {
            var result = _.clone(_defaultAttachmentTypeIcon);

            if (typeof extension !== 'string') {
                return result;
            }

            extension = extension.toLowerCase();
            extension = extension.replace(/^\.+/, '');

            var cssClass = _fileExtToAttachmentTypeIconCssClass[extension];
            if (typeof cssClass === 'string') {
                result.cssClass = cssClass;
            }

            var title = _fileExtToAttachmentTypeIconTitle[extension];
            if (typeof title === 'string') {
                result.title = title;
            }

            return result;
        },

        /**
         * Perform version number comparison. Returns a number less than 0 if version A is lower than B, greater than 0
         * if A is higher than B, 0 if both equals.
         *
         * Example:
         * - compareVersion('5.7.10', '5.8.0') // returns -1
         * - compareVersion('5.8.0', '5.8.0') // returns 0
         * - compareVersion('5.8.1', '5.8.0') // returns 1
         * - compareVersion('5.10.0', '5.8.0') // returns 1
         * - compareVersion('5.8', '5.8.0') // returns -1
         * - compareVersion('5.8', '5.8.0') // returns -1
         * - compareVersion('5.0a', '5.0') // returns NaN
         *
         * @param verA (string) version number (eg: 5.7.10)
         * @param verB (string) version number (eg: 5.7.10)
         *
         * @return (number) A number less than 0 if version A is lower than B, greater than 0 if A is higher than B,
         * 0 if both equals, NaN if version comparison can't be performed
         */
        compareVersion : function (verA, verB) {
            var partsA = verA.split('.');
            var partsB = verB.split('.');
            var result = NaN;

            $(partsA).each(function (i, e) {
                if (i >= partsB.length) {
                    return false;
                }
                var partA = Number(e);
                var partB = Number(partsB[i]);
                if (isNaN(partA) || isNaN(partB)) {
                    //noinspection JSUnusedAssignment
                    result = NaN;
                    return false;
                }
                if (partA < partB) {
                    //noinspection JSUnusedAssignment
                    result = -1;
                    return false;
                } else if (partA > partB) {
                    //noinspection JSUnusedAssignment
                    result = 1;
                    return false;
                }
                result = 0;
            });

            if (result == 0 && partsA.length != partsB.length) {
                return (partsA.length > partsB.length) ? 1 : -1;
            }

            return result;
        }
    }
});;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources', location = '/js/SpeechRecognition.js' */
define('wiki-edit/SpeechRecognition', [
    'jquery',
    'aui/flag'
], function ($, auiFlag)
{
    function getIsFinal(results)
    {
        return results && results[0] && results[0].isFinal;
    }
    function getTranscript(results)
    {
        return results && results[0] && results[0][0] && results[0][0].transcript || '';
    }

    return {
        start: function (textareaInstance)
        {
            var self = this;
            var recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = true;
            // if lang is converted into something that Chrome does not understand, it defaults to the system language
            recognition.lang = AJS.Meta.get("user-locale").replace("_", "-");
            // stops any recognition in progress to start a new session
            recognition.stop();
            recognition.start();

            recognition.onstart = function()
            {
                self.showTimedMessage({title: "You can start speaking now :)"}, "info", 10);
                self.selectionStart = textareaInstance.manipulationEngine.getSelection().start;
            }
            recognition.onresult = function(event)
            {
                self.dismissCurrentMessage();
                var isFinal = getIsFinal(event.results);
                var speechResult = getTranscript(event.results);
                // capitalise first letter
                speechResult = speechResult.charAt(0).toUpperCase() + speechResult.slice(1);

                if (isFinal)
                {
                    textareaInstance.undoRedoEl.recordHistoryItem();
                }
                textareaInstance.manipulationEngine.replaceSelectionWith.call(textareaInstance.manipulationEngine, speechResult, false);
                var selectionEnd = self.selectionStart + speechResult.length;
                if (isFinal)
                {
                    // clears the selection
                    textareaInstance.manipulationEngine.setSelection(selectionEnd);
                    textareaInstance.undoRedoEl.recordHistoryItem();
                    textareaInstance.$el.trigger("input");
                    recognition.stop();
                }
                else
                {
                    textareaInstance.manipulationEngine.setSelection(self.selectionStart, selectionEnd);
                }
            }
            recognition.onerror = function(event)
            {
                recognition.stop();

                // this is a generic error message in case no specific error is raised
                var message = {
                    title: "Sorry, I can\'t hear you :(",
                    body: ''
                }
                switch (event.error)
                {
                    case "not-allowed":
                        message.title = "Speech recognition is currently disabled";
                        message.body = "Click the camera icon in the browser\'s address bar to enable it.";
                        break;
                    case "network":
                        message.title = "No internet connection";
                        message.body = "You need a working internet connection to use speech recognition.";
                        break;
                    case "no-speech":
                        message.title = "Sorry, I couldn\'t hear anything :(";
                        message.body = "Is your microphone working and unmuted?";
                        break;
                    // this only happens by user interaction, so there is no need to display a message
                    case "aborted":
                        return;
                }
                self.showTimedMessage(message, "warning", 5);
            }
            recognition.onend = function()
            {
                recognition.stop();
            }
        },

        /**
         * Shows a specific auiFlag and automatically hides it after the specified timeout
         *
         * @param message
         * @param flagType
         * @param duration in seconds
         */
        showTimedMessage: function(message, flagType, duration)
        {
            this.dismissCurrentMessage();
            this.speakFlag = auiFlag({
                type: flagType,
                title: message.title,
                body: message.body,
                persistent: true
            });

            clearTimeout(this.flagTimer);
            this.flagTimer = setTimeout(this.dismissCurrentMessage.bind(this), duration * 1000);
        },
        dismissCurrentMessage: function()
        {
            if (this.speakFlag && this.speakFlag.close)
            {
                this.speakFlag.close();
                this.speakFlag = null;
            }
        }
    }
})
;;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:skate', location = '/js/lib/skate.js' */
define('wiki-edit/skate', ['jira/skate'], function(skate) {
    return skate;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.jira-wiki-editor:wiki-editor-resources-init', location = '/js/wiki-editor-init.js' */
require([
    'wiki-edit/WikiEditor',
    'wiki-edit/JIRA',
    'wiki-edit/skate',
    'jquery',
    'underscore'
], function(WikiEditor, JIRA, skate, $, _) {

    function createWikiTextfield(element) {
        var el = (this instanceof Element) ? this : element;
        var create = function(elem) {
            WikiEditor.create(elem);
            WikiEditor.initBrowseLink(elem);
            elem.wikiEnabled = true;
        };

        if (el.wikiEnabled === false) {
            if ($(el).is(':hidden')) {
                _.defer(create, el);
            } else {
                create(el);
            }
        }
    }

    function wikiEditorDefinition() {
        return {
            type: skate.type.CLASSNAME,
            attached: createWikiTextfield,
            prototype: {
                wikiEnabled: false
            }
        };
    }

    skate('wiki-textfield', wikiEditorDefinition());

    skate('wiki-enabled-textfield', wikiEditorDefinition());

    $(function() {
        if ($("#gh").length > 0) {
            JIRA.Dialogs.comment.options.width = 810;
            JIRA.Dialogs.assignIssue.options.width = 810;
            JIRA.Dialogs.attachFile.options.width = 810;
            JIRA.Dialogs.logWork.options.width = 810;
            JIRA.Dialogs.logWork.options.width = 810;
        }
    });

});
;